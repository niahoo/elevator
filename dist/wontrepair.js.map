{"version":3,"sources":["webpack:///webpack/bootstrap aa605966bdace68a332d","webpack:///./app/js/main.js","webpack:///./app/js/conf.js","webpack:///./app/js/elevator.js","webpack:///./app/js/graphics.js","webpack:///./app/js/model/Storey.js","webpack:///./~/extend/index.js","webpack:///./app/js/tpl/app.svg","webpack:///./~/ractive/ractive.js","webpack:///./app/js/cabinfsm.js","webpack:///./~/lodash/lang/isNative.js","webpack:///./~/lodash/internal/isLength.js","webpack:///./~/lodash/lang/isObject.js","webpack:///./~/lodash/internal/isObjectLike.js","webpack:///./~/lodash/lang/isArray.js","webpack:///./~/lodash/object/keys.js","webpack:///./~/lodash/internal/toObject.js","webpack:///./~/lodash/utility/constant.js","webpack:///(webpack)/~/node-libs-browser/~/timers-browserify/main.js","webpack:///./~/lodash/internal/baseClone.js","webpack:///./~/lodash/internal/isArrayLike.js","webpack:///./~/lodash/internal/isIndex.js","webpack:///./~/lodash/lang/isArguments.js","webpack:///./~/lodash/support.js","webpack:///./app/js/fsm.js","webpack:///./~/base-class-extend/lib/base-class-extend.js","webpack:///./~/lodash/internal/arrayCopy.js","webpack:///./~/lodash/internal/arrayEach.js","webpack:///./~/lodash/internal/baseAssign.js","webpack:///./~/lodash/internal/baseCopy.js","webpack:///./~/lodash/internal/baseFor.js","webpack:///./~/lodash/internal/baseForOwn.js","webpack:///./~/lodash/internal/baseIsEqual.js","webpack:///./~/lodash/internal/baseIsEqualDeep.js","webpack:///./~/lodash/internal/baseIsMatch.js","webpack:///./~/lodash/internal/baseMatches.js","webpack:///./~/lodash/internal/baseProperty.js","webpack:///./~/lodash/internal/baseToString.js","webpack:///./~/lodash/internal/bindCallback.js","webpack:///./~/lodash/internal/bufferClone.js","webpack:///./~/lodash/internal/createBaseFor.js","webpack:///./~/lodash/internal/equalArrays.js","webpack:///./~/lodash/internal/equalByTag.js","webpack:///./~/lodash/internal/equalObjects.js","webpack:///./~/lodash/internal/getLength.js","webpack:///./~/lodash/internal/getSymbols.js","webpack:///./~/lodash/internal/initCloneArray.js","webpack:///./~/lodash/internal/initCloneByTag.js","webpack:///./~/lodash/internal/initCloneObject.js","webpack:///./~/lodash/internal/isStrictComparable.js","webpack:///./~/lodash/internal/shimKeys.js","webpack:///./~/lodash/lang/cloneDeep.js","webpack:///./~/lodash/lang/isFinite.js","webpack:///./~/lodash/lang/isTypedArray.js","webpack:///./~/lodash/object/keysIn.js","webpack:///./~/lodash/string/escapeRegExp.js","webpack:///./~/lodash/utility/identity.js","webpack:///./~/lodash/utility/matches.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///./app/js/destination-selector.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;ACrCA,KAAI,QAAQ,GAAG,mBAAO,CAAC,CAAU,CAAC;AAClC,KAAI,QAAQ,GAAG,mBAAO,CAAC,CAAU,CAAC;AAClC,KAAI,MAAM,GAAG,mBAAO,CAAC,CAAc,CAAC;AACpC,KAAI,IAAI,GAAG,mBAAO,CAAC,CAAM,CAAC;;AAE1B,QAAO,CAAC,GAAG,CAAC,yBAAyB,CAAC;;AAEtC,OAAM,CAAC,UAAU,GAAG,UAAS,IAAI,EAAE;;AAElC,MAAI,OAAO,GAAG,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC;AAC3D,QAAM,CAAC,GAAG,GAAG,IAAI,QAAQ,CAAC,OAAO,CAAC;;;;;;AAMlC,SAAO,CAAC,GAAG,CAAC,KAAK,EAAC,GAAG,CAAC;AACtB,YAAU,CAAC,YAAU;AACpB,MAAG,CAAC,aAAa,CAAC,CAAC,CAAC;GACpB,EAAE,GAAG,CAAC;EACP;;AAED,QAAO,CAAC,GAAG,CAAC,sBAAsB,CAAC,C;;;;;;;;ACtBnC,KAAI,IAAI,GAAG;AACV,cAAY,EAAE,GAAG;AACjB,aAAW,EAAE,GAAG;AAChB,eAAa,EAAE,EAAE;AACjB,oBAAkB,EAAE,CAAC;AACrB,wBAAsB,EAAE,CAAC;AACzB,WAAS,EAAE,EAAE;AACb,uBAAqB,EAAE,CAAC;AACxB,WAAS,EAAE,IAAI;AACf,UAAQ,EAAE,GAAG;AACb,gBAAc,EAAC,EAAE;AACjB,eAAa,EAAC,GAAG;AACjB,uBAAqB,EAAC,EAAE;AAAA,EACxB;;AAED,KAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,qBAAqB;;AAE5G,OAAM,CAAC,OAAO,GAAG,IAAI,C;;;;;;;;AClBrB,KAAI,QAAQ,GAAG,mBAAO,CAAC,CAAU,CAAC;AAClC,KAAI,MAAM,GAAG,mBAAO,CAAC,CAAQ,CAAC;AAC9B,KAAI,mBAAmB,GAAG,mBAAO,CAAC,EAAsB,CAAC;;AAEzD,UAAS,eAAe,CAAE,MAAM,EAAE;AACjC,MAAI,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,EAAE,EAAC,CAAC,IAAI,CAAC,CAAC;AACtC,MAAI,CAAC,KAAK,GAAG,MAAM,CAAC,EAAE,EAAC,eAAe,CAAC,YAAY,CAAC;AACpD,SAAO,CAAC,KAAK,CAAC,+GAA+G,CAAC;;AAE9H,SAAO,CAAC,KAAK,CAAC,sFAAsF,CAAC;EACrG;;AAED,gBAAe,CAAC,SAAS,CAAC,cAAc,GAAG,UAAS,KAAK,EAAE;AAC1D,SAAO,CAAC,GAAG,CAAC,gBAAgB,EAAE,KAAK,CAAC;AACpC,SAAO,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;AAClC,SAAO,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC;AACpC,SAAO,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,KAAK,CAAC;EACtC;;AAED,gBAAe,CAAC,SAAS,CAAC,aAAa,GAAG,UAAS,KAAK,EAAE;AACzD,SAAO,CAAC,GAAG,CAAC,eAAe,EAAC,KAAK,CAAC;AAClC,MAAI,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,IAAI;AACpC,MAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC;EACzB;;AAED,gBAAe,CAAC,SAAS,CAAC,eAAe,GAAG,UAAS,KAAK,EAAE;AAC3D,SAAO,CAAC,GAAG,CAAC,iBAAiB,EAAC,KAAK,CAAC;AACpC,MAAI,CAAC,KAAK,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,IAAI;AACtC,MAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC;EACzB;;AAED,gBAAe,CAAC,SAAS,CAAC,gBAAgB,GAAG,UAAS,KAAK,EAAE;AAC5D,SAAO,CAAC,GAAG,CAAC,kBAAkB,EAAC,KAAK,CAAC;AACrC,MAAI,CAAC,KAAK,CAAC,cAAc,CAAC,KAAK,CAAC,GAAG,IAAI;AACvC,MAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC;EACzB;;AAED,gBAAe,CAAC,SAAS,CAAC,kBAAkB,GAAG,YAAW;;;;AAIzD,MAAI,QAAQ,GAAG,mBAAmB,CAAC,aAAa,CAAC;AAChD,cAAW,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC;AAC5D,gBAAa,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC;AAChE,iBAAc,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC;AAClE,eAAY,EAAE,IAAI,CAAC,KAAK,CAAC,YAAY;AACrC,mBAAgB,EAAE,IAAI,CAAC,KAAK,CAAC,gBAAgB;GAC7C,CAAC;AACF,SAAO,QAAQ,CAAC,OAAO,EAAE;EACzB;;AAED,gBAAe,CAAC,SAAS,GAAG,EAAC,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAC;;AAEpD,gBAAe,CAAC,YAAY,GAAG;AAC9B,kBAAgB,EAAE,eAAe,CAAC,SAAS,CAAC,EAAE;AAC9C,cAAY,EAAE,CAAC;;;;;;;;AAQf,aAAW,EAAE,EAAE;AACf,eAAa,EAAE,EAAE;;;;;AAKjB,gBAAc,EAAE,EAAE;;;AAGlB,OAAK,EAAE,SAAS;;;AAIhB,QAAM,EAAE,EAAE,EACV;;AAGD,OAAM,CAAC,OAAO,GAAG,eAAe;;;;;;;;;AChFhC,KAAI,OAAO,GAAG,mBAAO,CAAC,CAAS,CAAC;AAChC,KAAI,IAAI,GAAG,mBAAO,CAAC,CAAM,CAAC;AAC1B,KAAI,cAAc,GAAG,mBAAO,CAAC,CAAa,CAAC;;;;;;;;AAQ3C,UAAS,UAAU,CAAC,KAAK,EAAE,GAAG,EAAE;AAC/B,MAAI,QAAQ,GAAG,GAAG,GAAG,CAAC;AACtB,MAAI,EAAE,GAAG,QAAQ,GAAG,KAAK;AACzB,MAAI,CAAC,GAAG,IAAI,CAAC,qBAAqB,GAAI,EAAE,GAAG,IAAI,CAAC,YAAa,GAAI,EAAE,GAAG,IAAI,CAAC,aAAc;AACzF,SAAO,CAAC;EACR;;;;;;;;AAQD,UAAS,YAAY,CAAC,KAAK,EAAE,GAAG,EAAE;AACjC,SAAO,CAAC,GAAG,CAAC,cAAc,EAAE,KAAK,EAAE,GAAG,CAAC;AACvC,MAAI,CAAC,GAAG,UAAU,CAAC,KAAK,EAAE,GAAG,CAAC,IAAI,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,cAAc,CAAC;AAC1E,SAAO,CAAC;EACR;;AAID,UAAS,WAAW,CAAE,QAAQ,EAAE;;;AAG/B,MAAI,IAAI,GAAG,QAAQ,CAAC,GAAG,CAAC,UAAS,CAAC,EAAC;AAClC,UAAO;AACN,KAAC,EAAE,CAAC,CAAC,QAAQ;AACb,WAAO,EAAE,CAAC;AACV,KAAC,EAAE,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,qBAAqB;AAC9C,KAAC,EAAE,UAAU,CAAC,CAAC,CAAC,QAAQ,EAAE,QAAQ,CAAC,MAAM,CAAC;AAC1C,SAAK,EAAE,IAAI,CAAC,WAAW;AACvB,UAAM,EAAE,IAAI,CAAC,YAAY,EACzB;GACD,CAAC;AACF,SAAO,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC;AAC5B,SAAO,IAAI;EACX;;AAED,UAAS,cAAc,CAAC,IAAI,EAAE;AAC7B,SAAO,CAAC,GAAG,CAAC,gBAAgB,EAAC,IAAI,CAAC;AAClC,MAAI,GAAG,GAAG,IAAI,CAAC,QAAQ;AACvB,MAAI,YAAY,GAAG,GAAG,CAAC,QAAQ,EAAE;AACjC,MAAI,OAAO,GAAG,IAAI,OAAO,CAAC;AACzB,KAAE,EAAE,IAAI,CAAC,OAAO;AAChB,WAAQ,EAAE,cAAc;AACxB,OAAI,EAAE;AACL,WAAO,EAAE,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC;AAClC,OAAG,EAAE;AACJ,WAAM,EAAE,IAAI,CAAC,cAAc;AAC3B,UAAK,EAAE,IAAI,CAAC,aAAa;AACzB,MAAC,EAAE,IAAI,CAAC,SAAS;AACjB,QAAG,EAAE,YAAY,CAAC,aAAa;AAC/B,MAAC,EAAE,YAAY,CAAC,YAAY,CAAC,aAAa,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;KAChE;IACD;AACD,aAAU,EAAE,sBAAW;AAAE,WAAO,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,MAAM;IAAE;AAC/D,aAAU,EAAE,sBAAW;AAAE,WAAO,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC;IAAE,EACxD,CAAC,CAAC;;;;AAIH,KAAG,CAAC,EAAE,CAAC,GAAG,EAAC,YAAU,EAGpB,CAAC;AACF,KAAG,CAAC,EAAE,CAAC,YAAY,EAAC,YAAU;;AAE7B,UAAO,CAAC,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,KAAK,CAAC;GAClC,CAAC;;AAEF,KAAG,CAAC,EAAE,CAAC,QAAQ,EAAE,UAAS,WAAW,EAAE,QAAQ,EAAC;AAC/C,OAAI,IAAI,GAAG,YAAY,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;AACzD,UAAO,OAAO,CAAC,OAAO,CACrB,EAAC,OAAO,EAAE,IAAI,EAAE,SAAS,EAAC,WAAW,EAAC,EACtC,EAAC,QAAQ,EAAC,QAAQ,EAAC,MAAM,EAAC,WAAW,EAAC,CACtC;GACD,CAAC;;AAEF,SAAO,OAAO;EACd;;AAED,QAAO,CAAC,cAAc,GAAG,cAAc;;;;;;;;;;;;;;;ACvFvC,UAAS,MAAM,CAAC,QAAQ,EAAE,QAAQ,EAAE;AACnC,MAAI,CAAC,QAAQ,GAAG,QAAQ;AACxB,MAAI,CAAC,QAAQ,GAAG,QAAQ;EACxB;;AAED,OAAM,CAAC,OAAO,GAAG,MAAM,C;;;;;;ACTvB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;;AAEA,QAAO,YAAY;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACvFA,iBAAgB,YAAY,sBAAsB,uBAAuB,kBAAkB,sBAAsB,kBAAkB,qBAAqB,yBAAyB,OAAO,qBAAqB,kBAAkB,qBAAqB,yBAAyB,OAAO,WAAW,uBAAuB,oBAAoB,OAAO,GAAG,MAAM,mBAAmB,+BAA+B,WAAW,mBAAmB,eAAe,OAAO,YAAY,sBAAsB,UAAU,kBAAkB,aAAa,mBAAmB,QAAQ,cAAc,QAAQ,cAAc,GAAG,gBAAgB,EAAE,MAAM,sBAAsB,0BAA0B,sBAAsB,aAAa,uBAAuB,QAAQ,kBAAkB,QAAQ,kBAAkB,GAAG,EAAE,EAAE,G;;;;;;ACA1wB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC,oBAAoB;;AAErB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,eAAc,6BAA6B;;AAE3C;AACA;AACA;AACA;AACA,oBAAmB,MAAM;AACzB,2BAA0B,OAAO;AACjC;;AAEA;AACA,YAAW;AACX,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,4BAA2B,WAAW,WAAW;AACjD;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,4BAA2B,WAAW,WAAW;;AAEjD;AACA,mEAAkE,WAAW;AAC7E;;AAEA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA8B,GAAG,QAAQ,WAAW,EAAE;AACtD,KAAI;AACJ;AACA;AACA;;AAEA;AACA,oDAAmD,QAAQ,WAAW,EAAE;AACxE;;AAEA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;;AAEA;AACA,yFAAwF,aAAa;AACrG;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yFAAwF,aAAa;AACrG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA,sGAAqG,qBAAqB,2BAA2B,qBAAqB,2BAA2B,qBAAqB,6BAA6B,qBAAqB,4BAA4B;AACxS,mQAAkQ,uHAAuH,eAAe,EAAE;;AAE1Y;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2FAA0F,2BAA2B;AACrH;;AAEA;AACA;AACA;AACA,KAAI;AACJ,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA,sFAAqF,aAAa;AAClG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sFAAqF,aAAa;AAClG;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sFAAqF,aAAa;AAClG;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,iBAAiB;AAClC;AACA;;AAEA,kBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,gBAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,gBAAe,qDAAqD;AACpE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qCAAoC,OAAO;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAkB;AAClB,qBAAoB;AACpB;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,WAAU;AACV,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB;AACnB,MAAK;AACL,gBAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAQ,GAAG;AACX;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAc,wBAAwB;AACtC;AACA;AACA;;AAEA,eAAc,wBAAwB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,gBAAe,kBAAkB;AACjC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAmB;AACnB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAiB;AACjB;;AAEA,kBAAiB;AACjB,KAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,sBAAqB;AACrB;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB;;AAElB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAoB;;AAEpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAe,kBAAkB;AACjC,YAAW,cAAc;;AAEzB,yBAAwB,0BAA0B;AAClD,aAAY;AACZ,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA,cAAa,0BAA0B;;AAEvC,aAAY,iBAAiB;AAC7B,aAAY,cAAc;AAC1B,kBAAiB,yBAAyB;AAC1C,eAAc,gBAAgB;;AAE9B,cAAa;AACb,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,iDAAgD;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,+BAA8B,QAAQ;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6CAA4C,SAAS;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP,OAAM;AACN;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI,GAAG,+CAA+C;;AAEtD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAuC,4CAA4C;AACnF;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAc,iBAAiB;AAC/B;AACA;;AAEA,UAAS,eAAe;AACxB;AACA;;AAEA,UAAS,SAAS;AAClB;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uFAAsF,aAAa;AACnG;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,aAAa;AAChC,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,kCAAiC,UAAU,EAAE,QAAQ;AACrD;AACA;AACA;AACA,oDAAmD,YAAY;AAC/D;AACA;;AAEA,sCAAqC,WAAW;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAqB,yBAAyB;AAC9C;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uCAAsC;AACtC;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2OAA0O,cAAc,oBAAoB,QAAQ,KAAK,qCAAqC,kBAAkB,KAAK;AACrV;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+CAA8C;;AAE9C;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,gBAAe,SAAS;AACxB,qBAAoB;;AAEpB;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+CAA8C;AAC9C,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,+BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAc,wBAAwB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA,eAAc,wBAAwB;AACtC;;AAEA;AACA;AACA,yBAAwB;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,sEAAqE,EAAE,cAAc,EAAE;;AAEvF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,kCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,8BAA6B;AAC7B;AACA;AACA;;AAEA;;AAEA,kDAAiD;AACjD;;AAEA,8BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,6CAA4C,SAAS;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAe,wDAAwD;;AAEvE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,OAAM;AACN;AACA,OAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAa;AACb,+CAA8C;;AAE9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAa;AACb,+CAA8C;;AAE9C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAc;AACd,gDAA+C;;AAE/C;;AAEA,+CAA8C,UAAU;AACxD,0BAAyB,aAAa,QAAQ,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,eAAc,8BAA8B;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAmB;AACnB,qDAAoD;;AAEpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,eAAc;;AAEd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAe;AACf,KAAI;AACJ,gBAAe;;AAEf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,uBAAsB,MAAM,kBAAkB,SAAS;AACvD;;AAEA;AACA,+BAA8B,WAAW,SAAS,MAAM;AACxD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA,MAAK;AACL;AACA,uBAAsB,MAAM,kBAAkB,SAAS;AACvD;;AAEA;AACA,6CAA4C,MAAM;AAClD;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA2B,WAAW;AACtC,0BAAyB,MAAM;AAC/B,8CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,mBAAkB;AAClB;AACA,oGAAmG;;AAEnG;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAiC,0BAA0B,6BAA6B;AACxF;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAc,kBAAkB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAsC,GAAG;AACzC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,YAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI,EAAE;;AAEN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI,EAAE;AACN;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA4B,KAAK,KAAK;AACtC,qCAAoC,KAAK,KAAK;AAC9C;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA,aAAY;AACZ,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,cAAa;AACb;AACA,KAAI;AACJ;;AAEA;AACA,cAAa;AACb;AACA,KAAI;AACJ;;AAEA;AACA,cAAa;AACb;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA,KAAI;AACJ;;AAEA,+BAA8B;AAC9B;AACA;;AAEA;;AAEA;;AAEA,8BAA6B;AAC7B,cAAa;AACb;;AAEA;AACA;;AAEA;;AAEA,+BAA8B;AAC9B,eAAc;AACd;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,cAAa;AACb;;AAEA;AACA;;AAEA;;AAEA;AACA,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAI;AACJ,IAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,YAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAe;AACf;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA,mCAAkC,GAAG;AACrC;AACA;AACA;AACA;AACA,qBAAoB,gEAAgE;AACpF,kBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS,SAAS,aAAa;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oDAAmD,0EAA0E;AAC7H;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,yDAAwD;AACxD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,+EAA8E,uBAAuB,OAAO,UAAU,kCAAkC,eAAe,gBAAgB,eAAe;;AAEtM;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8CAA6C,0EAA0E;AACvH;AACA;AACA;;AAEA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,kGAAiG;;AAEjG;AACA;AACA,qDAAoD;AACpD;;AAEA;AACA;;AAEA;AACA;AACA,6DAA4D,OAAO;AACnE;AACA;;AAEA,yDAAwD,MAAM;;AAE9D,mBAAkB,mIAAmI,GAAG,kHAAkH,GAAG,kHAAkH,GAAG,6HAA6H;;AAE/f;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,KAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI,IAAI;AACR;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oDAAmD,cAAc;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ,wBAAuB;;AAEvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA,cAAa;;AAEb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,qBAAoB,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA,eAAc,sBAAsB;AACpC,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA,yDAAwD;AACxD;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yDAAwD;AACxD;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,UAAU;AACrB;AACA;;AAEA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAgB,iCAAiC;AACjD,eAAc,+BAA+B;AAC7C,aAAY;AACZ;;AAEA;AACA;AACA,mBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAsD,oCAAoC;AAC1F;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,yBAAwB,sEAAsE;AAC9F;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA,kBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,eAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,eAAc,SAAS;AACvB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,eAAc,SAAS;AACvB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,eAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB,eAAe;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA6B,YAAY;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mDAAkD;;AAElD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,eAAc,SAAS;AACvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAc,SAAS;AACvB;AACA,0DAAyD;;AAEzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb,MAAK;AACL;;AAEA;;AAEA,oBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAc,SAAS;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAc,SAAS;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAuB;AACvB;AACA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA,yBAAwB,KAAK;AAC7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,wDAAwD;AAC3E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAoC,wBAAwB,uBAAuB;AACnF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2EAA0E;;AAE1E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0EAAyE;AACzE;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,8BAA8B,mBAAmB;;AAE3E;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB,SAAS;;AAEjC;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA6B,UAAU;AACvC;AACA,2BAA0B;AAC1B;;AAEA,8BAA6B,QAAQ;AACrC;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;;AAEA,kDAAiD,QAAQ;AACzD;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAoC;AACpC,0IAAyI,qBAAqB;AAC9J;AACA;;AAEA;AACA,2FAA0F,qBAAqB;AAC/G;AACA;AACA,KAAI;AACJ;AACA,kBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2KAA0K,qBAAqB;AAC/L;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA0B;AAC1B,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA,oBAAmB,0BAA0B;AAC7C;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA,qBAAoB,0BAA0B;AAC9C;AACA,KAAI;;AAEJ;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA,8BAA6B;;AAE7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA,oBAAmB,0BAA0B;AAC7C;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL,KAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yHAAwH,wBAAwB;AAChJ;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mDAAkD,eAAe;AACjE;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA,KAAI;;AAEJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mDAAkD,kCAAkC;AACpF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mDAAkD,2BAA2B;AAC7E;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;;AAEA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA,sDAAqD,kBAAkB;AACvE;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA,iCAAgC;AAChC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAiC;AACjC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA,sDAAqD;;AAErD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA,yDAAwD,qBAAqB;AAC7E;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2JAA0J,eAAe;AACzK,UAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,SAAQ;AACR,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN,MAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,+BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAc;AACd,KAAI;AACJ;AACA,gBAAe;AACf,MAAK;AACL,gBAAe;AACf,MAAK;AACL,gBAAe;AACf;AACA,KAAI;AACJ;AACA;;AAEA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8FAA6F,qBAAqB;AAClH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc,UAAU;AACxB,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,qDAAoD;AACpD,oCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,4EAA2E;AAC3E;AACA;;AAEA;AACA,4CAA2C,gBAAgB;;AAE3D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wEAAuE,mBAAmB;AAC1F;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+BAA8B,KAAK,iDAAiD,mBAAmB;AACvG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,gBAAe,MAAM;AACrB;AACA;AACA;AACA,+BAA8B;AAC9B;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA,qDAAoD,oDAAoD;AACxG,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oDAAmD,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAwD,qBAAqB;AAC7E;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8EAA6E,mBAAmB;;AAEhG;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oEAAmE,aAAa;AAChF;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,4BAA2B,WAAW,WAAW;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,kCAAiC;AACjC;AACA,iDAAgD,4BAA4B;AAC5E;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,IAAG;AACH,yBAAwB;AACxB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA4C,2DAA2D;AACvG;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAoB;AACpB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6DAA4D;;AAE5D;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT,SAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAuB;;AAEvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA,qBAAoB,iDAAiD;;AAErE;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,OAAM;;AAEN;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO,aAAa,MAAM;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,YAAW;AACX;;AAEA;AACA;AACA,KAAI;AACJ,+DAA8D;AAC9D;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iDAAgD;;AAEhD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAiD,eAAe;AAChE;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA,yBAAwB,iBAAiB;AACzC,0BAAyB;AACzB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,8BAA6B,eAAe;;AAE5C;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA,qCAAoC,kBAAkB;AACtD;AACA;;AAEA;AACA;AACA,2BAA0B,eAAe;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAI;;AAEJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,wDAAuD,KAAK,KAAK;AACjE;AACA,uBAAsB;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI,OAAO;;AAEX;AACA,0CAAyC;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,qDAAoD;AACpD,iDAAgD;;AAEhD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,qCAAoC,4BAA4B;;AAEhE;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0DAAyD,UAAU;AACnE;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sPAAqP;AACrP,0DAAyD,mBAAmB;AAC5E;;AAEA;AACA,OAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B,iBAAgB;AAChB,qBAAoB;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sCAAqC,UAAU;AAC/C;;AAEA;AACA;;AAEA;AACA,kEAAiE;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA2C;AAC3C,WAAU;AACV;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA,SAAQ;AACR,QAAO;AACP;AACA;AACA,mCAAkC;AAClC,UAAS;AACT;AACA;AACA,SAAQ;AACR;;AAEA;AACA,OAAM;AACN;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,uDAAsD,2BAA2B;;AAEjF;AACA;AACA,KAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wGAAuG,yBAAyB;AAChI;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,0EAAyE,wBAAwB;AACjG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA,gEAA+D,uCAAuC;AACtG;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,+BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;;AAEA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAuC,qBAAqB;;AAE5D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL,KAAI;AACJ;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gCAA+B;AAC/B;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAkB;AAClB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ,wDAAuD,KAAK;AAC5D;AACA;AACA;;AAEA,4CAA2C;AAC3C;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;;AAEA;;AAEA;AACA,sEAAqE,aAAa;AAClF;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA,iDAAgD;;AAEhD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,eAAe;;AAE9B;AACA,cAAa,6DAA6D;;AAE1E;AACA,eAAc;AACd,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,iBAAgB;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAW,8BAA8B;AACzC,qBAAoB,8BAA8B;;AAElD;AACA,aAAY,iBAAiB;AAC7B,kBAAiB,qBAAqB;AACtC,YAAW,gBAAgB;;AAE3B;AACA,cAAa,uBAAuB;;AAEpC;AACA,UAAS,aAAa;AACtB,YAAW,4BAA4B;;AAEvC;AACA,cAAa,iBAAiB;;AAE9B;AACA,eAAc,0BAA0B,EAAE;AAC1C,iBAAgB,0BAA0B,EAAE;AAC5C,iBAAgB,0BAA0B,EAAE;AAC5C,aAAY,uCAAuC;AACnD,aAAY,0BAA0B,EAAE;AACxC,oBAAmB,8CAA8C;AACjE,eAAc,0BAA0B,EAAE;AAC1C,kBAAiB,0BAA0B;AAC3C;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAC;AACD;;;;;;;;;AC1ugBA,KAAI,GAAG,GAAG,mBAAO,CAAC,EAAK,CAAC;;AAExB,KAAI,eAAe,GAAG;AACrB,aAAW,EAAE,GAAG;AAChB,eAAa,EAAE,CAAC;AAChB,eAAa,EAAE,GAAG;AAClB,OAAK,EAAE;AACN,kBAAe,EAAC,GAAG;AACnB,kBAAe,EAAC,GAAG,EACnB;EACD;;AAED,KAAI,WAAW,GAAG,EAAC,KAAK,EAAC,CAAC,CAAC,EAAE,IAAI,EAAC,CAAC,EAAC;;AAEpC,KAAI,QAAQ,GAAG,GAAG,CAAC,MAAM,CAAC,UAAU,EAAE;;AAErC,UAAQ,EAAE,eAAe;AACzB,kBAAgB,EAAE,GAAG;AACrB,oBAAkB,EAAE,GAAG;AACvB,aAAW,EAAE,WAAW;AACxB,OAAK,EAAE,EAAE;AACT,YAAU,EAAE,WAAW,CAAC,KAAK;;AAE7B,YAAU,EAAE,oBAAS,OAAO,EAAE;AAC7B,UAAO,CAAC,GAAG,CAAC,0BAA0B,EAAE,SAAS,CAAC;AAClD,OAAI,CAAC,OAAO,GAAG,OAAO;;;AAGtB,UAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;GAC3B;;AAED,MAAI,EAAE,gBAAW;AAChB,UAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAC3C,CAAC,CAAC,UAAS,UAAU,EAAC;AACtB,WAAO,CAAC,GAAG,CAAC,yCAAyC,EAAE,UAAU,CAAC;AAClE,WAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAC,GAAG,CAAC;IAC/B,CAAC;GACF;;AAED,UAAQ,EAAE,oBAAW;;AAEpB,UAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC;IAC3C,KAAK,CAAC,CAAC,EAAE,YAAU;;;AAGnB,QAAI,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,kBAAkB,EAAE;AAChD,QAAI,CAAE,QAAQ,EAAE;;AAEf,YAAO,CAAC,GAAG,CAAC,sBAAsB,CAAC;AACnC,YAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;KAC3B,MAAM;AACN,YAAO,CAAC,GAAG,CAAC,uCAAuC,EAAE,QAAQ,CAAC;AAC9D,YAAO,IAAI,CAAC,IAAI,EAAE;KAClB;IACD,CAAC;GACF;EACD,CAAC;;;;;;;;AAQF,UAAS,oBAAoB,CAAC,SAAS,EAAE,QAAQ,EAAE;AAClD,MAAI,SAAS,KAAK,SAAS,CAAC,EAAE,EAAE,OAAO,IAAI,MACtC,OAAO,IAAI;;GAAA;EAEhB;;AAGD,OAAM,CAAC,OAAO,GAAG,QAAQ,C;;;;;;ACvEzB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACrDA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,cAAa,QAAQ;AACrB;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC3BA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;ACXA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,0BAAyB,kBAAkB,EAAE;AAC7C;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACvCA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC5CA;;AAEA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,cAAa,SAAS;AACtB;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACtBA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,iBAAiB;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA,G;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,YAAW,QAAQ;AACnB,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,cAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;;;;;;AC/HA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;ACdA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,YAAW,OAAO;AAClB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACpBA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,cAAa,QAAQ;AACrB;AACA;AACA,8BAA6B,kBAAkB,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACnCA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB,YAAY,EAAE;AACvC;AACA,iBAAgB,sBAAsB;AACtC;;AAEA,qBAAoB;AACpB,8BAA6B,iBAAiB;;AAE9C;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA,oDAAmD,aAAa,EAAE;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,EAAC;;AAED;;;;;;;;;;AC5EA,KAAI,MAAM,GAAG,mBAAO,CAAC,CAAQ,CAAC;AAC9B,KAAI,SAAS,GAAG,mBAAO,CAAC,EAAmB,CAAC;AAC5C,KAAI,CAAC,GAAG;AACP,UAAQ,EAAE,mBAAO,CAAC,EAAsB,CAAC;AACzC,SAAO,EAAE,mBAAO,CAAC,EAAwB,CAAC;AAC1C,WAAS,EAAE,mBAAO,CAAC,EAAuB,CAAC;EAC3C;AACD,KAAI,KAAK,GAAG,YAAY;;;;;;AAMxB,UAAS,IAAI,GAAG,EAAc;;AAE9B,UAAS,eAAe,CAAC,CAAC,EAAE;AAC3B,SAAO,UAAS,CAAC,EAAE;AAClB,UAAO,CAAC,KAAK,CAAC;GACd;EACD;;AAED,KAAI,GAAG,GAAI,eAAY;AACtB,MAAI,GAAG,GAAG,CAAC;AACX,SAAO,YAAW;AACjB,UAAO,EAAE,GAAG;GACZ;EACA;;AAEF,KAAI,eAAe,GAAG,CAAC;;AAEvB,KAAI,MAAM,GAAG,kBAAW;AACvB,MAAI,IAAI,GAAG,CAAC,KAAK,GAAE,eAAe,EAAE,CAAC,CACnC,MAAM,CAAC,YAAY,CAAC,CACpB,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AAC/C,SAAO,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC;EAChC;;AAED,OAAM,GAAG,IAAI;;AAEb,UAAS,UAAU,GAAG;AAAE,SAAO,IAAI;EAAE;;;;;;;;;;;;;;;;;;;AAmBrC,KAAI,IAAI,GAAG,SAAS,CAAC,MAAM,CAAC,MAAM,EAAE;AACnC,aAAW,EAAE,qBAAS,IAAI,EAAE,QAAQ,EAAE;AACrC,OAAI,IAAI,GAAG,OAAO,IAAI,KAAK,UAAU,GAAG,EAAC,UAAU,EAAC,IAAI,EAAC,GAAG,IAAI;AAChE,SAAM,CAAC,IAAI,EAAE,IAAI,CAAC;AAClB,OAAI,CAAC,SAAS,GAAG,IAAI,OAAO,EAAE;AAC9B,OAAI,CAAC,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC;;AAExC,OAAI,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,EAAE,QAAQ,CAAC;AAClD,OAAI,IAAI,GAAG,IAAI;AACf,QAAK,CAAC,YAAU;AACf,QAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC;IAC/B,CAAC;GACF;;AAED,YAAU,EAAE,sBAAU;AACrB,SAAM,IAAI,KAAK,CAAC,yCAAuC,CAAC;GACxD;;AAED,QAAM,EAAE,gBAAS,OAAO,EAAE;;AAEzB,OAAI,IAAI,GAAG,IAAI;AACf,UAAO,CAAC,IAAI,CAAC,UAAS,GAAG,EAAC;AACzB,QAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC;IAC5B,CAAC,SAAM,CAAC,UAAS,GAAG,EAAC;AACrB,WAAO,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC;AACxB,UAAM,GAAG;IACT,CAAC;GACF;;AAED,oBAAkB,EAAE,4BAAS,OAAO,EAAE;;AAErC,OAAI,OAAO,YAAY,IAAI,IAAI,OAAO,YAAY,OAAO,EAAE;AAC1D,WAAO,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACrC,MAAM,IAAI,OAAO,YAAY,IAAI,EAAE;;AAEnC,WAAM;IACN,MAAM;AACN,WAAO,CAAC,KAAK,CAAC,OAAO,EAAE,wBAAwB,CAAC;IAChD;GACD;;AAED,MAAI,EAAE,cAAS,GAAG,EAAE,IAAI,EAAE;AACzB,SAAM,CAAC,WAAW,EAAE,IAAI,CAAC;AACzB,UAAO,IAAI,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC;GAC1B;;AAED,MAAI,EAAE,gBAAW;AAChB,UAAO,IAAI,IAAI,EAAE;GACjB;;AAED,SAAO,EAAE,iBAAS,OAAO,EAAE,GAAG,EAAE;AAC/B,UAAO,IAAI,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,GAAG,CAAC;GACxD;;AAED,YAAU,EAAE,oBAAS,GAAG,EAAE;AACzB,UAAO,IAAI,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;GACzC;;;;;;AAMD,OAAK,EAAE,eAAS,GAAG,EAAE;AACpB,OAAI,KAAK,GAAG,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC;AAC1B,OAAI,IAAI,GAAG,IAAI;AACf,UAAO,IAAI,OAAO,CAAC,UAAS,OAAO,EAAE,MAAM,EAAE;AAC5C,QAAI,IAAI,GAAG,SAAP,IAAI,CAAY,CAAC,EAAE,IAAI,EAAE;AAC5B,YAAO,CAAC,CAAC,CAAC,EAAC,IAAI,CAAC,CAAC;KACjB;AACD,SAAK,CAAC,IAAI,CAAC;IACX,CAAC,CAAC,IAAI,CAAC,UAAS,IAAI,EAAC;AACrB,WAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACjC,CAAC;GACF;EACD,CAAC;;;;;;;;;;;;;;;AAgBF,UAAS,IAAI,GAAG,EAAE;;AAElB,UAAS,IAAI,CAAC,GAAG,EAAE,IAAI,EAAE;AACxB,MAAI,CAAC,GAAG,GAAG,GAAG;AACd,MAAI,CAAC,IAAI,GAAG,IAAI;EAChB;;AAED,KAAI,CAAC,SAAS,CAAC,GAAG,GAAG,UAAU,OAAO,EAAE;AACvC,MAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC;MAAE,IAAI,GAAG,IAAI;AAC/C,SAAO,IAAI,OAAO,CAAC,UAAS,OAAO,EAAE,MAAM,EAAC;AAC3C,OAAI,IAAI,GAAG,SAAP,IAAI,GAAa;AAAE,WAAO,CAAC,KAAK,EAAE,CAAC;IAAE;;;AAGzC,OAAI,IAAI,CAAC,IAAI,GAAG,CAAC,EAAE,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,MACzC,KAAK,CAAC,IAAI,CAAC;GAChB,CAAC;EACF;;AAED,UAAS,OAAO,CAAC,OAAO,EAAE,IAAI,EAAE;AAC/B,MAAI,CAAC,OAAO,GAAG,OAAO;AACtB,MAAI,CAAC,OAAO,GAAG,EAAE;AACjB,MAAI,CAAC,WAAW,GAAG,SAAS;AAC5B,MAAI,IAAI,GAAG,IAAI;EACf;;AAED,QAAO,CAAC,SAAS,CAAC,OAAO,GAAG,UAAU,OAAO,EAAE,QAAQ,EAAE;AACxD,MAAI,SAAS,GAAG,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC;AAClD,MAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;AACxC,SAAO,IAAI;EACX;;;AAGD,QAAO,CAAC,SAAS,CAAC,CAAC,GAAG,UAAU,QAAQ,EAAE;AACzC,MAAI,SAAS,GAAG,UAAU;AAC1B,MAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;AACzC,SAAO,IAAI;EACX;;AAED,QAAO,CAAC,SAAS,CAAC,CAAC,GAAG,UAAU,QAAQ,EAAE;AACzC,SAAO,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,QAAQ,CAAC;EACzC;;AAED,QAAO,CAAC,SAAS,CAAC,oBAAoB,GAAG,UAAU,OAAO,EAAE;AAC3D,MAAI,SAAS,GAAG,IAAI,CAAC,yBAAyB,CAAC,OAAO,CAAC;AACvD,SAAO,UAAS,CAAC,EAAE;AAClB,OAAI,OAAO,GAAG,SAAS,CAAC,CAAC,CAAC;AAC1B,SAAM,CAAC,OAAO,EAAE,OAAO,GAAG,WAAW,GAAG,oBAAoB,EAAE,CAAC,CAAC;AAChE,UAAO,OAAO;GACd;EACD;;AAED,QAAO,CAAC,SAAS,CAAC,yBAAyB,GAAG,UAAU,OAAO,EAAE;AAChE,UAAQ,OAAO,OAAO;AACrB,QAAK,QAAQ;AACZ,WAAO,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC;AAC1B,QAAK,UAAU;AACd,WAAO,OAAO;AACf;AACC,WAAO,eAAe,CAAC,OAAO,CAAC;AAAA,GAChC;EACD;;;;;;;;;;;;;;;;;;;AAmBD,QAAO,CAAC,SAAS,CAAC,KAAK,GAAG,UAAU,OAAO,EAAE,QAAQ,EAAE;AACtD,MAAI,CAAC,WAAW,GAAG,CAAC,OAAO,EAAE,QAAQ,CAAC;AACtC,SAAO,IAAI;EACX;;AAED,QAAO,CAAC,SAAS,CAAC,GAAG,GAAG,UAAU,eAAe,EAAE;AAClD,QAAM,CAAC,aAAa,CAAC;AACrB,MAAI,CAAE,IAAI,CAAC,WAAW,EAAE;;;AAGvB,SAAM,CAAC,8BAA8B,CAAC;AACtC,OAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;GACpB;;;;;;AAMD,SAAO,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CACnF,IAAI,CAAC,UAAS,YAAY,EAAC;AAC3B,UAAO,IAAI,IAAI,CAAC,YAAU;AACzB,UAAM,CAAC,eAAe,EAAE,YAAY,CAAC;;;;;AAKrC,WAAO,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,YAAY,CAAC,OAAO,CAAC;IACxE,CAAC;GACF,CAAC;EACH;;;;AAID,UAAS,OAAO,GAAG;AAClB,MAAI,CAAC,KAAK,GAAG,EAAE;AACf,MAAI,CAAC,SAAS,GAAG,KAAK;EACtB;;AAED,QAAO,CAAC,SAAS,CAAC,IAAI,GAAG,UAAU,OAAO,EAAE;;AAE3C,QAAM,CAAC,qBAAqB,EAAE,OAAO,CAAC;;;AAGtC,MAAI,CAAC,IAAI,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE;AAChD,OAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC;GACxB;EACD;;;;AAID,QAAO,CAAC,SAAS,CAAC,SAAS,GAAG,UAAU,OAAO,EAAE,OAAO,EAAE,eAAe,EAAE;AAC1E,QAAM,CAAC,yBAAyB,EAAE,IAAI,CAAC,KAAK,CAAC;AAC7C,MAAI,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM;MACxB,IAAI,GAAG,OAAO,CAAC,MAAM;MACrB,OAAO;MACP,MAAM;MACN,SAAS;MACT,QAAQ;MACR,CAAC;MACD,CAAC;MACD,IAAI,GAAG,IAAI;AACf,OAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE;AAC1B,UAAO,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;AACvB,SAAM,CAAC,cAAc,EAAE,OAAO,CAAC;AAC/B,QAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE;AAC1B,UAAM,GAAG,OAAO,CAAC,CAAC,CAAC;AACnB,aAAS,GAAG,MAAM,CAAC,CAAC,CAAC;AACrB,YAAQ,GAAG,MAAM,CAAC,CAAC,CAAC;AACpB,QAAI,SAAS,CAAC,OAAO,CAAC,EAAE;;AAEvB,SAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAC,CAAC,CAAC;AACtB,YAAO,OAAO,CAAC,OAAO,CAAC;AACtB,aAAO,EAAE,IAAI;AACb,aAAO,EAAC,OAAO;AACf,cAAQ,EAAC,QAAQ;MACjB,CAAC;KACF;IACD;GACD;;;;;;;;AAQD,MAAI,IAAI,CAAC,SAAS,EAAE;AACnB,UAAO,CAAC,KAAK,CAAC,yBAAyB,CAAC;AACxC,SAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC;GAClD;;AAGD,MAAI,KAAK;;AAET,SAAO,IAAI,OAAO,CAAC,UAAS,OAAO,EAAE,MAAM,EAAC;AAC3C,OAAI,CAAC,SAAS,GAAG,UAAS,OAAO,EAAC;AACjC,UAAM,CAAC,0BAA0B,CAAC;;AAElC,SAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE;AAC1B,WAAM,GAAG,OAAO,CAAC,CAAC,CAAC;AACnB,cAAS,GAAG,MAAM,CAAC,CAAC,CAAC;AACrB,aAAQ,GAAG,MAAM,CAAC,CAAC,CAAC;AACpB,SAAI,SAAS,CAAC,OAAO,CAAC,EAAE;AACvB,UAAI,CAAC,SAAS,GAAG,KAAK;;;;;AAKtB,kBAAY,CAAC,KAAK,CAAC;AACnB,aAAO,CAAC;AACP,cAAO,EAAE,IAAI;AACb,cAAO,EAAC,OAAO;AACf,eAAQ,EAAC,QAAQ;OACjB,CAAC;;;AAGF,aAAO,IAAI;MACX;KACD;AACD,WAAO,KAAK;IACZ;;AAED,OAAI,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;;;AAGxB,UAAM,CAAC,cAAc,GAAG,OAAO,CAAC;AAChC,QAAI,cAAc,GAAG,SAAjB,cAAc,GAAa;AAC9B,SAAI,CAAC,SAAS,GAAG,KAAK;AACtB,YAAO,CAAC;AACP,aAAO,EAAE,KAAK;AACd,aAAO,EAAC,SAAS;AACjB,cAAQ,EAAC,eAAe;MACxB,CAAC;KACF;;AAED,QAAI,OAAO,GAAG,CAAC,EAAE,KAAK,GAAG,UAAU,CAAC,cAAc,EAAE,OAAO,CAAC,yBACnC,cAAc,EAAE;IACzC;GACD,CAAC;EACF;;;;AAKD,UAAS,MAAM,CAAC,OAAO,EAAE;AACxB,MAAI,CAAC,OAAO,GAAG,OAAO;EACtB;;AAED,OAAM,CAAC,SAAS,CAAC,IAAI,GAAG,UAAU,OAAO,EAAE;AAC1C,MAAI,IAAI,GAAG,IAAI;;AAEf,QAAM,CAAC,cAAc,EAAC,OAAO,CAAC;;AAE9B,OAAK,CAAC,YAAU;AAAE,OAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;GAAE,CAAC;EAC5D;;;;AAID,KAAI,CAAC,KAAK,GAAG,UAAS,IAAI,EAAE,QAAQ,EAAE;AACrC,MAAI,WAAW,GAAG,IAAI;AACtB,MAAI,IAAI,GAAG,IAAI,WAAW,CAAC,IAAI,EAAE,QAAQ,CAAC;AAC1C,MAAI,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI;AACzB,SAAO,IAAI,CAAC,MAAM;EAClB;;AAED,OAAM,CAAC,OAAO,GAAG,IAAI;;;;;;;;ACxYrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yCAAwC,WAAW,EAAE,EAAE;AACvD,wCAAuC,iBAAiB;;AAExD;AACA;AACA;AACA,yCAAwC;AACxC,4CAA2C,EAAE,EAAE;AAC/C,wCAAuC,iBAAiB;;AAExD;AACA;AACA,oCAAmC,uBAAuB;;AAE1D;AACA;AACA,6BAA4B,sBAAsB;;AAElD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0DAAyD,WAAW;AACpE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,0CAAyC,EAAE;AAC3C,8CAA6C;AAC7C,6BAA4B,oBAAoB,EAAE;AAClD,gCAA+B,mBAAmB,GAAG;AACrD,gBAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0CAAyC;AACzC,yBAAwB;AACxB;AACA;AACA;AACA,qEAAoE;AACpE;AACA,+CAA8C,EAAE;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC,yBAAwB;AACxB;AACA;AACA;AACA,qEAAoE;AACpE,wCAAuC,EAAE;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA,8CAA6C;AAC7C,iDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAqB;AACrB,yDAAwD;AACxD,sBAAqB;AACrB;AACA;AACA,4DAA2D;;;AAG3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;;;;;;ACnMD;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,cAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB,cAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACrBA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,SAAS;AAC/C;AACA;AACA,IAAG;AACH;AACA,UAAS,oBAAoB,EAAE;AAC/B;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9CA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,YAAW,OAAO,WAAW;AAC7B,cAAa,OAAO;AACpB;AACA;AACA,yBAAwB;;AAExB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACtBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB,cAAa,OAAO;AACpB;AACA;;AAEA;;;;;;;AChBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;AChBA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,YAAW,EAAE;AACb,YAAW,SAAS;AACpB,YAAW,QAAQ;AACnB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AChCA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB,YAAW,QAAQ;AACnB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACrGA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AChDA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9CA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACfA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,EAAE;AACb,YAAW,OAAO;AAClB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,YAAY;AACvB,cAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACtDA;;AAEA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB,YAAW,QAAQ;AACnB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC/CA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB,YAAW,QAAQ;AACnB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACzEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,EAAE;AACf;AACA;;AAEA;;;;;;;ACdA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;;;;;;;AClBA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,cAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACzBA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9DA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACfA;;AAEA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACzCA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,YAAW,SAAS;AACpB,YAAW,EAAE;AACb,cAAa,EAAE;AACf;AACA;AACA;AACA,OAAM,mBAAmB;AACzB,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACrDA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACrCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AChEA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA8B;AAC9B;;AAEA;AACA;AACA,oCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,cAAa,EAAE;AACf;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACnBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,SAAS;AACtB;AACA;AACA;AACA,OAAM,8CAA8C;AACpD,OAAM;AACN;AACA;AACA,+BAA8B,6BAA6B;AAC3D,YAAW,6CAA6C;AACxD;AACA;AACA;AACA;;AAEA;;;;;;;AChCA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU;;;;;;;;;ACzDtC,UAAS,mBAAmB,CAAC,IAAI,EAAE,SAAS,EAAE;AAC7C,MAAI,CAAC,IAAI,GAAG,IAAI;;;AAGhB,MAAI,CAAC,OAAO,GAAG,SAAS;;;AAGxB,MAAI,CAAC,UAAU,GAAG,EAAE;EACpB;;AAED,oBAAmB,CAAC,aAAa,GAAG,UAAS,IAAI,EAAC;;;;;;;;AAQjD,SAAO,CAAC,KAAK,CAAC,0DAA0D,CAAC;AACzE,MAAI,SAAS,GAAG,4BAA4B;AAC5C,SAAO,IAAI,mBAAmB,CAAC,IAAI,EAAC,SAAS,CAAC;EAC9C;;;;;AAMD,oBAAmB,CAAC,SAAS,CAAC,CAAC,GAAG,YAAW;;AAE5C,MAAI,IAAI,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC;AAChD,SAAO,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC;AAChC,SAAO,IAAI;EACX;;AAED,oBAAmB,CAAC,SAAS,CAAC,YAAY,GAAG,YAAW;;AAEvD,MAAI,CAAC,UAAU,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CACrD,MAAM,CAAC,UAAS,GAAG,EAAE,GAAG,EAAC;AACzB,UAAO,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC;GACtB,EAAE,IAAI,CAAC,UAAU,CAAC;AACpB,SAAO,IAAI;EACX;;AAED,oBAAmB,CAAC,SAAS,CAAC,KAAK,GAAG,YAAW;;AAEhD,MAAI,CAAC,UAAU,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CACrD,MAAM,CAAC,UAAS,GAAG,EAAE,GAAG,EAAC;AACzB,UAAO,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC;GACtB,EAAE,IAAI,CAAC,UAAU,CAAC;AACpB,SAAO,IAAI;EACX;;AAED,oBAAmB,CAAC,SAAS,CAAC,UAAU,GAAG,UAAS,CAAC,EAAE;AACtD,MAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,UAAS,CAAC,EAAC;AACnD,UAAO,CAAC,GAAG,CAAC;GACZ,CAAC;AACF,SAAO,IAAI;EACX;;AAED,oBAAmB,CAAC,SAAS,CAAC,SAAS,GAAG,UAAS,CAAC,EAAE;AACrD,MAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,UAAS,CAAC,EAAC;AACnD,UAAO,CAAC,GAAG,CAAC;GACZ,CAAC;AACF,SAAO,IAAI;EACX;;AAED,oBAAmB,CAAC,SAAS,CAAC,IAAI,GAAG,UAAS,CAAC,EAAE;AAChD,MAAI,CAAC,UAAU,GAAG,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC;AACpC,SAAO,IAAI;EACX;;;;AAID,oBAAmB,CAAC,SAAS,CAAC,GAAG,GAAG,UAAS,CAAC,EAAE;AAC/C,MAAI,CAAC,UAAU,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;AACzD,SAAO,IAAI;EACX;;AAED,oBAAmB,CAAC,SAAS,CAAC,GAAG,GAAG,UAAS,CAAC,EAAE;AAC/C,MAAI,CAAC,UAAU,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;AACzD,SAAO,IAAI;EACX;;AAED,oBAAmB,CAAC,SAAS,CAAC,KAAK,GAAG,UAAS,CAAC,EAAE;AACjD,SAAO,CAAC;EACR;;AAED,oBAAmB,CAAC,SAAS,CAAC,MAAM,GAAG,UAAS,IAAI,EAAE;;;;;;AAMrD,MAAI,IAAI,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE;AACjE,UAAO,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;GACzB,MAAM;AACN,UAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;GACxB;EACD;;AAED,UAAS,4BAA4B,GAAG;;;AAGvC,MAAI,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,YAAU;;AAClC,UAAO,IAAI;;;;;;;IAOV,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC;IACtC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC;IACxC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC;IAClC,GAAG,EAAE;IACL,MAAM,CAAC,YAAU;;AACjB,WAAO,IAAI;KACV,KAAK,CAAC,CAAC,CAAC;KAAA;IACT,CAAC;;IAAA;GAEF,CAAC;;AAEF,SAAO,MAAM;EACb;;AAED,OAAM,CAAC,OAAO,GAAG,mBAAmB,C","file":"wontrepair.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap aa605966bdace68a332d\n **/","\nvar graphics = require('graphics')\nvar Elevator = require('elevator')\nvar Storey = require('model/Storey')\nvar CONF = require('conf')\n\nconsole.log('WontRepair initializing')\n\nwindow.WontRepair = function(node) {\n\t// initialize\n\tvar storeys = [new Storey(0), new Storey(1), new Storey(2)]\n\twindow.elv = new Elevator(storeys)\n\t// var renderer = graphics.createRenderer({\n\t//\tdomnode:node,\n\t//\televator:elv,\n\t//\tstoreys: storeys\n\t// })\n\tconsole.log('elv',elv)// DEBUG\n\tsetTimeout(function(){\n\t\telv.addWaypointUp(1)\n\t}, 300)\n}\n\nconsole.log('WontRepair installed')\n\n\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./app/js/main.js\n **/","\nvar conf = {\n\tstoreyHeight: 100,\n\tstoreyWidth: 200,\n\tstoreySpacing: 12,\n\tinitialStoreyCount: 3,\n\tinitialElevatorPostion: 0, // it's a storey index\n\tbuildingX: 20,\n\tbuildingWallThickness: 5,\n\tsvgHeight: 1000,\n\tsvgWidth: 400,\n\televatorHeight:70,\n\televatorWidth:100,\n\tstoreyElevatorSpacing:10 // horizontal spacing\n}\n\nconf.elevatorX = conf.buildingX + conf.buildingWallThickness + conf.storeyWidth + conf.storeyElevatorSpacing\n\nmodule.exports = conf\n\n\n\n/** WEBPACK FOOTER **\n ** ./app/js/conf.js\n **/","var CabinFSM = require('cabinfsm')\nvar extend = require('extend')\nvar DestinationSelector = require('destination-selector')\n\nfunction ElevatorControl (floors) {\n\tthis.cabin = CabinFSM.spawn({},[this])\n\tthis.props = extend({},ElevatorControl.defaultProps)\n\tconsole.error('@todo pick a (random?) floor, set our currentFloor to it and send a goto event to the cabin to force it there')\n\t// this.props.currentFloor = 0 // already in default props\n\tconsole.error('@todo listen to cabin events and change currentFloor when the cabins reaches a floor')\n}\n\nElevatorControl.prototype.deleteWaypoint = function(index) {\n\tconsole.log('deleteWaypoint', index)\n\tdelete this.props.waypoints[index]\n\tdelete this.props.waypointsUp[index]\n\tdelete this.props.waypointsDown[index]\n}\n\nElevatorControl.prototype.addWaypointUp = function(index) {\n\tconsole.log('addWaypointUp',index)\n\tthis.props.waypointsUp[index] = true\n\tthis.cabin.send('wakeup')\n}\n\nElevatorControl.prototype.addWaypointDown = function(index) {\n\tconsole.log('addWaypointDown',index)\n\tthis.props.waypointsDown[index] = true\n\tthis.cabin.send('wakeup')\n}\n\nElevatorControl.prototype.addWaypointCabin = function(index) {\n\tconsole.log('addWaypointCabin',index)\n\tthis.props.waypointsCabin[index] = true\n\tthis.cabin.send('wakeup')\n}\n\nElevatorControl.prototype.getNextDestination = function() {\n\t// we pass all our current information to the selector. It must choose a\n\t// destination with a snapshot of the current state. All waypoints are\n\t// converted to integers\n\tvar selector = DestinationSelector.buildSelector({\n\t\twaypointsUp: Object.keys(this.props.waypointsUp).map(Number),\n\t\twaypointsDown: Object.keys(this.props.waypointsDown).map(Number),\n\t\twaypointsCabin: Object.keys(this.props.waypointsCabin).map(Number),\n\t\tcurrentFloor: this.props.currentFloor,\n\t\tcurrentDirection: this.props.currentDirection\n\t})\n\treturn selector.getNext()\n}\n\nElevatorControl.direction = {UP: 'UP', DOWN: 'DOWN'}\n\nElevatorControl.defaultProps = {\n\tcurrentDirection: ElevatorControl.direction.UP, // no matter at the beginning but it must be set\n\tcurrentFloor: 0,\n\n\t// WAYPOINTS. waypoints stores are sets, i.e we only consider the keys. Set\n\t// wp[2]to any value to stop at the floor which index is 2.\n\t// delete wp[2] when at the floor to clean the object keys. (clean the\n\t// three lists).\n\t// --\n\t// We handle two buttons at each floor : one to go down, one to go up\n\twaypointsUp: {}, // list of floors that upmoving people want to reach\n\twaypointsDown: {}, // … the opposite\n\t// when in the cabin, the selected floors are stored into waypoints,\n\t// because we do not know (IRL) which people pushed them ant where they want\n\t// to go. To implement undirected buttons at floors, make a call to add\n\t// calls there and ignore waypointsUp/Down\n\twaypointsCabin: {},\n\n\t// TIMING\n\ttimer: undefined, // A timer used to have cancellable setTimeout\n\n\n\t// floorS\n\tfloors: [], // a list of floor objects\n}\n\n\nmodule.exports = ElevatorControl\n\n\n\n/** WEBPACK FOOTER **\n ** ./app/js/elevator.js\n **/","var Ractive = require('ractive')\nvar CONF = require('conf')\nvar appSVGTemplate = require('tpl/app.svg')\n\n/**\n* Returns a storey's bounding box. Svg vertical coordinates are descending\n* @param  {0..} index   the storey's index\n* @param  {1..} amt     the total number of storeys (= max index + 1)\n * @return {integer}       y coordinate\n*/\nfunction getStoreyY(index, amt) {\n\tvar maxIndex = amt - 1\n\tvar sa = maxIndex - index // count of storeys above\n\tvar y = CONF.buildingWallThickness + (sa * CONF.storeyHeight) + (sa * CONF.storeySpacing)\n\treturn y\n}\n\n/**\n * Get the elevator Y position when at a storey\n * @param  {integer} index The storey's index the elevator is at\n * @param  {integer} amt   The total number of storeys\n * @return {integer}       y coordinate\n */\nfunction getElevatorY(index, amt) {\n\tconsole.log('getElevatorY', index, amt)\n\tvar y = getStoreyY(index, amt) + (CONF.storeyHeight - CONF.elevatorHeight)\n\treturn y\n}\n\n\n\nfunction wrapStoreys (_storeys) {\n\t// @todo if reducing the amount of storeys, check if elevator is not\n\t// above the new max\n\tvar data = _storeys.map(function(s){\n\t\treturn {\n\t\t\ti: s.position,\n\t\t\t_storey: s,\n\t\t\tx: CONF.buildingX + CONF.buildingWallThickness,\n\t\t\ty: getStoreyY(s.position, _storeys.length),\n\t\t\twidth: CONF.storeyWidth,\n\t\t\theight: CONF.storeyHeight,\n\t\t}\n\t})\n\tconsole.log('wrapped', data)\n\treturn data\n}\n\nfunction createRenderer(opts) {\n\tconsole.log('createRenderer',opts)\n\tvar elv = opts.elevator\n\tvar initialProps = elv.getProps()\n\tvar ractive = new Ractive({\n\t\tel: opts.domnode,\n\t\ttemplate: appSVGTemplate,\n\t\tdata: {\n\t\t\tstoreys: wrapStoreys(opts.storeys),\n\t\t\telv: { // elevator\n\t\t\t\theight: CONF.elevatorHeight,\n\t\t\t\twidth: CONF.elevatorWidth,\n\t\t\t\tx: CONF.elevatorX,\n\t\t\t\tpos: initialProps.currentStorey,\n\t\t\t\ty: getElevatorY(initialProps.currentStorey, opts.storeys.length)\n\t\t\t}\n\t\t},\n\t\tstoreysAmt: function() { return ractive.get('storeys').length },\n\t\tcurrentPos: function() { return ractive.get('elv.pos') },\n\t});\n\n\t// -- listen to elevator changes\n\n\telv.on('*',function(){\n\t\t// console.log('elv emit',arguments)\n\t\t// console.log(' (state)', elv.state)\n\t})\n\telv.on('transition',function(){\n\t\t// console.log('elv emit',arguments)\n\t\tconsole.log(' (state)', elv.state)\n\t})\n\n\telv.on('moving', function(nextPostion, duration){\n\t\tvar newY = getElevatorY(nextPostion, opts.storeys.length)\n\t\treturn ractive.animate(\n\t\t\t{'elv.y': newY, 'elv.pos':nextPostion},\n\t\t\t{duration:duration,easing:'easeInOut'}\n\t\t)\n\t})\n\n\treturn ractive\n}\n\nexports.createRenderer = createRenderer\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./app/js/graphics.js\n **/","\n// The position is an ordered index in the lsit of all the storeys, helping the\n// elevator destination algorithm find its way\n\nfunction Storey(position, altitude) {\n\tthis.position = position\n\tthis.altitude = altitude\n}\n\nmodule.exports = Storey\n\n\n\n/** WEBPACK FOOTER **\n ** ./app/js/model/Storey.js\n **/","var hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar undefined;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\t'use strict';\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar has_own_constructor = hasOwn.call(obj, 'constructor');\n\tvar has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !has_own_constructor && !has_is_property_of_method) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) {}\n\n\treturn key === undefined || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\t'use strict';\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0],\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target === copy) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if (copy !== undefined) {\n\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/extend/index.js\n ** module id = 5\n ** module chunks = 0\n **/","module.exports={\"v\":3,\"t\":[{\"t\":7,\"e\":\"svg\",\"f\":[{\"t\":7,\"e\":\"style\",\"a\":{\"type\":\"text/css\"},\"f\":[\"#storeys rect {\\n\\t\\t\\tfill:none;\\n\\t\\t\\tstroke:black;\\n\\t\\t\\tstroke-width:1px;\\n\\t\\t}\\n\\t\\trect#elevator {\\n\\t\\t\\tfill:none;\\n\\t\\t\\tstroke:black;\\n\\t\\t\\tstroke-width:1px;\\n\\t\\t}\\n\\t\\tsvg {\\n\\t\\t\\theight: 1000px;\\n\\t\\t\\twidth:800px;\\n\\t\\t}\"]},\" \",{\"t\":7,\"e\":\"g\",\"a\":{\"transform\":\"translate(30,30)\"},\"f\":[\" \",{\"t\":7,\"e\":\"g\",\"a\":{\"id\":\"storeys\"},\"f\":[{\"t\":4,\"f\":[{\"t\":7,\"e\":\"rect\",\"a\":{\"width\":[{\"t\":2,\"r\":\"width\"}],\"height\":[{\"t\":2,\"r\":\"height\"}],\"x\":[{\"t\":2,\"r\":\"x\"}],\"y\":[{\"t\":2,\"r\":\"y\"}]}}],\"r\":\"storeys\"}]},\" \",{\"t\":7,\"e\":\"rect\",\"a\":{\"id\":\"elevator\",\"width\":[{\"t\":2,\"r\":\"elv.width\"}],\"height\":[{\"t\":2,\"r\":\"elv.height\"}],\"x\":[{\"t\":2,\"r\":\"elv.x\"}],\"y\":[{\"t\":2,\"r\":\"elv.y\"}]}}]}]}]};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/js/tpl/app.svg\n ** module id = 6\n ** module chunks = 0\n **/","/*\n\tRactive.js v0.7.3\n\tSat Apr 25 2015 13:52:38 GMT-0400 (EDT) - commit da40f81c660ba2f09c45a09a9c20fdd34ee36d80\n\n\thttp://ractivejs.org\n\thttp://twitter.com/RactiveJS\n\n\tReleased under the MIT License.\n*/\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.Ractive = factory()\n}(this, function () { 'use strict';\n\n  var TEMPLATE_VERSION = 3;\n\n  var defaultOptions = {\n\n  \t// render placement:\n  \tel: void 0,\n  \tappend: false,\n\n  \t// template:\n  \ttemplate: { v: TEMPLATE_VERSION, t: [] },\n\n  \t// parse:     // TODO static delimiters?\n  \tpreserveWhitespace: false,\n  \tsanitize: false,\n  \tstripComments: true,\n  \tdelimiters: [\"{{\", \"}}\"],\n  \ttripleDelimiters: [\"{{{\", \"}}}\"],\n  \tinterpolate: false,\n\n  \t// data & binding:\n  \tdata: {},\n  \tcomputed: {},\n  \tmagic: false,\n  \tmodifyArrays: true,\n  \tadapt: [],\n  \tisolated: false,\n  \ttwoway: true,\n  \tlazy: false,\n\n  \t// transitions:\n  \tnoIntro: false,\n  \ttransitionsEnabled: true,\n  \tcomplete: void 0,\n\n  \t// css:\n  \tcss: null,\n  \tnoCssTransform: false\n  };\n\n  var config_defaults = defaultOptions;\n\n  // These are a subset of the easing equations found at\n  // https://raw.github.com/danro/easing-js - license info\n  // follows:\n\n  // --------------------------------------------------\n  // easing.js v0.5.4\n  // Generic set of easing functions with AMD support\n  // https://github.com/danro/easing-js\n  // This code may be freely distributed under the MIT license\n  // http://danro.mit-license.org/\n  // --------------------------------------------------\n  // All functions adapted from Thomas Fuchs & Jeremy Kahn\n  // Easing Equations (c) 2003 Robert Penner, BSD license\n  // https://raw.github.com/danro/easing-js/master/LICENSE\n  // --------------------------------------------------\n\n  // In that library, the functions named easeIn, easeOut, and\n  // easeInOut below are named easeInCubic, easeOutCubic, and\n  // (you guessed it) easeInOutCubic.\n  //\n  // You can add additional easing functions to this list, and they\n  // will be globally available.\n\n  var static_easing = {\n  \tlinear: function (pos) {\n  \t\treturn pos;\n  \t},\n  \teaseIn: function (pos) {\n  \t\treturn Math.pow(pos, 3);\n  \t},\n  \teaseOut: function (pos) {\n  \t\treturn Math.pow(pos - 1, 3) + 1;\n  \t},\n  \teaseInOut: function (pos) {\n  \t\tif ((pos /= 0.5) < 1) {\n  \t\t\treturn 0.5 * Math.pow(pos, 3);\n  \t\t}\n  \t\treturn 0.5 * (Math.pow(pos - 2, 3) + 2);\n  \t}\n  };\n\n  /*global console, navigator */\n  var isClient, isJsdom, hasConsole, environment__magic, namespaces, svg, vendors;\n\n  isClient = typeof document === \"object\";\n\n  isJsdom = typeof navigator !== \"undefined\" && /jsDom/.test(navigator.appName);\n\n  hasConsole = typeof console !== \"undefined\" && typeof console.warn === \"function\" && typeof console.warn.apply === \"function\";\n\n  try {\n  \tObject.defineProperty({}, \"test\", { value: 0 });\n  \tenvironment__magic = true;\n  } catch (e) {\n  \tenvironment__magic = false;\n  }\n\n  namespaces = {\n  \thtml: \"http://www.w3.org/1999/xhtml\",\n  \tmathml: \"http://www.w3.org/1998/Math/MathML\",\n  \tsvg: \"http://www.w3.org/2000/svg\",\n  \txlink: \"http://www.w3.org/1999/xlink\",\n  \txml: \"http://www.w3.org/XML/1998/namespace\",\n  \txmlns: \"http://www.w3.org/2000/xmlns/\"\n  };\n\n  if (typeof document === \"undefined\") {\n  \tsvg = false;\n  } else {\n  \tsvg = document && document.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#BasicStructure\", \"1.1\");\n  }\n\n  vendors = [\"o\", \"ms\", \"moz\", \"webkit\"];\n\n  var createElement, matches, dom__div, methodNames, unprefixed, prefixed, dom__i, j, makeFunction;\n\n  // Test for SVG support\n  if (!svg) {\n  \tcreateElement = function (type, ns) {\n  \t\tif (ns && ns !== namespaces.html) {\n  \t\t\tthrow \"This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information\";\n  \t\t}\n\n  \t\treturn document.createElement(type);\n  \t};\n  } else {\n  \tcreateElement = function (type, ns) {\n  \t\tif (!ns || ns === namespaces.html) {\n  \t\t\treturn document.createElement(type);\n  \t\t}\n\n  \t\treturn document.createElementNS(ns, type);\n  \t};\n  }\n\n  function getElement(input) {\n  \tvar output;\n\n  \tif (!input || typeof input === \"boolean\") {\n  \t\treturn;\n  \t}\n\n  \tif (typeof window === \"undefined\" || !document || !input) {\n  \t\treturn null;\n  \t}\n\n  \t// We already have a DOM node - no work to do. (Duck typing alert!)\n  \tif (input.nodeType) {\n  \t\treturn input;\n  \t}\n\n  \t// Get node from string\n  \tif (typeof input === \"string\") {\n  \t\t// try ID first\n  \t\toutput = document.getElementById(input);\n\n  \t\t// then as selector, if possible\n  \t\tif (!output && document.querySelector) {\n  \t\t\toutput = document.querySelector(input);\n  \t\t}\n\n  \t\t// did it work?\n  \t\tif (output && output.nodeType) {\n  \t\t\treturn output;\n  \t\t}\n  \t}\n\n  \t// If we've been given a collection (jQuery, Zepto etc), extract the first item\n  \tif (input[0] && input[0].nodeType) {\n  \t\treturn input[0];\n  \t}\n\n  \treturn null;\n  }\n\n  if (!isClient) {\n  \tmatches = null;\n  } else {\n  \tdom__div = createElement(\"div\");\n  \tmethodNames = [\"matches\", \"matchesSelector\"];\n\n  \tmakeFunction = function (methodName) {\n  \t\treturn function (node, selector) {\n  \t\t\treturn node[methodName](selector);\n  \t\t};\n  \t};\n\n  \tdom__i = methodNames.length;\n\n  \twhile (dom__i-- && !matches) {\n  \t\tunprefixed = methodNames[dom__i];\n\n  \t\tif (dom__div[unprefixed]) {\n  \t\t\tmatches = makeFunction(unprefixed);\n  \t\t} else {\n  \t\t\tj = vendors.length;\n  \t\t\twhile (j--) {\n  \t\t\t\tprefixed = vendors[dom__i] + unprefixed.substr(0, 1).toUpperCase() + unprefixed.substring(1);\n\n  \t\t\t\tif (dom__div[prefixed]) {\n  \t\t\t\t\tmatches = makeFunction(prefixed);\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// IE8...\n  \tif (!matches) {\n  \t\tmatches = function (node, selector) {\n  \t\t\tvar nodes, parentNode, i;\n\n  \t\t\tparentNode = node.parentNode;\n\n  \t\t\tif (!parentNode) {\n  \t\t\t\t// empty dummy <div>\n  \t\t\t\tdom__div.innerHTML = \"\";\n\n  \t\t\t\tparentNode = dom__div;\n  \t\t\t\tnode = node.cloneNode();\n\n  \t\t\t\tdom__div.appendChild(node);\n  \t\t\t}\n\n  \t\t\tnodes = parentNode.querySelectorAll(selector);\n\n  \t\t\ti = nodes.length;\n  \t\t\twhile (i--) {\n  \t\t\t\tif (nodes[i] === node) {\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\treturn false;\n  \t\t};\n  \t}\n  }\n\n  function detachNode(node) {\n  \tif (node && typeof node.parentNode !== \"unknown\" && node.parentNode) {\n  \t\tnode.parentNode.removeChild(node);\n  \t}\n\n  \treturn node;\n  }\n\n  function safeToStringValue(value) {\n  \treturn value == null || !value.toString ? \"\" : value;\n  }\n\n  var legacy = null;\n\n  var create, defineProperty, defineProperties;\n\n  try {\n  \tObject.defineProperty({}, \"test\", { value: 0 });\n\n  \tif (isClient) {\n  \t\tObject.defineProperty(document.createElement(\"div\"), \"test\", { value: 0 });\n  \t}\n\n  \tdefineProperty = Object.defineProperty;\n  } catch (err) {\n  \t// Object.defineProperty doesn't exist, or we're in IE8 where you can\n  \t// only use it with DOM objects (what were you smoking, MSFT?)\n  \tdefineProperty = function (obj, prop, desc) {\n  \t\tobj[prop] = desc.value;\n  \t};\n  }\n\n  try {\n  \ttry {\n  \t\tObject.defineProperties({}, { test: { value: 0 } });\n  \t} catch (err) {\n  \t\t// TODO how do we account for this? noMagic = true;\n  \t\tthrow err;\n  \t}\n\n  \tif (isClient) {\n  \t\tObject.defineProperties(createElement(\"div\"), { test: { value: 0 } });\n  \t}\n\n  \tdefineProperties = Object.defineProperties;\n  } catch (err) {\n  \tdefineProperties = function (obj, props) {\n  \t\tvar prop;\n\n  \t\tfor (prop in props) {\n  \t\t\tif (props.hasOwnProperty(prop)) {\n  \t\t\t\tdefineProperty(obj, prop, props[prop]);\n  \t\t\t}\n  \t\t}\n  \t};\n  }\n\n  try {\n  \tObject.create(null);\n\n  \tcreate = Object.create;\n  } catch (err) {\n  \t// sigh\n  \tcreate = (function () {\n  \t\tvar F = function () {};\n\n  \t\treturn function (proto, props) {\n  \t\t\tvar obj;\n\n  \t\t\tif (proto === null) {\n  \t\t\t\treturn {};\n  \t\t\t}\n\n  \t\t\tF.prototype = proto;\n  \t\t\tobj = new F();\n\n  \t\t\tif (props) {\n  \t\t\t\tObject.defineProperties(obj, props);\n  \t\t\t}\n\n  \t\t\treturn obj;\n  \t\t};\n  \t})();\n  }\n\n  function utils_object__extend(target) {\n  \tfor (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\tsources[_key - 1] = arguments[_key];\n  \t}\n\n  \tvar prop, source;\n\n  \twhile (source = sources.shift()) {\n  \t\tfor (prop in source) {\n  \t\t\tif (hasOwn.call(source, prop)) {\n  \t\t\t\ttarget[prop] = source[prop];\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn target;\n  }\n\n  function fillGaps(target) {\n  \tfor (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\tsources[_key - 1] = arguments[_key];\n  \t}\n\n  \tsources.forEach(function (s) {\n  \t\tfor (var key in s) {\n  \t\t\tif (s.hasOwnProperty(key) && !(key in target)) {\n  \t\t\t\ttarget[key] = s[key];\n  \t\t\t}\n  \t\t}\n  \t});\n\n  \treturn target;\n  }\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  // thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n  var is__toString = Object.prototype.toString,\n      arrayLikePattern = /^\\[object (?:Array|FileList)\\]$/;\n  function isArray(thing) {\n  \treturn is__toString.call(thing) === \"[object Array]\";\n  }\n\n  function isArrayLike(obj) {\n  \treturn arrayLikePattern.test(is__toString.call(obj));\n  }\n\n  function isEqual(a, b) {\n  \tif (a === null && b === null) {\n  \t\treturn true;\n  \t}\n\n  \tif (typeof a === \"object\" || typeof b === \"object\") {\n  \t\treturn false;\n  \t}\n\n  \treturn a === b;\n  }\n\n  function is__isNumeric(thing) {\n  \treturn !isNaN(parseFloat(thing)) && isFinite(thing);\n  }\n\n  function isObject(thing) {\n  \treturn thing && is__toString.call(thing) === \"[object Object]\";\n  }\n\n  var noop = function () {};\n\n  /* global console */\n  var alreadyWarned = {},\n      log,\n      printWarning,\n      welcome;\n\n  if (hasConsole) {\n  \t(function () {\n  \t\tvar welcomeIntro = [\"%cRactive.js %c0.7.3 %cin debug mode, %cmore...\", \"color: rgb(114, 157, 52); font-weight: normal;\", \"color: rgb(85, 85, 85); font-weight: normal;\", \"color: rgb(85, 85, 85); font-weight: normal;\", \"color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;\"];\n  \t\tvar welcomeMessage = \"You're running Ractive 0.7.3 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\\n\\nTo disable debug mode, add this line at the start of your app:\\n  Ractive.DEBUG = false;\\n\\nTo disable debug mode when your app is minified, add this snippet:\\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\\n\\nGet help and support:\\n  http://docs.ractivejs.org\\n  http://stackoverflow.com/questions/tagged/ractivejs\\n  http://groups.google.com/forum/#!forum/ractive-js\\n  http://twitter.com/ractivejs\\n\\nFound a bug? Raise an issue:\\n  https://github.com/ractivejs/ractive/issues\\n\\n\";\n\n  \t\twelcome = function () {\n  \t\t\tvar hasGroup = !!console.groupCollapsed;\n  \t\t\tconsole[hasGroup ? \"groupCollapsed\" : \"log\"].apply(console, welcomeIntro);\n  \t\t\tconsole.log(welcomeMessage);\n  \t\t\tif (hasGroup) {\n  \t\t\t\tconsole.groupEnd(welcomeIntro);\n  \t\t\t}\n\n  \t\t\twelcome = noop;\n  \t\t};\n\n  \t\tprintWarning = function (message, args) {\n  \t\t\twelcome();\n\n  \t\t\t// extract information about the instance this message pertains to, if applicable\n  \t\t\tif (typeof args[args.length - 1] === \"object\") {\n  \t\t\t\tvar options = args.pop();\n  \t\t\t\tvar ractive = options ? options.ractive : null;\n\n  \t\t\t\tif (ractive) {\n  \t\t\t\t\t// if this is an instance of a component that we know the name of, add\n  \t\t\t\t\t// it to the message\n  \t\t\t\t\tvar _name = undefined;\n  \t\t\t\t\tif (ractive.component && (_name = ractive.component.name)) {\n  \t\t\t\t\t\tmessage = \"<\" + _name + \"> \" + message;\n  \t\t\t\t\t}\n\n  \t\t\t\t\tvar node = undefined;\n  \t\t\t\t\tif (node = options.node || ractive.fragment && ractive.fragment.rendered && ractive.find(\"*\")) {\n  \t\t\t\t\t\targs.push(node);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tconsole.warn.apply(console, [\"%cRactive.js: %c\" + message, \"color: rgb(114, 157, 52);\", \"color: rgb(85, 85, 85);\"].concat(args));\n  \t\t};\n\n  \t\tlog = function () {\n  \t\t\tconsole.log.apply(console, arguments);\n  \t\t};\n  \t})();\n  } else {\n  \tprintWarning = log = welcome = noop;\n  }\n\n  function format(message, args) {\n  \treturn message.replace(/%s/g, function () {\n  \t\treturn args.shift();\n  \t});\n  }\n\n  function fatal(message) {\n  \tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\targs[_key - 1] = arguments[_key];\n  \t}\n\n  \tmessage = format(message, args);\n  \tthrow new Error(message);\n  }\n\n  function logIfDebug() {\n  \tif (_Ractive.DEBUG) {\n  \t\tlog.apply(null, arguments);\n  \t}\n  }\n\n  function warn(message) {\n  \tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\targs[_key - 1] = arguments[_key];\n  \t}\n\n  \tmessage = format(message, args);\n  \tprintWarning(message, args);\n  }\n\n  function warnOnce(message) {\n  \tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\targs[_key - 1] = arguments[_key];\n  \t}\n\n  \tmessage = format(message, args);\n\n  \tif (alreadyWarned[message]) {\n  \t\treturn;\n  \t}\n\n  \talreadyWarned[message] = true;\n  \tprintWarning(message, args);\n  }\n\n  function warnIfDebug() {\n  \tif (_Ractive.DEBUG) {\n  \t\twarn.apply(null, arguments);\n  \t}\n  }\n\n  function warnOnceIfDebug() {\n  \tif (_Ractive.DEBUG) {\n  \t\twarnOnce.apply(null, arguments);\n  \t}\n  }\n\n  // Error messages that are used (or could be) in multiple places\n  var badArguments = \"Bad arguments\";\n  var noRegistryFunctionReturn = \"A function was specified for \\\"%s\\\" %s, but no %s was returned\";\n  var missingPlugin = function (name, type) {\n    return \"Missing \\\"\" + name + \"\\\" \" + type + \" plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#\" + type + \"s\";\n  };\n\n  function findInViewHierarchy(registryName, ractive, name) {\n  \tvar instance = findInstance(registryName, ractive, name);\n  \treturn instance ? instance[registryName][name] : null;\n  }\n\n  function findInstance(registryName, ractive, name) {\n  \twhile (ractive) {\n  \t\tif (name in ractive[registryName]) {\n  \t\t\treturn ractive;\n  \t\t}\n\n  \t\tif (ractive.isolated) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tractive = ractive.parent;\n  \t}\n  }\n\n  var interpolate = function (from, to, ractive, type) {\n  \tif (from === to) {\n  \t\treturn snap(to);\n  \t}\n\n  \tif (type) {\n\n  \t\tvar interpol = findInViewHierarchy(\"interpolators\", ractive, type);\n  \t\tif (interpol) {\n  \t\t\treturn interpol(from, to) || snap(to);\n  \t\t}\n\n  \t\tfatal(missingPlugin(type, \"interpolator\"));\n  \t}\n\n  \treturn static_interpolators.number(from, to) || static_interpolators.array(from, to) || static_interpolators.object(from, to) || snap(to);\n  };\n\n  var shared_interpolate = interpolate;\n\n  function snap(to) {\n  \treturn function () {\n  \t\treturn to;\n  \t};\n  }\n\n  var interpolators = {\n  \tnumber: function (from, to) {\n  \t\tvar delta;\n\n  \t\tif (!is__isNumeric(from) || !is__isNumeric(to)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tfrom = +from;\n  \t\tto = +to;\n\n  \t\tdelta = to - from;\n\n  \t\tif (!delta) {\n  \t\t\treturn function () {\n  \t\t\t\treturn from;\n  \t\t\t};\n  \t\t}\n\n  \t\treturn function (t) {\n  \t\t\treturn from + t * delta;\n  \t\t};\n  \t},\n\n  \tarray: function (from, to) {\n  \t\tvar intermediate, interpolators, len, i;\n\n  \t\tif (!isArray(from) || !isArray(to)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tintermediate = [];\n  \t\tinterpolators = [];\n\n  \t\ti = len = Math.min(from.length, to.length);\n  \t\twhile (i--) {\n  \t\t\tinterpolators[i] = shared_interpolate(from[i], to[i]);\n  \t\t}\n\n  \t\t// surplus values - don't interpolate, but don't exclude them either\n  \t\tfor (i = len; i < from.length; i += 1) {\n  \t\t\tintermediate[i] = from[i];\n  \t\t}\n\n  \t\tfor (i = len; i < to.length; i += 1) {\n  \t\t\tintermediate[i] = to[i];\n  \t\t}\n\n  \t\treturn function (t) {\n  \t\t\tvar i = len;\n\n  \t\t\twhile (i--) {\n  \t\t\t\tintermediate[i] = interpolators[i](t);\n  \t\t\t}\n\n  \t\t\treturn intermediate;\n  \t\t};\n  \t},\n\n  \tobject: function (from, to) {\n  \t\tvar properties, len, interpolators, intermediate, prop;\n\n  \t\tif (!isObject(from) || !isObject(to)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tproperties = [];\n  \t\tintermediate = {};\n  \t\tinterpolators = {};\n\n  \t\tfor (prop in from) {\n  \t\t\tif (hasOwn.call(from, prop)) {\n  \t\t\t\tif (hasOwn.call(to, prop)) {\n  \t\t\t\t\tproperties.push(prop);\n  \t\t\t\t\tinterpolators[prop] = shared_interpolate(from[prop], to[prop]);\n  \t\t\t\t} else {\n  \t\t\t\t\tintermediate[prop] = from[prop];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tfor (prop in to) {\n  \t\t\tif (hasOwn.call(to, prop) && !hasOwn.call(from, prop)) {\n  \t\t\t\tintermediate[prop] = to[prop];\n  \t\t\t}\n  \t\t}\n\n  \t\tlen = properties.length;\n\n  \t\treturn function (t) {\n  \t\t\tvar i = len,\n  \t\t\t    prop;\n\n  \t\t\twhile (i--) {\n  \t\t\t\tprop = properties[i];\n\n  \t\t\t\tintermediate[prop] = interpolators[prop](t);\n  \t\t\t}\n\n  \t\t\treturn intermediate;\n  \t\t};\n  \t}\n  };\n\n  var static_interpolators = interpolators;\n\n  // This function takes a keypath such as 'foo.bar.baz', and returns\n  // all the variants of that keypath that include a wildcard in place\n  // of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.\n  // These are then checked against the dependants map (ractive.viewmodel.depsMap)\n  // to see if any pattern observers are downstream of one or more of\n  // these wildcard keypaths (e.g. 'foo.bar.*.status')\n  var utils_getPotentialWildcardMatches = getPotentialWildcardMatches;\n\n  var starMaps = {};\n  function getPotentialWildcardMatches(keypath) {\n  \tvar keys, starMap, mapper, i, result, wildcardKeypath;\n\n  \tkeys = keypath.split(\".\");\n  \tif (!(starMap = starMaps[keys.length])) {\n  \t\tstarMap = getStarMap(keys.length);\n  \t}\n\n  \tresult = [];\n\n  \tmapper = function (star, i) {\n  \t\treturn star ? \"*\" : keys[i];\n  \t};\n\n  \ti = starMap.length;\n  \twhile (i--) {\n  \t\twildcardKeypath = starMap[i].map(mapper).join(\".\");\n\n  \t\tif (!result.hasOwnProperty(wildcardKeypath)) {\n  \t\t\tresult.push(wildcardKeypath);\n  \t\t\tresult[wildcardKeypath] = true;\n  \t\t}\n  \t}\n\n  \treturn result;\n  }\n\n  // This function returns all the possible true/false combinations for\n  // a given number - e.g. for two, the possible combinations are\n  // [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n  // It does so by getting all the binary values between 0 and e.g. 11\n  function getStarMap(num) {\n  \tvar ones = \"\",\n  \t    max,\n  \t    binary,\n  \t    starMap,\n  \t    mapper,\n  \t    i,\n  \t    j,\n  \t    l,\n  \t    map;\n\n  \tif (!starMaps[num]) {\n  \t\tstarMap = [];\n\n  \t\twhile (ones.length < num) {\n  \t\t\tones += 1;\n  \t\t}\n\n  \t\tmax = parseInt(ones, 2);\n\n  \t\tmapper = function (digit) {\n  \t\t\treturn digit === \"1\";\n  \t\t};\n\n  \t\tfor (i = 0; i <= max; i += 1) {\n  \t\t\tbinary = i.toString(2);\n  \t\t\twhile (binary.length < num) {\n  \t\t\t\tbinary = \"0\" + binary;\n  \t\t\t}\n\n  \t\t\tmap = [];\n  \t\t\tl = binary.length;\n  \t\t\tfor (j = 0; j < l; j++) {\n  \t\t\t\tmap.push(mapper(binary[j]));\n  \t\t\t}\n  \t\t\tstarMap[i] = map;\n  \t\t}\n\n  \t\tstarMaps[num] = starMap;\n  \t}\n\n  \treturn starMaps[num];\n  }\n\n  var refPattern = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\n  var patternPattern = /\\*/;\n  var keypathCache = {};\n\n  var Keypath = function (str) {\n  \tvar keys = str.split(\".\");\n\n  \tthis.str = str;\n\n  \tif (str[0] === \"@\") {\n  \t\tthis.isSpecial = true;\n  \t\tthis.value = decodeKeypath(str);\n  \t}\n\n  \tthis.firstKey = keys[0];\n  \tthis.lastKey = keys.pop();\n\n  \tthis.isPattern = patternPattern.test(str);\n\n  \tthis.parent = str === \"\" ? null : getKeypath(keys.join(\".\"));\n  \tthis.isRoot = !str;\n  };\n\n  Keypath.prototype = {\n  \tequalsOrStartsWith: function (keypath) {\n  \t\treturn keypath === this || this.startsWith(keypath);\n  \t},\n\n  \tjoin: function (str) {\n  \t\treturn getKeypath(this.isRoot ? String(str) : this.str + \".\" + str);\n  \t},\n\n  \treplace: function (oldKeypath, newKeypath) {\n  \t\tif (this === oldKeypath) {\n  \t\t\treturn newKeypath;\n  \t\t}\n\n  \t\tif (this.startsWith(oldKeypath)) {\n  \t\t\treturn newKeypath === null ? newKeypath : getKeypath(this.str.replace(oldKeypath.str + \".\", newKeypath.str + \".\"));\n  \t\t}\n  \t},\n\n  \tstartsWith: function (keypath) {\n  \t\tif (!keypath) {\n  \t\t\t// TODO under what circumstances does this happen?\n  \t\t\treturn false;\n  \t\t}\n\n  \t\treturn keypath && this.str.substr(0, keypath.str.length + 1) === keypath.str + \".\";\n  \t},\n\n  \ttoString: function () {\n  \t\tthrow new Error(\"Bad coercion\");\n  \t},\n\n  \tvalueOf: function () {\n  \t\tthrow new Error(\"Bad coercion\");\n  \t},\n\n  \twildcardMatches: function () {\n  \t\treturn this._wildcardMatches || (this._wildcardMatches = utils_getPotentialWildcardMatches(this.str));\n  \t}\n  };\n  function assignNewKeypath(target, property, oldKeypath, newKeypath) {\n  \tvar existingKeypath = target[property];\n\n  \tif (existingKeypath && (existingKeypath.equalsOrStartsWith(newKeypath) || !existingKeypath.equalsOrStartsWith(oldKeypath))) {\n  \t\treturn;\n  \t}\n\n  \ttarget[property] = existingKeypath ? existingKeypath.replace(oldKeypath, newKeypath) : newKeypath;\n  \treturn true;\n  }\n\n  function decodeKeypath(keypath) {\n  \tvar value = keypath.slice(2);\n\n  \tif (keypath[1] === \"i\") {\n  \t\treturn is__isNumeric(value) ? +value : value;\n  \t} else {\n  \t\treturn value;\n  \t}\n  }\n\n  function getKeypath(str) {\n  \tif (str == null) {\n  \t\treturn str;\n  \t}\n\n  \t// TODO it *may* be worth having two versions of this function - one where\n  \t// keypathCache inherits from null, and one for IE8. Depends on how\n  \t// much of an overhead hasOwnProperty is - probably negligible\n  \tif (!keypathCache.hasOwnProperty(str)) {\n  \t\tkeypathCache[str] = new Keypath(str);\n  \t}\n\n  \treturn keypathCache[str];\n  }\n\n  function getMatchingKeypaths(ractive, keypath) {\n  \tvar keys, key, matchingKeypaths;\n\n  \tkeys = keypath.str.split(\".\");\n  \tmatchingKeypaths = [rootKeypath];\n\n  \twhile (key = keys.shift()) {\n  \t\tif (key === \"*\") {\n  \t\t\t// expand to find all valid child keypaths\n  \t\t\tmatchingKeypaths = matchingKeypaths.reduce(expand, []);\n  \t\t} else {\n  \t\t\tif (matchingKeypaths[0] === rootKeypath) {\n  \t\t\t\t// first key\n  \t\t\t\tmatchingKeypaths[0] = getKeypath(key);\n  \t\t\t} else {\n  \t\t\t\tmatchingKeypaths = matchingKeypaths.map(concatenate(key));\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn matchingKeypaths;\n\n  \tfunction expand(matchingKeypaths, keypath) {\n  \t\tvar wrapper, value, keys;\n\n  \t\tif (keypath.isRoot) {\n  \t\t\tkeys = [].concat(Object.keys(ractive.viewmodel.data), Object.keys(ractive.viewmodel.mappings), Object.keys(ractive.viewmodel.computations));\n  \t\t} else {\n  \t\t\twrapper = ractive.viewmodel.wrapped[keypath.str];\n  \t\t\tvalue = wrapper ? wrapper.get() : ractive.viewmodel.get(keypath);\n\n  \t\t\tkeys = value ? Object.keys(value) : null;\n  \t\t}\n\n  \t\tif (keys) {\n  \t\t\tkeys.forEach(function (key) {\n  \t\t\t\tif (key !== \"_ractive\" || !isArray(value)) {\n  \t\t\t\t\tmatchingKeypaths.push(keypath.join(key));\n  \t\t\t\t}\n  \t\t\t});\n  \t\t}\n\n  \t\treturn matchingKeypaths;\n  \t}\n  }\n\n  function concatenate(key) {\n  \treturn function (keypath) {\n  \t\treturn keypath.join(key);\n  \t};\n  }\n  function normalise(ref) {\n  \treturn ref ? ref.replace(refPattern, \".$1\") : \"\";\n  }\n\n  var rootKeypath = getKeypath(\"\");\n\n  var shared_add = add;\n  var shared_add__errorMessage = \"Cannot add to a non-numeric value\";\n  function add(root, keypath, d) {\n  \tif (typeof keypath !== \"string\" || !is__isNumeric(d)) {\n  \t\tthrow new Error(\"Bad arguments\");\n  \t}\n\n  \tvar value = undefined,\n  \t    changes = undefined;\n\n  \tif (/\\*/.test(keypath)) {\n  \t\tchanges = {};\n\n  \t\tgetMatchingKeypaths(root, getKeypath(normalise(keypath))).forEach(function (keypath) {\n  \t\t\tvar value = root.viewmodel.get(keypath);\n\n  \t\t\tif (!is__isNumeric(value)) {\n  \t\t\t\tthrow new Error(shared_add__errorMessage);\n  \t\t\t}\n\n  \t\t\tchanges[keypath.str] = value + d;\n  \t\t});\n\n  \t\treturn root.set(changes);\n  \t}\n\n  \tvalue = root.get(keypath);\n\n  \tif (!is__isNumeric(value)) {\n  \t\tthrow new Error(shared_add__errorMessage);\n  \t}\n\n  \treturn root.set(keypath, +value + d);\n  }\n\n  var prototype_add = Ractive$add;\n  function Ractive$add(keypath, d) {\n  \treturn shared_add(this, keypath, d === undefined ? 1 : +d);\n  }\n\n  var requestAnimationFrame;\n\n  // If window doesn't exist, we don't need requestAnimationFrame\n  if (typeof window === \"undefined\") {\n  \trequestAnimationFrame = null;\n  } else {\n  \t// https://gist.github.com/paulirish/1579671\n  \t(function (vendors, lastTime, window) {\n\n  \t\tvar x, setTimeout;\n\n  \t\tif (window.requestAnimationFrame) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfor (x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n  \t\t\twindow.requestAnimationFrame = window[vendors[x] + \"RequestAnimationFrame\"];\n  \t\t}\n\n  \t\tif (!window.requestAnimationFrame) {\n  \t\t\tsetTimeout = window.setTimeout;\n\n  \t\t\twindow.requestAnimationFrame = function (callback) {\n  \t\t\t\tvar currTime, timeToCall, id;\n\n  \t\t\t\tcurrTime = Date.now();\n  \t\t\t\ttimeToCall = Math.max(0, 16 - (currTime - lastTime));\n  \t\t\t\tid = setTimeout(function () {\n  \t\t\t\t\tcallback(currTime + timeToCall);\n  \t\t\t\t}, timeToCall);\n\n  \t\t\t\tlastTime = currTime + timeToCall;\n  \t\t\t\treturn id;\n  \t\t\t};\n  \t\t}\n  \t})(vendors, 0, window);\n\n  \trequestAnimationFrame = window.requestAnimationFrame;\n  }\n\n  var rAF = requestAnimationFrame;\n\n  var getTime;\n\n  if (typeof window !== \"undefined\" && window.performance && typeof window.performance.now === \"function\") {\n  \tgetTime = function () {\n  \t\treturn window.performance.now();\n  \t};\n  } else {\n  \tgetTime = function () {\n  \t\treturn Date.now();\n  \t};\n  }\n\n  var utils_getTime = getTime;\n\n  var deprecations = {\n  \tconstruct: {\n  \t\tdeprecated: \"beforeInit\",\n  \t\treplacement: \"onconstruct\"\n  \t},\n  \trender: {\n  \t\tdeprecated: \"init\",\n  \t\tmessage: \"The \\\"init\\\" method has been deprecated \" + \"and will likely be removed in a future release. \" + \"You can either use the \\\"oninit\\\" method which will fire \" + \"only once prior to, and regardless of, any eventual ractive \" + \"instance being rendered, or if you need to access the \" + \"rendered DOM, use \\\"onrender\\\" instead. \" + \"See http://docs.ractivejs.org/latest/migrating for more information.\"\n  \t},\n  \tcomplete: {\n  \t\tdeprecated: \"complete\",\n  \t\treplacement: \"oncomplete\"\n  \t}\n  };\n\n  function Hook(event) {\n  \tthis.event = event;\n  \tthis.method = \"on\" + event;\n  \tthis.deprecate = deprecations[event];\n  }\n\n  Hook.prototype.fire = function (ractive, arg) {\n  \tfunction call(method) {\n  \t\tif (ractive[method]) {\n  \t\t\targ ? ractive[method](arg) : ractive[method]();\n  \t\t\treturn true;\n  \t\t}\n  \t}\n\n  \tcall(this.method);\n\n  \tif (!ractive[this.method] && this.deprecate && call(this.deprecate.deprecated)) {\n  \t\tif (this.deprecate.message) {\n  \t\t\twarnIfDebug(this.deprecate.message);\n  \t\t} else {\n  \t\t\twarnIfDebug(\"The method \\\"%s\\\" has been deprecated in favor of \\\"%s\\\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.\", this.deprecate.deprecated, this.deprecate.replacement);\n  \t\t}\n  \t}\n\n  \targ ? ractive.fire(this.event, arg) : ractive.fire(this.event);\n  };\n\n  var hooks_Hook = Hook;\n\n  function addToArray(array, value) {\n  \tvar index = array.indexOf(value);\n\n  \tif (index === -1) {\n  \t\tarray.push(value);\n  \t}\n  }\n\n  function arrayContains(array, value) {\n  \tfor (var i = 0, c = array.length; i < c; i++) {\n  \t\tif (array[i] == value) {\n  \t\t\treturn true;\n  \t\t}\n  \t}\n\n  \treturn false;\n  }\n\n  function arrayContentsMatch(a, b) {\n  \tvar i;\n\n  \tif (!isArray(a) || !isArray(b)) {\n  \t\treturn false;\n  \t}\n\n  \tif (a.length !== b.length) {\n  \t\treturn false;\n  \t}\n\n  \ti = a.length;\n  \twhile (i--) {\n  \t\tif (a[i] !== b[i]) {\n  \t\t\treturn false;\n  \t\t}\n  \t}\n\n  \treturn true;\n  }\n\n  function ensureArray(x) {\n  \tif (typeof x === \"string\") {\n  \t\treturn [x];\n  \t}\n\n  \tif (x === undefined) {\n  \t\treturn [];\n  \t}\n\n  \treturn x;\n  }\n\n  function lastItem(array) {\n  \treturn array[array.length - 1];\n  }\n\n  function removeFromArray(array, member) {\n  \tvar index = array.indexOf(member);\n\n  \tif (index !== -1) {\n  \t\tarray.splice(index, 1);\n  \t}\n  }\n\n  function toArray(arrayLike) {\n  \tvar array = [],\n  \t    i = arrayLike.length;\n  \twhile (i--) {\n  \t\tarray[i] = arrayLike[i];\n  \t}\n\n  \treturn array;\n  }\n\n  var _Promise,\n      PENDING = {},\n      FULFILLED = {},\n      REJECTED = {};\n\n  if (typeof Promise === \"function\") {\n  \t// use native Promise\n  \t_Promise = Promise;\n  } else {\n  \t_Promise = function (callback) {\n  \t\tvar fulfilledHandlers = [],\n  \t\t    rejectedHandlers = [],\n  \t\t    state = PENDING,\n  \t\t    result,\n  \t\t    dispatchHandlers,\n  \t\t    makeResolver,\n  \t\t    fulfil,\n  \t\t    reject,\n  \t\t    promise;\n\n  \t\tmakeResolver = function (newState) {\n  \t\t\treturn function (value) {\n  \t\t\t\tif (state !== PENDING) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tresult = value;\n  \t\t\t\tstate = newState;\n\n  \t\t\t\tdispatchHandlers = makeDispatcher(state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result);\n\n  \t\t\t\t// dispatch onFulfilled and onRejected handlers asynchronously\n  \t\t\t\twait(dispatchHandlers);\n  \t\t\t};\n  \t\t};\n\n  \t\tfulfil = makeResolver(FULFILLED);\n  \t\treject = makeResolver(REJECTED);\n\n  \t\ttry {\n  \t\t\tcallback(fulfil, reject);\n  \t\t} catch (err) {\n  \t\t\treject(err);\n  \t\t}\n\n  \t\tpromise = {\n  \t\t\t// `then()` returns a Promise - 2.2.7\n  \t\t\tthen: function (onFulfilled, onRejected) {\n  \t\t\t\tvar promise2 = new _Promise(function (fulfil, reject) {\n\n  \t\t\t\t\tvar processResolutionHandler = function (handler, handlers, forward) {\n\n  \t\t\t\t\t\t// 2.2.1.1\n  \t\t\t\t\t\tif (typeof handler === \"function\") {\n  \t\t\t\t\t\t\thandlers.push(function (p1result) {\n  \t\t\t\t\t\t\t\tvar x;\n\n  \t\t\t\t\t\t\t\ttry {\n  \t\t\t\t\t\t\t\t\tx = handler(p1result);\n  \t\t\t\t\t\t\t\t\tutils_Promise__resolve(promise2, x, fulfil, reject);\n  \t\t\t\t\t\t\t\t} catch (err) {\n  \t\t\t\t\t\t\t\t\treject(err);\n  \t\t\t\t\t\t\t\t}\n  \t\t\t\t\t\t\t});\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\t// Forward the result of promise1 to promise2, if resolution handlers\n  \t\t\t\t\t\t\t// are not given\n  \t\t\t\t\t\t\thandlers.push(forward);\n  \t\t\t\t\t\t}\n  \t\t\t\t\t};\n\n  \t\t\t\t\t// 2.2\n  \t\t\t\t\tprocessResolutionHandler(onFulfilled, fulfilledHandlers, fulfil);\n  \t\t\t\t\tprocessResolutionHandler(onRejected, rejectedHandlers, reject);\n\n  \t\t\t\t\tif (state !== PENDING) {\n  \t\t\t\t\t\t// If the promise has resolved already, dispatch the appropriate handlers asynchronously\n  \t\t\t\t\t\twait(dispatchHandlers);\n  \t\t\t\t\t}\n  \t\t\t\t});\n\n  \t\t\t\treturn promise2;\n  \t\t\t}\n  \t\t};\n\n  \t\tpromise[\"catch\"] = function (onRejected) {\n  \t\t\treturn this.then(null, onRejected);\n  \t\t};\n\n  \t\treturn promise;\n  \t};\n\n  \t_Promise.all = function (promises) {\n  \t\treturn new _Promise(function (fulfil, reject) {\n  \t\t\tvar result = [],\n  \t\t\t    pending,\n  \t\t\t    i,\n  \t\t\t    processPromise;\n\n  \t\t\tif (!promises.length) {\n  \t\t\t\tfulfil(result);\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tprocessPromise = function (promise, i) {\n  \t\t\t\tif (promise && typeof promise.then === \"function\") {\n  \t\t\t\t\tpromise.then(function (value) {\n  \t\t\t\t\t\tresult[i] = value;\n  \t\t\t\t\t\t--pending || fulfil(result);\n  \t\t\t\t\t}, reject);\n  \t\t\t\t} else {\n  \t\t\t\t\tresult[i] = promise;\n  \t\t\t\t\t--pending || fulfil(result);\n  \t\t\t\t}\n  \t\t\t};\n\n  \t\t\tpending = i = promises.length;\n  \t\t\twhile (i--) {\n  \t\t\t\tprocessPromise(promises[i], i);\n  \t\t\t}\n  \t\t});\n  \t};\n\n  \t_Promise.resolve = function (value) {\n  \t\treturn new _Promise(function (fulfil) {\n  \t\t\tfulfil(value);\n  \t\t});\n  \t};\n\n  \t_Promise.reject = function (reason) {\n  \t\treturn new _Promise(function (fulfil, reject) {\n  \t\t\treject(reason);\n  \t\t});\n  \t};\n  }\n\n  var utils_Promise = _Promise;\n\n  // TODO use MutationObservers or something to simulate setImmediate\n  function wait(callback) {\n  \tsetTimeout(callback, 0);\n  }\n\n  function makeDispatcher(handlers, result) {\n  \treturn function () {\n  \t\tvar handler;\n\n  \t\twhile (handler = handlers.shift()) {\n  \t\t\thandler(result);\n  \t\t}\n  \t};\n  }\n\n  function utils_Promise__resolve(promise, x, fulfil, reject) {\n  \t// Promise Resolution Procedure\n  \tvar then;\n\n  \t// 2.3.1\n  \tif (x === promise) {\n  \t\tthrow new TypeError(\"A promise's fulfillment handler cannot return the same promise\");\n  \t}\n\n  \t// 2.3.2\n  \tif (x instanceof _Promise) {\n  \t\tx.then(fulfil, reject);\n  \t}\n\n  \t// 2.3.3\n  \telse if (x && (typeof x === \"object\" || typeof x === \"function\")) {\n  \t\ttry {\n  \t\t\tthen = x.then; // 2.3.3.1\n  \t\t} catch (e) {\n  \t\t\treject(e); // 2.3.3.2\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// 2.3.3.3\n  \t\tif (typeof then === \"function\") {\n  \t\t\tvar called, resolvePromise, rejectPromise;\n\n  \t\t\tresolvePromise = function (y) {\n  \t\t\t\tif (called) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n  \t\t\t\tcalled = true;\n  \t\t\t\tutils_Promise__resolve(promise, y, fulfil, reject);\n  \t\t\t};\n\n  \t\t\trejectPromise = function (r) {\n  \t\t\t\tif (called) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n  \t\t\t\tcalled = true;\n  \t\t\t\treject(r);\n  \t\t\t};\n\n  \t\t\ttry {\n  \t\t\t\tthen.call(x, resolvePromise, rejectPromise);\n  \t\t\t} catch (e) {\n  \t\t\t\tif (!called) {\n  \t\t\t\t\t// 2.3.3.3.4.1\n  \t\t\t\t\treject(e); // 2.3.3.3.4.2\n  \t\t\t\t\tcalled = true;\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else {\n  \t\t\tfulfil(x);\n  \t\t}\n  \t} else {\n  \t\tfulfil(x);\n  \t}\n  }\n\n  var getInnerContext = function (fragment) {\n  \tdo {\n  \t\tif (fragment.context !== undefined) {\n  \t\t\treturn fragment.context;\n  \t\t}\n  \t} while (fragment = fragment.parent);\n\n  \treturn rootKeypath;\n  };\n\n  var shared_resolveRef = resolveRef;\n\n  function resolveRef(ractive, ref, fragment) {\n  \tvar keypath;\n\n  \tref = normalise(ref);\n\n  \t// If a reference begins '~/', it's a top-level reference\n  \tif (ref.substr(0, 2) === \"~/\") {\n  \t\tkeypath = getKeypath(ref.substring(2));\n  \t\tcreateMappingIfNecessary(ractive, keypath.firstKey, fragment);\n  \t}\n\n  \t// If a reference begins with '.', it's either a restricted reference or\n  \t// an ancestor reference...\n  \telse if (ref[0] === \".\") {\n  \t\tkeypath = resolveAncestorRef(getInnerContext(fragment), ref);\n\n  \t\tif (keypath) {\n  \t\t\tcreateMappingIfNecessary(ractive, keypath.firstKey, fragment);\n  \t\t}\n  \t}\n\n  \t// ...otherwise we need to figure out the keypath based on context\n  \telse {\n  \t\tkeypath = resolveAmbiguousReference(ractive, getKeypath(ref), fragment);\n  \t}\n\n  \treturn keypath;\n  }\n\n  function resolveAncestorRef(baseContext, ref) {\n  \tvar contextKeys;\n\n  \t// TODO...\n  \tif (baseContext != undefined && typeof baseContext !== \"string\") {\n  \t\tbaseContext = baseContext.str;\n  \t}\n\n  \t// {{.}} means 'current context'\n  \tif (ref === \".\") return getKeypath(baseContext);\n\n  \tcontextKeys = baseContext ? baseContext.split(\".\") : [];\n\n  \t// ancestor references (starting \"../\") go up the tree\n  \tif (ref.substr(0, 3) === \"../\") {\n  \t\twhile (ref.substr(0, 3) === \"../\") {\n  \t\t\tif (!contextKeys.length) {\n  \t\t\t\tthrow new Error(\"Could not resolve reference - too many \\\"../\\\" prefixes\");\n  \t\t\t}\n\n  \t\t\tcontextKeys.pop();\n  \t\t\tref = ref.substring(3);\n  \t\t}\n\n  \t\tcontextKeys.push(ref);\n  \t\treturn getKeypath(contextKeys.join(\".\"));\n  \t}\n\n  \t// not an ancestor reference - must be a restricted reference (prepended with \".\" or \"./\")\n  \tif (!baseContext) {\n  \t\treturn getKeypath(ref.replace(/^\\.\\/?/, \"\"));\n  \t}\n\n  \treturn getKeypath(baseContext + ref.replace(/^\\.\\//, \".\"));\n  }\n\n  function resolveAmbiguousReference(ractive, ref, fragment, isParentLookup) {\n  \tvar context, key, parentValue, hasContextChain, parentKeypath;\n\n  \tif (ref.isRoot) {\n  \t\treturn ref;\n  \t}\n\n  \tkey = ref.firstKey;\n\n  \twhile (fragment) {\n  \t\tcontext = fragment.context;\n  \t\tfragment = fragment.parent;\n\n  \t\tif (!context) {\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\thasContextChain = true;\n  \t\tparentValue = ractive.viewmodel.get(context);\n\n  \t\tif (parentValue && (typeof parentValue === \"object\" || typeof parentValue === \"function\") && key in parentValue) {\n  \t\t\treturn context.join(ref.str);\n  \t\t}\n  \t}\n\n  \t// Root/computed/mapped property?\n  \tif (isRootProperty(ractive.viewmodel, key)) {\n  \t\treturn ref;\n  \t}\n\n  \t// If this is an inline component, and it's not isolated, we\n  \t// can try going up the scope chain\n  \tif (ractive.parent && !ractive.isolated) {\n  \t\thasContextChain = true;\n  \t\tfragment = ractive.component.parentFragment;\n\n  \t\tkey = getKeypath(key);\n\n  \t\tif (parentKeypath = resolveAmbiguousReference(ractive.parent, key, fragment, true)) {\n  \t\t\t// We need to create an inter-component binding\n  \t\t\tractive.viewmodel.map(key, {\n  \t\t\t\torigin: ractive.parent.viewmodel,\n  \t\t\t\tkeypath: parentKeypath\n  \t\t\t});\n\n  \t\t\treturn ref;\n  \t\t}\n  \t}\n\n  \t// If there's no context chain, and the instance is either a) isolated or\n  \t// b) an orphan, then we know that the keypath is identical to the reference\n  \tif (!isParentLookup && !hasContextChain) {\n  \t\t// the data object needs to have a property by this name,\n  \t\t// to prevent future failed lookups\n  \t\tractive.viewmodel.set(ref, undefined);\n  \t\treturn ref;\n  \t}\n  }\n\n  function createMappingIfNecessary(ractive, key) {\n  \tvar parentKeypath;\n\n  \tif (!ractive.parent || ractive.isolated || isRootProperty(ractive.viewmodel, key)) {\n  \t\treturn;\n  \t}\n\n  \tkey = getKeypath(key);\n\n  \tif (parentKeypath = resolveAmbiguousReference(ractive.parent, key, ractive.component.parentFragment, true)) {\n  \t\tractive.viewmodel.map(key, {\n  \t\t\torigin: ractive.parent.viewmodel,\n  \t\t\tkeypath: parentKeypath\n  \t\t});\n  \t}\n  }\n\n  function isRootProperty(viewmodel, key) {\n  \t// special case for reference to root\n  \treturn key === \"\" || key in viewmodel.data || key in viewmodel.computations || key in viewmodel.mappings;\n  }\n\n  function teardown(x) {\n    x.teardown();\n  }\n\n  function methodCallers__unbind(x) {\n    x.unbind();\n  }\n\n  function methodCallers__unrender(x) {\n    x.unrender();\n  }\n\n  function cancel(x) {\n    x.cancel();\n  }\n\n  var TransitionManager = function (callback, parent) {\n  \tthis.callback = callback;\n  \tthis.parent = parent;\n\n  \tthis.intros = [];\n  \tthis.outros = [];\n\n  \tthis.children = [];\n  \tthis.totalChildren = this.outroChildren = 0;\n\n  \tthis.detachQueue = [];\n  \tthis.decoratorQueue = [];\n  \tthis.outrosComplete = false;\n\n  \tif (parent) {\n  \t\tparent.addChild(this);\n  \t}\n  };\n\n  TransitionManager.prototype = {\n  \taddChild: function (child) {\n  \t\tthis.children.push(child);\n\n  \t\tthis.totalChildren += 1;\n  \t\tthis.outroChildren += 1;\n  \t},\n\n  \tdecrementOutros: function () {\n  \t\tthis.outroChildren -= 1;\n  \t\tcheck(this);\n  \t},\n\n  \tdecrementTotal: function () {\n  \t\tthis.totalChildren -= 1;\n  \t\tcheck(this);\n  \t},\n\n  \tadd: function (transition) {\n  \t\tvar list = transition.isIntro ? this.intros : this.outros;\n  \t\tlist.push(transition);\n  \t},\n\n  \taddDecorator: function (decorator) {\n  \t\tthis.decoratorQueue.push(decorator);\n  \t},\n\n  \tremove: function (transition) {\n  \t\tvar list = transition.isIntro ? this.intros : this.outros;\n  \t\tremoveFromArray(list, transition);\n  \t\tcheck(this);\n  \t},\n\n  \tinit: function () {\n  \t\tthis.ready = true;\n  \t\tcheck(this);\n  \t},\n\n  \tdetachNodes: function () {\n  \t\tthis.decoratorQueue.forEach(teardown);\n  \t\tthis.detachQueue.forEach(detach);\n  \t\tthis.children.forEach(detachNodes);\n  \t}\n  };\n\n  function detach(element) {\n  \telement.detach();\n  }\n\n  function detachNodes(tm) {\n  \ttm.detachNodes();\n  }\n\n  function check(tm) {\n  \tif (!tm.ready || tm.outros.length || tm.outroChildren) return;\n\n  \t// If all outros are complete, and we haven't already done this,\n  \t// we notify the parent if there is one, otherwise\n  \t// start detaching nodes\n  \tif (!tm.outrosComplete) {\n  \t\tif (tm.parent) {\n  \t\t\ttm.parent.decrementOutros(tm);\n  \t\t} else {\n  \t\t\ttm.detachNodes();\n  \t\t}\n\n  \t\ttm.outrosComplete = true;\n  \t}\n\n  \t// Once everything is done, we can notify parent transition\n  \t// manager and call the callback\n  \tif (!tm.intros.length && !tm.totalChildren) {\n  \t\tif (typeof tm.callback === \"function\") {\n  \t\t\ttm.callback();\n  \t\t}\n\n  \t\tif (tm.parent) {\n  \t\t\ttm.parent.decrementTotal();\n  \t\t}\n  \t}\n  }\n\n  var global_TransitionManager = TransitionManager;\n\n  var batch,\n      runloop,\n      unresolved = [],\n      changeHook = new hooks_Hook(\"change\");\n\n  runloop = {\n  \tstart: function (instance, returnPromise) {\n  \t\tvar promise, fulfilPromise;\n\n  \t\tif (returnPromise) {\n  \t\t\tpromise = new utils_Promise(function (f) {\n  \t\t\t\treturn fulfilPromise = f;\n  \t\t\t});\n  \t\t}\n\n  \t\tbatch = {\n  \t\t\tpreviousBatch: batch,\n  \t\t\ttransitionManager: new global_TransitionManager(fulfilPromise, batch && batch.transitionManager),\n  \t\t\tviews: [],\n  \t\t\ttasks: [],\n  \t\t\tractives: [],\n  \t\t\tinstance: instance\n  \t\t};\n\n  \t\tif (instance) {\n  \t\t\tbatch.ractives.push(instance);\n  \t\t}\n\n  \t\treturn promise;\n  \t},\n\n  \tend: function () {\n  \t\tflushChanges();\n\n  \t\tbatch.transitionManager.init();\n  \t\tif (!batch.previousBatch && !!batch.instance) batch.instance.viewmodel.changes = [];\n  \t\tbatch = batch.previousBatch;\n  \t},\n\n  \taddRactive: function (ractive) {\n  \t\tif (batch) {\n  \t\t\taddToArray(batch.ractives, ractive);\n  \t\t}\n  \t},\n\n  \tregisterTransition: function (transition) {\n  \t\ttransition._manager = batch.transitionManager;\n  \t\tbatch.transitionManager.add(transition);\n  \t},\n\n  \tregisterDecorator: function (decorator) {\n  \t\tbatch.transitionManager.addDecorator(decorator);\n  \t},\n\n  \taddView: function (view) {\n  \t\tbatch.views.push(view);\n  \t},\n\n  \taddUnresolved: function (thing) {\n  \t\tunresolved.push(thing);\n  \t},\n\n  \tremoveUnresolved: function (thing) {\n  \t\tremoveFromArray(unresolved, thing);\n  \t},\n\n  \t// synchronise node detachments with transition ends\n  \tdetachWhenReady: function (thing) {\n  \t\tbatch.transitionManager.detachQueue.push(thing);\n  \t},\n\n  \tscheduleTask: function (task, postRender) {\n  \t\tvar _batch;\n\n  \t\tif (!batch) {\n  \t\t\ttask();\n  \t\t} else {\n  \t\t\t_batch = batch;\n  \t\t\twhile (postRender && _batch.previousBatch) {\n  \t\t\t\t// this can't happen until the DOM has been fully updated\n  \t\t\t\t// otherwise in some situations (with components inside elements)\n  \t\t\t\t// transitions and decorators will initialise prematurely\n  \t\t\t\t_batch = _batch.previousBatch;\n  \t\t\t}\n\n  \t\t\t_batch.tasks.push(task);\n  \t\t}\n  \t}\n  };\n\n  var global_runloop = runloop;\n\n  function flushChanges() {\n  \tvar i, thing, changeHash;\n\n  \twhile (batch.ractives.length) {\n  \t\tthing = batch.ractives.pop();\n  \t\tchangeHash = thing.viewmodel.applyChanges();\n\n  \t\tif (changeHash) {\n  \t\t\tchangeHook.fire(thing, changeHash);\n  \t\t}\n  \t}\n\n  \tattemptKeypathResolution();\n\n  \t// Now that changes have been fully propagated, we can update the DOM\n  \t// and complete other tasks\n  \tfor (i = 0; i < batch.views.length; i += 1) {\n  \t\tbatch.views[i].update();\n  \t}\n  \tbatch.views.length = 0;\n\n  \tfor (i = 0; i < batch.tasks.length; i += 1) {\n  \t\tbatch.tasks[i]();\n  \t}\n  \tbatch.tasks.length = 0;\n\n  \t// If updating the view caused some model blowback - e.g. a triple\n  \t// containing <option> elements caused the binding on the <select>\n  \t// to update - then we start over\n  \tif (batch.ractives.length) return flushChanges();\n  }\n\n  function attemptKeypathResolution() {\n  \tvar i, item, keypath, resolved;\n\n  \ti = unresolved.length;\n\n  \t// see if we can resolve any unresolved references\n  \twhile (i--) {\n  \t\titem = unresolved[i];\n\n  \t\tif (item.keypath) {\n  \t\t\t// it resolved some other way. TODO how? two-way binding? Seems\n  \t\t\t// weird that we'd still end up here\n  \t\t\tunresolved.splice(i, 1);\n  \t\t\tcontinue; // avoid removing the wrong thing should the next condition be true\n  \t\t}\n\n  \t\tif (keypath = shared_resolveRef(item.root, item.ref, item.parentFragment)) {\n  \t\t\t(resolved || (resolved = [])).push({\n  \t\t\t\titem: item,\n  \t\t\t\tkeypath: keypath\n  \t\t\t});\n\n  \t\t\tunresolved.splice(i, 1);\n  \t\t}\n  \t}\n\n  \tif (resolved) {\n  \t\tresolved.forEach(global_runloop__resolve);\n  \t}\n  }\n\n  function global_runloop__resolve(resolved) {\n  \tresolved.item.resolve(resolved.keypath);\n  }\n\n  var queue = [];\n\n  var animations = {\n  \ttick: function () {\n  \t\tvar i, animation, now;\n\n  \t\tnow = utils_getTime();\n\n  \t\tglobal_runloop.start();\n\n  \t\tfor (i = 0; i < queue.length; i += 1) {\n  \t\t\tanimation = queue[i];\n\n  \t\t\tif (!animation.tick(now)) {\n  \t\t\t\t// animation is complete, remove it from the stack, and decrement i so we don't miss one\n  \t\t\t\tqueue.splice(i--, 1);\n  \t\t\t}\n  \t\t}\n\n  \t\tglobal_runloop.end();\n\n  \t\tif (queue.length) {\n  \t\t\trAF(animations.tick);\n  \t\t} else {\n  \t\t\tanimations.running = false;\n  \t\t}\n  \t},\n\n  \tadd: function (animation) {\n  \t\tqueue.push(animation);\n\n  \t\tif (!animations.running) {\n  \t\t\tanimations.running = true;\n  \t\t\trAF(animations.tick);\n  \t\t}\n  \t},\n\n  \t// TODO optimise this\n  \tabort: function (keypath, root) {\n  \t\tvar i = queue.length,\n  \t\t    animation;\n\n  \t\twhile (i--) {\n  \t\t\tanimation = queue[i];\n\n  \t\t\tif (animation.root === root && animation.keypath === keypath) {\n  \t\t\t\tanimation.stop();\n  \t\t\t}\n  \t\t}\n  \t}\n  };\n\n  var shared_animations = animations;\n\n  var Animation = function (options) {\n  \tvar key;\n\n  \tthis.startTime = Date.now();\n\n  \t// from and to\n  \tfor (key in options) {\n  \t\tif (options.hasOwnProperty(key)) {\n  \t\t\tthis[key] = options[key];\n  \t\t}\n  \t}\n\n  \tthis.interpolator = shared_interpolate(this.from, this.to, this.root, this.interpolator);\n  \tthis.running = true;\n\n  \tthis.tick();\n  };\n\n  Animation.prototype = {\n  \ttick: function () {\n  \t\tvar elapsed, t, value, timeNow, index, keypath;\n\n  \t\tkeypath = this.keypath;\n\n  \t\tif (this.running) {\n  \t\t\ttimeNow = Date.now();\n  \t\t\telapsed = timeNow - this.startTime;\n\n  \t\t\tif (elapsed >= this.duration) {\n  \t\t\t\tif (keypath !== null) {\n  \t\t\t\t\tglobal_runloop.start(this.root);\n  \t\t\t\t\tthis.root.viewmodel.set(keypath, this.to);\n  \t\t\t\t\tglobal_runloop.end();\n  \t\t\t\t}\n\n  \t\t\t\tif (this.step) {\n  \t\t\t\t\tthis.step(1, this.to);\n  \t\t\t\t}\n\n  \t\t\t\tthis.complete(this.to);\n\n  \t\t\t\tindex = this.root._animations.indexOf(this);\n\n  \t\t\t\t// TODO investigate why this happens\n  \t\t\t\tif (index === -1) {\n  \t\t\t\t\twarnIfDebug(\"Animation was not found\");\n  \t\t\t\t}\n\n  \t\t\t\tthis.root._animations.splice(index, 1);\n\n  \t\t\t\tthis.running = false;\n  \t\t\t\treturn false; // remove from the stack\n  \t\t\t}\n\n  \t\t\tt = this.easing ? this.easing(elapsed / this.duration) : elapsed / this.duration;\n\n  \t\t\tif (keypath !== null) {\n  \t\t\t\tvalue = this.interpolator(t);\n  \t\t\t\tglobal_runloop.start(this.root);\n  \t\t\t\tthis.root.viewmodel.set(keypath, value);\n  \t\t\t\tglobal_runloop.end();\n  \t\t\t}\n\n  \t\t\tif (this.step) {\n  \t\t\t\tthis.step(t, value);\n  \t\t\t}\n\n  \t\t\treturn true; // keep in the stack\n  \t\t}\n\n  \t\treturn false; // remove from the stack\n  \t},\n\n  \tstop: function () {\n  \t\tvar index;\n\n  \t\tthis.running = false;\n\n  \t\tindex = this.root._animations.indexOf(this);\n\n  \t\t// TODO investigate why this happens\n  \t\tif (index === -1) {\n  \t\t\twarnIfDebug(\"Animation was not found\");\n  \t\t}\n\n  \t\tthis.root._animations.splice(index, 1);\n  \t}\n  };\n\n  var animate_Animation = Animation;\n\n  var prototype_animate = Ractive$animate;\n\n  var noAnimation = { stop: noop };\n  function Ractive$animate(keypath, to, options) {\n  \tvar promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;\n\n  \tpromise = new utils_Promise(function (fulfil) {\n  \t\treturn fulfilPromise = fulfil;\n  \t});\n\n  \t// animate multiple keypaths\n  \tif (typeof keypath === \"object\") {\n  \t\toptions = to || {};\n  \t\teasing = options.easing;\n  \t\tduration = options.duration;\n\n  \t\tanimations = [];\n\n  \t\t// we don't want to pass the `step` and `complete` handlers, as they will\n  \t\t// run for each animation! So instead we'll store the handlers and create\n  \t\t// our own...\n  \t\tstep = options.step;\n  \t\tcomplete = options.complete;\n\n  \t\tif (step || complete) {\n  \t\t\tcurrentValues = {};\n\n  \t\t\toptions.step = null;\n  \t\t\toptions.complete = null;\n\n  \t\t\tmakeValueCollector = function (keypath) {\n  \t\t\t\treturn function (t, value) {\n  \t\t\t\t\tcurrentValues[keypath] = value;\n  \t\t\t\t};\n  \t\t\t};\n  \t\t}\n\n  \t\tfor (k in keypath) {\n  \t\t\tif (keypath.hasOwnProperty(k)) {\n  \t\t\t\tif (step || complete) {\n  \t\t\t\t\tcollectValue = makeValueCollector(k);\n  \t\t\t\t\toptions = { easing: easing, duration: duration };\n\n  \t\t\t\t\tif (step) {\n  \t\t\t\t\t\toptions.step = collectValue;\n  \t\t\t\t\t}\n  \t\t\t\t}\n\n  \t\t\t\toptions.complete = complete ? collectValue : noop;\n  \t\t\t\tanimations.push(animate(this, k, keypath[k], options));\n  \t\t\t}\n  \t\t}\n\n  \t\t// Create a dummy animation, to facilitate step/complete\n  \t\t// callbacks, and Promise fulfilment\n  \t\tdummyOptions = { easing: easing, duration: duration };\n\n  \t\tif (step) {\n  \t\t\tdummyOptions.step = function (t) {\n  \t\t\t\treturn step(t, currentValues);\n  \t\t\t};\n  \t\t}\n\n  \t\tif (complete) {\n  \t\t\tpromise.then(function (t) {\n  \t\t\t\treturn complete(t, currentValues);\n  \t\t\t});\n  \t\t}\n\n  \t\tdummyOptions.complete = fulfilPromise;\n\n  \t\tdummy = animate(this, null, null, dummyOptions);\n  \t\tanimations.push(dummy);\n\n  \t\tpromise.stop = function () {\n  \t\t\tvar animation;\n\n  \t\t\twhile (animation = animations.pop()) {\n  \t\t\t\tanimation.stop();\n  \t\t\t}\n\n  \t\t\tif (dummy) {\n  \t\t\t\tdummy.stop();\n  \t\t\t}\n  \t\t};\n\n  \t\treturn promise;\n  \t}\n\n  \t// animate a single keypath\n  \toptions = options || {};\n\n  \tif (options.complete) {\n  \t\tpromise.then(options.complete);\n  \t}\n\n  \toptions.complete = fulfilPromise;\n  \tanimation = animate(this, keypath, to, options);\n\n  \tpromise.stop = function () {\n  \t\treturn animation.stop();\n  \t};\n  \treturn promise;\n  }\n\n  function animate(root, keypath, to, options) {\n  \tvar easing, duration, animation, from;\n\n  \tif (keypath) {\n  \t\tkeypath = getKeypath(normalise(keypath));\n  \t}\n\n  \tif (keypath !== null) {\n  \t\tfrom = root.viewmodel.get(keypath);\n  \t}\n\n  \t// cancel any existing animation\n  \t// TODO what about upstream/downstream keypaths?\n  \tshared_animations.abort(keypath, root);\n\n  \t// don't bother animating values that stay the same\n  \tif (isEqual(from, to)) {\n  \t\tif (options.complete) {\n  \t\t\toptions.complete(options.to);\n  \t\t}\n\n  \t\treturn noAnimation;\n  \t}\n\n  \t// easing function\n  \tif (options.easing) {\n  \t\tif (typeof options.easing === \"function\") {\n  \t\t\teasing = options.easing;\n  \t\t} else {\n  \t\t\teasing = root.easing[options.easing];\n  \t\t}\n\n  \t\tif (typeof easing !== \"function\") {\n  \t\t\teasing = null;\n  \t\t}\n  \t}\n\n  \t// duration\n  \tduration = options.duration === undefined ? 400 : options.duration;\n\n  \t// TODO store keys, use an internal set method\n  \tanimation = new animate_Animation({\n  \t\tkeypath: keypath,\n  \t\tfrom: from,\n  \t\tto: to,\n  \t\troot: root,\n  \t\tduration: duration,\n  \t\teasing: easing,\n  \t\tinterpolator: options.interpolator,\n\n  \t\t// TODO wrap callbacks if necessary, to use instance as context\n  \t\tstep: options.step,\n  \t\tcomplete: options.complete\n  \t});\n\n  \tshared_animations.add(animation);\n  \troot._animations.push(animation);\n\n  \treturn animation;\n  }\n\n  var prototype_detach = Ractive$detach;\n  var prototype_detach__detachHook = new hooks_Hook(\"detach\");\n  function Ractive$detach() {\n  \tif (this.detached) {\n  \t\treturn this.detached;\n  \t}\n\n  \tif (this.el) {\n  \t\tremoveFromArray(this.el.__ractive_instances__, this);\n  \t}\n  \tthis.detached = this.fragment.detach();\n  \tprototype_detach__detachHook.fire(this);\n  \treturn this.detached;\n  }\n\n  var prototype_find = Ractive$find;\n\n  function Ractive$find(selector) {\n  \tif (!this.el) {\n  \t\treturn null;\n  \t}\n\n  \treturn this.fragment.find(selector);\n  }\n\n  var test = Query$test;\n  function Query$test(item, noDirty) {\n  \tvar itemMatches;\n\n  \tif (this._isComponentQuery) {\n  \t\titemMatches = !this.selector || item.name === this.selector;\n  \t} else {\n  \t\titemMatches = item.node ? matches(item.node, this.selector) : null;\n  \t}\n\n  \tif (itemMatches) {\n  \t\tthis.push(item.node || item.instance);\n\n  \t\tif (!noDirty) {\n  \t\t\tthis._makeDirty();\n  \t\t}\n\n  \t\treturn true;\n  \t}\n  }\n\n  var makeQuery_cancel = function () {\n  \tvar liveQueries, selector, index;\n\n  \tliveQueries = this._root[this._isComponentQuery ? \"liveComponentQueries\" : \"liveQueries\"];\n  \tselector = this.selector;\n\n  \tindex = liveQueries.indexOf(selector);\n\n  \tif (index !== -1) {\n  \t\tliveQueries.splice(index, 1);\n  \t\tliveQueries[selector] = null;\n  \t}\n  };\n\n  var sortByItemPosition = function (a, b) {\n  \tvar ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;\n\n  \tancestryA = getAncestry(a.component || a._ractive.proxy);\n  \tancestryB = getAncestry(b.component || b._ractive.proxy);\n\n  \toldestA = lastItem(ancestryA);\n  \toldestB = lastItem(ancestryB);\n\n  \t// remove items from the end of both ancestries as long as they are identical\n  \t// - the final one removed is the closest mutual ancestor\n  \twhile (oldestA && oldestA === oldestB) {\n  \t\tancestryA.pop();\n  \t\tancestryB.pop();\n\n  \t\tmutualAncestor = oldestA;\n\n  \t\toldestA = lastItem(ancestryA);\n  \t\toldestB = lastItem(ancestryB);\n  \t}\n\n  \t// now that we have the mutual ancestor, we can find which is earliest\n  \toldestA = oldestA.component || oldestA;\n  \toldestB = oldestB.component || oldestB;\n\n  \tfragmentA = oldestA.parentFragment;\n  \tfragmentB = oldestB.parentFragment;\n\n  \t// if both items share a parent fragment, our job is easy\n  \tif (fragmentA === fragmentB) {\n  \t\tindexA = fragmentA.items.indexOf(oldestA);\n  \t\tindexB = fragmentB.items.indexOf(oldestB);\n\n  \t\t// if it's the same index, it means one contains the other,\n  \t\t// so we see which has the longest ancestry\n  \t\treturn indexA - indexB || ancestryA.length - ancestryB.length;\n  \t}\n\n  \t// if mutual ancestor is a section, we first test to see which section\n  \t// fragment comes first\n  \tif (fragments = mutualAncestor.fragments) {\n  \t\tindexA = fragments.indexOf(fragmentA);\n  \t\tindexB = fragments.indexOf(fragmentB);\n\n  \t\treturn indexA - indexB || ancestryA.length - ancestryB.length;\n  \t}\n\n  \tthrow new Error(\"An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!\");\n  };\n\n  function getParent(item) {\n  \tvar parentFragment;\n\n  \tif (parentFragment = item.parentFragment) {\n  \t\treturn parentFragment.owner;\n  \t}\n\n  \tif (item.component && (parentFragment = item.component.parentFragment)) {\n  \t\treturn parentFragment.owner;\n  \t}\n  }\n\n  function getAncestry(item) {\n  \tvar ancestry, ancestor;\n\n  \tancestry = [item];\n\n  \tancestor = getParent(item);\n\n  \twhile (ancestor) {\n  \t\tancestry.push(ancestor);\n  \t\tancestor = getParent(ancestor);\n  \t}\n\n  \treturn ancestry;\n  }\n\n  var sortByDocumentPosition = function (node, otherNode) {\n  \tvar bitmask;\n\n  \tif (node.compareDocumentPosition) {\n  \t\tbitmask = node.compareDocumentPosition(otherNode);\n  \t\treturn bitmask & 2 ? 1 : -1;\n  \t}\n\n  \t// In old IE, we can piggy back on the mechanism for\n  \t// comparing component positions\n  \treturn sortByItemPosition(node, otherNode);\n  };\n\n  var sort = function () {\n  \tthis.sort(this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition);\n  \tthis._dirty = false;\n  };\n\n  var makeQuery_dirty = function () {\n  \tvar _this = this;\n\n  \tif (!this._dirty) {\n  \t\tthis._dirty = true;\n\n  \t\t// Once the DOM has been updated, ensure the query\n  \t\t// is correctly ordered\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\t_this._sort();\n  \t\t});\n  \t}\n  };\n\n  var remove = function (nodeOrComponent) {\n  \tvar index = this.indexOf(this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent);\n\n  \tif (index !== -1) {\n  \t\tthis.splice(index, 1);\n  \t}\n  };\n\n  var _makeQuery = makeQuery;\n  function makeQuery(ractive, selector, live, isComponentQuery) {\n  \tvar query = [];\n\n  \tdefineProperties(query, {\n  \t\tselector: { value: selector },\n  \t\tlive: { value: live },\n\n  \t\t_isComponentQuery: { value: isComponentQuery },\n  \t\t_test: { value: test }\n  \t});\n\n  \tif (!live) {\n  \t\treturn query;\n  \t}\n\n  \tdefineProperties(query, {\n  \t\tcancel: { value: makeQuery_cancel },\n\n  \t\t_root: { value: ractive },\n  \t\t_sort: { value: sort },\n  \t\t_makeDirty: { value: makeQuery_dirty },\n  \t\t_remove: { value: remove },\n\n  \t\t_dirty: { value: false, writable: true }\n  \t});\n\n  \treturn query;\n  }\n\n  var prototype_findAll = Ractive$findAll;\n  function Ractive$findAll(selector, options) {\n  \tvar liveQueries, query;\n\n  \tif (!this.el) {\n  \t\treturn [];\n  \t}\n\n  \toptions = options || {};\n  \tliveQueries = this._liveQueries;\n\n  \t// Shortcut: if we're maintaining a live query with this\n  \t// selector, we don't need to traverse the parallel DOM\n  \tif (query = liveQueries[selector]) {\n\n  \t\t// Either return the exact same query, or (if not live) a snapshot\n  \t\treturn options && options.live ? query : query.slice();\n  \t}\n\n  \tquery = _makeQuery(this, selector, !!options.live, false);\n\n  \t// Add this to the list of live queries Ractive needs to maintain,\n  \t// if applicable\n  \tif (query.live) {\n  \t\tliveQueries.push(selector);\n  \t\tliveQueries[\"_\" + selector] = query;\n  \t}\n\n  \tthis.fragment.findAll(selector, query);\n  \treturn query;\n  }\n\n  var prototype_findAllComponents = Ractive$findAllComponents;\n  function Ractive$findAllComponents(selector, options) {\n  \tvar liveQueries, query;\n\n  \toptions = options || {};\n  \tliveQueries = this._liveComponentQueries;\n\n  \t// Shortcut: if we're maintaining a live query with this\n  \t// selector, we don't need to traverse the parallel DOM\n  \tif (query = liveQueries[selector]) {\n\n  \t\t// Either return the exact same query, or (if not live) a snapshot\n  \t\treturn options && options.live ? query : query.slice();\n  \t}\n\n  \tquery = _makeQuery(this, selector, !!options.live, true);\n\n  \t// Add this to the list of live queries Ractive needs to maintain,\n  \t// if applicable\n  \tif (query.live) {\n  \t\tliveQueries.push(selector);\n  \t\tliveQueries[\"_\" + selector] = query;\n  \t}\n\n  \tthis.fragment.findAllComponents(selector, query);\n  \treturn query;\n  }\n\n  var prototype_findComponent = Ractive$findComponent;\n\n  function Ractive$findComponent(selector) {\n  \treturn this.fragment.findComponent(selector);\n  }\n\n  var findContainer = Ractive$findContainer;\n\n  function Ractive$findContainer(selector) {\n  \tif (this.container) {\n  \t\tif (this.container.component && this.container.component.name === selector) {\n  \t\t\treturn this.container;\n  \t\t} else {\n  \t\t\treturn this.container.findContainer(selector);\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  var findParent = Ractive$findParent;\n\n  function Ractive$findParent(selector) {\n\n  \tif (this.parent) {\n  \t\tif (this.parent.component && this.parent.component.name === selector) {\n  \t\t\treturn this.parent;\n  \t\t} else {\n  \t\t\treturn this.parent.findParent(selector);\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  var eventStack = {\n  \tenqueue: function (ractive, event) {\n  \t\tif (ractive.event) {\n  \t\t\tractive._eventQueue = ractive._eventQueue || [];\n  \t\t\tractive._eventQueue.push(ractive.event);\n  \t\t}\n  \t\tractive.event = event;\n  \t},\n  \tdequeue: function (ractive) {\n  \t\tif (ractive._eventQueue && ractive._eventQueue.length) {\n  \t\t\tractive.event = ractive._eventQueue.pop();\n  \t\t} else {\n  \t\t\tdelete ractive.event;\n  \t\t}\n  \t}\n  };\n\n  var shared_eventStack = eventStack;\n\n  var shared_fireEvent = fireEvent;\n\n  function fireEvent(ractive, eventName) {\n  \tvar options = arguments[2] === undefined ? {} : arguments[2];\n\n  \tif (!eventName) {\n  \t\treturn;\n  \t}\n\n  \tif (!options.event) {\n  \t\toptions.event = {\n  \t\t\tname: eventName,\n  \t\t\t// until event not included as argument default\n  \t\t\t_noArg: true\n  \t\t};\n  \t} else {\n  \t\toptions.event.name = eventName;\n  \t}\n\n  \tvar eventNames = getKeypath(eventName).wildcardMatches();\n  \tfireEventAs(ractive, eventNames, options.event, options.args, true);\n  }\n\n  function fireEventAs(ractive, eventNames, event, args) {\n  \tvar initialFire = arguments[4] === undefined ? false : arguments[4];\n\n  \tvar subscribers,\n  \t    i,\n  \t    bubble = true;\n\n  \tshared_eventStack.enqueue(ractive, event);\n\n  \tfor (i = eventNames.length; i >= 0; i--) {\n  \t\tsubscribers = ractive._subs[eventNames[i]];\n\n  \t\tif (subscribers) {\n  \t\t\tbubble = notifySubscribers(ractive, subscribers, event, args) && bubble;\n  \t\t}\n  \t}\n\n  \tshared_eventStack.dequeue(ractive);\n\n  \tif (ractive.parent && bubble) {\n\n  \t\tif (initialFire && ractive.component) {\n  \t\t\tvar fullName = ractive.component.name + \".\" + eventNames[eventNames.length - 1];\n  \t\t\teventNames = getKeypath(fullName).wildcardMatches();\n\n  \t\t\tif (event) {\n  \t\t\t\tevent.component = ractive;\n  \t\t\t}\n  \t\t}\n\n  \t\tfireEventAs(ractive.parent, eventNames, event, args);\n  \t}\n  }\n\n  function notifySubscribers(ractive, subscribers, event, args) {\n  \tvar originalEvent = null,\n  \t    stopEvent = false;\n\n  \tif (event && !event._noArg) {\n  \t\targs = [event].concat(args);\n  \t}\n\n  \t// subscribers can be modified inflight, e.g. \"once\" functionality\n  \t// so we need to copy to make sure everyone gets called\n  \tsubscribers = subscribers.slice();\n\n  \tfor (var i = 0, len = subscribers.length; i < len; i += 1) {\n  \t\tif (subscribers[i].apply(ractive, args) === false) {\n  \t\t\tstopEvent = true;\n  \t\t}\n  \t}\n\n  \tif (event && !event._noArg && stopEvent && (originalEvent = event.original)) {\n  \t\toriginalEvent.preventDefault && originalEvent.preventDefault();\n  \t\toriginalEvent.stopPropagation && originalEvent.stopPropagation();\n  \t}\n\n  \treturn !stopEvent;\n  }\n\n  var prototype_fire = Ractive$fire;\n  function Ractive$fire(eventName) {\n\n  \tvar options = {\n  \t\targs: Array.prototype.slice.call(arguments, 1)\n  \t};\n\n  \tshared_fireEvent(this, eventName, options);\n  }\n\n  var prototype_get = Ractive$get;\n  var options = {\n  \tcapture: true, // top-level calls should be intercepted\n  \tnoUnwrap: true, // wrapped values should NOT be unwrapped\n  \tfullRootGet: true // root get should return mappings\n  };\n  function Ractive$get(keypath) {\n  \tvar value;\n\n  \tkeypath = getKeypath(normalise(keypath));\n  \tvalue = this.viewmodel.get(keypath, options);\n\n  \t// Create inter-component binding, if necessary\n  \tif (value === undefined && this.parent && !this.isolated) {\n  \t\tif (shared_resolveRef(this, keypath.str, this.component.parentFragment)) {\n  \t\t\t// creates binding as side-effect, if appropriate\n  \t\t\tvalue = this.viewmodel.get(keypath);\n  \t\t}\n  \t}\n\n  \treturn value;\n  }\n\n  var insert = Ractive$insert;\n\n  var insertHook = new hooks_Hook(\"insert\");\n  function Ractive$insert(target, anchor) {\n  \tif (!this.fragment.rendered) {\n  \t\t// TODO create, and link to, documentation explaining this\n  \t\tthrow new Error(\"The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.\");\n  \t}\n\n  \ttarget = getElement(target);\n  \tanchor = getElement(anchor) || null;\n\n  \tif (!target) {\n  \t\tthrow new Error(\"You must specify a valid target to insert into\");\n  \t}\n\n  \ttarget.insertBefore(this.detach(), anchor);\n  \tthis.el = target;\n\n  \t(target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(this);\n  \tthis.detached = null;\n\n  \tfireInsertHook(this);\n  }\n\n  function fireInsertHook(ractive) {\n  \tinsertHook.fire(ractive);\n\n  \tractive.findAllComponents(\"*\").forEach(function (child) {\n  \t\tfireInsertHook(child.instance);\n  \t});\n  }\n\n  var prototype_merge = Ractive$merge;\n  function Ractive$merge(keypath, array, options) {\n  \tvar currentArray, promise;\n\n  \tkeypath = getKeypath(normalise(keypath));\n  \tcurrentArray = this.viewmodel.get(keypath);\n\n  \t// If either the existing value or the new value isn't an\n  \t// array, just do a regular set\n  \tif (!isArray(currentArray) || !isArray(array)) {\n  \t\treturn this.set(keypath, array, options && options.complete);\n  \t}\n\n  \t// Manage transitions\n  \tpromise = global_runloop.start(this, true);\n  \tthis.viewmodel.merge(keypath, currentArray, array, options);\n  \tglobal_runloop.end();\n\n  \treturn promise;\n  }\n\n  var Observer = function (ractive, keypath, callback, options) {\n  \tthis.root = ractive;\n  \tthis.keypath = keypath;\n  \tthis.callback = callback;\n  \tthis.defer = options.defer;\n\n  \t// default to root as context, but allow it to be overridden\n  \tthis.context = options && options.context ? options.context : ractive;\n  };\n\n  Observer.prototype = {\n  \tinit: function (immediate) {\n  \t\tthis.value = this.root.get(this.keypath.str);\n\n  \t\tif (immediate !== false) {\n  \t\t\tthis.update();\n  \t\t} else {\n  \t\t\tthis.oldValue = this.value;\n  \t\t}\n  \t},\n\n  \tsetValue: function (value) {\n  \t\tvar _this = this;\n\n  \t\tif (!isEqual(value, this.value)) {\n  \t\t\tthis.value = value;\n\n  \t\t\tif (this.defer && this.ready) {\n  \t\t\t\tglobal_runloop.scheduleTask(function () {\n  \t\t\t\t\treturn _this.update();\n  \t\t\t\t});\n  \t\t\t} else {\n  \t\t\t\tthis.update();\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tupdate: function () {\n  \t\t// Prevent infinite loops\n  \t\tif (this.updating) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.updating = true;\n\n  \t\tthis.callback.call(this.context, this.value, this.oldValue, this.keypath.str);\n  \t\tthis.oldValue = this.value;\n\n  \t\tthis.updating = false;\n  \t}\n  };\n\n  var observe_Observer = Observer;\n\n  var observe_getPattern = getPattern;\n  function getPattern(ractive, pattern) {\n  \tvar matchingKeypaths, values;\n\n  \tmatchingKeypaths = getMatchingKeypaths(ractive, pattern);\n\n  \tvalues = {};\n  \tmatchingKeypaths.forEach(function (keypath) {\n  \t\tvalues[keypath.str] = ractive.get(keypath.str);\n  \t});\n\n  \treturn values;\n  }\n\n  var PatternObserver,\n      slice = Array.prototype.slice;\n\n  PatternObserver = function (ractive, keypath, callback, options) {\n  \tthis.root = ractive;\n\n  \tthis.callback = callback;\n  \tthis.defer = options.defer;\n\n  \tthis.keypath = keypath;\n  \tthis.regex = new RegExp(\"^\" + keypath.str.replace(/\\./g, \"\\\\.\").replace(/\\*/g, \"([^\\\\.]+)\") + \"$\");\n  \tthis.values = {};\n\n  \tif (this.defer) {\n  \t\tthis.proxies = [];\n  \t}\n\n  \t// default to root as context, but allow it to be overridden\n  \tthis.context = options && options.context ? options.context : ractive;\n  };\n\n  PatternObserver.prototype = {\n  \tinit: function (immediate) {\n  \t\tvar values, keypath;\n\n  \t\tvalues = observe_getPattern(this.root, this.keypath);\n\n  \t\tif (immediate !== false) {\n  \t\t\tfor (keypath in values) {\n  \t\t\t\tif (values.hasOwnProperty(keypath)) {\n  \t\t\t\t\tthis.update(getKeypath(keypath));\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else {\n  \t\t\tthis.values = values;\n  \t\t}\n  \t},\n\n  \tupdate: function (keypath) {\n  \t\tvar _this = this;\n\n  \t\tvar values;\n\n  \t\tif (keypath.isPattern) {\n  \t\t\tvalues = observe_getPattern(this.root, keypath);\n\n  \t\t\tfor (keypath in values) {\n  \t\t\t\tif (values.hasOwnProperty(keypath)) {\n  \t\t\t\t\tthis.update(getKeypath(keypath));\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// special case - array mutation should not trigger `array.*`\n  \t\t// pattern observer with `array.length`\n  \t\tif (this.root.viewmodel.implicitChanges[keypath.str]) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (this.defer && this.ready) {\n  \t\t\tglobal_runloop.scheduleTask(function () {\n  \t\t\t\treturn _this.getProxy(keypath).update();\n  \t\t\t});\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.reallyUpdate(keypath);\n  \t},\n\n  \treallyUpdate: function (keypath) {\n  \t\tvar keypathStr, value, keys, args;\n\n  \t\tkeypathStr = keypath.str;\n  \t\tvalue = this.root.viewmodel.get(keypath);\n\n  \t\t// Prevent infinite loops\n  \t\tif (this.updating) {\n  \t\t\tthis.values[keypathStr] = value;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.updating = true;\n\n  \t\tif (!isEqual(value, this.values[keypathStr]) || !this.ready) {\n  \t\t\tkeys = slice.call(this.regex.exec(keypathStr), 1);\n  \t\t\targs = [value, this.values[keypathStr], keypathStr].concat(keys);\n\n  \t\t\tthis.values[keypathStr] = value;\n  \t\t\tthis.callback.apply(this.context, args);\n  \t\t}\n\n  \t\tthis.updating = false;\n  \t},\n\n  \tgetProxy: function (keypath) {\n  \t\tvar _this = this;\n\n  \t\tif (!this.proxies[keypath.str]) {\n  \t\t\tthis.proxies[keypath.str] = {\n  \t\t\t\tupdate: function () {\n  \t\t\t\t\treturn _this.reallyUpdate(keypath);\n  \t\t\t\t}\n  \t\t\t};\n  \t\t}\n\n  \t\treturn this.proxies[keypath.str];\n  \t}\n  };\n\n  var observe_PatternObserver = PatternObserver;\n\n  var observe_getObserverFacade = getObserverFacade;\n  var emptyObject = {};\n  function getObserverFacade(ractive, keypath, callback, options) {\n  \tvar observer, isPatternObserver, cancelled;\n\n  \tkeypath = getKeypath(normalise(keypath));\n  \toptions = options || emptyObject;\n\n  \t// pattern observers are treated differently\n  \tif (keypath.isPattern) {\n  \t\tobserver = new observe_PatternObserver(ractive, keypath, callback, options);\n  \t\tractive.viewmodel.patternObservers.push(observer);\n  \t\tisPatternObserver = true;\n  \t} else {\n  \t\tobserver = new observe_Observer(ractive, keypath, callback, options);\n  \t}\n\n  \tobserver.init(options.init);\n  \tractive.viewmodel.register(keypath, observer, isPatternObserver ? \"patternObservers\" : \"observers\");\n\n  \t// This flag allows observers to initialise even with undefined values\n  \tobserver.ready = true;\n\n  \tvar facade = {\n  \t\tcancel: function () {\n  \t\t\tvar index;\n\n  \t\t\tif (cancelled) {\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tif (isPatternObserver) {\n  \t\t\t\tindex = ractive.viewmodel.patternObservers.indexOf(observer);\n\n  \t\t\t\tractive.viewmodel.patternObservers.splice(index, 1);\n  \t\t\t\tractive.viewmodel.unregister(keypath, observer, \"patternObservers\");\n  \t\t\t} else {\n  \t\t\t\tractive.viewmodel.unregister(keypath, observer, \"observers\");\n  \t\t\t}\n  \t\t\tcancelled = true;\n  \t\t}\n  \t};\n\n  \tractive._observers.push(facade);\n  \treturn facade;\n  }\n\n  var observe = Ractive$observe;\n  function Ractive$observe(keypath, callback, options) {\n\n  \tvar observers, map, keypaths, i;\n\n  \t// Allow a map of keypaths to handlers\n  \tif (isObject(keypath)) {\n  \t\toptions = callback;\n  \t\tmap = keypath;\n\n  \t\tobservers = [];\n\n  \t\tfor (keypath in map) {\n  \t\t\tif (map.hasOwnProperty(keypath)) {\n  \t\t\t\tcallback = map[keypath];\n  \t\t\t\tobservers.push(this.observe(keypath, callback, options));\n  \t\t\t}\n  \t\t}\n\n  \t\treturn {\n  \t\t\tcancel: function () {\n  \t\t\t\twhile (observers.length) {\n  \t\t\t\t\tobservers.pop().cancel();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t};\n  \t}\n\n  \t// Allow `ractive.observe( callback )` - i.e. observe entire model\n  \tif (typeof keypath === \"function\") {\n  \t\toptions = callback;\n  \t\tcallback = keypath;\n  \t\tkeypath = \"\";\n\n  \t\treturn observe_getObserverFacade(this, keypath, callback, options);\n  \t}\n\n  \tkeypaths = keypath.split(\" \");\n\n  \t// Single keypath\n  \tif (keypaths.length === 1) {\n  \t\treturn observe_getObserverFacade(this, keypath, callback, options);\n  \t}\n\n  \t// Multiple space-separated keypaths\n  \tobservers = [];\n\n  \ti = keypaths.length;\n  \twhile (i--) {\n  \t\tkeypath = keypaths[i];\n\n  \t\tif (keypath) {\n  \t\t\tobservers.push(observe_getObserverFacade(this, keypath, callback, options));\n  \t\t}\n  \t}\n\n  \treturn {\n  \t\tcancel: function () {\n  \t\t\twhile (observers.length) {\n  \t\t\t\tobservers.pop().cancel();\n  \t\t\t}\n  \t\t}\n  \t};\n  }\n\n  var observeOnce = Ractive$observeOnce;\n\n  function Ractive$observeOnce(property, callback, options) {\n\n  \tvar observer = this.observe(property, function () {\n  \t\tcallback.apply(this, arguments);\n  \t\tobserver.cancel();\n  \t}, { init: false, defer: options && options.defer });\n\n  \treturn observer;\n  }\n\n  var shared_trim = function (str) {\n    return str.trim();\n  };\n\n  var notEmptyString = function (str) {\n    return str !== \"\";\n  };\n\n  var off = Ractive$off;\n  function Ractive$off(eventName, callback) {\n  \tvar _this = this;\n\n  \tvar eventNames;\n\n  \t// if no arguments specified, remove all callbacks\n  \tif (!eventName) {\n  \t\t// TODO use this code instead, once the following issue has been resolved\n  \t\t// in PhantomJS (tests are unpassable otherwise!)\n  \t\t// https://github.com/ariya/phantomjs/issues/11856\n  \t\t// defineProperty( this, '_subs', { value: create( null ), configurable: true });\n  \t\tfor (eventName in this._subs) {\n  \t\t\tdelete this._subs[eventName];\n  \t\t}\n  \t} else {\n  \t\t// Handle multiple space-separated event names\n  \t\teventNames = eventName.split(\" \").map(shared_trim).filter(notEmptyString);\n\n  \t\teventNames.forEach(function (eventName) {\n  \t\t\tvar subscribers, index;\n\n  \t\t\t// If we have subscribers for this event...\n  \t\t\tif (subscribers = _this._subs[eventName]) {\n  \t\t\t\t// ...if a callback was specified, only remove that\n  \t\t\t\tif (callback) {\n  \t\t\t\t\tindex = subscribers.indexOf(callback);\n  \t\t\t\t\tif (index !== -1) {\n  \t\t\t\t\t\tsubscribers.splice(index, 1);\n  \t\t\t\t\t}\n  \t\t\t\t}\n\n  \t\t\t\t// ...otherwise remove all callbacks\n  \t\t\t\telse {\n  \t\t\t\t\t_this._subs[eventName] = [];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t});\n  \t}\n\n  \treturn this;\n  }\n\n  var on = Ractive$on;\n  function Ractive$on(eventName, callback) {\n  \tvar _this = this;\n\n  \tvar listeners, n, eventNames;\n\n  \t// allow mutliple listeners to be bound in one go\n  \tif (typeof eventName === \"object\") {\n  \t\tlisteners = [];\n\n  \t\tfor (n in eventName) {\n  \t\t\tif (eventName.hasOwnProperty(n)) {\n  \t\t\t\tlisteners.push(this.on(n, eventName[n]));\n  \t\t\t}\n  \t\t}\n\n  \t\treturn {\n  \t\t\tcancel: function () {\n  \t\t\t\tvar listener;\n\n  \t\t\t\twhile (listener = listeners.pop()) {\n  \t\t\t\t\tlistener.cancel();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t};\n  \t}\n\n  \t// Handle multiple space-separated event names\n  \teventNames = eventName.split(\" \").map(shared_trim).filter(notEmptyString);\n\n  \teventNames.forEach(function (eventName) {\n  \t\t(_this._subs[eventName] || (_this._subs[eventName] = [])).push(callback);\n  \t});\n\n  \treturn {\n  \t\tcancel: function () {\n  \t\t\treturn _this.off(eventName, callback);\n  \t\t}\n  \t};\n  }\n\n  var once = Ractive$once;\n\n  function Ractive$once(eventName, handler) {\n\n  \tvar listener = this.on(eventName, function () {\n  \t\thandler.apply(this, arguments);\n  \t\tlistener.cancel();\n  \t});\n\n  \t// so we can still do listener.cancel() manually\n  \treturn listener;\n  }\n\n  // This function takes an array, the name of a mutator method, and the\n  // arguments to call that mutator method with, and returns an array that\n  // maps the old indices to their new indices.\n\n  // So if you had something like this...\n  //\n  //     array = [ 'a', 'b', 'c', 'd' ];\n  //     array.push( 'e' );\n  //\n  // ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n  // have changed. If you then did this...\n  //\n  //     array.unshift( 'z' );\n  //\n  // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n  // one higher to make room for the 'z'. If you removed an item, the new index\n  // would be -1...\n  //\n  //     array.splice( 2, 2 );\n  //\n  // ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n  //\n  // This information is used to enable fast, non-destructive shuffling of list\n  // sections when you do e.g. `ractive.splice( 'items', 2, 2 );\n\n  var shared_getNewIndices = getNewIndices;\n\n  function getNewIndices(array, methodName, args) {\n  \tvar spliceArguments,\n  \t    len,\n  \t    newIndices = [],\n  \t    removeStart,\n  \t    removeEnd,\n  \t    balance,\n  \t    i;\n\n  \tspliceArguments = getSpliceEquivalent(array, methodName, args);\n\n  \tif (!spliceArguments) {\n  \t\treturn null; // TODO support reverse and sort?\n  \t}\n\n  \tlen = array.length;\n  \tbalance = spliceArguments.length - 2 - spliceArguments[1];\n\n  \tremoveStart = Math.min(len, spliceArguments[0]);\n  \tremoveEnd = removeStart + spliceArguments[1];\n\n  \tfor (i = 0; i < removeStart; i += 1) {\n  \t\tnewIndices.push(i);\n  \t}\n\n  \tfor (; i < removeEnd; i += 1) {\n  \t\tnewIndices.push(-1);\n  \t}\n\n  \tfor (; i < len; i += 1) {\n  \t\tnewIndices.push(i + balance);\n  \t}\n\n  \t// there is a net shift for the rest of the array starting with index + balance\n  \tif (balance !== 0) {\n  \t\tnewIndices.touchedFrom = spliceArguments[0];\n  \t} else {\n  \t\tnewIndices.touchedFrom = array.length;\n  \t}\n\n  \treturn newIndices;\n  }\n\n  // The pop, push, shift an unshift methods can all be represented\n  // as an equivalent splice\n  function getSpliceEquivalent(array, methodName, args) {\n  \tswitch (methodName) {\n  \t\tcase \"splice\":\n  \t\t\tif (args[0] !== undefined && args[0] < 0) {\n  \t\t\t\targs[0] = array.length + Math.max(args[0], -array.length);\n  \t\t\t}\n\n  \t\t\twhile (args.length < 2) {\n  \t\t\t\targs.push(0);\n  \t\t\t}\n\n  \t\t\t// ensure we only remove elements that exist\n  \t\t\targs[1] = Math.min(args[1], array.length - args[0]);\n\n  \t\t\treturn args;\n\n  \t\tcase \"sort\":\n  \t\tcase \"reverse\":\n  \t\t\treturn null;\n\n  \t\tcase \"pop\":\n  \t\t\tif (array.length) {\n  \t\t\t\treturn [array.length - 1, 1];\n  \t\t\t}\n  \t\t\treturn [0, 0];\n\n  \t\tcase \"push\":\n  \t\t\treturn [array.length, 0].concat(args);\n\n  \t\tcase \"shift\":\n  \t\t\treturn [0, array.length ? 1 : 0];\n\n  \t\tcase \"unshift\":\n  \t\t\treturn [0, 0].concat(args);\n  \t}\n  }\n\n  var arrayProto = Array.prototype;\n\n  var makeArrayMethod = function (methodName) {\n  \treturn function (keypath) {\n  \t\tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\t\targs[_key - 1] = arguments[_key];\n  \t\t}\n\n  \t\tvar array,\n  \t\t    newIndices = [],\n  \t\t    len,\n  \t\t    promise,\n  \t\t    result;\n\n  \t\tkeypath = getKeypath(normalise(keypath));\n\n  \t\tarray = this.viewmodel.get(keypath);\n  \t\tlen = array.length;\n\n  \t\tif (!isArray(array)) {\n  \t\t\tthrow new Error(\"Called ractive.\" + methodName + \"('\" + keypath.str + \"'), but '\" + keypath.str + \"' does not refer to an array\");\n  \t\t}\n\n  \t\tnewIndices = shared_getNewIndices(array, methodName, args);\n\n  \t\tresult = arrayProto[methodName].apply(array, args);\n  \t\tpromise = global_runloop.start(this, true).then(function () {\n  \t\t\treturn result;\n  \t\t});\n\n  \t\tif (!!newIndices) {\n  \t\t\tthis.viewmodel.smartUpdate(keypath, array, newIndices);\n  \t\t} else {\n  \t\t\tthis.viewmodel.mark(keypath);\n  \t\t}\n\n  \t\tglobal_runloop.end();\n\n  \t\treturn promise;\n  \t};\n  };\n\n  var pop = makeArrayMethod(\"pop\");\n\n  var push = makeArrayMethod(\"push\");\n\n  var css,\n      update,\n      styleElement,\n      head,\n      styleSheet,\n      inDom,\n      global_css__prefix = \"/* Ractive.js component styles */\\n\",\n      styles = [],\n      dirty = false;\n\n  if (!isClient) {\n  \t// TODO handle encapsulated CSS in server-rendered HTML!\n  \tcss = {\n  \t\tadd: noop,\n  \t\tapply: noop\n  \t};\n  } else {\n  \tstyleElement = document.createElement(\"style\");\n  \tstyleElement.type = \"text/css\";\n\n  \thead = document.getElementsByTagName(\"head\")[0];\n\n  \tinDom = false;\n\n  \t// Internet Exploder won't let you use styleSheet.innerHTML - we have to\n  \t// use styleSheet.cssText instead\n  \tstyleSheet = styleElement.styleSheet;\n\n  \tupdate = function () {\n  \t\tvar css = global_css__prefix + styles.map(function (s) {\n  \t\t\treturn \"\\n/* {\" + s.id + \"} */\\n\" + s.styles;\n  \t\t}).join(\"\\n\");\n\n  \t\tif (styleSheet) {\n  \t\t\tstyleSheet.cssText = css;\n  \t\t} else {\n  \t\t\tstyleElement.innerHTML = css;\n  \t\t}\n\n  \t\tif (!inDom) {\n  \t\t\thead.appendChild(styleElement);\n  \t\t\tinDom = true;\n  \t\t}\n  \t};\n\n  \tcss = {\n  \t\tadd: function (s) {\n  \t\t\tstyles.push(s);\n  \t\t\tdirty = true;\n  \t\t},\n\n  \t\tapply: function () {\n  \t\t\tif (dirty) {\n  \t\t\t\tupdate();\n  \t\t\t\tdirty = false;\n  \t\t\t}\n  \t\t}\n  \t};\n  }\n\n  var global_css = css;\n\n  var prototype_render = Ractive$render;\n\n  var renderHook = new hooks_Hook(\"render\"),\n      completeHook = new hooks_Hook(\"complete\");\n  function Ractive$render(target, anchor) {\n  \tvar _this = this;\n\n  \tvar promise, instances, transitionsEnabled;\n\n  \t// if `noIntro` is `true`, temporarily disable transitions\n  \ttransitionsEnabled = this.transitionsEnabled;\n  \tif (this.noIntro) {\n  \t\tthis.transitionsEnabled = false;\n  \t}\n\n  \tpromise = global_runloop.start(this, true);\n  \tglobal_runloop.scheduleTask(function () {\n  \t\treturn renderHook.fire(_this);\n  \t}, true);\n\n  \tif (this.fragment.rendered) {\n  \t\tthrow new Error(\"You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first\");\n  \t}\n\n  \ttarget = getElement(target) || this.el;\n  \tanchor = getElement(anchor) || this.anchor;\n\n  \tthis.el = target;\n  \tthis.anchor = anchor;\n\n  \tif (!this.append && target) {\n  \t\t// Teardown any existing instances *before* trying to set up the new one -\n  \t\t// avoids certain weird bugs\n  \t\tvar others = target.__ractive_instances__;\n  \t\tif (others && others.length) {\n  \t\t\tremoveOtherInstances(others);\n  \t\t}\n\n  \t\t// make sure we are the only occupants\n  \t\ttarget.innerHTML = \"\"; // TODO is this quicker than removeChild? Initial research inconclusive\n  \t}\n\n  \tif (this.cssId) {\n  \t\t// ensure encapsulated CSS is up-to-date\n  \t\tglobal_css.apply();\n  \t}\n\n  \tif (target) {\n  \t\tif (!(instances = target.__ractive_instances__)) {\n  \t\t\ttarget.__ractive_instances__ = [this];\n  \t\t} else {\n  \t\t\tinstances.push(this);\n  \t\t}\n\n  \t\tif (anchor) {\n  \t\t\ttarget.insertBefore(this.fragment.render(), anchor);\n  \t\t} else {\n  \t\t\ttarget.appendChild(this.fragment.render());\n  \t\t}\n  \t}\n\n  \tglobal_runloop.end();\n\n  \tthis.transitionsEnabled = transitionsEnabled;\n\n  \treturn promise.then(function () {\n  \t\treturn completeHook.fire(_this);\n  \t});\n  }\n\n  function removeOtherInstances(others) {\n  \tothers.splice(0, others.length).forEach(teardown);\n  }\n\n  var adaptConfigurator = {\n  \textend: function (Parent, proto, options) {\n  \t\tproto.adapt = custom_adapt__combine(proto.adapt, ensureArray(options.adapt));\n  \t},\n\n  \tinit: function () {}\n  };\n\n  var custom_adapt = adaptConfigurator;\n\n  function custom_adapt__combine(a, b) {\n  \tvar c = a.slice(),\n  \t    i = b.length;\n\n  \twhile (i--) {\n  \t\tif (! ~c.indexOf(b[i])) {\n  \t\t\tc.push(b[i]);\n  \t\t}\n  \t}\n\n  \treturn c;\n  }\n\n  var transform = transformCss;\n\n  var selectorsPattern = /(?:^|\\})?\\s*([^\\{\\}]+)\\s*\\{/g,\n      commentsPattern = /\\/\\*.*?\\*\\//g,\n      selectorUnitPattern = /((?:(?:\\[[^\\]+]\\])|(?:[^\\s\\+\\>\\~:]))+)((?::[^\\s\\+\\>\\~\\(]+(?:\\([^\\)]+\\))?)?\\s*[\\s\\+\\>\\~]?)\\s*/g,\n      mediaQueryPattern = /^@media/,\n      dataRvcGuidPattern = /\\[data-ractive-css~=\"\\{[a-z0-9-]+\\}\"]/g;\n  function transformCss(css, id) {\n  \tvar transformed, dataAttr, addGuid;\n\n  \tdataAttr = \"[data-ractive-css~=\\\"{\" + id + \"}\\\"]\";\n\n  \taddGuid = function (selector) {\n  \t\tvar selectorUnits,\n  \t\t    match,\n  \t\t    unit,\n  \t\t    base,\n  \t\t    prepended,\n  \t\t    appended,\n  \t\t    i,\n  \t\t    transformed = [];\n\n  \t\tselectorUnits = [];\n\n  \t\twhile (match = selectorUnitPattern.exec(selector)) {\n  \t\t\tselectorUnits.push({\n  \t\t\t\tstr: match[0],\n  \t\t\t\tbase: match[1],\n  \t\t\t\tmodifiers: match[2]\n  \t\t\t});\n  \t\t}\n\n  \t\t// For each simple selector within the selector, we need to create a version\n  \t\t// that a) combines with the id, and b) is inside the id\n  \t\tbase = selectorUnits.map(extractString);\n\n  \t\ti = selectorUnits.length;\n  \t\twhile (i--) {\n  \t\t\tappended = base.slice();\n\n  \t\t\t// Pseudo-selectors should go after the attribute selector\n  \t\t\tunit = selectorUnits[i];\n  \t\t\tappended[i] = unit.base + dataAttr + unit.modifiers || \"\";\n\n  \t\t\tprepended = base.slice();\n  \t\t\tprepended[i] = dataAttr + \" \" + prepended[i];\n\n  \t\t\ttransformed.push(appended.join(\" \"), prepended.join(\" \"));\n  \t\t}\n\n  \t\treturn transformed.join(\", \");\n  \t};\n\n  \tif (dataRvcGuidPattern.test(css)) {\n  \t\ttransformed = css.replace(dataRvcGuidPattern, dataAttr);\n  \t} else {\n  \t\ttransformed = css.replace(commentsPattern, \"\").replace(selectorsPattern, function (match, $1) {\n  \t\t\tvar selectors, transformed;\n\n  \t\t\t// don't transform media queries!\n  \t\t\tif (mediaQueryPattern.test($1)) return match;\n\n  \t\t\tselectors = $1.split(\",\").map(trim);\n  \t\t\ttransformed = selectors.map(addGuid).join(\", \") + \" \";\n\n  \t\t\treturn match.replace($1, transformed);\n  \t\t});\n  \t}\n\n  \treturn transformed;\n  }\n\n  function trim(str) {\n  \tif (str.trim) {\n  \t\treturn str.trim();\n  \t}\n\n  \treturn str.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");\n  }\n\n  function extractString(unit) {\n  \treturn unit.str;\n  }\n\n  var css_css__uid = 1;\n\n  var cssConfigurator = {\n  \tname: \"css\",\n\n  \textend: function (Parent, proto, options) {\n  \t\tif (options.css) {\n  \t\t\tvar id = css_css__uid++;\n  \t\t\tvar styles = options.noCssTransform ? options.css : transform(options.css, id);\n\n  \t\t\tproto.cssId = id;\n  \t\t\tglobal_css.add({ id: id, styles: styles });\n  \t\t}\n  \t},\n\n  \tinit: function () {}\n  };\n\n  var css_css = cssConfigurator;\n\n  function validate(data) {\n  \t// Warn if userOptions.data is a non-POJO\n  \tif (data && data.constructor !== Object) {\n  \t\tif (typeof data === \"function\") {} else if (typeof data !== \"object\") {\n  \t\t\tfatal(\"data option must be an object or a function, `\" + data + \"` is not valid\");\n  \t\t} else {\n  \t\t\twarnIfDebug(\"If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged\");\n  \t\t}\n  \t}\n  }\n\n  var dataConfigurator = {\n  \tname: \"data\",\n\n  \textend: function (Parent, proto, options) {\n  \t\tvar key = undefined,\n  \t\t    value = undefined;\n\n  \t\t// check for non-primitives, which could cause mutation-related bugs\n  \t\tif (options.data && isObject(options.data)) {\n  \t\t\tfor (key in options.data) {\n  \t\t\t\tvalue = options.data[key];\n\n  \t\t\t\tif (value && typeof value === \"object\") {\n  \t\t\t\t\tif (isObject(value) || isArray(value)) {\n  \t\t\t\t\t\twarnIfDebug(\"Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\\n\\n  // this...\\n  data: function () {\\n    return {\\n      myObject: {}\\n    };\\n  })\\n\\n  // instead of this:\\n  data: {\\n    myObject: {}\\n  }\");\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tproto.data = custom_data__combine(proto.data, options.data);\n  \t},\n\n  \tinit: function (Parent, ractive, options) {\n  \t\tvar result = custom_data__combine(Parent.prototype.data, options.data);\n\n  \t\tif (typeof result === \"function\") {\n  \t\t\tresult = result.call(ractive);\n  \t\t}\n\n  \t\treturn result || {};\n  \t},\n\n  \treset: function (ractive) {\n  \t\tvar result = this.init(ractive.constructor, ractive, ractive.viewmodel);\n\n  \t\tractive.viewmodel.reset(result);\n  \t\treturn true;\n  \t}\n  };\n\n  var custom_data = dataConfigurator;\n\n  function custom_data__combine(parentValue, childValue) {\n  \tvalidate(childValue);\n\n  \tvar parentIsFn = typeof parentValue === \"function\";\n  \tvar childIsFn = typeof childValue === \"function\";\n\n  \t// Very important, otherwise child instance can become\n  \t// the default data object on Ractive or a component.\n  \t// then ractive.set() ends up setting on the prototype!\n  \tif (!childValue && !parentIsFn) {\n  \t\tchildValue = {};\n  \t}\n\n  \t// Fast path, where we just need to copy properties from\n  \t// parent to child\n  \tif (!parentIsFn && !childIsFn) {\n  \t\treturn fromProperties(childValue, parentValue);\n  \t}\n\n  \treturn function () {\n  \t\tvar child = childIsFn ? callDataFunction(childValue, this) : childValue;\n  \t\tvar parent = parentIsFn ? callDataFunction(parentValue, this) : parentValue;\n\n  \t\treturn fromProperties(child, parent);\n  \t};\n  }\n\n  function callDataFunction(fn, context) {\n  \tvar data = fn.call(context);\n\n  \tif (!data) return;\n\n  \tif (typeof data !== \"object\") {\n  \t\tfatal(\"Data function must return an object\");\n  \t}\n\n  \tif (data.constructor !== Object) {\n  \t\twarnOnceIfDebug(\"Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged\");\n  \t}\n\n  \treturn data;\n  }\n\n  function fromProperties(primary, secondary) {\n  \tif (primary && secondary) {\n  \t\tfor (var key in secondary) {\n  \t\t\tif (!(key in primary)) {\n  \t\t\t\tprimary[key] = secondary[key];\n  \t\t\t}\n  \t\t}\n\n  \t\treturn primary;\n  \t}\n\n  \treturn primary || secondary;\n  }\n\n  // TODO do we need to support this in the new Ractive() case?\n\n  var Parser,\n      ParseError,\n      parse_Parser__leadingWhitespace = /^\\s+/;\n\n  ParseError = function (message) {\n  \tthis.name = \"ParseError\";\n  \tthis.message = message;\n  \ttry {\n  \t\tthrow new Error(message);\n  \t} catch (e) {\n  \t\tthis.stack = e.stack;\n  \t}\n  };\n\n  ParseError.prototype = Error.prototype;\n\n  Parser = function (str, options) {\n  \tvar items,\n  \t    item,\n  \t    lineStart = 0;\n\n  \tthis.str = str;\n  \tthis.options = options || {};\n  \tthis.pos = 0;\n\n  \tthis.lines = this.str.split(\"\\n\");\n  \tthis.lineEnds = this.lines.map(function (line) {\n  \t\tvar lineEnd = lineStart + line.length + 1; // +1 for the newline\n\n  \t\tlineStart = lineEnd;\n  \t\treturn lineEnd;\n  \t}, 0);\n\n  \t// Custom init logic\n  \tif (this.init) this.init(str, options);\n\n  \titems = [];\n\n  \twhile (this.pos < this.str.length && (item = this.read())) {\n  \t\titems.push(item);\n  \t}\n\n  \tthis.leftover = this.remaining();\n  \tthis.result = this.postProcess ? this.postProcess(items, options) : items;\n  };\n\n  Parser.prototype = {\n  \tread: function (converters) {\n  \t\tvar pos, i, len, item;\n\n  \t\tif (!converters) converters = this.converters;\n\n  \t\tpos = this.pos;\n\n  \t\tlen = converters.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\tthis.pos = pos; // reset for each attempt\n\n  \t\t\tif (item = converters[i](this)) {\n  \t\t\t\treturn item;\n  \t\t\t}\n  \t\t}\n\n  \t\treturn null;\n  \t},\n\n  \tgetLinePos: function (char) {\n  \t\tvar lineNum = 0,\n  \t\t    lineStart = 0,\n  \t\t    columnNum;\n\n  \t\twhile (char >= this.lineEnds[lineNum]) {\n  \t\t\tlineStart = this.lineEnds[lineNum];\n  \t\t\tlineNum += 1;\n  \t\t}\n\n  \t\tcolumnNum = char - lineStart;\n  \t\treturn [lineNum + 1, columnNum + 1, char]; // line/col should be one-based, not zero-based!\n  \t},\n\n  \terror: function (message) {\n  \t\tvar pos = this.getLinePos(this.pos);\n  \t\tvar lineNum = pos[0];\n  \t\tvar columnNum = pos[1];\n\n  \t\tvar line = this.lines[pos[0] - 1];\n  \t\tvar numTabs = 0;\n  \t\tvar annotation = line.replace(/\\t/g, function (match, char) {\n  \t\t\tif (char < pos[1]) {\n  \t\t\t\tnumTabs += 1;\n  \t\t\t}\n\n  \t\t\treturn \"  \";\n  \t\t}) + \"\\n\" + new Array(pos[1] + numTabs).join(\" \") + \"^----\";\n\n  \t\tvar error = new ParseError(\"\" + message + \" at line \" + lineNum + \" character \" + columnNum + \":\\n\" + annotation);\n\n  \t\terror.line = pos[0];\n  \t\terror.character = pos[1];\n  \t\terror.shortMessage = message;\n\n  \t\tthrow error;\n  \t},\n\n  \tmatchString: function (string) {\n  \t\tif (this.str.substr(this.pos, string.length) === string) {\n  \t\t\tthis.pos += string.length;\n  \t\t\treturn string;\n  \t\t}\n  \t},\n\n  \tmatchPattern: function (pattern) {\n  \t\tvar match;\n\n  \t\tif (match = pattern.exec(this.remaining())) {\n  \t\t\tthis.pos += match[0].length;\n  \t\t\treturn match[1] || match[0];\n  \t\t}\n  \t},\n\n  \tallowWhitespace: function () {\n  \t\tthis.matchPattern(parse_Parser__leadingWhitespace);\n  \t},\n\n  \tremaining: function () {\n  \t\treturn this.str.substring(this.pos);\n  \t},\n\n  \tnextChar: function () {\n  \t\treturn this.str.charAt(this.pos);\n  \t}\n  };\n\n  Parser.extend = function (proto) {\n  \tvar Parent = this,\n  \t    Child,\n  \t    key;\n\n  \tChild = function (str, options) {\n  \t\tParser.call(this, str, options);\n  \t};\n\n  \tChild.prototype = create(Parent.prototype);\n\n  \tfor (key in proto) {\n  \t\tif (hasOwn.call(proto, key)) {\n  \t\t\tChild.prototype[key] = proto[key];\n  \t\t}\n  \t}\n\n  \tChild.extend = Parser.extend;\n  \treturn Child;\n  };\n\n  var parse_Parser = Parser;\n\n  var TEXT = 1;\n  var INTERPOLATOR = 2;\n  var TRIPLE = 3;\n  var SECTION = 4;\n  var INVERTED = 5;\n  var CLOSING = 6;\n  var ELEMENT = 7;\n  var PARTIAL = 8;\n  var COMMENT = 9;\n  var DELIMCHANGE = 10;\n  var ATTRIBUTE = 13;\n  var CLOSING_TAG = 14;\n  var COMPONENT = 15;\n  var YIELDER = 16;\n  var INLINE_PARTIAL = 17;\n  var DOCTYPE = 18;\n\n  var NUMBER_LITERAL = 20;\n  var STRING_LITERAL = 21;\n  var ARRAY_LITERAL = 22;\n  var OBJECT_LITERAL = 23;\n  var BOOLEAN_LITERAL = 24;\n  var REGEXP_LITERAL = 25;\n\n  var GLOBAL = 26;\n  var KEY_VALUE_PAIR = 27;\n\n  var REFERENCE = 30;\n  var REFINEMENT = 31;\n  var MEMBER = 32;\n  var PREFIX_OPERATOR = 33;\n  var BRACKETED = 34;\n  var CONDITIONAL = 35;\n  var INFIX_OPERATOR = 36;\n\n  var INVOCATION = 40;\n\n  var SECTION_IF = 50;\n  var SECTION_UNLESS = 51;\n  var SECTION_EACH = 52;\n  var SECTION_WITH = 53;\n  var SECTION_IF_WITH = 54;\n\n  var ELSE = 60;\n  var ELSEIF = 61;\n\n  var mustache_readDelimiterChange = readDelimiterChange;\n  var delimiterChangePattern = /^[^\\s=]+/,\n      whitespacePattern = /^\\s+/;\n  function readDelimiterChange(parser) {\n  \tvar start, opening, closing;\n\n  \tif (!parser.matchString(\"=\")) {\n  \t\treturn null;\n  \t}\n\n  \tstart = parser.pos;\n\n  \t// allow whitespace before new opening delimiter\n  \tparser.allowWhitespace();\n\n  \topening = parser.matchPattern(delimiterChangePattern);\n  \tif (!opening) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \t// allow whitespace (in fact, it's necessary...)\n  \tif (!parser.matchPattern(whitespacePattern)) {\n  \t\treturn null;\n  \t}\n\n  \tclosing = parser.matchPattern(delimiterChangePattern);\n  \tif (!closing) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \t// allow whitespace before closing '='\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"=\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \treturn [opening, closing];\n  }\n\n  var readRegexpLiteral = readRegexpLiteral__readNumberLiteral;\n  var regexpPattern = /^(\\/(?:[^\\n\\r\\u2028\\u2029/\\\\[]|\\\\.|\\[(?:[^\\n\\r\\u2028\\u2029\\]\\\\]|\\\\.)*])+\\/(?:([gimuy])(?![a-z]*\\2))*(?![a-zA-Z_$0-9]))/;\n  function readRegexpLiteral__readNumberLiteral(parser) {\n  \tvar result;\n\n  \tif (result = parser.matchPattern(regexpPattern)) {\n  \t\treturn {\n  \t\t\tt: REGEXP_LITERAL,\n  \t\t\tv: result\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  var converters_readMustache = readMustache;\n\n  var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };\n  function readMustache(parser) {\n  \tvar mustache, i;\n\n  \t// If we're inside a <script> or <style> tag, and we're not\n  \t// interpolating, bug out\n  \tif (parser.interpolate[parser.inside] === false) {\n  \t\treturn null;\n  \t}\n\n  \tfor (i = 0; i < parser.tags.length; i += 1) {\n  \t\tif (mustache = readMustacheOfType(parser, parser.tags[i])) {\n  \t\t\treturn mustache;\n  \t\t}\n  \t}\n  }\n\n  function readMustacheOfType(parser, tag) {\n  \tvar start, mustache, reader, i;\n\n  \tstart = parser.pos;\n\n  \tif (parser.matchString(\"\\\\\" + tag.open)) {\n  \t\tif (start === 0 || parser.str[start - 1] !== \"\\\\\") {\n  \t\t\treturn tag.open;\n  \t\t}\n  \t} else if (!parser.matchString(tag.open)) {\n  \t\treturn null;\n  \t}\n\n  \t// delimiter change?\n  \tif (mustache = mustache_readDelimiterChange(parser)) {\n  \t\t// find closing delimiter or abort...\n  \t\tif (!parser.matchString(tag.close)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\t// ...then make the switch\n  \t\ttag.open = mustache[0];\n  \t\ttag.close = mustache[1];\n  \t\tparser.sortMustacheTags();\n\n  \t\treturn delimiterChangeToken;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \t// illegal section closer\n  \tif (parser.matchString(\"/\")) {\n  \t\tparser.pos -= 1;\n  \t\tvar rewind = parser.pos;\n  \t\tif (!readRegexpLiteral(parser)) {\n  \t\t\tparser.pos = rewind - tag.close.length;\n  \t\t\tparser.error(\"Attempted to close a section that wasn't open\");\n  \t\t} else {\n  \t\t\tparser.pos = rewind;\n  \t\t}\n  \t}\n\n  \tfor (i = 0; i < tag.readers.length; i += 1) {\n  \t\treader = tag.readers[i];\n\n  \t\tif (mustache = reader(parser, tag)) {\n  \t\t\tif (tag.isStatic) {\n  \t\t\t\tmustache.s = true; // TODO make this `1` instead - more compact\n  \t\t\t}\n\n  \t\t\tif (parser.includeLinePositions) {\n  \t\t\t\tmustache.p = parser.getLinePos(start);\n  \t\t\t}\n\n  \t\t\treturn mustache;\n  \t\t}\n  \t}\n\n  \tparser.pos = start;\n  \treturn null;\n  }\n\n  var expectedExpression = \"Expected a JavaScript expression\";\n  var expectedParen = \"Expected closing paren\";\n\n  var literal_readNumberLiteral = literal_readNumberLiteral__readNumberLiteral;\n  var literal_readNumberLiteral__numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n  function literal_readNumberLiteral__readNumberLiteral(parser) {\n  \tvar result;\n\n  \tif (result = parser.matchPattern(literal_readNumberLiteral__numberPattern)) {\n  \t\treturn {\n  \t\t\tt: NUMBER_LITERAL,\n  \t\t\tv: result\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  var literal_readBooleanLiteral = readBooleanLiteral;\n  function readBooleanLiteral(parser) {\n  \tvar remaining = parser.remaining();\n\n  \tif (remaining.substr(0, 4) === \"true\") {\n  \t\tparser.pos += 4;\n  \t\treturn {\n  \t\t\tt: BOOLEAN_LITERAL,\n  \t\t\tv: \"true\"\n  \t\t};\n  \t}\n\n  \tif (remaining.substr(0, 5) === \"false\") {\n  \t\tparser.pos += 5;\n  \t\treturn {\n  \t\t\tt: BOOLEAN_LITERAL,\n  \t\t\tv: \"false\"\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;\n\n  // Match one or more characters until: \", ', \\, or EOL/EOF.\n  // EOL/EOF is written as (?!.) (meaning there's no non-newline char next).\n  stringMiddlePattern = /^(?=.)[^\"'\\\\]+?(?:(?!.)|(?=[\"'\\\\]))/;\n\n  // Match one escape sequence, including the backslash.\n  escapeSequencePattern = /^\\\\(?:['\"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\n  // Match one ES5 line continuation (backslash + line terminator).\n  lineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\n  // Helper for defining getDoubleQuotedString and getSingleQuotedString.\n  var makeQuotedStringMatcher = function (okQuote) {\n  \treturn function (parser) {\n  \t\tvar start, literal, done, next;\n\n  \t\tstart = parser.pos;\n  \t\tliteral = \"\\\"\";\n  \t\tdone = false;\n\n  \t\twhile (!done) {\n  \t\t\tnext = parser.matchPattern(stringMiddlePattern) || parser.matchPattern(escapeSequencePattern) || parser.matchString(okQuote);\n  \t\t\tif (next) {\n  \t\t\t\tif (next === \"\\\"\") {\n  \t\t\t\t\tliteral += \"\\\\\\\"\";\n  \t\t\t\t} else if (next === \"\\\\'\") {\n  \t\t\t\t\tliteral += \"'\";\n  \t\t\t\t} else {\n  \t\t\t\t\tliteral += next;\n  \t\t\t\t}\n  \t\t\t} else {\n  \t\t\t\tnext = parser.matchPattern(lineContinuationPattern);\n  \t\t\t\tif (next) {\n  \t\t\t\t\t// convert \\(newline-like) into a \\u escape, which is allowed in JSON\n  \t\t\t\t\tliteral += \"\\\\u\" + (\"000\" + next.charCodeAt(1).toString(16)).slice(-4);\n  \t\t\t\t} else {\n  \t\t\t\t\tdone = true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tliteral += \"\\\"\";\n\n  \t\t// use JSON.parse to interpret escapes\n  \t\treturn JSON.parse(literal);\n  \t};\n  };\n\n  var getSingleQuotedString = makeQuotedStringMatcher(\"\\\"\");\n  var getDoubleQuotedString = makeQuotedStringMatcher(\"'\");\n\n  var readStringLiteral = function (parser) {\n  \tvar start, string;\n\n  \tstart = parser.pos;\n\n  \tif (parser.matchString(\"\\\"\")) {\n  \t\tstring = getDoubleQuotedString(parser);\n\n  \t\tif (!parser.matchString(\"\\\"\")) {\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn {\n  \t\t\tt: STRING_LITERAL,\n  \t\t\tv: string\n  \t\t};\n  \t}\n\n  \tif (parser.matchString(\"'\")) {\n  \t\tstring = getSingleQuotedString(parser);\n\n  \t\tif (!parser.matchString(\"'\")) {\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn {\n  \t\t\tt: STRING_LITERAL,\n  \t\t\tv: string\n  \t\t};\n  \t}\n\n  \treturn null;\n  };\n\n  var patterns__name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;\n\n  // http://mathiasbynens.be/notes/javascript-properties\n  // can be any name, string literal, or number literal\n  var shared_readKey = readKey;\n  var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n  function readKey(parser) {\n  \tvar token;\n\n  \tif (token = readStringLiteral(parser)) {\n  \t\treturn identifier.test(token.v) ? token.v : \"\\\"\" + token.v.replace(/\"/g, \"\\\\\\\"\") + \"\\\"\";\n  \t}\n\n  \tif (token = literal_readNumberLiteral(parser)) {\n  \t\treturn token.v;\n  \t}\n\n  \tif (token = parser.matchPattern(patterns__name)) {\n  \t\treturn token;\n  \t}\n  }\n\n  var keyValuePair = readKeyValuePair;\n  function readKeyValuePair(parser) {\n  \tvar start, key, value;\n\n  \tstart = parser.pos;\n\n  \t// allow whitespace between '{' and key\n  \tparser.allowWhitespace();\n\n  \tkey = shared_readKey(parser);\n  \tif (key === null) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \t// allow whitespace between key and ':'\n  \tparser.allowWhitespace();\n\n  \t// next character must be ':'\n  \tif (!parser.matchString(\":\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \t// allow whitespace between ':' and value\n  \tparser.allowWhitespace();\n\n  \t// next expression must be a, well... expression\n  \tvalue = converters_readExpression(parser);\n  \tif (value === null) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \treturn {\n  \t\tt: KEY_VALUE_PAIR,\n  \t\tk: key,\n  \t\tv: value\n  \t};\n  }\n\n  var objectLiteral_keyValuePairs = readKeyValuePairs;\n  function readKeyValuePairs(parser) {\n  \tvar start, pairs, pair, keyValuePairs;\n\n  \tstart = parser.pos;\n\n  \tpair = keyValuePair(parser);\n  \tif (pair === null) {\n  \t\treturn null;\n  \t}\n\n  \tpairs = [pair];\n\n  \tif (parser.matchString(\",\")) {\n  \t\tkeyValuePairs = readKeyValuePairs(parser);\n\n  \t\tif (!keyValuePairs) {\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn pairs.concat(keyValuePairs);\n  \t}\n\n  \treturn pairs;\n  }\n\n  var readObjectLiteral = function (parser) {\n  \tvar start, keyValuePairs;\n\n  \tstart = parser.pos;\n\n  \t// allow whitespace\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"{\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tkeyValuePairs = objectLiteral_keyValuePairs(parser);\n\n  \t// allow whitespace between final value and '}'\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"}\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \treturn {\n  \t\tt: OBJECT_LITERAL,\n  \t\tm: keyValuePairs\n  \t};\n  };\n\n  var shared_readExpressionList = readExpressionList;\n  function readExpressionList(parser) {\n  \tvar start, expressions, expr, next;\n\n  \tstart = parser.pos;\n\n  \tparser.allowWhitespace();\n\n  \texpr = converters_readExpression(parser);\n\n  \tif (expr === null) {\n  \t\treturn null;\n  \t}\n\n  \texpressions = [expr];\n\n  \t// allow whitespace between expression and ','\n  \tparser.allowWhitespace();\n\n  \tif (parser.matchString(\",\")) {\n  \t\tnext = readExpressionList(parser);\n  \t\tif (next === null) {\n  \t\t\tparser.error(expectedExpression);\n  \t\t}\n\n  \t\tnext.forEach(append);\n  \t}\n\n  \tfunction append(expression) {\n  \t\texpressions.push(expression);\n  \t}\n\n  \treturn expressions;\n  }\n\n  var readArrayLiteral = function (parser) {\n  \tvar start, expressionList;\n\n  \tstart = parser.pos;\n\n  \t// allow whitespace before '['\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"[\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \texpressionList = shared_readExpressionList(parser);\n\n  \tif (!parser.matchString(\"]\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \treturn {\n  \t\tt: ARRAY_LITERAL,\n  \t\tm: expressionList\n  \t};\n  };\n\n  var primary_readLiteral = readLiteral;\n  function readLiteral(parser) {\n  \treturn literal_readNumberLiteral(parser) || literal_readBooleanLiteral(parser) || readStringLiteral(parser) || readObjectLiteral(parser) || readArrayLiteral(parser) || readRegexpLiteral(parser);\n  }\n\n  var primary_readReference = readReference;\n  var prefixPattern = /^(?:~\\/|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/,\n      globals,\n      keywords;\n\n  // if a reference is a browser global, we don't deference it later, so it needs special treatment\n  globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)\\b/;\n\n  // keywords are not valid references, with the exception of `this`\n  keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\n  var legalReference = /^[a-zA-Z$_0-9]+(?:(?:\\.[a-zA-Z$_0-9]+)|(?:\\[[0-9]+\\]))*/;\n  var relaxedName = /^[a-zA-Z_$][-a-zA-Z_$0-9]*/;\n  function readReference(parser) {\n  \tvar startPos, prefix, name, global, reference, lastDotIndex;\n\n  \tstartPos = parser.pos;\n\n  \tname = parser.matchPattern(/^@(?:keypath|index|key)/);\n\n  \tif (!name) {\n  \t\tprefix = parser.matchPattern(prefixPattern) || \"\";\n  \t\tname = !prefix && parser.relaxedNames && parser.matchPattern(relaxedName) || parser.matchPattern(legalReference);\n\n  \t\tif (!name && prefix === \".\") {\n  \t\t\tprefix = \"\";\n  \t\t\tname = \".\";\n  \t\t}\n  \t}\n\n  \tif (!name) {\n  \t\treturn null;\n  \t}\n\n  \t// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)\n  \tif (!prefix && !parser.relaxedNames && keywords.test(name)) {\n  \t\tparser.pos = startPos;\n  \t\treturn null;\n  \t}\n\n  \t// if this is a browser global, stop here\n  \tif (!prefix && globals.test(name)) {\n  \t\tglobal = globals.exec(name)[0];\n  \t\tparser.pos = startPos + global.length;\n\n  \t\treturn {\n  \t\t\tt: GLOBAL,\n  \t\t\tv: global\n  \t\t};\n  \t}\n\n  \treference = (prefix || \"\") + normalise(name);\n\n  \tif (parser.matchString(\"(\")) {\n  \t\t// if this is a method invocation (as opposed to a function) we need\n  \t\t// to strip the method name from the reference combo, else the context\n  \t\t// will be wrong\n  \t\tlastDotIndex = reference.lastIndexOf(\".\");\n  \t\tif (lastDotIndex !== -1) {\n  \t\t\treference = reference.substr(0, lastDotIndex);\n  \t\t\tparser.pos = startPos + reference.length;\n  \t\t} else {\n  \t\t\tparser.pos -= 1;\n  \t\t}\n  \t}\n\n  \treturn {\n  \t\tt: REFERENCE,\n  \t\tn: reference.replace(/^this\\./, \"./\").replace(/^this$/, \".\")\n  \t};\n  }\n\n  var primary_readBracketedExpression = readBracketedExpression;\n  function readBracketedExpression(parser) {\n  \tvar start, expr;\n\n  \tstart = parser.pos;\n\n  \tif (!parser.matchString(\"(\")) {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \texpr = converters_readExpression(parser);\n  \tif (!expr) {\n  \t\tparser.error(expectedExpression);\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\")\")) {\n  \t\tparser.error(expectedParen);\n  \t}\n\n  \treturn {\n  \t\tt: BRACKETED,\n  \t\tx: expr\n  \t};\n  }\n\n  var readPrimary = function (parser) {\n  \treturn primary_readLiteral(parser) || primary_readReference(parser) || primary_readBracketedExpression(parser);\n  };\n\n  var shared_readRefinement = readRefinement;\n  function readRefinement(parser) {\n  \tvar start, name, expr;\n\n  \tstart = parser.pos;\n\n  \tparser.allowWhitespace();\n\n  \t// \".\" name\n  \tif (parser.matchString(\".\")) {\n  \t\tparser.allowWhitespace();\n\n  \t\tif (name = parser.matchPattern(patterns__name)) {\n  \t\t\treturn {\n  \t\t\t\tt: REFINEMENT,\n  \t\t\t\tn: name\n  \t\t\t};\n  \t\t}\n\n  \t\tparser.error(\"Expected a property name\");\n  \t}\n\n  \t// \"[\" expression \"]\"\n  \tif (parser.matchString(\"[\")) {\n  \t\tparser.allowWhitespace();\n\n  \t\texpr = converters_readExpression(parser);\n  \t\tif (!expr) {\n  \t\t\tparser.error(expectedExpression);\n  \t\t}\n\n  \t\tparser.allowWhitespace();\n\n  \t\tif (!parser.matchString(\"]\")) {\n  \t\t\tparser.error(\"Expected ']'\");\n  \t\t}\n\n  \t\treturn {\n  \t\t\tt: REFINEMENT,\n  \t\t\tx: expr\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  var readMemberOrInvocation = function (parser) {\n  \tvar current, expression, refinement, expressionList;\n\n  \texpression = readPrimary(parser);\n\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \twhile (expression) {\n  \t\tcurrent = parser.pos;\n\n  \t\tif (refinement = shared_readRefinement(parser)) {\n  \t\t\texpression = {\n  \t\t\t\tt: MEMBER,\n  \t\t\t\tx: expression,\n  \t\t\t\tr: refinement\n  \t\t\t};\n  \t\t} else if (parser.matchString(\"(\")) {\n  \t\t\tparser.allowWhitespace();\n  \t\t\texpressionList = shared_readExpressionList(parser);\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif (!parser.matchString(\")\")) {\n  \t\t\t\tparser.error(expectedParen);\n  \t\t\t}\n\n  \t\t\texpression = {\n  \t\t\t\tt: INVOCATION,\n  \t\t\t\tx: expression\n  \t\t\t};\n\n  \t\t\tif (expressionList) {\n  \t\t\t\texpression.o = expressionList;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tbreak;\n  \t\t}\n  \t}\n\n  \treturn expression;\n  };\n\n  var readTypeOf, makePrefixSequenceMatcher;\n\n  makePrefixSequenceMatcher = function (symbol, fallthrough) {\n  \treturn function (parser) {\n  \t\tvar expression;\n\n  \t\tif (expression = fallthrough(parser)) {\n  \t\t\treturn expression;\n  \t\t}\n\n  \t\tif (!parser.matchString(symbol)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tparser.allowWhitespace();\n\n  \t\texpression = converters_readExpression(parser);\n  \t\tif (!expression) {\n  \t\t\tparser.error(expectedExpression);\n  \t\t}\n\n  \t\treturn {\n  \t\t\ts: symbol,\n  \t\t\to: expression,\n  \t\t\tt: PREFIX_OPERATOR\n  \t\t};\n  \t};\n  };\n\n  // create all prefix sequence matchers, return readTypeOf\n  (function () {\n  \tvar i, len, matcher, prefixOperators, fallthrough;\n\n  \tprefixOperators = \"! ~ + - typeof\".split(\" \");\n\n  \tfallthrough = readMemberOrInvocation;\n  \tfor (i = 0, len = prefixOperators.length; i < len; i += 1) {\n  \t\tmatcher = makePrefixSequenceMatcher(prefixOperators[i], fallthrough);\n  \t\tfallthrough = matcher;\n  \t}\n\n  \t// typeof operator is higher precedence than multiplication, so provides the\n  \t// fallthrough for the multiplication sequence matcher we're about to create\n  \t// (we're skipping void and delete)\n  \treadTypeOf = fallthrough;\n  })();\n\n  var readTypeof = readTypeOf;\n\n  var readLogicalOr, makeInfixSequenceMatcher;\n\n  makeInfixSequenceMatcher = function (symbol, fallthrough) {\n  \treturn function (parser) {\n  \t\tvar start, left, right;\n\n  \t\tleft = fallthrough(parser);\n  \t\tif (!left) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\t// Loop to handle left-recursion in a case like `a * b * c` and produce\n  \t\t// left association, i.e. `(a * b) * c`.  The matcher can't call itself\n  \t\t// to parse `left` because that would be infinite regress.\n  \t\twhile (true) {\n  \t\t\tstart = parser.pos;\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif (!parser.matchString(symbol)) {\n  \t\t\t\tparser.pos = start;\n  \t\t\t\treturn left;\n  \t\t\t}\n\n  \t\t\t// special case - in operator must not be followed by [a-zA-Z_$0-9]\n  \t\t\tif (symbol === \"in\" && /[a-zA-Z_$0-9]/.test(parser.remaining().charAt(0))) {\n  \t\t\t\tparser.pos = start;\n  \t\t\t\treturn left;\n  \t\t\t}\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\t// right operand must also consist of only higher-precedence operators\n  \t\t\tright = fallthrough(parser);\n  \t\t\tif (!right) {\n  \t\t\t\tparser.pos = start;\n  \t\t\t\treturn left;\n  \t\t\t}\n\n  \t\t\tleft = {\n  \t\t\t\tt: INFIX_OPERATOR,\n  \t\t\t\ts: symbol,\n  \t\t\t\to: [left, right]\n  \t\t\t};\n\n  \t\t\t// Loop back around.  If we don't see another occurrence of the symbol,\n  \t\t\t// we'll return left.\n  \t\t}\n  \t};\n  };\n\n  // create all infix sequence matchers, and return readLogicalOr\n  (function () {\n  \tvar i, len, matcher, infixOperators, fallthrough;\n\n  \t// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n  \t// Each sequence matcher will initially fall through to its higher precedence\n  \t// neighbour, and only attempt to match if one of the higher precedence operators\n  \t// (or, ultimately, a literal, reference, or bracketed expression) already matched\n  \tinfixOperators = \"* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||\".split(\" \");\n\n  \t// A typeof operator is higher precedence than multiplication\n  \tfallthrough = readTypeof;\n  \tfor (i = 0, len = infixOperators.length; i < len; i += 1) {\n  \t\tmatcher = makeInfixSequenceMatcher(infixOperators[i], fallthrough);\n  \t\tfallthrough = matcher;\n  \t}\n\n  \t// Logical OR is the fallthrough for the conditional matcher\n  \treadLogicalOr = fallthrough;\n  })();\n\n  var expressions_readLogicalOr = readLogicalOr;\n\n  // The conditional operator is the lowest precedence operator, so we start here\n  var readConditional = getConditional;\n  function getConditional(parser) {\n  \tvar start, expression, ifTrue, ifFalse;\n\n  \texpression = expressions_readLogicalOr(parser);\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \tstart = parser.pos;\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"?\")) {\n  \t\tparser.pos = start;\n  \t\treturn expression;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tifTrue = converters_readExpression(parser);\n  \tif (!ifTrue) {\n  \t\tparser.error(expectedExpression);\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\":\")) {\n  \t\tparser.error(\"Expected \\\":\\\"\");\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tifFalse = converters_readExpression(parser);\n  \tif (!ifFalse) {\n  \t\tparser.error(expectedExpression);\n  \t}\n\n  \treturn {\n  \t\tt: CONDITIONAL,\n  \t\to: [expression, ifTrue, ifFalse]\n  \t};\n  }\n\n  var converters_readExpression = readExpression;\n  function readExpression(parser) {\n  \t// The conditional operator is the lowest precedence operator (except yield,\n  \t// assignment operators, and commas, none of which are supported), so we\n  \t// start there. If it doesn't match, it 'falls through' to progressively\n  \t// higher precedence operators, until it eventually matches (or fails to\n  \t// match) a 'primary' - a literal or a reference. This way, the abstract syntax\n  \t// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n  \treturn readConditional(parser);\n  }\n\n  var utils_flattenExpression = flattenExpression;\n\n  function flattenExpression(expression) {\n  \tvar refs;\n\n  \textractRefs(expression, refs = []);\n\n  \treturn {\n  \t\tr: refs,\n  \t\ts: stringify(expression)\n  \t};\n\n  \tfunction stringify(node) {\n  \t\tswitch (node.t) {\n  \t\t\tcase BOOLEAN_LITERAL:\n  \t\t\tcase GLOBAL:\n  \t\t\tcase NUMBER_LITERAL:\n  \t\t\tcase REGEXP_LITERAL:\n  \t\t\t\treturn node.v;\n\n  \t\t\tcase STRING_LITERAL:\n  \t\t\t\treturn JSON.stringify(String(node.v));\n\n  \t\t\tcase ARRAY_LITERAL:\n  \t\t\t\treturn \"[\" + (node.m ? node.m.map(stringify).join(\",\") : \"\") + \"]\";\n\n  \t\t\tcase OBJECT_LITERAL:\n  \t\t\t\treturn \"{\" + (node.m ? node.m.map(stringify).join(\",\") : \"\") + \"}\";\n\n  \t\t\tcase KEY_VALUE_PAIR:\n  \t\t\t\treturn node.k + \":\" + stringify(node.v);\n\n  \t\t\tcase PREFIX_OPERATOR:\n  \t\t\t\treturn (node.s === \"typeof\" ? \"typeof \" : node.s) + stringify(node.o);\n\n  \t\t\tcase INFIX_OPERATOR:\n  \t\t\t\treturn stringify(node.o[0]) + (node.s.substr(0, 2) === \"in\" ? \" \" + node.s + \" \" : node.s) + stringify(node.o[1]);\n\n  \t\t\tcase INVOCATION:\n  \t\t\t\treturn stringify(node.x) + \"(\" + (node.o ? node.o.map(stringify).join(\",\") : \"\") + \")\";\n\n  \t\t\tcase BRACKETED:\n  \t\t\t\treturn \"(\" + stringify(node.x) + \")\";\n\n  \t\t\tcase MEMBER:\n  \t\t\t\treturn stringify(node.x) + stringify(node.r);\n\n  \t\t\tcase REFINEMENT:\n  \t\t\t\treturn node.n ? \".\" + node.n : \"[\" + stringify(node.x) + \"]\";\n\n  \t\t\tcase CONDITIONAL:\n  \t\t\t\treturn stringify(node.o[0]) + \"?\" + stringify(node.o[1]) + \":\" + stringify(node.o[2]);\n\n  \t\t\tcase REFERENCE:\n  \t\t\t\treturn \"_\" + refs.indexOf(node.n);\n\n  \t\t\tdefault:\n  \t\t\t\tthrow new Error(\"Expected legal JavaScript\");\n  \t\t}\n  \t}\n  }\n\n  // TODO maybe refactor this?\n  function extractRefs(node, refs) {\n  \tvar i, list;\n\n  \tif (node.t === REFERENCE) {\n  \t\tif (refs.indexOf(node.n) === -1) {\n  \t\t\trefs.unshift(node.n);\n  \t\t}\n  \t}\n\n  \tlist = node.o || node.m;\n  \tif (list) {\n  \t\tif (isObject(list)) {\n  \t\t\textractRefs(list, refs);\n  \t\t} else {\n  \t\t\ti = list.length;\n  \t\t\twhile (i--) {\n  \t\t\t\textractRefs(list[i], refs);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tif (node.x) {\n  \t\textractRefs(node.x, refs);\n  \t}\n\n  \tif (node.r) {\n  \t\textractRefs(node.r, refs);\n  \t}\n\n  \tif (node.v) {\n  \t\textractRefs(node.v, refs);\n  \t}\n  }\n\n  var utils_refineExpression = refineExpression;\n\n  var arrayMemberPattern = /^[0-9][1-9]*$/;\n  function refineExpression(expression, mustache) {\n  \tvar referenceExpression;\n\n  \tif (expression) {\n  \t\twhile (expression.t === BRACKETED && expression.x) {\n  \t\t\texpression = expression.x;\n  \t\t}\n\n  \t\t// special case - integers should be treated as array members references,\n  \t\t// rather than as expressions in their own right\n  \t\tif (expression.t === REFERENCE) {\n  \t\t\tmustache.r = expression.n;\n  \t\t} else {\n  \t\t\tif (expression.t === NUMBER_LITERAL && arrayMemberPattern.test(expression.v)) {\n  \t\t\t\tmustache.r = expression.v;\n  \t\t\t} else if (referenceExpression = getReferenceExpression(expression)) {\n  \t\t\t\tmustache.rx = referenceExpression;\n  \t\t\t} else {\n  \t\t\t\tmustache.x = utils_flattenExpression(expression);\n  \t\t\t}\n  \t\t}\n\n  \t\treturn mustache;\n  \t}\n  }\n\n  // TODO refactor this! it's bewildering\n  function getReferenceExpression(expression) {\n  \tvar members = [],\n  \t    refinement;\n\n  \twhile (expression.t === MEMBER && expression.r.t === REFINEMENT) {\n  \t\trefinement = expression.r;\n\n  \t\tif (refinement.x) {\n  \t\t\tif (refinement.x.t === REFERENCE) {\n  \t\t\t\tmembers.unshift(refinement.x);\n  \t\t\t} else {\n  \t\t\t\tmembers.unshift(utils_flattenExpression(refinement.x));\n  \t\t\t}\n  \t\t} else {\n  \t\t\tmembers.unshift(refinement.n);\n  \t\t}\n\n  \t\texpression = expression.x;\n  \t}\n\n  \tif (expression.t !== REFERENCE) {\n  \t\treturn null;\n  \t}\n\n  \treturn {\n  \t\tr: expression.n,\n  \t\tm: members\n  \t};\n  }\n\n  var mustache_readTriple = readTriple;\n  function readTriple(parser, tag) {\n  \tvar expression = converters_readExpression(parser),\n  \t    triple;\n\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \ttriple = { t: TRIPLE };\n  \tutils_refineExpression(expression, triple); // TODO handle this differently - it's mysterious\n\n  \treturn triple;\n  }\n\n  var mustache_readUnescaped = readUnescaped;\n  function readUnescaped(parser, tag) {\n  \tvar expression, triple;\n\n  \tif (!parser.matchString(\"&\")) {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \texpression = converters_readExpression(parser);\n\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \ttriple = { t: TRIPLE };\n  \tutils_refineExpression(expression, triple); // TODO handle this differently - it's mysterious\n\n  \treturn triple;\n  }\n\n  var mustache_readPartial = readPartial;\n  function readPartial(parser, tag) {\n  \tvar start, nameStart, expression, context, partial;\n\n  \tstart = parser.pos;\n\n  \tif (!parser.matchString(\">\")) {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n  \tnameStart = parser.pos;\n\n  \t// Partial names can include hyphens, so we can't use readExpression\n  \t// blindly. Instead, we use the `relaxedNames` flag to indicate that\n  \t// `foo-bar` should be read as a single name, rather than 'subtract\n  \t// bar from foo'\n  \tparser.relaxedNames = true;\n  \texpression = converters_readExpression(parser);\n  \tparser.relaxedNames = false;\n\n  \tparser.allowWhitespace();\n  \tcontext = converters_readExpression(parser);\n  \tparser.allowWhitespace();\n\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \tpartial = { t: PARTIAL };\n  \tutils_refineExpression(expression, partial); // TODO...\n\n  \tparser.allowWhitespace();\n\n  \t// if we have another expression - e.g. `{{>foo bar}}` - then\n  \t// we turn it into `{{#with bar}}{{>foo}}{{/with}}`\n  \tif (context) {\n  \t\tpartial = {\n  \t\t\tt: SECTION,\n  \t\t\tn: SECTION_WITH,\n  \t\t\tf: [partial]\n  \t\t};\n\n  \t\tutils_refineExpression(context, partial);\n  \t}\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \treturn partial;\n  }\n\n  var readMustacheComment = readComment;\n  function readComment(parser, tag) {\n  \tvar index;\n\n  \tif (!parser.matchString(\"!\")) {\n  \t\treturn null;\n  \t}\n\n  \tindex = parser.remaining().indexOf(tag.close);\n\n  \tif (index !== -1) {\n  \t\tparser.pos += index + tag.close.length;\n  \t\treturn { t: COMMENT };\n  \t}\n  }\n\n  var converters_readExpressionOrReference = readExpressionOrReference;\n  function readExpressionOrReference(parser, expectedFollowers) {\n  \tvar start, expression, i;\n\n  \tstart = parser.pos;\n  \texpression = converters_readExpression(parser);\n\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \tfor (i = 0; i < expectedFollowers.length; i += 1) {\n  \t\tif (parser.remaining().substr(0, expectedFollowers[i].length) === expectedFollowers[i]) {\n  \t\t\treturn expression;\n  \t\t}\n  \t}\n\n  \tparser.pos = start;\n  \treturn primary_readReference(parser);\n  }\n\n  var mustache_readInterpolator = readInterpolator;\n  function readInterpolator(parser, tag) {\n  \tvar start, expression, interpolator, err;\n\n  \tstart = parser.pos;\n\n  \t// TODO would be good for perf if we could do away with the try-catch\n  \ttry {\n  \t\texpression = converters_readExpressionOrReference(parser, [tag.close]);\n  \t} catch (e) {\n  \t\terr = e;\n  \t}\n\n  \tif (!expression) {\n  \t\tif (parser.str.charAt(start) === \"!\") {\n  \t\t\t// special case - comment\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tif (err) {\n  \t\t\tthrow err;\n  \t\t}\n  \t}\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"' after reference\");\n\n  \t\tif (!expression) {\n  \t\t\t// special case - comment\n  \t\t\tif (parser.nextChar() === \"!\") {\n  \t\t\t\treturn null;\n  \t\t\t}\n\n  \t\t\tparser.error(\"Expected expression or legal reference\");\n  \t\t}\n  \t}\n\n  \tinterpolator = { t: INTERPOLATOR };\n  \tutils_refineExpression(expression, interpolator); // TODO handle this differently - it's mysterious\n\n  \treturn interpolator;\n  }\n\n  var mustache_readYielder = readYielder;\n  var yieldPattern = /^yield\\s*/;\n  function readYielder(parser, tag) {\n  \tvar start, name, yielder;\n\n  \tif (!parser.matchPattern(yieldPattern)) {\n  \t\treturn null;\n  \t}\n\n  \tstart = parser.pos;\n  \tname = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/);\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"expected legal partial name\");\n  \t}\n\n  \tyielder = { t: YIELDER };\n\n  \tif (name) {\n  \t\tyielder.n = name;\n  \t}\n\n  \treturn yielder;\n  }\n\n  var section_readClosing = readClosing;\n  function readClosing(parser, tag) {\n  \tvar start, remaining, index, closing;\n\n  \tstart = parser.pos;\n\n  \tif (!parser.matchString(tag.open)) {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"/\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tremaining = parser.remaining();\n  \tindex = remaining.indexOf(tag.close);\n\n  \tif (index !== -1) {\n  \t\tclosing = {\n  \t\t\tt: CLOSING,\n  \t\t\tr: remaining.substr(0, index).split(\" \")[0]\n  \t\t};\n\n  \t\tparser.pos += index;\n\n  \t\tif (!parser.matchString(tag.close)) {\n  \t\t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t\t}\n\n  \t\treturn closing;\n  \t}\n\n  \tparser.pos = start;\n  \treturn null;\n  }\n\n  var section_readElse = section_readElse__readElse;\n  var section_readElse__elsePattern = /^\\s*else\\s*/;\n  function section_readElse__readElse(parser, tag) {\n  \tvar start = parser.pos;\n\n  \tif (!parser.matchString(tag.open)) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchPattern(section_readElse__elsePattern)) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \treturn {\n  \t\tt: ELSE\n  \t};\n  }\n\n  var readElseIf = readElseIf__readElse;\n  var readElseIf__elsePattern = /^\\s*elseif\\s+/;\n  function readElseIf__readElse(parser, tag) {\n  \tvar start = parser.pos,\n  \t    expression;\n\n  \tif (!parser.matchString(tag.open)) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchPattern(readElseIf__elsePattern)) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \texpression = converters_readExpression(parser);\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \treturn {\n  \t\tt: ELSEIF,\n  \t\tx: expression\n  \t};\n  }\n\n  var handlebarsBlockCodes = {\n  \teach: SECTION_EACH,\n  \t\"if\": SECTION_IF,\n  \t\"if-with\": SECTION_IF_WITH,\n  \t\"with\": SECTION_WITH,\n  \tunless: SECTION_UNLESS\n  };\n\n  var mustache_readSection = readSection;\n\n  var indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n      keyIndexRefPattern = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n      handlebarsBlockPattern = new RegExp(\"^(\" + Object.keys(handlebarsBlockCodes).join(\"|\") + \")\\\\b\");\n  function readSection(parser, tag) {\n  \tvar start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose;\n\n  \tstart = parser.pos;\n\n  \tif (parser.matchString(\"^\")) {\n  \t\tsection = { t: SECTION, f: [], n: SECTION_UNLESS };\n  \t} else if (parser.matchString(\"#\")) {\n  \t\tsection = { t: SECTION, f: [] };\n\n  \t\tif (parser.matchString(\"partial\")) {\n  \t\t\tparser.pos = start - parser.standardDelimiters[0].length;\n  \t\t\tparser.error(\"Partial definitions can only be at the top level of the template, or immediately inside components\");\n  \t\t}\n\n  \t\tif (block = parser.matchPattern(handlebarsBlockPattern)) {\n  \t\t\texpectedClose = block;\n  \t\t\tsection.n = handlebarsBlockCodes[block];\n  \t\t}\n  \t} else {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \texpression = converters_readExpression(parser);\n\n  \tif (!expression) {\n  \t\tparser.error(\"Expected expression\");\n  \t}\n\n  \t// optional index and key references\n  \tif (i = parser.matchPattern(indexRefPattern)) {\n  \t\tvar extra = undefined;\n\n  \t\tif (extra = parser.matchPattern(keyIndexRefPattern)) {\n  \t\t\tsection.i = i + \",\" + extra;\n  \t\t} else {\n  \t\t\tsection.i = i;\n  \t\t}\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \tparser.sectionDepth += 1;\n  \tchildren = section.f;\n\n  \tconditions = [];\n\n  \tdo {\n  \t\tif (child = section_readClosing(parser, tag)) {\n  \t\t\tif (expectedClose && child.r !== expectedClose) {\n  \t\t\t\tparser.error(\"Expected \" + tag.open + \"/\" + expectedClose + \"\" + tag.close);\n  \t\t\t}\n\n  \t\t\tparser.sectionDepth -= 1;\n  \t\t\tclosed = true;\n  \t\t} else if (child = readElseIf(parser, tag)) {\n  \t\t\tif (section.n === SECTION_UNLESS) {\n  \t\t\t\tparser.error(\"{{else}} not allowed in {{#unless}}\");\n  \t\t\t}\n\n  \t\t\tif (hasElse) {\n  \t\t\t\tparser.error(\"illegal {{elseif...}} after {{else}}\");\n  \t\t\t}\n\n  \t\t\tif (!unlessBlock) {\n  \t\t\t\tunlessBlock = createUnlessBlock(expression, section.n);\n  \t\t\t}\n\n  \t\t\tunlessBlock.f.push({\n  \t\t\t\tt: SECTION,\n  \t\t\t\tn: SECTION_IF,\n  \t\t\t\tx: utils_flattenExpression(mustache_readSection__combine(conditions.concat(child.x))),\n  \t\t\t\tf: children = []\n  \t\t\t});\n\n  \t\t\tconditions.push(invert(child.x));\n  \t\t} else if (child = section_readElse(parser, tag)) {\n  \t\t\tif (section.n === SECTION_UNLESS) {\n  \t\t\t\tparser.error(\"{{else}} not allowed in {{#unless}}\");\n  \t\t\t}\n\n  \t\t\tif (hasElse) {\n  \t\t\t\tparser.error(\"there can only be one {{else}} block, at the end of a section\");\n  \t\t\t}\n\n  \t\t\thasElse = true;\n\n  \t\t\t// use an unless block if there's no elseif\n  \t\t\tif (!unlessBlock) {\n  \t\t\t\tunlessBlock = createUnlessBlock(expression, section.n);\n  \t\t\t\tchildren = unlessBlock.f;\n  \t\t\t} else {\n  \t\t\t\tunlessBlock.f.push({\n  \t\t\t\t\tt: SECTION,\n  \t\t\t\t\tn: SECTION_IF,\n  \t\t\t\t\tx: utils_flattenExpression(mustache_readSection__combine(conditions)),\n  \t\t\t\t\tf: children = []\n  \t\t\t\t});\n  \t\t\t}\n  \t\t} else {\n  \t\t\tchild = parser.read(READERS);\n\n  \t\t\tif (!child) {\n  \t\t\t\tbreak;\n  \t\t\t}\n\n  \t\t\tchildren.push(child);\n  \t\t}\n  \t} while (!closed);\n\n  \tif (unlessBlock) {\n  \t\t// special case - `with` should become `if-with` (TODO is this right?\n  \t\t// seems to me that `with` ought to behave consistently, regardless\n  \t\t// of the presence/absence of `else`. In other words should always\n  \t\t// be `if-with`\n  \t\tif (section.n === SECTION_WITH) {\n  \t\t\tsection.n = SECTION_IF_WITH;\n  \t\t}\n\n  \t\tsection.l = unlessBlock;\n  \t}\n\n  \tutils_refineExpression(expression, section);\n\n  \t// TODO if a section is empty it should be discarded. Don't do\n  \t// that here though - we need to clean everything up first, as\n  \t// it may contain removeable whitespace. As a temporary measure,\n  \t// to pass the existing tests, remove empty `f` arrays\n  \tif (!section.f.length) {\n  \t\tdelete section.f;\n  \t}\n\n  \treturn section;\n  }\n\n  function createUnlessBlock(expression, sectionType) {\n  \tvar unlessBlock;\n\n  \tif (sectionType === SECTION_WITH) {\n  \t\t// special case - a `{{#with foo}}` section will render if `foo` is\n  \t\t// truthy, so the `{{else}}` section needs to render if `foo` is falsy,\n  \t\t// rather than adhering to the normal `{{#unless foo}}` logic (which\n  \t\t// treats empty arrays/objects as falsy)\n  \t\tunlessBlock = {\n  \t\t\tt: SECTION,\n  \t\t\tn: SECTION_IF,\n  \t\t\tf: []\n  \t\t};\n\n  \t\tutils_refineExpression(invert(expression), unlessBlock);\n  \t} else {\n  \t\tunlessBlock = {\n  \t\t\tt: SECTION,\n  \t\t\tn: SECTION_UNLESS,\n  \t\t\tf: []\n  \t\t};\n\n  \t\tutils_refineExpression(expression, unlessBlock);\n  \t}\n\n  \treturn unlessBlock;\n  }\n\n  function invert(expression) {\n  \tif (expression.t === PREFIX_OPERATOR && expression.s === \"!\") {\n  \t\treturn expression.o;\n  \t}\n\n  \treturn {\n  \t\tt: PREFIX_OPERATOR,\n  \t\ts: \"!\",\n  \t\to: parensIfNecessary(expression)\n  \t};\n  }\n\n  function mustache_readSection__combine(expressions) {\n  \tif (expressions.length === 1) {\n  \t\treturn expressions[0];\n  \t}\n\n  \treturn {\n  \t\tt: INFIX_OPERATOR,\n  \t\ts: \"&&\",\n  \t\to: [parensIfNecessary(expressions[0]), parensIfNecessary(mustache_readSection__combine(expressions.slice(1)))]\n  \t};\n  }\n\n  function parensIfNecessary(expression) {\n  \t// TODO only wrap if necessary\n  \treturn {\n  \t\tt: BRACKETED,\n  \t\tx: expression\n  \t};\n  }\n\n  var converters_readHtmlComment = readHtmlComment;\n  var OPEN_COMMENT = \"<!--\",\n      CLOSE_COMMENT = \"-->\";\n  function readHtmlComment(parser) {\n  \tvar start, content, remaining, endIndex, comment;\n\n  \tstart = parser.pos;\n\n  \tif (!parser.matchString(OPEN_COMMENT)) {\n  \t\treturn null;\n  \t}\n\n  \tremaining = parser.remaining();\n  \tendIndex = remaining.indexOf(CLOSE_COMMENT);\n\n  \tif (endIndex === -1) {\n  \t\tparser.error(\"Illegal HTML - expected closing comment sequence ('-->')\");\n  \t}\n\n  \tcontent = remaining.substr(0, endIndex);\n  \tparser.pos += endIndex + 3;\n\n  \tcomment = {\n  \t\tt: COMMENT,\n  \t\tc: content\n  \t};\n\n  \tif (parser.includeLinePositions) {\n  \t\tcomment.p = parser.getLinePos(start);\n  \t}\n\n  \treturn comment;\n  }\n\n  var booleanAttributes, voidElementNames, htmlEntities, controlCharacters, entityPattern, lessThan, greaterThan, amp;\n\n  // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n  booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\n  voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\n\n  htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 };\n  controlCharacters = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376];\n  entityPattern = new RegExp(\"&(#?(?:x[\\\\w\\\\d]+|\\\\d+|\" + Object.keys(htmlEntities).join(\"|\") + \"));?\", \"g\");\n\n  function decodeCharacterReferences(html) {\n  \treturn html.replace(entityPattern, function (match, entity) {\n  \t\tvar code;\n\n  \t\t// Handle named entities\n  \t\tif (entity[0] !== \"#\") {\n  \t\t\tcode = htmlEntities[entity];\n  \t\t} else if (entity[1] === \"x\") {\n  \t\t\tcode = parseInt(entity.substring(2), 16);\n  \t\t} else {\n  \t\t\tcode = parseInt(entity.substring(1), 10);\n  \t\t}\n\n  \t\tif (!code) {\n  \t\t\treturn match;\n  \t\t}\n\n  \t\treturn String.fromCharCode(validateCode(code));\n  \t});\n  }\n\n  // some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n  // code points with alternatives in some cases - since we're bypassing that mechanism, we need\n  // to replace them ourselves\n  //\n  // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n  function validateCode(code) {\n  \tif (!code) {\n  \t\treturn 65533;\n  \t}\n\n  \t// line feed becomes generic whitespace\n  \tif (code === 10) {\n  \t\treturn 32;\n  \t}\n\n  \t// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n  \tif (code < 128) {\n  \t\treturn code;\n  \t}\n\n  \t// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n  \t// to correct the mistake or we'll end up with missing € signs and so on\n  \tif (code <= 159) {\n  \t\treturn controlCharacters[code - 128];\n  \t}\n\n  \t// basic multilingual plane\n  \tif (code < 55296) {\n  \t\treturn code;\n  \t}\n\n  \t// UTF-16 surrogate halves\n  \tif (code <= 57343) {\n  \t\treturn 65533;\n  \t}\n\n  \t// rest of the basic multilingual plane\n  \tif (code <= 65535) {\n  \t\treturn code;\n  \t}\n\n  \treturn 65533;\n  }\n\n  lessThan = /</g;\n  greaterThan = />/g;\n  amp = /&/g;\n\n  function escapeHtml(str) {\n  \treturn str.replace(amp, \"&amp;\").replace(lessThan, \"&lt;\").replace(greaterThan, \"&gt;\");\n  }\n\n  var leadingLinebreak = /^\\s*\\r?\\n/,\n      trailingLinebreak = /\\r?\\n\\s*$/;\n\n  var stripStandalones = function (items) {\n  \tvar i, current, backOne, backTwo, lastSectionItem;\n\n  \tfor (i = 1; i < items.length; i += 1) {\n  \t\tcurrent = items[i];\n  \t\tbackOne = items[i - 1];\n  \t\tbackTwo = items[i - 2];\n\n  \t\t// if we're at the end of a [text][comment][text] sequence...\n  \t\tif (isString(current) && isComment(backOne) && isString(backTwo)) {\n\n  \t\t\t// ... and the comment is a standalone (i.e. line breaks either side)...\n  \t\t\tif (trailingLinebreak.test(backTwo) && leadingLinebreak.test(current)) {\n\n  \t\t\t\t// ... then we want to remove the whitespace after the first line break\n  \t\t\t\titems[i - 2] = backTwo.replace(trailingLinebreak, \"\\n\");\n\n  \t\t\t\t// and the leading line break of the second text token\n  \t\t\t\titems[i] = current.replace(leadingLinebreak, \"\");\n  \t\t\t}\n  \t\t}\n\n  \t\t// if the current item is a section, and it is preceded by a linebreak, and\n  \t\t// its first item is a linebreak...\n  \t\tif (isSection(current) && isString(backOne)) {\n  \t\t\tif (trailingLinebreak.test(backOne) && isString(current.f[0]) && leadingLinebreak.test(current.f[0])) {\n  \t\t\t\titems[i - 1] = backOne.replace(trailingLinebreak, \"\\n\");\n  \t\t\t\tcurrent.f[0] = current.f[0].replace(leadingLinebreak, \"\");\n  \t\t\t}\n  \t\t}\n\n  \t\t// if the last item was a section, and it is followed by a linebreak, and\n  \t\t// its last item is a linebreak...\n  \t\tif (isString(current) && isSection(backOne)) {\n  \t\t\tlastSectionItem = lastItem(backOne.f);\n\n  \t\t\tif (isString(lastSectionItem) && trailingLinebreak.test(lastSectionItem) && leadingLinebreak.test(current)) {\n  \t\t\t\tbackOne.f[backOne.f.length - 1] = lastSectionItem.replace(trailingLinebreak, \"\\n\");\n  \t\t\t\titems[i] = current.replace(leadingLinebreak, \"\");\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn items;\n  };\n\n  function isString(item) {\n  \treturn typeof item === \"string\";\n  }\n\n  function isComment(item) {\n  \treturn item.t === COMMENT || item.t === DELIMCHANGE;\n  }\n\n  function isSection(item) {\n  \treturn (item.t === SECTION || item.t === INVERTED) && item.f;\n  }\n\n  var trimWhitespace = function (items, leadingPattern, trailingPattern) {\n  \tvar item;\n\n  \tif (leadingPattern) {\n  \t\titem = items[0];\n  \t\tif (typeof item === \"string\") {\n  \t\t\titem = item.replace(leadingPattern, \"\");\n\n  \t\t\tif (!item) {\n  \t\t\t\titems.shift();\n  \t\t\t} else {\n  \t\t\t\titems[0] = item;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tif (trailingPattern) {\n  \t\titem = lastItem(items);\n  \t\tif (typeof item === \"string\") {\n  \t\t\titem = item.replace(trailingPattern, \"\");\n\n  \t\t\tif (!item) {\n  \t\t\t\titems.pop();\n  \t\t\t} else {\n  \t\t\t\titems[items.length - 1] = item;\n  \t\t\t}\n  \t\t}\n  \t}\n  };\n\n  var utils_cleanup = cleanup;\n  var contiguousWhitespace = /[ \\t\\f\\r\\n]+/g;\n  var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;\n  var utils_cleanup__leadingWhitespace = /^[ \\t\\f\\r\\n]+/;\n  var trailingWhitespace = /[ \\t\\f\\r\\n]+$/;\n  var leadingNewLine = /^(?:\\r\\n|\\r|\\n)/;\n  var trailingNewLine = /(?:\\r\\n|\\r|\\n)$/;\n  function cleanup(items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace) {\n  \tvar i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, key;\n\n  \t// First pass - remove standalones and comments etc\n  \tstripStandalones(items);\n\n  \ti = items.length;\n  \twhile (i--) {\n  \t\titem = items[i];\n\n  \t\t// Remove delimiter changes, unsafe elements etc\n  \t\tif (item.exclude) {\n  \t\t\titems.splice(i, 1);\n  \t\t}\n\n  \t\t// Remove comments, unless we want to keep them\n  \t\telse if (stripComments && item.t === COMMENT) {\n  \t\t\titems.splice(i, 1);\n  \t\t}\n  \t}\n\n  \t// If necessary, remove leading and trailing whitespace\n  \ttrimWhitespace(items, removeLeadingWhitespace ? utils_cleanup__leadingWhitespace : null, removeTrailingWhitespace ? trailingWhitespace : null);\n\n  \ti = items.length;\n  \twhile (i--) {\n  \t\titem = items[i];\n\n  \t\t// Recurse\n  \t\tif (item.f) {\n  \t\t\tvar isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test(item.e);\n  \t\t\tpreserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;\n\n  \t\t\tif (!preserveWhitespace && isPreserveWhitespaceElement) {\n  \t\t\t\ttrimWhitespace(item.f, leadingNewLine, trailingNewLine);\n  \t\t\t}\n\n  \t\t\tif (!preserveWhitespaceInsideFragment) {\n  \t\t\t\tpreviousItem = items[i - 1];\n  \t\t\t\tnextItem = items[i + 1];\n\n  \t\t\t\t// if the previous item was a text item with trailing whitespace,\n  \t\t\t\t// remove leading whitespace inside the fragment\n  \t\t\t\tif (!previousItem || typeof previousItem === \"string\" && trailingWhitespace.test(previousItem)) {\n  \t\t\t\t\tremoveLeadingWhitespaceInsideFragment = true;\n  \t\t\t\t}\n\n  \t\t\t\t// and vice versa\n  \t\t\t\tif (!nextItem || typeof nextItem === \"string\" && utils_cleanup__leadingWhitespace.test(nextItem)) {\n  \t\t\t\t\tremoveTrailingWhitespaceInsideFragment = true;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tcleanup(item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  \t\t}\n\n  \t\t// Split if-else blocks into two (an if, and an unless)\n  \t\tif (item.l) {\n  \t\t\tcleanup(item.l.f, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n\n  \t\t\titems.splice(i + 1, 0, item.l);\n  \t\t\tdelete item.l; // TODO would be nice if there was a way around this\n  \t\t}\n\n  \t\t// Clean up element attributes\n  \t\tif (item.a) {\n  \t\t\tfor (key in item.a) {\n  \t\t\t\tif (item.a.hasOwnProperty(key) && typeof item.a[key] !== \"string\") {\n  \t\t\t\t\tcleanup(item.a[key], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// Clean up conditional attributes\n  \t\tif (item.m) {\n  \t\t\tcleanup(item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  \t\t}\n\n  \t\t// Clean up event handlers\n  \t\tif (item.v) {\n  \t\t\tfor (key in item.v) {\n  \t\t\t\tif (item.v.hasOwnProperty(key)) {\n  \t\t\t\t\t// clean up names\n  \t\t\t\t\tif (isArray(item.v[key].n)) {\n  \t\t\t\t\t\tcleanup(item.v[key].n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  \t\t\t\t\t}\n\n  \t\t\t\t\t// clean up params\n  \t\t\t\t\tif (isArray(item.v[key].d)) {\n  \t\t\t\t\t\tcleanup(item.v[key].d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// final pass - fuse text nodes together\n  \ti = items.length;\n  \twhile (i--) {\n  \t\tif (typeof items[i] === \"string\") {\n  \t\t\tif (typeof items[i + 1] === \"string\") {\n  \t\t\t\titems[i] = items[i] + items[i + 1];\n  \t\t\t\titems.splice(i + 1, 1);\n  \t\t\t}\n\n  \t\t\tif (!preserveWhitespace) {\n  \t\t\t\titems[i] = items[i].replace(contiguousWhitespace, \" \");\n  \t\t\t}\n\n  \t\t\tif (items[i] === \"\") {\n  \t\t\t\titems.splice(i, 1);\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  var element_readClosingTag = readClosingTag;\n  var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n  function readClosingTag(parser) {\n  \tvar start, tag;\n\n  \tstart = parser.pos;\n\n  \t// are we looking at a closing tag?\n  \tif (!parser.matchString(\"</\")) {\n  \t\treturn null;\n  \t}\n\n  \tif (tag = parser.matchPattern(closingTagPattern)) {\n  \t\tif (parser.inside && tag !== parser.inside) {\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn {\n  \t\t\tt: CLOSING_TAG,\n  \t\t\te: tag\n  \t\t};\n  \t}\n\n  \t// We have an illegal closing tag, report it\n  \tparser.pos -= 2;\n  \tparser.error(\"Illegal closing tag\");\n  }\n\n  var getLowestIndex = function (haystack, needles) {\n  \tvar i, index, lowest;\n\n  \ti = needles.length;\n  \twhile (i--) {\n  \t\tindex = haystack.indexOf(needles[i]);\n\n  \t\t// short circuit\n  \t\tif (!index) {\n  \t\t\treturn 0;\n  \t\t}\n\n  \t\tif (index === -1) {\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\tif (!lowest || index < lowest) {\n  \t\t\tlowest = index;\n  \t\t}\n  \t}\n\n  \treturn lowest || -1;\n  };\n\n  var element_readAttribute = readAttribute;\n\n  var attributeNamePattern = /^[^\\s\"'>\\/=]+/,\n      unquotedAttributeValueTextPattern = /^[^\\s\"'=<>`]+/;\n  function readAttribute(parser) {\n  \tvar attr, name, value;\n\n  \tparser.allowWhitespace();\n\n  \tname = parser.matchPattern(attributeNamePattern);\n  \tif (!name) {\n  \t\treturn null;\n  \t}\n\n  \tattr = { name: name };\n\n  \tvalue = readAttributeValue(parser);\n  \tif (value != null) {\n  \t\t// not null/undefined\n  \t\tattr.value = value;\n  \t}\n\n  \treturn attr;\n  }\n\n  function readAttributeValue(parser) {\n  \tvar start, valueStart, startDepth, value;\n\n  \tstart = parser.pos;\n\n  \t// next character must be `=`, `/`, `>` or whitespace\n  \tif (!/[=\\/>\\s]/.test(parser.nextChar())) {\n  \t\tparser.error(\"Expected `=`, `/`, `>` or whitespace\");\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"=\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tvalueStart = parser.pos;\n  \tstartDepth = parser.sectionDepth;\n\n  \tvalue = readQuotedAttributeValue(parser, \"'\") || readQuotedAttributeValue(parser, \"\\\"\") || readUnquotedAttributeValue(parser);\n\n  \tif (value === null) {\n  \t\tparser.error(\"Expected valid attribute value\");\n  \t}\n\n  \tif (parser.sectionDepth !== startDepth) {\n  \t\tparser.pos = valueStart;\n  \t\tparser.error(\"An attribute value must contain as many opening section tags as closing section tags\");\n  \t}\n\n  \tif (!value.length) {\n  \t\treturn \"\";\n  \t}\n\n  \tif (value.length === 1 && typeof value[0] === \"string\") {\n  \t\treturn decodeCharacterReferences(value[0]);\n  \t}\n\n  \treturn value;\n  }\n\n  function readUnquotedAttributeValueToken(parser) {\n  \tvar start, text, haystack, needles, index;\n\n  \tstart = parser.pos;\n\n  \ttext = parser.matchPattern(unquotedAttributeValueTextPattern);\n\n  \tif (!text) {\n  \t\treturn null;\n  \t}\n\n  \thaystack = text;\n  \tneedles = parser.tags.map(function (t) {\n  \t\treturn t.open;\n  \t}); // TODO refactor... we do this in readText.js as well\n\n  \tif ((index = getLowestIndex(haystack, needles)) !== -1) {\n  \t\ttext = text.substr(0, index);\n  \t\tparser.pos = start + text.length;\n  \t}\n\n  \treturn text;\n  }\n\n  function readUnquotedAttributeValue(parser) {\n  \tvar tokens, token;\n\n  \tparser.inAttribute = true;\n\n  \ttokens = [];\n\n  \ttoken = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  \twhile (token !== null) {\n  \t\ttokens.push(token);\n  \t\ttoken = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  \t}\n\n  \tif (!tokens.length) {\n  \t\treturn null;\n  \t}\n\n  \tparser.inAttribute = false;\n  \treturn tokens;\n  }\n\n  function readQuotedAttributeValue(parser, quoteMark) {\n  \tvar start, tokens, token;\n\n  \tstart = parser.pos;\n\n  \tif (!parser.matchString(quoteMark)) {\n  \t\treturn null;\n  \t}\n\n  \tparser.inAttribute = quoteMark;\n\n  \ttokens = [];\n\n  \ttoken = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  \twhile (token !== null) {\n  \t\ttokens.push(token);\n  \t\ttoken = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  \t}\n\n  \tif (!parser.matchString(quoteMark)) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tparser.inAttribute = false;\n\n  \treturn tokens;\n  }\n\n  function readQuotedStringToken(parser, quoteMark) {\n  \tvar start, index, haystack, needles;\n\n  \tstart = parser.pos;\n  \thaystack = parser.remaining();\n\n  \tneedles = parser.tags.map(function (t) {\n  \t\treturn t.open;\n  \t}); // TODO refactor... we do this in readText.js as well\n  \tneedles.push(quoteMark);\n\n  \tindex = getLowestIndex(haystack, needles);\n\n  \tif (index === -1) {\n  \t\tparser.error(\"Quoted attribute value must have a closing quote\");\n  \t}\n\n  \tif (!index) {\n  \t\treturn null;\n  \t}\n\n  \tparser.pos += index;\n  \treturn haystack.substr(0, index);\n  }\n\n  var JsonParser, specials, specialsPattern, parseJSON__numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;\n\n  specials = {\n  \t\"true\": true,\n  \t\"false\": false,\n  \tundefined: undefined,\n  \t\"null\": null\n  };\n\n  specialsPattern = new RegExp(\"^(?:\" + Object.keys(specials).join(\"|\") + \")\");\n  parseJSON__numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n  placeholderPattern = /\\$\\{([^\\}]+)\\}/g;\n  placeholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\n  onlyWhitespace = /^\\s*$/;\n\n  JsonParser = parse_Parser.extend({\n  \tinit: function (str, options) {\n  \t\tthis.values = options.values;\n  \t\tthis.allowWhitespace();\n  \t},\n\n  \tpostProcess: function (result) {\n  \t\tif (result.length !== 1 || !onlyWhitespace.test(this.leftover)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn { value: result[0].v };\n  \t},\n\n  \tconverters: [function getPlaceholder(parser) {\n  \t\tvar placeholder;\n\n  \t\tif (!parser.values) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tplaceholder = parser.matchPattern(placeholderAtStartPattern);\n\n  \t\tif (placeholder && parser.values.hasOwnProperty(placeholder)) {\n  \t\t\treturn { v: parser.values[placeholder] };\n  \t\t}\n  \t}, function getSpecial(parser) {\n  \t\tvar special;\n\n  \t\tif (special = parser.matchPattern(specialsPattern)) {\n  \t\t\treturn { v: specials[special] };\n  \t\t}\n  \t}, function getNumber(parser) {\n  \t\tvar number;\n\n  \t\tif (number = parser.matchPattern(parseJSON__numberPattern)) {\n  \t\t\treturn { v: +number };\n  \t\t}\n  \t}, function getString(parser) {\n  \t\tvar stringLiteral = readStringLiteral(parser),\n  \t\t    values;\n\n  \t\tif (stringLiteral && (values = parser.values)) {\n  \t\t\treturn {\n  \t\t\t\tv: stringLiteral.v.replace(placeholderPattern, function (match, $1) {\n  \t\t\t\t\treturn $1 in values ? values[$1] : $1;\n  \t\t\t\t})\n  \t\t\t};\n  \t\t}\n\n  \t\treturn stringLiteral;\n  \t}, function getObject(parser) {\n  \t\tvar result, pair;\n\n  \t\tif (!parser.matchString(\"{\")) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tresult = {};\n\n  \t\tparser.allowWhitespace();\n\n  \t\tif (parser.matchString(\"}\")) {\n  \t\t\treturn { v: result };\n  \t\t}\n\n  \t\twhile (pair = getKeyValuePair(parser)) {\n  \t\t\tresult[pair.key] = pair.value;\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif (parser.matchString(\"}\")) {\n  \t\t\t\treturn { v: result };\n  \t\t\t}\n\n  \t\t\tif (!parser.matchString(\",\")) {\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t}\n\n  \t\treturn null;\n  \t}, function getArray(parser) {\n  \t\tvar result, valueToken;\n\n  \t\tif (!parser.matchString(\"[\")) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tresult = [];\n\n  \t\tparser.allowWhitespace();\n\n  \t\tif (parser.matchString(\"]\")) {\n  \t\t\treturn { v: result };\n  \t\t}\n\n  \t\twhile (valueToken = parser.read()) {\n  \t\t\tresult.push(valueToken.v);\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif (parser.matchString(\"]\")) {\n  \t\t\t\treturn { v: result };\n  \t\t\t}\n\n  \t\t\tif (!parser.matchString(\",\")) {\n  \t\t\t\treturn null;\n  \t\t\t}\n\n  \t\t\tparser.allowWhitespace();\n  \t\t}\n\n  \t\treturn null;\n  \t}]\n  });\n\n  function getKeyValuePair(parser) {\n  \tvar key, valueToken, pair;\n\n  \tparser.allowWhitespace();\n\n  \tkey = shared_readKey(parser);\n\n  \tif (!key) {\n  \t\treturn null;\n  \t}\n\n  \tpair = { key: key };\n\n  \tparser.allowWhitespace();\n  \tif (!parser.matchString(\":\")) {\n  \t\treturn null;\n  \t}\n  \tparser.allowWhitespace();\n\n  \tvalueToken = parser.read();\n  \tif (!valueToken) {\n  \t\treturn null;\n  \t}\n\n  \tpair.value = valueToken.v;\n\n  \treturn pair;\n  }\n\n  var parseJSON = function (str, values) {\n  \tvar parser = new JsonParser(str, {\n  \t\tvalues: values\n  \t});\n\n  \treturn parser.result;\n  };\n\n  // TODO clean this up, it's shocking\n  var element_processDirective = processDirective;\n  var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\\(/,\n      methodCallExcessPattern = /\\)\\s*$/,\n      ExpressionParser;\n\n  ExpressionParser = parse_Parser.extend({\n  \tconverters: [converters_readExpression]\n  });\n  function processDirective(tokens, parentParser) {\n  \tvar result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;\n\n  \tif (typeof tokens === \"string\") {\n  \t\tif (match = methodCallPattern.exec(tokens)) {\n  \t\t\tvar end = tokens.lastIndexOf(\")\");\n\n  \t\t\t// check for invalid method calls\n  \t\t\tif (!methodCallExcessPattern.test(tokens)) {\n  \t\t\t\tparentParser.error(\"Invalid input after method call expression '\" + tokens.slice(end + 1) + \"'\");\n  \t\t\t}\n\n  \t\t\tresult = { m: match[1] };\n  \t\t\targs = \"[\" + tokens.slice(result.m.length + 1, end) + \"]\";\n\n  \t\t\tparser = new ExpressionParser(args);\n  \t\t\tresult.a = utils_flattenExpression(parser.result[0]);\n\n  \t\t\treturn result;\n  \t\t}\n\n  \t\tif (tokens.indexOf(\":\") === -1) {\n  \t\t\treturn tokens.trim();\n  \t\t}\n\n  \t\ttokens = [tokens];\n  \t}\n\n  \tresult = {};\n\n  \tdirectiveName = [];\n  \tdirectiveArgs = [];\n\n  \tif (tokens) {\n  \t\twhile (tokens.length) {\n  \t\t\ttoken = tokens.shift();\n\n  \t\t\tif (typeof token === \"string\") {\n  \t\t\t\tcolonIndex = token.indexOf(\":\");\n\n  \t\t\t\tif (colonIndex === -1) {\n  \t\t\t\t\tdirectiveName.push(token);\n  \t\t\t\t} else {\n\n  \t\t\t\t\t// is the colon the first character?\n  \t\t\t\t\tif (colonIndex) {\n  \t\t\t\t\t\t// no\n  \t\t\t\t\t\tdirectiveName.push(token.substr(0, colonIndex));\n  \t\t\t\t\t}\n\n  \t\t\t\t\t// if there is anything after the colon in this token, treat\n  \t\t\t\t\t// it as the first token of the directiveArgs fragment\n  \t\t\t\t\tif (token.length > colonIndex + 1) {\n  \t\t\t\t\t\tdirectiveArgs[0] = token.substring(colonIndex + 1);\n  \t\t\t\t\t}\n\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t} else {\n  \t\t\t\tdirectiveName.push(token);\n  \t\t\t}\n  \t\t}\n\n  \t\tdirectiveArgs = directiveArgs.concat(tokens);\n  \t}\n\n  \tif (!directiveName.length) {\n  \t\tresult = \"\";\n  \t} else if (directiveArgs.length || typeof directiveName !== \"string\") {\n  \t\tresult = {\n  \t\t\t// TODO is this really necessary? just use the array\n  \t\t\tn: directiveName.length === 1 && typeof directiveName[0] === \"string\" ? directiveName[0] : directiveName\n  \t\t};\n\n  \t\tif (directiveArgs.length === 1 && typeof directiveArgs[0] === \"string\") {\n  \t\t\tparsed = parseJSON(\"[\" + directiveArgs[0] + \"]\");\n  \t\t\tresult.a = parsed ? parsed.value : directiveArgs[0].trim();\n  \t\t} else {\n  \t\t\tresult.d = directiveArgs;\n  \t\t}\n  \t} else {\n  \t\tresult = directiveName;\n  \t}\n\n  \treturn result;\n  }\n\n  var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/,\n      validTagNameFollower = /^[\\s\\n\\/>]/,\n      onPattern = /^on/,\n      proxyEventPattern = /^on-([a-zA-Z\\\\*\\\\.$_][a-zA-Z\\\\*\\\\.$_0-9\\-]+)$/,\n      reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,\n      directives = { \"intro-outro\": \"t0\", intro: \"t1\", outro: \"t2\", decorator: \"o\" },\n      exclude = { exclude: true },\n      disallowedContents;\n\n  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\n  disallowedContents = {\n  \tli: [\"li\"],\n  \tdt: [\"dt\", \"dd\"],\n  \tdd: [\"dt\", \"dd\"],\n  \tp: \"address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul\".split(\" \"),\n  \trt: [\"rt\", \"rp\"],\n  \trp: [\"rt\", \"rp\"],\n  \toptgroup: [\"optgroup\"],\n  \toption: [\"option\", \"optgroup\"],\n  \tthead: [\"tbody\", \"tfoot\"],\n  \ttbody: [\"tbody\", \"tfoot\"],\n  \ttfoot: [\"tbody\"],\n  \ttr: [\"tr\", \"tbody\"],\n  \ttd: [\"td\", \"th\", \"tr\"],\n  \tth: [\"td\", \"th\", \"tr\"]\n  };\n\n  var converters_readElement = readElement;\n\n  function readElement(parser) {\n  \tvar start, element, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, partials, hasPartials, child, closed, pos, remaining, closingTag;\n\n  \tstart = parser.pos;\n\n  \tif (parser.inside || parser.inAttribute) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchString(\"<\")) {\n  \t\treturn null;\n  \t}\n\n  \t// if this is a closing tag, abort straight away\n  \tif (parser.nextChar() === \"/\") {\n  \t\treturn null;\n  \t}\n\n  \telement = {};\n  \tif (parser.includeLinePositions) {\n  \t\telement.p = parser.getLinePos(start);\n  \t}\n\n  \tif (parser.matchString(\"!\")) {\n  \t\telement.t = DOCTYPE;\n  \t\tif (!parser.matchPattern(/^doctype/i)) {\n  \t\t\tparser.error(\"Expected DOCTYPE declaration\");\n  \t\t}\n\n  \t\telement.a = parser.matchPattern(/^(.+?)>/);\n  \t\treturn element;\n  \t}\n\n  \telement.t = ELEMENT;\n\n  \t// element name\n  \telement.e = parser.matchPattern(tagNamePattern);\n  \tif (!element.e) {\n  \t\treturn null;\n  \t}\n\n  \t// next character must be whitespace, closing solidus or '>'\n  \tif (!validTagNameFollower.test(parser.nextChar())) {\n  \t\tparser.error(\"Illegal tag name\");\n  \t}\n\n  \taddProxyEvent = function (name, directive) {\n  \t\tvar directiveName = directive.n || directive;\n\n  \t\tif (reservedEventNames.test(directiveName)) {\n  \t\t\tparser.pos -= directiveName.length;\n  \t\t\tparser.error(\"Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)\");\n  \t\t}\n\n  \t\telement.v[name] = directive;\n  \t};\n\n  \tparser.allowWhitespace();\n\n  \t// directives and attributes\n  \twhile (attribute = converters_readMustache(parser) || element_readAttribute(parser)) {\n  \t\t// regular attributes\n  \t\tif (attribute.name) {\n  \t\t\t// intro, outro, decorator\n  \t\t\tif (directiveName = directives[attribute.name]) {\n  \t\t\t\telement[directiveName] = element_processDirective(attribute.value, parser);\n  \t\t\t}\n\n  \t\t\t// on-click etc\n  \t\t\telse if (match = proxyEventPattern.exec(attribute.name)) {\n  \t\t\t\tif (!element.v) element.v = {};\n  \t\t\t\tdirective = element_processDirective(attribute.value, parser);\n  \t\t\t\taddProxyEvent(match[1], directive);\n  \t\t\t} else {\n  \t\t\t\tif (!parser.sanitizeEventAttributes || !onPattern.test(attribute.name)) {\n  \t\t\t\t\tif (!element.a) element.a = {};\n  \t\t\t\t\telement.a[attribute.name] = attribute.value || (attribute.value === \"\" ? \"\" : 0);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// {{#if foo}}class='foo'{{/if}}\n  \t\telse {\n  \t\t\tif (!element.m) element.m = [];\n  \t\t\telement.m.push(attribute);\n  \t\t}\n\n  \t\tparser.allowWhitespace();\n  \t}\n\n  \t// allow whitespace before closing solidus\n  \tparser.allowWhitespace();\n\n  \t// self-closing solidus?\n  \tif (parser.matchString(\"/\")) {\n  \t\tselfClosing = true;\n  \t}\n\n  \t// closing angle bracket\n  \tif (!parser.matchString(\">\")) {\n  \t\treturn null;\n  \t}\n\n  \tvar lowerCaseName = element.e.toLowerCase();\n  \tvar preserveWhitespace = parser.preserveWhitespace;\n\n  \tif (!selfClosing && !voidElementNames.test(element.e)) {\n  \t\tparser.elementStack.push(lowerCaseName);\n\n  \t\t// Special case - if we open a script element, further tags should\n  \t\t// be ignored unless they're a closing script element\n  \t\tif (lowerCaseName === \"script\" || lowerCaseName === \"style\") {\n  \t\t\tparser.inside = lowerCaseName;\n  \t\t}\n\n  \t\tchildren = [];\n  \t\tpartials = create(null);\n\n  \t\tdo {\n  \t\t\tpos = parser.pos;\n  \t\t\tremaining = parser.remaining();\n\n  \t\t\t// if for example we're in an <li> element, and we see another\n  \t\t\t// <li> tag, close the first so they become siblings\n  \t\t\tif (!canContain(lowerCaseName, remaining)) {\n  \t\t\t\tclosed = true;\n  \t\t\t}\n\n  \t\t\t// closing tag\n  \t\t\telse if (closingTag = element_readClosingTag(parser)) {\n  \t\t\t\tclosed = true;\n\n  \t\t\t\tvar closingTagName = closingTag.e.toLowerCase();\n\n  \t\t\t\t// if this *isn't* the closing tag for the current element...\n  \t\t\t\tif (closingTagName !== lowerCaseName) {\n  \t\t\t\t\t// rewind parser\n  \t\t\t\t\tparser.pos = pos;\n\n  \t\t\t\t\t// if it doesn't close a parent tag, error\n  \t\t\t\t\tif (! ~parser.elementStack.indexOf(closingTagName)) {\n  \t\t\t\t\t\tvar errorMessage = \"Unexpected closing tag\";\n\n  \t\t\t\t\t\t// add additional help for void elements, since component names\n  \t\t\t\t\t\t// might clash with them\n  \t\t\t\t\t\tif (voidElementNames.test(closingTagName)) {\n  \t\t\t\t\t\t\terrorMessage += \" (<\" + closingTagName + \"> is a void element - it cannot contain children)\";\n  \t\t\t\t\t\t}\n\n  \t\t\t\t\t\tparser.error(errorMessage);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\t// implicit close by closing section tag. TODO clean this up\n  \t\t\telse if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {\n  \t\t\t\tclosed = true;\n  \t\t\t\tparser.pos = pos;\n  \t\t\t} else {\n  \t\t\t\tif (child = parser.read(PARTIAL_READERS)) {\n  \t\t\t\t\tif (partials[child.n]) {\n  \t\t\t\t\t\tparser.pos = pos;\n  \t\t\t\t\t\tparser.error(\"Duplicate partial definition\");\n  \t\t\t\t\t}\n\n  \t\t\t\t\tutils_cleanup(child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);\n\n  \t\t\t\t\tpartials[child.n] = child.f;\n  \t\t\t\t\thasPartials = true;\n  \t\t\t\t} else {\n  \t\t\t\t\tif (child = parser.read(READERS)) {\n  \t\t\t\t\t\tchildren.push(child);\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tclosed = true;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} while (!closed);\n\n  \t\tif (children.length) {\n  \t\t\telement.f = children;\n  \t\t}\n\n  \t\tif (hasPartials) {\n  \t\t\telement.p = partials;\n  \t\t}\n\n  \t\tparser.elementStack.pop();\n  \t}\n\n  \tparser.inside = null;\n\n  \tif (parser.sanitizeElements && parser.sanitizeElements.indexOf(lowerCaseName) !== -1) {\n  \t\treturn exclude;\n  \t}\n\n  \treturn element;\n  }\n\n  function canContain(name, remaining) {\n  \tvar match, disallowed;\n\n  \tmatch = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(remaining);\n  \tdisallowed = disallowedContents[name];\n\n  \tif (!match || !disallowed) {\n  \t\treturn true;\n  \t}\n\n  \treturn ! ~disallowed.indexOf(match[1].toLowerCase());\n  }\n\n  var converters_readText = readText;\n  function readText(parser) {\n  \tvar index, remaining, disallowed, barrier;\n\n  \tremaining = parser.remaining();\n\n  \tbarrier = parser.inside ? \"</\" + parser.inside : \"<\";\n\n  \tif (parser.inside && !parser.interpolate[parser.inside]) {\n  \t\tindex = remaining.indexOf(barrier);\n  \t} else {\n  \t\tdisallowed = parser.tags.map(function (t) {\n  \t\t\treturn t.open;\n  \t\t});\n  \t\tdisallowed = disallowed.concat(parser.tags.map(function (t) {\n  \t\t\treturn \"\\\\\" + t.open;\n  \t\t}));\n\n  \t\t// http://developers.whatwg.org/syntax.html#syntax-attributes\n  \t\tif (parser.inAttribute === true) {\n  \t\t\t// we're inside an unquoted attribute value\n  \t\t\tdisallowed.push(\"\\\"\", \"'\", \"=\", \"<\", \">\", \"`\");\n  \t\t} else if (parser.inAttribute) {\n  \t\t\t// quoted attribute value\n  \t\t\tdisallowed.push(parser.inAttribute);\n  \t\t} else {\n  \t\t\tdisallowed.push(barrier);\n  \t\t}\n\n  \t\tindex = getLowestIndex(remaining, disallowed);\n  \t}\n\n  \tif (!index) {\n  \t\treturn null;\n  \t}\n\n  \tif (index === -1) {\n  \t\tindex = remaining.length;\n  \t}\n\n  \tparser.pos += index;\n\n  \treturn parser.inside ? remaining.substr(0, index) : decodeCharacterReferences(remaining.substr(0, index));\n  }\n\n  var utils_escapeRegExp = escapeRegExp;\n  var utils_escapeRegExp__pattern = /[-/\\\\^$*+?.()|[\\]{}]/g;\n  function escapeRegExp(str) {\n  \treturn str.replace(utils_escapeRegExp__pattern, \"\\\\$&\");\n  }\n\n  var converters_readPartialDefinitionComment = readPartialDefinitionComment;\n\n  var startPattern = /^<!--\\s*/,\n      namePattern = /s*>\\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\\s*/,\n      finishPattern = /\\s*-->/,\n      child;\n\n  function readPartialDefinitionComment(parser) {\n  \tvar firstPos = parser.pos,\n  \t    open = parser.standardDelimiters[0],\n  \t    close = parser.standardDelimiters[1],\n  \t    content = undefined,\n  \t    closed = undefined;\n\n  \tif (!parser.matchPattern(startPattern) || !parser.matchString(open)) {\n  \t\tparser.pos = firstPos;\n  \t\treturn null;\n  \t}\n\n  \tvar name = parser.matchPattern(namePattern);\n\n  \twarnOnceIfDebug(\"Inline partial comments are deprecated.\\nUse this...\\n  {{#partial \" + name + \"}} ... {{/partial}}\\n\\n...instead of this:\\n  <!-- {{>\" + name + \"}} --> ... <!-- {{/\" + name + \"}} -->'\");\n\n  \t// make sure the rest of the comment is in the correct place\n  \tif (!parser.matchString(close) || !parser.matchPattern(finishPattern)) {\n  \t\tparser.pos = firstPos;\n  \t\treturn null;\n  \t}\n\n  \tcontent = [];\n\n  \tvar endPattern = new RegExp(\"^<!--\\\\s*\" + utils_escapeRegExp(open) + \"\\\\s*\\\\/\\\\s*\" + name + \"\\\\s*\" + utils_escapeRegExp(close) + \"\\\\s*-->\");\n\n  \tdo {\n  \t\tif (parser.matchPattern(endPattern)) {\n  \t\t\tclosed = true;\n  \t\t} else {\n  \t\t\tchild = parser.read(READERS);\n  \t\t\tif (!child) {\n  \t\t\t\tparser.error(\"expected closing comment ('<!-- \" + open + \"/\" + name + \"\" + close + \" -->')\");\n  \t\t\t}\n\n  \t\t\tcontent.push(child);\n  \t\t}\n  \t} while (!closed);\n\n  \treturn {\n  \t\tt: INLINE_PARTIAL,\n  \t\tf: content,\n  \t\tn: name\n  \t};\n  }\n\n  var converters_readPartialDefinitionSection = readPartialDefinitionSection;\n  var partialDefinitionSectionPattern = /^#\\s*partial\\s+/;\n  function readPartialDefinitionSection(parser) {\n  \tvar start, name, content, child, closed;\n\n  \tstart = parser.pos;\n\n  \tvar delimiters = parser.standardDelimiters;\n\n  \tif (!parser.matchString(delimiters[0])) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchPattern(partialDefinitionSectionPattern)) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tname = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/);\n\n  \tif (!name) {\n  \t\tparser.error(\"expected legal partial name\");\n  \t}\n\n  \tif (!parser.matchString(delimiters[1])) {\n  \t\tparser.error(\"Expected closing delimiter '\" + delimiters[1] + \"'\");\n  \t}\n\n  \tcontent = [];\n\n  \tdo {\n  \t\t// TODO clean this up\n  \t\tif (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {\n  \t\t\tif (!child.r === \"partial\") {\n  \t\t\t\tparser.error(\"Expected \" + delimiters[0] + \"/partial\" + delimiters[1]);\n  \t\t\t}\n\n  \t\t\tclosed = true;\n  \t\t} else {\n  \t\t\tchild = parser.read(READERS);\n\n  \t\t\tif (!child) {\n  \t\t\t\tparser.error(\"Expected \" + delimiters[0] + \"/partial\" + delimiters[1]);\n  \t\t\t}\n\n  \t\t\tcontent.push(child);\n  \t\t}\n  \t} while (!closed);\n\n  \treturn {\n  \t\tt: INLINE_PARTIAL,\n  \t\tn: name,\n  \t\tf: content\n  \t};\n  }\n\n  var converters_readTemplate = readTemplate;\n  function readTemplate(parser) {\n  \tvar fragment = [];\n  \tvar partials = create(null);\n  \tvar hasPartials = false;\n\n  \tvar preserveWhitespace = parser.preserveWhitespace;\n\n  \twhile (parser.pos < parser.str.length) {\n  \t\tvar pos = parser.pos,\n  \t\t    item = undefined,\n  \t\t    partial = undefined;\n\n  \t\tif (partial = parser.read(PARTIAL_READERS)) {\n  \t\t\tif (partials[partial.n]) {\n  \t\t\t\tparser.pos = pos;\n  \t\t\t\tparser.error(\"Duplicated partial definition\");\n  \t\t\t}\n\n  \t\t\tutils_cleanup(partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);\n\n  \t\t\tpartials[partial.n] = partial.f;\n  \t\t\thasPartials = true;\n  \t\t} else if (item = parser.read(READERS)) {\n  \t\t\tfragment.push(item);\n  \t\t} else {\n  \t\t\tparser.error(\"Unexpected template content\");\n  \t\t}\n  \t}\n\n  \tvar result = {\n  \t\tv: TEMPLATE_VERSION,\n  \t\tt: fragment\n  \t};\n\n  \tif (hasPartials) {\n  \t\tresult.p = partials;\n  \t}\n\n  \treturn result;\n  }\n\n  var _parse = parse;\n\n  var STANDARD_READERS = [mustache_readPartial, mustache_readUnescaped, mustache_readSection, mustache_readYielder, mustache_readInterpolator, readMustacheComment];\n  var TRIPLE_READERS = [mustache_readTriple];\n  var STATIC_READERS = [mustache_readUnescaped, mustache_readSection, mustache_readInterpolator]; // TODO does it make sense to have a static section?\n\n  var StandardParser = undefined;\n  function parse(template, options) {\n  \treturn new StandardParser(template, options || {}).result;\n  }\n\n  var READERS = [converters_readMustache, converters_readHtmlComment, converters_readElement, converters_readText];\n  var PARTIAL_READERS = [converters_readPartialDefinitionComment, converters_readPartialDefinitionSection];\n\n  StandardParser = parse_Parser.extend({\n  \tinit: function (str, options) {\n  \t\tvar tripleDelimiters = options.tripleDelimiters || [\"{{{\", \"}}}\"],\n  \t\t    staticDelimiters = options.staticDelimiters || [\"[[\", \"]]\"],\n  \t\t    staticTripleDelimiters = options.staticTripleDelimiters || [\"[[[\", \"]]]\"];\n\n  \t\tthis.standardDelimiters = options.delimiters || [\"{{\", \"}}\"];\n\n  \t\tthis.tags = [{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS }, { isStatic: false, isTriple: true, open: tripleDelimiters[0], close: tripleDelimiters[1], readers: TRIPLE_READERS }, { isStatic: true, isTriple: false, open: staticDelimiters[0], close: staticDelimiters[1], readers: STATIC_READERS }, { isStatic: true, isTriple: true, open: staticTripleDelimiters[0], close: staticTripleDelimiters[1], readers: TRIPLE_READERS }];\n\n  \t\tthis.sortMustacheTags();\n\n  \t\tthis.sectionDepth = 0;\n  \t\tthis.elementStack = [];\n\n  \t\tthis.interpolate = {\n  \t\t\tscript: !options.interpolate || options.interpolate.script !== false,\n  \t\t\tstyle: !options.interpolate || options.interpolate.style !== false\n  \t\t};\n\n  \t\tif (options.sanitize === true) {\n  \t\t\toptions.sanitize = {\n  \t\t\t\t// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n  \t\t\t\telements: \"applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title\".split(\" \"),\n  \t\t\t\teventAttributes: true\n  \t\t\t};\n  \t\t}\n\n  \t\tthis.stripComments = options.stripComments !== false;\n  \t\tthis.preserveWhitespace = options.preserveWhitespace;\n  \t\tthis.sanitizeElements = options.sanitize && options.sanitize.elements;\n  \t\tthis.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n  \t\tthis.includeLinePositions = options.includeLinePositions;\n  \t},\n\n  \tpostProcess: function (result) {\n  \t\t// special case - empty string\n  \t\tif (!result.length) {\n  \t\t\treturn { t: [], v: TEMPLATE_VERSION };\n  \t\t}\n\n  \t\tif (this.sectionDepth > 0) {\n  \t\t\tthis.error(\"A section was left open\");\n  \t\t}\n\n  \t\tutils_cleanup(result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace);\n\n  \t\treturn result[0];\n  \t},\n\n  \tconverters: [converters_readTemplate],\n\n  \tsortMustacheTags: function () {\n  \t\t// Sort in order of descending opening delimiter length (longer first),\n  \t\t// to protect against opening delimiters being substrings of each other\n  \t\tthis.tags.sort(function (a, b) {\n  \t\t\treturn b.open.length - a.open.length;\n  \t\t});\n  \t}\n  });\n\n  var parseOptions = [\"preserveWhitespace\", \"sanitize\", \"stripComments\", \"delimiters\", \"tripleDelimiters\", \"interpolate\"];\n\n  var parser = {\n  \tfromId: fromId, isHashedId: isHashedId, isParsed: isParsed, getParseOptions: getParseOptions, createHelper: template_parser__createHelper,\n  \tparse: doParse\n  };\n\n  function template_parser__createHelper(parseOptions) {\n  \tvar helper = create(parser);\n  \thelper.parse = function (template, options) {\n  \t\treturn doParse(template, options || parseOptions);\n  \t};\n  \treturn helper;\n  }\n\n  function doParse(template, parseOptions) {\n  \tif (!_parse) {\n  \t\tthrow new Error(\"Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser\");\n  \t}\n\n  \treturn _parse(template, parseOptions || this.options);\n  }\n\n  function fromId(id, options) {\n  \tvar template;\n\n  \tif (!isClient) {\n  \t\tif (options && options.noThrow) {\n  \t\t\treturn;\n  \t\t}\n  \t\tthrow new Error(\"Cannot retrieve template #\" + id + \" as Ractive is not running in a browser.\");\n  \t}\n\n  \tif (isHashedId(id)) {\n  \t\tid = id.substring(1);\n  \t}\n\n  \tif (!(template = document.getElementById(id))) {\n  \t\tif (options && options.noThrow) {\n  \t\t\treturn;\n  \t\t}\n  \t\tthrow new Error(\"Could not find template element with id #\" + id);\n  \t}\n\n  \tif (template.tagName.toUpperCase() !== \"SCRIPT\") {\n  \t\tif (options && options.noThrow) {\n  \t\t\treturn;\n  \t\t}\n  \t\tthrow new Error(\"Template element with id #\" + id + \", must be a <script> element\");\n  \t}\n\n  \treturn \"textContent\" in template ? template.textContent : template.innerHTML;\n  }\n\n  function isHashedId(id) {\n  \treturn id && id[0] === \"#\";\n  }\n\n  function isParsed(template) {\n  \treturn !(typeof template === \"string\");\n  }\n\n  function getParseOptions(ractive) {\n  \t// Could be Ractive or a Component\n  \tif (ractive.defaults) {\n  \t\tractive = ractive.defaults;\n  \t}\n\n  \treturn parseOptions.reduce(function (val, key) {\n  \t\tval[key] = ractive[key];\n  \t\treturn val;\n  \t}, {});\n  }\n\n  var template_parser = parser;\n\n  var templateConfigurator = {\n  \tname: \"template\",\n\n  \textend: function extend(Parent, proto, options) {\n  \t\tvar template;\n\n  \t\t// only assign if exists\n  \t\tif (\"template\" in options) {\n  \t\t\ttemplate = options.template;\n\n  \t\t\tif (typeof template === \"function\") {\n  \t\t\t\tproto.template = template;\n  \t\t\t} else {\n  \t\t\t\tproto.template = parseIfString(template, proto);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tinit: function init(Parent, ractive, options) {\n  \t\tvar template, fn;\n\n  \t\t// TODO because of prototypal inheritance, we might just be able to use\n  \t\t// ractive.template, and not bother passing through the Parent object.\n  \t\t// At present that breaks the test mocks' expectations\n  \t\ttemplate = \"template\" in options ? options.template : Parent.prototype.template;\n\n  \t\tif (typeof template === \"function\") {\n  \t\t\tfn = template;\n  \t\t\ttemplate = getDynamicTemplate(ractive, fn);\n\n  \t\t\tractive._config.template = {\n  \t\t\t\tfn: fn,\n  \t\t\t\tresult: template\n  \t\t\t};\n  \t\t}\n\n  \t\ttemplate = parseIfString(template, ractive);\n\n  \t\t// TODO the naming of this is confusing - ractive.template refers to [...],\n  \t\t// but Component.prototype.template refers to {v:1,t:[],p:[]}...\n  \t\t// it's unnecessary, because the developer never needs to access\n  \t\t// ractive.template\n  \t\tractive.template = template.t;\n\n  \t\tif (template.p) {\n  \t\t\textendPartials(ractive.partials, template.p);\n  \t\t}\n  \t},\n\n  \treset: function (ractive) {\n  \t\tvar result = resetValue(ractive),\n  \t\t    parsed;\n\n  \t\tif (result) {\n  \t\t\tparsed = parseIfString(result, ractive);\n\n  \t\t\tractive.template = parsed.t;\n  \t\t\textendPartials(ractive.partials, parsed.p, true);\n\n  \t\t\treturn true;\n  \t\t}\n  \t}\n  };\n\n  function resetValue(ractive) {\n  \tvar initial = ractive._config.template,\n  \t    result;\n\n  \t// If this isn't a dynamic template, there's nothing to do\n  \tif (!initial || !initial.fn) {\n  \t\treturn;\n  \t}\n\n  \tresult = getDynamicTemplate(ractive, initial.fn);\n\n  \t// TODO deep equality check to prevent unnecessary re-rendering\n  \t// in the case of already-parsed templates\n  \tif (result !== initial.result) {\n  \t\tinitial.result = result;\n  \t\tresult = parseIfString(result, ractive);\n  \t\treturn result;\n  \t}\n  }\n\n  function getDynamicTemplate(ractive, fn) {\n  \tvar helper = template_template__createHelper(template_parser.getParseOptions(ractive));\n  \treturn fn.call(ractive, helper);\n  }\n\n  function template_template__createHelper(parseOptions) {\n  \tvar helper = create(template_parser);\n  \thelper.parse = function (template, options) {\n  \t\treturn template_parser.parse(template, options || parseOptions);\n  \t};\n  \treturn helper;\n  }\n\n  function parseIfString(template, ractive) {\n  \tif (typeof template === \"string\") {\n  \t\t// ID of an element containing the template?\n  \t\tif (template[0] === \"#\") {\n  \t\t\ttemplate = template_parser.fromId(template);\n  \t\t}\n\n  \t\ttemplate = _parse(template, template_parser.getParseOptions(ractive));\n  \t}\n\n  \t// Check that the template even exists\n  \telse if (template == undefined) {\n  \t\tthrow new Error(\"The template cannot be \" + template + \".\");\n  \t}\n\n  \t// Check the parsed template has a version at all\n  \telse if (typeof template.v !== \"number\") {\n  \t\tthrow new Error(\"The template parser was passed a non-string template, but the template doesn't have a version.  Make sure you're passing in the template you think you are.\");\n  \t}\n\n  \t// Check we're using the correct version\n  \telse if (template.v !== TEMPLATE_VERSION) {\n  \t\tthrow new Error(\"Mismatched template version (expected \" + TEMPLATE_VERSION + \", got \" + template.v + \") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app\");\n  \t}\n\n  \treturn template;\n  }\n\n  function extendPartials(existingPartials, newPartials, overwrite) {\n  \tif (!newPartials) return;\n\n  \t// TODO there's an ambiguity here - we need to overwrite in the `reset()`\n  \t// case, but not initially...\n\n  \tfor (var key in newPartials) {\n  \t\tif (overwrite || !existingPartials.hasOwnProperty(key)) {\n  \t\t\texistingPartials[key] = newPartials[key];\n  \t\t}\n  \t}\n  }\n\n  var template_template = templateConfigurator;\n\n  var config_registries__registryNames, Registry, registries;\n\n  config_registries__registryNames = [\"adaptors\", \"components\", \"computed\", \"decorators\", \"easing\", \"events\", \"interpolators\", \"partials\", \"transitions\"];\n\n  Registry = function (name, useDefaults) {\n  \tthis.name = name;\n  \tthis.useDefaults = useDefaults;\n  };\n\n  Registry.prototype = {\n  \tconstructor: Registry,\n\n  \textend: function (Parent, proto, options) {\n  \t\tthis.configure(this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options);\n  \t},\n\n  \tinit: function () {},\n\n  \tconfigure: function (Parent, target, options) {\n  \t\tvar name = this.name,\n  \t\t    option = options[name],\n  \t\t    registry;\n\n  \t\tregistry = create(Parent[name]);\n\n  \t\tfor (var key in option) {\n  \t\t\tregistry[key] = option[key];\n  \t\t}\n\n  \t\ttarget[name] = registry;\n  \t},\n\n  \treset: function (ractive) {\n  \t\tvar registry = ractive[this.name];\n  \t\tvar changed = false;\n  \t\tObject.keys(registry).forEach(function (key) {\n  \t\t\tvar item = registry[key];\n  \t\t\tif (item._fn) {\n  \t\t\t\tif (item._fn.isOwner) {\n  \t\t\t\t\tregistry[key] = item._fn;\n  \t\t\t\t} else {\n  \t\t\t\t\tdelete registry[key];\n  \t\t\t\t}\n  \t\t\t\tchanged = true;\n  \t\t\t}\n  \t\t});\n  \t\treturn changed;\n  \t}\n  };\n\n  registries = config_registries__registryNames.map(function (name) {\n  \treturn new Registry(name, name === \"computed\");\n  });\n\n  var config_registries = registries;\n\n  /*this.configure(\n  \tthis.useDefaults ? Parent.defaults : Parent,\n  \tractive,\n  \toptions );*/\n\n  var wrapPrototype = wrap;\n\n  function wrap(parent, name, method) {\n  \tif (!/_super/.test(method)) {\n  \t\treturn method;\n  \t}\n\n  \tvar wrapper = function wrapSuper() {\n  \t\tvar superMethod = getSuperMethod(wrapper._parent, name),\n  \t\t    hasSuper = (\"_super\" in this),\n  \t\t    oldSuper = this._super,\n  \t\t    result;\n\n  \t\tthis._super = superMethod;\n\n  \t\tresult = method.apply(this, arguments);\n\n  \t\tif (hasSuper) {\n  \t\t\tthis._super = oldSuper;\n  \t\t} else {\n  \t\t\tdelete this._super;\n  \t\t}\n\n  \t\treturn result;\n  \t};\n\n  \twrapper._parent = parent;\n  \twrapper._method = method;\n\n  \treturn wrapper;\n  }\n\n  function getSuperMethod(parent, name) {\n  \tvar value, method;\n\n  \tif (name in parent) {\n  \t\tvalue = parent[name];\n\n  \t\tif (typeof value === \"function\") {\n  \t\t\tmethod = value;\n  \t\t} else {\n  \t\t\tmethod = function returnValue() {\n  \t\t\t\treturn value;\n  \t\t\t};\n  \t\t}\n  \t} else {\n  \t\tmethod = noop;\n  \t}\n\n  \treturn method;\n  }\n\n  var config_deprecate = deprecate;\n  function getMessage(deprecated, correct, isError) {\n  \treturn \"options.\" + deprecated + \" has been deprecated in favour of options.\" + correct + \".\" + (isError ? \" You cannot specify both options, please use options.\" + correct + \".\" : \"\");\n  }\n\n  function deprecateOption(options, deprecatedOption, correct) {\n  \tif (deprecatedOption in options) {\n  \t\tif (!(correct in options)) {\n  \t\t\twarnIfDebug(getMessage(deprecatedOption, correct));\n  \t\t\toptions[correct] = options[deprecatedOption];\n  \t\t} else {\n  \t\t\tthrow new Error(getMessage(deprecatedOption, correct, true));\n  \t\t}\n  \t}\n  }\n  function deprecate(options) {\n  \tdeprecateOption(options, \"beforeInit\", \"onconstruct\");\n  \tdeprecateOption(options, \"init\", \"onrender\");\n  \tdeprecateOption(options, \"complete\", \"oncomplete\");\n  \tdeprecateOption(options, \"eventDefinitions\", \"events\");\n\n  \t// Using extend with Component instead of options,\n  \t// like Human.extend( Spider ) means adaptors as a registry\n  \t// gets copied to options. So we have to check if actually an array\n  \tif (isArray(options.adaptors)) {\n  \t\tdeprecateOption(options, \"adaptors\", \"adapt\");\n  \t}\n  }\n\n  var config, order, defaultKeys, custom, isBlacklisted, isStandardKey;\n\n  custom = {\n  \tadapt: custom_adapt,\n  \tcss: css_css,\n  \tdata: custom_data,\n  \ttemplate: template_template\n  };\n\n  defaultKeys = Object.keys(config_defaults);\n\n  isStandardKey = makeObj(defaultKeys.filter(function (key) {\n  \treturn !custom[key];\n  }));\n\n  // blacklisted keys that we don't double extend\n  isBlacklisted = makeObj(defaultKeys.concat(config_registries.map(function (r) {\n  \treturn r.name;\n  })));\n\n  order = [].concat(defaultKeys.filter(function (key) {\n  \treturn !config_registries[key] && !custom[key];\n  }), config_registries, custom.data, custom.template, custom.css);\n\n  config = {\n  \textend: function (Parent, proto, options) {\n  \t\treturn configure(\"extend\", Parent, proto, options);\n  \t},\n\n  \tinit: function (Parent, ractive, options) {\n  \t\treturn configure(\"init\", Parent, ractive, options);\n  \t},\n\n  \treset: function (ractive) {\n  \t\treturn order.filter(function (c) {\n  \t\t\treturn c.reset && c.reset(ractive);\n  \t\t}).map(function (c) {\n  \t\t\treturn c.name;\n  \t\t});\n  \t},\n\n  \t// this defines the order. TODO this isn't used anywhere in the codebase,\n  \t// only in the test suite - should get rid of it\n  \torder: order };\n\n  function configure(method, Parent, target, options) {\n  \tconfig_deprecate(options);\n\n  \tfor (var key in options) {\n  \t\tif (isStandardKey.hasOwnProperty(key)) {\n  \t\t\tvar value = options[key];\n\n  \t\t\t// warn the developer if they passed a function and ignore its value\n\n  \t\t\t// NOTE: we allow some functions on \"el\" because we duck type element lists\n  \t\t\t// and some libraries or ef'ed-up virtual browsers (phantomJS) return a\n  \t\t\t// function object as the result of querySelector methods\n  \t\t\tif (key !== \"el\" && typeof value === \"function\") {\n  \t\t\t\twarnIfDebug(\"\" + key + \" is a Ractive option that does not expect a function and will be ignored\", method === \"init\" ? target : null);\n  \t\t\t} else {\n  \t\t\t\ttarget[key] = value;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tconfig_registries.forEach(function (registry) {\n  \t\tregistry[method](Parent, target, options);\n  \t});\n\n  \tcustom_adapt[method](Parent, target, options);\n  \ttemplate_template[method](Parent, target, options);\n  \tcss_css[method](Parent, target, options);\n\n  \textendOtherMethods(Parent.prototype, target, options);\n  }\n\n  function extendOtherMethods(parent, target, options) {\n  \tfor (var key in options) {\n  \t\tif (!isBlacklisted[key] && options.hasOwnProperty(key)) {\n  \t\t\tvar member = options[key];\n\n  \t\t\t// if this is a method that overwrites a method, wrap it:\n  \t\t\tif (typeof member === \"function\") {\n  \t\t\t\tmember = wrapPrototype(parent, key, member);\n  \t\t\t}\n\n  \t\t\ttarget[key] = member;\n  \t\t}\n  \t}\n  }\n\n  function makeObj(array) {\n  \tvar obj = {};\n  \tarray.forEach(function (x) {\n  \t\treturn obj[x] = true;\n  \t});\n  \treturn obj;\n  }\n\n  var config_config = config;\n\n  var prototype_bubble = Fragment$bubble;\n\n  function Fragment$bubble() {\n  \tthis.dirtyValue = this.dirtyArgs = true;\n\n  \tif (this.bound && typeof this.owner.bubble === \"function\") {\n  \t\tthis.owner.bubble();\n  \t}\n  }\n\n  var Fragment_prototype_detach = Fragment$detach;\n\n  function Fragment$detach() {\n  \tvar docFrag;\n\n  \tif (this.items.length === 1) {\n  \t\treturn this.items[0].detach();\n  \t}\n\n  \tdocFrag = document.createDocumentFragment();\n\n  \tthis.items.forEach(function (item) {\n  \t\tvar node = item.detach();\n\n  \t\t// TODO The if {...} wasn't previously required - it is now, because we're\n  \t\t// forcibly detaching everything to reorder sections after an update. That's\n  \t\t// a non-ideal brute force approach, implemented to get all the tests to pass\n  \t\t// - as soon as it's replaced with something more elegant, this should\n  \t\t// revert to `docFrag.appendChild( item.detach() )`\n  \t\tif (node) {\n  \t\t\tdocFrag.appendChild(node);\n  \t\t}\n  \t});\n\n  \treturn docFrag;\n  }\n\n  var Fragment_prototype_find = Fragment$find;\n\n  function Fragment$find(selector) {\n  \tvar i, len, item, queryResult;\n\n  \tif (this.items) {\n  \t\tlen = this.items.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\titem = this.items[i];\n\n  \t\t\tif (item.find && (queryResult = item.find(selector))) {\n  \t\t\t\treturn queryResult;\n  \t\t\t}\n  \t\t}\n\n  \t\treturn null;\n  \t}\n  }\n\n  var Fragment_prototype_findAll = Fragment$findAll;\n\n  function Fragment$findAll(selector, query) {\n  \tvar i, len, item;\n\n  \tif (this.items) {\n  \t\tlen = this.items.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\titem = this.items[i];\n\n  \t\t\tif (item.findAll) {\n  \t\t\t\titem.findAll(selector, query);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn query;\n  }\n\n  var Fragment_prototype_findAllComponents = Fragment$findAllComponents;\n\n  function Fragment$findAllComponents(selector, query) {\n  \tvar i, len, item;\n\n  \tif (this.items) {\n  \t\tlen = this.items.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\titem = this.items[i];\n\n  \t\t\tif (item.findAllComponents) {\n  \t\t\t\titem.findAllComponents(selector, query);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn query;\n  }\n\n  var Fragment_prototype_findComponent = Fragment$findComponent;\n\n  function Fragment$findComponent(selector) {\n  \tvar len, i, item, queryResult;\n\n  \tif (this.items) {\n  \t\tlen = this.items.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\titem = this.items[i];\n\n  \t\t\tif (item.findComponent && (queryResult = item.findComponent(selector))) {\n  \t\t\t\treturn queryResult;\n  \t\t\t}\n  \t\t}\n\n  \t\treturn null;\n  \t}\n  }\n\n  var prototype_findNextNode = Fragment$findNextNode;\n\n  function Fragment$findNextNode(item) {\n  \tvar index = item.index,\n  \t    node;\n\n  \tif (this.items[index + 1]) {\n  \t\tnode = this.items[index + 1].firstNode();\n  \t}\n\n  \t// if this is the root fragment, and there are no more items,\n  \t// it means we're at the end...\n  \telse if (this.owner === this.root) {\n  \t\tif (!this.owner.component) {\n  \t\t\t// TODO but something else could have been appended to\n  \t\t\t// this.root.el, no?\n  \t\t\tnode = null;\n  \t\t}\n\n  \t\t// ...unless this is a component\n  \t\telse {\n  \t\t\tnode = this.owner.component.findNextNode();\n  \t\t}\n  \t} else {\n  \t\tnode = this.owner.findNextNode(this);\n  \t}\n\n  \treturn node;\n  }\n\n  var prototype_firstNode = Fragment$firstNode;\n\n  function Fragment$firstNode() {\n  \tif (this.items && this.items[0]) {\n  \t\treturn this.items[0].firstNode();\n  \t}\n\n  \treturn null;\n  }\n\n  var shared_processItems = processItems;\n\n  function processItems(items, values, guid, counter) {\n  \tcounter = counter || 0;\n\n  \treturn items.map(function (item) {\n  \t\tvar placeholderId, wrapped, value;\n\n  \t\tif (item.text) {\n  \t\t\treturn item.text;\n  \t\t}\n\n  \t\tif (item.fragments) {\n  \t\t\treturn item.fragments.map(function (fragment) {\n  \t\t\t\treturn processItems(fragment.items, values, guid, counter);\n  \t\t\t}).join(\"\");\n  \t\t}\n\n  \t\tplaceholderId = guid + \"-\" + counter++;\n\n  \t\tif (item.keypath && (wrapped = item.root.viewmodel.wrapped[item.keypath.str])) {\n  \t\t\tvalue = wrapped.value;\n  \t\t} else {\n  \t\t\tvalue = item.getValue();\n  \t\t}\n\n  \t\tvalues[placeholderId] = value;\n\n  \t\treturn \"${\" + placeholderId + \"}\";\n  \t}).join(\"\");\n  }\n\n  var getArgsList = Fragment$getArgsList;\n  function Fragment$getArgsList() {\n  \tvar values, source, parsed, result;\n\n  \tif (this.dirtyArgs) {\n  \t\tsource = shared_processItems(this.items, values = {}, this.root._guid);\n  \t\tparsed = parseJSON(\"[\" + source + \"]\", values);\n\n  \t\tif (!parsed) {\n  \t\t\tresult = [this.toString()];\n  \t\t} else {\n  \t\t\tresult = parsed.value;\n  \t\t}\n\n  \t\tthis.argsList = result;\n  \t\tthis.dirtyArgs = false;\n  \t}\n\n  \treturn this.argsList;\n  }\n\n  var getNode = Fragment$getNode;\n\n  function Fragment$getNode() {\n  \tvar fragment = this;\n\n  \tdo {\n  \t\tif (fragment.pElement) {\n  \t\t\treturn fragment.pElement.node;\n  \t\t}\n  \t} while (fragment = fragment.parent);\n\n  \treturn this.root.detached || this.root.el;\n  }\n\n  var prototype_getValue = Fragment$getValue;\n  function Fragment$getValue() {\n  \tvar values, source, parsed, result;\n\n  \tif (this.dirtyValue) {\n  \t\tsource = shared_processItems(this.items, values = {}, this.root._guid);\n  \t\tparsed = parseJSON(source, values);\n\n  \t\tif (!parsed) {\n  \t\t\tresult = this.toString();\n  \t\t} else {\n  \t\t\tresult = parsed.value;\n  \t\t}\n\n  \t\tthis.value = result;\n  \t\tthis.dirtyValue = false;\n  \t}\n\n  \treturn this.value;\n  }\n\n  var shared_detach = function () {\n  \treturn detachNode(this.node);\n  };\n\n  var Text = function (options) {\n  \tthis.type = TEXT;\n  \tthis.text = options.template;\n  };\n\n  Text.prototype = {\n  \tdetach: shared_detach,\n\n  \tfirstNode: function () {\n  \t\treturn this.node;\n  \t},\n\n  \trender: function () {\n  \t\tif (!this.node) {\n  \t\t\tthis.node = document.createTextNode(this.text);\n  \t\t}\n\n  \t\treturn this.node;\n  \t},\n\n  \ttoString: function (escape) {\n  \t\treturn escape ? escapeHtml(this.text) : this.text;\n  \t},\n\n  \tunrender: function (shouldDestroy) {\n  \t\tif (shouldDestroy) {\n  \t\t\treturn this.detach();\n  \t\t}\n  \t}\n  };\n\n  var items_Text = Text;\n\n  var shared_unbind = shared_unbind__unbind;\n\n  function shared_unbind__unbind() {\n  \tif (this.registered) {\n  \t\t// this was registered as a dependant\n  \t\tthis.root.viewmodel.unregister(this.keypath, this);\n  \t}\n\n  \tif (this.resolver) {\n  \t\tthis.resolver.unbind();\n  \t}\n  }\n\n  var Mustache_getValue = Mustache$getValue;\n\n  function Mustache$getValue() {\n  \treturn this.value;\n  }\n\n  var ReferenceResolver = function (owner, ref, callback) {\n  \tvar keypath;\n\n  \tthis.ref = ref;\n  \tthis.resolved = false;\n\n  \tthis.root = owner.root;\n  \tthis.parentFragment = owner.parentFragment;\n  \tthis.callback = callback;\n\n  \tkeypath = shared_resolveRef(owner.root, ref, owner.parentFragment);\n  \tif (keypath != undefined) {\n  \t\tthis.resolve(keypath);\n  \t} else {\n  \t\tglobal_runloop.addUnresolved(this);\n  \t}\n  };\n\n  ReferenceResolver.prototype = {\n  \tresolve: function (keypath) {\n  \t\tif (this.keypath && !keypath) {\n  \t\t\t// it was resolved, and now it's not. Can happen if e.g. `bar` in\n  \t\t\t// `{{foo[bar]}}` becomes undefined\n  \t\t\tglobal_runloop.addUnresolved(this);\n  \t\t}\n\n  \t\tthis.resolved = true;\n\n  \t\tthis.keypath = keypath;\n  \t\tthis.callback(keypath);\n  \t},\n\n  \tforceResolution: function () {\n  \t\tthis.resolve(getKeypath(this.ref));\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tvar keypath;\n\n  \t\tif (this.keypath != undefined) {\n  \t\t\tkeypath = this.keypath.replace(oldKeypath, newKeypath);\n  \t\t\t// was a new keypath created?\n  \t\t\tif (keypath !== undefined) {\n  \t\t\t\t// resolve it\n  \t\t\t\tthis.resolve(keypath);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tunbind: function () {\n  \t\tif (!this.resolved) {\n  \t\t\tglobal_runloop.removeUnresolved(this);\n  \t\t}\n  \t}\n  };\n\n  var Resolvers_ReferenceResolver = ReferenceResolver;\n\n  var SpecialResolver = function (owner, ref, callback) {\n  \tthis.parentFragment = owner.parentFragment;\n  \tthis.ref = ref;\n  \tthis.callback = callback;\n\n  \tthis.rebind();\n  };\n\n  var props = {\n  \t\"@keypath\": { prefix: \"c\", prop: [\"context\"] },\n  \t\"@index\": { prefix: \"i\", prop: [\"index\"] },\n  \t\"@key\": { prefix: \"k\", prop: [\"key\", \"index\"] }\n  };\n\n  function getProp(target, prop) {\n  \tvar value;\n  \tfor (var i = 0; i < prop.prop.length; i++) {\n  \t\tif ((value = target[prop.prop[i]]) !== undefined) {\n  \t\t\treturn value;\n  \t\t}\n  \t}\n  }\n\n  SpecialResolver.prototype = {\n  \trebind: function () {\n  \t\tvar ref = this.ref,\n  \t\t    fragment = this.parentFragment,\n  \t\t    prop = props[ref],\n  \t\t    value;\n\n  \t\tif (!prop) {\n  \t\t\tthrow new Error(\"Unknown special reference \\\"\" + ref + \"\\\" - valid references are @index, @key and @keypath\");\n  \t\t}\n\n  \t\t// have we already found the nearest parent?\n  \t\tif (this.cached) {\n  \t\t\treturn this.callback(getKeypath(\"@\" + prop.prefix + getProp(this.cached, prop)));\n  \t\t}\n\n  \t\t// special case for indices, which may cross component boundaries\n  \t\tif (prop.prop.indexOf(\"index\") !== -1 || prop.prop.indexOf(\"key\") !== -1) {\n  \t\t\twhile (fragment) {\n  \t\t\t\tif (fragment.owner.currentSubtype === SECTION_EACH && (value = getProp(fragment, prop)) !== undefined) {\n  \t\t\t\t\tthis.cached = fragment;\n\n  \t\t\t\t\tfragment.registerIndexRef(this);\n\n  \t\t\t\t\treturn this.callback(getKeypath(\"@\" + prop.prefix + value));\n  \t\t\t\t}\n\n  \t\t\t\t// watch for component boundaries\n  \t\t\t\tif (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {\n  \t\t\t\t\tfragment = fragment.owner.component.parentFragment;\n  \t\t\t\t} else {\n  \t\t\t\t\tfragment = fragment.parent;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else {\n  \t\t\twhile (fragment) {\n  \t\t\t\tif ((value = getProp(fragment, prop)) !== undefined) {\n  \t\t\t\t\treturn this.callback(getKeypath(\"@\" + prop.prefix + value.str));\n  \t\t\t\t}\n\n  \t\t\t\tfragment = fragment.parent;\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tunbind: function () {\n  \t\tif (this.cached) {\n  \t\t\tthis.cached.unregisterIndexRef(this);\n  \t\t}\n  \t}\n  };\n\n  var Resolvers_SpecialResolver = SpecialResolver;\n\n  var IndexResolver = function (owner, ref, callback) {\n  \tthis.parentFragment = owner.parentFragment;\n  \tthis.ref = ref;\n  \tthis.callback = callback;\n\n  \tref.ref.fragment.registerIndexRef(this);\n\n  \tthis.rebind();\n  };\n\n  IndexResolver.prototype = {\n  \trebind: function () {\n  \t\tvar index,\n  \t\t    ref = this.ref.ref;\n\n  \t\tif (ref.ref.t === \"k\") {\n  \t\t\tindex = \"k\" + ref.fragment.key;\n  \t\t} else {\n  \t\t\tindex = \"i\" + ref.fragment.index;\n  \t\t}\n\n  \t\tif (index !== undefined) {\n  \t\t\tthis.callback(getKeypath(\"@\" + index));\n  \t\t}\n  \t},\n\n  \tunbind: function () {\n  \t\tthis.ref.ref.fragment.unregisterIndexRef(this);\n  \t}\n  };\n\n  var Resolvers_IndexResolver = IndexResolver;\n\n  var Resolvers_findIndexRefs = findIndexRefs;\n\n  function findIndexRefs(fragment, refName) {\n  \tvar result = {},\n  \t    refs,\n  \t    fragRefs,\n  \t    ref,\n  \t    i,\n  \t    owner,\n  \t    hit = false;\n\n  \tif (!refName) {\n  \t\tresult.refs = refs = {};\n  \t}\n\n  \twhile (fragment) {\n  \t\tif ((owner = fragment.owner) && (fragRefs = owner.indexRefs)) {\n\n  \t\t\t// we're looking for a particular ref, and it's here\n  \t\t\tif (refName && (ref = owner.getIndexRef(refName))) {\n  \t\t\t\tresult.ref = {\n  \t\t\t\t\tfragment: fragment,\n  \t\t\t\t\tref: ref\n  \t\t\t\t};\n  \t\t\t\treturn result;\n  \t\t\t}\n\n  \t\t\t// we're collecting refs up-tree\n  \t\t\telse if (!refName) {\n  \t\t\t\tfor (i in fragRefs) {\n  \t\t\t\t\tref = fragRefs[i];\n\n  \t\t\t\t\t// don't overwrite existing refs - they should shadow parents\n  \t\t\t\t\tif (!refs[ref.n]) {\n  \t\t\t\t\t\thit = true;\n  \t\t\t\t\t\trefs[ref.n] = {\n  \t\t\t\t\t\t\tfragment: fragment,\n  \t\t\t\t\t\t\tref: ref\n  \t\t\t\t\t\t};\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// watch for component boundaries\n  \t\tif (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {\n  \t\t\tresult.componentBoundary = true;\n  \t\t\tfragment = fragment.owner.component.parentFragment;\n  \t\t} else {\n  \t\t\tfragment = fragment.parent;\n  \t\t}\n  \t}\n\n  \tif (!hit) {\n  \t\treturn undefined;\n  \t} else {\n  \t\treturn result;\n  \t}\n  }\n\n  findIndexRefs.resolve = function resolve(indices) {\n  \tvar refs = {},\n  \t    k,\n  \t    ref;\n\n  \tfor (k in indices.refs) {\n  \t\tref = indices.refs[k];\n  \t\trefs[ref.ref.n] = ref.ref.t === \"k\" ? ref.fragment.key : ref.fragment.index;\n  \t}\n\n  \treturn refs;\n  };\n\n  var Resolvers_createReferenceResolver = createReferenceResolver;\n  function createReferenceResolver(owner, ref, callback) {\n  \tvar indexRef;\n\n  \tif (ref.charAt(0) === \"@\") {\n  \t\treturn new Resolvers_SpecialResolver(owner, ref, callback);\n  \t}\n\n  \tif (indexRef = Resolvers_findIndexRefs(owner.parentFragment, ref)) {\n  \t\treturn new Resolvers_IndexResolver(owner, indexRef, callback);\n  \t}\n\n  \treturn new Resolvers_ReferenceResolver(owner, ref, callback);\n  }\n\n  var shared_getFunctionFromString = getFunctionFromString;\n  var cache = {};\n  function getFunctionFromString(str, i) {\n  \tvar fn, args;\n\n  \tif (cache[str]) {\n  \t\treturn cache[str];\n  \t}\n\n  \targs = [];\n  \twhile (i--) {\n  \t\targs[i] = \"_\" + i;\n  \t}\n\n  \tfn = new Function(args.join(\",\"), \"return(\" + str + \")\");\n\n  \tcache[str] = fn;\n  \treturn fn;\n  }\n\n  var ExpressionResolver,\n      Resolvers_ExpressionResolver__bind = Function.prototype.bind;\n\n  ExpressionResolver = function (owner, parentFragment, expression, callback) {\n  \tvar _this = this;\n\n  \tvar ractive;\n\n  \tractive = owner.root;\n\n  \tthis.root = ractive;\n  \tthis.parentFragment = parentFragment;\n  \tthis.callback = callback;\n  \tthis.owner = owner;\n  \tthis.str = expression.s;\n  \tthis.keypaths = [];\n\n  \t// Create resolvers for each reference\n  \tthis.pending = expression.r.length;\n  \tthis.refResolvers = expression.r.map(function (ref, i) {\n  \t\treturn Resolvers_createReferenceResolver(_this, ref, function (keypath) {\n  \t\t\t_this.resolve(i, keypath);\n  \t\t});\n  \t});\n\n  \tthis.ready = true;\n  \tthis.bubble();\n  };\n\n  ExpressionResolver.prototype = {\n  \tbubble: function () {\n  \t\tif (!this.ready) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.uniqueString = getUniqueString(this.str, this.keypaths);\n  \t\tthis.keypath = createExpressionKeypath(this.uniqueString);\n\n  \t\tthis.createEvaluator();\n  \t\tthis.callback(this.keypath);\n  \t},\n\n  \tunbind: function () {\n  \t\tvar resolver;\n\n  \t\twhile (resolver = this.refResolvers.pop()) {\n  \t\t\tresolver.unbind();\n  \t\t}\n  \t},\n\n  \tresolve: function (index, keypath) {\n  \t\tthis.keypaths[index] = keypath;\n  \t\tthis.bubble();\n  \t},\n\n  \tcreateEvaluator: function () {\n  \t\tvar _this = this;\n\n  \t\tvar computation, valueGetters, signature, keypath, fn;\n\n  \t\tkeypath = this.keypath;\n  \t\tcomputation = this.root.viewmodel.computations[keypath.str];\n\n  \t\t// only if it doesn't exist yet!\n  \t\tif (!computation) {\n  \t\t\tfn = shared_getFunctionFromString(this.str, this.refResolvers.length);\n\n  \t\t\tvalueGetters = this.keypaths.map(function (keypath) {\n  \t\t\t\tvar value;\n\n  \t\t\t\tif (keypath === \"undefined\") {\n  \t\t\t\t\treturn function () {\n  \t\t\t\t\t\treturn undefined;\n  \t\t\t\t\t};\n  \t\t\t\t}\n\n  \t\t\t\t// 'special' keypaths encode a value\n  \t\t\t\tif (keypath.isSpecial) {\n  \t\t\t\t\tvalue = keypath.value;\n  \t\t\t\t\treturn function () {\n  \t\t\t\t\t\treturn value;\n  \t\t\t\t\t};\n  \t\t\t\t}\n\n  \t\t\t\treturn function () {\n  \t\t\t\t\tvar value = _this.root.viewmodel.get(keypath, { noUnwrap: true, fullRootGet: true });\n  \t\t\t\t\tif (typeof value === \"function\") {\n  \t\t\t\t\t\tvalue = wrapFunction(value, _this.root);\n  \t\t\t\t\t}\n  \t\t\t\t\treturn value;\n  \t\t\t\t};\n  \t\t\t});\n\n  \t\t\tsignature = {\n  \t\t\t\tdeps: this.keypaths.filter(isValidDependency),\n  \t\t\t\tgetter: function () {\n  \t\t\t\t\tvar args = valueGetters.map(call);\n  \t\t\t\t\treturn fn.apply(null, args);\n  \t\t\t\t}\n  \t\t\t};\n\n  \t\t\tcomputation = this.root.viewmodel.compute(keypath, signature);\n  \t\t} else {\n  \t\t\tthis.root.viewmodel.mark(keypath);\n  \t\t}\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\t// TODO only bubble once, no matter how many references are affected by the rebind\n  \t\tthis.refResolvers.forEach(function (r) {\n  \t\t\treturn r.rebind(oldKeypath, newKeypath);\n  \t\t});\n  \t}\n  };\n\n  var Resolvers_ExpressionResolver = ExpressionResolver;\n\n  function call(value) {\n  \treturn value.call();\n  }\n\n  function getUniqueString(str, keypaths) {\n  \t// get string that is unique to this expression\n  \treturn str.replace(/_([0-9]+)/g, function (match, $1) {\n  \t\tvar keypath, value;\n\n  \t\t// make sure we're not replacing a non-keypath _[0-9]\n  \t\tif (+$1 >= keypaths.length) {\n  \t\t\treturn \"_\" + $1;\n  \t\t}\n\n  \t\tkeypath = keypaths[$1];\n\n  \t\tif (keypath === undefined) {\n  \t\t\treturn \"undefined\";\n  \t\t}\n\n  \t\tif (keypath.isSpecial) {\n  \t\t\tvalue = keypath.value;\n  \t\t\treturn typeof value === \"number\" ? value : \"\\\"\" + value + \"\\\"\";\n  \t\t}\n\n  \t\treturn keypath.str;\n  \t});\n  }\n\n  function createExpressionKeypath(uniqueString) {\n  \t// Sanitize by removing any periods or square brackets. Otherwise\n  \t// we can't split the keypath into keys!\n  \t// Remove asterisks too, since they mess with pattern observers\n  \treturn getKeypath(\"${\" + uniqueString.replace(/[\\.\\[\\]]/g, \"-\").replace(/\\*/, \"#MUL#\") + \"}\");\n  }\n\n  function isValidDependency(keypath) {\n  \treturn keypath !== undefined && keypath[0] !== \"@\";\n  }\n\n  function wrapFunction(fn, ractive) {\n  \tvar wrapped, prop, key;\n\n  \tif (fn.__ractive_nowrap) {\n  \t\treturn fn;\n  \t}\n\n  \tprop = \"__ractive_\" + ractive._guid;\n  \twrapped = fn[prop];\n\n  \tif (wrapped) {\n  \t\treturn wrapped;\n  \t} else if (/this/.test(fn.toString())) {\n  \t\tdefineProperty(fn, prop, {\n  \t\t\tvalue: Resolvers_ExpressionResolver__bind.call(fn, ractive),\n  \t\t\tconfigurable: true\n  \t\t});\n\n  \t\t// Add properties/methods to wrapped function\n  \t\tfor (key in fn) {\n  \t\t\tif (fn.hasOwnProperty(key)) {\n  \t\t\t\tfn[prop][key] = fn[key];\n  \t\t\t}\n  \t\t}\n\n  \t\tractive._boundFunctions.push({\n  \t\t\tfn: fn,\n  \t\t\tprop: prop\n  \t\t});\n\n  \t\treturn fn[prop];\n  \t}\n\n  \tdefineProperty(fn, \"__ractive_nowrap\", {\n  \t\tvalue: fn\n  \t});\n\n  \treturn fn.__ractive_nowrap;\n  }\n\n  var MemberResolver = function (template, resolver, parentFragment) {\n  \tvar _this = this;\n\n  \tthis.resolver = resolver;\n  \tthis.root = resolver.root;\n  \tthis.parentFragment = parentFragment;\n  \tthis.viewmodel = resolver.root.viewmodel;\n\n  \tif (typeof template === \"string\") {\n  \t\tthis.value = template;\n  \t}\n\n  \t// Simple reference?\n  \telse if (template.t === REFERENCE) {\n  \t\tthis.refResolver = Resolvers_createReferenceResolver(this, template.n, function (keypath) {\n  \t\t\t_this.resolve(keypath);\n  \t\t});\n  \t}\n\n  \t// Otherwise we have an expression in its own right\n  \telse {\n  \t\tnew Resolvers_ExpressionResolver(resolver, parentFragment, template, function (keypath) {\n  \t\t\t_this.resolve(keypath);\n  \t\t});\n  \t}\n  };\n\n  MemberResolver.prototype = {\n  \tresolve: function (keypath) {\n  \t\tif (this.keypath) {\n  \t\t\tthis.viewmodel.unregister(this.keypath, this);\n  \t\t}\n\n  \t\tthis.keypath = keypath;\n  \t\tthis.value = this.viewmodel.get(keypath);\n\n  \t\tthis.bind();\n\n  \t\tthis.resolver.bubble();\n  \t},\n\n  \tbind: function () {\n  \t\tthis.viewmodel.register(this.keypath, this);\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tif (this.refResolver) {\n  \t\t\tthis.refResolver.rebind(oldKeypath, newKeypath);\n  \t\t}\n  \t},\n\n  \tsetValue: function (value) {\n  \t\tthis.value = value;\n  \t\tthis.resolver.bubble();\n  \t},\n\n  \tunbind: function () {\n  \t\tif (this.keypath) {\n  \t\t\tthis.viewmodel.unregister(this.keypath, this);\n  \t\t}\n\n  \t\tif (this.refResolver) {\n  \t\t\tthis.refResolver.unbind();\n  \t\t}\n  \t},\n\n  \tforceResolution: function () {\n  \t\tif (this.refResolver) {\n  \t\t\tthis.refResolver.forceResolution();\n  \t\t}\n  \t}\n  };\n\n  var ReferenceExpressionResolver_MemberResolver = MemberResolver;\n\n  var ReferenceExpressionResolver = function (mustache, template, callback) {\n  \tvar _this = this;\n\n  \tvar ractive, ref, keypath, parentFragment;\n\n  \tthis.parentFragment = parentFragment = mustache.parentFragment;\n  \tthis.root = ractive = mustache.root;\n  \tthis.mustache = mustache;\n\n  \tthis.ref = ref = template.r;\n  \tthis.callback = callback;\n\n  \tthis.unresolved = [];\n\n  \t// Find base keypath\n  \tif (keypath = shared_resolveRef(ractive, ref, parentFragment)) {\n  \t\tthis.base = keypath;\n  \t} else {\n  \t\tthis.baseResolver = new Resolvers_ReferenceResolver(this, ref, function (keypath) {\n  \t\t\t_this.base = keypath;\n  \t\t\t_this.baseResolver = null;\n  \t\t\t_this.bubble();\n  \t\t});\n  \t}\n\n  \t// Find values for members, or mark them as unresolved\n  \tthis.members = template.m.map(function (template) {\n  \t\treturn new ReferenceExpressionResolver_MemberResolver(template, _this, parentFragment);\n  \t});\n\n  \tthis.ready = true;\n  \tthis.bubble(); // trigger initial resolution if possible\n  };\n\n  ReferenceExpressionResolver.prototype = {\n  \tgetKeypath: function () {\n  \t\tvar values = this.members.map(ReferenceExpressionResolver_ReferenceExpressionResolver__getValue);\n\n  \t\tif (!values.every(isDefined) || this.baseResolver) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn this.base.join(values.join(\".\"));\n  \t},\n\n  \tbubble: function () {\n  \t\tif (!this.ready || this.baseResolver) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.callback(this.getKeypath());\n  \t},\n\n  \tunbind: function () {\n  \t\tthis.members.forEach(methodCallers__unbind);\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tvar changed;\n\n  \t\tif (this.base) {\n  \t\t\tvar newBase = this.base.replace(oldKeypath, newKeypath);\n  \t\t\tif (newBase && newBase !== this.base) {\n  \t\t\t\tthis.base = newBase;\n  \t\t\t\tchanged = true;\n  \t\t\t}\n  \t\t}\n\n  \t\tthis.members.forEach(function (members) {\n  \t\t\tif (members.rebind(oldKeypath, newKeypath)) {\n  \t\t\t\tchanged = true;\n  \t\t\t}\n  \t\t});\n\n  \t\tif (changed) {\n  \t\t\tthis.bubble();\n  \t\t}\n  \t},\n\n  \tforceResolution: function () {\n  \t\tif (this.baseResolver) {\n  \t\t\tthis.base = getKeypath(this.ref);\n\n  \t\t\tthis.baseResolver.unbind();\n  \t\t\tthis.baseResolver = null;\n  \t\t}\n\n  \t\tthis.members.forEach(forceResolution);\n  \t\tthis.bubble();\n  \t}\n  };\n\n  function ReferenceExpressionResolver_ReferenceExpressionResolver__getValue(member) {\n  \treturn member.value;\n  }\n\n  function isDefined(value) {\n  \treturn value != undefined;\n  }\n\n  function forceResolution(member) {\n  \tmember.forceResolution();\n  }\n\n  var ReferenceExpressionResolver_ReferenceExpressionResolver = ReferenceExpressionResolver;\n\n  var Mustache_initialise = Mustache$init;\n  function Mustache$init(mustache, options) {\n\n  \tvar ref, parentFragment, template;\n\n  \tparentFragment = options.parentFragment;\n  \ttemplate = options.template;\n\n  \tmustache.root = parentFragment.root;\n  \tmustache.parentFragment = parentFragment;\n  \tmustache.pElement = parentFragment.pElement;\n\n  \tmustache.template = options.template;\n  \tmustache.index = options.index || 0;\n  \tmustache.isStatic = options.template.s;\n\n  \tmustache.type = options.template.t;\n\n  \tmustache.registered = false;\n\n  \t// if this is a simple mustache, with a reference, we just need to resolve\n  \t// the reference to a keypath\n  \tif (ref = template.r) {\n  \t\tmustache.resolver = Resolvers_createReferenceResolver(mustache, ref, resolve);\n  \t}\n\n  \t// if it's an expression, we have a bit more work to do\n  \tif (options.template.x) {\n  \t\tmustache.resolver = new Resolvers_ExpressionResolver(mustache, parentFragment, options.template.x, resolveAndRebindChildren);\n  \t}\n\n  \tif (options.template.rx) {\n  \t\tmustache.resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(mustache, options.template.rx, resolveAndRebindChildren);\n  \t}\n\n  \t// Special case - inverted sections\n  \tif (mustache.template.n === SECTION_UNLESS && !mustache.hasOwnProperty(\"value\")) {\n  \t\tmustache.setValue(undefined);\n  \t}\n\n  \tfunction resolve(keypath) {\n  \t\tmustache.resolve(keypath);\n  \t}\n\n  \tfunction resolveAndRebindChildren(newKeypath) {\n  \t\tvar oldKeypath = mustache.keypath;\n\n  \t\tif (newKeypath != oldKeypath) {\n  \t\t\tmustache.resolve(newKeypath);\n\n  \t\t\tif (oldKeypath !== undefined) {\n  \t\t\t\tmustache.fragments && mustache.fragments.forEach(function (f) {\n  \t\t\t\t\tf.rebind(oldKeypath, newKeypath);\n  \t\t\t\t});\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  var Mustache_resolve = Mustache$resolve;\n\n  function Mustache$resolve(keypath) {\n  \tvar wasResolved, value, twowayBinding;\n\n  \t// 'Special' keypaths, e.g. @foo or @7, encode a value\n  \tif (keypath && keypath.isSpecial) {\n  \t\tthis.keypath = keypath;\n  \t\tthis.setValue(keypath.value);\n  \t\treturn;\n  \t}\n\n  \t// If we resolved previously, we need to unregister\n  \tif (this.registered) {\n  \t\t// undefined or null\n  \t\tthis.root.viewmodel.unregister(this.keypath, this);\n  \t\tthis.registered = false;\n\n  \t\twasResolved = true;\n  \t}\n\n  \tthis.keypath = keypath;\n\n  \t// If the new keypath exists, we need to register\n  \t// with the viewmodel\n  \tif (keypath != undefined) {\n  \t\t// undefined or null\n  \t\tvalue = this.root.viewmodel.get(keypath);\n  \t\tthis.root.viewmodel.register(keypath, this);\n\n  \t\tthis.registered = true;\n  \t}\n\n  \t// Either way we need to queue up a render (`value`\n  \t// will be `undefined` if there's no keypath)\n  \tthis.setValue(value);\n\n  \t// Two-way bindings need to point to their new target keypath\n  \tif (wasResolved && (twowayBinding = this.twowayBinding)) {\n  \t\ttwowayBinding.rebound();\n  \t}\n  }\n\n  var Mustache_rebind = Mustache$rebind;\n\n  function Mustache$rebind(oldKeypath, newKeypath) {\n  \t// Children first\n  \tif (this.fragments) {\n  \t\tthis.fragments.forEach(function (f) {\n  \t\t\treturn f.rebind(oldKeypath, newKeypath);\n  \t\t});\n  \t}\n\n  \t// Expression mustache?\n  \tif (this.resolver) {\n  \t\tthis.resolver.rebind(oldKeypath, newKeypath);\n  \t}\n  }\n\n  var Mustache = {\n  \tgetValue: Mustache_getValue,\n  \tinit: Mustache_initialise,\n  \tresolve: Mustache_resolve,\n  \trebind: Mustache_rebind\n  };\n\n  var Interpolator = function (options) {\n  \tthis.type = INTERPOLATOR;\n  \tMustache.init(this, options);\n  };\n\n  Interpolator.prototype = {\n  \tupdate: function () {\n  \t\tthis.node.data = this.value == undefined ? \"\" : this.value;\n  \t},\n  \tresolve: Mustache.resolve,\n  \trebind: Mustache.rebind,\n  \tdetach: shared_detach,\n\n  \tunbind: shared_unbind,\n\n  \trender: function () {\n  \t\tif (!this.node) {\n  \t\t\tthis.node = document.createTextNode(safeToStringValue(this.value));\n  \t\t}\n\n  \t\treturn this.node;\n  \t},\n\n  \tunrender: function (shouldDestroy) {\n  \t\tif (shouldDestroy) {\n  \t\t\tdetachNode(this.node);\n  \t\t}\n  \t},\n\n  \tgetValue: Mustache.getValue,\n\n  \t// TEMP\n  \tsetValue: function (value) {\n  \t\tvar wrapper;\n\n  \t\t// TODO is there a better way to approach this?\n  \t\tif (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {\n  \t\t\tvalue = wrapper.get();\n  \t\t}\n\n  \t\tif (!isEqual(value, this.value)) {\n  \t\t\tthis.value = value;\n  \t\t\tthis.parentFragment.bubble();\n\n  \t\t\tif (this.node) {\n  \t\t\t\tglobal_runloop.addView(this);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tfirstNode: function () {\n  \t\treturn this.node;\n  \t},\n\n  \ttoString: function (escape) {\n  \t\tvar string = \"\" + safeToStringValue(this.value);\n  \t\treturn escape ? escapeHtml(string) : string;\n  \t}\n  };\n\n  var items_Interpolator = Interpolator;\n\n  var Section_prototype_bubble = Section$bubble;\n\n  function Section$bubble() {\n  \tthis.parentFragment.bubble();\n  }\n\n  var Section_prototype_detach = Section$detach;\n\n  function Section$detach() {\n  \tvar docFrag;\n\n  \tif (this.fragments.length === 1) {\n  \t\treturn this.fragments[0].detach();\n  \t}\n\n  \tdocFrag = document.createDocumentFragment();\n\n  \tthis.fragments.forEach(function (item) {\n  \t\tdocFrag.appendChild(item.detach());\n  \t});\n\n  \treturn docFrag;\n  }\n\n  var find = Section$find;\n\n  function Section$find(selector) {\n  \tvar i, len, queryResult;\n\n  \tlen = this.fragments.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tif (queryResult = this.fragments[i].find(selector)) {\n  \t\t\treturn queryResult;\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  var findAll = Section$findAll;\n\n  function Section$findAll(selector, query) {\n  \tvar i, len;\n\n  \tlen = this.fragments.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tthis.fragments[i].findAll(selector, query);\n  \t}\n  }\n\n  var findAllComponents = Section$findAllComponents;\n\n  function Section$findAllComponents(selector, query) {\n  \tvar i, len;\n\n  \tlen = this.fragments.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tthis.fragments[i].findAllComponents(selector, query);\n  \t}\n  }\n\n  var findComponent = Section$findComponent;\n\n  function Section$findComponent(selector) {\n  \tvar i, len, queryResult;\n\n  \tlen = this.fragments.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tif (queryResult = this.fragments[i].findComponent(selector)) {\n  \t\t\treturn queryResult;\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  var findNextNode = Section$findNextNode;\n\n  function Section$findNextNode(fragment) {\n  \tif (this.fragments[fragment.index + 1]) {\n  \t\treturn this.fragments[fragment.index + 1].firstNode();\n  \t}\n\n  \treturn this.parentFragment.findNextNode(this);\n  }\n\n  var firstNode = Section$firstNode;\n\n  function Section$firstNode() {\n  \tvar len, i, node;\n\n  \tif (len = this.fragments.length) {\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\tif (node = this.fragments[i].firstNode()) {\n  \t\t\t\treturn node;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn this.parentFragment.findNextNode(this);\n  }\n\n  var shuffle = Section$shuffle;\n\n  function Section$shuffle(newIndices) {\n  \tvar _this = this;\n\n  \tvar parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;\n\n  \t// short circuit any double-updates, and ensure that this isn't applied to\n  \t// non-list sections\n  \tif (this.shuffling || this.unbound || this.currentSubtype !== SECTION_EACH) {\n  \t\treturn;\n  \t}\n\n  \tthis.shuffling = true;\n  \tglobal_runloop.scheduleTask(function () {\n  \t\treturn _this.shuffling = false;\n  \t});\n\n  \tparentFragment = this.parentFragment;\n\n  \treboundFragments = [];\n\n  \t// TODO: need to update this\n  \t// first, rebind existing fragments\n  \tnewIndices.forEach(function (newIndex, oldIndex) {\n  \t\tvar fragment, by, oldKeypath, newKeypath, deps;\n\n  \t\tif (newIndex === oldIndex) {\n  \t\t\treboundFragments[newIndex] = _this.fragments[oldIndex];\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfragment = _this.fragments[oldIndex];\n\n  \t\tif (firstChange === undefined) {\n  \t\t\tfirstChange = oldIndex;\n  \t\t}\n\n  \t\t// does this fragment need to be torn down?\n  \t\tif (newIndex === -1) {\n  \t\t\t_this.fragmentsToUnrender.push(fragment);\n  \t\t\tfragment.unbind();\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// Otherwise, it needs to be rebound to a new index\n  \t\tby = newIndex - oldIndex;\n  \t\toldKeypath = _this.keypath.join(oldIndex);\n  \t\tnewKeypath = _this.keypath.join(newIndex);\n\n  \t\tfragment.index = newIndex;\n\n  \t\t// notify any registered index refs directly\n  \t\tif (deps = fragment.registeredIndexRefs) {\n  \t\t\tdeps.forEach(shuffle__blindRebind);\n  \t\t}\n\n  \t\tfragment.rebind(oldKeypath, newKeypath);\n  \t\treboundFragments[newIndex] = fragment;\n  \t});\n\n  \tnewLength = this.root.viewmodel.get(this.keypath).length;\n\n  \t// If nothing changed with the existing fragments, then we start adding\n  \t// new fragments at the end...\n  \tif (firstChange === undefined) {\n  \t\t// ...unless there are no new fragments to add\n  \t\tif (this.length === newLength) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfirstChange = this.length;\n  \t}\n\n  \tthis.length = this.fragments.length = newLength;\n\n  \tif (this.rendered) {\n  \t\tglobal_runloop.addView(this);\n  \t}\n\n  \t// Prepare new fragment options\n  \tfragmentOptions = {\n  \t\ttemplate: this.template.f,\n  \t\troot: this.root,\n  \t\towner: this\n  \t};\n\n  \t// Add as many new fragments as we need to, or add back existing\n  \t// (detached) fragments\n  \tfor (i = firstChange; i < newLength; i += 1) {\n  \t\tfragment = reboundFragments[i];\n\n  \t\tif (!fragment) {\n  \t\t\tthis.fragmentsToCreate.push(i);\n  \t\t}\n\n  \t\tthis.fragments[i] = fragment;\n  \t}\n  }\n\n  function shuffle__blindRebind(dep) {\n  \t// the keypath doesn't actually matter here as it won't have changed\n  \tdep.rebind(\"\", \"\");\n  }\n\n  var prototype_rebind = function (oldKeypath, newKeypath) {\n  \tMustache.rebind.call(this, oldKeypath, newKeypath);\n  };\n\n  var Section_prototype_render = Section$render;\n\n  function Section$render() {\n  \tvar _this = this;\n\n  \tthis.docFrag = document.createDocumentFragment();\n\n  \tthis.fragments.forEach(function (f) {\n  \t\treturn _this.docFrag.appendChild(f.render());\n  \t});\n\n  \tthis.renderedFragments = this.fragments.slice();\n  \tthis.fragmentsToRender = [];\n\n  \tthis.rendered = true;\n  \treturn this.docFrag;\n  }\n\n  var setValue = Section$setValue;\n\n  function Section$setValue(value) {\n  \tvar _this = this;\n\n  \tvar wrapper, fragmentOptions;\n\n  \tif (this.updating) {\n  \t\t// If a child of this section causes a re-evaluation - for example, an\n  \t\t// expression refers to a function that mutates the array that this\n  \t\t// section depends on - we'll end up with a double rendering bug (see\n  \t\t// https://github.com/ractivejs/ractive/issues/748). This prevents it.\n  \t\treturn;\n  \t}\n\n  \tthis.updating = true;\n\n  \t// with sections, we need to get the fake value if we have a wrapped object\n  \tif (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {\n  \t\tvalue = wrapper.get();\n  \t}\n\n  \t// If any fragments are awaiting creation after a splice,\n  \t// this is the place to do it\n  \tif (this.fragmentsToCreate.length) {\n  \t\tfragmentOptions = {\n  \t\t\ttemplate: this.template.f || [],\n  \t\t\troot: this.root,\n  \t\t\tpElement: this.pElement,\n  \t\t\towner: this\n  \t\t};\n\n  \t\tthis.fragmentsToCreate.forEach(function (index) {\n  \t\t\tvar fragment;\n\n  \t\t\tfragmentOptions.context = _this.keypath.join(index);\n  \t\t\tfragmentOptions.index = index;\n\n  \t\t\tfragment = new virtualdom_Fragment(fragmentOptions);\n  \t\t\t_this.fragmentsToRender.push(_this.fragments[index] = fragment);\n  \t\t});\n\n  \t\tthis.fragmentsToCreate.length = 0;\n  \t} else if (reevaluateSection(this, value)) {\n  \t\tthis.bubble();\n\n  \t\tif (this.rendered) {\n  \t\t\tglobal_runloop.addView(this);\n  \t\t}\n  \t}\n\n  \tthis.value = value;\n  \tthis.updating = false;\n  }\n\n  function changeCurrentSubtype(section, value, obj) {\n  \tif (value === SECTION_EACH) {\n  \t\t// make sure ref type is up to date for key or value indices\n  \t\tif (section.indexRefs && section.indexRefs[0]) {\n  \t\t\tvar ref = section.indexRefs[0];\n\n  \t\t\t// when switching flavors, make sure the section gets updated\n  \t\t\tif (obj && ref.t === \"i\" || !obj && ref.t === \"k\") {\n  \t\t\t\t// if switching from object to list, unbind all of the old fragments\n  \t\t\t\tif (!obj) {\n  \t\t\t\t\tsection.length = 0;\n  \t\t\t\t\tsection.fragmentsToUnrender = section.fragments.slice(0);\n  \t\t\t\t\tsection.fragmentsToUnrender.forEach(function (f) {\n  \t\t\t\t\t\treturn f.unbind();\n  \t\t\t\t\t});\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tref.t = obj ? \"k\" : \"i\";\n  \t\t}\n  \t}\n\n  \tsection.currentSubtype = value;\n  }\n\n  function reevaluateSection(section, value) {\n  \tvar fragmentOptions = {\n  \t\ttemplate: section.template.f || [],\n  \t\troot: section.root,\n  \t\tpElement: section.parentFragment.pElement,\n  \t\towner: section\n  \t};\n\n  \tsection.hasContext = true;\n\n  \t// If we already know the section type, great\n  \t// TODO can this be optimised? i.e. pick an reevaluateSection function during init\n  \t// and avoid doing this each time?\n  \tif (section.subtype) {\n  \t\tswitch (section.subtype) {\n  \t\t\tcase SECTION_IF:\n  \t\t\t\tsection.hasContext = false;\n  \t\t\t\treturn reevaluateConditionalSection(section, value, false, fragmentOptions);\n\n  \t\t\tcase SECTION_UNLESS:\n  \t\t\t\tsection.hasContext = false;\n  \t\t\t\treturn reevaluateConditionalSection(section, value, true, fragmentOptions);\n\n  \t\t\tcase SECTION_WITH:\n  \t\t\t\treturn reevaluateContextSection(section, fragmentOptions);\n\n  \t\t\tcase SECTION_IF_WITH:\n  \t\t\t\treturn reevaluateConditionalContextSection(section, value, fragmentOptions);\n\n  \t\t\tcase SECTION_EACH:\n  \t\t\t\tif (isObject(value)) {\n  \t\t\t\t\tchangeCurrentSubtype(section, section.subtype, true);\n  \t\t\t\t\treturn reevaluateListObjectSection(section, value, fragmentOptions);\n  \t\t\t\t}\n\n  \t\t\t\t// Fallthrough - if it's a conditional or an array we need to continue\n  \t\t}\n  \t}\n\n  \t// Otherwise we need to work out what sort of section we're dealing with\n  \tsection.ordered = !!isArrayLike(value);\n\n  \t// Ordered list section\n  \tif (section.ordered) {\n  \t\tchangeCurrentSubtype(section, SECTION_EACH, false);\n  \t\treturn reevaluateListSection(section, value, fragmentOptions);\n  \t}\n\n  \t// Unordered list, or context\n  \tif (isObject(value) || typeof value === \"function\") {\n  \t\t// Index reference indicates section should be treated as a list\n  \t\tif (section.template.i) {\n  \t\t\tchangeCurrentSubtype(section, SECTION_EACH, true);\n  \t\t\treturn reevaluateListObjectSection(section, value, fragmentOptions);\n  \t\t}\n\n  \t\t// Otherwise, object provides context for contents\n  \t\tchangeCurrentSubtype(section, SECTION_WITH, false);\n  \t\treturn reevaluateContextSection(section, fragmentOptions);\n  \t}\n\n  \t// Conditional section\n  \tchangeCurrentSubtype(section, SECTION_IF, false);\n  \tsection.hasContext = false;\n  \treturn reevaluateConditionalSection(section, value, false, fragmentOptions);\n  }\n\n  function reevaluateListSection(section, value, fragmentOptions) {\n  \tvar i, length, fragment;\n\n  \tlength = value.length;\n\n  \tif (length === section.length) {\n  \t\t// Nothing to do\n  \t\treturn false;\n  \t}\n\n  \t// if the array is shorter than it was previously, remove items\n  \tif (length < section.length) {\n  \t\tsection.fragmentsToUnrender = section.fragments.splice(length, section.length - length);\n  \t\tsection.fragmentsToUnrender.forEach(methodCallers__unbind);\n  \t}\n\n  \t// otherwise...\n  \telse {\n  \t\tif (length > section.length) {\n  \t\t\t// add any new ones\n  \t\t\tfor (i = section.length; i < length; i += 1) {\n  \t\t\t\t// append list item to context stack\n  \t\t\t\tfragmentOptions.context = section.keypath.join(i);\n  \t\t\t\tfragmentOptions.index = i;\n\n  \t\t\t\tfragment = new virtualdom_Fragment(fragmentOptions);\n  \t\t\t\tsection.fragmentsToRender.push(section.fragments[i] = fragment);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tsection.length = length;\n  \treturn true;\n  }\n\n  function reevaluateListObjectSection(section, value, fragmentOptions) {\n  \tvar id, i, hasKey, fragment, changed, deps;\n\n  \thasKey = section.hasKey || (section.hasKey = {});\n\n  \t// remove any fragments that should no longer exist\n  \ti = section.fragments.length;\n  \twhile (i--) {\n  \t\tfragment = section.fragments[i];\n\n  \t\tif (!(fragment.key in value)) {\n  \t\t\tchanged = true;\n\n  \t\t\tfragment.unbind();\n  \t\t\tsection.fragmentsToUnrender.push(fragment);\n  \t\t\tsection.fragments.splice(i, 1);\n\n  \t\t\thasKey[fragment.key] = false;\n  \t\t}\n  \t}\n\n  \t// notify any dependents about changed indices\n  \ti = section.fragments.length;\n  \twhile (i--) {\n  \t\tfragment = section.fragments[i];\n\n  \t\tif (fragment.index !== i) {\n  \t\t\tfragment.index = i;\n  \t\t\tif (deps = fragment.registeredIndexRefs) {\n  \t\t\t\tdeps.forEach(setValue__blindRebind);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// add any that haven't been created yet\n  \ti = section.fragments.length;\n  \tfor (id in value) {\n  \t\tif (!hasKey[id]) {\n  \t\t\tchanged = true;\n\n  \t\t\tfragmentOptions.context = section.keypath.join(id);\n  \t\t\tfragmentOptions.key = id;\n  \t\t\tfragmentOptions.index = i++;\n\n  \t\t\tfragment = new virtualdom_Fragment(fragmentOptions);\n\n  \t\t\tsection.fragmentsToRender.push(fragment);\n  \t\t\tsection.fragments.push(fragment);\n  \t\t\thasKey[id] = true;\n  \t\t}\n  \t}\n\n  \tsection.length = section.fragments.length;\n  \treturn changed;\n  }\n\n  function reevaluateConditionalContextSection(section, value, fragmentOptions) {\n  \tif (value) {\n  \t\treturn reevaluateContextSection(section, fragmentOptions);\n  \t} else {\n  \t\treturn removeSectionFragments(section);\n  \t}\n  }\n\n  function reevaluateContextSection(section, fragmentOptions) {\n  \tvar fragment;\n\n  \t// ...then if it isn't rendered, render it, adding section.keypath to the context stack\n  \t// (if it is already rendered, then any children dependent on the context stack\n  \t// will update themselves without any prompting)\n  \tif (!section.length) {\n  \t\t// append this section to the context stack\n  \t\tfragmentOptions.context = section.keypath;\n  \t\tfragmentOptions.index = 0;\n\n  \t\tfragment = new virtualdom_Fragment(fragmentOptions);\n\n  \t\tsection.fragmentsToRender.push(section.fragments[0] = fragment);\n  \t\tsection.length = 1;\n\n  \t\treturn true;\n  \t}\n  }\n\n  function reevaluateConditionalSection(section, value, inverted, fragmentOptions) {\n  \tvar doRender, emptyArray, emptyObject, fragment, name;\n\n  \temptyArray = isArrayLike(value) && value.length === 0;\n  \temptyObject = false;\n  \tif (!isArrayLike(value) && isObject(value)) {\n  \t\temptyObject = true;\n  \t\tfor (name in value) {\n  \t\t\temptyObject = false;\n  \t\t\tbreak;\n  \t\t}\n  \t}\n\n  \tif (inverted) {\n  \t\tdoRender = emptyArray || emptyObject || !value;\n  \t} else {\n  \t\tdoRender = value && !emptyArray && !emptyObject;\n  \t}\n\n  \tif (doRender) {\n  \t\tif (!section.length) {\n  \t\t\t// no change to context stack\n  \t\t\tfragmentOptions.index = 0;\n\n  \t\t\tfragment = new virtualdom_Fragment(fragmentOptions);\n  \t\t\tsection.fragmentsToRender.push(section.fragments[0] = fragment);\n  \t\t\tsection.length = 1;\n\n  \t\t\treturn true;\n  \t\t}\n\n  \t\tif (section.length > 1) {\n  \t\t\tsection.fragmentsToUnrender = section.fragments.splice(1);\n  \t\t\tsection.fragmentsToUnrender.forEach(methodCallers__unbind);\n\n  \t\t\treturn true;\n  \t\t}\n  \t} else {\n  \t\treturn removeSectionFragments(section);\n  \t}\n  }\n\n  function removeSectionFragments(section) {\n  \tif (section.length) {\n  \t\tsection.fragmentsToUnrender = section.fragments.splice(0, section.fragments.length).filter(isRendered);\n  \t\tsection.fragmentsToUnrender.forEach(methodCallers__unbind);\n  \t\tsection.length = section.fragmentsToRender.length = 0;\n  \t\treturn true;\n  \t}\n  }\n\n  function isRendered(fragment) {\n  \treturn fragment.rendered;\n  }\n\n  function setValue__blindRebind(dep) {\n  \t// the keypath doesn't actually matter here as it won't have changed\n  \tdep.rebind(\"\", \"\");\n  }\n\n  var prototype_toString = Section$toString;\n\n  function Section$toString(escape) {\n  \tvar str, i, len;\n\n  \tstr = \"\";\n\n  \ti = 0;\n  \tlen = this.length;\n\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tstr += this.fragments[i].toString(escape);\n  \t}\n\n  \treturn str;\n  }\n\n  var prototype_unbind = Section$unbind;\n  function Section$unbind() {\n  \tvar _this = this;\n\n  \tthis.fragments.forEach(methodCallers__unbind);\n  \tthis.fragmentsToRender.forEach(function (f) {\n  \t\treturn removeFromArray(_this.fragments, f);\n  \t});\n  \tthis.fragmentsToRender = [];\n  \tshared_unbind.call(this);\n\n  \tthis.length = 0;\n  \tthis.unbound = true;\n  }\n\n  var prototype_unrender = Section$unrender;\n\n  function Section$unrender(shouldDestroy) {\n  \tthis.fragments.forEach(shouldDestroy ? unrenderAndDestroy : prototype_unrender__unrender);\n  \tthis.renderedFragments = [];\n  \tthis.rendered = false;\n  }\n\n  function unrenderAndDestroy(fragment) {\n  \tfragment.unrender(true);\n  }\n\n  function prototype_unrender__unrender(fragment) {\n  \tfragment.unrender(false);\n  }\n\n  var prototype_update = Section$update;\n\n  function Section$update() {\n  \tvar fragment, renderIndex, renderedFragments, anchor, target, i, len;\n\n  \t// `this.renderedFragments` is in the order of the previous render.\n  \t// If fragments have shuffled about, this allows us to quickly\n  \t// reinsert them in the correct place\n  \trenderedFragments = this.renderedFragments;\n\n  \t// Remove fragments that have been marked for destruction\n  \twhile (fragment = this.fragmentsToUnrender.pop()) {\n  \t\tfragment.unrender(true);\n  \t\trenderedFragments.splice(renderedFragments.indexOf(fragment), 1);\n  \t}\n\n  \t// Render new fragments (but don't insert them yet)\n  \twhile (fragment = this.fragmentsToRender.shift()) {\n  \t\tfragment.render();\n  \t}\n\n  \tif (this.rendered) {\n  \t\ttarget = this.parentFragment.getNode();\n  \t}\n\n  \tlen = this.fragments.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tfragment = this.fragments[i];\n  \t\trenderIndex = renderedFragments.indexOf(fragment, i); // search from current index - it's guaranteed to be the same or higher\n\n  \t\tif (renderIndex === i) {\n  \t\t\t// already in the right place. insert accumulated nodes (if any) and carry on\n  \t\t\tif (this.docFrag.childNodes.length) {\n  \t\t\t\tanchor = fragment.firstNode();\n  \t\t\t\ttarget.insertBefore(this.docFrag, anchor);\n  \t\t\t}\n\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\tthis.docFrag.appendChild(fragment.detach());\n\n  \t\t// update renderedFragments\n  \t\tif (renderIndex !== -1) {\n  \t\t\trenderedFragments.splice(renderIndex, 1);\n  \t\t}\n  \t\trenderedFragments.splice(i, 0, fragment);\n  \t}\n\n  \tif (this.rendered && this.docFrag.childNodes.length) {\n  \t\tanchor = this.parentFragment.findNextNode(this);\n  \t\ttarget.insertBefore(this.docFrag, anchor);\n  \t}\n\n  \t// Save the rendering order for next time\n  \tthis.renderedFragments = this.fragments.slice();\n  }\n\n  var Section = function (options) {\n  \tthis.type = SECTION;\n  \tthis.subtype = this.currentSubtype = options.template.n;\n  \tthis.inverted = this.subtype === SECTION_UNLESS;\n\n  \tthis.pElement = options.pElement;\n\n  \tthis.fragments = [];\n  \tthis.fragmentsToCreate = [];\n  \tthis.fragmentsToRender = [];\n  \tthis.fragmentsToUnrender = [];\n\n  \tif (options.template.i) {\n  \t\tthis.indexRefs = options.template.i.split(\",\").map(function (k, i) {\n  \t\t\treturn { n: k, t: i === 0 ? \"k\" : \"i\" };\n  \t\t});\n  \t}\n\n  \tthis.renderedFragments = [];\n\n  \tthis.length = 0; // number of times this section is rendered\n\n  \tMustache.init(this, options);\n  };\n\n  Section.prototype = {\n  \tbubble: Section_prototype_bubble,\n  \tdetach: Section_prototype_detach,\n  \tfind: find,\n  \tfindAll: findAll,\n  \tfindAllComponents: findAllComponents,\n  \tfindComponent: findComponent,\n  \tfindNextNode: findNextNode,\n  \tfirstNode: firstNode,\n  \tgetIndexRef: function (name) {\n  \t\tif (this.indexRefs) {\n  \t\t\tvar i = this.indexRefs.length;\n  \t\t\twhile (i--) {\n  \t\t\t\tvar ref = this.indexRefs[i];\n  \t\t\t\tif (ref.n === name) {\n  \t\t\t\t\treturn ref;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetValue: Mustache.getValue,\n  \tshuffle: shuffle,\n  \trebind: prototype_rebind,\n  \trender: Section_prototype_render,\n  \tresolve: Mustache.resolve,\n  \tsetValue: setValue,\n  \ttoString: prototype_toString,\n  \tunbind: prototype_unbind,\n  \tunrender: prototype_unrender,\n  \tupdate: prototype_update\n  };\n\n  var _Section = Section;\n\n  var Triple_prototype_detach = Triple$detach;\n\n  function Triple$detach() {\n  \tvar len, i;\n\n  \tif (this.docFrag) {\n  \t\tlen = this.nodes.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\tthis.docFrag.appendChild(this.nodes[i]);\n  \t\t}\n\n  \t\treturn this.docFrag;\n  \t}\n  }\n\n  var Triple_prototype_find = Triple$find;\n  function Triple$find(selector) {\n  \tvar i, len, node, queryResult;\n\n  \tlen = this.nodes.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tnode = this.nodes[i];\n\n  \t\tif (node.nodeType !== 1) {\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\tif (matches(node, selector)) {\n  \t\t\treturn node;\n  \t\t}\n\n  \t\tif (queryResult = node.querySelector(selector)) {\n  \t\t\treturn queryResult;\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  var Triple_prototype_findAll = Triple$findAll;\n  function Triple$findAll(selector, queryResult) {\n  \tvar i, len, node, queryAllResult, numNodes, j;\n\n  \tlen = this.nodes.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tnode = this.nodes[i];\n\n  \t\tif (node.nodeType !== 1) {\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\tif (matches(node, selector)) {\n  \t\t\tqueryResult.push(node);\n  \t\t}\n\n  \t\tif (queryAllResult = node.querySelectorAll(selector)) {\n  \t\t\tnumNodes = queryAllResult.length;\n  \t\t\tfor (j = 0; j < numNodes; j += 1) {\n  \t\t\t\tqueryResult.push(queryAllResult[j]);\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  var Triple_prototype_firstNode = Triple$firstNode;\n\n  function Triple$firstNode() {\n  \tif (this.rendered && this.nodes[0]) {\n  \t\treturn this.nodes[0];\n  \t}\n\n  \treturn this.parentFragment.findNextNode(this);\n  }\n\n  var elementCache = {},\n      ieBug,\n      ieBlacklist;\n\n  try {\n  \tcreateElement(\"table\").innerHTML = \"foo\";\n  } catch (err) {\n  \tieBug = true;\n\n  \tieBlacklist = {\n  \t\tTABLE: [\"<table class=\\\"x\\\">\", \"</table>\"],\n  \t\tTHEAD: [\"<table><thead class=\\\"x\\\">\", \"</thead></table>\"],\n  \t\tTBODY: [\"<table><tbody class=\\\"x\\\">\", \"</tbody></table>\"],\n  \t\tTR: [\"<table><tr class=\\\"x\\\">\", \"</tr></table>\"],\n  \t\tSELECT: [\"<select class=\\\"x\\\">\", \"</select>\"]\n  \t};\n  }\n\n  var insertHtml = function (html, node, docFrag) {\n  \tvar container,\n  \t    nodes = [],\n  \t    wrapper,\n  \t    selectedOption,\n  \t    child,\n  \t    i;\n\n  \t// render 0 and false\n  \tif (html != null && html !== \"\") {\n  \t\tif (ieBug && (wrapper = ieBlacklist[node.tagName])) {\n  \t\t\tcontainer = element(\"DIV\");\n  \t\t\tcontainer.innerHTML = wrapper[0] + html + wrapper[1];\n  \t\t\tcontainer = container.querySelector(\".x\");\n\n  \t\t\tif (container.tagName === \"SELECT\") {\n  \t\t\t\tselectedOption = container.options[container.selectedIndex];\n  \t\t\t}\n  \t\t} else if (node.namespaceURI === namespaces.svg) {\n  \t\t\tcontainer = element(\"DIV\");\n  \t\t\tcontainer.innerHTML = \"<svg class=\\\"x\\\">\" + html + \"</svg>\";\n  \t\t\tcontainer = container.querySelector(\".x\");\n  \t\t} else {\n  \t\t\tcontainer = element(node.tagName);\n  \t\t\tcontainer.innerHTML = html;\n\n  \t\t\tif (container.tagName === \"SELECT\") {\n  \t\t\t\tselectedOption = container.options[container.selectedIndex];\n  \t\t\t}\n  \t\t}\n\n  \t\twhile (child = container.firstChild) {\n  \t\t\tnodes.push(child);\n  \t\t\tdocFrag.appendChild(child);\n  \t\t}\n\n  \t\t// This is really annoying. Extracting <option> nodes from the\n  \t\t// temporary container <select> causes the remaining ones to\n  \t\t// become selected. So now we have to deselect them. IE8, you\n  \t\t// amaze me. You really do\n  \t\t// ...and now Chrome too\n  \t\tif (node.tagName === \"SELECT\") {\n  \t\t\ti = nodes.length;\n  \t\t\twhile (i--) {\n  \t\t\t\tif (nodes[i] !== selectedOption) {\n  \t\t\t\t\tnodes[i].selected = false;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn nodes;\n  };\n\n  function element(tagName) {\n  \treturn elementCache[tagName] || (elementCache[tagName] = createElement(tagName));\n  }\n\n  var helpers_updateSelect = updateSelect;\n\n  function updateSelect(parentElement) {\n  \tvar selectedOptions, option, value;\n\n  \tif (!parentElement || parentElement.name !== \"select\" || !parentElement.binding) {\n  \t\treturn;\n  \t}\n\n  \tselectedOptions = toArray(parentElement.node.options).filter(isSelected);\n\n  \t// If one of them had a `selected` attribute, we need to sync\n  \t// the model to the view\n  \tif (parentElement.getAttribute(\"multiple\")) {\n  \t\tvalue = selectedOptions.map(function (o) {\n  \t\t\treturn o.value;\n  \t\t});\n  \t} else if (option = selectedOptions[0]) {\n  \t\tvalue = option.value;\n  \t}\n\n  \tif (value !== undefined) {\n  \t\tparentElement.binding.setValue(value);\n  \t}\n\n  \tparentElement.bubble();\n  }\n\n  function isSelected(option) {\n  \treturn option.selected;\n  }\n\n  var Triple_prototype_render = Triple$render;\n  function Triple$render() {\n  \tif (this.rendered) {\n  \t\tthrow new Error(\"Attempted to render an item that was already rendered\");\n  \t}\n\n  \tthis.docFrag = document.createDocumentFragment();\n  \tthis.nodes = insertHtml(this.value, this.parentFragment.getNode(), this.docFrag);\n\n  \t// Special case - we're inserting the contents of a <select>\n  \thelpers_updateSelect(this.pElement);\n\n  \tthis.rendered = true;\n  \treturn this.docFrag;\n  }\n\n  var prototype_setValue = Triple$setValue;\n  function Triple$setValue(value) {\n  \tvar wrapper;\n\n  \t// TODO is there a better way to approach this?\n  \tif (wrapper = this.root.viewmodel.wrapped[this.keypath.str]) {\n  \t\tvalue = wrapper.get();\n  \t}\n\n  \tif (value !== this.value) {\n  \t\tthis.value = value;\n  \t\tthis.parentFragment.bubble();\n\n  \t\tif (this.rendered) {\n  \t\t\tglobal_runloop.addView(this);\n  \t\t}\n  \t}\n  }\n\n  var Triple_prototype_toString = Triple$toString;\n  function Triple$toString() {\n  \treturn this.value != undefined ? decodeCharacterReferences(\"\" + this.value) : \"\";\n  }\n\n  var Triple_prototype_unrender = Triple$unrender;\n  function Triple$unrender(shouldDestroy) {\n  \tif (this.rendered && shouldDestroy) {\n  \t\tthis.nodes.forEach(detachNode);\n  \t\tthis.rendered = false;\n  \t}\n\n  \t// TODO update live queries\n  }\n\n  var Triple_prototype_update = Triple$update;\n  function Triple$update() {\n  \tvar node, parentNode;\n\n  \tif (!this.rendered) {\n  \t\treturn;\n  \t}\n\n  \t// Remove existing nodes\n  \twhile (this.nodes && this.nodes.length) {\n  \t\tnode = this.nodes.pop();\n  \t\tnode.parentNode.removeChild(node);\n  \t}\n\n  \t// Insert new nodes\n  \tparentNode = this.parentFragment.getNode();\n\n  \tthis.nodes = insertHtml(this.value, parentNode, this.docFrag);\n  \tparentNode.insertBefore(this.docFrag, this.parentFragment.findNextNode(this));\n\n  \t// Special case - we're inserting the contents of a <select>\n  \thelpers_updateSelect(this.pElement);\n  }\n\n  var Triple = function (options) {\n  \tthis.type = TRIPLE;\n  \tMustache.init(this, options);\n  };\n\n  Triple.prototype = {\n  \tdetach: Triple_prototype_detach,\n  \tfind: Triple_prototype_find,\n  \tfindAll: Triple_prototype_findAll,\n  \tfirstNode: Triple_prototype_firstNode,\n  \tgetValue: Mustache.getValue,\n  \trebind: Mustache.rebind,\n  \trender: Triple_prototype_render,\n  \tresolve: Mustache.resolve,\n  \tsetValue: prototype_setValue,\n  \ttoString: Triple_prototype_toString,\n  \tunbind: shared_unbind,\n  \tunrender: Triple_prototype_unrender,\n  \tupdate: Triple_prototype_update\n  };\n\n  var _Triple = Triple;\n\n  var Element_prototype_bubble = function () {\n  \tthis.parentFragment.bubble();\n  };\n\n  var Element_prototype_detach = Element$detach;\n\n  function Element$detach() {\n  \tvar node = this.node,\n  \t    parentNode;\n\n  \tif (node) {\n  \t\t// need to check for parent node - DOM may have been altered\n  \t\t// by something other than Ractive! e.g. jQuery UI...\n  \t\tif (parentNode = node.parentNode) {\n  \t\t\tparentNode.removeChild(node);\n  \t\t}\n\n  \t\treturn node;\n  \t}\n  }\n\n  var Element_prototype_find = function (selector) {\n  \tif (!this.node) {\n  \t\t// this element hasn't been rendered yet\n  \t\treturn null;\n  \t}\n\n  \tif (matches(this.node, selector)) {\n  \t\treturn this.node;\n  \t}\n\n  \tif (this.fragment && this.fragment.find) {\n  \t\treturn this.fragment.find(selector);\n  \t}\n  };\n\n  var Element_prototype_findAll = function (selector, query) {\n  \t// Add this node to the query, if applicable, and register the\n  \t// query on this element\n  \tif (query._test(this, true) && query.live) {\n  \t\t(this.liveQueries || (this.liveQueries = [])).push(query);\n  \t}\n\n  \tif (this.fragment) {\n  \t\tthis.fragment.findAll(selector, query);\n  \t}\n  };\n\n  var Element_prototype_findAllComponents = function (selector, query) {\n  \tif (this.fragment) {\n  \t\tthis.fragment.findAllComponents(selector, query);\n  \t}\n  };\n\n  var Element_prototype_findComponent = function (selector) {\n  \tif (this.fragment) {\n  \t\treturn this.fragment.findComponent(selector);\n  \t}\n  };\n\n  var Element_prototype_findNextNode = Element$findNextNode;\n\n  function Element$findNextNode() {\n  \treturn null;\n  }\n\n  var Element_prototype_firstNode = Element$firstNode;\n\n  function Element$firstNode() {\n  \treturn this.node;\n  }\n\n  var getAttribute = Element$getAttribute;\n\n  function Element$getAttribute(name) {\n  \tif (!this.attributes || !this.attributes[name]) {\n  \t\treturn;\n  \t}\n\n  \treturn this.attributes[name].value;\n  }\n\n  var truthy = /^true|on|yes|1$/i;\n  var processBindingAttributes__isNumeric = /^[0-9]+$/;\n\n  var processBindingAttributes = function (element, template) {\n  \tvar val, attrs, attributes;\n\n  \tattributes = template.a || {};\n  \tattrs = {};\n\n  \t// attributes that are present but don't have a value (=)\n  \t// will be set to the number 0, which we condider to be true\n  \t// the string '0', however is false\n\n  \tval = attributes.twoway;\n  \tif (val !== undefined) {\n  \t\tattrs.twoway = val === 0 || truthy.test(val);\n  \t}\n\n  \tval = attributes.lazy;\n  \tif (val !== undefined) {\n  \t\t// check for timeout value\n  \t\tif (val !== 0 && processBindingAttributes__isNumeric.test(val)) {\n  \t\t\tattrs.lazy = parseInt(val);\n  \t\t} else {\n  \t\t\tattrs.lazy = val === 0 || truthy.test(val);\n  \t\t}\n  \t}\n\n  \treturn attrs;\n  };\n\n  var Attribute_prototype_bubble = Attribute$bubble;\n  function Attribute$bubble() {\n  \tvar value = this.useProperty || !this.rendered ? this.fragment.getValue() : this.fragment.toString();\n\n  \t// TODO this can register the attribute multiple times (see render test\n  \t// 'Attribute with nested mustaches')\n  \tif (!isEqual(value, this.value)) {\n\n  \t\t// Need to clear old id from ractive.nodes\n  \t\tif (this.name === \"id\" && this.value) {\n  \t\t\tdelete this.root.nodes[this.value];\n  \t\t}\n\n  \t\tthis.value = value;\n\n  \t\tif (this.name === \"value\" && this.node) {\n  \t\t\t// We need to store the value on the DOM like this so we\n  \t\t\t// can retrieve it later without it being coerced to a string\n  \t\t\tthis.node._ractive.value = value;\n  \t\t}\n\n  \t\tif (this.rendered) {\n  \t\t\tglobal_runloop.addView(this);\n  \t\t}\n  \t}\n  }\n\n  var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;\n  svgCamelCaseElements = \"altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern\".split(\" \");\n  svgCamelCaseAttributes = \"attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan\".split(\" \");\n\n  createMap = function (items) {\n  \tvar map = {},\n  \t    i = items.length;\n  \twhile (i--) {\n  \t\tmap[items[i].toLowerCase()] = items[i];\n  \t}\n  \treturn map;\n  };\n\n  map = createMap(svgCamelCaseElements.concat(svgCamelCaseAttributes));\n\n  var enforceCase = function (elementName) {\n  \tvar lowerCaseElementName = elementName.toLowerCase();\n  \treturn map[lowerCaseElementName] || lowerCaseElementName;\n  };\n\n  var determineNameAndNamespace = function (attribute, name) {\n  \tvar colonIndex, namespacePrefix;\n\n  \t// are we dealing with a namespaced attribute, e.g. xlink:href?\n  \tcolonIndex = name.indexOf(\":\");\n  \tif (colonIndex !== -1) {\n\n  \t\t// looks like we are, yes...\n  \t\tnamespacePrefix = name.substr(0, colonIndex);\n\n  \t\t// ...unless it's a namespace *declaration*, which we ignore (on the assumption\n  \t\t// that only valid namespaces will be used)\n  \t\tif (namespacePrefix !== \"xmlns\") {\n  \t\t\tname = name.substring(colonIndex + 1);\n\n  \t\t\tattribute.name = enforceCase(name);\n  \t\t\tattribute.namespace = namespaces[namespacePrefix.toLowerCase()];\n  \t\t\tattribute.namespacePrefix = namespacePrefix;\n\n  \t\t\tif (!attribute.namespace) {\n  \t\t\t\tthrow \"Unknown namespace (\\\"\" + namespacePrefix + \"\\\")\";\n  \t\t\t}\n\n  \t\t\treturn;\n  \t\t}\n  \t}\n\n  \t// SVG attribute names are case sensitive\n  \tattribute.name = attribute.element.namespace !== namespaces.html ? enforceCase(name) : name;\n  };\n\n  var helpers_getInterpolator = getInterpolator;\n  function getInterpolator(attribute) {\n  \tvar items = attribute.fragment.items;\n\n  \tif (items.length !== 1) {\n  \t\treturn;\n  \t}\n\n  \tif (items[0].type === INTERPOLATOR) {\n  \t\treturn items[0];\n  \t}\n  }\n\n  var prototype_init = Attribute$init;\n  function Attribute$init(options) {\n  \tthis.type = ATTRIBUTE;\n  \tthis.element = options.element;\n  \tthis.root = options.root;\n\n  \tdetermineNameAndNamespace(this, options.name);\n  \tthis.isBoolean = booleanAttributes.test(this.name);\n\n  \t// if it's an empty attribute, or just a straight key-value pair, with no\n  \t// mustache shenanigans, set the attribute accordingly and go home\n  \tif (!options.value || typeof options.value === \"string\") {\n  \t\tthis.value = this.isBoolean ? true : options.value || \"\";\n  \t\treturn;\n  \t}\n\n  \t// otherwise we need to do some work\n\n  \t// share parentFragment with parent element\n  \tthis.parentFragment = this.element.parentFragment;\n\n  \tthis.fragment = new virtualdom_Fragment({\n  \t\ttemplate: options.value,\n  \t\troot: this.root,\n  \t\towner: this\n  \t});\n\n  \t// TODO can we use this.fragment.toString() in some cases? It's quicker\n  \tthis.value = this.fragment.getValue();\n\n  \t// Store a reference to this attribute's interpolator, if its fragment\n  \t// takes the form `{{foo}}`. This is necessary for two-way binding and\n  \t// for correctly rendering HTML later\n  \tthis.interpolator = helpers_getInterpolator(this);\n  \tthis.isBindable = !!this.interpolator && !this.interpolator.isStatic;\n\n  \t// mark as ready\n  \tthis.ready = true;\n  }\n\n  var Attribute_prototype_rebind = Attribute$rebind;\n\n  function Attribute$rebind(oldKeypath, newKeypath) {\n  \tif (this.fragment) {\n  \t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t}\n  }\n\n  var Attribute_prototype_render = Attribute$render;\n  var propertyNames = {\n  \t\"accept-charset\": \"acceptCharset\",\n  \taccesskey: \"accessKey\",\n  \tbgcolor: \"bgColor\",\n  \t\"class\": \"className\",\n  \tcodebase: \"codeBase\",\n  \tcolspan: \"colSpan\",\n  \tcontenteditable: \"contentEditable\",\n  \tdatetime: \"dateTime\",\n  \tdirname: \"dirName\",\n  \t\"for\": \"htmlFor\",\n  \t\"http-equiv\": \"httpEquiv\",\n  \tismap: \"isMap\",\n  \tmaxlength: \"maxLength\",\n  \tnovalidate: \"noValidate\",\n  \tpubdate: \"pubDate\",\n  \treadonly: \"readOnly\",\n  \trowspan: \"rowSpan\",\n  \ttabindex: \"tabIndex\",\n  \tusemap: \"useMap\"\n  };\n  function Attribute$render(node) {\n  \tvar propertyName;\n\n  \tthis.node = node;\n\n  \t// should we use direct property access, or setAttribute?\n  \tif (!node.namespaceURI || node.namespaceURI === namespaces.html) {\n  \t\tpropertyName = propertyNames[this.name] || this.name;\n\n  \t\tif (node[propertyName] !== undefined) {\n  \t\t\tthis.propertyName = propertyName;\n  \t\t}\n\n  \t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n  \t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n  \t\tif (this.isBoolean || this.isTwoway) {\n  \t\t\tthis.useProperty = true;\n  \t\t}\n\n  \t\tif (propertyName === \"value\") {\n  \t\t\tnode._ractive.value = this.value;\n  \t\t}\n  \t}\n\n  \tthis.rendered = true;\n  \tthis.update();\n  }\n\n  var Attribute_prototype_toString = Attribute$toString;\n\n  function Attribute$toString() {\n  \tvar _ref = this;\n\n  \tvar name = _ref.name;\n  \tvar namespacePrefix = _ref.namespacePrefix;\n  \tvar value = _ref.value;\n  \tvar interpolator = _ref.interpolator;\n  \tvar fragment = _ref.fragment;\n\n  \t// Special case - select and textarea values (should not be stringified)\n  \tif (name === \"value\" && (this.element.name === \"select\" || this.element.name === \"textarea\")) {\n  \t\treturn;\n  \t}\n\n  \t// Special case - content editable\n  \tif (name === \"value\" && this.element.getAttribute(\"contenteditable\") !== undefined) {\n  \t\treturn;\n  \t}\n\n  \t// Special case - radio names\n  \tif (name === \"name\" && this.element.name === \"input\" && interpolator) {\n  \t\treturn \"name={{\" + (interpolator.keypath.str || interpolator.ref) + \"}}\";\n  \t}\n\n  \t// Boolean attributes\n  \tif (this.isBoolean) {\n  \t\treturn value ? name : \"\";\n  \t}\n\n  \tif (fragment) {\n  \t\t// special case - this catches undefined/null values (#1211)\n  \t\tif (fragment.items.length === 1 && fragment.items[0].value == null) {\n  \t\t\treturn \"\";\n  \t\t}\n\n  \t\tvalue = fragment.toString();\n  \t}\n\n  \tif (namespacePrefix) {\n  \t\tname = namespacePrefix + \":\" + name;\n  \t}\n\n  \treturn value ? name + \"=\\\"\" + Attribute_prototype_toString__escape(value) + \"\\\"\" : name;\n  }\n\n  function Attribute_prototype_toString__escape(value) {\n  \treturn value.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#39;\");\n  }\n\n  var Attribute_prototype_unbind = Attribute$unbind;\n\n  function Attribute$unbind() {\n  \t// ignore non-dynamic attributes\n  \tif (this.fragment) {\n  \t\tthis.fragment.unbind();\n  \t}\n\n  \tif (this.name === \"id\") {\n  \t\tdelete this.root.nodes[this.value];\n  \t}\n  }\n\n  var updateSelectValue = Attribute$updateSelect;\n\n  function Attribute$updateSelect() {\n  \tvar value = this.value,\n  \t    options,\n  \t    option,\n  \t    optionValue,\n  \t    i;\n\n  \tif (!this.locked) {\n  \t\tthis.node._ractive.value = value;\n\n  \t\toptions = this.node.options;\n  \t\ti = options.length;\n\n  \t\twhile (i--) {\n  \t\t\toption = options[i];\n  \t\t\toptionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n\n  \t\t\tif (optionValue == value) {\n  \t\t\t\t// double equals as we may be comparing numbers with strings\n  \t\t\t\toption.selected = true;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// if we're still here, it means the new value didn't match any of the options...\n  \t// TODO figure out what to do in this situation\n  }\n\n  var updateMultipleSelectValue = Attribute$updateMultipleSelect;\n  function Attribute$updateMultipleSelect() {\n  \tvar value = this.value,\n  \t    options,\n  \t    i,\n  \t    option,\n  \t    optionValue;\n\n  \tif (!isArray(value)) {\n  \t\tvalue = [value];\n  \t}\n\n  \toptions = this.node.options;\n  \ti = options.length;\n\n  \twhile (i--) {\n  \t\toption = options[i];\n  \t\toptionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n  \t\toption.selected = arrayContains(value, optionValue);\n  \t}\n  }\n\n  var updateRadioName = Attribute$updateRadioName;\n\n  function Attribute$updateRadioName() {\n  \tvar _ref = this;\n\n  \tvar node = _ref.node;\n  \tvar value = _ref.value;\n\n  \tnode.checked = value == node._ractive.value;\n  }\n\n  var updateRadioValue = Attribute$updateRadioValue;\n  function Attribute$updateRadioValue() {\n  \tvar wasChecked,\n  \t    node = this.node,\n  \t    binding,\n  \t    bindings,\n  \t    i;\n\n  \twasChecked = node.checked;\n\n  \tnode.value = this.element.getAttribute(\"value\");\n  \tnode.checked = this.element.getAttribute(\"value\") === this.element.getAttribute(\"name\");\n\n  \t// This is a special case - if the input was checked, and the value\n  \t// changed so that it's no longer checked, the twoway binding is\n  \t// most likely out of date. To fix it we have to jump through some\n  \t// hoops... this is a little kludgy but it works\n  \tif (wasChecked && !node.checked && this.element.binding) {\n  \t\tbindings = this.element.binding.siblings;\n\n  \t\tif (i = bindings.length) {\n  \t\t\twhile (i--) {\n  \t\t\t\tbinding = bindings[i];\n\n  \t\t\t\tif (!binding.element.node) {\n  \t\t\t\t\t// this is the initial render, siblings are still rendering!\n  \t\t\t\t\t// we'll come back later...\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tif (binding.element.node.checked) {\n  \t\t\t\t\tglobal_runloop.addRactive(binding.root);\n  \t\t\t\t\treturn binding.handleChange();\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tthis.root.viewmodel.set(binding.keypath, undefined);\n  \t\t}\n  \t}\n  }\n\n  var updateCheckboxName = Attribute$updateCheckboxName;\n  function Attribute$updateCheckboxName() {\n  \tvar _ref = this;\n\n  \tvar element = _ref.element;\n  \tvar node = _ref.node;\n  \tvar value = _ref.value;var binding = element.binding;var valueAttribute;var i;\n\n  \tvalueAttribute = element.getAttribute(\"value\");\n\n  \tif (!isArray(value)) {\n  \t\tbinding.isChecked = node.checked = value == valueAttribute;\n  \t} else {\n  \t\ti = value.length;\n  \t\twhile (i--) {\n  \t\t\tif (valueAttribute == value[i]) {\n  \t\t\t\tbinding.isChecked = node.checked = true;\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n  \t\tbinding.isChecked = node.checked = false;\n  \t}\n  }\n\n  var updateClassName = Attribute$updateClassName;\n  function Attribute$updateClassName() {\n  \tthis.node.className = safeToStringValue(this.value);\n  }\n\n  var updateIdAttribute = Attribute$updateIdAttribute;\n\n  function Attribute$updateIdAttribute() {\n  \tvar _ref = this;\n\n  \tvar node = _ref.node;\n  \tvar value = _ref.value;\n\n  \tthis.root.nodes[value] = node;\n  \tnode.id = value;\n  }\n\n  var updateIEStyleAttribute = Attribute$updateIEStyleAttribute;\n\n  function Attribute$updateIEStyleAttribute() {\n  \tvar node, value;\n\n  \tnode = this.node;\n  \tvalue = this.value;\n\n  \tif (value === undefined) {\n  \t\tvalue = \"\";\n  \t}\n\n  \tnode.style.setAttribute(\"cssText\", value);\n  }\n\n  var updateContentEditableValue = Attribute$updateContentEditableValue;\n\n  function Attribute$updateContentEditableValue() {\n  \tvar value = this.value;\n\n  \tif (value === undefined) {\n  \t\tvalue = \"\";\n  \t}\n\n  \tif (!this.locked) {\n  \t\tthis.node.innerHTML = value;\n  \t}\n  }\n\n  var updateValue = Attribute$updateValue;\n\n  function Attribute$updateValue() {\n  \tvar _ref = this;\n\n  \tvar node = _ref.node;\n  \tvar value = _ref.value;\n\n  \t// store actual value, so it doesn't get coerced to a string\n  \tnode._ractive.value = value;\n\n  \t// with two-way binding, only update if the change wasn't initiated by the user\n  \t// otherwise the cursor will often be sent to the wrong place\n  \tif (!this.locked) {\n  \t\tnode.value = value == undefined ? \"\" : value;\n  \t}\n  }\n\n  var updateBoolean = Attribute$updateBooleanAttribute;\n\n  function Attribute$updateBooleanAttribute() {\n  \t// with two-way binding, only update if the change wasn't initiated by the user\n  \t// otherwise the cursor will often be sent to the wrong place\n  \tif (!this.locked) {\n  \t\tthis.node[this.propertyName] = this.value;\n  \t}\n  }\n\n  var updateEverythingElse = Attribute$updateEverythingElse;\n\n  function Attribute$updateEverythingElse() {\n  \tvar _ref = this;\n\n  \tvar node = _ref.node;\n  \tvar namespace = _ref.namespace;\n  \tvar name = _ref.name;\n  \tvar value = _ref.value;\n  \tvar fragment = _ref.fragment;\n\n  \tif (namespace) {\n  \t\tnode.setAttributeNS(namespace, name, (fragment || value).toString());\n  \t} else if (!this.isBoolean) {\n  \t\tif (value == null) {\n  \t\t\tnode.removeAttribute(name);\n  \t\t} else {\n  \t\t\tnode.setAttribute(name, (fragment || value).toString());\n  \t\t}\n  \t}\n\n  \t// Boolean attributes - truthy becomes '', falsy means 'remove attribute'\n  \telse {\n  \t\tif (value) {\n  \t\t\tnode.setAttribute(name, \"\");\n  \t\t} else {\n  \t\t\tnode.removeAttribute(name);\n  \t\t}\n  \t}\n  }\n\n  // There are a few special cases when it comes to updating attributes. For this reason,\n  // the prototype .update() method points to this method, which waits until the\n  // attribute has finished initialising, then replaces the prototype method with a more\n  // suitable one. That way, we save ourselves doing a bunch of tests on each call\n  var Attribute_prototype_update = Attribute$update;\n  function Attribute$update() {\n  \tvar _ref = this;\n\n  \tvar name = _ref.name;\n  \tvar element = _ref.element;\n  \tvar node = _ref.node;var type;var updateMethod;\n\n  \tif (name === \"id\") {\n  \t\tupdateMethod = updateIdAttribute;\n  \t} else if (name === \"value\") {\n  \t\t// special case - selects\n  \t\tif (element.name === \"select\" && name === \"value\") {\n  \t\t\tupdateMethod = element.getAttribute(\"multiple\") ? updateMultipleSelectValue : updateSelectValue;\n  \t\t} else if (element.name === \"textarea\") {\n  \t\t\tupdateMethod = updateValue;\n  \t\t}\n\n  \t\t// special case - contenteditable\n  \t\telse if (element.getAttribute(\"contenteditable\") != null) {\n  \t\t\tupdateMethod = updateContentEditableValue;\n  \t\t}\n\n  \t\t// special case - <input>\n  \t\telse if (element.name === \"input\") {\n  \t\t\ttype = element.getAttribute(\"type\");\n\n  \t\t\t// type='file' value='{{fileList}}'>\n  \t\t\tif (type === \"file\") {\n  \t\t\t\tupdateMethod = noop; // read-only\n  \t\t\t}\n\n  \t\t\t// type='radio' name='{{twoway}}'\n  \t\t\telse if (type === \"radio\" && element.binding && element.binding.name === \"name\") {\n  \t\t\t\tupdateMethod = updateRadioValue;\n  \t\t\t} else {\n  \t\t\t\tupdateMethod = updateValue;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// special case - <input type='radio' name='{{twoway}}' value='foo'>\n  \telse if (this.isTwoway && name === \"name\") {\n  \t\tif (node.type === \"radio\") {\n  \t\t\tupdateMethod = updateRadioName;\n  \t\t} else if (node.type === \"checkbox\") {\n  \t\t\tupdateMethod = updateCheckboxName;\n  \t\t}\n  \t}\n\n  \t// special case - style attributes in Internet Exploder\n  \telse if (name === \"style\" && node.style.setAttribute) {\n  \t\tupdateMethod = updateIEStyleAttribute;\n  \t}\n\n  \t// special case - class names. IE fucks things up, again\n  \telse if (name === \"class\" && (!node.namespaceURI || node.namespaceURI === namespaces.html)) {\n  \t\tupdateMethod = updateClassName;\n  \t} else if (this.useProperty) {\n  \t\tupdateMethod = updateBoolean;\n  \t}\n\n  \tif (!updateMethod) {\n  \t\tupdateMethod = updateEverythingElse;\n  \t}\n\n  \tthis.update = updateMethod;\n  \tthis.update();\n  }\n\n  var Attribute = function (options) {\n  \tthis.init(options);\n  };\n\n  Attribute.prototype = {\n  \tbubble: Attribute_prototype_bubble,\n  \tinit: prototype_init,\n  \trebind: Attribute_prototype_rebind,\n  \trender: Attribute_prototype_render,\n  \ttoString: Attribute_prototype_toString,\n  \tunbind: Attribute_prototype_unbind,\n  \tupdate: Attribute_prototype_update\n  };\n\n  var _Attribute = Attribute;\n\n  var createAttributes = function (element, attributes) {\n  \tvar name,\n  \t    attribute,\n  \t    result = [];\n\n  \tfor (name in attributes) {\n  \t\t// skip binding attributes\n  \t\tif (name === \"twoway\" || name === \"lazy\") {\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\tif (attributes.hasOwnProperty(name)) {\n  \t\t\tattribute = new _Attribute({\n  \t\t\t\telement: element,\n  \t\t\t\tname: name,\n  \t\t\t\tvalue: attributes[name],\n  \t\t\t\troot: element.root\n  \t\t\t});\n\n  \t\t\tresult[name] = attribute;\n\n  \t\t\tif (name !== \"value\") {\n  \t\t\t\tresult.push(attribute);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// value attribute goes last. This is because it\n  \t// may get clamped on render otherwise, e.g. in\n  \t// `<input type='range' value='999' min='0' max='1000'>`\n  \t// since default max is 100\n  \tif (attribute = result.value) {\n  \t\tresult.push(attribute);\n  \t}\n\n  \treturn result;\n  };\n\n  var _ConditionalAttribute__div;\n\n  if (typeof document !== \"undefined\") {\n  \t_ConditionalAttribute__div = createElement(\"div\");\n  }\n\n  var ConditionalAttribute = function (element, template) {\n  \tthis.element = element;\n  \tthis.root = element.root;\n  \tthis.parentFragment = element.parentFragment;\n\n  \tthis.attributes = [];\n\n  \tthis.fragment = new virtualdom_Fragment({\n  \t\troot: element.root,\n  \t\towner: this,\n  \t\ttemplate: [template]\n  \t});\n  };\n\n  ConditionalAttribute.prototype = {\n  \tbubble: function () {\n  \t\tif (this.node) {\n  \t\t\tthis.update();\n  \t\t}\n\n  \t\tthis.element.bubble();\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t},\n\n  \trender: function (node) {\n  \t\tthis.node = node;\n  \t\tthis.isSvg = node.namespaceURI === namespaces.svg;\n\n  \t\tthis.update();\n  \t},\n\n  \tunbind: function () {\n  \t\tthis.fragment.unbind();\n  \t},\n\n  \tupdate: function () {\n  \t\tvar _this = this;\n\n  \t\tvar str, attrs;\n\n  \t\tstr = this.fragment.toString();\n  \t\tattrs = parseAttributes(str, this.isSvg);\n\n  \t\t// any attributes that previously existed but no longer do\n  \t\t// must be removed\n  \t\tthis.attributes.filter(function (a) {\n  \t\t\treturn notIn(attrs, a);\n  \t\t}).forEach(function (a) {\n  \t\t\t_this.node.removeAttribute(a.name);\n  \t\t});\n\n  \t\tattrs.forEach(function (a) {\n  \t\t\t_this.node.setAttribute(a.name, a.value);\n  \t\t});\n\n  \t\tthis.attributes = attrs;\n  \t},\n\n  \ttoString: function () {\n  \t\treturn this.fragment.toString();\n  \t}\n  };\n\n  var _ConditionalAttribute = ConditionalAttribute;\n\n  function parseAttributes(str, isSvg) {\n  \tvar tag = isSvg ? \"svg\" : \"div\";\n  \t_ConditionalAttribute__div.innerHTML = \"<\" + tag + \" \" + str + \"></\" + tag + \">\";\n\n  \treturn toArray(_ConditionalAttribute__div.childNodes[0].attributes);\n  }\n\n  function notIn(haystack, needle) {\n  \tvar i = haystack.length;\n\n  \twhile (i--) {\n  \t\tif (haystack[i].name === needle.name) {\n  \t\t\treturn false;\n  \t\t}\n  \t}\n\n  \treturn true;\n  }\n\n  var createConditionalAttributes = function (element, attributes) {\n  \tif (!attributes) {\n  \t\treturn [];\n  \t}\n\n  \treturn attributes.map(function (a) {\n  \t\treturn new _ConditionalAttribute(element, a);\n  \t});\n  };\n\n  var Binding = function (element) {\n  \tvar interpolator, keypath, value, parentForm;\n\n  \tthis.element = element;\n  \tthis.root = element.root;\n  \tthis.attribute = element.attributes[this.name || \"value\"];\n\n  \tinterpolator = this.attribute.interpolator;\n  \tinterpolator.twowayBinding = this;\n\n  \tif (keypath = interpolator.keypath) {\n  \t\tif (keypath.str.slice(-1) === \"}\") {\n  \t\t\twarnOnceIfDebug(\"Two-way binding does not work with expressions (`%s` on <%s>)\", interpolator.resolver.uniqueString, element.name, { ractive: this.root });\n  \t\t\treturn false;\n  \t\t}\n\n  \t\tif (keypath.isSpecial) {\n  \t\t\twarnOnceIfDebug(\"Two-way binding does not work with %s\", interpolator.resolver.ref, { ractive: this.root });\n  \t\t\treturn false;\n  \t\t}\n  \t} else {\n  \t\t// A mustache may be *ambiguous*. Let's say we were given\n  \t\t// `value=\"{{bar}}\"`. If the context was `foo`, and `foo.bar`\n  \t\t// *wasn't* `undefined`, the keypath would be `foo.bar`.\n  \t\t// Then, any user input would result in `foo.bar` being updated.\n  \t\t//\n  \t\t// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be\n  \t\t// left with an unresolved partial keypath - so we are forced to make an\n  \t\t// assumption. That assumption is that the input in question should\n  \t\t// be forced to resolve to `bar`, and any user input would affect `bar`\n  \t\t// and not `foo.bar`.\n  \t\t//\n  \t\t// Did that make any sense? No? Oh. Sorry. Well the moral of the story is\n  \t\t// be explicit when using two-way data-binding about what keypath you're\n  \t\t// updating. Using it in lists is probably a recipe for confusion...\n  \t\tvar ref = interpolator.template.r ? \"'\" + interpolator.template.r + \"' reference\" : \"expression\";\n  \t\twarnIfDebug(\"The %s being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity\", ref, { ractive: this.root });\n  \t\tinterpolator.resolver.forceResolution();\n  \t\tkeypath = interpolator.keypath;\n  \t}\n\n  \tthis.attribute.isTwoway = true;\n  \tthis.keypath = keypath;\n\n  \t// initialise value, if it's undefined\n  \tvalue = this.root.viewmodel.get(keypath);\n\n  \tif (value === undefined && this.getInitialValue) {\n  \t\tvalue = this.getInitialValue();\n\n  \t\tif (value !== undefined) {\n  \t\t\tthis.root.viewmodel.set(keypath, value);\n  \t\t}\n  \t}\n\n  \tif (parentForm = findParentForm(element)) {\n  \t\tthis.resetValue = value;\n  \t\tparentForm.formBindings.push(this);\n  \t}\n  };\n\n  Binding.prototype = {\n  \thandleChange: function () {\n  \t\tvar _this = this;\n\n  \t\tglobal_runloop.start(this.root);\n  \t\tthis.attribute.locked = true;\n  \t\tthis.root.viewmodel.set(this.keypath, this.getValue());\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\treturn _this.attribute.locked = false;\n  \t\t});\n  \t\tglobal_runloop.end();\n  \t},\n\n  \trebound: function () {\n  \t\tvar bindings, oldKeypath, newKeypath;\n\n  \t\toldKeypath = this.keypath;\n  \t\tnewKeypath = this.attribute.interpolator.keypath;\n\n  \t\t// The attribute this binding is linked to has already done the work\n  \t\tif (oldKeypath === newKeypath) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tremoveFromArray(this.root._twowayBindings[oldKeypath.str], this);\n\n  \t\tthis.keypath = newKeypath;\n\n  \t\tbindings = this.root._twowayBindings[newKeypath.str] || (this.root._twowayBindings[newKeypath.str] = []);\n  \t\tbindings.push(this);\n  \t},\n\n  \tunbind: function () {}\n  };\n\n  Binding.extend = function (properties) {\n  \tvar Parent = this,\n  \t    SpecialisedBinding;\n\n  \tSpecialisedBinding = function (element) {\n  \t\tBinding.call(this, element);\n\n  \t\tif (this.init) {\n  \t\t\tthis.init();\n  \t\t}\n  \t};\n\n  \tSpecialisedBinding.prototype = create(Parent.prototype);\n  \tutils_object__extend(SpecialisedBinding.prototype, properties);\n\n  \tSpecialisedBinding.extend = Binding.extend;\n\n  \treturn SpecialisedBinding;\n  };\n\n  var Binding_Binding = Binding;\n\n  function findParentForm(element) {\n  \twhile (element = element.parent) {\n  \t\tif (element.name === \"form\") {\n  \t\t\treturn element;\n  \t\t}\n  \t}\n  }\n\n  // this is called when the element is unbound.\n  // Specialised bindings can override it\n\n  // This is the handler for DOM events that would lead to a change in the model\n  // (i.e. change, sometimes, input, and occasionally click and keyup)\n  var handleDomEvent = handleChange;\n\n  function handleChange() {\n  \tthis._ractive.binding.handleChange();\n  }\n\n  var GenericBinding;\n\n  GenericBinding = Binding_Binding.extend({\n  \tgetInitialValue: function () {\n  \t\treturn \"\";\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.element.node.value;\n  \t},\n\n  \trender: function () {\n  \t\tvar node = this.element.node,\n  \t\t    lazy,\n  \t\t    timeout = false;\n  \t\tthis.rendered = true;\n\n  \t\t// any lazy setting for this element overrides the root\n  \t\t// if the value is a number, it's a timeout\n  \t\tlazy = this.root.lazy;\n  \t\tif (this.element.lazy === true) {\n  \t\t\tlazy = true;\n  \t\t} else if (this.element.lazy === false) {\n  \t\t\tlazy = false;\n  \t\t} else if (is__isNumeric(this.element.lazy)) {\n  \t\t\tlazy = false;\n  \t\t\ttimeout = +this.element.lazy;\n  \t\t} else if (is__isNumeric(lazy || \"\")) {\n  \t\t\ttimeout = +lazy;\n  \t\t\tlazy = false;\n\n  \t\t\t// make sure the timeout is available to the handler\n  \t\t\tthis.element.lazy = timeout;\n  \t\t}\n\n  \t\tthis.handler = timeout ? handleDelay : handleDomEvent;\n\n  \t\tnode.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\tif (!lazy) {\n  \t\t\tnode.addEventListener(\"input\", this.handler, false);\n\n  \t\t\tif (node.attachEvent) {\n  \t\t\t\tnode.addEventListener(\"keyup\", this.handler, false);\n  \t\t\t}\n  \t\t}\n\n  \t\tnode.addEventListener(\"blur\", handleBlur, false);\n  \t},\n\n  \tunrender: function () {\n  \t\tvar node = this.element.node;\n  \t\tthis.rendered = false;\n\n  \t\tnode.removeEventListener(\"change\", handleDomEvent, false);\n  \t\tnode.removeEventListener(\"input\", this.handler, false);\n  \t\tnode.removeEventListener(\"keyup\", this.handler, false);\n  \t\tnode.removeEventListener(\"blur\", handleBlur, false);\n  \t}\n  });\n\n  var Binding_GenericBinding = GenericBinding;\n\n  function handleBlur() {\n  \tvar value;\n\n  \thandleDomEvent.call(this);\n\n  \tvalue = this._ractive.root.viewmodel.get(this._ractive.binding.keypath);\n  \tthis.value = value == undefined ? \"\" : value;\n  }\n\n  function handleDelay() {\n  \tvar binding = this._ractive.binding,\n  \t    el = this;\n\n  \tif (!!binding._timeout) clearTimeout(binding._timeout);\n\n  \tbinding._timeout = setTimeout(function () {\n  \t\tif (binding.rendered) handleDomEvent.call(el);\n  \t\tbinding._timeout = undefined;\n  \t}, binding.element.lazy);\n  }\n\n  var ContentEditableBinding = Binding_GenericBinding.extend({\n  \tgetInitialValue: function () {\n  \t\treturn this.element.fragment ? this.element.fragment.toString() : \"\";\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.element.node.innerHTML;\n  \t}\n  });\n\n  var Binding_ContentEditableBinding = ContentEditableBinding;\n\n  var shared_getSiblings = getSiblings;\n  var sets = {};\n  function getSiblings(id, group, keypath) {\n  \tvar hash = id + group + keypath;\n  \treturn sets[hash] || (sets[hash] = []);\n  }\n\n  var RadioBinding = Binding_Binding.extend({\n  \tname: \"checked\",\n\n  \tinit: function () {\n  \t\tthis.siblings = shared_getSiblings(this.root._guid, \"radio\", this.element.getAttribute(\"name\"));\n  \t\tthis.siblings.push(this);\n  \t},\n\n  \trender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\tif (node.attachEvent) {\n  \t\t\tnode.addEventListener(\"click\", handleDomEvent, false);\n  \t\t}\n  \t},\n\n  \tunrender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.removeEventListener(\"change\", handleDomEvent, false);\n  \t\tnode.removeEventListener(\"click\", handleDomEvent, false);\n  \t},\n\n  \thandleChange: function () {\n  \t\tglobal_runloop.start(this.root);\n\n  \t\tthis.siblings.forEach(function (binding) {\n  \t\t\tbinding.root.viewmodel.set(binding.keypath, binding.getValue());\n  \t\t});\n\n  \t\tglobal_runloop.end();\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.element.node.checked;\n  \t},\n\n  \tunbind: function () {\n  \t\tremoveFromArray(this.siblings, this);\n  \t}\n  });\n\n  var Binding_RadioBinding = RadioBinding;\n\n  var RadioNameBinding = Binding_Binding.extend({\n  \tname: \"name\",\n\n  \tinit: function () {\n  \t\tthis.siblings = shared_getSiblings(this.root._guid, \"radioname\", this.keypath.str);\n  \t\tthis.siblings.push(this);\n\n  \t\tthis.radioName = true; // so that ractive.updateModel() knows what to do with this\n  \t},\n\n  \tgetInitialValue: function () {\n  \t\tif (this.element.getAttribute(\"checked\")) {\n  \t\t\treturn this.element.getAttribute(\"value\");\n  \t\t}\n  \t},\n\n  \trender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.name = \"{{\" + this.keypath.str + \"}}\";\n  \t\tnode.checked = this.root.viewmodel.get(this.keypath) == this.element.getAttribute(\"value\");\n\n  \t\tnode.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\tif (node.attachEvent) {\n  \t\t\tnode.addEventListener(\"click\", handleDomEvent, false);\n  \t\t}\n  \t},\n\n  \tunrender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.removeEventListener(\"change\", handleDomEvent, false);\n  \t\tnode.removeEventListener(\"click\", handleDomEvent, false);\n  \t},\n\n  \tgetValue: function () {\n  \t\tvar node = this.element.node;\n  \t\treturn node._ractive ? node._ractive.value : node.value;\n  \t},\n\n  \thandleChange: function () {\n  \t\t// If this <input> is the one that's checked, then the value of its\n  \t\t// `name` keypath gets set to its value\n  \t\tif (this.element.node.checked) {\n  \t\t\tBinding_Binding.prototype.handleChange.call(this);\n  \t\t}\n  \t},\n\n  \trebound: function (oldKeypath, newKeypath) {\n  \t\tvar node;\n\n  \t\tBinding_Binding.prototype.rebound.call(this, oldKeypath, newKeypath);\n\n  \t\tif (node = this.element.node) {\n  \t\t\tnode.name = \"{{\" + this.keypath.str + \"}}\";\n  \t\t}\n  \t},\n\n  \tunbind: function () {\n  \t\tremoveFromArray(this.siblings, this);\n  \t}\n  });\n\n  var Binding_RadioNameBinding = RadioNameBinding;\n\n  var CheckboxNameBinding = Binding_Binding.extend({\n  \tname: \"name\",\n\n  \tgetInitialValue: function () {\n  \t\t// This only gets called once per group (of inputs that\n  \t\t// share a name), because it only gets called if there\n  \t\t// isn't an initial value. By the same token, we can make\n  \t\t// a note of that fact that there was no initial value,\n  \t\t// and populate it using any `checked` attributes that\n  \t\t// exist (which users should avoid, but which we should\n  \t\t// support anyway to avoid breaking expectations)\n  \t\tthis.noInitialValue = true;\n  \t\treturn [];\n  \t},\n\n  \tinit: function () {\n  \t\tvar existingValue, bindingValue;\n\n  \t\tthis.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\n  \t\t// Each input has a reference to an array containing it and its\n  \t\t// siblings, as two-way binding depends on being able to ascertain\n  \t\t// the status of all inputs within the group\n  \t\tthis.siblings = shared_getSiblings(this.root._guid, \"checkboxes\", this.keypath.str);\n  \t\tthis.siblings.push(this);\n\n  \t\tif (this.noInitialValue) {\n  \t\t\tthis.siblings.noInitialValue = true;\n  \t\t}\n\n  \t\t// If no initial value was set, and this input is checked, we\n  \t\t// update the model\n  \t\tif (this.siblings.noInitialValue && this.element.getAttribute(\"checked\")) {\n  \t\t\texistingValue = this.root.viewmodel.get(this.keypath);\n  \t\t\tbindingValue = this.element.getAttribute(\"value\");\n\n  \t\t\texistingValue.push(bindingValue);\n  \t\t}\n  \t},\n\n  \tunbind: function () {\n  \t\tremoveFromArray(this.siblings, this);\n  \t},\n\n  \trender: function () {\n  \t\tvar node = this.element.node,\n  \t\t    existingValue,\n  \t\t    bindingValue;\n\n  \t\texistingValue = this.root.viewmodel.get(this.keypath);\n  \t\tbindingValue = this.element.getAttribute(\"value\");\n\n  \t\tif (isArray(existingValue)) {\n  \t\t\tthis.isChecked = arrayContains(existingValue, bindingValue);\n  \t\t} else {\n  \t\t\tthis.isChecked = existingValue == bindingValue;\n  \t\t}\n\n  \t\tnode.name = \"{{\" + this.keypath.str + \"}}\";\n  \t\tnode.checked = this.isChecked;\n\n  \t\tnode.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\t// in case of IE emergency, bind to click event as well\n  \t\tif (node.attachEvent) {\n  \t\t\tnode.addEventListener(\"click\", handleDomEvent, false);\n  \t\t}\n  \t},\n\n  \tunrender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.removeEventListener(\"change\", handleDomEvent, false);\n  \t\tnode.removeEventListener(\"click\", handleDomEvent, false);\n  \t},\n\n  \tchanged: function () {\n  \t\tvar wasChecked = !!this.isChecked;\n  \t\tthis.isChecked = this.element.node.checked;\n  \t\treturn this.isChecked === wasChecked;\n  \t},\n\n  \thandleChange: function () {\n  \t\tthis.isChecked = this.element.node.checked;\n  \t\tBinding_Binding.prototype.handleChange.call(this);\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.siblings.filter(isChecked).map(Binding_CheckboxNameBinding__getValue);\n  \t}\n  });\n\n  function isChecked(binding) {\n  \treturn binding.isChecked;\n  }\n\n  function Binding_CheckboxNameBinding__getValue(binding) {\n  \treturn binding.element.getAttribute(\"value\");\n  }\n\n  var Binding_CheckboxNameBinding = CheckboxNameBinding;\n\n  var CheckboxBinding = Binding_Binding.extend({\n  \tname: \"checked\",\n\n  \trender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\tif (node.attachEvent) {\n  \t\t\tnode.addEventListener(\"click\", handleDomEvent, false);\n  \t\t}\n  \t},\n\n  \tunrender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.removeEventListener(\"change\", handleDomEvent, false);\n  \t\tnode.removeEventListener(\"click\", handleDomEvent, false);\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.element.node.checked;\n  \t}\n  });\n\n  var Binding_CheckboxBinding = CheckboxBinding;\n\n  var SelectBinding = Binding_Binding.extend({\n  \tgetInitialValue: function () {\n  \t\tvar options = this.element.options,\n  \t\t    len,\n  \t\t    i,\n  \t\t    value,\n  \t\t    optionWasSelected;\n\n  \t\tif (this.element.getAttribute(\"value\") !== undefined) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\ti = len = options.length;\n\n  \t\tif (!len) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// take the final selected option...\n  \t\twhile (i--) {\n  \t\t\tif (options[i].getAttribute(\"selected\")) {\n  \t\t\t\tvalue = options[i].getAttribute(\"value\");\n  \t\t\t\toptionWasSelected = true;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n\n  \t\t// or the first non-disabled option, if none are selected\n  \t\tif (!optionWasSelected) {\n  \t\t\twhile (++i < len) {\n  \t\t\t\tif (!options[i].getAttribute(\"disabled\")) {\n  \t\t\t\t\tvalue = options[i].getAttribute(\"value\");\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// This is an optimisation (aka hack) that allows us to forgo some\n  \t\t// other more expensive work\n  \t\tif (value !== undefined) {\n  \t\t\tthis.element.attributes.value.value = value;\n  \t\t}\n\n  \t\treturn value;\n  \t},\n\n  \trender: function () {\n  \t\tthis.element.node.addEventListener(\"change\", handleDomEvent, false);\n  \t},\n\n  \tunrender: function () {\n  \t\tthis.element.node.removeEventListener(\"change\", handleDomEvent, false);\n  \t},\n\n  \t// TODO this method is an anomaly... is it necessary?\n  \tsetValue: function (value) {\n  \t\tthis.root.viewmodel.set(this.keypath, value);\n  \t},\n\n  \tgetValue: function () {\n  \t\tvar options, i, len, option, optionValue;\n\n  \t\toptions = this.element.node.options;\n  \t\tlen = options.length;\n\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\toption = options[i];\n\n  \t\t\tif (options[i].selected) {\n  \t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n  \t\t\t\treturn optionValue;\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tforceUpdate: function () {\n  \t\tvar _this = this;\n\n  \t\tvar value = this.getValue();\n\n  \t\tif (value !== undefined) {\n  \t\t\tthis.attribute.locked = true;\n  \t\t\tglobal_runloop.scheduleTask(function () {\n  \t\t\t\treturn _this.attribute.locked = false;\n  \t\t\t});\n  \t\t\tthis.root.viewmodel.set(this.keypath, value);\n  \t\t}\n  \t}\n  });\n\n  var Binding_SelectBinding = SelectBinding;\n\n  var MultipleSelectBinding = Binding_SelectBinding.extend({\n  \tgetInitialValue: function () {\n  \t\treturn this.element.options.filter(function (option) {\n  \t\t\treturn option.getAttribute(\"selected\");\n  \t\t}).map(function (option) {\n  \t\t\treturn option.getAttribute(\"value\");\n  \t\t});\n  \t},\n\n  \trender: function () {\n  \t\tvar valueFromModel;\n\n  \t\tthis.element.node.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\tvalueFromModel = this.root.viewmodel.get(this.keypath);\n\n  \t\tif (valueFromModel === undefined) {\n  \t\t\t// get value from DOM, if possible\n  \t\t\tthis.handleChange();\n  \t\t}\n  \t},\n\n  \tunrender: function () {\n  \t\tthis.element.node.removeEventListener(\"change\", handleDomEvent, false);\n  \t},\n\n  \tsetValue: function () {\n  \t\tthrow new Error(\"TODO not implemented yet\");\n  \t},\n\n  \tgetValue: function () {\n  \t\tvar selectedValues, options, i, len, option, optionValue;\n\n  \t\tselectedValues = [];\n  \t\toptions = this.element.node.options;\n  \t\tlen = options.length;\n\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\toption = options[i];\n\n  \t\t\tif (option.selected) {\n  \t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n  \t\t\t\tselectedValues.push(optionValue);\n  \t\t\t}\n  \t\t}\n\n  \t\treturn selectedValues;\n  \t},\n\n  \thandleChange: function () {\n  \t\tvar attribute, previousValue, value;\n\n  \t\tattribute = this.attribute;\n  \t\tpreviousValue = attribute.value;\n\n  \t\tvalue = this.getValue();\n\n  \t\tif (previousValue === undefined || !arrayContentsMatch(value, previousValue)) {\n  \t\t\tBinding_SelectBinding.prototype.handleChange.call(this);\n  \t\t}\n\n  \t\treturn this;\n  \t},\n\n  \tforceUpdate: function () {\n  \t\tvar _this = this;\n\n  \t\tvar value = this.getValue();\n\n  \t\tif (value !== undefined) {\n  \t\t\tthis.attribute.locked = true;\n  \t\t\tglobal_runloop.scheduleTask(function () {\n  \t\t\t\treturn _this.attribute.locked = false;\n  \t\t\t});\n  \t\t\tthis.root.viewmodel.set(this.keypath, value);\n  \t\t}\n  \t},\n\n  \tupdateModel: function () {\n  \t\tif (this.attribute.value === undefined || !this.attribute.value.length) {\n  \t\t\tthis.root.viewmodel.set(this.keypath, this.initialValue);\n  \t\t}\n  \t}\n  });\n\n  var Binding_MultipleSelectBinding = MultipleSelectBinding;\n\n  var FileListBinding = Binding_Binding.extend({\n  \trender: function () {\n  \t\tthis.element.node.addEventListener(\"change\", handleDomEvent, false);\n  \t},\n\n  \tunrender: function () {\n  \t\tthis.element.node.removeEventListener(\"change\", handleDomEvent, false);\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.element.node.files;\n  \t}\n  });\n\n  var Binding_FileListBinding = FileListBinding;\n\n  var NumericBinding = Binding_GenericBinding.extend({\n  \tgetInitialValue: function () {\n  \t\treturn undefined;\n  \t},\n\n  \tgetValue: function () {\n  \t\tvar value = parseFloat(this.element.node.value);\n  \t\treturn isNaN(value) ? undefined : value;\n  \t}\n  });\n\n  var init_createTwowayBinding = createTwowayBinding;\n\n  function createTwowayBinding(element) {\n  \tvar attributes = element.attributes,\n  \t    type,\n  \t    Binding,\n  \t    bindName,\n  \t    bindChecked,\n  \t    binding;\n\n  \t// if this is a late binding, and there's already one, it\n  \t// needs to be torn down\n  \tif (element.binding) {\n  \t\telement.binding.teardown();\n  \t\telement.binding = null;\n  \t}\n\n  \t// contenteditable\n  \tif (\n  \t// if the contenteditable attribute is true or is bindable and may thus become true\n  \t(element.getAttribute(\"contenteditable\") || !!attributes.contenteditable && isBindable(attributes.contenteditable)) && isBindable(attributes.value)) {\n  \t\tBinding = Binding_ContentEditableBinding;\n  \t}\n\n  \t// <input>\n  \telse if (element.name === \"input\") {\n  \t\ttype = element.getAttribute(\"type\");\n\n  \t\tif (type === \"radio\" || type === \"checkbox\") {\n  \t\t\tbindName = isBindable(attributes.name);\n  \t\t\tbindChecked = isBindable(attributes.checked);\n\n  \t\t\t// we can either bind the name attribute, or the checked attribute - not both\n  \t\t\tif (bindName && bindChecked) {\n  \t\t\t\twarnIfDebug(\"A radio input can have two-way binding on its name attribute, or its checked attribute - not both\", { ractive: element.root });\n  \t\t\t}\n\n  \t\t\tif (bindName) {\n  \t\t\t\tBinding = type === \"radio\" ? Binding_RadioNameBinding : Binding_CheckboxNameBinding;\n  \t\t\t} else if (bindChecked) {\n  \t\t\t\tBinding = type === \"radio\" ? Binding_RadioBinding : Binding_CheckboxBinding;\n  \t\t\t}\n  \t\t} else if (type === \"file\" && isBindable(attributes.value)) {\n  \t\t\tBinding = Binding_FileListBinding;\n  \t\t} else if (isBindable(attributes.value)) {\n  \t\t\tBinding = type === \"number\" || type === \"range\" ? NumericBinding : Binding_GenericBinding;\n  \t\t}\n  \t}\n\n  \t// <select>\n  \telse if (element.name === \"select\" && isBindable(attributes.value)) {\n  \t\tBinding = element.getAttribute(\"multiple\") ? Binding_MultipleSelectBinding : Binding_SelectBinding;\n  \t}\n\n  \t// <textarea>\n  \telse if (element.name === \"textarea\" && isBindable(attributes.value)) {\n  \t\tBinding = Binding_GenericBinding;\n  \t}\n\n  \tif (Binding && (binding = new Binding(element)) && binding.keypath) {\n  \t\treturn binding;\n  \t}\n  }\n\n  function isBindable(attribute) {\n  \treturn attribute && attribute.isBindable;\n  }\n\n  // and this element also has a value attribute to bind\n\n  var EventHandler_prototype_bubble = EventHandler$bubble;\n\n  function EventHandler$bubble() {\n  \tvar hasAction = this.getAction();\n\n  \tif (hasAction && !this.hasListener) {\n  \t\tthis.listen();\n  \t} else if (!hasAction && this.hasListener) {\n  \t\tthis.unrender();\n  \t}\n  }\n\n  // This function may be overwritten, if the event directive\n  // includes parameters\n  var EventHandler_prototype_fire = EventHandler$fire;\n  function EventHandler$fire(event) {\n  \tshared_fireEvent(this.root, this.getAction(), { event: event });\n  }\n\n  var getAction = EventHandler$getAction;\n\n  function EventHandler$getAction() {\n  \treturn this.action.toString().trim();\n  }\n\n  var EventHandler_prototype_init = EventHandler$init;\n\n  var eventPattern = /^event(?:\\.(.+))?/;\n  function EventHandler$init(element, name, template) {\n  \tvar _this = this;\n\n  \tvar action, refs, ractive;\n\n  \tthis.element = element;\n  \tthis.root = element.root;\n  \tthis.parentFragment = element.parentFragment;\n  \tthis.name = name;\n\n  \tif (name.indexOf(\"*\") !== -1) {\n  \t\tfatal(\"Only component proxy-events may contain \\\"*\\\" wildcards, <%s on-%s=\\\"...\\\"/> is not valid\", element.name, name);\n  \t\tthis.invalid = true;\n  \t}\n\n  \tif (template.m) {\n  \t\trefs = template.a.r;\n\n  \t\t// This is a method call\n  \t\tthis.method = template.m;\n  \t\tthis.keypaths = [];\n  \t\tthis.fn = shared_getFunctionFromString(template.a.s, refs.length);\n\n  \t\tthis.parentFragment = element.parentFragment;\n  \t\tractive = this.root;\n\n  \t\t// Create resolvers for each reference\n  \t\tthis.refResolvers = [];\n  \t\trefs.forEach(function (ref, i) {\n  \t\t\tvar match = undefined;\n\n  \t\t\t// special case - the `event` object\n  \t\t\tif (match = eventPattern.exec(ref)) {\n  \t\t\t\t_this.keypaths[i] = {\n  \t\t\t\t\teventObject: true,\n  \t\t\t\t\trefinements: match[1] ? match[1].split(\".\") : []\n  \t\t\t\t};\n  \t\t\t} else {\n  \t\t\t\t_this.refResolvers.push(Resolvers_createReferenceResolver(_this, ref, function (keypath) {\n  \t\t\t\t\treturn _this.resolve(i, keypath);\n  \t\t\t\t}));\n  \t\t\t}\n  \t\t});\n\n  \t\tthis.fire = fireMethodCall;\n  \t} else {\n  \t\t// Get action ('foo' in 'on-click='foo')\n  \t\taction = template.n || template;\n  \t\tif (typeof action !== \"string\") {\n  \t\t\taction = new virtualdom_Fragment({\n  \t\t\t\ttemplate: action,\n  \t\t\t\troot: this.root,\n  \t\t\t\towner: this\n  \t\t\t});\n  \t\t}\n\n  \t\tthis.action = action;\n\n  \t\t// Get parameters\n  \t\tif (template.d) {\n  \t\t\tthis.dynamicParams = new virtualdom_Fragment({\n  \t\t\t\ttemplate: template.d,\n  \t\t\t\troot: this.root,\n  \t\t\t\towner: this.element\n  \t\t\t});\n\n  \t\t\tthis.fire = fireEventWithDynamicParams;\n  \t\t} else if (template.a) {\n  \t\t\tthis.params = template.a;\n  \t\t\tthis.fire = fireEventWithParams;\n  \t\t}\n  \t}\n  }\n\n  function fireMethodCall(event) {\n  \tvar ractive, values, args;\n\n  \tractive = this.root;\n\n  \tif (typeof ractive[this.method] !== \"function\") {\n  \t\tthrow new Error(\"Attempted to call a non-existent method (\\\"\" + this.method + \"\\\")\");\n  \t}\n\n  \tvalues = this.keypaths.map(function (keypath) {\n  \t\tvar value, len, i;\n\n  \t\tif (keypath === undefined) {\n  \t\t\t// not yet resolved\n  \t\t\treturn undefined;\n  \t\t}\n\n  \t\t// TODO the refinements stuff would be better handled at parse time\n  \t\tif (keypath.eventObject) {\n  \t\t\tvalue = event;\n\n  \t\t\tif (len = keypath.refinements.length) {\n  \t\t\t\tfor (i = 0; i < len; i += 1) {\n  \t\t\t\t\tvalue = value[keypath.refinements[i]];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else {\n  \t\t\tvalue = ractive.viewmodel.get(keypath);\n  \t\t}\n\n  \t\treturn value;\n  \t});\n\n  \tshared_eventStack.enqueue(ractive, event);\n\n  \targs = this.fn.apply(null, values);\n  \tractive[this.method].apply(ractive, args);\n\n  \tshared_eventStack.dequeue(ractive);\n  }\n\n  function fireEventWithParams(event) {\n  \tshared_fireEvent(this.root, this.getAction(), { event: event, args: this.params });\n  }\n\n  function fireEventWithDynamicParams(event) {\n  \tvar args = this.dynamicParams.getArgsList();\n\n  \t// need to strip [] from ends if a string!\n  \tif (typeof args === \"string\") {\n  \t\targs = args.substr(1, args.length - 2);\n  \t}\n\n  \tshared_fireEvent(this.root, this.getAction(), { event: event, args: args });\n  }\n\n  var shared_genericHandler = genericHandler;\n  function genericHandler(event) {\n  \tvar storage,\n  \t    handler,\n  \t    indices,\n  \t    index = {};\n\n  \tstorage = this._ractive;\n  \thandler = storage.events[event.type];\n\n  \tif (indices = Resolvers_findIndexRefs(handler.element.parentFragment)) {\n  \t\tindex = Resolvers_findIndexRefs.resolve(indices);\n  \t}\n\n  \thandler.fire({\n  \t\tnode: this,\n  \t\toriginal: event,\n  \t\tindex: index,\n  \t\tkeypath: storage.keypath.str,\n  \t\tcontext: storage.root.viewmodel.get(storage.keypath)\n  \t});\n  }\n\n  var listen = EventHandler$listen;\n\n  var customHandlers = {},\n      touchEvents = {\n  \ttouchstart: true,\n  \ttouchmove: true,\n  \ttouchend: true,\n  \ttouchcancel: true,\n  \t//not w3c, but supported in some browsers\n  \ttouchleave: true\n  };\n  function EventHandler$listen() {\n  \tvar definition,\n  \t    name = this.name;\n\n  \tif (this.invalid) {\n  \t\treturn;\n  \t}\n\n  \tif (definition = findInViewHierarchy(\"events\", this.root, name)) {\n  \t\tthis.custom = definition(this.node, getCustomHandler(name));\n  \t} else {\n  \t\t// Looks like we're dealing with a standard DOM event... but let's check\n  \t\tif (!(\"on\" + name in this.node) && !(window && \"on\" + name in window) && !isJsdom) {\n\n  \t\t\t// okay to use touch events if this browser doesn't support them\n  \t\t\tif (!touchEvents[name]) {\n  \t\t\t\twarnOnceIfDebug(missingPlugin(name, \"event\"), { node: this.node });\n  \t\t\t}\n\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.node.addEventListener(name, shared_genericHandler, false);\n  \t}\n\n  \tthis.hasListener = true;\n  }\n\n  function getCustomHandler(name) {\n  \tif (!customHandlers[name]) {\n  \t\tcustomHandlers[name] = function (event) {\n  \t\t\tvar storage = event.node._ractive;\n\n  \t\t\tevent.index = storage.index;\n  \t\t\tevent.keypath = storage.keypath.str;\n  \t\t\tevent.context = storage.root.viewmodel.get(storage.keypath);\n\n  \t\t\tstorage.events[name].fire(event);\n  \t\t};\n  \t}\n\n  \treturn customHandlers[name];\n  }\n\n  var EventHandler_prototype_rebind = EventHandler$rebind;\n\n  function EventHandler$rebind(oldKeypath, newKeypath) {\n  \tvar fragment;\n  \tif (this.method) {\n  \t\tfragment = this.element.parentFragment;\n  \t\tthis.refResolvers.forEach(rebind);\n\n  \t\treturn;\n  \t}\n\n  \tif (typeof this.action !== \"string\") {\n  \t\trebind(this.action);\n  \t}\n\n  \tif (this.dynamicParams) {\n  \t\trebind(this.dynamicParams);\n  \t}\n\n  \tfunction rebind(thing) {\n  \t\tthing && thing.rebind(oldKeypath, newKeypath);\n  \t}\n  }\n\n  var EventHandler_prototype_render = EventHandler$render;\n\n  function EventHandler$render() {\n  \tthis.node = this.element.node;\n  \t// store this on the node itself, so it can be retrieved by a\n  \t// universal handler\n  \tthis.node._ractive.events[this.name] = this;\n\n  \tif (this.method || this.getAction()) {\n  \t\tthis.listen();\n  \t}\n  }\n\n  var prototype_resolve = EventHandler$resolve;\n\n  function EventHandler$resolve(index, keypath) {\n  \tthis.keypaths[index] = keypath;\n  }\n\n  var EventHandler_prototype_unbind = EventHandler$unbind;\n  function EventHandler$unbind() {\n  \tif (this.method) {\n  \t\tthis.refResolvers.forEach(methodCallers__unbind);\n  \t\treturn;\n  \t}\n\n  \t// Tear down dynamic name\n  \tif (typeof this.action !== \"string\") {\n  \t\tthis.action.unbind();\n  \t}\n\n  \t// Tear down dynamic parameters\n  \tif (this.dynamicParams) {\n  \t\tthis.dynamicParams.unbind();\n  \t}\n  }\n\n  var EventHandler_prototype_unrender = EventHandler$unrender;\n  function EventHandler$unrender() {\n\n  \tif (this.custom) {\n  \t\tthis.custom.teardown();\n  \t} else {\n  \t\tthis.node.removeEventListener(this.name, shared_genericHandler, false);\n  \t}\n\n  \tthis.hasListener = false;\n  }\n\n  var EventHandler = function (element, name, template) {\n  \tthis.init(element, name, template);\n  };\n\n  EventHandler.prototype = {\n  \tbubble: EventHandler_prototype_bubble,\n  \tfire: EventHandler_prototype_fire,\n  \tgetAction: getAction,\n  \tinit: EventHandler_prototype_init,\n  \tlisten: listen,\n  \trebind: EventHandler_prototype_rebind,\n  \trender: EventHandler_prototype_render,\n  \tresolve: prototype_resolve,\n  \tunbind: EventHandler_prototype_unbind,\n  \tunrender: EventHandler_prototype_unrender\n  };\n\n  var _EventHandler = EventHandler;\n\n  var createEventHandlers = function (element, template) {\n  \tvar i,\n  \t    name,\n  \t    names,\n  \t    handler,\n  \t    result = [];\n\n  \tfor (name in template) {\n  \t\tif (template.hasOwnProperty(name)) {\n  \t\t\tnames = name.split(\"-\");\n  \t\t\ti = names.length;\n\n  \t\t\twhile (i--) {\n  \t\t\t\thandler = new _EventHandler(element, names[i], template[name]);\n  \t\t\t\tresult.push(handler);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn result;\n  };\n\n  var Decorator = function (element, template) {\n  \tvar self = this,\n  \t    ractive,\n  \t    name,\n  \t    fragment;\n\n  \tthis.element = element;\n  \tthis.root = ractive = element.root;\n\n  \tname = template.n || template;\n\n  \tif (typeof name !== \"string\") {\n  \t\tfragment = new virtualdom_Fragment({\n  \t\t\ttemplate: name,\n  \t\t\troot: ractive,\n  \t\t\towner: element\n  \t\t});\n\n  \t\tname = fragment.toString();\n  \t\tfragment.unbind();\n\n  \t\tif (name === \"\") {\n  \t\t\t// empty string okay, just no decorator\n  \t\t\treturn;\n  \t\t}\n  \t}\n\n  \tif (template.a) {\n  \t\tthis.params = template.a;\n  \t} else if (template.d) {\n  \t\tthis.fragment = new virtualdom_Fragment({\n  \t\t\ttemplate: template.d,\n  \t\t\troot: ractive,\n  \t\t\towner: element\n  \t\t});\n\n  \t\tthis.params = this.fragment.getArgsList();\n\n  \t\tthis.fragment.bubble = function () {\n  \t\t\tthis.dirtyArgs = this.dirtyValue = true;\n  \t\t\tself.params = this.getArgsList();\n\n  \t\t\tif (self.ready) {\n  \t\t\t\tself.update();\n  \t\t\t}\n  \t\t};\n  \t}\n\n  \tthis.fn = findInViewHierarchy(\"decorators\", ractive, name);\n\n  \tif (!this.fn) {\n  \t\tfatal(missingPlugin(name, \"decorator\"));\n  \t}\n  };\n\n  Decorator.prototype = {\n  \tinit: function () {\n  \t\tvar node, result, args;\n\n  \t\tnode = this.element.node;\n\n  \t\tif (this.params) {\n  \t\t\targs = [node].concat(this.params);\n  \t\t\tresult = this.fn.apply(this.root, args);\n  \t\t} else {\n  \t\t\tresult = this.fn.call(this.root, node);\n  \t\t}\n\n  \t\tif (!result || !result.teardown) {\n  \t\t\tthrow new Error(\"Decorator definition must return an object with a teardown method\");\n  \t\t}\n\n  \t\t// TODO does this make sense?\n  \t\tthis.actual = result;\n  \t\tthis.ready = true;\n  \t},\n\n  \tupdate: function () {\n  \t\tif (this.actual.update) {\n  \t\t\tthis.actual.update.apply(this.root, this.params);\n  \t\t} else {\n  \t\t\tthis.actual.teardown(true);\n  \t\t\tthis.init();\n  \t\t}\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tif (this.fragment) {\n  \t\t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t\t}\n  \t},\n\n  \tteardown: function (updating) {\n  \t\tthis.torndown = true;\n  \t\tif (this.ready) {\n  \t\t\tthis.actual.teardown();\n  \t\t}\n\n  \t\tif (!updating && this.fragment) {\n  \t\t\tthis.fragment.unbind();\n  \t\t}\n  \t}\n  };\n\n  var _Decorator = Decorator;\n\n  function select__bubble() {\n  \tvar _this = this;\n\n  \tif (!this.dirty) {\n  \t\tthis.dirty = true;\n\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\tsync(_this);\n  \t\t\t_this.dirty = false;\n  \t\t});\n  \t}\n\n  \tthis.parentFragment.bubble(); // default behaviour\n  }\n\n  function sync(selectElement) {\n  \tvar selectNode, selectValue, isMultiple, options, optionWasSelected;\n\n  \tselectNode = selectElement.node;\n\n  \tif (!selectNode) {\n  \t\treturn;\n  \t}\n\n  \toptions = toArray(selectNode.options);\n\n  \tselectValue = selectElement.getAttribute(\"value\");\n  \tisMultiple = selectElement.getAttribute(\"multiple\");\n\n  \t// If the <select> has a specified value, that should override\n  \t// these options\n  \tif (selectValue !== undefined) {\n  \t\toptions.forEach(function (o) {\n  \t\t\tvar optionValue, shouldSelect;\n\n  \t\t\toptionValue = o._ractive ? o._ractive.value : o.value;\n  \t\t\tshouldSelect = isMultiple ? valueContains(selectValue, optionValue) : selectValue == optionValue;\n\n  \t\t\tif (shouldSelect) {\n  \t\t\t\toptionWasSelected = true;\n  \t\t\t}\n\n  \t\t\to.selected = shouldSelect;\n  \t\t});\n\n  \t\tif (!optionWasSelected) {\n  \t\t\tif (options[0]) {\n  \t\t\t\toptions[0].selected = true;\n  \t\t\t}\n\n  \t\t\tif (selectElement.binding) {\n  \t\t\t\tselectElement.binding.forceUpdate();\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// Otherwise the value should be initialised according to which\n  \t// <option> element is selected, if twoway binding is in effect\n  \telse if (selectElement.binding) {\n  \t\tselectElement.binding.forceUpdate();\n  \t}\n  }\n\n  function valueContains(selectValue, optionValue) {\n  \tvar i = selectValue.length;\n  \twhile (i--) {\n  \t\tif (selectValue[i] == optionValue) {\n  \t\t\treturn true;\n  \t\t}\n  \t}\n  }\n\n  function special_option__init(option, template) {\n  \toption.select = findParentSelect(option.parent);\n\n  \t// we might be inside a <datalist> element\n  \tif (!option.select) {\n  \t\treturn;\n  \t}\n\n  \toption.select.options.push(option);\n\n  \t// If the value attribute is missing, use the element's content\n  \tif (!template.a) {\n  \t\ttemplate.a = {};\n  \t}\n\n  \t// ...as long as it isn't disabled\n  \tif (template.a.value === undefined && !template.a.hasOwnProperty(\"disabled\")) {\n  \t\ttemplate.a.value = template.f;\n  \t}\n\n  \t// If there is a `selected` attribute, but the <select>\n  \t// already has a value, delete it\n  \tif (\"selected\" in template.a && option.select.getAttribute(\"value\") !== undefined) {\n  \t\tdelete template.a.selected;\n  \t}\n  }\n\n  function special_option__unbind(option) {\n  \tif (option.select) {\n  \t\tremoveFromArray(option.select.options, option);\n  \t}\n  }\n\n  function findParentSelect(element) {\n  \tif (!element) {\n  \t\treturn;\n  \t}\n\n  \tdo {\n  \t\tif (element.name === \"select\") {\n  \t\t\treturn element;\n  \t\t}\n  \t} while (element = element.parent);\n  }\n\n  var Element_prototype_init = Element$init;\n  function Element$init(options) {\n  \tvar parentFragment, template, ractive, binding, bindings, twoway, bindingAttrs;\n\n  \tthis.type = ELEMENT;\n\n  \t// stuff we'll need later\n  \tparentFragment = this.parentFragment = options.parentFragment;\n  \ttemplate = this.template = options.template;\n\n  \tthis.parent = options.pElement || parentFragment.pElement;\n\n  \tthis.root = ractive = parentFragment.root;\n  \tthis.index = options.index;\n  \tthis.key = options.key;\n\n  \tthis.name = enforceCase(template.e);\n\n  \t// Special case - <option> elements\n  \tif (this.name === \"option\") {\n  \t\tspecial_option__init(this, template);\n  \t}\n\n  \t// Special case - <select> elements\n  \tif (this.name === \"select\") {\n  \t\tthis.options = [];\n  \t\tthis.bubble = select__bubble; // TODO this is a kludge\n  \t}\n\n  \t// Special case - <form> elements\n  \tif (this.name === \"form\") {\n  \t\tthis.formBindings = [];\n  \t}\n\n  \t// handle binding attributes first (twoway, lazy)\n  \tbindingAttrs = processBindingAttributes(this, template);\n\n  \t// create attributes\n  \tthis.attributes = createAttributes(this, template.a);\n  \tthis.conditionalAttributes = createConditionalAttributes(this, template.m);\n\n  \t// append children, if there are any\n  \tif (template.f) {\n  \t\tthis.fragment = new virtualdom_Fragment({\n  \t\t\ttemplate: template.f,\n  \t\t\troot: ractive,\n  \t\t\towner: this,\n  \t\t\tpElement: this,\n  \t\t\tcssIds: null\n  \t\t});\n  \t}\n\n  \t// the element setting should override the ractive setting\n  \ttwoway = ractive.twoway;\n  \tif (bindingAttrs.twoway === false) twoway = false;else if (bindingAttrs.twoway === true) twoway = true;\n\n  \tthis.twoway = twoway;\n  \tthis.lazy = bindingAttrs.lazy;\n\n  \t// create twoway binding\n  \tif (twoway && (binding = init_createTwowayBinding(this, template.a))) {\n  \t\tthis.binding = binding;\n\n  \t\t// register this with the root, so that we can do ractive.updateModel()\n  \t\tbindings = this.root._twowayBindings[binding.keypath.str] || (this.root._twowayBindings[binding.keypath.str] = []);\n  \t\tbindings.push(binding);\n  \t}\n\n  \t// create event proxies\n  \tif (template.v) {\n  \t\tthis.eventHandlers = createEventHandlers(this, template.v);\n  \t}\n\n  \t// create decorator\n  \tif (template.o) {\n  \t\tthis.decorator = new _Decorator(this, template.o);\n  \t}\n\n  \t// create transitions\n  \tthis.intro = template.t0 || template.t1;\n  \tthis.outro = template.t0 || template.t2;\n  }\n\n  var Element_prototype_rebind = Element$rebind;\n  function Element$rebind(oldKeypath, newKeypath) {\n  \tvar i, storage, liveQueries, ractive;\n\n  \tif (this.attributes) {\n  \t\tthis.attributes.forEach(rebind);\n  \t}\n\n  \tif (this.conditionalAttributes) {\n  \t\tthis.conditionalAttributes.forEach(rebind);\n  \t}\n\n  \tif (this.eventHandlers) {\n  \t\tthis.eventHandlers.forEach(rebind);\n  \t}\n\n  \tif (this.decorator) {\n  \t\trebind(this.decorator);\n  \t}\n\n  \t// rebind children\n  \tif (this.fragment) {\n  \t\trebind(this.fragment);\n  \t}\n\n  \t// Update live queries, if necessary\n  \tif (liveQueries = this.liveQueries) {\n  \t\tractive = this.root;\n\n  \t\ti = liveQueries.length;\n  \t\twhile (i--) {\n  \t\t\tliveQueries[i]._makeDirty();\n  \t\t}\n  \t}\n\n  \tif (this.node && (storage = this.node._ractive)) {\n\n  \t\t// adjust keypath if needed\n  \t\tassignNewKeypath(storage, \"keypath\", oldKeypath, newKeypath);\n  \t}\n\n  \tfunction rebind(thing) {\n  \t\tthing.rebind(oldKeypath, newKeypath);\n  \t}\n  }\n\n  function special_img__render(img) {\n  \tvar loadHandler;\n\n  \t// if this is an <img>, and we're in a crap browser, we may need to prevent it\n  \t// from overriding width and height when it loads the src\n  \tif (img.attributes.width || img.attributes.height) {\n  \t\timg.node.addEventListener(\"load\", loadHandler = function () {\n  \t\t\tvar width = img.getAttribute(\"width\"),\n  \t\t\t    height = img.getAttribute(\"height\");\n\n  \t\t\tif (width !== undefined) {\n  \t\t\t\timg.node.setAttribute(\"width\", width);\n  \t\t\t}\n\n  \t\t\tif (height !== undefined) {\n  \t\t\t\timg.node.setAttribute(\"height\", height);\n  \t\t\t}\n\n  \t\t\timg.node.removeEventListener(\"load\", loadHandler, false);\n  \t\t}, false);\n  \t}\n  }\n\n  function form__render(element) {\n  \telement.node.addEventListener(\"reset\", handleReset, false);\n  }\n\n  function form__unrender(element) {\n  \telement.node.removeEventListener(\"reset\", handleReset, false);\n  }\n\n  function handleReset() {\n  \tvar element = this._ractive.proxy;\n\n  \tglobal_runloop.start();\n  \telement.formBindings.forEach(updateModel);\n  \tglobal_runloop.end();\n  }\n\n  function updateModel(binding) {\n  \tbinding.root.viewmodel.set(binding.keypath, binding.resetValue);\n  }\n\n  var Transition_prototype_init = Transition$init;\n  function Transition$init(element, template, isIntro) {\n  \tvar ractive, name, fragment;\n\n  \tthis.element = element;\n  \tthis.root = ractive = element.root;\n  \tthis.isIntro = isIntro;\n\n  \tname = template.n || template;\n\n  \tif (typeof name !== \"string\") {\n  \t\tfragment = new virtualdom_Fragment({\n  \t\t\ttemplate: name,\n  \t\t\troot: ractive,\n  \t\t\towner: element\n  \t\t});\n\n  \t\tname = fragment.toString();\n  \t\tfragment.unbind();\n\n  \t\tif (name === \"\") {\n  \t\t\t// empty string okay, just no transition\n  \t\t\treturn;\n  \t\t}\n  \t}\n\n  \tthis.name = name;\n\n  \tif (template.a) {\n  \t\tthis.params = template.a;\n  \t} else if (template.d) {\n  \t\t// TODO is there a way to interpret dynamic arguments without all the\n  \t\t// 'dependency thrashing'?\n  \t\tfragment = new virtualdom_Fragment({\n  \t\t\ttemplate: template.d,\n  \t\t\troot: ractive,\n  \t\t\towner: element\n  \t\t});\n\n  \t\tthis.params = fragment.getArgsList();\n  \t\tfragment.unbind();\n  \t}\n\n  \tthis._fn = findInViewHierarchy(\"transitions\", ractive, name);\n\n  \tif (!this._fn) {\n  \t\twarnOnceIfDebug(missingPlugin(name, \"transition\"), { ractive: this.root });\n  \t}\n  }\n\n  var camelCase = function (hyphenatedStr) {\n  \treturn hyphenatedStr.replace(/-([a-zA-Z])/g, function (match, $1) {\n  \t\treturn $1.toUpperCase();\n  \t});\n  };\n\n  var helpers_prefix__prefix, prefixCache, helpers_prefix__testStyle;\n\n  if (!isClient) {\n  \thelpers_prefix__prefix = null;\n  } else {\n  \tprefixCache = {};\n  \thelpers_prefix__testStyle = createElement(\"div\").style;\n\n  \thelpers_prefix__prefix = function (prop) {\n  \t\tvar i, vendor, capped;\n\n  \t\tprop = camelCase(prop);\n\n  \t\tif (!prefixCache[prop]) {\n  \t\t\tif (helpers_prefix__testStyle[prop] !== undefined) {\n  \t\t\t\tprefixCache[prop] = prop;\n  \t\t\t} else {\n  \t\t\t\t// test vendors...\n  \t\t\t\tcapped = prop.charAt(0).toUpperCase() + prop.substring(1);\n\n  \t\t\t\ti = vendors.length;\n  \t\t\t\twhile (i--) {\n  \t\t\t\t\tvendor = vendors[i];\n  \t\t\t\t\tif (helpers_prefix__testStyle[vendor + capped] !== undefined) {\n  \t\t\t\t\t\tprefixCache[prop] = vendor + capped;\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\treturn prefixCache[prop];\n  \t};\n  }\n\n  var helpers_prefix = helpers_prefix__prefix;\n\n  var getStyle, prototype_getStyle__getComputedStyle;\n\n  if (!isClient) {\n  \tgetStyle = null;\n  } else {\n  \tprototype_getStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n  \tgetStyle = function (props) {\n  \t\tvar computedStyle, styles, i, prop, value;\n\n  \t\tcomputedStyle = prototype_getStyle__getComputedStyle(this.node);\n\n  \t\tif (typeof props === \"string\") {\n  \t\t\tvalue = computedStyle[helpers_prefix(props)];\n  \t\t\tif (value === \"0px\") {\n  \t\t\t\tvalue = 0;\n  \t\t\t}\n  \t\t\treturn value;\n  \t\t}\n\n  \t\tif (!isArray(props)) {\n  \t\t\tthrow new Error(\"Transition$getStyle must be passed a string, or an array of strings representing CSS properties\");\n  \t\t}\n\n  \t\tstyles = {};\n\n  \t\ti = props.length;\n  \t\twhile (i--) {\n  \t\t\tprop = props[i];\n  \t\t\tvalue = computedStyle[helpers_prefix(prop)];\n  \t\t\tif (value === \"0px\") {\n  \t\t\t\tvalue = 0;\n  \t\t\t}\n  \t\t\tstyles[prop] = value;\n  \t\t}\n\n  \t\treturn styles;\n  \t};\n  }\n\n  var prototype_getStyle = getStyle;\n\n  var setStyle = function (style, value) {\n  \tvar prop;\n\n  \tif (typeof style === \"string\") {\n  \t\tthis.node.style[helpers_prefix(style)] = value;\n  \t} else {\n  \t\tfor (prop in style) {\n  \t\t\tif (style.hasOwnProperty(prop)) {\n  \t\t\t\tthis.node.style[helpers_prefix(prop)] = style[prop];\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn this;\n  };\n\n  var Ticker = function (options) {\n  \tvar easing;\n\n  \tthis.duration = options.duration;\n  \tthis.step = options.step;\n  \tthis.complete = options.complete;\n\n  \t// easing\n  \tif (typeof options.easing === \"string\") {\n  \t\teasing = options.root.easing[options.easing];\n\n  \t\tif (!easing) {\n  \t\t\twarnOnceIfDebug(missingPlugin(options.easing, \"easing\"));\n  \t\t\teasing = linear;\n  \t\t}\n  \t} else if (typeof options.easing === \"function\") {\n  \t\teasing = options.easing;\n  \t} else {\n  \t\teasing = linear;\n  \t}\n\n  \tthis.easing = easing;\n\n  \tthis.start = utils_getTime();\n  \tthis.end = this.start + this.duration;\n\n  \tthis.running = true;\n  \tshared_animations.add(this);\n  };\n\n  Ticker.prototype = {\n  \ttick: function (now) {\n  \t\tvar elapsed, eased;\n\n  \t\tif (!this.running) {\n  \t\t\treturn false;\n  \t\t}\n\n  \t\tif (now > this.end) {\n  \t\t\tif (this.step) {\n  \t\t\t\tthis.step(1);\n  \t\t\t}\n\n  \t\t\tif (this.complete) {\n  \t\t\t\tthis.complete(1);\n  \t\t\t}\n\n  \t\t\treturn false;\n  \t\t}\n\n  \t\telapsed = now - this.start;\n  \t\teased = this.easing(elapsed / this.duration);\n\n  \t\tif (this.step) {\n  \t\t\tthis.step(eased);\n  \t\t}\n\n  \t\treturn true;\n  \t},\n\n  \tstop: function () {\n  \t\tif (this.abort) {\n  \t\t\tthis.abort();\n  \t\t}\n\n  \t\tthis.running = false;\n  \t}\n  };\n\n  var shared_Ticker = Ticker;\n  function linear(t) {\n  \treturn t;\n  }\n\n  var unprefixPattern = new RegExp(\"^-(?:\" + vendors.join(\"|\") + \")-\");\n\n  var unprefix = function (prop) {\n  \treturn prop.replace(unprefixPattern, \"\");\n  };\n\n  var vendorPattern = new RegExp(\"^(?:\" + vendors.join(\"|\") + \")([A-Z])\");\n\n  var hyphenate = function (str) {\n  \tvar hyphenated;\n\n  \tif (!str) {\n  \t\treturn \"\"; // edge case\n  \t}\n\n  \tif (vendorPattern.test(str)) {\n  \t\tstr = \"-\" + str;\n  \t}\n\n  \thyphenated = str.replace(/[A-Z]/g, function (match) {\n  \t\treturn \"-\" + match.toLowerCase();\n  \t});\n\n  \treturn hyphenated;\n  };\n\n  var createTransitions,\n      animateStyle_createTransitions__testStyle,\n      TRANSITION,\n      TRANSITIONEND,\n      CSS_TRANSITIONS_ENABLED,\n      TRANSITION_DURATION,\n      TRANSITION_PROPERTY,\n      TRANSITION_TIMING_FUNCTION,\n      canUseCssTransitions = {},\n      cannotUseCssTransitions = {};\n\n  if (!isClient) {\n  \tcreateTransitions = null;\n  } else {\n  \tanimateStyle_createTransitions__testStyle = createElement(\"div\").style;\n\n  \t// determine some facts about our environment\n  \t(function () {\n  \t\tif (animateStyle_createTransitions__testStyle.transition !== undefined) {\n  \t\t\tTRANSITION = \"transition\";\n  \t\t\tTRANSITIONEND = \"transitionend\";\n  \t\t\tCSS_TRANSITIONS_ENABLED = true;\n  \t\t} else if (animateStyle_createTransitions__testStyle.webkitTransition !== undefined) {\n  \t\t\tTRANSITION = \"webkitTransition\";\n  \t\t\tTRANSITIONEND = \"webkitTransitionEnd\";\n  \t\t\tCSS_TRANSITIONS_ENABLED = true;\n  \t\t} else {\n  \t\t\tCSS_TRANSITIONS_ENABLED = false;\n  \t\t}\n  \t})();\n\n  \tif (TRANSITION) {\n  \t\tTRANSITION_DURATION = TRANSITION + \"Duration\";\n  \t\tTRANSITION_PROPERTY = TRANSITION + \"Property\";\n  \t\tTRANSITION_TIMING_FUNCTION = TRANSITION + \"TimingFunction\";\n  \t}\n\n  \tcreateTransitions = function (t, to, options, changedProperties, resolve) {\n\n  \t\t// Wait a beat (otherwise the target styles will be applied immediately)\n  \t\t// TODO use a fastdom-style mechanism?\n  \t\tsetTimeout(function () {\n\n  \t\t\tvar hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;\n\n  \t\t\tcheckComplete = function () {\n  \t\t\t\tif (jsTransitionsComplete && cssTransitionsComplete) {\n  \t\t\t\t\t// will changes to events and fire have an unexpected consequence here?\n  \t\t\t\t\tt.root.fire(t.name + \":end\", t.node, t.isIntro);\n  \t\t\t\t\tresolve();\n  \t\t\t\t}\n  \t\t\t};\n\n  \t\t\t// this is used to keep track of which elements can use CSS to animate\n  \t\t\t// which properties\n  \t\t\thashPrefix = (t.node.namespaceURI || \"\") + t.node.tagName;\n\n  \t\t\tt.node.style[TRANSITION_PROPERTY] = changedProperties.map(helpers_prefix).map(hyphenate).join(\",\");\n  \t\t\tt.node.style[TRANSITION_TIMING_FUNCTION] = hyphenate(options.easing || \"linear\");\n  \t\t\tt.node.style[TRANSITION_DURATION] = options.duration / 1000 + \"s\";\n\n  \t\t\ttransitionEndHandler = function (event) {\n  \t\t\t\tvar index;\n\n  \t\t\t\tindex = changedProperties.indexOf(camelCase(unprefix(event.propertyName)));\n  \t\t\t\tif (index !== -1) {\n  \t\t\t\t\tchangedProperties.splice(index, 1);\n  \t\t\t\t}\n\n  \t\t\t\tif (changedProperties.length) {\n  \t\t\t\t\t// still transitioning...\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tt.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n  \t\t\t\tcssTransitionsComplete = true;\n  \t\t\t\tcheckComplete();\n  \t\t\t};\n\n  \t\t\tt.node.addEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n  \t\t\tsetTimeout(function () {\n  \t\t\t\tvar i = changedProperties.length,\n  \t\t\t\t    hash,\n  \t\t\t\t    originalValue,\n  \t\t\t\t    index,\n  \t\t\t\t    propertiesToTransitionInJs = [],\n  \t\t\t\t    prop,\n  \t\t\t\t    suffix;\n\n  \t\t\t\twhile (i--) {\n  \t\t\t\t\tprop = changedProperties[i];\n  \t\t\t\t\thash = hashPrefix + prop;\n\n  \t\t\t\t\tif (CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[hash]) {\n  \t\t\t\t\t\tt.node.style[helpers_prefix(prop)] = to[prop];\n\n  \t\t\t\t\t\t// If we're not sure if CSS transitions are supported for\n  \t\t\t\t\t\t// this tag/property combo, find out now\n  \t\t\t\t\t\tif (!canUseCssTransitions[hash]) {\n  \t\t\t\t\t\t\toriginalValue = t.getStyle(prop);\n\n  \t\t\t\t\t\t\t// if this property is transitionable in this browser,\n  \t\t\t\t\t\t\t// the current style will be different from the target style\n  \t\t\t\t\t\t\tcanUseCssTransitions[hash] = t.getStyle(prop) != to[prop];\n  \t\t\t\t\t\t\tcannotUseCssTransitions[hash] = !canUseCssTransitions[hash];\n\n  \t\t\t\t\t\t\t// Reset, if we're going to use timers after all\n  \t\t\t\t\t\t\tif (cannotUseCssTransitions[hash]) {\n  \t\t\t\t\t\t\t\tt.node.style[helpers_prefix(prop)] = originalValue;\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n\n  \t\t\t\t\tif (!CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[hash]) {\n  \t\t\t\t\t\t// we need to fall back to timer-based stuff\n  \t\t\t\t\t\tif (originalValue === undefined) {\n  \t\t\t\t\t\t\toriginalValue = t.getStyle(prop);\n  \t\t\t\t\t\t}\n\n  \t\t\t\t\t\t// need to remove this from changedProperties, otherwise transitionEndHandler\n  \t\t\t\t\t\t// will get confused\n  \t\t\t\t\t\tindex = changedProperties.indexOf(prop);\n  \t\t\t\t\t\tif (index === -1) {\n  \t\t\t\t\t\t\twarnIfDebug(\"Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!\", { node: t.node });\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\tchangedProperties.splice(index, 1);\n  \t\t\t\t\t\t}\n\n  \t\t\t\t\t\t// TODO Determine whether this property is animatable at all\n\n  \t\t\t\t\t\tsuffix = /[^\\d]*$/.exec(to[prop])[0];\n\n  \t\t\t\t\t\t// ...then kick off a timer-based transition\n  \t\t\t\t\t\tpropertiesToTransitionInJs.push({\n  \t\t\t\t\t\t\tname: helpers_prefix(prop),\n  \t\t\t\t\t\t\tinterpolator: shared_interpolate(parseFloat(originalValue), parseFloat(to[prop])),\n  \t\t\t\t\t\t\tsuffix: suffix\n  \t\t\t\t\t\t});\n  \t\t\t\t\t}\n  \t\t\t\t}\n\n  \t\t\t\t// javascript transitions\n  \t\t\t\tif (propertiesToTransitionInJs.length) {\n  \t\t\t\t\tnew shared_Ticker({\n  \t\t\t\t\t\troot: t.root,\n  \t\t\t\t\t\tduration: options.duration,\n  \t\t\t\t\t\teasing: camelCase(options.easing || \"\"),\n  \t\t\t\t\t\tstep: function (pos) {\n  \t\t\t\t\t\t\tvar prop, i;\n\n  \t\t\t\t\t\t\ti = propertiesToTransitionInJs.length;\n  \t\t\t\t\t\t\twhile (i--) {\n  \t\t\t\t\t\t\t\tprop = propertiesToTransitionInJs[i];\n  \t\t\t\t\t\t\t\tt.node.style[prop.name] = prop.interpolator(pos) + prop.suffix;\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t},\n  \t\t\t\t\t\tcomplete: function () {\n  \t\t\t\t\t\t\tjsTransitionsComplete = true;\n  \t\t\t\t\t\t\tcheckComplete();\n  \t\t\t\t\t\t}\n  \t\t\t\t\t});\n  \t\t\t\t} else {\n  \t\t\t\t\tjsTransitionsComplete = true;\n  \t\t\t\t}\n\n  \t\t\t\tif (!changedProperties.length) {\n  \t\t\t\t\t// We need to cancel the transitionEndHandler, and deal with\n  \t\t\t\t\t// the fact that it will never fire\n  \t\t\t\t\tt.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n  \t\t\t\t\tcssTransitionsComplete = true;\n  \t\t\t\t\tcheckComplete();\n  \t\t\t\t}\n  \t\t\t}, 0);\n  \t\t}, options.delay || 0);\n  \t};\n  }\n\n  var animateStyle_createTransitions = createTransitions;\n\n  var hidden, vendor, animateStyle_visibility__prefix, animateStyle_visibility__i, visibility;\n\n  if (typeof document !== \"undefined\") {\n  \thidden = \"hidden\";\n\n  \tvisibility = {};\n\n  \tif (hidden in document) {\n  \t\tanimateStyle_visibility__prefix = \"\";\n  \t} else {\n  \t\tanimateStyle_visibility__i = vendors.length;\n  \t\twhile (animateStyle_visibility__i--) {\n  \t\t\tvendor = vendors[animateStyle_visibility__i];\n  \t\t\thidden = vendor + \"Hidden\";\n\n  \t\t\tif (hidden in document) {\n  \t\t\t\tanimateStyle_visibility__prefix = vendor;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tif (animateStyle_visibility__prefix !== undefined) {\n  \t\tdocument.addEventListener(animateStyle_visibility__prefix + \"visibilitychange\", onChange);\n\n  \t\t// initialise\n  \t\tonChange();\n  \t} else {\n  \t\t// gah, we're in an old browser\n  \t\tif (\"onfocusout\" in document) {\n  \t\t\tdocument.addEventListener(\"focusout\", onHide);\n  \t\t\tdocument.addEventListener(\"focusin\", onShow);\n  \t\t} else {\n  \t\t\twindow.addEventListener(\"pagehide\", onHide);\n  \t\t\twindow.addEventListener(\"blur\", onHide);\n\n  \t\t\twindow.addEventListener(\"pageshow\", onShow);\n  \t\t\twindow.addEventListener(\"focus\", onShow);\n  \t\t}\n\n  \t\tvisibility.hidden = false; // until proven otherwise. Not ideal but hey\n  \t}\n  }\n\n  function onChange() {\n  \tvisibility.hidden = document[hidden];\n  }\n\n  function onHide() {\n  \tvisibility.hidden = true;\n  }\n\n  function onShow() {\n  \tvisibility.hidden = false;\n  }\n\n  var animateStyle_visibility = visibility;\n\n  var animateStyle, _animateStyle__getComputedStyle, resolved;\n\n  if (!isClient) {\n  \tanimateStyle = null;\n  } else {\n  \t_animateStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n  \tanimateStyle = function (style, value, options) {\n  \t\tvar _this = this;\n\n  \t\tvar to;\n\n  \t\tif (arguments.length === 4) {\n  \t\t\tthrow new Error(\"t.animateStyle() returns a promise - use .then() instead of passing a callback\");\n  \t\t}\n\n  \t\t// Special case - page isn't visible. Don't animate anything, because\n  \t\t// that way you'll never get CSS transitionend events\n  \t\tif (animateStyle_visibility.hidden) {\n  \t\t\tthis.setStyle(style, value);\n  \t\t\treturn resolved || (resolved = utils_Promise.resolve());\n  \t\t}\n\n  \t\tif (typeof style === \"string\") {\n  \t\t\tto = {};\n  \t\t\tto[style] = value;\n  \t\t} else {\n  \t\t\tto = style;\n\n  \t\t\t// shuffle arguments\n  \t\t\toptions = value;\n  \t\t}\n\n  \t\t// As of 0.3.9, transition authors should supply an `option` object with\n  \t\t// `duration` and `easing` properties (and optional `delay`), plus a\n  \t\t// callback function that gets called after the animation completes\n\n  \t\t// TODO remove this check in a future version\n  \t\tif (!options) {\n  \t\t\twarnOnceIfDebug(\"The \\\"%s\\\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340\", this.name);\n  \t\t\toptions = this;\n  \t\t}\n\n  \t\tvar promise = new utils_Promise(function (resolve) {\n  \t\t\tvar propertyNames, changedProperties, computedStyle, current, from, i, prop;\n\n  \t\t\t// Edge case - if duration is zero, set style synchronously and complete\n  \t\t\tif (!options.duration) {\n  \t\t\t\t_this.setStyle(to);\n  \t\t\t\tresolve();\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\t// Get a list of the properties we're animating\n  \t\t\tpropertyNames = Object.keys(to);\n  \t\t\tchangedProperties = [];\n\n  \t\t\t// Store the current styles\n  \t\t\tcomputedStyle = _animateStyle__getComputedStyle(_this.node);\n\n  \t\t\tfrom = {};\n  \t\t\ti = propertyNames.length;\n  \t\t\twhile (i--) {\n  \t\t\t\tprop = propertyNames[i];\n  \t\t\t\tcurrent = computedStyle[helpers_prefix(prop)];\n\n  \t\t\t\tif (current === \"0px\") {\n  \t\t\t\t\tcurrent = 0;\n  \t\t\t\t}\n\n  \t\t\t\t// we need to know if we're actually changing anything\n  \t\t\t\tif (current != to[prop]) {\n  \t\t\t\t\t// use != instead of !==, so we can compare strings with numbers\n  \t\t\t\t\tchangedProperties.push(prop);\n\n  \t\t\t\t\t// make the computed style explicit, so we can animate where\n  \t\t\t\t\t// e.g. height='auto'\n  \t\t\t\t\t_this.node.style[helpers_prefix(prop)] = current;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\t// If we're not actually changing anything, the transitionend event\n  \t\t\t// will never fire! So we complete early\n  \t\t\tif (!changedProperties.length) {\n  \t\t\t\tresolve();\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tanimateStyle_createTransitions(_this, to, options, changedProperties, resolve);\n  \t\t});\n\n  \t\treturn promise;\n  \t};\n  }\n\n  var _animateStyle = animateStyle;\n\n  var processParams = function (params, defaults) {\n  \tif (typeof params === \"number\") {\n  \t\tparams = { duration: params };\n  \t} else if (typeof params === \"string\") {\n  \t\tif (params === \"slow\") {\n  \t\t\tparams = { duration: 600 };\n  \t\t} else if (params === \"fast\") {\n  \t\t\tparams = { duration: 200 };\n  \t\t} else {\n  \t\t\tparams = { duration: 400 };\n  \t\t}\n  \t} else if (!params) {\n  \t\tparams = {};\n  \t}\n\n  \treturn fillGaps({}, params, defaults);\n  };\n\n  var prototype_start = Transition$start;\n\n  function Transition$start() {\n  \tvar _this = this;\n\n  \tvar node, originalStyle, completed;\n\n  \tnode = this.node = this.element.node;\n  \toriginalStyle = node.getAttribute(\"style\");\n\n  \t// create t.complete() - we don't want this on the prototype,\n  \t// because we don't want `this` silliness when passing it as\n  \t// an argument\n  \tthis.complete = function (noReset) {\n  \t\tif (completed) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (!noReset && _this.isIntro) {\n  \t\t\tresetStyle(node, originalStyle);\n  \t\t}\n\n  \t\tnode._ractive.transition = null;\n  \t\t_this._manager.remove(_this);\n\n  \t\tcompleted = true;\n  \t};\n\n  \t// If the transition function doesn't exist, abort\n  \tif (!this._fn) {\n  \t\tthis.complete();\n  \t\treturn;\n  \t}\n\n  \tthis._fn.apply(this.root, [this].concat(this.params));\n  }\n\n  function resetStyle(node, style) {\n  \tif (style) {\n  \t\tnode.setAttribute(\"style\", style);\n  \t} else {\n\n  \t\t// Next line is necessary, to remove empty style attribute!\n  \t\t// See http://stackoverflow.com/a/7167553\n  \t\tnode.getAttribute(\"style\");\n  \t\tnode.removeAttribute(\"style\");\n  \t}\n  }\n\n  var Transition = function (owner, template, isIntro) {\n  \tthis.init(owner, template, isIntro);\n  };\n\n  Transition.prototype = {\n  \tinit: Transition_prototype_init,\n  \tstart: prototype_start,\n  \tgetStyle: prototype_getStyle,\n  \tsetStyle: setStyle,\n  \tanimateStyle: _animateStyle,\n  \tprocessParams: processParams\n  };\n\n  var _Transition = Transition;\n\n  var Element_prototype_render = Element$render;\n\n  var updateCss, updateScript;\n\n  updateCss = function () {\n  \tvar node = this.node,\n  \t    content = this.fragment.toString(false);\n\n  \t// IE8 has no styleSheet unless there's a type text/css\n  \tif (window && window.appearsToBeIELessEqual8) {\n  \t\tnode.type = \"text/css\";\n  \t}\n\n  \tif (node.styleSheet) {\n  \t\tnode.styleSheet.cssText = content;\n  \t} else {\n\n  \t\twhile (node.hasChildNodes()) {\n  \t\t\tnode.removeChild(node.firstChild);\n  \t\t}\n\n  \t\tnode.appendChild(document.createTextNode(content));\n  \t}\n  };\n\n  updateScript = function () {\n  \tif (!this.node.type || this.node.type === \"text/javascript\") {\n  \t\twarnIfDebug(\"Script tag was updated. This does not cause the code to be re-evaluated!\", { ractive: this.root });\n  \t\t// As it happens, we ARE in a position to re-evaluate the code if we wanted\n  \t\t// to - we could eval() it, or insert it into a fresh (temporary) script tag.\n  \t\t// But this would be a terrible idea with unpredictable results, so let's not.\n  \t}\n\n  \tthis.node.text = this.fragment.toString(false);\n  };\n  function Element$render() {\n  \tvar _this = this;\n\n  \tvar root = this.root,\n  \t    namespace,\n  \t    node,\n  \t    transition;\n\n  \tnamespace = getNamespace(this);\n  \tnode = this.node = createElement(this.name, namespace);\n\n  \t// Is this a top-level node of a component? If so, we may need to add\n  \t// a data-ractive-css attribute, for CSS encapsulation\n  \tif (this.parentFragment.cssIds) {\n  \t\tthis.node.setAttribute(\"data-ractive-css\", this.parentFragment.cssIds.map(function (x) {\n  \t\t\treturn \"{\" + x + \"}\";\n  \t\t}).join(\" \"));\n  \t}\n\n  \t// Add _ractive property to the node - we use this object to store stuff\n  \t// related to proxy events, two-way bindings etc\n  \tdefineProperty(this.node, \"_ractive\", {\n  \t\tvalue: {\n  \t\t\tproxy: this,\n  \t\t\tkeypath: getInnerContext(this.parentFragment),\n  \t\t\tevents: create(null),\n  \t\t\troot: root\n  \t\t}\n  \t});\n\n  \t// Render attributes\n  \tthis.attributes.forEach(function (a) {\n  \t\treturn a.render(node);\n  \t});\n  \tthis.conditionalAttributes.forEach(function (a) {\n  \t\treturn a.render(node);\n  \t});\n\n  \t// Render children\n  \tif (this.fragment) {\n  \t\t// Special case - <script> element\n  \t\tif (this.name === \"script\") {\n  \t\t\tthis.bubble = updateScript;\n  \t\t\tthis.node.text = this.fragment.toString(false); // bypass warning initially\n  \t\t\tthis.fragment.unrender = noop; // TODO this is a kludge\n  \t\t}\n\n  \t\t// Special case - <style> element\n  \t\telse if (this.name === \"style\") {\n  \t\t\tthis.bubble = updateCss;\n  \t\t\tthis.bubble();\n  \t\t\tthis.fragment.unrender = noop;\n  \t\t}\n\n  \t\t// Special case - contenteditable\n  \t\telse if (this.binding && this.getAttribute(\"contenteditable\")) {\n  \t\t\tthis.fragment.unrender = noop;\n  \t\t} else {\n  \t\t\tthis.node.appendChild(this.fragment.render());\n  \t\t}\n  \t}\n\n  \t// deal with two-way bindings\n  \tif (this.binding) {\n  \t\tthis.binding.render();\n  \t\tthis.node._ractive.binding = this.binding;\n  \t}\n\n  \t// Add proxy event handlers\n  \tif (this.eventHandlers) {\n  \t\tthis.eventHandlers.forEach(function (h) {\n  \t\t\treturn h.render();\n  \t\t});\n  \t}\n\n  \tif (this.name === \"option\") {\n  \t\tprocessOption(this);\n  \t}\n\n  \t// Special cases\n  \tif (this.name === \"img\") {\n  \t\t// if this is an <img>, and we're in a crap browser, we may\n  \t\t// need to prevent it from overriding width and height when\n  \t\t// it loads the src\n  \t\tspecial_img__render(this);\n  \t} else if (this.name === \"form\") {\n  \t\t// forms need to keep track of their bindings, in case of reset\n  \t\tform__render(this);\n  \t} else if (this.name === \"input\" || this.name === \"textarea\") {\n  \t\t// inputs and textareas should store their initial value as\n  \t\t// `defaultValue` in case of reset\n  \t\tthis.node.defaultValue = this.node.value;\n  \t} else if (this.name === \"option\") {\n  \t\t// similarly for option nodes\n  \t\tthis.node.defaultSelected = this.node.selected;\n  \t}\n\n  \t// apply decorator(s)\n  \tif (this.decorator && this.decorator.fn) {\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\tif (!_this.decorator.torndown) {\n  \t\t\t\t_this.decorator.init();\n  \t\t\t}\n  \t\t}, true);\n  \t}\n\n  \t// trigger intro transition\n  \tif (root.transitionsEnabled && this.intro) {\n  \t\ttransition = new _Transition(this, this.intro, true);\n  \t\tglobal_runloop.registerTransition(transition);\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\treturn transition.start();\n  \t\t}, true);\n\n  \t\tthis.transition = transition;\n  \t}\n\n  \tif (this.node.autofocus) {\n  \t\t// Special case. Some browsers (*cough* Firefix *cough*) have a problem\n  \t\t// with dynamically-generated elements having autofocus, and they won't\n  \t\t// allow you to programmatically focus the element until it's in the DOM\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\treturn _this.node.focus();\n  \t\t}, true);\n  \t}\n\n  \tupdateLiveQueries(this);\n  \treturn this.node;\n  }\n\n  function getNamespace(element) {\n  \tvar namespace, xmlns, parent;\n\n  \t// Use specified namespace...\n  \tif (xmlns = element.getAttribute(\"xmlns\")) {\n  \t\tnamespace = xmlns;\n  \t}\n\n  \t// ...or SVG namespace, if this is an <svg> element\n  \telse if (element.name === \"svg\") {\n  \t\tnamespace = namespaces.svg;\n  \t} else if (parent = element.parent) {\n  \t\t// ...or HTML, if the parent is a <foreignObject>\n  \t\tif (parent.name === \"foreignObject\") {\n  \t\t\tnamespace = namespaces.html;\n  \t\t}\n\n  \t\t// ...or inherit from the parent node\n  \t\telse {\n  \t\t\tnamespace = parent.node.namespaceURI;\n  \t\t}\n  \t} else {\n  \t\tnamespace = element.root.el.namespaceURI;\n  \t}\n\n  \treturn namespace;\n  }\n\n  function processOption(option) {\n  \tvar optionValue, selectValue, i;\n\n  \tif (!option.select) {\n  \t\treturn;\n  \t}\n\n  \tselectValue = option.select.getAttribute(\"value\");\n  \tif (selectValue === undefined) {\n  \t\treturn;\n  \t}\n\n  \toptionValue = option.getAttribute(\"value\");\n\n  \tif (option.select.node.multiple && isArray(selectValue)) {\n  \t\ti = selectValue.length;\n  \t\twhile (i--) {\n  \t\t\tif (optionValue == selectValue[i]) {\n  \t\t\t\toption.node.selected = true;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t} else {\n  \t\toption.node.selected = optionValue == selectValue;\n  \t}\n  }\n\n  function updateLiveQueries(element) {\n  \tvar instance, liveQueries, i, selector, query;\n\n  \t// Does this need to be added to any live queries?\n  \tinstance = element.root;\n\n  \tdo {\n  \t\tliveQueries = instance._liveQueries;\n\n  \t\ti = liveQueries.length;\n  \t\twhile (i--) {\n  \t\t\tselector = liveQueries[i];\n  \t\t\tquery = liveQueries[\"_\" + selector];\n\n  \t\t\tif (query._test(element)) {\n  \t\t\t\t// keep register of applicable selectors, for when we teardown\n  \t\t\t\t(element.liveQueries || (element.liveQueries = [])).push(query);\n  \t\t\t}\n  \t\t}\n  \t} while (instance = instance.parent);\n  }\n\n  var Element_prototype_toString = function () {\n  \tvar str, escape;\n\n  \tif (this.template.y) {\n  \t\t// DOCTYPE declaration\n  \t\treturn \"<!DOCTYPE\" + this.template.dd + \">\";\n  \t}\n\n  \tstr = \"<\" + this.template.e;\n\n  \tstr += this.attributes.map(stringifyAttribute).join(\"\") + this.conditionalAttributes.map(stringifyAttribute).join(\"\");\n\n  \t// Special case - selected options\n  \tif (this.name === \"option\" && optionIsSelected(this)) {\n  \t\tstr += \" selected\";\n  \t}\n\n  \t// Special case - two-way radio name bindings\n  \tif (this.name === \"input\" && inputIsCheckedRadio(this)) {\n  \t\tstr += \" checked\";\n  \t}\n\n  \tstr += \">\";\n\n  \t// Special case - textarea\n  \tif (this.name === \"textarea\" && this.getAttribute(\"value\") !== undefined) {\n  \t\tstr += escapeHtml(this.getAttribute(\"value\"));\n  \t}\n\n  \t// Special case - contenteditable\n  \telse if (this.getAttribute(\"contenteditable\") !== undefined) {\n  \t\tstr += this.getAttribute(\"value\") || \"\";\n  \t}\n\n  \tif (this.fragment) {\n  \t\tescape = this.name !== \"script\" && this.name !== \"style\";\n  \t\tstr += this.fragment.toString(escape);\n  \t}\n\n  \t// add a closing tag if this isn't a void element\n  \tif (!voidElementNames.test(this.template.e)) {\n  \t\tstr += \"</\" + this.template.e + \">\";\n  \t}\n\n  \treturn str;\n  };\n\n  function optionIsSelected(element) {\n  \tvar optionValue, selectValue, i;\n\n  \toptionValue = element.getAttribute(\"value\");\n\n  \tif (optionValue === undefined || !element.select) {\n  \t\treturn false;\n  \t}\n\n  \tselectValue = element.select.getAttribute(\"value\");\n\n  \tif (selectValue == optionValue) {\n  \t\treturn true;\n  \t}\n\n  \tif (element.select.getAttribute(\"multiple\") && isArray(selectValue)) {\n  \t\ti = selectValue.length;\n  \t\twhile (i--) {\n  \t\t\tif (selectValue[i] == optionValue) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  function inputIsCheckedRadio(element) {\n  \tvar attributes, typeAttribute, valueAttribute, nameAttribute;\n\n  \tattributes = element.attributes;\n\n  \ttypeAttribute = attributes.type;\n  \tvalueAttribute = attributes.value;\n  \tnameAttribute = attributes.name;\n\n  \tif (!typeAttribute || typeAttribute.value !== \"radio\" || !valueAttribute || !nameAttribute.interpolator) {\n  \t\treturn;\n  \t}\n\n  \tif (valueAttribute.value === nameAttribute.interpolator.value) {\n  \t\treturn true;\n  \t}\n  }\n\n  function stringifyAttribute(attribute) {\n  \tvar str = attribute.toString();\n  \treturn str ? \" \" + str : \"\";\n  }\n\n  var Element_prototype_unbind = Element$unbind;\n  function Element$unbind() {\n  \tif (this.fragment) {\n  \t\tthis.fragment.unbind();\n  \t}\n\n  \tif (this.binding) {\n  \t\tthis.binding.unbind();\n  \t}\n\n  \tif (this.eventHandlers) {\n  \t\tthis.eventHandlers.forEach(methodCallers__unbind);\n  \t}\n\n  \t// Special case - <option>\n  \tif (this.name === \"option\") {\n  \t\tspecial_option__unbind(this);\n  \t}\n\n  \tthis.attributes.forEach(methodCallers__unbind);\n  \tthis.conditionalAttributes.forEach(methodCallers__unbind);\n  }\n\n  var Element_prototype_unrender = Element$unrender;\n\n  function Element$unrender(shouldDestroy) {\n  \tvar binding, bindings, transition;\n\n  \tif (transition = this.transition) {\n  \t\ttransition.complete();\n  \t}\n\n  \t// Detach as soon as we can\n  \tif (this.name === \"option\") {\n  \t\t// <option> elements detach immediately, so that\n  \t\t// their parent <select> element syncs correctly, and\n  \t\t// since option elements can't have transitions anyway\n  \t\tthis.detach();\n  \t} else if (shouldDestroy) {\n  \t\tglobal_runloop.detachWhenReady(this);\n  \t}\n\n  \t// Children first. that way, any transitions on child elements will be\n  \t// handled by the current transitionManager\n  \tif (this.fragment) {\n  \t\tthis.fragment.unrender(false);\n  \t}\n\n  \tif (binding = this.binding) {\n  \t\tthis.binding.unrender();\n\n  \t\tthis.node._ractive.binding = null;\n  \t\tbindings = this.root._twowayBindings[binding.keypath.str];\n  \t\tbindings.splice(bindings.indexOf(binding), 1);\n  \t}\n\n  \t// Remove event handlers\n  \tif (this.eventHandlers) {\n  \t\tthis.eventHandlers.forEach(methodCallers__unrender);\n  \t}\n\n  \tif (this.decorator) {\n  \t\tglobal_runloop.registerDecorator(this.decorator);\n  \t}\n\n  \t// trigger outro transition if necessary\n  \tif (this.root.transitionsEnabled && this.outro) {\n  \t\ttransition = new _Transition(this, this.outro, false);\n  \t\tglobal_runloop.registerTransition(transition);\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\treturn transition.start();\n  \t\t});\n  \t}\n\n  \t// Remove this node from any live queries\n  \tif (this.liveQueries) {\n  \t\tremoveFromLiveQueries(this);\n  \t}\n\n  \tif (this.name === \"form\") {\n  \t\tform__unrender(this);\n  \t}\n  }\n\n  function removeFromLiveQueries(element) {\n  \tvar query, selector, i;\n\n  \ti = element.liveQueries.length;\n  \twhile (i--) {\n  \t\tquery = element.liveQueries[i];\n  \t\tselector = query.selector;\n\n  \t\tquery._remove(element.node);\n  \t}\n  }\n\n  var Element = function (options) {\n  \tthis.init(options);\n  };\n\n  Element.prototype = {\n  \tbubble: Element_prototype_bubble,\n  \tdetach: Element_prototype_detach,\n  \tfind: Element_prototype_find,\n  \tfindAll: Element_prototype_findAll,\n  \tfindAllComponents: Element_prototype_findAllComponents,\n  \tfindComponent: Element_prototype_findComponent,\n  \tfindNextNode: Element_prototype_findNextNode,\n  \tfirstNode: Element_prototype_firstNode,\n  \tgetAttribute: getAttribute,\n  \tinit: Element_prototype_init,\n  \trebind: Element_prototype_rebind,\n  \trender: Element_prototype_render,\n  \ttoString: Element_prototype_toString,\n  \tunbind: Element_prototype_unbind,\n  \tunrender: Element_prototype_unrender\n  };\n\n  var _Element = Element;\n\n  var deIndent__empty = /^\\s*$/,\n      deIndent__leadingWhitespace = /^\\s*/;\n\n  var deIndent = function (str) {\n  \tvar lines, firstLine, lastLine, minIndent;\n\n  \tlines = str.split(\"\\n\");\n\n  \t// remove first and last line, if they only contain whitespace\n  \tfirstLine = lines[0];\n  \tif (firstLine !== undefined && deIndent__empty.test(firstLine)) {\n  \t\tlines.shift();\n  \t}\n\n  \tlastLine = lastItem(lines);\n  \tif (lastLine !== undefined && deIndent__empty.test(lastLine)) {\n  \t\tlines.pop();\n  \t}\n\n  \tminIndent = lines.reduce(reducer, null);\n\n  \tif (minIndent) {\n  \t\tstr = lines.map(function (line) {\n  \t\t\treturn line.replace(minIndent, \"\");\n  \t\t}).join(\"\\n\");\n  \t}\n\n  \treturn str;\n  };\n\n  function reducer(previous, line) {\n  \tvar lineIndent = deIndent__leadingWhitespace.exec(line)[0];\n\n  \tif (previous === null || lineIndent.length < previous.length) {\n  \t\treturn lineIndent;\n  \t}\n\n  \treturn previous;\n  }\n\n  var Partial_getPartialTemplate = getPartialTemplate;\n\n  function getPartialTemplate(ractive, name, parentFragment) {\n  \tvar partial;\n\n  \t// If the partial in instance or view heirarchy instances, great\n  \tif (partial = getPartialFromRegistry(ractive, name, parentFragment || {})) {\n  \t\treturn partial;\n  \t}\n\n  \t// Does it exist on the page as a script tag?\n  \tpartial = template_parser.fromId(name, { noThrow: true });\n\n  \tif (partial) {\n  \t\t// is this necessary?\n  \t\tpartial = deIndent(partial);\n\n  \t\t// parse and register to this ractive instance\n  \t\tvar parsed = template_parser.parse(partial, template_parser.getParseOptions(ractive));\n\n  \t\t// register (and return main partial if there are others in the template)\n  \t\treturn ractive.partials[name] = parsed.t;\n  \t}\n  }\n\n  function getPartialFromRegistry(ractive, name, parentFragment) {\n  \tvar fn = undefined,\n  \t    partial = findParentPartial(name, parentFragment.owner);\n\n  \t// if there was an instance up-hierarchy, cool\n  \tif (partial) return partial;\n\n  \t// find first instance in the ractive or view hierarchy that has this partial\n  \tvar instance = findInstance(\"partials\", ractive, name);\n\n  \tif (!instance) {\n  \t\treturn;\n  \t}\n\n  \tpartial = instance.partials[name];\n\n  \t// partial is a function?\n  \tif (typeof partial === \"function\") {\n  \t\tfn = partial.bind(instance);\n  \t\tfn.isOwner = instance.partials.hasOwnProperty(name);\n  \t\tpartial = fn.call(ractive, template_parser);\n  \t}\n\n  \tif (!partial && partial !== \"\") {\n  \t\twarnIfDebug(noRegistryFunctionReturn, name, \"partial\", \"partial\", { ractive: ractive });\n  \t\treturn;\n  \t}\n\n  \t// If this was added manually to the registry,\n  \t// but hasn't been parsed, parse it now\n  \tif (!template_parser.isParsed(partial)) {\n\n  \t\t// use the parseOptions of the ractive instance on which it was found\n  \t\tvar parsed = template_parser.parse(partial, template_parser.getParseOptions(instance));\n\n  \t\t// Partials cannot contain nested partials!\n  \t\t// TODO add a test for this\n  \t\tif (parsed.p) {\n  \t\t\twarnIfDebug(\"Partials ({{>%s}}) cannot contain nested inline partials\", name, { ractive: ractive });\n  \t\t}\n\n  \t\t// if fn, use instance to store result, otherwise needs to go\n  \t\t// in the correct point in prototype chain on instance or constructor\n  \t\tvar target = fn ? instance : findOwner(instance, name);\n\n  \t\t// may be a template with partials, which need to be registered and main template extracted\n  \t\ttarget.partials[name] = partial = parsed.t;\n  \t}\n\n  \t// store for reset\n  \tif (fn) {\n  \t\tpartial._fn = fn;\n  \t}\n\n  \treturn partial.v ? partial.t : partial;\n  }\n\n  function findOwner(ractive, key) {\n  \treturn ractive.partials.hasOwnProperty(key) ? ractive : findConstructor(ractive.constructor, key);\n  }\n\n  function findConstructor(constructor, key) {\n  \tif (!constructor) {\n  \t\treturn;\n  \t}\n  \treturn constructor.partials.hasOwnProperty(key) ? constructor : findConstructor(constructor._Parent, key);\n  }\n\n  function findParentPartial(name, parent) {\n  \tif (parent) {\n  \t\tif (parent.template && parent.template.p && parent.template.p[name]) {\n  \t\t\treturn parent.template.p[name];\n  \t\t} else if (parent.parentFragment && parent.parentFragment.owner) {\n  \t\t\treturn findParentPartial(name, parent.parentFragment.owner);\n  \t\t}\n  \t}\n  }\n\n  var applyIndent = function (string, indent) {\n  \tvar indented;\n\n  \tif (!indent) {\n  \t\treturn string;\n  \t}\n\n  \tindented = string.split(\"\\n\").map(function (line, notFirstLine) {\n  \t\treturn notFirstLine ? indent + line : line;\n  \t}).join(\"\\n\");\n\n  \treturn indented;\n  };\n\n  var missingPartialMessage = \"Could not find template for partial \\\"%s\\\"\";\n\n  var Partial = function (options) {\n  \tvar parentFragment, template;\n\n  \tparentFragment = this.parentFragment = options.parentFragment;\n\n  \tthis.root = parentFragment.root;\n  \tthis.type = PARTIAL;\n  \tthis.index = options.index;\n  \tthis.name = options.template.r;\n  \tthis.rendered = false;\n\n  \tthis.fragment = this.fragmentToRender = this.fragmentToUnrender = null;\n\n  \tMustache.init(this, options);\n\n  \t// If this didn't resolve, it most likely means we have a named partial\n  \t// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial\n  \t// whose name is the value of `foo`')\n  \tif (!this.keypath) {\n  \t\tif (template = Partial_getPartialTemplate(this.root, this.name, parentFragment)) {\n  \t\t\tshared_unbind.call(this); // prevent any further changes\n  \t\t\tthis.isNamed = true;\n  \t\t\tthis.setTemplate(template);\n  \t\t} else {\n  \t\t\twarnOnceIfDebug(missingPartialMessage, this.name);\n  \t\t}\n  \t}\n  };\n\n  Partial.prototype = {\n  \tbubble: function () {\n  \t\tthis.parentFragment.bubble();\n  \t},\n\n  \tdetach: function () {\n  \t\treturn this.fragment.detach();\n  \t},\n\n  \tfind: function (selector) {\n  \t\treturn this.fragment.find(selector);\n  \t},\n\n  \tfindAll: function (selector, query) {\n  \t\treturn this.fragment.findAll(selector, query);\n  \t},\n\n  \tfindComponent: function (selector) {\n  \t\treturn this.fragment.findComponent(selector);\n  \t},\n\n  \tfindAllComponents: function (selector, query) {\n  \t\treturn this.fragment.findAllComponents(selector, query);\n  \t},\n\n  \tfirstNode: function () {\n  \t\treturn this.fragment.firstNode();\n  \t},\n\n  \tfindNextNode: function () {\n  \t\treturn this.parentFragment.findNextNode(this);\n  \t},\n\n  \tgetPartialName: function () {\n  \t\tif (this.isNamed && this.name) return this.name;else if (this.value === undefined) return this.name;else return this.value;\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.fragment.getValue();\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\t// named partials aren't bound, so don't rebind\n  \t\tif (!this.isNamed) {\n  \t\t\tMustache_rebind.call(this, oldKeypath, newKeypath);\n  \t\t}\n\n  \t\tif (this.fragment) {\n  \t\t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t\t}\n  \t},\n\n  \trender: function () {\n  \t\tthis.docFrag = document.createDocumentFragment();\n  \t\tthis.update();\n\n  \t\tthis.rendered = true;\n  \t\treturn this.docFrag;\n  \t},\n\n  \tresolve: Mustache.resolve,\n\n  \tsetValue: function (value) {\n  \t\tvar template;\n\n  \t\tif (value !== undefined && value === this.value) {\n  \t\t\t// nothing has changed, so no work to be done\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (value !== undefined) {\n  \t\t\ttemplate = Partial_getPartialTemplate(this.root, \"\" + value, this.parentFragment);\n  \t\t}\n\n  \t\t// we may be here if we have a partial like `{{>foo}}` and `foo` is the\n  \t\t// name of both a data property (whose value ISN'T the name of a partial)\n  \t\t// and a partial. In those cases, this becomes a named partial\n  \t\tif (!template && this.name && (template = Partial_getPartialTemplate(this.root, this.name, this.parentFragment))) {\n  \t\t\tshared_unbind.call(this);\n  \t\t\tthis.isNamed = true;\n  \t\t}\n\n  \t\tif (!template) {\n  \t\t\twarnOnceIfDebug(missingPartialMessage, this.name, { ractive: this.root });\n  \t\t}\n\n  \t\tthis.value = value;\n\n  \t\tthis.setTemplate(template || []);\n\n  \t\tthis.bubble();\n\n  \t\tif (this.rendered) {\n  \t\t\tglobal_runloop.addView(this);\n  \t\t}\n  \t},\n\n  \tsetTemplate: function (template) {\n  \t\tif (this.fragment) {\n  \t\t\tthis.fragment.unbind();\n  \t\t\tif (this.rendered) {\n  \t\t\t\tthis.fragmentToUnrender = this.fragment;\n  \t\t\t}\n  \t\t}\n\n  \t\tthis.fragment = new virtualdom_Fragment({\n  \t\t\ttemplate: template,\n  \t\t\troot: this.root,\n  \t\t\towner: this,\n  \t\t\tpElement: this.parentFragment.pElement\n  \t\t});\n\n  \t\tthis.fragmentToRender = this.fragment;\n  \t},\n\n  \ttoString: function (toString) {\n  \t\tvar string, previousItem, lastLine, match;\n\n  \t\tstring = this.fragment.toString(toString);\n\n  \t\tpreviousItem = this.parentFragment.items[this.index - 1];\n\n  \t\tif (!previousItem || previousItem.type !== TEXT) {\n  \t\t\treturn string;\n  \t\t}\n\n  \t\tlastLine = previousItem.text.split(\"\\n\").pop();\n\n  \t\tif (match = /^\\s+$/.exec(lastLine)) {\n  \t\t\treturn applyIndent(string, match[0]);\n  \t\t}\n\n  \t\treturn string;\n  \t},\n\n  \tunbind: function () {\n  \t\tif (!this.isNamed) {\n  \t\t\t// dynamic partial - need to unbind self\n  \t\t\tshared_unbind.call(this);\n  \t\t}\n\n  \t\tif (this.fragment) {\n  \t\t\tthis.fragment.unbind();\n  \t\t}\n  \t},\n\n  \tunrender: function (shouldDestroy) {\n  \t\tif (this.rendered) {\n  \t\t\tif (this.fragment) {\n  \t\t\t\tthis.fragment.unrender(shouldDestroy);\n  \t\t\t}\n  \t\t\tthis.rendered = false;\n  \t\t}\n  \t},\n\n  \tupdate: function () {\n  \t\tvar target, anchor;\n\n  \t\tif (this.fragmentToUnrender) {\n  \t\t\tthis.fragmentToUnrender.unrender(true);\n  \t\t\tthis.fragmentToUnrender = null;\n  \t\t}\n\n  \t\tif (this.fragmentToRender) {\n  \t\t\tthis.docFrag.appendChild(this.fragmentToRender.render());\n  \t\t\tthis.fragmentToRender = null;\n  \t\t}\n\n  \t\tif (this.rendered) {\n  \t\t\ttarget = this.parentFragment.getNode();\n  \t\t\tanchor = this.parentFragment.findNextNode(this);\n  \t\t\ttarget.insertBefore(this.docFrag, anchor);\n  \t\t}\n  \t}\n  };\n\n  var _Partial = Partial;\n\n  // finds the component constructor in the registry or view hierarchy registries\n\n  var Component_getComponent = getComponent;\n  function getComponent(ractive, name) {\n\n  \tvar Component,\n  \t    instance = findInstance(\"components\", ractive, name);\n\n  \tif (instance) {\n  \t\tComponent = instance.components[name];\n\n  \t\t// best test we have for not Ractive.extend\n  \t\tif (!Component._Parent) {\n  \t\t\t// function option, execute and store for reset\n  \t\t\tvar fn = Component.bind(instance);\n  \t\t\tfn.isOwner = instance.components.hasOwnProperty(name);\n  \t\t\tComponent = fn();\n\n  \t\t\tif (!Component) {\n  \t\t\t\twarnIfDebug(noRegistryFunctionReturn, name, \"component\", \"component\", { ractive: ractive });\n\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tif (typeof Component === \"string\") {\n  \t\t\t\t// allow string lookup\n  \t\t\t\tComponent = getComponent(ractive, Component);\n  \t\t\t}\n\n  \t\t\tComponent._fn = fn;\n  \t\t\tinstance.components[name] = Component;\n  \t\t}\n  \t}\n\n  \treturn Component;\n  }\n\n  var Component_prototype_detach = Component$detach;\n  var Component_prototype_detach__detachHook = new hooks_Hook(\"detach\");\n  function Component$detach() {\n  \tvar detached = this.instance.fragment.detach();\n  \tComponent_prototype_detach__detachHook.fire(this.instance);\n  \treturn detached;\n  }\n\n  var Component_prototype_find = Component$find;\n\n  function Component$find(selector) {\n  \treturn this.instance.fragment.find(selector);\n  }\n\n  var Component_prototype_findAll = Component$findAll;\n\n  function Component$findAll(selector, query) {\n  \treturn this.instance.fragment.findAll(selector, query);\n  }\n\n  var Component_prototype_findAllComponents = Component$findAllComponents;\n\n  function Component$findAllComponents(selector, query) {\n  \tquery._test(this, true);\n\n  \tif (this.instance.fragment) {\n  \t\tthis.instance.fragment.findAllComponents(selector, query);\n  \t}\n  }\n\n  var Component_prototype_findComponent = Component$findComponent;\n\n  function Component$findComponent(selector) {\n  \tif (!selector || selector === this.name) {\n  \t\treturn this.instance;\n  \t}\n\n  \tif (this.instance.fragment) {\n  \t\treturn this.instance.fragment.findComponent(selector);\n  \t}\n\n  \treturn null;\n  }\n\n  var Component_prototype_findNextNode = Component$findNextNode;\n\n  function Component$findNextNode() {\n  \treturn this.parentFragment.findNextNode(this);\n  }\n\n  var Component_prototype_firstNode = Component$firstNode;\n\n  function Component$firstNode() {\n  \tif (this.rendered) {\n  \t\treturn this.instance.fragment.firstNode();\n  \t}\n\n  \treturn null;\n  }\n\n  var processWrapper = function (wrapper, array, methodName, newIndices) {\n  \tvar root = wrapper.root;\n  \tvar keypath = wrapper.keypath;\n\n  \tif (!!newIndices) {\n  \t\troot.viewmodel.smartUpdate(keypath, array, newIndices);\n  \t} else {\n  \t\t// If this is a sort or reverse, we just do root.set()...\n  \t\t// TODO use merge logic?\n  \t\troot.viewmodel.mark(keypath);\n  \t}\n  };\n\n  var patchedArrayProto = [],\n      mutatorMethods = [\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"],\n      testObj,\n      patchArrayMethods,\n      unpatchArrayMethods;\n\n  mutatorMethods.forEach(function (methodName) {\n  \tvar method = function () {\n  \t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n  \t\t\targs[_key] = arguments[_key];\n  \t\t}\n\n  \t\tvar newIndices, result, wrapper, i;\n\n  \t\tnewIndices = shared_getNewIndices(this, methodName, args);\n\n  \t\t// apply the underlying method\n  \t\tresult = Array.prototype[methodName].apply(this, arguments);\n\n  \t\t// trigger changes\n  \t\tglobal_runloop.start();\n\n  \t\tthis._ractive.setting = true;\n  \t\ti = this._ractive.wrappers.length;\n  \t\twhile (i--) {\n  \t\t\twrapper = this._ractive.wrappers[i];\n\n  \t\t\tglobal_runloop.addRactive(wrapper.root);\n  \t\t\tprocessWrapper(wrapper, this, methodName, newIndices);\n  \t\t}\n\n  \t\tglobal_runloop.end();\n\n  \t\tthis._ractive.setting = false;\n  \t\treturn result;\n  \t};\n\n  \tdefineProperty(patchedArrayProto, methodName, {\n  \t\tvalue: method\n  \t});\n  });\n\n  // can we use prototype chain injection?\n  // http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\n  testObj = {};\n\n  if (testObj.__proto__) {\n  \t// yes, we can\n  \tpatchArrayMethods = function (array) {\n  \t\tarray.__proto__ = patchedArrayProto;\n  \t};\n\n  \tunpatchArrayMethods = function (array) {\n  \t\tarray.__proto__ = Array.prototype;\n  \t};\n  } else {\n  \t// no, we can't\n  \tpatchArrayMethods = function (array) {\n  \t\tvar i, methodName;\n\n  \t\ti = mutatorMethods.length;\n  \t\twhile (i--) {\n  \t\t\tmethodName = mutatorMethods[i];\n  \t\t\tdefineProperty(array, methodName, {\n  \t\t\t\tvalue: patchedArrayProto[methodName],\n  \t\t\t\tconfigurable: true\n  \t\t\t});\n  \t\t}\n  \t};\n\n  \tunpatchArrayMethods = function (array) {\n  \t\tvar i;\n\n  \t\ti = mutatorMethods.length;\n  \t\twhile (i--) {\n  \t\t\tdelete array[mutatorMethods[i]];\n  \t\t}\n  \t};\n  }\n\n  patchArrayMethods.unpatch = unpatchArrayMethods;\n  var patch = patchArrayMethods;\n\n  var arrayAdaptor,\n\n  // helpers\n  ArrayWrapper, array_index__errorMessage;\n\n  arrayAdaptor = {\n  \tfilter: function (object) {\n  \t\t// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,\n  \t\t// or the array didn't trigger the get() itself\n  \t\treturn isArray(object) && (!object._ractive || !object._ractive.setting);\n  \t},\n  \twrap: function (ractive, array, keypath) {\n  \t\treturn new ArrayWrapper(ractive, array, keypath);\n  \t}\n  };\n\n  ArrayWrapper = function (ractive, array, keypath) {\n  \tthis.root = ractive;\n  \tthis.value = array;\n  \tthis.keypath = getKeypath(keypath);\n\n  \t// if this array hasn't already been ractified, ractify it\n  \tif (!array._ractive) {\n\n  \t\t// define a non-enumerable _ractive property to store the wrappers\n  \t\tdefineProperty(array, \"_ractive\", {\n  \t\t\tvalue: {\n  \t\t\t\twrappers: [],\n  \t\t\t\tinstances: [],\n  \t\t\t\tsetting: false\n  \t\t\t},\n  \t\t\tconfigurable: true\n  \t\t});\n\n  \t\tpatch(array);\n  \t}\n\n  \t// store the ractive instance, so we can handle transitions later\n  \tif (!array._ractive.instances[ractive._guid]) {\n  \t\tarray._ractive.instances[ractive._guid] = 0;\n  \t\tarray._ractive.instances.push(ractive);\n  \t}\n\n  \tarray._ractive.instances[ractive._guid] += 1;\n  \tarray._ractive.wrappers.push(this);\n  };\n\n  ArrayWrapper.prototype = {\n  \tget: function () {\n  \t\treturn this.value;\n  \t},\n  \tteardown: function () {\n  \t\tvar array, storage, wrappers, instances, index;\n\n  \t\tarray = this.value;\n  \t\tstorage = array._ractive;\n  \t\twrappers = storage.wrappers;\n  \t\tinstances = storage.instances;\n\n  \t\t// if teardown() was invoked because we're clearing the cache as a result of\n  \t\t// a change that the array itself triggered, we can save ourselves the teardown\n  \t\t// and immediate setup\n  \t\tif (storage.setting) {\n  \t\t\treturn false; // so that we don't remove it from this.root.viewmodel.wrapped\n  \t\t}\n\n  \t\tindex = wrappers.indexOf(this);\n  \t\tif (index === -1) {\n  \t\t\tthrow new Error(array_index__errorMessage);\n  \t\t}\n\n  \t\twrappers.splice(index, 1);\n\n  \t\t// if nothing else depends on this array, we can revert it to its\n  \t\t// natural state\n  \t\tif (!wrappers.length) {\n  \t\t\tdelete array._ractive;\n  \t\t\tpatch.unpatch(this.value);\n  \t\t} else {\n  \t\t\t// remove ractive instance if possible\n  \t\t\tinstances[this.root._guid] -= 1;\n  \t\t\tif (!instances[this.root._guid]) {\n  \t\t\t\tindex = instances.indexOf(this.root);\n\n  \t\t\t\tif (index === -1) {\n  \t\t\t\t\tthrow new Error(array_index__errorMessage);\n  \t\t\t\t}\n\n  \t\t\t\tinstances.splice(index, 1);\n  \t\t\t}\n  \t\t}\n  \t}\n  };\n\n  array_index__errorMessage = \"Something went wrong in a rather interesting way\";\n  var array_index = arrayAdaptor;\n\n  var numeric = /^\\s*[0-9]+\\s*$/;\n\n  var createBranch = function (key) {\n  \treturn numeric.test(key) ? [] : {};\n  };\n\n  var magicAdaptor, MagicWrapper;\n\n  try {\n  \tObject.defineProperty({}, \"test\", { value: 0 });\n\n  \tmagicAdaptor = {\n  \t\tfilter: function (object, keypath, ractive) {\n  \t\t\tvar parentWrapper, parentValue;\n\n  \t\t\tif (!keypath) {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\tkeypath = getKeypath(keypath);\n\n  \t\t\t// If the parent value is a wrapper, other than a magic wrapper,\n  \t\t\t// we shouldn't wrap this property\n  \t\t\tif ((parentWrapper = ractive.viewmodel.wrapped[keypath.parent.str]) && !parentWrapper.magic) {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\tparentValue = ractive.viewmodel.get(keypath.parent);\n\n  \t\t\t// if parentValue is an array that doesn't include this member,\n  \t\t\t// we should return false otherwise lengths will get messed up\n  \t\t\tif (isArray(parentValue) && /^[0-9]+$/.test(keypath.lastKey)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\treturn parentValue && (typeof parentValue === \"object\" || typeof parentValue === \"function\");\n  \t\t},\n  \t\twrap: function (ractive, property, keypath) {\n  \t\t\treturn new MagicWrapper(ractive, property, keypath);\n  \t\t}\n  \t};\n\n  \tMagicWrapper = function (ractive, value, keypath) {\n  \t\tvar objKeypath, template, siblings;\n\n  \t\tkeypath = getKeypath(keypath);\n\n  \t\tthis.magic = true;\n\n  \t\tthis.ractive = ractive;\n  \t\tthis.keypath = keypath;\n  \t\tthis.value = value;\n\n  \t\tthis.prop = keypath.lastKey;\n\n  \t\tobjKeypath = keypath.parent;\n  \t\tthis.obj = objKeypath.isRoot ? ractive.viewmodel.data : ractive.viewmodel.get(objKeypath);\n\n  \t\ttemplate = this.originalDescriptor = Object.getOwnPropertyDescriptor(this.obj, this.prop);\n\n  \t\t// Has this property already been wrapped?\n  \t\tif (template && template.set && (siblings = template.set._ractiveWrappers)) {\n\n  \t\t\t// Yes. Register this wrapper to this property, if it hasn't been already\n  \t\t\tif (siblings.indexOf(this) === -1) {\n  \t\t\t\tsiblings.push(this);\n  \t\t\t}\n\n  \t\t\treturn; // already wrapped\n  \t\t}\n\n  \t\t// No, it hasn't been wrapped\n  \t\tcreateAccessors(this, value, template);\n  \t};\n\n  \tMagicWrapper.prototype = {\n  \t\tget: function () {\n  \t\t\treturn this.value;\n  \t\t},\n  \t\treset: function (value) {\n  \t\t\tif (this.updating) {\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tthis.updating = true;\n  \t\t\tthis.obj[this.prop] = value; // trigger set() accessor\n  \t\t\tglobal_runloop.addRactive(this.ractive);\n  \t\t\tthis.ractive.viewmodel.mark(this.keypath, { keepExistingWrapper: true });\n  \t\t\tthis.updating = false;\n  \t\t\treturn true;\n  \t\t},\n  \t\tset: function (key, value) {\n  \t\t\tif (this.updating) {\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tif (!this.obj[this.prop]) {\n  \t\t\t\tthis.updating = true;\n  \t\t\t\tthis.obj[this.prop] = createBranch(key);\n  \t\t\t\tthis.updating = false;\n  \t\t\t}\n\n  \t\t\tthis.obj[this.prop][key] = value;\n  \t\t},\n  \t\tteardown: function () {\n  \t\t\tvar template, set, value, wrappers, index;\n\n  \t\t\t// If this method was called because the cache was being cleared as a\n  \t\t\t// result of a set()/update() call made by this wrapper, we return false\n  \t\t\t// so that it doesn't get torn down\n  \t\t\tif (this.updating) {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\ttemplate = Object.getOwnPropertyDescriptor(this.obj, this.prop);\n  \t\t\tset = template && template.set;\n\n  \t\t\tif (!set) {\n  \t\t\t\t// most likely, this was an array member that was spliced out\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\twrappers = set._ractiveWrappers;\n\n  \t\t\tindex = wrappers.indexOf(this);\n  \t\t\tif (index !== -1) {\n  \t\t\t\twrappers.splice(index, 1);\n  \t\t\t}\n\n  \t\t\t// Last one out, turn off the lights\n  \t\t\tif (!wrappers.length) {\n  \t\t\t\tvalue = this.obj[this.prop];\n\n  \t\t\t\tObject.defineProperty(this.obj, this.prop, this.originalDescriptor || {\n  \t\t\t\t\twritable: true,\n  \t\t\t\t\tenumerable: true,\n  \t\t\t\t\tconfigurable: true\n  \t\t\t\t});\n\n  \t\t\t\tthis.obj[this.prop] = value;\n  \t\t\t}\n  \t\t}\n  \t};\n  } catch (err) {\n  \tmagicAdaptor = false; // no magic in this browser\n  }\n\n  var adaptors_magic = magicAdaptor;\n\n  function createAccessors(originalWrapper, value, template) {\n\n  \tvar object, property, oldGet, oldSet, get, set;\n\n  \tobject = originalWrapper.obj;\n  \tproperty = originalWrapper.prop;\n\n  \t// Is this template configurable?\n  \tif (template && !template.configurable) {\n  \t\t// Special case - array length\n  \t\tif (property === \"length\") {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthrow new Error(\"Cannot use magic mode with property \\\"\" + property + \"\\\" - object is not configurable\");\n  \t}\n\n  \t// Time to wrap this property\n  \tif (template) {\n  \t\toldGet = template.get;\n  \t\toldSet = template.set;\n  \t}\n\n  \tget = oldGet || function () {\n  \t\treturn value;\n  \t};\n\n  \tset = function (v) {\n  \t\tif (oldSet) {\n  \t\t\toldSet(v);\n  \t\t}\n\n  \t\tvalue = oldGet ? oldGet() : v;\n  \t\tset._ractiveWrappers.forEach(updateWrapper);\n  \t};\n\n  \tfunction updateWrapper(wrapper) {\n  \t\tvar keypath, ractive;\n\n  \t\twrapper.value = value;\n\n  \t\tif (wrapper.updating) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tractive = wrapper.ractive;\n  \t\tkeypath = wrapper.keypath;\n\n  \t\twrapper.updating = true;\n  \t\tglobal_runloop.start(ractive);\n\n  \t\tractive.viewmodel.mark(keypath);\n\n  \t\tglobal_runloop.end();\n  \t\twrapper.updating = false;\n  \t}\n\n  \t// Create an array of wrappers, in case other keypaths/ractives depend on this property.\n  \t// Handily, we can store them as a property of the set function. Yay JavaScript.\n  \tset._ractiveWrappers = [originalWrapper];\n  \tObject.defineProperty(object, property, { get: get, set: set, enumerable: true, configurable: true });\n  }\n\n  var magicArrayAdaptor, MagicArrayWrapper;\n\n  if (adaptors_magic) {\n  \tmagicArrayAdaptor = {\n  \t\tfilter: function (object, keypath, ractive) {\n  \t\t\treturn adaptors_magic.filter(object, keypath, ractive) && array_index.filter(object);\n  \t\t},\n\n  \t\twrap: function (ractive, array, keypath) {\n  \t\t\treturn new MagicArrayWrapper(ractive, array, keypath);\n  \t\t}\n  \t};\n\n  \tMagicArrayWrapper = function (ractive, array, keypath) {\n  \t\tthis.value = array;\n\n  \t\tthis.magic = true;\n\n  \t\tthis.magicWrapper = adaptors_magic.wrap(ractive, array, keypath);\n  \t\tthis.arrayWrapper = array_index.wrap(ractive, array, keypath);\n  \t};\n\n  \tMagicArrayWrapper.prototype = {\n  \t\tget: function () {\n  \t\t\treturn this.value;\n  \t\t},\n  \t\tteardown: function () {\n  \t\t\tthis.arrayWrapper.teardown();\n  \t\t\tthis.magicWrapper.teardown();\n  \t\t},\n  \t\treset: function (value) {\n  \t\t\treturn this.magicWrapper.reset(value);\n  \t\t}\n  \t};\n  }\n\n  var magicArray = magicArrayAdaptor;\n\n  var prototype_adapt = Viewmodel$adapt;\n\n  var prefixers = {};\n  function Viewmodel$adapt(keypath, value) {\n  \tvar len, i, adaptor, wrapped;\n\n  \tif (!this.adaptors) return;\n\n  \t// Do we have an adaptor for this value?\n  \tlen = this.adaptors.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tadaptor = this.adaptors[i];\n\n  \t\tif (adaptor.filter(value, keypath, this.ractive)) {\n  \t\t\twrapped = this.wrapped[keypath] = adaptor.wrap(this.ractive, value, keypath, getPrefixer(keypath));\n  \t\t\twrapped.value = value;\n  \t\t\treturn;\n  \t\t}\n  \t}\n  }\n\n  function prefixKeypath(obj, prefix) {\n  \tvar prefixed = {},\n  \t    key;\n\n  \tif (!prefix) {\n  \t\treturn obj;\n  \t}\n\n  \tprefix += \".\";\n\n  \tfor (key in obj) {\n  \t\tif (obj.hasOwnProperty(key)) {\n  \t\t\tprefixed[prefix + key] = obj[key];\n  \t\t}\n  \t}\n\n  \treturn prefixed;\n  }\n\n  function getPrefixer(rootKeypath) {\n  \tvar rootDot;\n\n  \tif (!prefixers[rootKeypath]) {\n  \t\trootDot = rootKeypath ? rootKeypath + \".\" : \"\";\n\n  \t\tprefixers[rootKeypath] = function (relativeKeypath, value) {\n  \t\t\tvar obj;\n\n  \t\t\tif (typeof relativeKeypath === \"string\") {\n  \t\t\t\tobj = {};\n  \t\t\t\tobj[rootDot + relativeKeypath] = value;\n  \t\t\t\treturn obj;\n  \t\t\t}\n\n  \t\t\tif (typeof relativeKeypath === \"object\") {\n  \t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\n  \t\t\t\treturn rootDot ? prefixKeypath(relativeKeypath, rootKeypath) : relativeKeypath;\n  \t\t\t}\n  \t\t};\n  \t}\n\n  \treturn prefixers[rootKeypath];\n  }\n\n  // TEMP\n\n  var helpers_getUpstreamChanges = getUpstreamChanges;\n  function getUpstreamChanges(changes) {\n  \tvar upstreamChanges = [rootKeypath],\n  \t    i,\n  \t    keypath;\n\n  \ti = changes.length;\n  \twhile (i--) {\n  \t\tkeypath = changes[i].parent;\n\n  \t\twhile (keypath && !keypath.isRoot) {\n  \t\t\tif (changes.indexOf(keypath) === -1) {\n  \t\t\t\taddToArray(upstreamChanges, keypath);\n  \t\t\t}\n  \t\t\tkeypath = keypath.parent;\n  \t\t}\n  \t}\n\n  \treturn upstreamChanges;\n  }\n\n  var applyChanges_notifyPatternObservers = notifyPatternObservers;\n\n  function notifyPatternObservers(viewmodel, keypath, onlyDirect) {\n  \tvar potentialWildcardMatches;\n\n  \tupdateMatchingPatternObservers(viewmodel, keypath);\n\n  \tif (onlyDirect) {\n  \t\treturn;\n  \t}\n\n  \tpotentialWildcardMatches = keypath.wildcardMatches();\n  \tpotentialWildcardMatches.forEach(function (upstreamPattern) {\n  \t\tcascade(viewmodel, upstreamPattern, keypath);\n  \t});\n  }\n\n  function cascade(viewmodel, upstreamPattern, keypath) {\n  \tvar group, map, actualChildKeypath;\n\n  \t// TODO should be one or the other\n  \tupstreamPattern = upstreamPattern.str || upstreamPattern;\n\n  \tgroup = viewmodel.depsMap.patternObservers;\n  \tmap = group && group[upstreamPattern];\n\n  \tif (!map) {\n  \t\treturn;\n  \t}\n\n  \tmap.forEach(function (childKeypath) {\n  \t\tactualChildKeypath = keypath.join(childKeypath.lastKey); // 'foo.bar.baz'\n\n  \t\tupdateMatchingPatternObservers(viewmodel, actualChildKeypath);\n  \t\tcascade(viewmodel, childKeypath, actualChildKeypath);\n  \t});\n  }\n\n  function updateMatchingPatternObservers(viewmodel, keypath) {\n  \tviewmodel.patternObservers.forEach(function (observer) {\n  \t\tif (observer.regex.test(keypath.str)) {\n  \t\t\tobserver.update(keypath);\n  \t\t}\n  \t});\n  }\n\n  var applyChanges = Viewmodel$applyChanges;\n\n  function Viewmodel$applyChanges() {\n  \tvar _this = this;\n\n  \tvar self = this,\n  \t    changes,\n  \t    upstreamChanges,\n  \t    hash = {},\n  \t    bindings;\n\n  \tchanges = this.changes;\n\n  \tif (!changes.length) {\n  \t\t// TODO we end up here on initial render. Perhaps we shouldn't?\n  \t\treturn;\n  \t}\n\n  \tfunction invalidateComputation(computation) {\n  \t\tvar key = computation.key;\n\n  \t\tif (computation.viewmodel === self) {\n  \t\t\tself.clearCache(key.str);\n  \t\t\tcomputation.invalidate();\n\n  \t\t\tchanges.push(key);\n  \t\t\tcascade(key);\n  \t\t} else {\n  \t\t\tcomputation.viewmodel.mark(key);\n  \t\t}\n  \t}\n\n  \tfunction cascade(keypath) {\n  \t\tvar map, computations;\n\n  \t\tif (self.noCascade.hasOwnProperty(keypath.str)) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (computations = self.deps.computed[keypath.str]) {\n  \t\t\tcomputations.forEach(invalidateComputation);\n  \t\t}\n\n  \t\tif (map = self.depsMap.computed[keypath.str]) {\n  \t\t\tmap.forEach(cascade);\n  \t\t}\n  \t}\n\n  \tchanges.slice().forEach(cascade);\n\n  \tupstreamChanges = helpers_getUpstreamChanges(changes);\n  \tupstreamChanges.forEach(function (keypath) {\n  \t\tvar computations;\n\n  \t\t// make sure we haven't already been down this particular keypath in this turn\n  \t\tif (changes.indexOf(keypath) === -1 && (computations = self.deps.computed[keypath.str])) {\n  \t\t\tcomputations.forEach(invalidateComputation);\n  \t\t}\n  \t});\n\n  \tthis.changes = [];\n\n  \t// Pattern observers are a weird special case\n  \tif (this.patternObservers.length) {\n  \t\tupstreamChanges.forEach(function (keypath) {\n  \t\t\treturn applyChanges_notifyPatternObservers(_this, keypath, true);\n  \t\t});\n  \t\tchanges.forEach(function (keypath) {\n  \t\t\treturn applyChanges_notifyPatternObservers(_this, keypath);\n  \t\t});\n  \t}\n\n  \tif (this.deps.observers) {\n  \t\tupstreamChanges.forEach(function (keypath) {\n  \t\t\treturn notifyUpstreamDependants(_this, null, keypath, \"observers\");\n  \t\t});\n  \t\tnotifyAllDependants(this, changes, \"observers\");\n  \t}\n\n  \tif (this.deps[\"default\"]) {\n  \t\tbindings = [];\n  \t\tupstreamChanges.forEach(function (keypath) {\n  \t\t\treturn notifyUpstreamDependants(_this, bindings, keypath, \"default\");\n  \t\t});\n\n  \t\tif (bindings.length) {\n  \t\t\tnotifyBindings(this, bindings, changes);\n  \t\t}\n\n  \t\tnotifyAllDependants(this, changes, \"default\");\n  \t}\n\n  \t// Return a hash of keypaths to updated values\n  \tchanges.forEach(function (keypath) {\n  \t\thash[keypath.str] = _this.get(keypath);\n  \t});\n\n  \tthis.implicitChanges = {};\n  \tthis.noCascade = {};\n\n  \treturn hash;\n  }\n\n  function notifyUpstreamDependants(viewmodel, bindings, keypath, groupName) {\n  \tvar dependants, value;\n\n  \tif (dependants = findDependants(viewmodel, keypath, groupName)) {\n  \t\tvalue = viewmodel.get(keypath);\n\n  \t\tdependants.forEach(function (d) {\n  \t\t\t// don't \"set\" the parent value, refine it\n  \t\t\t// i.e. not data = value, but data[foo] = fooValue\n  \t\t\tif (bindings && d.refineValue) {\n  \t\t\t\tbindings.push(d);\n  \t\t\t} else {\n  \t\t\t\td.setValue(value);\n  \t\t\t}\n  \t\t});\n  \t}\n  }\n\n  function notifyBindings(viewmodel, bindings, changes) {\n\n  \tbindings.forEach(function (binding) {\n  \t\tvar useSet = false,\n  \t\t    i = 0,\n  \t\t    length = changes.length,\n  \t\t    refinements = [];\n\n  \t\twhile (i < length) {\n  \t\t\tvar keypath = changes[i];\n\n  \t\t\tif (keypath === binding.keypath) {\n  \t\t\t\tuseSet = true;\n  \t\t\t\tbreak;\n  \t\t\t}\n\n  \t\t\tif (keypath.slice(0, binding.keypath.length) === binding.keypath) {\n  \t\t\t\trefinements.push(keypath);\n  \t\t\t}\n\n  \t\t\ti++;\n  \t\t}\n\n  \t\tif (useSet) {\n  \t\t\tbinding.setValue(viewmodel.get(binding.keypath));\n  \t\t}\n\n  \t\tif (refinements.length) {\n  \t\t\tbinding.refineValue(refinements);\n  \t\t}\n  \t});\n  }\n\n  function notifyAllDependants(viewmodel, keypaths, groupName) {\n  \tvar queue = [];\n\n  \taddKeypaths(keypaths);\n  \tqueue.forEach(dispatch);\n\n  \tfunction addKeypaths(keypaths) {\n  \t\tkeypaths.forEach(addKeypath);\n  \t\tkeypaths.forEach(cascade);\n  \t}\n\n  \tfunction addKeypath(keypath) {\n  \t\tvar deps = findDependants(viewmodel, keypath, groupName);\n\n  \t\tif (deps) {\n  \t\t\tqueue.push({\n  \t\t\t\tkeypath: keypath,\n  \t\t\t\tdeps: deps\n  \t\t\t});\n  \t\t}\n  \t}\n\n  \tfunction cascade(keypath) {\n  \t\tvar childDeps;\n\n  \t\tif (childDeps = viewmodel.depsMap[groupName][keypath.str]) {\n  \t\t\taddKeypaths(childDeps);\n  \t\t}\n  \t}\n\n  \tfunction dispatch(set) {\n  \t\tvar value = viewmodel.get(set.keypath);\n  \t\tset.deps.forEach(function (d) {\n  \t\t\treturn d.setValue(value);\n  \t\t});\n  \t}\n  }\n\n  function findDependants(viewmodel, keypath, groupName) {\n  \tvar group = viewmodel.deps[groupName];\n  \treturn group ? group[keypath.str] : null;\n  }\n\n  var capture = Viewmodel$capture;\n\n  function Viewmodel$capture() {\n  \tthis.captureGroups.push([]);\n  }\n\n  var clearCache = Viewmodel$clearCache;\n\n  function Viewmodel$clearCache(keypath, keepExistingWrapper) {\n  \tvar cacheMap, wrapper;\n\n  \tif (!keepExistingWrapper) {\n  \t\t// Is there a wrapped property at this keypath?\n  \t\tif (wrapper = this.wrapped[keypath]) {\n  \t\t\t// Did we unwrap it?\n  \t\t\tif (wrapper.teardown() !== false) {\n  \t\t\t\t// Is this right?\n  \t\t\t\t// What's the meaning of returning false from teardown?\n  \t\t\t\t// Could there be a GC ramification if this is a \"real\" ractive.teardown()?\n  \t\t\t\tthis.wrapped[keypath] = null;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tthis.cache[keypath] = undefined;\n\n  \tif (cacheMap = this.cacheMap[keypath]) {\n  \t\twhile (cacheMap.length) {\n  \t\t\tthis.clearCache(cacheMap.pop());\n  \t\t}\n  \t}\n  }\n\n  var UnresolvedDependency = function (computation, ref) {\n  \tthis.computation = computation;\n  \tthis.viewmodel = computation.viewmodel;\n  \tthis.ref = ref;\n\n  \t// TODO this seems like a red flag!\n  \tthis.root = this.viewmodel.ractive;\n  \tthis.parentFragment = this.root.component && this.root.component.parentFragment;\n  };\n\n  UnresolvedDependency.prototype = {\n  \tresolve: function (keypath) {\n  \t\tthis.computation.softDeps.push(keypath);\n  \t\tthis.computation.unresolvedDeps[keypath.str] = null;\n  \t\tthis.viewmodel.register(keypath, this.computation, \"computed\");\n  \t}\n  };\n\n  var Computation_UnresolvedDependency = UnresolvedDependency;\n\n  var Computation = function (key, signature) {\n  \tthis.key = key;\n\n  \tthis.getter = signature.getter;\n  \tthis.setter = signature.setter;\n\n  \tthis.hardDeps = signature.deps || [];\n  \tthis.softDeps = [];\n  \tthis.unresolvedDeps = {};\n\n  \tthis.depValues = {};\n\n  \tthis._dirty = this._firstRun = true;\n  };\n\n  Computation.prototype = {\n  \tconstructor: Computation,\n\n  \tinit: function (viewmodel) {\n  \t\tvar _this = this;\n\n  \t\tvar initial;\n\n  \t\tthis.viewmodel = viewmodel;\n  \t\tthis.bypass = true;\n\n  \t\tinitial = viewmodel.get(this.key);\n  \t\tviewmodel.clearCache(this.key.str);\n\n  \t\tthis.bypass = false;\n\n  \t\tif (this.setter && initial !== undefined) {\n  \t\t\tthis.set(initial);\n  \t\t}\n\n  \t\tif (this.hardDeps) {\n  \t\t\tthis.hardDeps.forEach(function (d) {\n  \t\t\t\treturn viewmodel.register(d, _this, \"computed\");\n  \t\t\t});\n  \t\t}\n  \t},\n\n  \tinvalidate: function () {\n  \t\tthis._dirty = true;\n  \t},\n\n  \tget: function () {\n  \t\tvar _this = this;\n\n  \t\tvar newDeps,\n  \t\t    dependenciesChanged,\n  \t\t    dependencyValuesChanged = false;\n\n  \t\tif (this.getting) {\n  \t\t\t// prevent double-computation (e.g. caused by array mutation inside computation)\n  \t\t\tvar msg = \"The \" + this.key.str + \" computation indirectly called itself. This probably indicates a bug in the computation. It is commonly caused by `array.sort(...)` - if that's the case, clone the array first with `array.slice().sort(...)`\";\n  \t\t\twarnOnce(msg);\n  \t\t\treturn this.value;\n  \t\t}\n\n  \t\tthis.getting = true;\n\n  \t\tif (this._dirty) {\n  \t\t\t// determine whether the inputs have changed, in case this depends on\n  \t\t\t// other computed values\n  \t\t\tif (this._firstRun || !this.hardDeps.length && !this.softDeps.length) {\n  \t\t\t\tdependencyValuesChanged = true;\n  \t\t\t} else {\n  \t\t\t\t[this.hardDeps, this.softDeps].forEach(function (deps) {\n  \t\t\t\t\tvar keypath, value, i;\n\n  \t\t\t\t\tif (dependencyValuesChanged) {\n  \t\t\t\t\t\treturn;\n  \t\t\t\t\t}\n\n  \t\t\t\t\ti = deps.length;\n  \t\t\t\t\twhile (i--) {\n  \t\t\t\t\t\tkeypath = deps[i];\n  \t\t\t\t\t\tvalue = _this.viewmodel.get(keypath);\n\n  \t\t\t\t\t\tif (!isEqual(value, _this.depValues[keypath.str])) {\n  \t\t\t\t\t\t\t_this.depValues[keypath.str] = value;\n  \t\t\t\t\t\t\tdependencyValuesChanged = true;\n\n  \t\t\t\t\t\t\treturn;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t});\n  \t\t\t}\n\n  \t\t\tif (dependencyValuesChanged) {\n  \t\t\t\tthis.viewmodel.capture();\n\n  \t\t\t\ttry {\n  \t\t\t\t\tthis.value = this.getter();\n  \t\t\t\t} catch (err) {\n  \t\t\t\t\twarnIfDebug(\"Failed to compute \\\"%s\\\"\", this.key.str);\n  \t\t\t\t\tlogIfDebug(err.stack || err);\n\n  \t\t\t\t\tthis.value = void 0;\n  \t\t\t\t}\n\n  \t\t\t\tnewDeps = this.viewmodel.release();\n  \t\t\t\tdependenciesChanged = this.updateDependencies(newDeps);\n\n  \t\t\t\tif (dependenciesChanged) {\n  \t\t\t\t\t[this.hardDeps, this.softDeps].forEach(function (deps) {\n  \t\t\t\t\t\tdeps.forEach(function (keypath) {\n  \t\t\t\t\t\t\t_this.depValues[keypath.str] = _this.viewmodel.get(keypath);\n  \t\t\t\t\t\t});\n  \t\t\t\t\t});\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tthis._dirty = false;\n  \t\t}\n\n  \t\tthis.getting = this._firstRun = false;\n  \t\treturn this.value;\n  \t},\n\n  \tset: function (value) {\n  \t\tif (this.setting) {\n  \t\t\tthis.value = value;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (!this.setter) {\n  \t\t\tthrow new Error(\"Computed properties without setters are read-only. (This may change in a future version of Ractive!)\");\n  \t\t}\n\n  \t\tthis.setter(value);\n  \t},\n\n  \tupdateDependencies: function (newDeps) {\n  \t\tvar i, oldDeps, keypath, dependenciesChanged, unresolved;\n\n  \t\toldDeps = this.softDeps;\n\n  \t\t// remove dependencies that are no longer used\n  \t\ti = oldDeps.length;\n  \t\twhile (i--) {\n  \t\t\tkeypath = oldDeps[i];\n\n  \t\t\tif (newDeps.indexOf(keypath) === -1) {\n  \t\t\t\tdependenciesChanged = true;\n  \t\t\t\tthis.viewmodel.unregister(keypath, this, \"computed\");\n  \t\t\t}\n  \t\t}\n\n  \t\t// create references for any new dependencies\n  \t\ti = newDeps.length;\n  \t\twhile (i--) {\n  \t\t\tkeypath = newDeps[i];\n\n  \t\t\tif (oldDeps.indexOf(keypath) === -1 && (!this.hardDeps || this.hardDeps.indexOf(keypath) === -1)) {\n  \t\t\t\tdependenciesChanged = true;\n\n  \t\t\t\t// if this keypath is currently unresolved, we need to mark\n  \t\t\t\t// it as such. TODO this is a bit muddy...\n  \t\t\t\tif (isUnresolved(this.viewmodel, keypath) && !this.unresolvedDeps[keypath.str]) {\n  \t\t\t\t\tunresolved = new Computation_UnresolvedDependency(this, keypath.str);\n  \t\t\t\t\tnewDeps.splice(i, 1);\n\n  \t\t\t\t\tthis.unresolvedDeps[keypath.str] = unresolved;\n  \t\t\t\t\tglobal_runloop.addUnresolved(unresolved);\n  \t\t\t\t} else {\n  \t\t\t\t\tthis.viewmodel.register(keypath, this, \"computed\");\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tif (dependenciesChanged) {\n  \t\t\tthis.softDeps = newDeps.slice();\n  \t\t}\n\n  \t\treturn dependenciesChanged;\n  \t}\n  };\n\n  function isUnresolved(viewmodel, keypath) {\n  \tvar key = keypath.firstKey;\n\n  \treturn !(key in viewmodel.data) && !(key in viewmodel.computations) && !(key in viewmodel.mappings);\n  }\n\n  var Computation_Computation = Computation;\n\n  var compute = Viewmodel$compute;\n  function Viewmodel$compute(key, signature) {\n  \tvar computation = new Computation_Computation(key, signature);\n\n  \tif (this.ready) {\n  \t\tcomputation.init(this);\n  \t}\n\n  \treturn this.computations[key.str] = computation;\n  }\n\n  var FAILED_LOOKUP = { FAILED_LOOKUP: true };\n\n  var viewmodel_prototype_get = Viewmodel$get;\n\n  var viewmodel_prototype_get__empty = {};\n  function Viewmodel$get(keypath, options) {\n  \tvar cache = this.cache,\n  \t    value,\n  \t    computation,\n  \t    wrapped,\n  \t    captureGroup,\n  \t    keypathStr = keypath.str,\n  \t    key;\n\n  \toptions = options || viewmodel_prototype_get__empty;\n\n  \t// capture the keypath, if we're inside a computation\n  \tif (options.capture && (captureGroup = lastItem(this.captureGroups))) {\n  \t\tif (! ~captureGroup.indexOf(keypath)) {\n  \t\t\tcaptureGroup.push(keypath);\n  \t\t}\n  \t}\n\n  \tif (hasOwn.call(this.mappings, keypath.firstKey)) {\n  \t\treturn this.mappings[keypath.firstKey].get(keypath, options);\n  \t}\n\n  \tif (keypath.isSpecial) {\n  \t\treturn keypath.value;\n  \t}\n\n  \tif (cache[keypathStr] === undefined) {\n\n  \t\t// Is this a computed property?\n  \t\tif ((computation = this.computations[keypathStr]) && !computation.bypass) {\n  \t\t\tvalue = computation.get();\n  \t\t\tthis.adapt(keypathStr, value);\n  \t\t}\n\n  \t\t// Is this a wrapped property?\n  \t\telse if (wrapped = this.wrapped[keypathStr]) {\n  \t\t\tvalue = wrapped.value;\n  \t\t}\n\n  \t\t// Is it the root?\n  \t\telse if (keypath.isRoot) {\n  \t\t\tthis.adapt(\"\", this.data);\n  \t\t\tvalue = this.data;\n  \t\t}\n\n  \t\t// No? Then we need to retrieve the value one key at a time\n  \t\telse {\n  \t\t\tvalue = retrieve(this, keypath);\n  \t\t}\n\n  \t\tcache[keypathStr] = value;\n  \t} else {\n  \t\tvalue = cache[keypathStr];\n  \t}\n\n  \tif (!options.noUnwrap && (wrapped = this.wrapped[keypathStr])) {\n  \t\tvalue = wrapped.get();\n  \t}\n\n  \tif (keypath.isRoot && options.fullRootGet) {\n  \t\tfor (key in this.mappings) {\n  \t\t\tvalue[key] = this.mappings[key].getValue();\n  \t\t}\n  \t}\n\n  \treturn value === FAILED_LOOKUP ? void 0 : value;\n  }\n\n  function retrieve(viewmodel, keypath) {\n\n  \tvar parentValue, cacheMap, value, wrapped;\n\n  \tparentValue = viewmodel.get(keypath.parent);\n\n  \tif (wrapped = viewmodel.wrapped[keypath.parent.str]) {\n  \t\tparentValue = wrapped.get();\n  \t}\n\n  \tif (parentValue === null || parentValue === undefined) {\n  \t\treturn;\n  \t}\n\n  \t// update cache map\n  \tif (!(cacheMap = viewmodel.cacheMap[keypath.parent.str])) {\n  \t\tviewmodel.cacheMap[keypath.parent.str] = [keypath.str];\n  \t} else {\n  \t\tif (cacheMap.indexOf(keypath.str) === -1) {\n  \t\t\tcacheMap.push(keypath.str);\n  \t\t}\n  \t}\n\n  \t// If this property doesn't exist, we return a sentinel value\n  \t// so that we know to query parent scope (if such there be)\n  \tif (typeof parentValue === \"object\" && !(keypath.lastKey in parentValue)) {\n  \t\treturn viewmodel.cache[keypath.str] = FAILED_LOOKUP;\n  \t}\n\n  \tvalue = parentValue[keypath.lastKey];\n\n  \t// Do we have an adaptor for this value?\n  \tviewmodel.adapt(keypath.str, value, false);\n\n  \t// Update cache\n  \tviewmodel.cache[keypath.str] = value;\n  \treturn value;\n  }\n\n  var viewmodel_prototype_init = Viewmodel$init;\n\n  function Viewmodel$init() {\n  \tvar key;\n\n  \tfor (key in this.computations) {\n  \t\tthis.computations[key].init(this);\n  \t}\n  }\n\n  var prototype_map = Viewmodel$map;\n\n  function Viewmodel$map(key, options) {\n  \tvar mapping = this.mappings[key.str] = new Mapping(key, options);\n  \tmapping.initViewmodel(this);\n  \treturn mapping;\n  }\n\n  var Mapping = function (localKey, options) {\n  \tthis.localKey = localKey;\n  \tthis.keypath = options.keypath;\n  \tthis.origin = options.origin;\n\n  \tthis.deps = [];\n  \tthis.unresolved = [];\n\n  \tthis.resolved = false;\n  };\n\n  Mapping.prototype = {\n  \tforceResolution: function () {\n  \t\t// TODO warn, as per #1692?\n  \t\tthis.keypath = this.localKey;\n  \t\tthis.setup();\n  \t},\n\n  \tget: function (keypath, options) {\n  \t\tif (!this.resolved) {\n  \t\t\treturn undefined;\n  \t\t}\n  \t\treturn this.origin.get(this.map(keypath), options);\n  \t},\n\n  \tgetValue: function () {\n  \t\tif (!this.keypath) {\n  \t\t\treturn undefined;\n  \t\t}\n  \t\treturn this.origin.get(this.keypath);\n  \t},\n\n  \tinitViewmodel: function (viewmodel) {\n  \t\tthis.local = viewmodel;\n  \t\tthis.setup();\n  \t},\n\n  \tmap: function (keypath) {\n  \t\tif (typeof this.keypath === undefined) {\n  \t\t\treturn this.localKey;\n  \t\t}\n  \t\treturn keypath.replace(this.localKey, this.keypath);\n  \t},\n\n  \tregister: function (keypath, dependant, group) {\n  \t\tthis.deps.push({ keypath: keypath, dep: dependant, group: group });\n\n  \t\tif (this.resolved) {\n  \t\t\tthis.origin.register(this.map(keypath), dependant, group);\n  \t\t}\n  \t},\n\n  \tresolve: function (keypath) {\n  \t\tif (this.keypath !== undefined) {\n  \t\t\tthis.unbind(true);\n  \t\t}\n\n  \t\tthis.keypath = keypath;\n  \t\tthis.setup();\n  \t},\n\n  \tset: function (keypath, value) {\n  \t\tif (!this.resolved) {\n  \t\t\tthis.forceResolution();\n  \t\t}\n\n  \t\tthis.origin.set(this.map(keypath), value);\n  \t},\n\n  \tsetup: function () {\n  \t\tvar _this = this;\n\n  \t\tif (this.keypath === undefined) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.resolved = true;\n\n  \t\t// accumulated dependants can now be registered\n  \t\tif (this.deps.length) {\n  \t\t\tthis.deps.forEach(function (d) {\n  \t\t\t\tvar keypath = _this.map(d.keypath);\n  \t\t\t\t_this.origin.register(keypath, d.dep, d.group);\n\n  \t\t\t\t// TODO this is a bit of a red flag... all deps should be the same?\n  \t\t\t\tif (d.dep.setValue) {\n  \t\t\t\t\td.dep.setValue(_this.origin.get(keypath));\n  \t\t\t\t} else if (d.dep.invalidate) {\n  \t\t\t\t\td.dep.invalidate();\n  \t\t\t\t} else {\n  \t\t\t\t\tthrow new Error(\"An unexpected error occurred. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!\");\n  \t\t\t\t}\n  \t\t\t});\n\n  \t\t\tthis.origin.mark(this.keypath);\n  \t\t}\n  \t},\n\n  \tsetValue: function (value) {\n  \t\tif (!this.keypath) {\n  \t\t\tthrow new Error(\"Mapping does not have keypath, cannot set value. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!\");\n  \t\t}\n\n  \t\tthis.origin.set(this.keypath, value);\n  \t},\n\n  \tunbind: function (keepLocal) {\n  \t\tvar _this = this;\n\n  \t\tif (!keepLocal) {\n  \t\t\tdelete this.local.mappings[this.localKey];\n  \t\t}\n\n  \t\tif (!this.resolved) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.deps.forEach(function (d) {\n  \t\t\t_this.origin.unregister(_this.map(d.keypath), d.dep, d.group);\n  \t\t});\n\n  \t\tif (this.tracker) {\n  \t\t\tthis.origin.unregister(this.keypath, this.tracker);\n  \t\t}\n  \t},\n\n  \tunregister: function (keypath, dependant, group) {\n  \t\tvar deps, i;\n\n  \t\tif (!this.resolved) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tdeps = this.deps;\n  \t\ti = deps.length;\n\n  \t\twhile (i--) {\n  \t\t\tif (deps[i].dep === dependant) {\n  \t\t\t\tdeps.splice(i, 1);\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t\tthis.origin.unregister(this.map(keypath), dependant, group);\n  \t}\n  };\n\n  var mark = Viewmodel$mark;\n\n  function Viewmodel$mark(keypath, options) {\n  \tvar computation,\n  \t    keypathStr = keypath.str;\n\n  \t// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)\n  \t// should not be picked up by pattern observers\n  \tif (options) {\n  \t\tif (options.implicit) {\n  \t\t\tthis.implicitChanges[keypathStr] = true;\n  \t\t}\n  \t\tif (options.noCascade) {\n  \t\t\tthis.noCascade[keypathStr] = true;\n  \t\t}\n  \t}\n\n  \tif (computation = this.computations[keypathStr]) {\n  \t\tcomputation.invalidate();\n  \t}\n\n  \tif (this.changes.indexOf(keypath) === -1) {\n  \t\tthis.changes.push(keypath);\n  \t}\n\n  \t// pass on keepExistingWrapper, if we can\n  \tvar keepExistingWrapper = options ? options.keepExistingWrapper : false;\n\n  \tthis.clearCache(keypathStr, keepExistingWrapper);\n\n  \tif (this.ready) {\n  \t\tthis.onchange();\n  \t}\n  }\n\n  var mapOldToNewIndex = function (oldArray, newArray) {\n  \tvar usedIndices, firstUnusedIndex, newIndices, changed;\n\n  \tusedIndices = {};\n  \tfirstUnusedIndex = 0;\n\n  \tnewIndices = oldArray.map(function (item, i) {\n  \t\tvar index, start, len;\n\n  \t\tstart = firstUnusedIndex;\n  \t\tlen = newArray.length;\n\n  \t\tdo {\n  \t\t\tindex = newArray.indexOf(item, start);\n\n  \t\t\tif (index === -1) {\n  \t\t\t\tchanged = true;\n  \t\t\t\treturn -1;\n  \t\t\t}\n\n  \t\t\tstart = index + 1;\n  \t\t} while (usedIndices[index] && start < len);\n\n  \t\t// keep track of the first unused index, so we don't search\n  \t\t// the whole of newArray for each item in oldArray unnecessarily\n  \t\tif (index === firstUnusedIndex) {\n  \t\t\tfirstUnusedIndex += 1;\n  \t\t}\n\n  \t\tif (index !== i) {\n  \t\t\tchanged = true;\n  \t\t}\n\n  \t\tusedIndices[index] = true;\n  \t\treturn index;\n  \t});\n\n  \treturn newIndices;\n  };\n\n  var merge = Viewmodel$merge;\n\n  var comparators = {};\n  function Viewmodel$merge(keypath, currentArray, array, options) {\n  \tvar oldArray, newArray, comparator, newIndices;\n\n  \tthis.mark(keypath);\n\n  \tif (options && options.compare) {\n\n  \t\tcomparator = getComparatorFunction(options.compare);\n\n  \t\ttry {\n  \t\t\toldArray = currentArray.map(comparator);\n  \t\t\tnewArray = array.map(comparator);\n  \t\t} catch (err) {\n  \t\t\t// fallback to an identity check - worst case scenario we have\n  \t\t\t// to do more DOM manipulation than we thought...\n  \t\t\twarnIfDebug(\"merge(): \\\"%s\\\" comparison failed. Falling back to identity checking\", keypath);\n\n  \t\t\toldArray = currentArray;\n  \t\t\tnewArray = array;\n  \t\t}\n  \t} else {\n  \t\toldArray = currentArray;\n  \t\tnewArray = array;\n  \t}\n\n  \t// find new indices for members of oldArray\n  \tnewIndices = mapOldToNewIndex(oldArray, newArray);\n\n  \tthis.smartUpdate(keypath, array, newIndices, currentArray.length !== array.length);\n  }\n\n  function stringify(item) {\n  \treturn JSON.stringify(item);\n  }\n\n  function getComparatorFunction(comparator) {\n  \t// If `compare` is `true`, we use JSON.stringify to compare\n  \t// objects that are the same shape, but non-identical - i.e.\n  \t// { foo: 'bar' } !== { foo: 'bar' }\n  \tif (comparator === true) {\n  \t\treturn stringify;\n  \t}\n\n  \tif (typeof comparator === \"string\") {\n  \t\tif (!comparators[comparator]) {\n  \t\t\tcomparators[comparator] = function (item) {\n  \t\t\t\treturn item[comparator];\n  \t\t\t};\n  \t\t}\n\n  \t\treturn comparators[comparator];\n  \t}\n\n  \tif (typeof comparator === \"function\") {\n  \t\treturn comparator;\n  \t}\n\n  \tthrow new Error(\"The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)\");\n  }\n\n  var register = Viewmodel$register;\n\n  function Viewmodel$register(keypath, dependant) {\n  \tvar group = arguments[2] === undefined ? \"default\" : arguments[2];\n\n  \tvar mapping, depsByKeypath, deps;\n\n  \tif (dependant.isStatic) {\n  \t\treturn; // TODO we should never get here if a dependant is static...\n  \t}\n\n  \tif (mapping = this.mappings[keypath.firstKey]) {\n  \t\tmapping.register(keypath, dependant, group);\n  \t} else {\n  \t\tdepsByKeypath = this.deps[group] || (this.deps[group] = {});\n  \t\tdeps = depsByKeypath[keypath.str] || (depsByKeypath[keypath.str] = []);\n\n  \t\tdeps.push(dependant);\n\n  \t\tif (!this.depsMap[group]) {\n  \t\t\tthis.depsMap[group] = {};\n  \t\t}\n\n  \t\tif (!keypath.isRoot) {\n  \t\t\tregister__updateDependantsMap(this, keypath, group);\n  \t\t}\n  \t}\n  }\n\n  function register__updateDependantsMap(viewmodel, keypath, group) {\n  \tvar map, parent, keypathStr;\n\n  \t// update dependants map\n  \twhile (!keypath.isRoot) {\n  \t\tmap = viewmodel.depsMap[group];\n  \t\tparent = map[keypath.parent.str] || (map[keypath.parent.str] = []);\n\n  \t\tkeypathStr = keypath.str;\n\n  \t\t// TODO find an alternative to this nasty approach\n  \t\tif (parent[\"_\" + keypathStr] === undefined) {\n  \t\t\tparent[\"_\" + keypathStr] = 0;\n  \t\t\tparent.push(keypath);\n  \t\t}\n\n  \t\tparent[\"_\" + keypathStr] += 1;\n  \t\tkeypath = keypath.parent;\n  \t}\n  }\n\n  var release = Viewmodel$release;\n\n  function Viewmodel$release() {\n  \treturn this.captureGroups.pop();\n  }\n\n  var reset = Viewmodel$reset;\n\n  function Viewmodel$reset(data) {\n  \tthis.data = data;\n  \tthis.clearCache(\"\");\n  }\n\n  var prototype_set = Viewmodel$set;\n\n  function Viewmodel$set(keypath, value) {\n  \tvar options = arguments[2] === undefined ? {} : arguments[2];\n\n  \tvar mapping, computation, wrapper, keepExistingWrapper;\n\n  \t// unless data is being set for data tracking purposes\n  \tif (!options.noMapping) {\n  \t\t// If this data belongs to a different viewmodel,\n  \t\t// pass the change along\n  \t\tif (mapping = this.mappings[keypath.firstKey]) {\n  \t\t\treturn mapping.set(keypath, value);\n  \t\t}\n  \t}\n\n  \tcomputation = this.computations[keypath.str];\n  \tif (computation) {\n  \t\tif (computation.setting) {\n  \t\t\t// let the other computation set() handle things...\n  \t\t\treturn;\n  \t\t}\n  \t\tcomputation.set(value);\n  \t\tvalue = computation.get();\n  \t}\n\n  \tif (isEqual(this.cache[keypath.str], value)) {\n  \t\treturn;\n  \t}\n\n  \twrapper = this.wrapped[keypath.str];\n\n  \t// If we have a wrapper with a `reset()` method, we try and use it. If the\n  \t// `reset()` method returns false, the wrapper should be torn down, and\n  \t// (most likely) a new one should be created later\n  \tif (wrapper && wrapper.reset) {\n  \t\tkeepExistingWrapper = wrapper.reset(value) !== false;\n\n  \t\tif (keepExistingWrapper) {\n  \t\t\tvalue = wrapper.get();\n  \t\t}\n  \t}\n\n  \tif (!computation && !keepExistingWrapper) {\n  \t\tresolveSet(this, keypath, value);\n  \t}\n\n  \tif (!options.silent) {\n  \t\tthis.mark(keypath);\n  \t} else {\n  \t\t// We're setting a parent of the original target keypath (i.e.\n  \t\t// creating a fresh branch) - we need to clear the cache, but\n  \t\t// not mark it as a change\n  \t\tthis.clearCache(keypath.str);\n  \t}\n  }\n\n  function resolveSet(viewmodel, keypath, value) {\n  \tvar wrapper, parentValue, wrapperSet, valueSet;\n\n  \twrapperSet = function () {\n  \t\tif (wrapper.set) {\n  \t\t\twrapper.set(keypath.lastKey, value);\n  \t\t} else {\n  \t\t\tparentValue = wrapper.get();\n  \t\t\tvalueSet();\n  \t\t}\n  \t};\n\n  \tvalueSet = function () {\n  \t\tif (!parentValue) {\n  \t\t\tparentValue = createBranch(keypath.lastKey);\n  \t\t\tviewmodel.set(keypath.parent, parentValue, { silent: true });\n  \t\t}\n  \t\tparentValue[keypath.lastKey] = value;\n  \t};\n\n  \twrapper = viewmodel.wrapped[keypath.parent.str];\n\n  \tif (wrapper) {\n  \t\twrapperSet();\n  \t} else {\n  \t\tparentValue = viewmodel.get(keypath.parent);\n\n  \t\t// may have been wrapped via the above .get()\n  \t\t// call on viewmodel if this is first access via .set()!\n  \t\tif (wrapper = viewmodel.wrapped[keypath.parent.str]) {\n  \t\t\twrapperSet();\n  \t\t} else {\n  \t\t\tvalueSet();\n  \t\t}\n  \t}\n  }\n\n  var smartUpdate = Viewmodel$smartUpdate;\n\n  var implicitOption = { implicit: true },\n      noCascadeOption = { noCascade: true };\n  function Viewmodel$smartUpdate(keypath, array, newIndices) {\n  \tvar _this = this;\n\n  \tvar dependants, oldLength, i;\n\n  \toldLength = newIndices.length;\n\n  \t// Indices that are being removed should be marked as dirty\n  \tnewIndices.forEach(function (newIndex, oldIndex) {\n  \t\tif (newIndex === -1) {\n  \t\t\t_this.mark(keypath.join(oldIndex), noCascadeOption);\n  \t\t}\n  \t});\n\n  \t// Update the model\n  \t// TODO allow existing array to be updated in place, rather than replaced?\n  \tthis.set(keypath, array, { silent: true });\n\n  \tif (dependants = this.deps[\"default\"][keypath.str]) {\n  \t\tdependants.filter(canShuffle).forEach(function (d) {\n  \t\t\treturn d.shuffle(newIndices, array);\n  \t\t});\n  \t}\n\n  \tif (oldLength !== array.length) {\n  \t\tthis.mark(keypath.join(\"length\"), implicitOption);\n\n  \t\tfor (i = newIndices.touchedFrom; i < array.length; i += 1) {\n  \t\t\tthis.mark(keypath.join(i));\n  \t\t}\n\n  \t\t// don't allow removed indexes beyond end of new array to trigger recomputations\n  \t\t// TODO is this still necessary, now that computations are lazy?\n  \t\tfor (i = array.length; i < oldLength; i += 1) {\n  \t\t\tthis.mark(keypath.join(i), noCascadeOption);\n  \t\t}\n  \t}\n  }\n\n  function canShuffle(dependant) {\n  \treturn typeof dependant.shuffle === \"function\";\n  }\n\n  var prototype_teardown = Viewmodel$teardown;\n\n  function Viewmodel$teardown() {\n  \tvar _this = this;\n\n  \tvar unresolvedImplicitDependency;\n\n  \t// Clear entire cache - this has the desired side-effect\n  \t// of unwrapping adapted values (e.g. arrays)\n  \tObject.keys(this.cache).forEach(function (keypath) {\n  \t\treturn _this.clearCache(keypath);\n  \t});\n\n  \t// Teardown any failed lookups - we don't need them to resolve any more\n  \twhile (unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop()) {\n  \t\tunresolvedImplicitDependency.teardown();\n  \t}\n  }\n\n  var unregister = Viewmodel$unregister;\n\n  function Viewmodel$unregister(keypath, dependant) {\n  \tvar group = arguments[2] === undefined ? \"default\" : arguments[2];\n\n  \tvar mapping, deps, index;\n\n  \tif (dependant.isStatic) {\n  \t\treturn;\n  \t}\n\n  \tif (mapping = this.mappings[keypath.firstKey]) {\n  \t\treturn mapping.unregister(keypath, dependant, group);\n  \t}\n\n  \tdeps = this.deps[group][keypath.str];\n  \tindex = deps.indexOf(dependant);\n\n  \tif (index === -1) {\n  \t\tthrow new Error(\"Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks\");\n  \t}\n\n  \tdeps.splice(index, 1);\n\n  \tif (keypath.isRoot) {\n  \t\treturn;\n  \t}\n\n  \tunregister__updateDependantsMap(this, keypath, group);\n  }\n\n  function unregister__updateDependantsMap(viewmodel, keypath, group) {\n  \tvar map, parent;\n\n  \t// update dependants map\n  \twhile (!keypath.isRoot) {\n  \t\tmap = viewmodel.depsMap[group];\n  \t\tparent = map[keypath.parent.str];\n\n  \t\tparent[\"_\" + keypath.str] -= 1;\n\n  \t\tif (!parent[\"_\" + keypath.str]) {\n  \t\t\t// remove from parent deps map\n  \t\t\tremoveFromArray(parent, keypath);\n  \t\t\tparent[\"_\" + keypath.str] = undefined;\n  \t\t}\n\n  \t\tkeypath = keypath.parent;\n  \t}\n  }\n\n  var Viewmodel = function (options) {\n  \tvar adapt = options.adapt;\n  \tvar data = options.data;\n  \tvar ractive = options.ractive;\n  \tvar computed = options.computed;\n  \tvar mappings = options.mappings;\n  \tvar key;\n  \tvar mapping;\n\n  \t// TODO is it possible to remove this reference?\n  \tthis.ractive = ractive;\n\n  \tthis.adaptors = adapt;\n  \tthis.onchange = options.onchange;\n\n  \tthis.cache = {}; // we need to be able to use hasOwnProperty, so can't inherit from null\n  \tthis.cacheMap = create(null);\n\n  \tthis.deps = {\n  \t\tcomputed: create(null),\n  \t\t\"default\": create(null)\n  \t};\n  \tthis.depsMap = {\n  \t\tcomputed: create(null),\n  \t\t\"default\": create(null)\n  \t};\n\n  \tthis.patternObservers = [];\n\n  \tthis.specials = create(null);\n\n  \tthis.wrapped = create(null);\n  \tthis.computations = create(null);\n\n  \tthis.captureGroups = [];\n  \tthis.unresolvedImplicitDependencies = [];\n\n  \tthis.changes = [];\n  \tthis.implicitChanges = {};\n  \tthis.noCascade = {};\n\n  \tthis.data = data;\n\n  \t// set up explicit mappings\n  \tthis.mappings = create(null);\n  \tfor (key in mappings) {\n  \t\tthis.map(getKeypath(key), mappings[key]);\n  \t}\n\n  \tif (data) {\n  \t\t// if data exists locally, but is missing on the parent,\n  \t\t// we transfer ownership to the parent\n  \t\tfor (key in data) {\n  \t\t\tif ((mapping = this.mappings[key]) && mapping.getValue() === undefined) {\n  \t\t\t\tmapping.setValue(data[key]);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tfor (key in computed) {\n  \t\tif (mappings && key in mappings) {\n  \t\t\tfatal(\"Cannot map to a computed property ('%s')\", key);\n  \t\t}\n\n  \t\tthis.compute(getKeypath(key), computed[key]);\n  \t}\n\n  \tthis.ready = true;\n  };\n\n  Viewmodel.prototype = {\n  \tadapt: prototype_adapt,\n  \tapplyChanges: applyChanges,\n  \tcapture: capture,\n  \tclearCache: clearCache,\n  \tcompute: compute,\n  \tget: viewmodel_prototype_get,\n  \tinit: viewmodel_prototype_init,\n  \tmap: prototype_map,\n  \tmark: mark,\n  \tmerge: merge,\n  \tregister: register,\n  \trelease: release,\n  \treset: reset,\n  \tset: prototype_set,\n  \tsmartUpdate: smartUpdate,\n  \tteardown: prototype_teardown,\n  \tunregister: unregister\n  };\n\n  var viewmodel_Viewmodel = Viewmodel;\n\n  function HookQueue(event) {\n  \tthis.hook = new hooks_Hook(event);\n  \tthis.inProcess = {};\n  \tthis.queue = {};\n  }\n\n  HookQueue.prototype = {\n\n  \tconstructor: HookQueue,\n\n  \tbegin: function (ractive) {\n  \t\tthis.inProcess[ractive._guid] = true;\n  \t},\n\n  \tend: function (ractive) {\n\n  \t\tvar parent = ractive.parent;\n\n  \t\t// If this is *isn't* a child of a component that's in process,\n  \t\t// it should call methods or fire at this point\n  \t\tif (!parent || !this.inProcess[parent._guid]) {\n  \t\t\tfire(this, ractive);\n  \t\t}\n  \t\t// elsewise, handoff to parent to fire when ready\n  \t\telse {\n  \t\t\tgetChildQueue(this.queue, parent).push(ractive);\n  \t\t}\n\n  \t\tdelete this.inProcess[ractive._guid];\n  \t}\n  };\n\n  function getChildQueue(queue, ractive) {\n  \treturn queue[ractive._guid] || (queue[ractive._guid] = []);\n  }\n\n  function fire(hookQueue, ractive) {\n\n  \tvar childQueue = getChildQueue(hookQueue.queue, ractive);\n\n  \thookQueue.hook.fire(ractive);\n\n  \t// queue is \"live\" because components can end up being\n  \t// added while hooks fire on parents that modify data values.\n  \twhile (childQueue.length) {\n  \t\tfire(hookQueue, childQueue.shift());\n  \t}\n\n  \tdelete hookQueue.queue[ractive._guid];\n  }\n\n  var hooks_HookQueue = HookQueue;\n\n  var helpers_getComputationSignatures = getComputationSignatures;\n\n  var helpers_getComputationSignatures__pattern = /\\$\\{([^\\}]+)\\}/g;\n  function getComputationSignatures(ractive, computed) {\n  \tvar signatures = {},\n  \t    key;\n\n  \tfor (key in computed) {\n  \t\tsignatures[key] = getComputationSignature(ractive, key, computed[key]);\n  \t}\n\n  \treturn signatures;\n  }\n\n  function getComputationSignature(ractive, key, signature) {\n  \tvar getter, setter;\n\n  \tif (typeof signature === \"function\") {\n  \t\tgetter = helpers_getComputationSignatures__bind(signature, ractive);\n  \t}\n\n  \tif (typeof signature === \"string\") {\n  \t\tgetter = createFunctionFromString(ractive, signature);\n  \t}\n\n  \tif (typeof signature === \"object\") {\n  \t\tif (typeof signature.get === \"string\") {\n  \t\t\tgetter = createFunctionFromString(ractive, signature.get);\n  \t\t} else if (typeof signature.get === \"function\") {\n  \t\t\tgetter = helpers_getComputationSignatures__bind(signature.get, ractive);\n  \t\t} else {\n  \t\t\tfatal(\"`%s` computation must have a `get()` method\", key);\n  \t\t}\n\n  \t\tif (typeof signature.set === \"function\") {\n  \t\t\tsetter = helpers_getComputationSignatures__bind(signature.set, ractive);\n  \t\t}\n  \t}\n\n  \treturn { getter: getter, setter: setter };\n  }\n\n  function createFunctionFromString(ractive, str) {\n  \tvar functionBody, hasThis, fn;\n\n  \tfunctionBody = \"return (\" + str.replace(helpers_getComputationSignatures__pattern, function (match, keypath) {\n  \t\thasThis = true;\n  \t\treturn \"__ractive.get(\\\"\" + keypath + \"\\\")\";\n  \t}) + \");\";\n\n  \tif (hasThis) {\n  \t\tfunctionBody = \"var __ractive = this; \" + functionBody;\n  \t}\n\n  \tfn = new Function(functionBody);\n  \treturn hasThis ? fn.bind(ractive) : fn;\n  }\n\n  function helpers_getComputationSignatures__bind(fn, context) {\n  \treturn /this/.test(fn.toString()) ? fn.bind(context) : fn;\n  }\n\n  var constructHook = new hooks_Hook(\"construct\");\n  var configHook = new hooks_Hook(\"config\");\n  var initHook = new hooks_HookQueue(\"init\");\n  var initialise__uid = 0;\n\n  var initialise__registryNames = [\"adaptors\", \"components\", \"decorators\", \"easing\", \"events\", \"interpolators\", \"partials\", \"transitions\"];\n\n  var initialise = initialiseRactiveInstance;\n\n  function initialiseRactiveInstance(ractive) {\n  \tvar userOptions = arguments[1] === undefined ? {} : arguments[1];\n  \tvar options = arguments[2] === undefined ? {} : arguments[2];\n\n  \tvar el, viewmodel;\n\n  \tif (_Ractive.DEBUG) {\n  \t\twelcome();\n  \t}\n\n  \tinitialiseProperties(ractive, options);\n\n  \t// TODO remove this, eventually\n  \tdefineProperty(ractive, \"data\", { get: deprecateRactiveData });\n\n  \t// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it\n  \tconstructHook.fire(ractive, userOptions);\n\n  \t// Add registries\n  \tinitialise__registryNames.forEach(function (name) {\n  \t\tractive[name] = utils_object__extend(create(ractive.constructor[name] || null), userOptions[name]);\n  \t});\n\n  \t// Create a viewmodel\n  \tviewmodel = new viewmodel_Viewmodel({\n  \t\tadapt: getAdaptors(ractive, ractive.adapt, userOptions),\n  \t\tdata: custom_data.init(ractive.constructor, ractive, userOptions),\n  \t\tcomputed: helpers_getComputationSignatures(ractive, utils_object__extend(create(ractive.constructor.prototype.computed), userOptions.computed)),\n  \t\tmappings: options.mappings,\n  \t\tractive: ractive,\n  \t\tonchange: function () {\n  \t\t\treturn global_runloop.addRactive(ractive);\n  \t\t}\n  \t});\n\n  \tractive.viewmodel = viewmodel;\n\n  \t// This can't happen earlier, because computed properties may call `ractive.get()`, etc\n  \tviewmodel.init();\n\n  \t// init config from Parent and options\n  \tconfig_config.init(ractive.constructor, ractive, userOptions);\n\n  \tconfigHook.fire(ractive);\n  \tinitHook.begin(ractive);\n\n  \t// // If this is a component with a function `data` property, call the function\n  \t// // with `ractive` as context (unless the child was also a function)\n  \t// if ( typeof ractive.constructor.prototype.data === 'function' && typeof userOptions.data !== 'function' ) {\n  \t// \tviewmodel.reset( ractive.constructor.prototype.data.call( ractive ) || fatal( '`data` functions must return a data object' ) );\n  \t// }\n\n  \t// Render virtual DOM\n  \tif (ractive.template) {\n  \t\tvar cssIds = undefined;\n\n  \t\tif (options.cssIds || ractive.cssId) {\n  \t\t\tcssIds = options.cssIds ? options.cssIds.slice() : [];\n\n  \t\t\tif (ractive.cssId) {\n  \t\t\t\tcssIds.push(ractive.cssId);\n  \t\t\t}\n  \t\t}\n\n  \t\tractive.fragment = new virtualdom_Fragment({\n  \t\t\ttemplate: ractive.template,\n  \t\t\troot: ractive,\n  \t\t\towner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on\n  \t\t\tcssIds: cssIds\n  \t\t});\n  \t}\n\n  \tinitHook.end(ractive);\n\n  \t// render automatically ( if `el` is specified )\n  \tif (el = getElement(ractive.el)) {\n  \t\tvar promise = ractive.render(el, ractive.append);\n\n  \t\tif (_Ractive.DEBUG_PROMISES) {\n  \t\t\tpromise[\"catch\"](function (err) {\n  \t\t\t\twarnOnceIfDebug(\"Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;\");\n  \t\t\t\twarnIfDebug(\"An error happened during rendering\", { ractive: ractive });\n  \t\t\t\terr.stack && logIfDebug(err.stack);\n\n  \t\t\t\tthrow err;\n  \t\t\t});\n  \t\t}\n  \t}\n  }\n\n  function getAdaptors(ractive, protoAdapt, userOptions) {\n  \tvar adapt, magic, modifyArrays;\n\n  \tprotoAdapt = protoAdapt.map(lookup);\n  \tadapt = ensureArray(userOptions.adapt).map(lookup);\n\n  \tadapt = initialise__combine(protoAdapt, adapt);\n\n  \tmagic = \"magic\" in userOptions ? userOptions.magic : ractive.magic;\n  \tmodifyArrays = \"modifyArrays\" in userOptions ? userOptions.modifyArrays : ractive.modifyArrays;\n\n  \tif (magic) {\n  \t\tif (!environment__magic) {\n  \t\t\tthrow new Error(\"Getters and setters (magic mode) are not supported in this browser\");\n  \t\t}\n\n  \t\tif (modifyArrays) {\n  \t\t\tadapt.push(magicArray);\n  \t\t}\n\n  \t\tadapt.push(adaptors_magic);\n  \t}\n\n  \tif (modifyArrays) {\n  \t\tadapt.push(array_index);\n  \t}\n\n  \treturn adapt;\n\n  \tfunction lookup(adaptor) {\n  \t\tif (typeof adaptor === \"string\") {\n  \t\t\tadaptor = findInViewHierarchy(\"adaptors\", ractive, adaptor);\n\n  \t\t\tif (!adaptor) {\n  \t\t\t\tfatal(missingPlugin(adaptor, \"adaptor\"));\n  \t\t\t}\n  \t\t}\n\n  \t\treturn adaptor;\n  \t}\n  }\n\n  function initialise__combine(a, b) {\n  \tvar c = a.slice(),\n  \t    i = b.length;\n\n  \twhile (i--) {\n  \t\tif (! ~c.indexOf(b[i])) {\n  \t\t\tc.push(b[i]);\n  \t\t}\n  \t}\n\n  \treturn c;\n  }\n\n  function initialiseProperties(ractive, options) {\n  \t// Generate a unique identifier, for places where you'd use a weak map if it\n  \t// existed\n  \tractive._guid = \"r-\" + initialise__uid++;\n\n  \t// events\n  \tractive._subs = create(null);\n\n  \t// storage for item configuration from instantiation to reset,\n  \t// like dynamic functions or original values\n  \tractive._config = {};\n\n  \t// two-way bindings\n  \tractive._twowayBindings = create(null);\n\n  \t// animations (so we can stop any in progress at teardown)\n  \tractive._animations = [];\n\n  \t// nodes registry\n  \tractive.nodes = {};\n\n  \t// live queries\n  \tractive._liveQueries = [];\n  \tractive._liveComponentQueries = [];\n\n  \t// bound data functions\n  \tractive._boundFunctions = [];\n\n  \t// observers\n  \tractive._observers = [];\n\n  \t// properties specific to inline components\n  \tif (options.component) {\n  \t\tractive.parent = options.parent;\n  \t\tractive.container = options.container || null;\n  \t\tractive.root = ractive.parent.root;\n\n  \t\tractive.component = options.component;\n  \t\toptions.component.instance = ractive;\n\n  \t\t// for hackability, this could be an open option\n  \t\t// for any ractive instance, but for now, just\n  \t\t// for components and just for ractive...\n  \t\tractive._inlinePartials = options.inlinePartials;\n  \t} else {\n  \t\tractive.root = ractive;\n  \t\tractive.parent = ractive.container = null;\n  \t}\n  }\n\n  function deprecateRactiveData() {\n  \tthrow new Error(\"Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead\");\n  }\n\n  function ComplexParameter(component, template, callback) {\n  \tthis.parentFragment = component.parentFragment;\n  \tthis.callback = callback;\n\n  \tthis.fragment = new virtualdom_Fragment({\n  \t\ttemplate: template,\n  \t\troot: component.root,\n  \t\towner: this\n  \t});\n\n  \tthis.update();\n  }\n\n  var initialise_ComplexParameter = ComplexParameter;\n\n  ComplexParameter.prototype = {\n  \tbubble: function () {\n  \t\tif (!this.dirty) {\n  \t\t\tthis.dirty = true;\n  \t\t\tglobal_runloop.addView(this);\n  \t\t}\n  \t},\n\n  \tupdate: function () {\n  \t\tthis.callback(this.fragment.getValue());\n  \t\tthis.dirty = false;\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t},\n\n  \tunbind: function () {\n  \t\tthis.fragment.unbind();\n  \t}\n  };\n\n  var createInstance = function (component, Component, attributes, yieldTemplate, partials) {\n  \tvar instance,\n  \t    parentFragment,\n  \t    ractive,\n  \t    fragment,\n  \t    container,\n  \t    inlinePartials = {},\n  \t    data = {},\n  \t    mappings = {},\n  \t    ready,\n  \t    resolvers = [];\n\n  \tparentFragment = component.parentFragment;\n  \tractive = component.root;\n\n  \tpartials = partials || {};\n  \tutils_object__extend(inlinePartials, partials);\n\n  \t// Make contents available as a {{>content}} partial\n  \tpartials.content = yieldTemplate || [];\n\n  \t// set a default partial for yields with no name\n  \tinlinePartials[\"\"] = partials.content;\n\n  \tif (Component.defaults.el) {\n  \t\twarnIfDebug(\"The <%s/> component has a default `el` property; it has been disregarded\", component.name);\n  \t}\n\n  \t// find container\n  \tfragment = parentFragment;\n  \twhile (fragment) {\n  \t\tif (fragment.owner.type === YIELDER) {\n  \t\t\tcontainer = fragment.owner.container;\n  \t\t\tbreak;\n  \t\t}\n\n  \t\tfragment = fragment.parent;\n  \t}\n\n  \t// each attribute represents either a) data or b) a mapping\n  \tif (attributes) {\n  \t\tObject.keys(attributes).forEach(function (key) {\n  \t\t\tvar attribute = attributes[key],\n  \t\t\t    parsed,\n  \t\t\t    resolver;\n\n  \t\t\tif (typeof attribute === \"string\") {\n  \t\t\t\t// it's static data\n  \t\t\t\tparsed = parseJSON(attribute);\n  \t\t\t\tdata[key] = parsed ? parsed.value : attribute;\n  \t\t\t} else if (attribute === 0) {\n  \t\t\t\t// it had no '=', so we'll call it true\n  \t\t\t\tdata[key] = true;\n  \t\t\t} else if (isArray(attribute)) {\n  \t\t\t\t// this represents dynamic data\n  \t\t\t\tif (isSingleInterpolator(attribute)) {\n  \t\t\t\t\tmappings[key] = {\n  \t\t\t\t\t\torigin: component.root.viewmodel,\n  \t\t\t\t\t\tkeypath: undefined\n  \t\t\t\t\t};\n\n  \t\t\t\t\tresolver = createResolver(component, attribute[0], function (keypath) {\n  \t\t\t\t\t\tif (keypath.isSpecial) {\n  \t\t\t\t\t\t\tif (ready) {\n  \t\t\t\t\t\t\t\tinstance.set(key, keypath.value); // TODO use viewmodel?\n  \t\t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\t\tdata[key] = keypath.value;\n\n  \t\t\t\t\t\t\t\t// TODO errr.... would be better if we didn't have to do this\n  \t\t\t\t\t\t\t\tdelete mappings[key];\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\tif (ready) {\n  \t\t\t\t\t\t\t\tinstance.viewmodel.mappings[key].resolve(keypath);\n  \t\t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\t\t// resolved immediately\n  \t\t\t\t\t\t\t\tmappings[key].keypath = keypath;\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t}\n  \t\t\t\t\t});\n  \t\t\t\t} else {\n  \t\t\t\t\tresolver = new initialise_ComplexParameter(component, attribute, function (value) {\n  \t\t\t\t\t\tif (ready) {\n  \t\t\t\t\t\t\tinstance.set(key, value); // TODO use viewmodel?\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\tdata[key] = value;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t});\n  \t\t\t\t}\n\n  \t\t\t\tresolvers.push(resolver);\n  \t\t\t} else {\n  \t\t\t\tthrow new Error(\"erm wut\");\n  \t\t\t}\n  \t\t});\n  \t}\n\n  \tinstance = create(Component.prototype);\n\n  \tinitialise(instance, {\n  \t\tel: null,\n  \t\tappend: true,\n  \t\tdata: data,\n  \t\tpartials: partials,\n  \t\tmagic: ractive.magic || Component.defaults.magic,\n  \t\tmodifyArrays: ractive.modifyArrays,\n  \t\t// need to inherit runtime parent adaptors\n  \t\tadapt: ractive.adapt\n  \t}, {\n  \t\tparent: ractive,\n  \t\tcomponent: component,\n  \t\tcontainer: container,\n  \t\tmappings: mappings,\n  \t\tinlinePartials: inlinePartials,\n  \t\tcssIds: parentFragment.cssIds\n  \t});\n\n  \tready = true;\n  \tcomponent.resolvers = resolvers;\n\n  \treturn instance;\n  };\n\n  function createResolver(component, template, callback) {\n  \tvar resolver;\n\n  \tif (template.r) {\n  \t\tresolver = Resolvers_createReferenceResolver(component, template.r, callback);\n  \t} else if (template.x) {\n  \t\tresolver = new Resolvers_ExpressionResolver(component, component.parentFragment, template.x, callback);\n  \t} else if (template.rx) {\n  \t\tresolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(component, template.rx, callback);\n  \t}\n\n  \treturn resolver;\n  }\n\n  function isSingleInterpolator(template) {\n  \treturn template.length === 1 && template[0].t === INTERPOLATOR;\n  }\n\n  // TODO how should event arguments be handled? e.g.\n  // <widget on-foo='bar:1,2,3'/>\n  // The event 'bar' will be fired on the parent instance\n  // when 'foo' fires on the child, but the 1,2,3 arguments\n  // will be lost\n\n  var initialise_propagateEvents = propagateEvents;\n\n  function propagateEvents(component, eventsDescriptor) {\n  \tvar eventName;\n\n  \tfor (eventName in eventsDescriptor) {\n  \t\tif (eventsDescriptor.hasOwnProperty(eventName)) {\n  \t\t\tpropagateEvent(component.instance, component.root, eventName, eventsDescriptor[eventName]);\n  \t\t}\n  \t}\n  }\n\n  function propagateEvent(childInstance, parentInstance, eventName, proxyEventName) {\n  \tif (typeof proxyEventName !== \"string\") {\n  \t\tfatal(\"Components currently only support simple events - you cannot include arguments. Sorry!\");\n  \t}\n\n  \tchildInstance.on(eventName, function () {\n  \t\tvar event, args;\n\n  \t\t// semi-weak test, but what else? tag the event obj ._isEvent ?\n  \t\tif (arguments.length && arguments[0] && arguments[0].node) {\n  \t\t\tevent = Array.prototype.shift.call(arguments);\n  \t\t}\n\n  \t\targs = Array.prototype.slice.call(arguments);\n\n  \t\tshared_fireEvent(parentInstance, proxyEventName, { event: event, args: args });\n\n  \t\t// cancel bubbling\n  \t\treturn false;\n  \t});\n  }\n\n  var initialise_updateLiveQueries = function (component) {\n  \tvar ancestor, query;\n\n  \t// If there's a live query for this component type, add it\n  \tancestor = component.root;\n  \twhile (ancestor) {\n  \t\tif (query = ancestor._liveComponentQueries[\"_\" + component.name]) {\n  \t\t\tquery.push(component.instance);\n  \t\t}\n\n  \t\tancestor = ancestor.parent;\n  \t}\n  };\n\n  var Component_prototype_init = Component$init;\n  function Component$init(options, Component) {\n  \tvar parentFragment, root;\n\n  \tif (!Component) {\n  \t\tthrow new Error(\"Component \\\"\" + this.name + \"\\\" not found\");\n  \t}\n\n  \tparentFragment = this.parentFragment = options.parentFragment;\n  \troot = parentFragment.root;\n\n  \tthis.root = root;\n  \tthis.type = COMPONENT;\n  \tthis.name = options.template.e;\n  \tthis.index = options.index;\n  \tthis.indexRefBindings = {};\n  \tthis.yielders = {};\n  \tthis.resolvers = [];\n\n  \tcreateInstance(this, Component, options.template.a, options.template.f, options.template.p);\n  \tinitialise_propagateEvents(this, options.template.v);\n\n  \t// intro, outro and decorator directives have no effect\n  \tif (options.template.t0 || options.template.t1 || options.template.t2 || options.template.o) {\n  \t\twarnIfDebug(\"The \\\"intro\\\", \\\"outro\\\" and \\\"decorator\\\" directives have no effect on components\", { ractive: this.instance });\n  \t}\n\n  \tinitialise_updateLiveQueries(this);\n  }\n\n  var Component_prototype_rebind = Component$rebind;\n\n  function Component$rebind(oldKeypath, newKeypath) {\n  \tvar query;\n\n  \tthis.resolvers.forEach(rebind);\n\n  \tfor (var k in this.yielders) {\n  \t\tif (this.yielders[k][0]) {\n  \t\t\trebind(this.yielders[k][0]);\n  \t\t}\n  \t}\n\n  \tif (query = this.root._liveComponentQueries[\"_\" + this.name]) {\n  \t\tquery._makeDirty();\n  \t}\n\n  \tfunction rebind(x) {\n  \t\tx.rebind(oldKeypath, newKeypath);\n  \t}\n  }\n\n  var Component_prototype_render = Component$render;\n\n  function Component$render() {\n  \tvar instance = this.instance;\n\n  \tinstance.render(this.parentFragment.getNode());\n\n  \tthis.rendered = true;\n  \treturn instance.fragment.detach();\n  }\n\n  var Component_prototype_toString = Component$toString;\n\n  function Component$toString() {\n  \treturn this.instance.fragment.toString();\n  }\n\n  var Component_prototype_unbind = Component$unbind;\n\n  var Component_prototype_unbind__teardownHook = new hooks_Hook(\"teardown\");\n  function Component$unbind() {\n  \tvar instance = this.instance;\n\n  \tthis.resolvers.forEach(methodCallers__unbind);\n\n  \tremoveFromLiveComponentQueries(this);\n\n  \tinstance._observers.forEach(cancel);\n\n  \t// teardown the instance\n  \tinstance.fragment.unbind();\n  \tinstance.viewmodel.teardown();\n\n  \tif (instance.fragment.rendered && instance.el.__ractive_instances__) {\n  \t\tremoveFromArray(instance.el.__ractive_instances__, instance);\n  \t}\n\n  \tComponent_prototype_unbind__teardownHook.fire(instance);\n  }\n\n  function removeFromLiveComponentQueries(component) {\n  \tvar instance, query;\n\n  \tinstance = component.root;\n\n  \tdo {\n  \t\tif (query = instance._liveComponentQueries[\"_\" + component.name]) {\n  \t\t\tquery._remove(component);\n  \t\t}\n  \t} while (instance = instance.parent);\n  }\n\n  var Component_prototype_unrender = Component$unrender;\n\n  function Component$unrender(shouldDestroy) {\n  \tthis.shouldDestroy = shouldDestroy;\n  \tthis.instance.unrender();\n  }\n\n  var Component = function (options, Constructor) {\n  \tthis.init(options, Constructor);\n  };\n\n  Component.prototype = {\n  \tdetach: Component_prototype_detach,\n  \tfind: Component_prototype_find,\n  \tfindAll: Component_prototype_findAll,\n  \tfindAllComponents: Component_prototype_findAllComponents,\n  \tfindComponent: Component_prototype_findComponent,\n  \tfindNextNode: Component_prototype_findNextNode,\n  \tfirstNode: Component_prototype_firstNode,\n  \tinit: Component_prototype_init,\n  \trebind: Component_prototype_rebind,\n  \trender: Component_prototype_render,\n  \ttoString: Component_prototype_toString,\n  \tunbind: Component_prototype_unbind,\n  \tunrender: Component_prototype_unrender\n  };\n\n  var _Component = Component;\n\n  var Comment = function (options) {\n  \tthis.type = COMMENT;\n  \tthis.value = options.template.c;\n  };\n\n  Comment.prototype = {\n  \tdetach: shared_detach,\n\n  \tfirstNode: function () {\n  \t\treturn this.node;\n  \t},\n\n  \trender: function () {\n  \t\tif (!this.node) {\n  \t\t\tthis.node = document.createComment(this.value);\n  \t\t}\n\n  \t\treturn this.node;\n  \t},\n\n  \ttoString: function () {\n  \t\treturn \"<!--\" + this.value + \"-->\";\n  \t},\n\n  \tunrender: function (shouldDestroy) {\n  \t\tif (shouldDestroy) {\n  \t\t\tthis.node.parentNode.removeChild(this.node);\n  \t\t}\n  \t}\n  };\n\n  var items_Comment = Comment;\n\n  var Yielder = function (options) {\n  \tvar container, component;\n\n  \tthis.type = YIELDER;\n\n  \tthis.container = container = options.parentFragment.root;\n  \tthis.component = component = container.component;\n\n  \tthis.container = container;\n  \tthis.containerFragment = options.parentFragment;\n  \tthis.parentFragment = component.parentFragment;\n\n  \tvar name = this.name = options.template.n || \"\";\n\n  \tvar template = container._inlinePartials[name];\n\n  \tif (!template) {\n  \t\twarnIfDebug(\"Could not find template for partial \\\"\" + name + \"\\\"\", { ractive: options.root });\n  \t\ttemplate = [];\n  \t}\n\n  \tthis.fragment = new virtualdom_Fragment({\n  \t\towner: this,\n  \t\troot: container.parent,\n  \t\ttemplate: template,\n  \t\tpElement: this.containerFragment.pElement\n  \t});\n\n  \t// even though only one yielder is allowed, we need to have an array of them\n  \t// as it's possible to cause a yielder to be created before the last one\n  \t// was destroyed in the same turn of the runloop\n  \tif (!isArray(component.yielders[name])) {\n  \t\tcomponent.yielders[name] = [this];\n  \t} else {\n  \t\tcomponent.yielders[name].push(this);\n  \t}\n\n  \tglobal_runloop.scheduleTask(function () {\n  \t\tif (component.yielders[name].length > 1) {\n  \t\t\tthrow new Error(\"A component template can only have one {{yield\" + (name ? \" \" + name : \"\") + \"}} declaration at a time\");\n  \t\t}\n  \t});\n  };\n\n  Yielder.prototype = {\n  \tdetach: function () {\n  \t\treturn this.fragment.detach();\n  \t},\n\n  \tfind: function (selector) {\n  \t\treturn this.fragment.find(selector);\n  \t},\n\n  \tfindAll: function (selector, query) {\n  \t\treturn this.fragment.findAll(selector, query);\n  \t},\n\n  \tfindComponent: function (selector) {\n  \t\treturn this.fragment.findComponent(selector);\n  \t},\n\n  \tfindAllComponents: function (selector, query) {\n  \t\treturn this.fragment.findAllComponents(selector, query);\n  \t},\n\n  \tfindNextNode: function () {\n  \t\treturn this.containerFragment.findNextNode(this);\n  \t},\n\n  \tfirstNode: function () {\n  \t\treturn this.fragment.firstNode();\n  \t},\n\n  \tgetValue: function (options) {\n  \t\treturn this.fragment.getValue(options);\n  \t},\n\n  \trender: function () {\n  \t\treturn this.fragment.render();\n  \t},\n\n  \tunbind: function () {\n  \t\tthis.fragment.unbind();\n  \t},\n\n  \tunrender: function (shouldDestroy) {\n  \t\tthis.fragment.unrender(shouldDestroy);\n  \t\tremoveFromArray(this.component.yielders[this.name], this);\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t},\n\n  \ttoString: function () {\n  \t\treturn this.fragment.toString();\n  \t}\n  };\n\n  var items_Yielder = Yielder;\n\n  var Doctype = function (options) {\n  \tthis.declaration = options.template.a;\n  };\n\n  Doctype.prototype = {\n  \tinit: noop,\n  \trender: noop,\n  \tunrender: noop,\n  \tteardown: noop,\n  \ttoString: function () {\n  \t\treturn \"<!DOCTYPE\" + this.declaration + \">\";\n  \t}\n  };\n\n  var items_Doctype = Doctype;\n\n  var Fragment_prototype_init = Fragment$init;\n\n  function Fragment$init(options) {\n  \tvar _this = this;\n\n  \tthis.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n  \tthis.parent = this.owner.parentFragment;\n\n  \t// inherited properties\n  \tthis.root = options.root;\n  \tthis.pElement = options.pElement;\n  \tthis.context = options.context;\n  \tthis.index = options.index;\n  \tthis.key = options.key;\n  \tthis.registeredIndexRefs = [];\n\n  \t// encapsulated styles should be inherited until they get applied by an element\n  \tthis.cssIds = \"cssIds\" in options ? options.cssIds : this.parent ? this.parent.cssIds : null;\n\n  \tthis.items = options.template.map(function (template, i) {\n  \t\treturn createItem({\n  \t\t\tparentFragment: _this,\n  \t\t\tpElement: options.pElement,\n  \t\t\ttemplate: template,\n  \t\t\tindex: i\n  \t\t});\n  \t});\n\n  \tthis.value = this.argsList = null;\n  \tthis.dirtyArgs = this.dirtyValue = true;\n\n  \tthis.bound = true;\n  }\n\n  function createItem(options) {\n  \tif (typeof options.template === \"string\") {\n  \t\treturn new items_Text(options);\n  \t}\n\n  \tswitch (options.template.t) {\n  \t\tcase YIELDER:\n  \t\t\treturn new items_Yielder(options);\n  \t\tcase INTERPOLATOR:\n  \t\t\treturn new items_Interpolator(options);\n  \t\tcase SECTION:\n  \t\t\treturn new _Section(options);\n  \t\tcase TRIPLE:\n  \t\t\treturn new _Triple(options);\n  \t\tcase ELEMENT:\n  \t\t\tvar constructor = undefined;\n  \t\t\tif (constructor = Component_getComponent(options.parentFragment.root, options.template.e)) {\n  \t\t\t\treturn new _Component(options, constructor);\n  \t\t\t}\n  \t\t\treturn new _Element(options);\n  \t\tcase PARTIAL:\n  \t\t\treturn new _Partial(options);\n  \t\tcase COMMENT:\n  \t\t\treturn new items_Comment(options);\n  \t\tcase DOCTYPE:\n  \t\t\treturn new items_Doctype(options);\n\n  \t\tdefault:\n  \t\t\tthrow new Error(\"Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!\");\n  \t}\n  }\n\n  var Fragment_prototype_rebind = Fragment$rebind;\n  function Fragment$rebind(oldKeypath, newKeypath) {\n\n  \t// assign new context keypath if needed\n  \tif (!this.owner || this.owner.hasContext) {\n  \t\tassignNewKeypath(this, \"context\", oldKeypath, newKeypath);\n  \t}\n\n  \tthis.items.forEach(function (item) {\n  \t\tif (item.rebind) {\n  \t\t\titem.rebind(oldKeypath, newKeypath);\n  \t\t}\n  \t});\n  }\n\n  var Fragment_prototype_render = Fragment$render;\n\n  function Fragment$render() {\n  \tvar result;\n\n  \tif (this.items.length === 1) {\n  \t\tresult = this.items[0].render();\n  \t} else {\n  \t\tresult = document.createDocumentFragment();\n\n  \t\tthis.items.forEach(function (item) {\n  \t\t\tresult.appendChild(item.render());\n  \t\t});\n  \t}\n\n  \tthis.rendered = true;\n  \treturn result;\n  }\n\n  var Fragment_prototype_toString = Fragment$toString;\n\n  function Fragment$toString(escape) {\n  \tif (!this.items) {\n  \t\treturn \"\";\n  \t}\n\n  \treturn this.items.map(escape ? toEscapedString : Fragment_prototype_toString__toString).join(\"\");\n  }\n\n  function Fragment_prototype_toString__toString(item) {\n  \treturn item.toString();\n  }\n\n  function toEscapedString(item) {\n  \treturn item.toString(true);\n  }\n\n  var Fragment_prototype_unbind = Fragment$unbind;\n\n  function Fragment$unbind() {\n  \tif (!this.bound) {\n  \t\treturn;\n  \t}\n\n  \tthis.items.forEach(unbindItem);\n  \tthis.bound = false;\n  }\n\n  function unbindItem(item) {\n  \tif (item.unbind) {\n  \t\titem.unbind();\n  \t}\n  }\n\n  var Fragment_prototype_unrender = Fragment$unrender;\n\n  function Fragment$unrender(shouldDestroy) {\n  \tif (!this.rendered) {\n  \t\tthrow new Error(\"Attempted to unrender a fragment that was not rendered\");\n  \t}\n\n  \tthis.items.forEach(function (i) {\n  \t\treturn i.unrender(shouldDestroy);\n  \t});\n  \tthis.rendered = false;\n  }\n\n  var Fragment = function (options) {\n  \tthis.init(options);\n  };\n\n  Fragment.prototype = {\n  \tbubble: prototype_bubble,\n  \tdetach: Fragment_prototype_detach,\n  \tfind: Fragment_prototype_find,\n  \tfindAll: Fragment_prototype_findAll,\n  \tfindAllComponents: Fragment_prototype_findAllComponents,\n  \tfindComponent: Fragment_prototype_findComponent,\n  \tfindNextNode: prototype_findNextNode,\n  \tfirstNode: prototype_firstNode,\n  \tgetArgsList: getArgsList,\n  \tgetNode: getNode,\n  \tgetValue: prototype_getValue,\n  \tinit: Fragment_prototype_init,\n  \trebind: Fragment_prototype_rebind,\n  \tregisterIndexRef: function (idx) {\n  \t\tvar idxs = this.registeredIndexRefs;\n  \t\tif (idxs.indexOf(idx) === -1) {\n  \t\t\tidxs.push(idx);\n  \t\t}\n  \t},\n  \trender: Fragment_prototype_render,\n  \ttoString: Fragment_prototype_toString,\n  \tunbind: Fragment_prototype_unbind,\n  \tunregisterIndexRef: function (idx) {\n  \t\tvar idxs = this.registeredIndexRefs;\n  \t\tidxs.splice(idxs.indexOf(idx), 1);\n  \t},\n  \tunrender: Fragment_prototype_unrender\n  };\n\n  var virtualdom_Fragment = Fragment;\n\n  var prototype_reset = Ractive$reset;\n  var shouldRerender = [\"template\", \"partials\", \"components\", \"decorators\", \"events\"],\n      resetHook = new hooks_Hook(\"reset\");\n  function Ractive$reset(data) {\n  \tvar promise, wrapper, changes, i, rerender;\n\n  \tdata = data || {};\n\n  \tif (typeof data !== \"object\") {\n  \t\tthrow new Error(\"The reset method takes either no arguments, or an object containing new data\");\n  \t}\n\n  \t// If the root object is wrapped, try and use the wrapper's reset value\n  \tif ((wrapper = this.viewmodel.wrapped[\"\"]) && wrapper.reset) {\n  \t\tif (wrapper.reset(data) === false) {\n  \t\t\t// reset was rejected, we need to replace the object\n  \t\t\tthis.viewmodel.reset(data);\n  \t\t}\n  \t} else {\n  \t\tthis.viewmodel.reset(data);\n  \t}\n\n  \t// reset config items and track if need to rerender\n  \tchanges = config_config.reset(this);\n\n  \ti = changes.length;\n  \twhile (i--) {\n  \t\tif (shouldRerender.indexOf(changes[i]) > -1) {\n  \t\t\trerender = true;\n  \t\t\tbreak;\n  \t\t}\n  \t}\n\n  \tif (rerender) {\n  \t\tvar component = undefined;\n\n  \t\tthis.viewmodel.mark(rootKeypath);\n\n  \t\t// Is this is a component, we need to set the `shouldDestroy`\n  \t\t// flag, otherwise it will assume by default that a parent node\n  \t\t// will be detached, and therefore it doesn't need to bother\n  \t\t// detaching its own nodes\n  \t\tif (component = this.component) {\n  \t\t\tcomponent.shouldDestroy = true;\n  \t\t}\n\n  \t\tthis.unrender();\n\n  \t\tif (component) {\n  \t\t\tcomponent.shouldDestroy = false;\n  \t\t}\n\n  \t\t// If the template changed, we need to destroy the parallel DOM\n  \t\t// TODO if we're here, presumably it did?\n  \t\tif (this.fragment.template !== this.template) {\n  \t\t\tthis.fragment.unbind();\n\n  \t\t\tthis.fragment = new virtualdom_Fragment({\n  \t\t\t\ttemplate: this.template,\n  \t\t\t\troot: this,\n  \t\t\t\towner: this\n  \t\t\t});\n  \t\t}\n\n  \t\tpromise = this.render(this.el, this.anchor);\n  \t} else {\n  \t\tpromise = global_runloop.start(this, true);\n  \t\tthis.viewmodel.mark(rootKeypath);\n  \t\tglobal_runloop.end();\n  \t}\n\n  \tresetHook.fire(this, data);\n\n  \treturn promise;\n  }\n\n  var resetPartial = function (name, partial) {\n  \tvar promise,\n  \t    collection = [];\n\n  \tfunction collect(source, dest, ractive) {\n  \t\t// if this is a component and it has its own partial, bail\n  \t\tif (ractive && ractive.partials[name]) return;\n\n  \t\tsource.forEach(function (item) {\n  \t\t\t// queue to rerender if the item is a partial and the current name matches\n  \t\t\tif (item.type === PARTIAL && item.getPartialName() === name) {\n  \t\t\t\tdest.push(item);\n  \t\t\t}\n\n  \t\t\t// if it has a fragment, process its items\n  \t\t\tif (item.fragment) {\n  \t\t\t\tcollect(item.fragment.items, dest, ractive);\n  \t\t\t}\n\n  \t\t\t// or if it has fragments\n  \t\t\tif (isArray(item.fragments)) {\n  \t\t\t\tcollect(item.fragments, dest, ractive);\n  \t\t\t}\n\n  \t\t\t// or if it is itself a fragment, process its items\n  \t\t\telse if (isArray(item.items)) {\n  \t\t\t\tcollect(item.items, dest, ractive);\n  \t\t\t}\n\n  \t\t\t// or if it is a component, step in and process its items\n  \t\t\telse if (item.type === COMPONENT && item.instance) {\n  \t\t\t\tcollect(item.instance.fragment.items, dest, item.instance);\n  \t\t\t}\n\n  \t\t\t// if the item is an element, process its attributes too\n  \t\t\tif (item.type === ELEMENT) {\n  \t\t\t\tif (isArray(item.attributes)) {\n  \t\t\t\t\tcollect(item.attributes, dest, ractive);\n  \t\t\t\t}\n\n  \t\t\t\tif (isArray(item.conditionalAttributes)) {\n  \t\t\t\t\tcollect(item.conditionalAttributes, dest, ractive);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t});\n  \t}\n\n  \tcollect(this.fragment.items, collection);\n  \tthis.partials[name] = partial;\n\n  \tpromise = global_runloop.start(this, true);\n\n  \tcollection.forEach(function (item) {\n  \t\titem.value = undefined;\n  \t\titem.setValue(name);\n  \t});\n\n  \tglobal_runloop.end();\n\n  \treturn promise;\n  };\n\n  // TODO should resetTemplate be asynchronous? i.e. should it be a case\n  // of outro, update template, intro? I reckon probably not, since that\n  // could be achieved with unrender-resetTemplate-render. Also, it should\n  // conceptually be similar to resetPartial, which couldn't be async\n\n  var resetTemplate = Ractive$resetTemplate;\n  function Ractive$resetTemplate(template) {\n  \tvar transitionsEnabled, component;\n\n  \ttemplate_template.init(null, this, { template: template });\n\n  \ttransitionsEnabled = this.transitionsEnabled;\n  \tthis.transitionsEnabled = false;\n\n  \t// Is this is a component, we need to set the `shouldDestroy`\n  \t// flag, otherwise it will assume by default that a parent node\n  \t// will be detached, and therefore it doesn't need to bother\n  \t// detaching its own nodes\n  \tif (component = this.component) {\n  \t\tcomponent.shouldDestroy = true;\n  \t}\n\n  \tthis.unrender();\n\n  \tif (component) {\n  \t\tcomponent.shouldDestroy = false;\n  \t}\n\n  \t// remove existing fragment and create new one\n  \tthis.fragment.unbind();\n  \tthis.fragment = new virtualdom_Fragment({\n  \t\ttemplate: this.template,\n  \t\troot: this,\n  \t\towner: this\n  \t});\n\n  \tthis.render(this.el, this.anchor);\n\n  \tthis.transitionsEnabled = transitionsEnabled;\n  }\n\n  var reverse = makeArrayMethod(\"reverse\");\n\n  var Ractive_prototype_set = Ractive$set;\n\n  function Ractive$set(keypath, value) {\n  \tvar map, promise;\n\n  \tpromise = global_runloop.start(this, true);\n\n  \t// Set multiple keypaths in one go\n  \tif (isObject(keypath)) {\n  \t\tmap = keypath;\n\n  \t\tfor (keypath in map) {\n  \t\t\tif (map.hasOwnProperty(keypath)) {\n  \t\t\t\tvalue = map[keypath];\n  \t\t\t\tset(this, keypath, value);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// Set a single keypath\n  \telse {\n  \t\tset(this, keypath, value);\n  \t}\n\n  \tglobal_runloop.end();\n\n  \treturn promise;\n  }\n\n  function set(ractive, keypath, value) {\n  \tkeypath = getKeypath(normalise(keypath));\n\n  \tif (keypath.isPattern) {\n  \t\tgetMatchingKeypaths(ractive, keypath).forEach(function (keypath) {\n  \t\t\tractive.viewmodel.set(keypath, value);\n  \t\t});\n  \t} else {\n  \t\tractive.viewmodel.set(keypath, value);\n  \t}\n  }\n\n  var shift = makeArrayMethod(\"shift\");\n\n  var prototype_sort = makeArrayMethod(\"sort\");\n\n  var splice = makeArrayMethod(\"splice\");\n\n  var subtract = Ractive$subtract;\n  function Ractive$subtract(keypath, d) {\n  \treturn shared_add(this, keypath, d === undefined ? -1 : -d);\n  }\n\n  // Teardown. This goes through the root fragment and all its children, removing observers\n  // and generally cleaning up after itself\n\n  var Ractive_prototype_teardown = Ractive$teardown;\n\n  var Ractive_prototype_teardown__teardownHook = new hooks_Hook(\"teardown\");\n  function Ractive$teardown() {\n  \tvar promise;\n\n  \tthis.fragment.unbind();\n  \tthis.viewmodel.teardown();\n\n  \tthis._observers.forEach(cancel);\n\n  \tif (this.fragment.rendered && this.el.__ractive_instances__) {\n  \t\tremoveFromArray(this.el.__ractive_instances__, this);\n  \t}\n\n  \tthis.shouldDestroy = true;\n  \tpromise = this.fragment.rendered ? this.unrender() : utils_Promise.resolve();\n\n  \tRactive_prototype_teardown__teardownHook.fire(this);\n\n  \tthis._boundFunctions.forEach(deleteFunctionCopy);\n\n  \treturn promise;\n  }\n\n  function deleteFunctionCopy(bound) {\n  \tdelete bound.fn[bound.prop];\n  }\n\n  var toggle = Ractive$toggle;\n  function Ractive$toggle(keypath) {\n  \tvar _this = this;\n\n  \tif (typeof keypath !== \"string\") {\n  \t\tthrow new TypeError(badArguments);\n  \t}\n\n  \tvar changes = undefined;\n\n  \tif (/\\*/.test(keypath)) {\n  \t\tchanges = {};\n\n  \t\tgetMatchingKeypaths(this, getKeypath(normalise(keypath))).forEach(function (keypath) {\n  \t\t\tchanges[keypath.str] = !_this.viewmodel.get(keypath);\n  \t\t});\n\n  \t\treturn this.set(changes);\n  \t}\n\n  \treturn this.set(keypath, !this.get(keypath));\n  }\n\n  var toHTML = Ractive$toHTML;\n\n  function Ractive$toHTML() {\n  \treturn this.fragment.toString(true);\n  }\n\n  var Ractive_prototype_unrender = Ractive$unrender;\n  var unrenderHook = new hooks_Hook(\"unrender\");\n  function Ractive$unrender() {\n  \tvar promise, shouldDestroy;\n\n  \tif (!this.fragment.rendered) {\n  \t\twarnIfDebug(\"ractive.unrender() was called on a Ractive instance that was not rendered\");\n  \t\treturn utils_Promise.resolve();\n  \t}\n\n  \tpromise = global_runloop.start(this, true);\n\n  \t// If this is a component, and the component isn't marked for destruction,\n  \t// don't detach nodes from the DOM unnecessarily\n  \tshouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\n  \t// Cancel any animations in progress\n  \twhile (this._animations[0]) {\n  \t\tthis._animations[0].stop(); // it will remove itself from the index\n  \t}\n\n  \tthis.fragment.unrender(shouldDestroy);\n\n  \tremoveFromArray(this.el.__ractive_instances__, this);\n\n  \tunrenderHook.fire(this);\n\n  \tglobal_runloop.end();\n  \treturn promise;\n  }\n\n  var unshift = makeArrayMethod(\"unshift\");\n\n  var Ractive_prototype_update = Ractive$update;\n  var updateHook = new hooks_Hook(\"update\");\n  function Ractive$update(keypath) {\n  \tvar promise;\n\n  \tkeypath = getKeypath(keypath) || rootKeypath;\n\n  \tpromise = global_runloop.start(this, true);\n  \tthis.viewmodel.mark(keypath);\n  \tglobal_runloop.end();\n\n  \tupdateHook.fire(this, keypath);\n\n  \treturn promise;\n  }\n\n  var prototype_updateModel = Ractive$updateModel;\n\n  function Ractive$updateModel(keypath, cascade) {\n  \tvar values, key, bindings;\n\n  \tif (typeof keypath === \"string\" && !cascade) {\n  \t\tbindings = this._twowayBindings[keypath];\n  \t} else {\n  \t\tbindings = [];\n\n  \t\tfor (key in this._twowayBindings) {\n  \t\t\tif (!keypath || getKeypath(key).equalsOrStartsWith(keypath)) {\n  \t\t\t\t// TODO is this right?\n  \t\t\t\tbindings.push.apply(bindings, this._twowayBindings[key]);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tvalues = consolidate(this, bindings);\n  \treturn this.set(values);\n  }\n\n  function consolidate(ractive, bindings) {\n  \tvar values = {},\n  \t    checkboxGroups = [];\n\n  \tbindings.forEach(function (b) {\n  \t\tvar oldValue, newValue;\n\n  \t\t// special case - radio name bindings\n  \t\tif (b.radioName && !b.element.node.checked) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// special case - checkbox name bindings come in groups, so\n  \t\t// we want to get the value once at most\n  \t\tif (b.checkboxName) {\n  \t\t\tif (!checkboxGroups[b.keypath.str] && !b.changed()) {\n  \t\t\t\tcheckboxGroups.push(b.keypath);\n  \t\t\t\tcheckboxGroups[b.keypath.str] = b;\n  \t\t\t}\n\n  \t\t\treturn;\n  \t\t}\n\n  \t\toldValue = b.attribute.value;\n  \t\tnewValue = b.getValue();\n\n  \t\tif (arrayContentsMatch(oldValue, newValue)) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (!isEqual(oldValue, newValue)) {\n  \t\t\tvalues[b.keypath.str] = newValue;\n  \t\t}\n  \t});\n\n  \t// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`\n  \tif (checkboxGroups.length) {\n  \t\tcheckboxGroups.forEach(function (keypath) {\n  \t\t\tvar binding, oldValue, newValue;\n\n  \t\t\tbinding = checkboxGroups[keypath.str]; // one to represent the entire group\n  \t\t\toldValue = binding.attribute.value;\n  \t\t\tnewValue = binding.getValue();\n\n  \t\t\tif (!arrayContentsMatch(oldValue, newValue)) {\n  \t\t\t\tvalues[keypath.str] = newValue;\n  \t\t\t}\n  \t\t});\n  \t}\n\n  \treturn values;\n  }\n\n  var prototype = {\n  \tadd: prototype_add,\n  \tanimate: prototype_animate,\n  \tdetach: prototype_detach,\n  \tfind: prototype_find,\n  \tfindAll: prototype_findAll,\n  \tfindAllComponents: prototype_findAllComponents,\n  \tfindComponent: prototype_findComponent,\n  \tfindContainer: findContainer,\n  \tfindParent: findParent,\n  \tfire: prototype_fire,\n  \tget: prototype_get,\n  \tinsert: insert,\n  \tmerge: prototype_merge,\n  \tobserve: observe,\n  \tobserveOnce: observeOnce,\n  \toff: off,\n  \ton: on,\n  \tonce: once,\n  \tpop: pop,\n  \tpush: push,\n  \trender: prototype_render,\n  \treset: prototype_reset,\n  \tresetPartial: resetPartial,\n  \tresetTemplate: resetTemplate,\n  \treverse: reverse,\n  \tset: Ractive_prototype_set,\n  \tshift: shift,\n  \tsort: prototype_sort,\n  \tsplice: splice,\n  \tsubtract: subtract,\n  \tteardown: Ractive_prototype_teardown,\n  \ttoggle: toggle,\n  \ttoHTML: toHTML,\n  \ttoHtml: toHTML,\n  \tunrender: Ractive_prototype_unrender,\n  \tunshift: unshift,\n  \tupdate: Ractive_prototype_update,\n  \tupdateModel: prototype_updateModel\n  };\n\n  var wrapMethod = function (method, superMethod, force) {\n\n  \tif (force || needsSuper(method, superMethod)) {\n\n  \t\treturn function () {\n\n  \t\t\tvar hasSuper = (\"_super\" in this),\n  \t\t\t    _super = this._super,\n  \t\t\t    result;\n\n  \t\t\tthis._super = superMethod;\n\n  \t\t\tresult = method.apply(this, arguments);\n\n  \t\t\tif (hasSuper) {\n  \t\t\t\tthis._super = _super;\n  \t\t\t}\n\n  \t\t\treturn result;\n  \t\t};\n  \t} else {\n  \t\treturn method;\n  \t}\n  };\n\n  function needsSuper(method, superMethod) {\n  \treturn typeof superMethod === \"function\" && /_super/.test(method);\n  }\n\n  var unwrapExtended = unwrap;\n\n  function unwrap(Child) {\n  \tvar options = {};\n\n  \twhile (Child) {\n  \t\taddRegistries(Child, options);\n  \t\taddOtherOptions(Child, options);\n\n  \t\tif (Child._Parent !== _Ractive) {\n  \t\t\tChild = Child._Parent;\n  \t\t} else {\n  \t\t\tChild = false;\n  \t\t}\n  \t}\n\n  \treturn options;\n  }\n\n  function addRegistries(Child, options) {\n  \tconfig_registries.forEach(function (r) {\n  \t\taddRegistry(r.useDefaults ? Child.prototype : Child, options, r.name);\n  \t});\n  }\n\n  function addRegistry(target, options, name) {\n  \tvar registry,\n  \t    keys = Object.keys(target[name]);\n\n  \tif (!keys.length) {\n  \t\treturn;\n  \t}\n\n  \tif (!(registry = options[name])) {\n  \t\tregistry = options[name] = {};\n  \t}\n\n  \tkeys.filter(function (key) {\n  \t\treturn !(key in registry);\n  \t}).forEach(function (key) {\n  \t\treturn registry[key] = target[name][key];\n  \t});\n  }\n\n  function addOtherOptions(Child, options) {\n  \tObject.keys(Child.prototype).forEach(function (key) {\n  \t\tif (key === \"computed\") {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar value = Child.prototype[key];\n\n  \t\tif (!(key in options)) {\n  \t\t\toptions[key] = value._method ? value._method : value;\n  \t\t}\n\n  \t\t// is it a wrapped function?\n  \t\telse if (typeof options[key] === \"function\" && typeof value === \"function\" && options[key]._method) {\n\n  \t\t\tvar result = undefined,\n  \t\t\t    needsSuper = value._method;\n\n  \t\t\tif (needsSuper) {\n  \t\t\t\tvalue = value._method;\n  \t\t\t}\n\n  \t\t\t// rewrap bound directly to parent fn\n  \t\t\tresult = wrapMethod(options[key]._method, value);\n\n  \t\t\tif (needsSuper) {\n  \t\t\t\tresult._method = result;\n  \t\t\t}\n\n  \t\t\toptions[key] = result;\n  \t\t}\n  \t});\n  }\n\n  var _extend = _extend__extend;\n\n  function _extend__extend() {\n  \tfor (var _len = arguments.length, options = Array(_len), _key = 0; _key < _len; _key++) {\n  \t\toptions[_key] = arguments[_key];\n  \t}\n\n  \tif (!options.length) {\n  \t\treturn extendOne(this);\n  \t} else {\n  \t\treturn options.reduce(extendOne, this);\n  \t}\n  }\n\n  function extendOne(Parent) {\n  \tvar options = arguments[1] === undefined ? {} : arguments[1];\n\n  \tvar Child, proto;\n\n  \t// if we're extending with another Ractive instance...\n  \t//\n  \t//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);\n  \t//   var Spiderman = Human.extend( Spider );\n  \t//\n  \t// ...inherit prototype methods and default options as well\n  \tif (options.prototype instanceof _Ractive) {\n  \t\toptions = unwrapExtended(options);\n  \t}\n\n  \tChild = function (options) {\n  \t\tif (!(this instanceof Child)) return new Child(options);\n  \t\tinitialise(this, options);\n  \t};\n\n  \tproto = create(Parent.prototype);\n  \tproto.constructor = Child;\n\n  \t// Static properties\n  \tdefineProperties(Child, {\n  \t\t// alias prototype as defaults\n  \t\tdefaults: { value: proto },\n\n  \t\t// extendable\n  \t\textend: { value: _extend__extend, writable: true, configurable: true },\n\n  \t\t// Parent - for IE8, can't use Object.getPrototypeOf\n  \t\t_Parent: { value: Parent }\n  \t});\n\n  \t// extend configuration\n  \tconfig_config.extend(Parent, proto, options);\n\n  \tcustom_data.extend(Parent, proto, options);\n\n  \tif (options.computed) {\n  \t\tproto.computed = utils_object__extend(create(Parent.prototype.computed), options.computed);\n  \t}\n\n  \tChild.prototype = proto;\n\n  \treturn Child;\n  }\n\n  var getNodeInfo = function (node) {\n  \tvar info = {},\n  \t    priv,\n  \t    indices;\n\n  \tif (!node || !(priv = node._ractive)) {\n  \t\treturn info;\n  \t}\n\n  \tinfo.ractive = priv.root;\n  \tinfo.keypath = priv.keypath.str;\n  \tinfo.index = {};\n\n  \t// find all index references and resolve them\n  \tif (indices = Resolvers_findIndexRefs(priv.proxy.parentFragment)) {\n  \t\tinfo.index = Resolvers_findIndexRefs.resolve(indices);\n  \t}\n\n  \treturn info;\n  };\n\n  var Ractive, properties;\n\n  // Main Ractive required object\n  Ractive = function (options) {\n  \tif (!(this instanceof Ractive)) return new Ractive(options);\n  \tinitialise(this, options);\n  };\n\n  // Ractive properties\n  properties = {\n\n  \t// debug flag\n  \tDEBUG: { writable: true, value: true },\n  \tDEBUG_PROMISES: { writable: true, value: true },\n\n  \t// static methods:\n  \textend: { value: _extend },\n  \tgetNodeInfo: { value: getNodeInfo },\n  \tparse: { value: _parse },\n\n  \t// Namespaced constructors\n  \tPromise: { value: utils_Promise },\n\n  \t// support\n  \tsvg: { value: svg },\n  \tmagic: { value: environment__magic },\n\n  \t// version\n  \tVERSION: { value: \"0.7.3\" },\n\n  \t// Plugins\n  \tadaptors: { writable: true, value: {} },\n  \tcomponents: { writable: true, value: {} },\n  \tdecorators: { writable: true, value: {} },\n  \teasing: { writable: true, value: static_easing },\n  \tevents: { writable: true, value: {} },\n  \tinterpolators: { writable: true, value: static_interpolators },\n  \tpartials: { writable: true, value: {} },\n  \ttransitions: { writable: true, value: {} }\n  };\n\n  // Ractive properties\n  defineProperties(Ractive, properties);\n\n  Ractive.prototype = utils_object__extend(prototype, config_defaults);\n\n  Ractive.prototype.constructor = Ractive;\n\n  // alias prototype as defaults\n  Ractive.defaults = Ractive.prototype;\n\n  // Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n  // older browsers, these are made available via a shim - here, we do a quick\n  // pre-flight check to make sure that either a) we're not in a shit browser,\n  // or b) we're using a Ractive-legacy.js build\n  var FUNCTION = \"function\";\n\n  if (typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== \"undefined\" && typeof window.addEventListener !== FUNCTION) {\n  \tthrow new Error(\"It looks like you're attempting to use Ractive.js in an older browser. You'll need to use one of the 'legacy builds' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.\");\n  }\n\n  var _Ractive = Ractive;\n\n  return _Ractive;\n\n}));\n//# sourceMappingURL=ractive.js.map\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ractive/ractive.js\n ** module id = 7\n ** module chunks = 0\n **/","var FSM = require('fsm')\n\nvar defaultHardware = {\n\tcabinWeight: 200,\n\ttractionForce: 2,\n\tcounterWeight: 200,\n\tdoors: {\n\t\topeningDuration:200,\n\t\tclosingDuration:200,\n\t}\n}\n\nvar doorsStates = {CLOSE:-1, OPEN:1}\n\nvar CabinFSM = FSM.extend('CabinFSM', {\n\n\thardware: defaultHardware,\n\topenAwaitingTime: 300,\t // default time with the doors left open\n\tclosedAwaitingTime: 300, // default time after doors close before set destination & move\n\tdoorsStates: doorsStates,\n\tstate: {}, // state is a custom object\n\tdoorsState: doorsStates.CLOSE,\n\n\tinitialize: function(control) {\n\t\tconsole.log('CabinFSM initialize args', arguments)\n\t\tthis.control = control // control is the elevator main controller\n\t\t// at the beginning, doors are close and the cabin is stopped, so we can\n\t\t// just call 'idle'\n\t\treturn this.next(this.idle)\n\t},\n\n\tidle: function() {\n\t\treturn this.receive('wakeup', this.onWakeUp)\n\t\t._(function(anyMessage){\n\t\t\tconsole.log('CabinFSM received unattended message : ', anyMessage)\n\t\t\treturn this.next(this.idle,100)\n\t\t})\n\t},\n\n\tonWakeUp: function() {\n\t\t// we could have received many 'wakeup' messages so we flush them\n\t\treturn this.receive('wakeup', this.onWakeUp) // we loop for all wakeup messages\n\t\t.after(0, function(){\n\t\t\t// and now we can do the real work\n\n\t\t\tvar nextDest = this.control.getNextDestination()\n\t\t\tif (! nextDest) {\n\t\t\t\t// no destination, just loop\n\t\t\t\tconsole.log('no destination to go')\n\t\t\t\treturn this.next(this.idle)\n\t\t\t} else {\n\t\t\t\tconsole.log('Cabin going to destination %s (@todo)', nextDest)\n\t\t\t\treturn this.exit()\n\t\t\t}\n\t\t})\n\t}\n})\n\n// -- helpers (stateless) -----------------------------------------------------\n\n/**\n * Returns the travel time for 1 storey at full speed, according to the\n * direction\n */\nfunction storeyTravelDuration(direction, hardware) {\n\tif (direction === direction.UP) return 1000\n\telse return 1200\n\t// @todo use hardware.cabinWeight, hardware.tractionForce, hardware.counterWeight\n}\n\n\nmodule.exports = CabinFSM\n\n\n\n/** WEBPACK FOOTER **\n ** ./app/js/cabinfsm.js\n **/","var escapeRegExp = require('../string/escapeRegExp'),\n    isObjectLike = require('../internal/isObjectLike');\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]';\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/**\n * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  escapeRegExp(objToString)\n  .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (objToString.call(value) == funcTag) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = isNative;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/lang/isNative.js\n ** module id = 9\n ** module chunks = 0\n **/","/**\n * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/isLength.js\n ** module id = 10\n ** module chunks = 0\n **/","/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type == 'function' || (!!value && type == 'object');\n}\n\nmodule.exports = isObject;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/lang/isObject.js\n ** module id = 11\n ** module chunks = 0\n **/","/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/isObjectLike.js\n ** module id = 12\n ** module chunks = 0\n **/","var isLength = require('../internal/isLength'),\n    isNative = require('./isNative'),\n    isObjectLike = require('../internal/isObjectLike');\n\n/** `Object#toString` result references. */\nvar arrayTag = '[object Array]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray;\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(function() { return arguments; }());\n * // => false\n */\nvar isArray = nativeIsArray || function(value) {\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n};\n\nmodule.exports = isArray;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/lang/isArray.js\n ** module id = 13\n ** module chunks = 0\n **/","var isArrayLike = require('../internal/isArrayLike'),\n    isNative = require('../lang/isNative'),\n    isObject = require('../lang/isObject'),\n    shimKeys = require('../internal/shimKeys');\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)\n * for more details.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nvar keys = !nativeKeys ? shimKeys : function(object) {\n  var Ctor = object != null && object.constructor;\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n      (typeof object != 'function' && isArrayLike(object))) {\n    return shimKeys(object);\n  }\n  return isObject(object) ? nativeKeys(object) : [];\n};\n\nmodule.exports = keys;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/object/keys.js\n ** module id = 14\n ** module chunks = 0\n **/","var isObject = require('../lang/isObject');\n\n/**\n * Converts `value` to an object if it is not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Object} Returns the object.\n */\nfunction toObject(value) {\n  return isObject(value) ? value : Object(value);\n}\n\nmodule.exports = toObject;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/toObject.js\n ** module id = 15\n ** module chunks = 0\n **/","/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new function.\n * @example\n *\n * var object = { 'user': 'fred' };\n * var getter = _.constant(object);\n *\n * getter() === object;\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/utility/constant.js\n ** module id = 16\n ** module chunks = 0\n **/","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/timers-browserify/main.js\n ** module id = 17\n ** module chunks = 0\n **/","var arrayCopy = require('./arrayCopy'),\n    arrayEach = require('./arrayEach'),\n    baseAssign = require('./baseAssign'),\n    baseForOwn = require('./baseForOwn'),\n    initCloneArray = require('./initCloneArray'),\n    initCloneByTag = require('./initCloneByTag'),\n    initCloneObject = require('./initCloneObject'),\n    isArray = require('../lang/isArray'),\n    isObject = require('../lang/isObject');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[boolTag] =\ncloneableTags[dateTag] = cloneableTags[float32Tag] =\ncloneableTags[float64Tag] = cloneableTags[int8Tag] =\ncloneableTags[int16Tag] = cloneableTags[int32Tag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[stringTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[mapTag] = cloneableTags[setTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * The base implementation of `_.clone` without support for argument juggling\n * and `this` binding `customizer` functions.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {Function} [customizer] The function to customize cloning values.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The object `value` belongs to.\n * @param {Array} [stackA=[]] Tracks traversed source objects.\n * @param {Array} [stackB=[]] Associates clones with source counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, customizer, key, object, stackA, stackB) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return arrayCopy(value, result);\n    }\n  } else {\n    var tag = objToString.call(value),\n        isFunc = tag == funcTag;\n\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return baseAssign(result, value);\n      }\n    } else {\n      return cloneableTags[tag]\n        ? initCloneByTag(value, tag, isDeep)\n        : (object ? value : {});\n    }\n  }\n  // Check for circular references and return corresponding clone.\n  stackA || (stackA = []);\n  stackB || (stackB = []);\n\n  var length = stackA.length;\n  while (length--) {\n    if (stackA[length] == value) {\n      return stackB[length];\n    }\n  }\n  // Add the source value to the stack of traversed objects and associate it with its clone.\n  stackA.push(value);\n  stackB.push(result);\n\n  // Recursively populate clone (susceptible to call stack limits).\n  (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {\n    result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/baseClone.js\n ** module id = 18\n ** module chunks = 0\n **/","var getLength = require('./getLength'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\nmodule.exports = isArrayLike;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/isArrayLike.js\n ** module id = 19\n ** module chunks = 0\n **/","/**\n * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = +value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\nmodule.exports = isIndex;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/isIndex.js\n ** module id = 20\n ** module chunks = 0\n **/","var isArrayLike = require('../internal/isArrayLike'),\n    isObjectLike = require('../internal/isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as an `arguments` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  return isObjectLike(value) && isArrayLike(value) && objToString.call(value) == argsTag;\n}\n\nmodule.exports = isArguments;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/lang/isArguments.js\n ** module id = 21\n ** module chunks = 0\n **/","/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to detect DOM support. */\nvar document = (document = global.window) && document.document;\n\n/** Native method references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * An object environment feature flags.\n *\n * @static\n * @memberOf _\n * @type Object\n */\nvar support = {};\n\n(function(x) {\n  var Ctor = function() { this.x = x; },\n      args = arguments,\n      object = { '0': x, 'length': x },\n      props = [];\n\n  Ctor.prototype = { 'valueOf': x, 'y': x };\n  for (var key in new Ctor) { props.push(key); }\n\n  /**\n   * Detect if functions can be decompiled by `Function#toString`\n   * (all but Firefox OS certified apps, older Opera mobile browsers, and\n   * the PlayStation 3; forced `false` for Windows 8 apps).\n   *\n   * @memberOf _.support\n   * @type boolean\n   */\n  support.funcDecomp = /\\bthis\\b/.test(function() { return this; });\n\n  /**\n   * Detect if `Function#name` is supported (all but IE).\n   *\n   * @memberOf _.support\n   * @type boolean\n   */\n  support.funcNames = typeof Function.name == 'string';\n\n  /**\n   * Detect if the DOM is supported.\n   *\n   * @memberOf _.support\n   * @type boolean\n   */\n  try {\n    support.dom = document.createDocumentFragment().nodeType === 11;\n  } catch(e) {\n    support.dom = false;\n  }\n\n  /**\n   * Detect if `arguments` object indexes are non-enumerable.\n   *\n   * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object\n   * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat\n   * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`\n   * checks for indexes that exceed the number of function parameters and\n   * whose associated argument values are `0`.\n   *\n   * @memberOf _.support\n   * @type boolean\n   */\n  try {\n    support.nonEnumArgs = !propertyIsEnumerable.call(args, 1);\n  } catch(e) {\n    support.nonEnumArgs = true;\n  }\n}(1, 0));\n\nmodule.exports = support;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/support.js\n ** module id = 22\n ** module chunks = 0\n **/","var extend = require('extend')\nvar BaseClass = require('base-class-extend')\nvar _ = {\n\tisFinite: require('lodash/lang/isFinite'),\n\tmatches: require('lodash/utility/matches'),\n\tcloneDeep: require('lodash/lang/cloneDeep')\n}\nvar spawn = setImmediate // freezes too much\n// var spawn = requestAnimationFrame // too slow\n// var spawn = setTimeout // mid slow, useless timers\n// var spawnNoFail = function(f){setTimeout(f,0)}\n// var Promise = require('es6-promise').Promise\n\nfunction noop() { /* hi ! */ }\n\nfunction strictIsEqualTo(a) {\n\treturn function(b) {\n\t\treturn a === b\n\t}\n}\n\nvar gid = (function () {\n\tvar gid = 0\n\treturn function() {\n\t\treturn ++gid\n\t}\n})\n\nvar DEBUG_INCREMENT = 0\n\nvar ttrace = function() {\n\tvar args = ['%c#'+ DEBUG_INCREMENT++]\n\t\t.concat('color:#aaa')\n\t\t.concat(Array.prototype.slice.call(arguments))\n\tconsole.log.apply(console, args)\n}\n\nttrace = noop\n\nfunction alwaysTrue() { return true }\n\n/*******************************************************************************\n\n\tHow it works\n\n\tThe user provides an `initialize` function. This function is wrapped into a\n\t`Next` object and passed to `handleContinuation` which accepts wrappers.\n\n\t`handleContinuation` checks that it is actually a wrapper and calls `.run()` on the\n\twrapper, passing proc context (the value of 'this' in the wrapped\n\tfunction'). Wrappers must return promises. Then, `handleContinuation` send the\n\tresponse from `wrapper.run()` to `proc.__loop()` which accepts promises.\n\t`proc.__loop()` calls `.then()` on the promise with a callback that accepts a\n\twrapper and send it to `handleContinuation`. Now, go back to the beginning of this\n\tparagraph and read again.\n\n*******************************************************************************/\n\nvar Proc = BaseClass.extend('Proc', {\n\tconstructor: function(init, initArgs) {\n\t\tvar opts = typeof init === 'function' ? {initialize:init} : init\n\t\textend(this, opts)\n\t\tthis.__mailbox = new Mailbox()\n\t\tthis.client = new Client(this.__mailbox)\n\t\t// initialization is synchronous\n\t\tvar handle = this.initialize.apply(this, initArgs)\n\t\tvar self = this\n\t\tspawn(function(){\n\t\t\tself.handleContinuation(handle)\n\t\t})\n\t},\n\n\tinitialize: function(){\n\t\tthrow new Error(\"The 'initialize' method is mandatory.\")\n\t},\n\n\t__loop: function(promise) {\n\t\t// ttrace('__loop', promise)\n\t\tvar self = this\n\t\tpromise.then(function(val){\n\t\t\tself.handleContinuation(val)\n\t\t}).catch(function(err){\n\t\t\tconsole.error(err.stack)\n\t\t\tthrow err\n\t\t})\n\t},\n\n\thandleContinuation: function(wrapper) {\n\t\t// ttrace('handleContinuation', wrapper)\n\t\tif (wrapper instanceof Next || wrapper instanceof Receive) {\n\t\t\treturn this.__loop(wrapper.run(this))\n\t\t} else if (wrapper instanceof Exit) {\n\t\t\t// we stop here\n\t\t\treturn\n\t\t} else {\n\t\t\tconsole.error(wrapper, 'is not a valid wrapper')\n\t\t}\n\t},\n\n\tnext: function(fun, time) {\n\t\tttrace('next time', time)\n\t\treturn new Next(fun, time)\n\t},\n\n\texit: function() {\n\t\treturn new Exit()\n\t},\n\n\treceive: function(pattern, fun) {\n\t\treturn new Receive(this.__mailbox).receive(pattern, fun)\n\t},\n\n\treceiveAny: function(fun) {\n\t\treturn new Receive(this.__mailbox)._(fun)\n\t},\n\n\t// This function allows the user to perform async work and then call the\n\t// resolve function passing the new continuation function. Then we use a\n\t// Next wrapper to turn the continuation fun into a promise (and thus force\n\t// spawn)\n\tasync: function(fun) {\n\t\tvar bound = fun.bind(this)\n\t\tvar self = this\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tvar next = function(f, time) {\n\t\t\t\tresolve([f,time])\n\t\t\t}\n\t\t\tbound(next)\n\t\t}).then(function(data){\n\t\t\treturn self.next(data[0],data[1])\n\t\t})\n\t}\n})\n\n\n// Override the extend functionnality to automatically spawn, and inherit the\n// overrident extend fun\n\n// var baseProcExtend = Proc.extend\n// Proc.extend = function() {\n// \tvar newClass = baseProcExtend.apply(this,arguments)\n// \tnewClass.spawn = Proc.spawner(newClass)\n// \tnewClass.extend = Proc.extend\n// \treturn newClass\n// }\n\n// -- Promise wrappers --------------------------------------------------------\n\nfunction Exit() {}\n\nfunction Next(fun, time) {\n\tthis.fun = fun\n\tthis.time = time\n}\n\nNext.prototype.run = function (context) {\n\tvar bound = this.fun.bind(context), self = this\n\treturn new Promise(function(resolve, reject){\n\t\tvar work = function(){ resolve(bound()) }\n\t\t// -- Asynchronicity is forced here since .next receives the optional\n\t\t// time parameter\n\t\tif (self.time > 0) setTimeout(work, self.time)\n\t\telse spawn(work)\n\t})\n}\n\nfunction Receive(mailbox, time) {\n\tthis.mailbox = mailbox\n\tthis.clauses = []\n\tthis.afterClause = undefined\n\tvar self = this\n}\n\nReceive.prototype.receive = function (pattern, callback) {\n\tvar predicate = this.getPredicateFunction(pattern)\n\tthis.clauses.push([predicate, callback])\n\treturn this\n}\n\n// matches anything (wildcard)\nReceive.prototype._ = function (callback) {\n\tvar predicate = alwaysTrue\n\tthis.clauses.push([alwaysTrue, callback])\n\treturn this\n}\n\nReceive.prototype._ = function (callback) {\n\treturn this.receive(alwaysTrue, callback)\n}\n\nReceive.prototype.getPredicateFunction = function (pattern) {\n\tvar predicate = this.REAL_getPredicateFunction(pattern)\n\treturn function(t) {\n\t\tvar matched = predicate(t)\n\t\tttrace(pattern, matched ? ' matches ' : ' does not matches ', t)\n\t\treturn matched\n\t}\n}\n\nReceive.prototype.REAL_getPredicateFunction = function (pattern) {\n\tswitch (typeof pattern) {\n\t\tcase 'object':\n\t\t\treturn _.matches(pattern)\n\t\tcase 'function':\n\t\t\treturn pattern // if already a predicate, just use it\n\t\tdefault:\n\t\t\treturn strictIsEqualTo(pattern)\n\t}\n}\n//\tthis.chain = this.chain.then(function(acc){\n//\t\t// if previous clause has found a message, just pass the context through\n//\t\tif (acc.matched) return acc\n\n//\t\t// if no message is found, udefined is returned\n//\t\tvar message = acc.mailbox.match(pattern)\n//\t\tif (message !== void 0) {\n//\t\t\tttrace('receive clause succeeded')\n//\t\t\treturn extend(acc,{matched:true, message:message, callback:callback})\n//\t\t} else {\n//\t\t\tttrace('receive clause failed')\n//\t\t\tacc.failedClauses.push([pattern,callback])\n//\t\t\treturn acc\n//\t\t}\n//\t})\n//\treturn this\n// }\n\nReceive.prototype.after = function (timeout, callback) {\n\tthis.afterClause = [timeout, callback]\n\treturn this\n}\n\nReceive.prototype.run = function (callbackContext) {\n\tttrace('Receive run')\n\tif (! this.afterClause) {\n\t\t// if no .after clause has been set, we set one with Infinity as a\n\t\t// timeout\n\t\tttrace('auto setting infinity clause')\n\t\tthis.after(Infinity)\n\t}\n\t// we send all the clauses to the mailbox which knows how to handle them (we\n\t// should define an interface because this violates encapsulation ?)\n\n\t// The mailbox returns a promise resulting in a match context with the\n\t// message and the associated callback\n\treturn this.mailbox.withMatch(this.clauses, this.afterClause[0], this.afterClause[1])\n\t\t.then(function(matchContext){\n\t\t\treturn new Next(function(){\n\t\t\t\tttrace('match context', matchContext)\n\t\t\t\t// we call the user callback, bound to the proc context, passing\n\t\t\t\t// the message. The callback must return a wrapper (this.next(),\n\t\t\t\t// this.receive(), ...)\n\t\t\t\t// if a timeout occured, the message is undefined\n\t\t\t\treturn matchContext.callback.bind(callbackContext)(matchContext.message)\n\t\t\t})\n\t\t})\n}\n\n// -- Mailbox -----------------------------------------------------------------\n\nfunction Mailbox() {\n\tthis.stack = []\n\tthis.onMessage = false\n}\n\nMailbox.prototype.push = function (message) {\n\n\tttrace('mailbox push called', message)\n\t// we check if a message handler is set. If yes, we only stack the message\n\t// if the handler returns falsy (message NOT consumed)\n\tif (!this.onMessage || !this.onMessage(message)) {\n\t\tthis.stack.push(message)\n\t}\n}\n\n// accepts a clauses array such as defined per Receiv & returns a match context\n// or undefined\nMailbox.prototype.withMatch = function (clauses, timeout, timeoutCallback) {\n\tttrace('withMatch mailbox stack', this.stack)\n\tvar slen = this.stack.length,\n\t    clen = clauses.length,\n\t    message,\n\t    clause,\n\t    predicate,\n\t    callback,\n\t    i,\n\t    j,\n\t    self = this\n\tfor (i = 0; i < slen; i++) {\n\t\tmessage = this.stack[i]\n\t\tttrace('test message', message)\n\t\tfor (j = 0; j < clen; j++) {\n\t\t\tclause = clauses[j]\n\t\t\tpredicate = clause[0]\n\t\t\tcallback = clause[1]\n\t\t\tif (predicate(message)) {\n\t\t\t\t// we found a matching message. We delete it\n\t\t\t\tthis.stack.splice(i,1)\n\t\t\t\treturn Promise.resolve({\n\t\t\t\t\tmatched: true,\n\t\t\t\t\tmessage:message,\n\t\t\t\t\tcallback:callback\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\t// we did not find a matching message. we will set a timeout and resolve it\n\t// as soon as we receive a matching message\n\n\t// onMessage should not be bound since the Receive promise wrapper should\n\t// not be resolved until the following code is executed (or if the previous\n\t// search matcses, onMessage won't be bound)\n\tif (this.onMessage) {\n\t\tconsole.error('onMessage already bound') //@todo remove this line\n\t\tthrow new Error('mailbox onMessage already bound')\n\t}\n\n\n\tvar timer\n\n\treturn new Promise(function(resolve, reject){\n\t\tself.onMessage = function(message){\n\t\t\tttrace('mailbox onMessage called')\n\t\t\t// when we get a message, we check for the clauses to match\n\t\t\tfor (j = 0; j < clen; j++) {\n\t\t\t\tclause = clauses[j]\n\t\t\t\tpredicate = clause[0]\n\t\t\t\tcallback = clause[1]\n\t\t\t\tif (predicate(message)) {\n\t\t\t\t\tself.onMessage = false\n\t\t\t\t\t// a clearTimeout should be useless as the promise can only\n\t\t\t\t\t// be resolved once ; but doing so we dicard any debug trace\n\t\t\t\t\t// in the timeout callback. (@todo in production, no debug\n\t\t\t\t\t// => no clearTimeout)\n\t\t\t\t\tclearTimeout(timer)\n\t\t\t\t\tresolve({\n\t\t\t\t\t\tmatched: true,\n\t\t\t\t\t\tmessage:message,\n\t\t\t\t\t\tcallback:callback\n\t\t\t\t\t})\n\t\t\t\t\t// we return true, which means that the message will not be\n\t\t\t\t\t// pushed on the stack (as we use it now)\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\t\t// set the onmessage listener. If the timeout is 0, a matching message has already be\n\t\tif (_.isFinite(timeout)) {\n\t\t\t// if the timeout occurs, we resolve the Promise with the associated\n\t\t\t// callback and an undefined message\n\t\t\tttrace('waiting for ' + timeout)\n\t\t\tvar resolveTimeout = function(){\n\t\t\t\tself.onMessage = false\n\t\t\t\tresolve({\n\t\t\t\t\tmatched: false,\n\t\t\t\t\tmessage:undefined,\n\t\t\t\t\tcallback:timeoutCallback\n\t\t\t\t})\n\t\t\t}\n\t\t\t// if timeout is 0 we resolve synchronously\n\t\t\tif (timeout > 0) timer = setTimeout(resolveTimeout, timeout)\n\t\t\telse /* timeout === 0 */ resolveTimeout()\n\t\t}\n\t})\n}\n\n\n// -- Client -----------------------------------------------------------------\n\nfunction Client(mailbox) {\n\tthis.mailbox = mailbox\n}\n\nClient.prototype.send = function (message) {\n\tvar self = this\n\t// @todo _.cloneDeep overkill ?\n\tttrace('send message',message)\n\t// the message will be received asynchronously (spawn)\n\tspawn(function(){ self.mailbox.push(_.cloneDeep(message)) })\n}\n\n// -- API ---------------------------------------------------------------------\n\nProc.spawn = function(init, initArgs) {\n\tvar constructor = this\n\tvar proc = new constructor(init, initArgs)\n\tproc.client.__proc = proc\n\treturn proc.client\n}\n\nmodule.exports = Proc\n\n\n\n/** WEBPACK FOOTER **\n ** ./app/js/fsm.js\n **/","// base-class-extend.js\r\n\r\n(function () {\r\n  'use strict';\r\n\r\n  // setConst(obj, prop, val)\r\n  var setConst = Object.defineProperty ?\r\n    function setConst(obj, prop, val) {\r\n      Object.defineProperty(obj, prop, {value: val}); } :\r\n    function setConst(obj, prop, val) { obj[prop] = val; };\r\n\r\n  // setValue(obj, prop, val)\r\n  var setValue = Object.defineProperty ?\r\n    function setValue(obj, prop, val) {\r\n      Object.defineProperty(obj, prop, {value: val,\r\n        writable: true, configurable: true}); } :\r\n    function setValue(obj, prop, val) { obj[prop] = val; };\r\n\r\n  // setProto(obj, proto)\r\n  var setProto = Object.setPrototypeOf ? Object.setPrototypeOf :\r\n    function setProto(obj, proto) { obj.__proto__ = proto; };\r\n\r\n  // getProto(obj)\r\n  var getProto = Object.getPrototypeOf ? Object.getPrototypeOf :\r\n    function getProto(obj) { return obj.__proto__; };\r\n\r\n  // fnameRegExp: function name regular expression\r\n  var fnameRegExp = /^\\s*function\\s*\\**\\s*([^\\(\\s]*)[\\S\\s]+$/im;\r\n\r\n  // fname: get function name\r\n  function fname() {\r\n    return ('' + this).replace(fnameRegExp, '$1');\r\n  }\r\n\r\n  // Function.prototype.name\r\n  if (!Function.prototype.hasOwnProperty('name')) {\r\n    if (Object.defineProperty)\r\n      Object.defineProperty(Function.prototype, 'name', {get: fname});\r\n    else if (Object.prototype.__defineGetter__)\r\n      Function.prototype.__defineGetter__('name', fname);\r\n  }\r\n\r\n  // Base.extend([name], [proto], [staticProps])\r\n  // Usage:\r\n  //    var SimpleClass =\r\n  //        Base.extend(\r\n  //          {new: function SimpleClass() {\r\n  //                  SimpleClass.super_.call(this);\r\n  //                  this.prop1 = 'val'; },\r\n  //           method1: function method1() {},\r\n  //           get prop1() { return this._prop1; },\r\n  //           set prop1(val) { this._prop1 = val; }},\r\n  //          {classMethod1: function () {}});\r\n  function Base_extend(name, proto, staticProps) {\r\n    // check argument: name\r\n    if (typeof name !== 'string') {\r\n      staticProps = proto;\r\n      proto = name;\r\n      name = '';\r\n    }\r\n\r\n    if (!proto || typeof proto !== 'object') proto = {};\r\n    var superCtor = typeof this === 'function' ? this : Object;\r\n\r\n    var ctor = proto.hasOwnProperty('constructor') ? proto.constructor :\r\n               proto.hasOwnProperty('new')         ? proto['new'] :\r\n      Function('proto, superCtor, Base_create',\r\n        'return function ' + name + '() {\\n' +\r\n        '  \"use strict\";' +\r\n        '  if (!(this instanceof proto.constructor) ||\\n' +\r\n        '      this instanceof Array && !this.hasOwnProperty(\"length\") ||\\n' +\r\n        '      this instanceof Error && !this.hasOwnProperty(\"message\"))\\n' +\r\n        '    return Base_create.apply(proto.constructor, arguments);\\n' +\r\n        '  if (superCtor !== Object && superCtor !== Array && superCtor !== Error)\\n' +\r\n        '    superCtor.apply(this, arguments); }')\r\n        (proto, superCtor, Base_create);\r\n    if (typeof ctor !== 'function')\r\n      throw new TypeError('constructor must be a function');\r\n    if (!ctor.name && name !== '') {\r\n      ctor.prototype = proto;\r\n      ctor = Function('proto, ctor, Base_create',\r\n        'return function ' + name + '() {\\n' +\r\n        '  \"use strict\";' +\r\n        '  if (!(this instanceof proto.constructor) ||\\n' +\r\n        '      this instanceof Array && !this.hasOwnProperty(\"length\") ||\\n' +\r\n        '      this instanceof Error && !this.hasOwnProperty(\"message\"))\\n' +\r\n        '    return Base_create.apply(proto.constructor, arguments);\\n' +\r\n        '  ctor.apply(this, arguments); }')\r\n        (proto, ctor, Base_create);\r\n    }\r\n    ctor.prototype = proto;\r\n\r\n    // override constructor\r\n    delete proto['new'];\r\n    setValue(proto, 'constructor', ctor);\r\n\r\n    // inherits from super constructor\r\n    setProto(proto, superCtor.prototype);\r\n\r\n    // constructor.__proto__ -> for inherits class methods\r\n    if (staticProps == null || typeof staticProps !== 'object') {\r\n      setProto(ctor, superCtor === Object ? Function.prototype : superCtor);\r\n    }\r\n    else {\r\n      setProto(ctor, staticProps);\r\n      setProto(staticProps, superCtor === Object ? Function.prototype : superCtor);\r\n\r\n      // class initializer: init\r\n      var init = staticProps.hasOwnProperty('init') && staticProps.init;\r\n      delete staticProps.init;\r\n      if (typeof init === 'function') init.call(ctor);\r\n\r\n      // add name to methods/functions if not found\r\n      var keys = Object.keys(staticProps);\r\n      for (var i = 0, n = keys.length; i < n; ++i) {\r\n        var key = keys[i];\r\n        if (typeof staticProps[key] === 'function' &&\r\n            !staticProps[key].name) {\r\n          staticProps[key] = Function('fn',\r\n            'return function ' + key + '_() {\\n' +\r\n            '  return fn.apply(this, arguments); }')\r\n            (staticProps[key]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // add methods and class methods if not found (in prototype chain)\r\n    if (ctor.extend !== Base_extend) ctor.extend = Base_extend;\r\n    if (ctor.create !== Base_create) ctor.create = Base_create;\r\n    if (ctor['new'] !== Base_create) ctor['new'] = Base_create;\r\n\r\n    if (!('private'      in proto)) proto['private']      = Base_addPrototype;\r\n    if (!('addPrototype' in proto)) proto['addPrototype'] = Base_addPrototype;\r\n\r\n    // constructor.super_ -> for points super class\r\n    setConst(ctor, 'super_', superCtor);\r\n    setConst(ctor, 'super', superCtor);\r\n\r\n    return ctor;\r\n  }\r\n\r\n  // Base.new(...args) or Base.create(...args)\r\n  function Base_create() {\r\n    if (this.prototype instanceof Array) {\r\n      var obj = Array.apply(null, arguments);\r\n      setProto(obj, this.prototype);\r\n    }\r\n    else if (this.prototype instanceof Error) {\r\n      var obj = Error.apply(null, arguments);\r\n      if (!obj.hasOwnProperty('message') &&\r\n          typeof arguments[0] === 'string')\r\n        obj.message = arguments[0];\r\n      if (typeof obj.stack === 'string')\r\n        obj.stack = obj.stack.split('\\n').filter(function (str) {\r\n          return !/((base-class.js)|(Base_create))/.test(str);\r\n        }).join('\\n');\r\n      setProto(obj, this.prototype);\r\n    }\r\n    else\r\n      var obj = Object.create(this.prototype);\r\n    return this.apply(obj, arguments), obj;\r\n  }\r\n\r\n  // Base.addPrototype(proto)\r\n  function Base_addPrototype(proto) {\r\n    setProto(proto, getProto(this));\r\n    setProto(this, proto);\r\n    return proto;\r\n  }\r\n\r\n  // Base.extendPrototype([ctor = Function])\r\n  function Base_extendPrototype(ctor) {\r\n    if (typeof ctor !== 'function') ctor = Function.prototype;\r\n    ctor.extend = Base_extend;\r\n    return this;\r\n  }\r\n\r\n  var Base = Base_extend('Base',\r\n                    {'private':       Base_addPrototype,\r\n                     addPrototype :   Base_addPrototype},\r\n                    {extend:          Base_extend,\r\n                     create:          Base_create,\r\n                     'new':           Base_create,\r\n                     extendPrototype: Base_extendPrototype});\r\n\r\n\r\n  // exports\r\n  if (typeof module !== 'undefined') {\r\n    module.exports = exports = Base;\r\n  }\r\n  else {\r\n    var g = Function('return this')();\r\n    g.BaseClass = Base;\r\n  }\r\n\r\n})();\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/base-class-extend/lib/base-class-extend.js\n ** module id = 24\n ** module chunks = 0\n **/","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction arrayCopy(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayCopy;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/arrayCopy.js\n ** module id = 25\n ** module chunks = 0\n **/","/**\n * A specialized version of `_.forEach` for arrays without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/arrayEach.js\n ** module id = 26\n ** module chunks = 0\n **/","var baseCopy = require('./baseCopy'),\n    getSymbols = require('./getSymbols'),\n    isNative = require('../lang/isNative'),\n    keys = require('../object/keys');\n\n/** Native method references. */\nvar preventExtensions = isNative(preventExtensions = Object.preventExtensions) && preventExtensions;\n\n/** Used as `baseAssign`. */\nvar nativeAssign = (function() {\n  // Avoid `Object.assign` in Firefox 34-37 which have an early implementation\n  // with a now defunct try/catch behavior. See https://bugzilla.mozilla.org/show_bug.cgi?id=1103344\n  // for more details.\n  //\n  // Use `Object.preventExtensions` on a plain object instead of simply using\n  // `Object('x')` because Chrome and IE fail to throw an error when attempting\n  // to assign values to readonly indexes of strings.\n  var func = preventExtensions && isNative(func = Object.assign) && func;\n  try {\n    if (func) {\n      var object = preventExtensions({ '1': 0 });\n      object[0] = 1;\n    }\n  } catch(e) {\n    // Only attempt in strict mode.\n    try { func(object, 'xo'); } catch(e) {}\n    return !object[1] && func;\n  }\n  return false;\n}());\n\n/**\n * The base implementation of `_.assign` without support for argument juggling,\n * multiple sources, and `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nvar baseAssign = nativeAssign || function(object, source) {\n  return source == null\n    ? object\n    : baseCopy(source, getSymbols(source), baseCopy(source, keys(source), object));\n};\n\nmodule.exports = baseAssign;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/baseAssign.js\n ** module id = 27\n ** module chunks = 0\n **/","/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property names to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @returns {Object} Returns `object`.\n */\nfunction baseCopy(source, props, object) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n    object[key] = source[key];\n  }\n  return object;\n}\n\nmodule.exports = baseCopy;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/baseCopy.js\n ** module id = 28\n ** module chunks = 0\n **/","var createBaseFor = require('./createBaseFor');\n\n/**\n * The base implementation of `baseForIn` and `baseForOwn` which iterates\n * over `object` properties returned by `keysFunc` invoking `iteratee` for\n * each property. Iteratee functions may exit iteration early by explicitly\n * returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/baseFor.js\n ** module id = 29\n ** module chunks = 0\n **/","var baseFor = require('./baseFor'),\n    keys = require('../object/keys');\n\n/**\n * The base implementation of `_.forOwn` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/baseForOwn.js\n ** module id = 30\n ** module chunks = 0\n **/","var baseIsEqualDeep = require('./baseIsEqualDeep');\n\n/**\n * The base implementation of `_.isEqual` without support for `this` binding\n * `customizer` functions.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparing values.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA] Tracks traversed `value` objects.\n * @param {Array} [stackB] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {\n  // Exit early for identical values.\n  if (value === other) {\n    return true;\n  }\n  var valType = typeof value,\n      othType = typeof other;\n\n  // Exit early for unlike primitive values.\n  if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||\n      value == null || other == null) {\n    // Return `false` unless both values are `NaN`.\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);\n}\n\nmodule.exports = baseIsEqual;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/baseIsEqual.js\n ** module id = 31\n ** module chunks = 0\n **/","var equalArrays = require('./equalArrays'),\n    equalByTag = require('./equalByTag'),\n    equalObjects = require('./equalObjects'),\n    isArray = require('../lang/isArray'),\n    isTypedArray = require('../lang/isTypedArray');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparing objects.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA=[]] Tracks traversed `value` objects.\n * @param {Array} [stackB=[]] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = objToString.call(object);\n    if (objTag == argsTag) {\n      objTag = objectTag;\n    } else if (objTag != objectTag) {\n      objIsArr = isTypedArray(object);\n    }\n  }\n  if (!othIsArr) {\n    othTag = objToString.call(other);\n    if (othTag == argsTag) {\n      othTag = objectTag;\n    } else if (othTag != objectTag) {\n      othIsArr = isTypedArray(other);\n    }\n  }\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !(objIsArr || objIsObj)) {\n    return equalByTag(object, other, objTag);\n  }\n  if (!isLoose) {\n    var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (valWrapped || othWrapped) {\n      return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  // For more information on detecting circular references see https://es5.github.io/#JO.\n  stackA || (stackA = []);\n  stackB || (stackB = []);\n\n  var length = stackA.length;\n  while (length--) {\n    if (stackA[length] == object) {\n      return stackB[length] == other;\n    }\n  }\n  // Add `object` and `other` to the stack of traversed objects.\n  stackA.push(object);\n  stackB.push(other);\n\n  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);\n\n  stackA.pop();\n  stackB.pop();\n\n  return result;\n}\n\nmodule.exports = baseIsEqualDeep;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/baseIsEqualDeep.js\n ** module id = 32\n ** module chunks = 0\n **/","var baseIsEqual = require('./baseIsEqual');\n\n/**\n * The base implementation of `_.isMatch` without support for callback\n * shorthands and `this` binding.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Array} props The source property names to match.\n * @param {Array} values The source values to match.\n * @param {Array} strictCompareFlags Strict comparison flags for source values.\n * @param {Function} [customizer] The function to customize comparing objects.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, props, values, strictCompareFlags, customizer) {\n  var index = -1,\n      length = props.length,\n      noCustomizer = !customizer;\n\n  while (++index < length) {\n    if ((noCustomizer && strictCompareFlags[index])\n          ? values[index] !== object[props[index]]\n          : !(props[index] in object)\n        ) {\n      return false;\n    }\n  }\n  index = -1;\n  while (++index < length) {\n    var key = props[index],\n        objValue = object[key],\n        srcValue = values[index];\n\n    if (noCustomizer && strictCompareFlags[index]) {\n      var result = objValue !== undefined || (key in object);\n    } else {\n      result = customizer ? customizer(objValue, srcValue, key) : undefined;\n      if (result === undefined) {\n        result = baseIsEqual(srcValue, objValue, customizer, true);\n      }\n    }\n    if (!result) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/baseIsMatch.js\n ** module id = 33\n ** module chunks = 0\n **/","var baseIsMatch = require('./baseIsMatch'),\n    constant = require('../utility/constant'),\n    isStrictComparable = require('./isStrictComparable'),\n    keys = require('../object/keys'),\n    toObject = require('./toObject');\n\n/**\n * The base implementation of `_.matches` which does not clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new function.\n */\nfunction baseMatches(source) {\n  var props = keys(source),\n      length = props.length;\n\n  if (!length) {\n    return constant(true);\n  }\n  if (length == 1) {\n    var key = props[0],\n        value = source[key];\n\n    if (isStrictComparable(value)) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === value && (value !== undefined || (key in toObject(object)));\n      };\n    }\n  }\n  var values = Array(length),\n      strictCompareFlags = Array(length);\n\n  while (length--) {\n    value = source[props[length]];\n    values[length] = value;\n    strictCompareFlags[length] = isStrictComparable(value);\n  }\n  return function(object) {\n    return object != null && baseIsMatch(toObject(object), props, values, strictCompareFlags);\n  };\n}\n\nmodule.exports = baseMatches;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/baseMatches.js\n ** module id = 34\n ** module chunks = 0\n **/","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/baseProperty.js\n ** module id = 35\n ** module chunks = 0\n **/","/**\n * Converts `value` to a string if it is not one. An empty string is returned\n * for `null` or `undefined` values.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  if (typeof value == 'string') {\n    return value;\n  }\n  return value == null ? '' : (value + '');\n}\n\nmodule.exports = baseToString;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/baseToString.js\n ** module id = 36\n ** module chunks = 0\n **/","var identity = require('../utility/identity');\n\n/**\n * A specialized version of `baseCallback` which only supports `this` binding\n * and specifying the number of arguments to provide to `func`.\n *\n * @private\n * @param {Function} func The function to bind.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {number} [argCount] The number of arguments to provide to `func`.\n * @returns {Function} Returns the callback.\n */\nfunction bindCallback(func, thisArg, argCount) {\n  if (typeof func != 'function') {\n    return identity;\n  }\n  if (thisArg === undefined) {\n    return func;\n  }\n  switch (argCount) {\n    case 1: return function(value) {\n      return func.call(thisArg, value);\n    };\n    case 3: return function(value, index, collection) {\n      return func.call(thisArg, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(thisArg, accumulator, value, index, collection);\n    };\n    case 5: return function(value, other, key, object, source) {\n      return func.call(thisArg, value, other, key, object, source);\n    };\n  }\n  return function() {\n    return func.apply(thisArg, arguments);\n  };\n}\n\nmodule.exports = bindCallback;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/bindCallback.js\n ** module id = 37\n ** module chunks = 0\n **/","var constant = require('../utility/constant'),\n    isNative = require('../lang/isNative');\n\n/** Native method references. */\nvar ArrayBuffer = isNative(ArrayBuffer = global.ArrayBuffer) && ArrayBuffer,\n    bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,\n    floor = Math.floor,\n    Uint8Array = isNative(Uint8Array = global.Uint8Array) && Uint8Array;\n\n/** Used to clone array buffers. */\nvar Float64Array = (function() {\n  // Safari 5 errors when using an array buffer to initialize a typed array\n  // where the array buffer's `byteLength` is not a multiple of the typed\n  // array's `BYTES_PER_ELEMENT`.\n  try {\n    var func = isNative(func = global.Float64Array) && func,\n        result = new func(new ArrayBuffer(10), 0, 1) && func;\n  } catch(e) {}\n  return result;\n}());\n\n/** Used as the size, in bytes, of each `Float64Array` element. */\nvar FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;\n\n/**\n * Creates a clone of the given array buffer.\n *\n * @private\n * @param {ArrayBuffer} buffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction bufferClone(buffer) {\n  return bufferSlice.call(buffer, 0);\n}\nif (!bufferSlice) {\n  // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.\n  bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {\n    var byteLength = buffer.byteLength,\n        floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,\n        offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,\n        result = new ArrayBuffer(byteLength);\n\n    if (floatLength) {\n      var view = new Float64Array(result, 0, floatLength);\n      view.set(new Float64Array(buffer, 0, floatLength));\n    }\n    if (byteLength != offset) {\n      view = new Uint8Array(result, offset);\n      view.set(new Uint8Array(buffer, offset));\n    }\n    return result;\n  };\n}\n\nmodule.exports = bufferClone;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/bufferClone.js\n ** module id = 38\n ** module chunks = 0\n **/","var toObject = require('./toObject');\n\n/**\n * Creates a base function for `_.forIn` or `_.forInRight`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var iterable = toObject(object),\n        props = keysFunc(object),\n        length = props.length,\n        index = fromRight ? length : -1;\n\n    while ((fromRight ? index-- : ++index < length)) {\n      var key = props[index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/createBaseFor.js\n ** module id = 39\n ** module chunks = 0\n **/","/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparing arrays.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA] Tracks traversed `value` objects.\n * @param {Array} [stackB] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {\n  var index = -1,\n      arrLength = array.length,\n      othLength = other.length,\n      result = true;\n\n  if (arrLength != othLength && !(isLoose && othLength > arrLength)) {\n    return false;\n  }\n  // Deep compare the contents, ignoring non-numeric properties.\n  while (result && ++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    result = undefined;\n    if (customizer) {\n      result = isLoose\n        ? customizer(othValue, arrValue, index)\n        : customizer(arrValue, othValue, index);\n    }\n    if (result === undefined) {\n      // Recursively compare arrays (susceptible to call stack limits).\n      if (isLoose) {\n        var othIndex = othLength;\n        while (othIndex--) {\n          othValue = other[othIndex];\n          result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);\n          if (result) {\n            break;\n          }\n        }\n      } else {\n        result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);\n      }\n    }\n  }\n  return !!result;\n}\n\nmodule.exports = equalArrays;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/equalArrays.js\n ** module id = 40\n ** module chunks = 0\n **/","/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    stringTag = '[object String]';\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} value The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag) {\n  switch (tag) {\n    case boolTag:\n    case dateTag:\n      // Coerce dates and booleans to numbers, dates to milliseconds and booleans\n      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.\n      return +object == +other;\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case numberTag:\n      // Treat `NaN` vs. `NaN` as equal.\n      return (object != +object)\n        ? other != +other\n        : object == +other;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings primitives and string\n      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.\n      return object == (other + '');\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/equalByTag.js\n ** module id = 41\n ** module chunks = 0\n **/","var keys = require('../object/keys');\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparing values.\n * @param {boolean} [isLoose] Specify performing partial comparisons.\n * @param {Array} [stackA] Tracks traversed `value` objects.\n * @param {Array} [stackB] Tracks traversed `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n  var objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isLoose) {\n    return false;\n  }\n  var skipCtor = isLoose,\n      index = -1;\n\n  while (++index < objLength) {\n    var key = objProps[index],\n        result = isLoose ? key in other : hasOwnProperty.call(other, key);\n\n    if (result) {\n      var objValue = object[key],\n          othValue = other[key];\n\n      result = undefined;\n      if (customizer) {\n        result = isLoose\n          ? customizer(othValue, objValue, key)\n          : customizer(objValue, othValue, key);\n      }\n      if (result === undefined) {\n        // Recursively compare objects (susceptible to call stack limits).\n        result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB);\n      }\n    }\n    if (!result) {\n      return false;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (!skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = equalObjects;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/equalObjects.js\n ** module id = 42\n ** module chunks = 0\n **/","var baseProperty = require('./baseProperty');\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\nmodule.exports = getLength;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/getLength.js\n ** module id = 43\n ** module chunks = 0\n **/","var constant = require('../utility/constant'),\n    isNative = require('../lang/isNative'),\n    toObject = require('./toObject');\n\n/** Native method references. */\nvar getOwnPropertySymbols = isNative(getOwnPropertySymbols = Object.getOwnPropertySymbols) && getOwnPropertySymbols;\n\n/**\n * Creates an array of the own symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !getOwnPropertySymbols ? constant([]) : function(object) {\n  return getOwnPropertySymbols(toObject(object));\n};\n\nmodule.exports = getSymbols;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/getSymbols.js\n ** module id = 44\n ** module chunks = 0\n **/","/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add array properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/initCloneArray.js\n ** module id = 45\n ** module chunks = 0\n **/","var bufferClone = require('./bufferClone');\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    stringTag = '[object String]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return bufferClone(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      var buffer = object.buffer;\n      return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      var result = new Ctor(object.source, reFlags.exec(object));\n      result.lastIndex = object.lastIndex;\n  }\n  return result;\n}\n\nmodule.exports = initCloneByTag;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/initCloneByTag.js\n ** module id = 46\n ** module chunks = 0\n **/","/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  var Ctor = object.constructor;\n  if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {\n    Ctor = Object;\n  }\n  return new Ctor;\n}\n\nmodule.exports = initCloneObject;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/initCloneObject.js\n ** module id = 47\n ** module chunks = 0\n **/","var isObject = require('../lang/isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/isStrictComparable.js\n ** module id = 48\n ** module chunks = 0\n **/","var isArguments = require('../lang/isArguments'),\n    isArray = require('../lang/isArray'),\n    isIndex = require('./isIndex'),\n    isLength = require('./isLength'),\n    keysIn = require('../object/keysIn'),\n    support = require('../support');\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A fallback implementation of `Object.keys` which creates an array of the\n * own enumerable property names of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction shimKeys(object) {\n  var props = keysIn(object),\n      propsLength = props.length,\n      length = propsLength && object.length;\n\n  var allowIndexes = length && isLength(length) &&\n    (isArray(object) || (support.nonEnumArgs && isArguments(object)));\n\n  var index = -1,\n      result = [];\n\n  while (++index < propsLength) {\n    var key = props[index];\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = shimKeys;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/shimKeys.js\n ** module id = 49\n ** module chunks = 0\n **/","var baseClone = require('../internal/baseClone'),\n    bindCallback = require('../internal/bindCallback');\n\n/**\n * Creates a deep clone of `value`. If `customizer` is provided it is invoked\n * to produce the cloned values. If `customizer` returns `undefined` cloning\n * is handled by the method instead. The `customizer` is bound to `thisArg`\n * and invoked with two argument; (value [, index|key, object]).\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\n * The enumerable properties of `arguments` objects and objects created by\n * constructors other than `Object` are cloned to plain `Object` objects. An\n * empty object is returned for uncloneable values such as functions, DOM nodes,\n * Maps, Sets, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to deep clone.\n * @param {Function} [customizer] The function to customize cloning values.\n * @param {*} [thisArg] The `this` binding of `customizer`.\n * @returns {*} Returns the deep cloned value.\n * @example\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * var deep = _.cloneDeep(users);\n * deep[0] === users[0];\n * // => false\n *\n * // using a customizer callback\n * var el = _.cloneDeep(document.body, function(value) {\n *   if (_.isElement(value)) {\n *     return value.cloneNode(true);\n *   }\n * });\n *\n * el === document.body\n * // => false\n * el.nodeName\n * // => BODY\n * el.childNodes.length;\n * // => 20\n */\nfunction cloneDeep(value, customizer, thisArg) {\n  customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);\n  return baseClone(value, true, customizer);\n}\n\nmodule.exports = cloneDeep;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/lang/cloneDeep.js\n ** module id = 50\n ** module chunks = 0\n **/","var isNative = require('./isNative');\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeIsFinite = global.isFinite,\n    nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite;\n\n/**\n * Checks if `value` is a finite primitive number.\n *\n * **Note:** This method is based on [`Number.isFinite`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite).\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n * @example\n *\n * _.isFinite(10);\n * // => true\n *\n * _.isFinite('10');\n * // => false\n *\n * _.isFinite(true);\n * // => false\n *\n * _.isFinite(Object(10));\n * // => false\n *\n * _.isFinite(Infinity);\n * // => false\n */\nvar isFinite = nativeNumIsFinite || function(value) {\n  return typeof value == 'number' && nativeIsFinite(value);\n};\n\nmodule.exports = isFinite;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/lang/isFinite.js\n ** module id = 51\n ** module chunks = 0\n **/","var isLength = require('../internal/isLength'),\n    isObjectLike = require('../internal/isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dateTag] = typedArrayTags[errorTag] =\ntypedArrayTags[funcTag] = typedArrayTags[mapTag] =\ntypedArrayTags[numberTag] = typedArrayTags[objectTag] =\ntypedArrayTags[regexpTag] = typedArrayTags[setTag] =\ntypedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nfunction isTypedArray(value) {\n  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\n}\n\nmodule.exports = isTypedArray;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/lang/isTypedArray.js\n ** module id = 52\n ** module chunks = 0\n **/","var isArguments = require('../lang/isArguments'),\n    isArray = require('../lang/isArray'),\n    isIndex = require('../internal/isIndex'),\n    isLength = require('../internal/isLength'),\n    isObject = require('../lang/isObject'),\n    support = require('../support');\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  if (object == null) {\n    return [];\n  }\n  if (!isObject(object)) {\n    object = Object(object);\n  }\n  var length = object.length;\n  length = (length && isLength(length) &&\n    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;\n\n  var Ctor = object.constructor,\n      index = -1,\n      isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n      result = Array(length),\n      skipIndexes = length > 0;\n\n  while (++index < length) {\n    result[index] = (index + '');\n  }\n  for (var key in object) {\n    if (!(skipIndexes && isIndex(key, length)) &&\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = keysIn;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/object/keysIn.js\n ** module id = 53\n ** module chunks = 0\n **/","var baseToString = require('../internal/baseToString');\n\n/**\n * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).\n * In addition to special characters the forward slash is escaped to allow for\n * easier `eval` use and `Function` compilation.\n */\nvar reRegExpChars = /[.*+?^${}()|[\\]\\/\\\\]/g,\n    reHasRegExpChars = RegExp(reRegExpChars.source);\n\n/**\n * Escapes the `RegExp` special characters \"\\\", \"/\", \"^\", \"$\", \".\", \"|\", \"?\",\n * \"*\", \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n *\n * @static\n * @memberOf _\n * @category String\n * @param {string} [string=''] The string to escape.\n * @returns {string} Returns the escaped string.\n * @example\n *\n * _.escapeRegExp('[lodash](https://lodash.com/)');\n * // => '\\[lodash\\]\\(https:\\/\\/lodash\\.com\\/\\)'\n */\nfunction escapeRegExp(string) {\n  string = baseToString(string);\n  return (string && reHasRegExpChars.test(string))\n    ? string.replace(reRegExpChars, '\\\\$&')\n    : string;\n}\n\nmodule.exports = escapeRegExp;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/string/escapeRegExp.js\n ** module id = 54\n ** module chunks = 0\n **/","/**\n * This method returns the first argument provided to it.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'user': 'fred' };\n *\n * _.identity(object) === object;\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/utility/identity.js\n ** module id = 55\n ** module chunks = 0\n **/","var baseClone = require('../internal/baseClone'),\n    baseMatches = require('../internal/baseMatches');\n\n/**\n * Creates a function which performs a deep comparison between a given object\n * and `source`, returning `true` if the given object has equivalent property\n * values, else `false`.\n *\n * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n * numbers, `Object` objects, regexes, and strings. Objects are compared by\n * their own, not inherited, enumerable properties. For comparing a single\n * own or inherited property value see `_.matchesProperty`.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new function.\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, _.matches({ 'age': 40, 'active': false }));\n * // => [{ 'user': 'fred', 'age': 40, 'active': false }]\n */\nfunction matches(source) {\n  return baseMatches(baseClone(source, true));\n}\n\nmodule.exports = matches;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/utility/matches.js\n ** module id = 56\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 57\n ** module chunks = 0\n **/","function DestinationSelector(data, algorithm) {\n\tthis.data = data\n\t// we directly bind the algorithm function to our object since the function\n\t// uses our API and returns a destination\n\tthis.getNext = algorithm\n\t// the 'candiates' Array will contain the selected destination. If the Array\n\t// lenghts comes to 1, then a destination is found\n\tthis.candidates = []\n}\n\nDestinationSelector.buildSelector = function(data){\n\t// data contains :\n\t//\t.waypointsUp\n\t//\t.waypointsDown\n\t//\t.waypointsCabin\n\t//\t.currentFloor\n\t//\t.currentDirection\n\t//\t@todo control ?\n\tconsole.error('@todo parse user defined algorithm and create a function')\n\tvar algorithm = FAKE_COMPILED_USER_ALGORITHM\n\treturn new DestinationSelector(data,algorithm)\n}\n\n\n// Most of the prototype functions return <this>, allowing for a simple chain\n// of calls, hiding the state\n\nDestinationSelector.prototype.d = function() {\n\t// DUMP function\n\tvar args = Array.prototype.slice.call(arguments)\n\tconsole.log.apply(console, args)\n\treturn this\n}\n\nDestinationSelector.prototype.addWaypoints = function() {\n\t// arguments must be lists of waypoints\n\tthis.candidates = Array.prototype.slice.call(arguments)\n\t\t.reduce(function(acc, wps){\n\t\t\treturn acc.concat(wps)\n\t\t}, this.candidates)\n\treturn this\n}\n\nDestinationSelector.prototype.clear = function() {\n\t// arguments must be lists of waypoints\n\tthis.candidates = Array.prototype.slice.call(arguments)\n\t\t.reduce(function(acc, wps){\n\t\t\treturn acc.concat(wps)\n\t\t}, this.candidates)\n\treturn this\n}\n\nDestinationSelector.prototype.higherThan = function(n) {\n\tthis.candidates = this.candidates.filter(function(c){\n\t\treturn c > n\n\t})\n\treturn this\n}\n\nDestinationSelector.prototype.LowerThan = function(n) {\n\tthis.candidates = this.candidates.filter(function(c){\n\t\treturn c < n\n\t})\n\treturn this\n}\n\nDestinationSelector.prototype.call = function(f) {\n\tthis.candidates = f(this.candidates)\n\treturn this\n}\n\n// Theese functions set only one candidate in the list\n\nDestinationSelector.prototype.min = function(n) {\n\tthis.candidates = [Math.min.apply(null, this.candidates)]\n\treturn this\n}\n\nDestinationSelector.prototype.max = function(n) {\n\tthis.candidates = [Math.max.apply(null, this.candidates)]\n\treturn this\n}\n\nDestinationSelector.prototype.force = function(n) {\n\treturn n\n}\n\nDestinationSelector.prototype.orElse = function(next) {\n\t// if there's only one candidate left and it's a storey (not Infinity or\n\t// -Inifnity), returns it.\n\n\t// else, execute the callback 'next' containing a new selection. But before\n\t// clean the new candidates\n\tif (this.candidates.length === 1 && isFinite(this.candidates[0])) {\n\t\treturn this.candidates[0]\n\t} else {\n\t\treturn next.bind(this)()\n\t}\n}\n\nfunction FAKE_COMPILED_USER_ALGORITHM() {\n\t// the function will be bound to the selector, so we can directly use our\n\t// functions there. 'orElse' bounds its callback to the selector too\n\tvar result = this.orElse(function(){ // orElse 0 start\n\t\treturn this /* chain calls */\n\n\t// user input (right comments below) consists in commands and arguments\n\t// commands are calls to 'this', chained ; arguments are properties of\n\t// 'this.data'. The orElse command is special, it wraps the following code\n\t// until the end of input in a callback (like a monad binding).\n//* USER INPUT START ---------------------------------------------------------\n\t\t.addWaypoints(this.data.waypointsCabin)        // addWaypoints waypointsCabin\n\t\t.addWaypoints(this.data.waypointsSameDir)      // addWaypoints waypointsSameDir\n\t\t.higherThan(this.data.currentFloor)            // higherThan currentFloor\n\t\t.min()                                         // min\n\t\t.orElse(function(){                            // orElse # 1 start\n\t\t\treturn this                                // // inserted by the parser\n\t\t\t.force(5)                                  // // force 5\n\t\t})                                             // orElse # 1 end\n//* USER INPUT END -----------------------------------------------------------\n\t}) // end of base wrapping\n\n\treturn result\n}\n\nmodule.exports = DestinationSelector\n\n\n\n/** WEBPACK FOOTER **\n ** ./app/js/destination-selector.js\n **/"],"sourceRoot":""}