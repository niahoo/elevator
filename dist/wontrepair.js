!function(n){function e(c){if(t[c])return t[c].exports;var g=t[c]={exports:{},id:c,loaded:!1};return n[c].call(g.exports,g,g.exports,e),g.loaded=!0,g.exports}var t={};return e.m=n,e.c=t,e.p="",e(0)}({0:function(module,exports,__webpack_require__){eval("'use strict';\n\nvar graphics = __webpack_require__(52);\nvar elevator = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"elevator\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nvar Storey = __webpack_require__(53);\nvar CONF = __webpack_require__(49);\n\nconsole.log('WontRepair initializing');\n\nwindow.WontRepair = function (node) {\n	// initialize\n	var storeys = [new Storey(0), new Storey(1), new Storey(2)];\n	var elv = elevator.createElevator();\n	// var renderer = graphics.createRenderer({\n	//	domnode:node,\n	//	elevator:elv,\n	//	storeys: storeys\n	// })\n	window.elv = elv; // DEBUG\n	setTimeout(function () {\n		elv.addWaypointUp(1);\n	}, 1000);\n};\n\nconsole.log('WontRepair installed');\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvbWFpbi5qcz8xZTNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsSUFBSSxRQUFRLEdBQUcsbUJBQU8sQ0FBQyxFQUFVLENBQUM7QUFDbEMsSUFBSSxRQUFRLEdBQUcsbUJBQU8sQ0FBQyxvSUFBVSxDQUFDO0FBQ2xDLElBQUksTUFBTSxHQUFHLG1CQUFPLENBQUMsRUFBYyxDQUFDO0FBQ3BDLElBQUksSUFBSSxHQUFHLG1CQUFPLENBQUMsRUFBTSxDQUFDOztBQUUxQixPQUFPLENBQUMsR0FBRyxDQUFDLHlCQUF5QixDQUFDOztBQUV0QyxNQUFNLENBQUMsVUFBVSxHQUFHLFVBQVMsSUFBSSxFQUFFOztBQUVsQyxLQUFJLE9BQU8sR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNELEtBQUksR0FBRyxHQUFHLFFBQVEsQ0FBQyxjQUFjLEVBQUU7Ozs7OztBQU1uQyxPQUFNLENBQUMsR0FBRyxHQUFHLEdBQUc7QUFDaEIsV0FBVSxDQUFDLFlBQVU7QUFBRSxLQUFHLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztFQUFFLEVBQUUsSUFBSSxDQUFDO0NBQ3BEOztBQUVELE9BQU8sQ0FBQyxHQUFHLENBQUMsc0JBQXNCLENBQUMiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG52YXIgZ3JhcGhpY3MgPSByZXF1aXJlKCdncmFwaGljcycpXG52YXIgZWxldmF0b3IgPSByZXF1aXJlKCdlbGV2YXRvcicpXG52YXIgU3RvcmV5ID0gcmVxdWlyZSgnbW9kZWwvU3RvcmV5JylcbnZhciBDT05GID0gcmVxdWlyZSgnY29uZicpXG5cbmNvbnNvbGUubG9nKCdXb250UmVwYWlyIGluaXRpYWxpemluZycpXG5cbndpbmRvdy5Xb250UmVwYWlyID0gZnVuY3Rpb24obm9kZSkge1xuXHQvLyBpbml0aWFsaXplXG5cdHZhciBzdG9yZXlzID0gW25ldyBTdG9yZXkoMCksIG5ldyBTdG9yZXkoMSksIG5ldyBTdG9yZXkoMildXG5cdHZhciBlbHYgPSBlbGV2YXRvci5jcmVhdGVFbGV2YXRvcigpXG5cdC8vIHZhciByZW5kZXJlciA9IGdyYXBoaWNzLmNyZWF0ZVJlbmRlcmVyKHtcblx0Ly9cdGRvbW5vZGU6bm9kZSxcblx0Ly9cdGVsZXZhdG9yOmVsdixcblx0Ly9cdHN0b3JleXM6IHN0b3JleXNcblx0Ly8gfSlcblx0d2luZG93LmVsdiA9IGVsdiAvLyBERUJVR1xuXHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IGVsdi5hZGRXYXlwb2ludFVwKDEpIH0sIDEwMDApXG59XG5cbmNvbnNvbGUubG9nKCdXb250UmVwYWlyIGluc3RhbGxlZCcpXG5cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvanMvbWFpbi5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},49:function(module,exports,__webpack_require__){eval('"use strict";\n\nvar conf = {\n	storeyHeight: 100,\n	storeyWidth: 200,\n	storeySpacing: 12,\n	initialStoreyCount: 3,\n	initialElevatorPostion: 0, // it\'s a storey index\n	buildingX: 20,\n	buildingWallThickness: 5,\n	svgHeight: 1000,\n	svgWidth: 400,\n	elevatorHeight: 70,\n	elevatorWidth: 100,\n	storeyElevatorSpacing: 10, // horizontal spacing,\n	storeyTravelDuration: {\n		down: 500,\n		up: 700\n	}\n};\n\nconf.elevatorX = conf.buildingX + conf.buildingWallThickness + conf.storeyWidth + conf.storeyElevatorSpacing;\n\nmodule.exports = conf;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvY29uZi5qcz81MzhhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EsSUFBSSxJQUFJLEdBQUc7QUFDVixhQUFZLEVBQUUsR0FBRztBQUNqQixZQUFXLEVBQUUsR0FBRztBQUNoQixjQUFhLEVBQUUsRUFBRTtBQUNqQixtQkFBa0IsRUFBRSxDQUFDO0FBQ3JCLHVCQUFzQixFQUFFLENBQUM7QUFDekIsVUFBUyxFQUFFLEVBQUU7QUFDYixzQkFBcUIsRUFBRSxDQUFDO0FBQ3hCLFVBQVMsRUFBRSxJQUFJO0FBQ2YsU0FBUSxFQUFFLEdBQUc7QUFDYixlQUFjLEVBQUMsRUFBRTtBQUNqQixjQUFhLEVBQUMsR0FBRztBQUNqQixzQkFBcUIsRUFBQyxFQUFFO0FBQ3hCLHFCQUFvQixFQUFFO0FBQ3JCLE1BQUksRUFBQyxHQUFHO0FBQ1IsSUFBRSxFQUFDLEdBQUc7RUFDTjtDQUNEOztBQUVELElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMscUJBQXFCOztBQUU1RyxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUkiLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBjb25mID0ge1xuXHRzdG9yZXlIZWlnaHQ6IDEwMCxcblx0c3RvcmV5V2lkdGg6IDIwMCxcblx0c3RvcmV5U3BhY2luZzogMTIsXG5cdGluaXRpYWxTdG9yZXlDb3VudDogMyxcblx0aW5pdGlhbEVsZXZhdG9yUG9zdGlvbjogMCwgLy8gaXQncyBhIHN0b3JleSBpbmRleFxuXHRidWlsZGluZ1g6IDIwLFxuXHRidWlsZGluZ1dhbGxUaGlja25lc3M6IDUsXG5cdHN2Z0hlaWdodDogMTAwMCxcblx0c3ZnV2lkdGg6IDQwMCxcblx0ZWxldmF0b3JIZWlnaHQ6NzAsXG5cdGVsZXZhdG9yV2lkdGg6MTAwLFxuXHRzdG9yZXlFbGV2YXRvclNwYWNpbmc6MTAsIC8vIGhvcml6b250YWwgc3BhY2luZyxcblx0c3RvcmV5VHJhdmVsRHVyYXRpb246IHtcblx0XHRkb3duOjUwMCxcblx0XHR1cDo3MDBcblx0fVxufVxuXG5jb25mLmVsZXZhdG9yWCA9IGNvbmYuYnVpbGRpbmdYICsgY29uZi5idWlsZGluZ1dhbGxUaGlja25lc3MgKyBjb25mLnN0b3JleVdpZHRoICsgY29uZi5zdG9yZXlFbGV2YXRvclNwYWNpbmdcblxubW9kdWxlLmV4cG9ydHMgPSBjb25mXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9qcy9jb25mLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==')},52:function(module,exports,__webpack_require__){eval("'use strict';\n\nvar Ractive = __webpack_require__(56);\nvar CONF = __webpack_require__(49);\nvar appSVGTemplate = __webpack_require__(55);\n\n/**\n* Returns a storey's bounding box. Svg vertical coordinates are descending\n* @param  {0..} index   the storey's index\n* @param  {1..} amt     the total number of storeys (= max index + 1)\n * @return {integer}       y coordinate\n*/\nfunction getStoreyY(index, amt) {\n	var maxIndex = amt - 1;\n	var sa = maxIndex - index; // count of storeys above\n	var y = CONF.buildingWallThickness + sa * CONF.storeyHeight + sa * CONF.storeySpacing;\n	return y;\n}\n\n/**\n * Get the elevator Y position when at a storey\n * @param  {integer} index The storey's index the elevator is at\n * @param  {integer} amt   The total number of storeys\n * @return {integer}       y coordinate\n */\nfunction getElevatorY(index, amt) {\n	console.log('getElevatorY', index, amt);\n	var y = getStoreyY(index, amt) + (CONF.storeyHeight - CONF.elevatorHeight);\n	return y;\n}\n\nfunction wrapStoreys(_storeys) {\n	// @todo if reducing the amount of storeys, check if elevator is not\n	// above the new max\n	var data = _storeys.map(function (s) {\n		return {\n			i: s.position,\n			_storey: s,\n			x: CONF.buildingX + CONF.buildingWallThickness,\n			y: getStoreyY(s.position, _storeys.length),\n			width: CONF.storeyWidth,\n			height: CONF.storeyHeight };\n	});\n	console.log('wrapped', data);\n	return data;\n}\n\nfunction createRenderer(opts) {\n	console.log('createRenderer', opts);\n	var elv = opts.elevator;\n	var initialProps = elv.getProps();\n	var ractive = new Ractive({\n		el: opts.domnode,\n		template: appSVGTemplate,\n		data: {\n			storeys: wrapStoreys(opts.storeys),\n			elv: { // elevator\n				height: CONF.elevatorHeight,\n				width: CONF.elevatorWidth,\n				x: CONF.elevatorX,\n				pos: initialProps.currentStorey,\n				y: getElevatorY(initialProps.currentStorey, opts.storeys.length)\n			}\n		},\n		storeysAmt: function storeysAmt() {\n			return ractive.get('storeys').length;\n		},\n		currentPos: function currentPos() {\n			return ractive.get('elv.pos');\n		} });\n\n	// -- listen to elevator changes\n\n	elv.on('*', function () {});\n	elv.on('transition', function () {\n		// console.log('elv emit',arguments)\n		console.log(' (state)', elv.state);\n	});\n\n	elv.on('moving', function (nextPostion, duration) {\n		var newY = getElevatorY(nextPostion, opts.storeys.length);\n		return ractive.animate({ 'elv.y': newY, 'elv.pos': nextPostion }, { duration: duration, easing: 'easeInOut' });\n	});\n\n	return ractive;\n}\n\nexports.createRenderer = createRenderer;\n\n// console.log('elv emit',arguments)\n// console.log(' (state)', elv.state)\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvZ3JhcGhpY3MuanM/NjZlYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLElBQUksT0FBTyxHQUFHLG1CQUFPLENBQUMsRUFBUyxDQUFDO0FBQ2hDLElBQUksSUFBSSxHQUFHLG1CQUFPLENBQUMsRUFBTSxDQUFDO0FBQzFCLElBQUksY0FBYyxHQUFHLG1CQUFPLENBQUMsRUFBYSxDQUFDOzs7Ozs7OztBQVEzQyxTQUFTLFVBQVUsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFO0FBQy9CLEtBQUksUUFBUSxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQ3RCLEtBQUksRUFBRSxHQUFHLFFBQVEsR0FBRyxLQUFLO0FBQ3pCLEtBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxxQkFBcUIsR0FBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLFlBQWEsR0FBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLGFBQWM7QUFDekYsUUFBTyxDQUFDO0NBQ1I7Ozs7Ozs7O0FBUUQsU0FBUyxZQUFZLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRTtBQUNqQyxRQUFPLENBQUMsR0FBRyxDQUFDLGNBQWMsRUFBRSxLQUFLLEVBQUUsR0FBRyxDQUFDO0FBQ3ZDLEtBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDO0FBQzFFLFFBQU8sQ0FBQztDQUNSOztBQUlELFNBQVMsV0FBVyxDQUFFLFFBQVEsRUFBRTs7O0FBRy9CLEtBQUksSUFBSSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBUyxDQUFDLEVBQUM7QUFDbEMsU0FBTztBQUNOLElBQUMsRUFBRSxDQUFDLENBQUMsUUFBUTtBQUNiLFVBQU8sRUFBRSxDQUFDO0FBQ1YsSUFBQyxFQUFFLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLHFCQUFxQjtBQUM5QyxJQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLE1BQU0sQ0FBQztBQUMxQyxRQUFLLEVBQUUsSUFBSSxDQUFDLFdBQVc7QUFDdkIsU0FBTSxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQ3pCO0VBQ0QsQ0FBQztBQUNGLFFBQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQztBQUM1QixRQUFPLElBQUk7Q0FDWDs7QUFFRCxTQUFTLGNBQWMsQ0FBQyxJQUFJLEVBQUU7QUFDN0IsUUFBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsRUFBQyxJQUFJLENBQUM7QUFDbEMsS0FBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVE7QUFDdkIsS0FBSSxZQUFZLEdBQUcsR0FBRyxDQUFDLFFBQVEsRUFBRTtBQUNqQyxLQUFJLE9BQU8sR0FBRyxJQUFJLE9BQU8sQ0FBQztBQUN6QixJQUFFLEVBQUUsSUFBSSxDQUFDLE9BQU87QUFDaEIsVUFBUSxFQUFFLGNBQWM7QUFDeEIsTUFBSSxFQUFFO0FBQ0wsVUFBTyxFQUFFLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO0FBQ2xDLE1BQUcsRUFBRTtBQUNKLFVBQU0sRUFBRSxJQUFJLENBQUMsY0FBYztBQUMzQixTQUFLLEVBQUUsSUFBSSxDQUFDLGFBQWE7QUFDekIsS0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTO0FBQ2pCLE9BQUcsRUFBRSxZQUFZLENBQUMsYUFBYTtBQUMvQixLQUFDLEVBQUUsWUFBWSxDQUFDLFlBQVksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7SUFDaEU7R0FDRDtBQUNELFlBQVUsRUFBRSxzQkFBVztBQUFFLFVBQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxNQUFNO0dBQUU7QUFDL0QsWUFBVSxFQUFFLHNCQUFXO0FBQUUsVUFBTyxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQztHQUFFLEVBQ3hELENBQUMsQ0FBQzs7OztBQUlILElBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFDLFlBQVUsRUFHcEIsQ0FBQztBQUNGLElBQUcsQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFDLFlBQVU7O0FBRTdCLFNBQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUM7RUFDbEMsQ0FBQzs7QUFFRixJQUFHLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxVQUFTLFdBQVcsRUFBRSxRQUFRLEVBQUM7QUFDL0MsTUFBSSxJQUFJLEdBQUcsWUFBWSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztBQUN6RCxTQUFPLE9BQU8sQ0FBQyxPQUFPLENBQ3JCLEVBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUMsV0FBVyxFQUFDLEVBQ3RDLEVBQUMsUUFBUSxFQUFDLFFBQVEsRUFBQyxNQUFNLEVBQUMsV0FBVyxFQUFDLENBQ3RDO0VBQ0QsQ0FBQzs7QUFFRixRQUFPLE9BQU87Q0FDZDs7QUFFRCxPQUFPLENBQUMsY0FBYyxHQUFHLGNBQWMiLCJmaWxlIjoiNTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUmFjdGl2ZSA9IHJlcXVpcmUoJ3JhY3RpdmUnKVxudmFyIENPTkYgPSByZXF1aXJlKCdjb25mJylcbnZhciBhcHBTVkdUZW1wbGF0ZSA9IHJlcXVpcmUoJ3RwbC9hcHAuc3ZnJylcblxuLyoqXG4qIFJldHVybnMgYSBzdG9yZXkncyBib3VuZGluZyBib3guIFN2ZyB2ZXJ0aWNhbCBjb29yZGluYXRlcyBhcmUgZGVzY2VuZGluZ1xuKiBAcGFyYW0gIHswLi59IGluZGV4ICAgdGhlIHN0b3JleSdzIGluZGV4XG4qIEBwYXJhbSAgezEuLn0gYW10ICAgICB0aGUgdG90YWwgbnVtYmVyIG9mIHN0b3JleXMgKD0gbWF4IGluZGV4ICsgMSlcbiAqIEByZXR1cm4ge2ludGVnZXJ9ICAgICAgIHkgY29vcmRpbmF0ZVxuKi9cbmZ1bmN0aW9uIGdldFN0b3JleVkoaW5kZXgsIGFtdCkge1xuXHR2YXIgbWF4SW5kZXggPSBhbXQgLSAxXG5cdHZhciBzYSA9IG1heEluZGV4IC0gaW5kZXggLy8gY291bnQgb2Ygc3RvcmV5cyBhYm92ZVxuXHR2YXIgeSA9IENPTkYuYnVpbGRpbmdXYWxsVGhpY2tuZXNzICsgKHNhICogQ09ORi5zdG9yZXlIZWlnaHQpICsgKHNhICogQ09ORi5zdG9yZXlTcGFjaW5nKVxuXHRyZXR1cm4geVxufVxuXG4vKipcbiAqIEdldCB0aGUgZWxldmF0b3IgWSBwb3NpdGlvbiB3aGVuIGF0IGEgc3RvcmV5XG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSBpbmRleCBUaGUgc3RvcmV5J3MgaW5kZXggdGhlIGVsZXZhdG9yIGlzIGF0XG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSBhbXQgICBUaGUgdG90YWwgbnVtYmVyIG9mIHN0b3JleXNcbiAqIEByZXR1cm4ge2ludGVnZXJ9ICAgICAgIHkgY29vcmRpbmF0ZVxuICovXG5mdW5jdGlvbiBnZXRFbGV2YXRvclkoaW5kZXgsIGFtdCkge1xuXHRjb25zb2xlLmxvZygnZ2V0RWxldmF0b3JZJywgaW5kZXgsIGFtdClcblx0dmFyIHkgPSBnZXRTdG9yZXlZKGluZGV4LCBhbXQpICsgKENPTkYuc3RvcmV5SGVpZ2h0IC0gQ09ORi5lbGV2YXRvckhlaWdodClcblx0cmV0dXJuIHlcbn1cblxuXG5cbmZ1bmN0aW9uIHdyYXBTdG9yZXlzIChfc3RvcmV5cykge1xuXHQvLyBAdG9kbyBpZiByZWR1Y2luZyB0aGUgYW1vdW50IG9mIHN0b3JleXMsIGNoZWNrIGlmIGVsZXZhdG9yIGlzIG5vdFxuXHQvLyBhYm92ZSB0aGUgbmV3IG1heFxuXHR2YXIgZGF0YSA9IF9zdG9yZXlzLm1hcChmdW5jdGlvbihzKXtcblx0XHRyZXR1cm4ge1xuXHRcdFx0aTogcy5wb3NpdGlvbixcblx0XHRcdF9zdG9yZXk6IHMsXG5cdFx0XHR4OiBDT05GLmJ1aWxkaW5nWCArIENPTkYuYnVpbGRpbmdXYWxsVGhpY2tuZXNzLFxuXHRcdFx0eTogZ2V0U3RvcmV5WShzLnBvc2l0aW9uLCBfc3RvcmV5cy5sZW5ndGgpLFxuXHRcdFx0d2lkdGg6IENPTkYuc3RvcmV5V2lkdGgsXG5cdFx0XHRoZWlnaHQ6IENPTkYuc3RvcmV5SGVpZ2h0LFxuXHRcdH1cblx0fSlcblx0Y29uc29sZS5sb2coJ3dyYXBwZWQnLCBkYXRhKVxuXHRyZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihvcHRzKSB7XG5cdGNvbnNvbGUubG9nKCdjcmVhdGVSZW5kZXJlcicsb3B0cylcblx0dmFyIGVsdiA9IG9wdHMuZWxldmF0b3Jcblx0dmFyIGluaXRpYWxQcm9wcyA9IGVsdi5nZXRQcm9wcygpXG5cdHZhciByYWN0aXZlID0gbmV3IFJhY3RpdmUoe1xuXHRcdGVsOiBvcHRzLmRvbW5vZGUsXG5cdFx0dGVtcGxhdGU6IGFwcFNWR1RlbXBsYXRlLFxuXHRcdGRhdGE6IHtcblx0XHRcdHN0b3JleXM6IHdyYXBTdG9yZXlzKG9wdHMuc3RvcmV5cyksXG5cdFx0XHRlbHY6IHsgLy8gZWxldmF0b3Jcblx0XHRcdFx0aGVpZ2h0OiBDT05GLmVsZXZhdG9ySGVpZ2h0LFxuXHRcdFx0XHR3aWR0aDogQ09ORi5lbGV2YXRvcldpZHRoLFxuXHRcdFx0XHR4OiBDT05GLmVsZXZhdG9yWCxcblx0XHRcdFx0cG9zOiBpbml0aWFsUHJvcHMuY3VycmVudFN0b3JleSxcblx0XHRcdFx0eTogZ2V0RWxldmF0b3JZKGluaXRpYWxQcm9wcy5jdXJyZW50U3RvcmV5LCBvcHRzLnN0b3JleXMubGVuZ3RoKVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c3RvcmV5c0FtdDogZnVuY3Rpb24oKSB7IHJldHVybiByYWN0aXZlLmdldCgnc3RvcmV5cycpLmxlbmd0aCB9LFxuXHRcdGN1cnJlbnRQb3M6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmFjdGl2ZS5nZXQoJ2Vsdi5wb3MnKSB9LFxuXHR9KTtcblxuXHQvLyAtLSBsaXN0ZW4gdG8gZWxldmF0b3IgY2hhbmdlc1xuXG5cdGVsdi5vbignKicsZnVuY3Rpb24oKXtcblx0XHQvLyBjb25zb2xlLmxvZygnZWx2IGVtaXQnLGFyZ3VtZW50cylcblx0XHQvLyBjb25zb2xlLmxvZygnIChzdGF0ZSknLCBlbHYuc3RhdGUpXG5cdH0pXG5cdGVsdi5vbigndHJhbnNpdGlvbicsZnVuY3Rpb24oKXtcblx0XHQvLyBjb25zb2xlLmxvZygnZWx2IGVtaXQnLGFyZ3VtZW50cylcblx0XHRjb25zb2xlLmxvZygnIChzdGF0ZSknLCBlbHYuc3RhdGUpXG5cdH0pXG5cblx0ZWx2Lm9uKCdtb3ZpbmcnLCBmdW5jdGlvbihuZXh0UG9zdGlvbiwgZHVyYXRpb24pe1xuXHRcdHZhciBuZXdZID0gZ2V0RWxldmF0b3JZKG5leHRQb3N0aW9uLCBvcHRzLnN0b3JleXMubGVuZ3RoKVxuXHRcdHJldHVybiByYWN0aXZlLmFuaW1hdGUoXG5cdFx0XHR7J2Vsdi55JzogbmV3WSwgJ2Vsdi5wb3MnOm5leHRQb3N0aW9ufSxcblx0XHRcdHtkdXJhdGlvbjpkdXJhdGlvbixlYXNpbmc6J2Vhc2VJbk91dCd9XG5cdFx0KVxuXHR9KVxuXG5cdHJldHVybiByYWN0aXZlXG59XG5cbmV4cG9ydHMuY3JlYXRlUmVuZGVyZXIgPSBjcmVhdGVSZW5kZXJlclxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9qcy9ncmFwaGljcy5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},53:function(module,exports,__webpack_require__){eval('"use strict";\n\nfunction Storey(position) {\n	this.position = position;\n}\n\nmodule.exports = Storey;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvbW9kZWwvU3RvcmV5LmpzPzFmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxTQUFTLE1BQU0sQ0FBQyxRQUFRLEVBQUU7QUFDekIsS0FBSSxDQUFDLFFBQVEsR0FBRyxRQUFRO0NBQ3hCOztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsTUFBTSIsImZpbGUiOiI1My5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFN0b3JleShwb3NpdGlvbikge1xuXHR0aGlzLnBvc2l0aW9uID0gcG9zaXRpb25cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdG9yZXlcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL2pzL21vZGVsL1N0b3JleS5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=')},55:function(module,exports,__webpack_require__){eval('module.exports={"v":3,"t":[{"t":7,"e":"svg","f":[{"t":7,"e":"style","a":{"type":"text/css"},"f":["#storeys rect {\\n\\t\\t\\tfill:none;\\n\\t\\t\\tstroke:black;\\n\\t\\t\\tstroke-width:1px;\\n\\t\\t}\\n\\t\\trect#elevator {\\n\\t\\t\\tfill:none;\\n\\t\\t\\tstroke:black;\\n\\t\\t\\tstroke-width:1px;\\n\\t\\t}\\n\\t\\tsvg {\\n\\t\\t\\theight: 1000px;\\n\\t\\t\\twidth:800px;\\n\\t\\t}"]}," ",{"t":7,"e":"g","a":{"transform":"translate(30,30)"},"f":[" ",{"t":7,"e":"g","a":{"id":"storeys"},"f":[{"t":4,"f":[{"t":7,"e":"rect","a":{"width":[{"t":2,"r":"width"}],"height":[{"t":2,"r":"height"}],"x":[{"t":2,"r":"x"}],"y":[{"t":2,"r":"y"}]}}],"r":"storeys"}]}," ",{"t":7,"e":"rect","a":{"id":"elevator","width":[{"t":2,"r":"elv.width"}],"height":[{"t":2,"r":"elv.height"}],"x":[{"t":2,"r":"elv.x"}],"y":[{"t":2,"r":"elv.y"}]}}]}]}]};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvdHBsL2FwcC5zdmc/OTRiOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsWUFBWSxzQkFBc0IsdUJBQXVCLGtCQUFrQixzQkFBc0Isa0JBQWtCLHFCQUFxQix5QkFBeUIsT0FBTyxxQkFBcUIsa0JBQWtCLHFCQUFxQix5QkFBeUIsT0FBTyxXQUFXLHVCQUF1QixvQkFBb0IsT0FBTyxHQUFHLE1BQU0sbUJBQW1CLCtCQUErQixXQUFXLG1CQUFtQixlQUFlLE9BQU8sWUFBWSxzQkFBc0IsVUFBVSxrQkFBa0IsYUFBYSxtQkFBbUIsUUFBUSxjQUFjLFFBQVEsY0FBYyxHQUFHLGdCQUFnQixFQUFFLE1BQU0sc0JBQXNCLDBCQUEwQixzQkFBc0IsYUFBYSx1QkFBdUIsUUFBUSxrQkFBa0IsUUFBUSxrQkFBa0IsR0FBRyxFQUFFLEVBQUUiLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17XCJ2XCI6MyxcInRcIjpbe1widFwiOjcsXCJlXCI6XCJzdmdcIixcImZcIjpbe1widFwiOjcsXCJlXCI6XCJzdHlsZVwiLFwiYVwiOntcInR5cGVcIjpcInRleHQvY3NzXCJ9LFwiZlwiOltcIiNzdG9yZXlzIHJlY3Qge1xcblxcdFxcdFxcdGZpbGw6bm9uZTtcXG5cXHRcXHRcXHRzdHJva2U6YmxhY2s7XFxuXFx0XFx0XFx0c3Ryb2tlLXdpZHRoOjFweDtcXG5cXHRcXHR9XFxuXFx0XFx0cmVjdCNlbGV2YXRvciB7XFxuXFx0XFx0XFx0ZmlsbDpub25lO1xcblxcdFxcdFxcdHN0cm9rZTpibGFjaztcXG5cXHRcXHRcXHRzdHJva2Utd2lkdGg6MXB4O1xcblxcdFxcdH1cXG5cXHRcXHRzdmcge1xcblxcdFxcdFxcdGhlaWdodDogMTAwMHB4O1xcblxcdFxcdFxcdHdpZHRoOjgwMHB4O1xcblxcdFxcdH1cIl19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiZ1wiLFwiYVwiOntcInRyYW5zZm9ybVwiOlwidHJhbnNsYXRlKDMwLDMwKVwifSxcImZcIjpbXCIgXCIse1widFwiOjcsXCJlXCI6XCJnXCIsXCJhXCI6e1wiaWRcIjpcInN0b3JleXNcIn0sXCJmXCI6W3tcInRcIjo0LFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInJlY3RcIixcImFcIjp7XCJ3aWR0aFwiOlt7XCJ0XCI6MixcInJcIjpcIndpZHRoXCJ9XSxcImhlaWdodFwiOlt7XCJ0XCI6MixcInJcIjpcImhlaWdodFwifV0sXCJ4XCI6W3tcInRcIjoyLFwiclwiOlwieFwifV0sXCJ5XCI6W3tcInRcIjoyLFwiclwiOlwieVwifV19fV0sXCJyXCI6XCJzdG9yZXlzXCJ9XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJyZWN0XCIsXCJhXCI6e1wiaWRcIjpcImVsZXZhdG9yXCIsXCJ3aWR0aFwiOlt7XCJ0XCI6MixcInJcIjpcImVsdi53aWR0aFwifV0sXCJoZWlnaHRcIjpbe1widFwiOjIsXCJyXCI6XCJlbHYuaGVpZ2h0XCJ9XSxcInhcIjpbe1widFwiOjIsXCJyXCI6XCJlbHYueFwifV0sXCJ5XCI6W3tcInRcIjoyLFwiclwiOlwiZWx2LnlcIn1dfX1dfV19XX07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9qcy90cGwvYXBwLnN2Z1xuICoqIG1vZHVsZSBpZCA9IDU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9')},56:function(module,exports,__webpack_require__){eval('/*\n	Ractive.js v0.7.2\n	Thu Apr 02 2015 13:53:56 GMT-0400 (EDT) - commit 8bae4689db1bb54ce0804697b66c658639a53e93\n\n	http://ractivejs.org\n	http://twitter.com/RactiveJS\n\n	Released under the MIT License.\n*/\n\n(function (global, factory) {\n  true ? module.exports = factory() :\n  typeof define === \'function\' && define.amd ? define(factory) :\n  global.Ractive = factory()\n}(this, function () { \'use strict\';\n\n  var TEMPLATE_VERSION = 3;\n\n  var defaultOptions = {\n\n  	// render placement:\n  	el: void 0,\n  	append: false,\n\n  	// template:\n  	template: { v: TEMPLATE_VERSION, t: [] },\n\n  	// parse:     // TODO static delimiters?\n  	preserveWhitespace: false,\n  	sanitize: false,\n  	stripComments: true,\n  	delimiters: ["{{", "}}"],\n  	tripleDelimiters: ["{{{", "}}}"],\n  	interpolate: false,\n\n  	// data & binding:\n  	data: {},\n  	computed: {},\n  	magic: false,\n  	modifyArrays: true,\n  	adapt: [],\n  	isolated: false,\n  	twoway: true,\n  	lazy: false,\n\n  	// transitions:\n  	noIntro: false,\n  	transitionsEnabled: true,\n  	complete: void 0,\n\n  	// css:\n  	css: null,\n  	noCssTransform: false\n  };\n\n  var config_defaults = defaultOptions;\n\n  // These are a subset of the easing equations found at\n  // https://raw.github.com/danro/easing-js - license info\n  // follows:\n\n  // --------------------------------------------------\n  // easing.js v0.5.4\n  // Generic set of easing functions with AMD support\n  // https://github.com/danro/easing-js\n  // This code may be freely distributed under the MIT license\n  // http://danro.mit-license.org/\n  // --------------------------------------------------\n  // All functions adapted from Thomas Fuchs & Jeremy Kahn\n  // Easing Equations (c) 2003 Robert Penner, BSD license\n  // https://raw.github.com/danro/easing-js/master/LICENSE\n  // --------------------------------------------------\n\n  // In that library, the functions named easeIn, easeOut, and\n  // easeInOut below are named easeInCubic, easeOutCubic, and\n  // (you guessed it) easeInOutCubic.\n  //\n  // You can add additional easing functions to this list, and they\n  // will be globally available.\n\n  var static_easing = {\n  	linear: function (pos) {\n  		return pos;\n  	},\n  	easeIn: function (pos) {\n  		return Math.pow(pos, 3);\n  	},\n  	easeOut: function (pos) {\n  		return Math.pow(pos - 1, 3) + 1;\n  	},\n  	easeInOut: function (pos) {\n  		if ((pos /= 0.5) < 1) {\n  			return 0.5 * Math.pow(pos, 3);\n  		}\n  		return 0.5 * (Math.pow(pos - 2, 3) + 2);\n  	}\n  };\n\n  /*global console, navigator */\n  var isClient, isJsdom, hasConsole, environment__magic, namespaces, svg, vendors;\n\n  isClient = typeof document === "object";\n\n  isJsdom = typeof navigator !== "undefined" && /jsDom/.test(navigator.appName);\n\n  hasConsole = typeof console !== "undefined" && typeof console.warn === "function" && typeof console.warn.apply === "function";\n\n  try {\n  	Object.defineProperty({}, "test", { value: 0 });\n  	environment__magic = true;\n  } catch (e) {\n  	environment__magic = false;\n  }\n\n  namespaces = {\n  	html: "http://www.w3.org/1999/xhtml",\n  	mathml: "http://www.w3.org/1998/Math/MathML",\n  	svg: "http://www.w3.org/2000/svg",\n  	xlink: "http://www.w3.org/1999/xlink",\n  	xml: "http://www.w3.org/XML/1998/namespace",\n  	xmlns: "http://www.w3.org/2000/xmlns/"\n  };\n\n  if (typeof document === "undefined") {\n  	svg = false;\n  } else {\n  	svg = document && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");\n  }\n\n  vendors = ["o", "ms", "moz", "webkit"];\n\n  var createElement, matches, dom__div, methodNames, unprefixed, prefixed, dom__i, j, makeFunction;\n\n  // Test for SVG support\n  if (!svg) {\n  	createElement = function (type, ns) {\n  		if (ns && ns !== namespaces.html) {\n  			throw "This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information";\n  		}\n\n  		return document.createElement(type);\n  	};\n  } else {\n  	createElement = function (type, ns) {\n  		if (!ns || ns === namespaces.html) {\n  			return document.createElement(type);\n  		}\n\n  		return document.createElementNS(ns, type);\n  	};\n  }\n\n  function getElement(input) {\n  	var output;\n\n  	if (!input || typeof input === "boolean") {\n  		return;\n  	}\n\n  	if (typeof window === "undefined" || !document || !input) {\n  		return null;\n  	}\n\n  	// We already have a DOM node - no work to do. (Duck typing alert!)\n  	if (input.nodeType) {\n  		return input;\n  	}\n\n  	// Get node from string\n  	if (typeof input === "string") {\n  		// try ID first\n  		output = document.getElementById(input);\n\n  		// then as selector, if possible\n  		if (!output && document.querySelector) {\n  			output = document.querySelector(input);\n  		}\n\n  		// did it work?\n  		if (output && output.nodeType) {\n  			return output;\n  		}\n  	}\n\n  	// If we\'ve been given a collection (jQuery, Zepto etc), extract the first item\n  	if (input[0] && input[0].nodeType) {\n  		return input[0];\n  	}\n\n  	return null;\n  }\n\n  if (!isClient) {\n  	matches = null;\n  } else {\n  	dom__div = createElement("div");\n  	methodNames = ["matches", "matchesSelector"];\n\n  	makeFunction = function (methodName) {\n  		return function (node, selector) {\n  			return node[methodName](selector);\n  		};\n  	};\n\n  	dom__i = methodNames.length;\n\n  	while (dom__i-- && !matches) {\n  		unprefixed = methodNames[dom__i];\n\n  		if (dom__div[unprefixed]) {\n  			matches = makeFunction(unprefixed);\n  		} else {\n  			j = vendors.length;\n  			while (j--) {\n  				prefixed = vendors[dom__i] + unprefixed.substr(0, 1).toUpperCase() + unprefixed.substring(1);\n\n  				if (dom__div[prefixed]) {\n  					matches = makeFunction(prefixed);\n  					break;\n  				}\n  			}\n  		}\n  	}\n\n  	// IE8...\n  	if (!matches) {\n  		matches = function (node, selector) {\n  			var nodes, parentNode, i;\n\n  			parentNode = node.parentNode;\n\n  			if (!parentNode) {\n  				// empty dummy <div>\n  				dom__div.innerHTML = "";\n\n  				parentNode = dom__div;\n  				node = node.cloneNode();\n\n  				dom__div.appendChild(node);\n  			}\n\n  			nodes = parentNode.querySelectorAll(selector);\n\n  			i = nodes.length;\n  			while (i--) {\n  				if (nodes[i] === node) {\n  					return true;\n  				}\n  			}\n\n  			return false;\n  		};\n  	}\n  }\n\n  function detachNode(node) {\n  	if (node && typeof node.parentNode !== "unknown" && node.parentNode) {\n  		node.parentNode.removeChild(node);\n  	}\n\n  	return node;\n  }\n\n  function safeToStringValue(value) {\n  	return value == null || !value.toString ? "" : value;\n  }\n\n  var legacy = null;\n\n  var create, defineProperty, defineProperties;\n\n  try {\n  	Object.defineProperty({}, "test", { value: 0 });\n\n  	if (isClient) {\n  		Object.defineProperty(document.createElement("div"), "test", { value: 0 });\n  	}\n\n  	defineProperty = Object.defineProperty;\n  } catch (err) {\n  	// Object.defineProperty doesn\'t exist, or we\'re in IE8 where you can\n  	// only use it with DOM objects (what were you smoking, MSFT?)\n  	defineProperty = function (obj, prop, desc) {\n  		obj[prop] = desc.value;\n  	};\n  }\n\n  try {\n  	try {\n  		Object.defineProperties({}, { test: { value: 0 } });\n  	} catch (err) {\n  		// TODO how do we account for this? noMagic = true;\n  		throw err;\n  	}\n\n  	if (isClient) {\n  		Object.defineProperties(createElement("div"), { test: { value: 0 } });\n  	}\n\n  	defineProperties = Object.defineProperties;\n  } catch (err) {\n  	defineProperties = function (obj, props) {\n  		var prop;\n\n  		for (prop in props) {\n  			if (props.hasOwnProperty(prop)) {\n  				defineProperty(obj, prop, props[prop]);\n  			}\n  		}\n  	};\n  }\n\n  try {\n  	Object.create(null);\n\n  	create = Object.create;\n  } catch (err) {\n  	// sigh\n  	create = (function () {\n  		var F = function () {};\n\n  		return function (proto, props) {\n  			var obj;\n\n  			if (proto === null) {\n  				return {};\n  			}\n\n  			F.prototype = proto;\n  			obj = new F();\n\n  			if (props) {\n  				Object.defineProperties(obj, props);\n  			}\n\n  			return obj;\n  		};\n  	})();\n  }\n\n  function utils_object__extend(target) {\n  	for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  		sources[_key - 1] = arguments[_key];\n  	}\n\n  	var prop, source;\n\n  	while (source = sources.shift()) {\n  		for (prop in source) {\n  			if (hasOwn.call(source, prop)) {\n  				target[prop] = source[prop];\n  			}\n  		}\n  	}\n\n  	return target;\n  }\n\n  function fillGaps(target) {\n  	for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  		sources[_key - 1] = arguments[_key];\n  	}\n\n  	sources.forEach(function (s) {\n  		for (var key in s) {\n  			if (s.hasOwnProperty(key) && !(key in target)) {\n  				target[key] = s[key];\n  			}\n  		}\n  	});\n\n  	return target;\n  }\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  // thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n  var is__toString = Object.prototype.toString,\n      arrayLikePattern = /^\\[object (?:Array|FileList)\\]$/;\n  function isArray(thing) {\n  	return is__toString.call(thing) === "[object Array]";\n  }\n\n  function isArrayLike(obj) {\n  	return arrayLikePattern.test(is__toString.call(obj));\n  }\n\n  function isEqual(a, b) {\n  	if (a === null && b === null) {\n  		return true;\n  	}\n\n  	if (typeof a === "object" || typeof b === "object") {\n  		return false;\n  	}\n\n  	return a === b;\n  }\n\n  function is__isNumeric(thing) {\n  	return !isNaN(parseFloat(thing)) && isFinite(thing);\n  }\n\n  function isObject(thing) {\n  	return thing && is__toString.call(thing) === "[object Object]";\n  }\n\n  var noop = function () {};\n\n  /* global console */\n  var alreadyWarned = {},\n      log,\n      printWarning,\n      welcome;\n\n  if (hasConsole) {\n  	(function () {\n  		var welcomeIntro = ["%cRactive.js %c0.7.2 %cin debug mode, %cmore...", "color: rgb(114, 157, 52); font-weight: normal;", "color: rgb(85, 85, 85); font-weight: normal;", "color: rgb(85, 85, 85); font-weight: normal;", "color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;"];\n  		var welcomeMessage = "You\'re running Ractive 0.7.2 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\\n\\nTo disable debug mode, add this line at the start of your app:\\n  Ractive.DEBUG = false;\\n\\nTo disable debug mode when your app is minified, add this snippet:\\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\\n\\nGet help and support:\\n  http://docs.ractivejs.org\\n  http://stackoverflow.com/questions/tagged/ractivejs\\n  http://groups.google.com/forum/#!forum/ractive-js\\n  http://twitter.com/ractivejs\\n\\nFound a bug? Raise an issue:\\n  https://github.com/ractivejs/ractive/issues\\n\\n";\n\n  		welcome = function () {\n  			var hasGroup = !!console.groupCollapsed;\n  			console[hasGroup ? "groupCollapsed" : "log"].apply(console, welcomeIntro);\n  			console.log(welcomeMessage);\n  			if (hasGroup) {\n  				console.groupEnd(welcomeIntro);\n  			}\n\n  			welcome = noop;\n  		};\n\n  		printWarning = function (message, args) {\n  			welcome();\n\n  			// extract information about the instance this message pertains to, if applicable\n  			if (typeof args[args.length - 1] === "object") {\n  				var options = args.pop();\n  				var ractive = options ? options.ractive : null;\n\n  				if (ractive) {\n  					// if this is an instance of a component that we know the name of, add\n  					// it to the message\n  					var _name = undefined;\n  					if (ractive.component && (_name = ractive.component.name)) {\n  						message = "<" + _name + "> " + message;\n  					}\n\n  					var node = undefined;\n  					if (node = options.node || ractive.fragment && ractive.fragment.rendered && ractive.find("*")) {\n  						args.push(node);\n  					}\n  				}\n  			}\n\n  			console.warn.apply(console, ["%cRactive.js: %c" + message, "color: rgb(114, 157, 52);", "color: rgb(85, 85, 85);"].concat(args));\n  		};\n\n  		log = function () {\n  			console.log.apply(console, arguments);\n  		};\n  	})();\n  } else {\n  	printWarning = log = welcome = noop;\n  }\n\n  function format(message, args) {\n  	return message.replace(/%s/g, function () {\n  		return args.shift();\n  	});\n  }\n\n  function fatal(message) {\n  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  		args[_key - 1] = arguments[_key];\n  	}\n\n  	message = format(message, args);\n  	throw new Error(message);\n  }\n\n  function logIfDebug() {\n  	if (_Ractive.DEBUG) {\n  		log.apply(null, arguments);\n  	}\n  }\n\n  function warn(message) {\n  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  		args[_key - 1] = arguments[_key];\n  	}\n\n  	message = format(message, args);\n  	printWarning(message, args);\n  }\n\n  function warnOnce(message) {\n  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  		args[_key - 1] = arguments[_key];\n  	}\n\n  	message = format(message, args);\n\n  	if (alreadyWarned[message]) {\n  		return;\n  	}\n\n  	alreadyWarned[message] = true;\n  	printWarning(message, args);\n  }\n\n  function warnIfDebug() {\n  	if (_Ractive.DEBUG) {\n  		warn.apply(null, arguments);\n  	}\n  }\n\n  function warnOnceIfDebug() {\n  	if (_Ractive.DEBUG) {\n  		warnOnce.apply(null, arguments);\n  	}\n  }\n\n  // Error messages that are used (or could be) in multiple places\n  var badArguments = "Bad arguments";\n  var noRegistryFunctionReturn = "A function was specified for \\"%s\\" %s, but no %s was returned";\n  var missingPlugin = function (name, type) {\n    return "Missing \\"" + name + "\\" " + type + " plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#" + type + "s";\n  };\n\n  function findInViewHierarchy(registryName, ractive, name) {\n  	var instance = findInstance(registryName, ractive, name);\n  	return instance ? instance[registryName][name] : null;\n  }\n\n  function findInstance(registryName, ractive, name) {\n  	while (ractive) {\n  		if (name in ractive[registryName]) {\n  			return ractive;\n  		}\n\n  		if (ractive.isolated) {\n  			return null;\n  		}\n\n  		ractive = ractive.parent;\n  	}\n  }\n\n  var interpolate = function (from, to, ractive, type) {\n  	if (from === to) {\n  		return snap(to);\n  	}\n\n  	if (type) {\n\n  		var interpol = findInViewHierarchy("interpolators", ractive, type);\n  		if (interpol) {\n  			return interpol(from, to) || snap(to);\n  		}\n\n  		fatal(missingPlugin(type, "interpolator"));\n  	}\n\n  	return static_interpolators.number(from, to) || static_interpolators.array(from, to) || static_interpolators.object(from, to) || snap(to);\n  };\n\n  var shared_interpolate = interpolate;\n\n  function snap(to) {\n  	return function () {\n  		return to;\n  	};\n  }\n\n  var interpolators = {\n  	number: function (from, to) {\n  		var delta;\n\n  		if (!is__isNumeric(from) || !is__isNumeric(to)) {\n  			return null;\n  		}\n\n  		from = +from;\n  		to = +to;\n\n  		delta = to - from;\n\n  		if (!delta) {\n  			return function () {\n  				return from;\n  			};\n  		}\n\n  		return function (t) {\n  			return from + t * delta;\n  		};\n  	},\n\n  	array: function (from, to) {\n  		var intermediate, interpolators, len, i;\n\n  		if (!isArray(from) || !isArray(to)) {\n  			return null;\n  		}\n\n  		intermediate = [];\n  		interpolators = [];\n\n  		i = len = Math.min(from.length, to.length);\n  		while (i--) {\n  			interpolators[i] = shared_interpolate(from[i], to[i]);\n  		}\n\n  		// surplus values - don\'t interpolate, but don\'t exclude them either\n  		for (i = len; i < from.length; i += 1) {\n  			intermediate[i] = from[i];\n  		}\n\n  		for (i = len; i < to.length; i += 1) {\n  			intermediate[i] = to[i];\n  		}\n\n  		return function (t) {\n  			var i = len;\n\n  			while (i--) {\n  				intermediate[i] = interpolators[i](t);\n  			}\n\n  			return intermediate;\n  		};\n  	},\n\n  	object: function (from, to) {\n  		var properties, len, interpolators, intermediate, prop;\n\n  		if (!isObject(from) || !isObject(to)) {\n  			return null;\n  		}\n\n  		properties = [];\n  		intermediate = {};\n  		interpolators = {};\n\n  		for (prop in from) {\n  			if (hasOwn.call(from, prop)) {\n  				if (hasOwn.call(to, prop)) {\n  					properties.push(prop);\n  					interpolators[prop] = shared_interpolate(from[prop], to[prop]);\n  				} else {\n  					intermediate[prop] = from[prop];\n  				}\n  			}\n  		}\n\n  		for (prop in to) {\n  			if (hasOwn.call(to, prop) && !hasOwn.call(from, prop)) {\n  				intermediate[prop] = to[prop];\n  			}\n  		}\n\n  		len = properties.length;\n\n  		return function (t) {\n  			var i = len,\n  			    prop;\n\n  			while (i--) {\n  				prop = properties[i];\n\n  				intermediate[prop] = interpolators[prop](t);\n  			}\n\n  			return intermediate;\n  		};\n  	}\n  };\n\n  var static_interpolators = interpolators;\n\n  // This function takes a keypath such as \'foo.bar.baz\', and returns\n  // all the variants of that keypath that include a wildcard in place\n  // of a key, such as \'foo.bar.*\', \'foo.*.baz\', \'foo.*.*\' and so on.\n  // These are then checked against the dependants map (ractive.viewmodel.depsMap)\n  // to see if any pattern observers are downstream of one or more of\n  // these wildcard keypaths (e.g. \'foo.bar.*.status\')\n  var utils_getPotentialWildcardMatches = getPotentialWildcardMatches;\n\n  var starMaps = {};\n  function getPotentialWildcardMatches(keypath) {\n  	var keys, starMap, mapper, i, result, wildcardKeypath;\n\n  	keys = keypath.split(".");\n  	if (!(starMap = starMaps[keys.length])) {\n  		starMap = getStarMap(keys.length);\n  	}\n\n  	result = [];\n\n  	mapper = function (star, i) {\n  		return star ? "*" : keys[i];\n  	};\n\n  	i = starMap.length;\n  	while (i--) {\n  		wildcardKeypath = starMap[i].map(mapper).join(".");\n\n  		if (!result.hasOwnProperty(wildcardKeypath)) {\n  			result.push(wildcardKeypath);\n  			result[wildcardKeypath] = true;\n  		}\n  	}\n\n  	return result;\n  }\n\n  // This function returns all the possible true/false combinations for\n  // a given number - e.g. for two, the possible combinations are\n  // [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n  // It does so by getting all the binary values between 0 and e.g. 11\n  function getStarMap(num) {\n  	var ones = "",\n  	    max,\n  	    binary,\n  	    starMap,\n  	    mapper,\n  	    i,\n  	    j,\n  	    l,\n  	    map;\n\n  	if (!starMaps[num]) {\n  		starMap = [];\n\n  		while (ones.length < num) {\n  			ones += 1;\n  		}\n\n  		max = parseInt(ones, 2);\n\n  		mapper = function (digit) {\n  			return digit === "1";\n  		};\n\n  		for (i = 0; i <= max; i += 1) {\n  			binary = i.toString(2);\n  			while (binary.length < num) {\n  				binary = "0" + binary;\n  			}\n\n  			map = [];\n  			l = binary.length;\n  			for (j = 0; j < l; j++) {\n  				map.push(mapper(binary[j]));\n  			}\n  			starMap[i] = map;\n  		}\n\n  		starMaps[num] = starMap;\n  	}\n\n  	return starMaps[num];\n  }\n\n  var refPattern = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\n  var patternPattern = /\\*/;\n  var keypathCache = {};\n\n  var Keypath = function (str) {\n  	var keys = str.split(".");\n\n  	this.str = str;\n\n  	if (str[0] === "@") {\n  		this.isSpecial = true;\n  		this.value = decodeKeypath(str);\n  	}\n\n  	this.firstKey = keys[0];\n  	this.lastKey = keys.pop();\n\n  	this.isPattern = patternPattern.test(str);\n\n  	this.parent = str === "" ? null : getKeypath(keys.join("."));\n  	this.isRoot = !str;\n  };\n\n  Keypath.prototype = {\n  	equalsOrStartsWith: function (keypath) {\n  		return keypath === this || this.startsWith(keypath);\n  	},\n\n  	join: function (str) {\n  		return getKeypath(this.isRoot ? String(str) : this.str + "." + str);\n  	},\n\n  	replace: function (oldKeypath, newKeypath) {\n  		if (this === oldKeypath) {\n  			return newKeypath;\n  		}\n\n  		if (this.startsWith(oldKeypath)) {\n  			return newKeypath === null ? newKeypath : getKeypath(this.str.replace(oldKeypath.str + ".", newKeypath.str + "."));\n  		}\n  	},\n\n  	startsWith: function (keypath) {\n  		if (!keypath) {\n  			// TODO under what circumstances does this happen?\n  			return false;\n  		}\n\n  		return keypath && this.str.substr(0, keypath.str.length + 1) === keypath.str + ".";\n  	},\n\n  	toString: function () {\n  		throw new Error("Bad coercion");\n  	},\n\n  	valueOf: function () {\n  		throw new Error("Bad coercion");\n  	},\n\n  	wildcardMatches: function () {\n  		return this._wildcardMatches || (this._wildcardMatches = utils_getPotentialWildcardMatches(this.str));\n  	}\n  };\n  function assignNewKeypath(target, property, oldKeypath, newKeypath) {\n  	var existingKeypath = target[property];\n\n  	if (existingKeypath && (existingKeypath.equalsOrStartsWith(newKeypath) || !existingKeypath.equalsOrStartsWith(oldKeypath))) {\n  		return;\n  	}\n\n  	target[property] = existingKeypath ? existingKeypath.replace(oldKeypath, newKeypath) : newKeypath;\n  	return true;\n  }\n\n  function decodeKeypath(keypath) {\n  	var value = keypath.slice(2);\n\n  	if (keypath[1] === "i") {\n  		return is__isNumeric(value) ? +value : value;\n  	} else {\n  		return value;\n  	}\n  }\n\n  function getKeypath(str) {\n  	if (str == null) {\n  		return str;\n  	}\n\n  	// TODO it *may* be worth having two versions of this function - one where\n  	// keypathCache inherits from null, and one for IE8. Depends on how\n  	// much of an overhead hasOwnProperty is - probably negligible\n  	if (!keypathCache.hasOwnProperty(str)) {\n  		keypathCache[str] = new Keypath(str);\n  	}\n\n  	return keypathCache[str];\n  }\n\n  function getMatchingKeypaths(ractive, keypath) {\n  	var keys, key, matchingKeypaths;\n\n  	keys = keypath.str.split(".");\n  	matchingKeypaths = [rootKeypath];\n\n  	while (key = keys.shift()) {\n  		if (key === "*") {\n  			// expand to find all valid child keypaths\n  			matchingKeypaths = matchingKeypaths.reduce(expand, []);\n  		} else {\n  			if (matchingKeypaths[0] === rootKeypath) {\n  				// first key\n  				matchingKeypaths[0] = getKeypath(key);\n  			} else {\n  				matchingKeypaths = matchingKeypaths.map(concatenate(key));\n  			}\n  		}\n  	}\n\n  	return matchingKeypaths;\n\n  	function expand(matchingKeypaths, keypath) {\n  		var wrapper, value, keys;\n\n  		if (keypath.isRoot) {\n  			keys = [].concat(Object.keys(ractive.viewmodel.data), Object.keys(ractive.viewmodel.mappings), Object.keys(ractive.viewmodel.computations));\n  		} else {\n  			wrapper = ractive.viewmodel.wrapped[keypath.str];\n  			value = wrapper ? wrapper.get() : ractive.viewmodel.get(keypath);\n\n  			keys = value ? Object.keys(value) : null;\n  		}\n\n  		if (keys) {\n  			keys.forEach(function (key) {\n  				if (key !== "_ractive" || !isArray(value)) {\n  					matchingKeypaths.push(keypath.join(key));\n  				}\n  			});\n  		}\n\n  		return matchingKeypaths;\n  	}\n  }\n\n  function concatenate(key) {\n  	return function (keypath) {\n  		return keypath.join(key);\n  	};\n  }\n  function normalise(ref) {\n  	return ref ? ref.replace(refPattern, ".$1") : "";\n  }\n\n  var rootKeypath = getKeypath("");\n\n  var shared_add = add;\n  var shared_add__errorMessage = "Cannot add to a non-numeric value";\n  function add(root, keypath, d) {\n  	if (typeof keypath !== "string" || !is__isNumeric(d)) {\n  		throw new Error("Bad arguments");\n  	}\n\n  	var value = undefined,\n  	    changes = undefined;\n\n  	if (/\\*/.test(keypath)) {\n  		changes = {};\n\n  		getMatchingKeypaths(root, getKeypath(normalise(keypath))).forEach(function (keypath) {\n  			var value = root.viewmodel.get(keypath);\n\n  			if (!is__isNumeric(value)) {\n  				throw new Error(shared_add__errorMessage);\n  			}\n\n  			changes[keypath.str] = value + d;\n  		});\n\n  		return root.set(changes);\n  	}\n\n  	value = root.get(keypath);\n\n  	if (!is__isNumeric(value)) {\n  		throw new Error(shared_add__errorMessage);\n  	}\n\n  	return root.set(keypath, +value + d);\n  }\n\n  var prototype_add = Ractive$add;\n  function Ractive$add(keypath, d) {\n  	return shared_add(this, keypath, d === undefined ? 1 : +d);\n  }\n\n  var requestAnimationFrame;\n\n  // If window doesn\'t exist, we don\'t need requestAnimationFrame\n  if (typeof window === "undefined") {\n  	requestAnimationFrame = null;\n  } else {\n  	// https://gist.github.com/paulirish/1579671\n  	(function (vendors, lastTime, window) {\n\n  		var x, setTimeout;\n\n  		if (window.requestAnimationFrame) {\n  			return;\n  		}\n\n  		for (x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n  			window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];\n  		}\n\n  		if (!window.requestAnimationFrame) {\n  			setTimeout = window.setTimeout;\n\n  			window.requestAnimationFrame = function (callback) {\n  				var currTime, timeToCall, id;\n\n  				currTime = Date.now();\n  				timeToCall = Math.max(0, 16 - (currTime - lastTime));\n  				id = setTimeout(function () {\n  					callback(currTime + timeToCall);\n  				}, timeToCall);\n\n  				lastTime = currTime + timeToCall;\n  				return id;\n  			};\n  		}\n  	})(vendors, 0, window);\n\n  	requestAnimationFrame = window.requestAnimationFrame;\n  }\n\n  var rAF = requestAnimationFrame;\n\n  var getTime;\n\n  if (typeof window !== "undefined" && window.performance && typeof window.performance.now === "function") {\n  	getTime = function () {\n  		return window.performance.now();\n  	};\n  } else {\n  	getTime = function () {\n  		return Date.now();\n  	};\n  }\n\n  var utils_getTime = getTime;\n\n  var deprecations = {\n  	construct: {\n  		deprecated: "beforeInit",\n  		replacement: "onconstruct"\n  	},\n  	render: {\n  		deprecated: "init",\n  		message: "The \\"init\\" method has been deprecated " + "and will likely be removed in a future release. " + "You can either use the \\"oninit\\" method which will fire " + "only once prior to, and regardless of, any eventual ractive " + "instance being rendered, or if you need to access the " + "rendered DOM, use \\"onrender\\" instead. " + "See http://docs.ractivejs.org/latest/migrating for more information."\n  	},\n  	complete: {\n  		deprecated: "complete",\n  		replacement: "oncomplete"\n  	}\n  };\n\n  function Hook(event) {\n  	this.event = event;\n  	this.method = "on" + event;\n  	this.deprecate = deprecations[event];\n  }\n\n  Hook.prototype.fire = function (ractive, arg) {\n  	function call(method) {\n  		if (ractive[method]) {\n  			arg ? ractive[method](arg) : ractive[method]();\n  			return true;\n  		}\n  	}\n\n  	call(this.method);\n\n  	if (!ractive[this.method] && this.deprecate && call(this.deprecate.deprecated)) {\n  		if (this.deprecate.message) {\n  			warnIfDebug(this.deprecate.message);\n  		} else {\n  			warnIfDebug("The method \\"%s\\" has been deprecated in favor of \\"%s\\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.", this.deprecate.deprecated, this.deprecate.replacement);\n  		}\n  	}\n\n  	arg ? ractive.fire(this.event, arg) : ractive.fire(this.event);\n  };\n\n  var hooks_Hook = Hook;\n\n  function addToArray(array, value) {\n  	var index = array.indexOf(value);\n\n  	if (index === -1) {\n  		array.push(value);\n  	}\n  }\n\n  function arrayContains(array, value) {\n  	for (var i = 0, c = array.length; i < c; i++) {\n  		if (array[i] == value) {\n  			return true;\n  		}\n  	}\n\n  	return false;\n  }\n\n  function arrayContentsMatch(a, b) {\n  	var i;\n\n  	if (!isArray(a) || !isArray(b)) {\n  		return false;\n  	}\n\n  	if (a.length !== b.length) {\n  		return false;\n  	}\n\n  	i = a.length;\n  	while (i--) {\n  		if (a[i] !== b[i]) {\n  			return false;\n  		}\n  	}\n\n  	return true;\n  }\n\n  function ensureArray(x) {\n  	if (typeof x === "string") {\n  		return [x];\n  	}\n\n  	if (x === undefined) {\n  		return [];\n  	}\n\n  	return x;\n  }\n\n  function lastItem(array) {\n  	return array[array.length - 1];\n  }\n\n  function removeFromArray(array, member) {\n  	var index = array.indexOf(member);\n\n  	if (index !== -1) {\n  		array.splice(index, 1);\n  	}\n  }\n\n  function toArray(arrayLike) {\n  	var array = [],\n  	    i = arrayLike.length;\n  	while (i--) {\n  		array[i] = arrayLike[i];\n  	}\n\n  	return array;\n  }\n\n  var _Promise,\n      PENDING = {},\n      FULFILLED = {},\n      REJECTED = {};\n\n  if (typeof Promise === "function") {\n  	// use native Promise\n  	_Promise = Promise;\n  } else {\n  	_Promise = function (callback) {\n  		var fulfilledHandlers = [],\n  		    rejectedHandlers = [],\n  		    state = PENDING,\n  		    result,\n  		    dispatchHandlers,\n  		    makeResolver,\n  		    fulfil,\n  		    reject,\n  		    promise;\n\n  		makeResolver = function (newState) {\n  			return function (value) {\n  				if (state !== PENDING) {\n  					return;\n  				}\n\n  				result = value;\n  				state = newState;\n\n  				dispatchHandlers = makeDispatcher(state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result);\n\n  				// dispatch onFulfilled and onRejected handlers asynchronously\n  				wait(dispatchHandlers);\n  			};\n  		};\n\n  		fulfil = makeResolver(FULFILLED);\n  		reject = makeResolver(REJECTED);\n\n  		try {\n  			callback(fulfil, reject);\n  		} catch (err) {\n  			reject(err);\n  		}\n\n  		promise = {\n  			// `then()` returns a Promise - 2.2.7\n  			then: function (onFulfilled, onRejected) {\n  				var promise2 = new _Promise(function (fulfil, reject) {\n\n  					var processResolutionHandler = function (handler, handlers, forward) {\n\n  						// 2.2.1.1\n  						if (typeof handler === "function") {\n  							handlers.push(function (p1result) {\n  								var x;\n\n  								try {\n  									x = handler(p1result);\n  									utils_Promise__resolve(promise2, x, fulfil, reject);\n  								} catch (err) {\n  									reject(err);\n  								}\n  							});\n  						} else {\n  							// Forward the result of promise1 to promise2, if resolution handlers\n  							// are not given\n  							handlers.push(forward);\n  						}\n  					};\n\n  					// 2.2\n  					processResolutionHandler(onFulfilled, fulfilledHandlers, fulfil);\n  					processResolutionHandler(onRejected, rejectedHandlers, reject);\n\n  					if (state !== PENDING) {\n  						// If the promise has resolved already, dispatch the appropriate handlers asynchronously\n  						wait(dispatchHandlers);\n  					}\n  				});\n\n  				return promise2;\n  			}\n  		};\n\n  		promise["catch"] = function (onRejected) {\n  			return this.then(null, onRejected);\n  		};\n\n  		return promise;\n  	};\n\n  	_Promise.all = function (promises) {\n  		return new _Promise(function (fulfil, reject) {\n  			var result = [],\n  			    pending,\n  			    i,\n  			    processPromise;\n\n  			if (!promises.length) {\n  				fulfil(result);\n  				return;\n  			}\n\n  			processPromise = function (promise, i) {\n  				if (promise && typeof promise.then === "function") {\n  					promise.then(function (value) {\n  						result[i] = value;\n  						--pending || fulfil(result);\n  					}, reject);\n  				} else {\n  					result[i] = promise;\n  					--pending || fulfil(result);\n  				}\n  			};\n\n  			pending = i = promises.length;\n  			while (i--) {\n  				processPromise(promises[i], i);\n  			}\n  		});\n  	};\n\n  	_Promise.resolve = function (value) {\n  		return new _Promise(function (fulfil) {\n  			fulfil(value);\n  		});\n  	};\n\n  	_Promise.reject = function (reason) {\n  		return new _Promise(function (fulfil, reject) {\n  			reject(reason);\n  		});\n  	};\n  }\n\n  var utils_Promise = _Promise;\n\n  // TODO use MutationObservers or something to simulate setImmediate\n  function wait(callback) {\n  	setTimeout(callback, 0);\n  }\n\n  function makeDispatcher(handlers, result) {\n  	return function () {\n  		var handler;\n\n  		while (handler = handlers.shift()) {\n  			handler(result);\n  		}\n  	};\n  }\n\n  function utils_Promise__resolve(promise, x, fulfil, reject) {\n  	// Promise Resolution Procedure\n  	var then;\n\n  	// 2.3.1\n  	if (x === promise) {\n  		throw new TypeError("A promise\'s fulfillment handler cannot return the same promise");\n  	}\n\n  	// 2.3.2\n  	if (x instanceof _Promise) {\n  		x.then(fulfil, reject);\n  	}\n\n  	// 2.3.3\n  	else if (x && (typeof x === "object" || typeof x === "function")) {\n  		try {\n  			then = x.then; // 2.3.3.1\n  		} catch (e) {\n  			reject(e); // 2.3.3.2\n  			return;\n  		}\n\n  		// 2.3.3.3\n  		if (typeof then === "function") {\n  			var called, resolvePromise, rejectPromise;\n\n  			resolvePromise = function (y) {\n  				if (called) {\n  					return;\n  				}\n  				called = true;\n  				utils_Promise__resolve(promise, y, fulfil, reject);\n  			};\n\n  			rejectPromise = function (r) {\n  				if (called) {\n  					return;\n  				}\n  				called = true;\n  				reject(r);\n  			};\n\n  			try {\n  				then.call(x, resolvePromise, rejectPromise);\n  			} catch (e) {\n  				if (!called) {\n  					// 2.3.3.3.4.1\n  					reject(e); // 2.3.3.3.4.2\n  					called = true;\n  					return;\n  				}\n  			}\n  		} else {\n  			fulfil(x);\n  		}\n  	} else {\n  		fulfil(x);\n  	}\n  }\n\n  var getInnerContext = function (fragment) {\n  	do {\n  		if (fragment.context !== undefined) {\n  			return fragment.context;\n  		}\n  	} while (fragment = fragment.parent);\n\n  	return rootKeypath;\n  };\n\n  var shared_resolveRef = resolveRef;\n\n  function resolveRef(ractive, ref, fragment) {\n  	var keypath;\n\n  	ref = normalise(ref);\n\n  	// If a reference begins \'~/\', it\'s a top-level reference\n  	if (ref.substr(0, 2) === "~/") {\n  		keypath = getKeypath(ref.substring(2));\n  		createMappingIfNecessary(ractive, keypath.firstKey, fragment);\n  	}\n\n  	// If a reference begins with \'.\', it\'s either a restricted reference or\n  	// an ancestor reference...\n  	else if (ref[0] === ".") {\n  		keypath = resolveAncestorRef(getInnerContext(fragment), ref);\n\n  		if (keypath) {\n  			createMappingIfNecessary(ractive, keypath.firstKey, fragment);\n  		}\n  	}\n\n  	// ...otherwise we need to figure out the keypath based on context\n  	else {\n  		keypath = resolveAmbiguousReference(ractive, getKeypath(ref), fragment);\n  	}\n\n  	return keypath;\n  }\n\n  function resolveAncestorRef(baseContext, ref) {\n  	var contextKeys;\n\n  	// TODO...\n  	if (baseContext != undefined && typeof baseContext !== "string") {\n  		baseContext = baseContext.str;\n  	}\n\n  	// {{.}} means \'current context\'\n  	if (ref === ".") return getKeypath(baseContext);\n\n  	contextKeys = baseContext ? baseContext.split(".") : [];\n\n  	// ancestor references (starting "../") go up the tree\n  	if (ref.substr(0, 3) === "../") {\n  		while (ref.substr(0, 3) === "../") {\n  			if (!contextKeys.length) {\n  				throw new Error("Could not resolve reference - too many \\"../\\" prefixes");\n  			}\n\n  			contextKeys.pop();\n  			ref = ref.substring(3);\n  		}\n\n  		contextKeys.push(ref);\n  		return getKeypath(contextKeys.join("."));\n  	}\n\n  	// not an ancestor reference - must be a restricted reference (prepended with "." or "./")\n  	if (!baseContext) {\n  		return getKeypath(ref.replace(/^\\.\\/?/, ""));\n  	}\n\n  	return getKeypath(baseContext + ref.replace(/^\\.\\//, "."));\n  }\n\n  function resolveAmbiguousReference(ractive, ref, fragment, isParentLookup) {\n  	var context, key, parentValue, hasContextChain, parentKeypath;\n\n  	if (ref.isRoot) {\n  		return ref;\n  	}\n\n  	key = ref.firstKey;\n\n  	while (fragment) {\n  		context = fragment.context;\n  		fragment = fragment.parent;\n\n  		if (!context) {\n  			continue;\n  		}\n\n  		hasContextChain = true;\n  		parentValue = ractive.viewmodel.get(context);\n\n  		if (parentValue && (typeof parentValue === "object" || typeof parentValue === "function") && key in parentValue) {\n  			return context.join(ref.str);\n  		}\n  	}\n\n  	// Root/computed/mapped property?\n  	if (isRootProperty(ractive.viewmodel, key)) {\n  		return ref;\n  	}\n\n  	// If this is an inline component, and it\'s not isolated, we\n  	// can try going up the scope chain\n  	if (ractive.parent && !ractive.isolated) {\n  		hasContextChain = true;\n  		fragment = ractive.component.parentFragment;\n\n  		key = getKeypath(key);\n\n  		if (parentKeypath = resolveAmbiguousReference(ractive.parent, key, fragment, true)) {\n  			// We need to create an inter-component binding\n  			ractive.viewmodel.map(key, {\n  				origin: ractive.parent.viewmodel,\n  				keypath: parentKeypath\n  			});\n\n  			return ref;\n  		}\n  	}\n\n  	// If there\'s no context chain, and the instance is either a) isolated or\n  	// b) an orphan, then we know that the keypath is identical to the reference\n  	if (!isParentLookup && !hasContextChain) {\n  		// the data object needs to have a property by this name,\n  		// to prevent future failed lookups\n  		ractive.viewmodel.set(ref, undefined);\n  		return ref;\n  	}\n  }\n\n  function createMappingIfNecessary(ractive, key) {\n  	var parentKeypath;\n\n  	if (!ractive.parent || ractive.isolated || isRootProperty(ractive.viewmodel, key)) {\n  		return;\n  	}\n\n  	key = getKeypath(key);\n\n  	if (parentKeypath = resolveAmbiguousReference(ractive.parent, key, ractive.component.parentFragment, true)) {\n  		ractive.viewmodel.map(key, {\n  			origin: ractive.parent.viewmodel,\n  			keypath: parentKeypath\n  		});\n  	}\n  }\n\n  function isRootProperty(viewmodel, key) {\n  	// special case for reference to root\n  	return key === "" || key in viewmodel.data || key in viewmodel.computations || key in viewmodel.mappings;\n  }\n\n  function teardown(x) {\n    x.teardown();\n  }\n\n  function methodCallers__unbind(x) {\n    x.unbind();\n  }\n\n  function methodCallers__unrender(x) {\n    x.unrender();\n  }\n\n  function cancel(x) {\n    x.cancel();\n  }\n\n  var TransitionManager = function (callback, parent) {\n  	this.callback = callback;\n  	this.parent = parent;\n\n  	this.intros = [];\n  	this.outros = [];\n\n  	this.children = [];\n  	this.totalChildren = this.outroChildren = 0;\n\n  	this.detachQueue = [];\n  	this.decoratorQueue = [];\n  	this.outrosComplete = false;\n\n  	if (parent) {\n  		parent.addChild(this);\n  	}\n  };\n\n  TransitionManager.prototype = {\n  	addChild: function (child) {\n  		this.children.push(child);\n\n  		this.totalChildren += 1;\n  		this.outroChildren += 1;\n  	},\n\n  	decrementOutros: function () {\n  		this.outroChildren -= 1;\n  		check(this);\n  	},\n\n  	decrementTotal: function () {\n  		this.totalChildren -= 1;\n  		check(this);\n  	},\n\n  	add: function (transition) {\n  		var list = transition.isIntro ? this.intros : this.outros;\n  		list.push(transition);\n  	},\n\n  	addDecorator: function (decorator) {\n  		this.decoratorQueue.push(decorator);\n  	},\n\n  	remove: function (transition) {\n  		var list = transition.isIntro ? this.intros : this.outros;\n  		removeFromArray(list, transition);\n  		check(this);\n  	},\n\n  	init: function () {\n  		this.ready = true;\n  		check(this);\n  	},\n\n  	detachNodes: function () {\n  		this.decoratorQueue.forEach(teardown);\n  		this.detachQueue.forEach(detach);\n  		this.children.forEach(detachNodes);\n  	}\n  };\n\n  function detach(element) {\n  	element.detach();\n  }\n\n  function detachNodes(tm) {\n  	tm.detachNodes();\n  }\n\n  function check(tm) {\n  	if (!tm.ready || tm.outros.length || tm.outroChildren) return;\n\n  	// If all outros are complete, and we haven\'t already done this,\n  	// we notify the parent if there is one, otherwise\n  	// start detaching nodes\n  	if (!tm.outrosComplete) {\n  		if (tm.parent) {\n  			tm.parent.decrementOutros(tm);\n  		} else {\n  			tm.detachNodes();\n  		}\n\n  		tm.outrosComplete = true;\n  	}\n\n  	// Once everything is done, we can notify parent transition\n  	// manager and call the callback\n  	if (!tm.intros.length && !tm.totalChildren) {\n  		if (typeof tm.callback === "function") {\n  			tm.callback();\n  		}\n\n  		if (tm.parent) {\n  			tm.parent.decrementTotal();\n  		}\n  	}\n  }\n\n  var global_TransitionManager = TransitionManager;\n\n  var batch,\n      runloop,\n      unresolved = [],\n      changeHook = new hooks_Hook("change");\n\n  runloop = {\n  	start: function (instance, returnPromise) {\n  		var promise, fulfilPromise;\n\n  		if (returnPromise) {\n  			promise = new utils_Promise(function (f) {\n  				return fulfilPromise = f;\n  			});\n  		}\n\n  		batch = {\n  			previousBatch: batch,\n  			transitionManager: new global_TransitionManager(fulfilPromise, batch && batch.transitionManager),\n  			views: [],\n  			tasks: [],\n  			ractives: [],\n  			instance: instance\n  		};\n\n  		if (instance) {\n  			batch.ractives.push(instance);\n  		}\n\n  		return promise;\n  	},\n\n  	end: function () {\n  		flushChanges();\n\n  		batch.transitionManager.init();\n  		if (!batch.previousBatch && !!batch.instance) batch.instance.viewmodel.changes = [];\n  		batch = batch.previousBatch;\n  	},\n\n  	addRactive: function (ractive) {\n  		if (batch) {\n  			addToArray(batch.ractives, ractive);\n  		}\n  	},\n\n  	registerTransition: function (transition) {\n  		transition._manager = batch.transitionManager;\n  		batch.transitionManager.add(transition);\n  	},\n\n  	registerDecorator: function (decorator) {\n  		batch.transitionManager.addDecorator(decorator);\n  	},\n\n  	addView: function (view) {\n  		batch.views.push(view);\n  	},\n\n  	addUnresolved: function (thing) {\n  		unresolved.push(thing);\n  	},\n\n  	removeUnresolved: function (thing) {\n  		removeFromArray(unresolved, thing);\n  	},\n\n  	// synchronise node detachments with transition ends\n  	detachWhenReady: function (thing) {\n  		batch.transitionManager.detachQueue.push(thing);\n  	},\n\n  	scheduleTask: function (task, postRender) {\n  		var _batch;\n\n  		if (!batch) {\n  			task();\n  		} else {\n  			_batch = batch;\n  			while (postRender && _batch.previousBatch) {\n  				// this can\'t happen until the DOM has been fully updated\n  				// otherwise in some situations (with components inside elements)\n  				// transitions and decorators will initialise prematurely\n  				_batch = _batch.previousBatch;\n  			}\n\n  			_batch.tasks.push(task);\n  		}\n  	}\n  };\n\n  var global_runloop = runloop;\n\n  function flushChanges() {\n  	var i, thing, changeHash;\n\n  	while (batch.ractives.length) {\n  		thing = batch.ractives.pop();\n  		changeHash = thing.viewmodel.applyChanges();\n\n  		if (changeHash) {\n  			changeHook.fire(thing, changeHash);\n  		}\n  	}\n\n  	attemptKeypathResolution();\n\n  	// Now that changes have been fully propagated, we can update the DOM\n  	// and complete other tasks\n  	for (i = 0; i < batch.views.length; i += 1) {\n  		batch.views[i].update();\n  	}\n  	batch.views.length = 0;\n\n  	for (i = 0; i < batch.tasks.length; i += 1) {\n  		batch.tasks[i]();\n  	}\n  	batch.tasks.length = 0;\n\n  	// If updating the view caused some model blowback - e.g. a triple\n  	// containing <option> elements caused the binding on the <select>\n  	// to update - then we start over\n  	if (batch.ractives.length) return flushChanges();\n  }\n\n  function attemptKeypathResolution() {\n  	var i, item, keypath, resolved;\n\n  	i = unresolved.length;\n\n  	// see if we can resolve any unresolved references\n  	while (i--) {\n  		item = unresolved[i];\n\n  		if (item.keypath) {\n  			// it resolved some other way. TODO how? two-way binding? Seems\n  			// weird that we\'d still end up here\n  			unresolved.splice(i, 1);\n  			continue; // avoid removing the wrong thing should the next condition be true\n  		}\n\n  		if (keypath = shared_resolveRef(item.root, item.ref, item.parentFragment)) {\n  			(resolved || (resolved = [])).push({\n  				item: item,\n  				keypath: keypath\n  			});\n\n  			unresolved.splice(i, 1);\n  		}\n  	}\n\n  	if (resolved) {\n  		resolved.forEach(global_runloop__resolve);\n  	}\n  }\n\n  function global_runloop__resolve(resolved) {\n  	resolved.item.resolve(resolved.keypath);\n  }\n\n  var queue = [];\n\n  var animations = {\n  	tick: function () {\n  		var i, animation, now;\n\n  		now = utils_getTime();\n\n  		global_runloop.start();\n\n  		for (i = 0; i < queue.length; i += 1) {\n  			animation = queue[i];\n\n  			if (!animation.tick(now)) {\n  				// animation is complete, remove it from the stack, and decrement i so we don\'t miss one\n  				queue.splice(i--, 1);\n  			}\n  		}\n\n  		global_runloop.end();\n\n  		if (queue.length) {\n  			rAF(animations.tick);\n  		} else {\n  			animations.running = false;\n  		}\n  	},\n\n  	add: function (animation) {\n  		queue.push(animation);\n\n  		if (!animations.running) {\n  			animations.running = true;\n  			rAF(animations.tick);\n  		}\n  	},\n\n  	// TODO optimise this\n  	abort: function (keypath, root) {\n  		var i = queue.length,\n  		    animation;\n\n  		while (i--) {\n  			animation = queue[i];\n\n  			if (animation.root === root && animation.keypath === keypath) {\n  				animation.stop();\n  			}\n  		}\n  	}\n  };\n\n  var shared_animations = animations;\n\n  var Animation = function (options) {\n  	var key;\n\n  	this.startTime = Date.now();\n\n  	// from and to\n  	for (key in options) {\n  		if (options.hasOwnProperty(key)) {\n  			this[key] = options[key];\n  		}\n  	}\n\n  	this.interpolator = shared_interpolate(this.from, this.to, this.root, this.interpolator);\n  	this.running = true;\n\n  	this.tick();\n  };\n\n  Animation.prototype = {\n  	tick: function () {\n  		var elapsed, t, value, timeNow, index, keypath;\n\n  		keypath = this.keypath;\n\n  		if (this.running) {\n  			timeNow = Date.now();\n  			elapsed = timeNow - this.startTime;\n\n  			if (elapsed >= this.duration) {\n  				if (keypath !== null) {\n  					global_runloop.start(this.root);\n  					this.root.viewmodel.set(keypath, this.to);\n  					global_runloop.end();\n  				}\n\n  				if (this.step) {\n  					this.step(1, this.to);\n  				}\n\n  				this.complete(this.to);\n\n  				index = this.root._animations.indexOf(this);\n\n  				// TODO investigate why this happens\n  				if (index === -1) {\n  					warnIfDebug("Animation was not found");\n  				}\n\n  				this.root._animations.splice(index, 1);\n\n  				this.running = false;\n  				return false; // remove from the stack\n  			}\n\n  			t = this.easing ? this.easing(elapsed / this.duration) : elapsed / this.duration;\n\n  			if (keypath !== null) {\n  				value = this.interpolator(t);\n  				global_runloop.start(this.root);\n  				this.root.viewmodel.set(keypath, value);\n  				global_runloop.end();\n  			}\n\n  			if (this.step) {\n  				this.step(t, value);\n  			}\n\n  			return true; // keep in the stack\n  		}\n\n  		return false; // remove from the stack\n  	},\n\n  	stop: function () {\n  		var index;\n\n  		this.running = false;\n\n  		index = this.root._animations.indexOf(this);\n\n  		// TODO investigate why this happens\n  		if (index === -1) {\n  			warnIfDebug("Animation was not found");\n  		}\n\n  		this.root._animations.splice(index, 1);\n  	}\n  };\n\n  var animate_Animation = Animation;\n\n  var prototype_animate = Ractive$animate;\n\n  var noAnimation = { stop: noop };\n  function Ractive$animate(keypath, to, options) {\n  	var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;\n\n  	promise = new utils_Promise(function (fulfil) {\n  		return fulfilPromise = fulfil;\n  	});\n\n  	// animate multiple keypaths\n  	if (typeof keypath === "object") {\n  		options = to || {};\n  		easing = options.easing;\n  		duration = options.duration;\n\n  		animations = [];\n\n  		// we don\'t want to pass the `step` and `complete` handlers, as they will\n  		// run for each animation! So instead we\'ll store the handlers and create\n  		// our own...\n  		step = options.step;\n  		complete = options.complete;\n\n  		if (step || complete) {\n  			currentValues = {};\n\n  			options.step = null;\n  			options.complete = null;\n\n  			makeValueCollector = function (keypath) {\n  				return function (t, value) {\n  					currentValues[keypath] = value;\n  				};\n  			};\n  		}\n\n  		for (k in keypath) {\n  			if (keypath.hasOwnProperty(k)) {\n  				if (step || complete) {\n  					collectValue = makeValueCollector(k);\n  					options = { easing: easing, duration: duration };\n\n  					if (step) {\n  						options.step = collectValue;\n  					}\n  				}\n\n  				options.complete = complete ? collectValue : noop;\n  				animations.push(animate(this, k, keypath[k], options));\n  			}\n  		}\n\n  		// Create a dummy animation, to facilitate step/complete\n  		// callbacks, and Promise fulfilment\n  		dummyOptions = { easing: easing, duration: duration };\n\n  		if (step) {\n  			dummyOptions.step = function (t) {\n  				return step(t, currentValues);\n  			};\n  		}\n\n  		if (complete) {\n  			promise.then(function (t) {\n  				return complete(t, currentValues);\n  			});\n  		}\n\n  		dummyOptions.complete = fulfilPromise;\n\n  		dummy = animate(this, null, null, dummyOptions);\n  		animations.push(dummy);\n\n  		promise.stop = function () {\n  			var animation;\n\n  			while (animation = animations.pop()) {\n  				animation.stop();\n  			}\n\n  			if (dummy) {\n  				dummy.stop();\n  			}\n  		};\n\n  		return promise;\n  	}\n\n  	// animate a single keypath\n  	options = options || {};\n\n  	if (options.complete) {\n  		promise.then(options.complete);\n  	}\n\n  	options.complete = fulfilPromise;\n  	animation = animate(this, keypath, to, options);\n\n  	promise.stop = function () {\n  		return animation.stop();\n  	};\n  	return promise;\n  }\n\n  function animate(root, keypath, to, options) {\n  	var easing, duration, animation, from;\n\n  	if (keypath) {\n  		keypath = getKeypath(normalise(keypath));\n  	}\n\n  	if (keypath !== null) {\n  		from = root.viewmodel.get(keypath);\n  	}\n\n  	// cancel any existing animation\n  	// TODO what about upstream/downstream keypaths?\n  	shared_animations.abort(keypath, root);\n\n  	// don\'t bother animating values that stay the same\n  	if (isEqual(from, to)) {\n  		if (options.complete) {\n  			options.complete(options.to);\n  		}\n\n  		return noAnimation;\n  	}\n\n  	// easing function\n  	if (options.easing) {\n  		if (typeof options.easing === "function") {\n  			easing = options.easing;\n  		} else {\n  			easing = root.easing[options.easing];\n  		}\n\n  		if (typeof easing !== "function") {\n  			easing = null;\n  		}\n  	}\n\n  	// duration\n  	duration = options.duration === undefined ? 400 : options.duration;\n\n  	// TODO store keys, use an internal set method\n  	animation = new animate_Animation({\n  		keypath: keypath,\n  		from: from,\n  		to: to,\n  		root: root,\n  		duration: duration,\n  		easing: easing,\n  		interpolator: options.interpolator,\n\n  		// TODO wrap callbacks if necessary, to use instance as context\n  		step: options.step,\n  		complete: options.complete\n  	});\n\n  	shared_animations.add(animation);\n  	root._animations.push(animation);\n\n  	return animation;\n  }\n\n  var prototype_detach = Ractive$detach;\n  var prototype_detach__detachHook = new hooks_Hook("detach");\n  function Ractive$detach() {\n  	if (this.detached) {\n  		return this.detached;\n  	}\n\n  	if (this.el) {\n  		removeFromArray(this.el.__ractive_instances__, this);\n  	}\n  	this.detached = this.fragment.detach();\n  	prototype_detach__detachHook.fire(this);\n  	return this.detached;\n  }\n\n  var prototype_find = Ractive$find;\n\n  function Ractive$find(selector) {\n  	if (!this.el) {\n  		return null;\n  	}\n\n  	return this.fragment.find(selector);\n  }\n\n  var test = Query$test;\n  function Query$test(item, noDirty) {\n  	var itemMatches;\n\n  	if (this._isComponentQuery) {\n  		itemMatches = !this.selector || item.name === this.selector;\n  	} else {\n  		itemMatches = item.node ? matches(item.node, this.selector) : null;\n  	}\n\n  	if (itemMatches) {\n  		this.push(item.node || item.instance);\n\n  		if (!noDirty) {\n  			this._makeDirty();\n  		}\n\n  		return true;\n  	}\n  }\n\n  var makeQuery_cancel = function () {\n  	var liveQueries, selector, index;\n\n  	liveQueries = this._root[this._isComponentQuery ? "liveComponentQueries" : "liveQueries"];\n  	selector = this.selector;\n\n  	index = liveQueries.indexOf(selector);\n\n  	if (index !== -1) {\n  		liveQueries.splice(index, 1);\n  		liveQueries[selector] = null;\n  	}\n  };\n\n  var sortByItemPosition = function (a, b) {\n  	var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;\n\n  	ancestryA = getAncestry(a.component || a._ractive.proxy);\n  	ancestryB = getAncestry(b.component || b._ractive.proxy);\n\n  	oldestA = lastItem(ancestryA);\n  	oldestB = lastItem(ancestryB);\n\n  	// remove items from the end of both ancestries as long as they are identical\n  	// - the final one removed is the closest mutual ancestor\n  	while (oldestA && oldestA === oldestB) {\n  		ancestryA.pop();\n  		ancestryB.pop();\n\n  		mutualAncestor = oldestA;\n\n  		oldestA = lastItem(ancestryA);\n  		oldestB = lastItem(ancestryB);\n  	}\n\n  	// now that we have the mutual ancestor, we can find which is earliest\n  	oldestA = oldestA.component || oldestA;\n  	oldestB = oldestB.component || oldestB;\n\n  	fragmentA = oldestA.parentFragment;\n  	fragmentB = oldestB.parentFragment;\n\n  	// if both items share a parent fragment, our job is easy\n  	if (fragmentA === fragmentB) {\n  		indexA = fragmentA.items.indexOf(oldestA);\n  		indexB = fragmentB.items.indexOf(oldestB);\n\n  		// if it\'s the same index, it means one contains the other,\n  		// so we see which has the longest ancestry\n  		return indexA - indexB || ancestryA.length - ancestryB.length;\n  	}\n\n  	// if mutual ancestor is a section, we first test to see which section\n  	// fragment comes first\n  	if (fragments = mutualAncestor.fragments) {\n  		indexA = fragments.indexOf(fragmentA);\n  		indexB = fragments.indexOf(fragmentB);\n\n  		return indexA - indexB || ancestryA.length - ancestryB.length;\n  	}\n\n  	throw new Error("An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!");\n  };\n\n  function getParent(item) {\n  	var parentFragment;\n\n  	if (parentFragment = item.parentFragment) {\n  		return parentFragment.owner;\n  	}\n\n  	if (item.component && (parentFragment = item.component.parentFragment)) {\n  		return parentFragment.owner;\n  	}\n  }\n\n  function getAncestry(item) {\n  	var ancestry, ancestor;\n\n  	ancestry = [item];\n\n  	ancestor = getParent(item);\n\n  	while (ancestor) {\n  		ancestry.push(ancestor);\n  		ancestor = getParent(ancestor);\n  	}\n\n  	return ancestry;\n  }\n\n  var sortByDocumentPosition = function (node, otherNode) {\n  	var bitmask;\n\n  	if (node.compareDocumentPosition) {\n  		bitmask = node.compareDocumentPosition(otherNode);\n  		return bitmask & 2 ? 1 : -1;\n  	}\n\n  	// In old IE, we can piggy back on the mechanism for\n  	// comparing component positions\n  	return sortByItemPosition(node, otherNode);\n  };\n\n  var sort = function () {\n  	this.sort(this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition);\n  	this._dirty = false;\n  };\n\n  var makeQuery_dirty = function () {\n  	var _this = this;\n\n  	if (!this._dirty) {\n  		this._dirty = true;\n\n  		// Once the DOM has been updated, ensure the query\n  		// is correctly ordered\n  		global_runloop.scheduleTask(function () {\n  			_this._sort();\n  		});\n  	}\n  };\n\n  var remove = function (nodeOrComponent) {\n  	var index = this.indexOf(this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent);\n\n  	if (index !== -1) {\n  		this.splice(index, 1);\n  	}\n  };\n\n  var _makeQuery = makeQuery;\n  function makeQuery(ractive, selector, live, isComponentQuery) {\n  	var query = [];\n\n  	defineProperties(query, {\n  		selector: { value: selector },\n  		live: { value: live },\n\n  		_isComponentQuery: { value: isComponentQuery },\n  		_test: { value: test }\n  	});\n\n  	if (!live) {\n  		return query;\n  	}\n\n  	defineProperties(query, {\n  		cancel: { value: makeQuery_cancel },\n\n  		_root: { value: ractive },\n  		_sort: { value: sort },\n  		_makeDirty: { value: makeQuery_dirty },\n  		_remove: { value: remove },\n\n  		_dirty: { value: false, writable: true }\n  	});\n\n  	return query;\n  }\n\n  var prototype_findAll = Ractive$findAll;\n  function Ractive$findAll(selector, options) {\n  	var liveQueries, query;\n\n  	if (!this.el) {\n  		return [];\n  	}\n\n  	options = options || {};\n  	liveQueries = this._liveQueries;\n\n  	// Shortcut: if we\'re maintaining a live query with this\n  	// selector, we don\'t need to traverse the parallel DOM\n  	if (query = liveQueries[selector]) {\n\n  		// Either return the exact same query, or (if not live) a snapshot\n  		return options && options.live ? query : query.slice();\n  	}\n\n  	query = _makeQuery(this, selector, !!options.live, false);\n\n  	// Add this to the list of live queries Ractive needs to maintain,\n  	// if applicable\n  	if (query.live) {\n  		liveQueries.push(selector);\n  		liveQueries["_" + selector] = query;\n  	}\n\n  	this.fragment.findAll(selector, query);\n  	return query;\n  }\n\n  var prototype_findAllComponents = Ractive$findAllComponents;\n  function Ractive$findAllComponents(selector, options) {\n  	var liveQueries, query;\n\n  	options = options || {};\n  	liveQueries = this._liveComponentQueries;\n\n  	// Shortcut: if we\'re maintaining a live query with this\n  	// selector, we don\'t need to traverse the parallel DOM\n  	if (query = liveQueries[selector]) {\n\n  		// Either return the exact same query, or (if not live) a snapshot\n  		return options && options.live ? query : query.slice();\n  	}\n\n  	query = _makeQuery(this, selector, !!options.live, true);\n\n  	// Add this to the list of live queries Ractive needs to maintain,\n  	// if applicable\n  	if (query.live) {\n  		liveQueries.push(selector);\n  		liveQueries["_" + selector] = query;\n  	}\n\n  	this.fragment.findAllComponents(selector, query);\n  	return query;\n  }\n\n  var prototype_findComponent = Ractive$findComponent;\n\n  function Ractive$findComponent(selector) {\n  	return this.fragment.findComponent(selector);\n  }\n\n  var findContainer = Ractive$findContainer;\n\n  function Ractive$findContainer(selector) {\n  	if (this.container) {\n  		if (this.container.component && this.container.component.name === selector) {\n  			return this.container;\n  		} else {\n  			return this.container.findContainer(selector);\n  		}\n  	}\n\n  	return null;\n  }\n\n  var findParent = Ractive$findParent;\n\n  function Ractive$findParent(selector) {\n\n  	if (this.parent) {\n  		if (this.parent.component && this.parent.component.name === selector) {\n  			return this.parent;\n  		} else {\n  			return this.parent.findParent(selector);\n  		}\n  	}\n\n  	return null;\n  }\n\n  var eventStack = {\n  	enqueue: function (ractive, event) {\n  		if (ractive.event) {\n  			ractive._eventQueue = ractive._eventQueue || [];\n  			ractive._eventQueue.push(ractive.event);\n  		}\n  		ractive.event = event;\n  	},\n  	dequeue: function (ractive) {\n  		if (ractive._eventQueue && ractive._eventQueue.length) {\n  			ractive.event = ractive._eventQueue.pop();\n  		} else {\n  			delete ractive.event;\n  		}\n  	}\n  };\n\n  var shared_eventStack = eventStack;\n\n  var shared_fireEvent = fireEvent;\n\n  function fireEvent(ractive, eventName) {\n  	var options = arguments[2] === undefined ? {} : arguments[2];\n\n  	if (!eventName) {\n  		return;\n  	}\n\n  	if (!options.event) {\n  		options.event = {\n  			name: eventName,\n  			// until event not included as argument default\n  			_noArg: true\n  		};\n  	} else {\n  		options.event.name = eventName;\n  	}\n\n  	var eventNames = getKeypath(eventName).wildcardMatches();\n  	fireEventAs(ractive, eventNames, options.event, options.args, true);\n  }\n\n  function fireEventAs(ractive, eventNames, event, args) {\n  	var initialFire = arguments[4] === undefined ? false : arguments[4];\n\n  	var subscribers,\n  	    i,\n  	    bubble = true;\n\n  	shared_eventStack.enqueue(ractive, event);\n\n  	for (i = eventNames.length; i >= 0; i--) {\n  		subscribers = ractive._subs[eventNames[i]];\n\n  		if (subscribers) {\n  			bubble = notifySubscribers(ractive, subscribers, event, args) && bubble;\n  		}\n  	}\n\n  	shared_eventStack.dequeue(ractive);\n\n  	if (ractive.parent && bubble) {\n\n  		if (initialFire && ractive.component) {\n  			var fullName = ractive.component.name + "." + eventNames[eventNames.length - 1];\n  			eventNames = getKeypath(fullName).wildcardMatches();\n\n  			if (event) {\n  				event.component = ractive;\n  			}\n  		}\n\n  		fireEventAs(ractive.parent, eventNames, event, args);\n  	}\n  }\n\n  function notifySubscribers(ractive, subscribers, event, args) {\n  	var originalEvent = null,\n  	    stopEvent = false;\n\n  	if (event && !event._noArg) {\n  		args = [event].concat(args);\n  	}\n\n  	// subscribers can be modified inflight, e.g. "once" functionality\n  	// so we need to copy to make sure everyone gets called\n  	subscribers = subscribers.slice();\n\n  	for (var i = 0, len = subscribers.length; i < len; i += 1) {\n  		if (subscribers[i].apply(ractive, args) === false) {\n  			stopEvent = true;\n  		}\n  	}\n\n  	if (event && !event._noArg && stopEvent && (originalEvent = event.original)) {\n  		originalEvent.preventDefault && originalEvent.preventDefault();\n  		originalEvent.stopPropagation && originalEvent.stopPropagation();\n  	}\n\n  	return !stopEvent;\n  }\n\n  var prototype_fire = Ractive$fire;\n  function Ractive$fire(eventName) {\n\n  	var options = {\n  		args: Array.prototype.slice.call(arguments, 1)\n  	};\n\n  	shared_fireEvent(this, eventName, options);\n  }\n\n  var prototype_get = Ractive$get;\n  var options = {\n  	capture: true, // top-level calls should be intercepted\n  	noUnwrap: true, // wrapped values should NOT be unwrapped\n  	fullRootGet: true // root get should return mappings\n  };\n  function Ractive$get(keypath) {\n  	var value;\n\n  	keypath = getKeypath(normalise(keypath));\n  	value = this.viewmodel.get(keypath, options);\n\n  	// Create inter-component binding, if necessary\n  	if (value === undefined && this.parent && !this.isolated) {\n  		if (shared_resolveRef(this, keypath.str, this.component.parentFragment)) {\n  			// creates binding as side-effect, if appropriate\n  			value = this.viewmodel.get(keypath);\n  		}\n  	}\n\n  	return value;\n  }\n\n  var insert = Ractive$insert;\n\n  var insertHook = new hooks_Hook("insert");\n  function Ractive$insert(target, anchor) {\n  	if (!this.fragment.rendered) {\n  		// TODO create, and link to, documentation explaining this\n  		throw new Error("The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.");\n  	}\n\n  	target = getElement(target);\n  	anchor = getElement(anchor) || null;\n\n  	if (!target) {\n  		throw new Error("You must specify a valid target to insert into");\n  	}\n\n  	target.insertBefore(this.detach(), anchor);\n  	this.el = target;\n\n  	(target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(this);\n  	this.detached = null;\n\n  	fireInsertHook(this);\n  }\n\n  function fireInsertHook(ractive) {\n  	insertHook.fire(ractive);\n\n  	ractive.findAllComponents("*").forEach(function (child) {\n  		fireInsertHook(child.instance);\n  	});\n  }\n\n  var prototype_merge = Ractive$merge;\n  function Ractive$merge(keypath, array, options) {\n  	var currentArray, promise;\n\n  	keypath = getKeypath(normalise(keypath));\n  	currentArray = this.viewmodel.get(keypath);\n\n  	// If either the existing value or the new value isn\'t an\n  	// array, just do a regular set\n  	if (!isArray(currentArray) || !isArray(array)) {\n  		return this.set(keypath, array, options && options.complete);\n  	}\n\n  	// Manage transitions\n  	promise = global_runloop.start(this, true);\n  	this.viewmodel.merge(keypath, currentArray, array, options);\n  	global_runloop.end();\n\n  	return promise;\n  }\n\n  var Observer = function (ractive, keypath, callback, options) {\n  	this.root = ractive;\n  	this.keypath = keypath;\n  	this.callback = callback;\n  	this.defer = options.defer;\n\n  	// default to root as context, but allow it to be overridden\n  	this.context = options && options.context ? options.context : ractive;\n  };\n\n  Observer.prototype = {\n  	init: function (immediate) {\n  		this.value = this.root.get(this.keypath.str);\n\n  		if (immediate !== false) {\n  			this.update();\n  		} else {\n  			this.oldValue = this.value;\n  		}\n  	},\n\n  	setValue: function (value) {\n  		var _this = this;\n\n  		if (!isEqual(value, this.value)) {\n  			this.value = value;\n\n  			if (this.defer && this.ready) {\n  				global_runloop.scheduleTask(function () {\n  					return _this.update();\n  				});\n  			} else {\n  				this.update();\n  			}\n  		}\n  	},\n\n  	update: function () {\n  		// Prevent infinite loops\n  		if (this.updating) {\n  			return;\n  		}\n\n  		this.updating = true;\n\n  		this.callback.call(this.context, this.value, this.oldValue, this.keypath.str);\n  		this.oldValue = this.value;\n\n  		this.updating = false;\n  	}\n  };\n\n  var observe_Observer = Observer;\n\n  var observe_getPattern = getPattern;\n  function getPattern(ractive, pattern) {\n  	var matchingKeypaths, values;\n\n  	matchingKeypaths = getMatchingKeypaths(ractive, pattern);\n\n  	values = {};\n  	matchingKeypaths.forEach(function (keypath) {\n  		values[keypath.str] = ractive.get(keypath.str);\n  	});\n\n  	return values;\n  }\n\n  var PatternObserver,\n      slice = Array.prototype.slice;\n\n  PatternObserver = function (ractive, keypath, callback, options) {\n  	this.root = ractive;\n\n  	this.callback = callback;\n  	this.defer = options.defer;\n\n  	this.keypath = keypath;\n  	this.regex = new RegExp("^" + keypath.str.replace(/\\./g, "\\\\.").replace(/\\*/g, "([^\\\\.]+)") + "$");\n  	this.values = {};\n\n  	if (this.defer) {\n  		this.proxies = [];\n  	}\n\n  	// default to root as context, but allow it to be overridden\n  	this.context = options && options.context ? options.context : ractive;\n  };\n\n  PatternObserver.prototype = {\n  	init: function (immediate) {\n  		var values, keypath;\n\n  		values = observe_getPattern(this.root, this.keypath);\n\n  		if (immediate !== false) {\n  			for (keypath in values) {\n  				if (values.hasOwnProperty(keypath)) {\n  					this.update(getKeypath(keypath));\n  				}\n  			}\n  		} else {\n  			this.values = values;\n  		}\n  	},\n\n  	update: function (keypath) {\n  		var _this = this;\n\n  		var values;\n\n  		if (keypath.isPattern) {\n  			values = observe_getPattern(this.root, keypath);\n\n  			for (keypath in values) {\n  				if (values.hasOwnProperty(keypath)) {\n  					this.update(getKeypath(keypath));\n  				}\n  			}\n\n  			return;\n  		}\n\n  		// special case - array mutation should not trigger `array.*`\n  		// pattern observer with `array.length`\n  		if (this.root.viewmodel.implicitChanges[keypath.str]) {\n  			return;\n  		}\n\n  		if (this.defer && this.ready) {\n  			global_runloop.scheduleTask(function () {\n  				return _this.getProxy(keypath).update();\n  			});\n  			return;\n  		}\n\n  		this.reallyUpdate(keypath);\n  	},\n\n  	reallyUpdate: function (keypath) {\n  		var keypathStr, value, keys, args;\n\n  		keypathStr = keypath.str;\n  		value = this.root.viewmodel.get(keypath);\n\n  		// Prevent infinite loops\n  		if (this.updating) {\n  			this.values[keypathStr] = value;\n  			return;\n  		}\n\n  		this.updating = true;\n\n  		if (!isEqual(value, this.values[keypathStr]) || !this.ready) {\n  			keys = slice.call(this.regex.exec(keypathStr), 1);\n  			args = [value, this.values[keypathStr], keypathStr].concat(keys);\n\n  			this.values[keypathStr] = value;\n  			this.callback.apply(this.context, args);\n  		}\n\n  		this.updating = false;\n  	},\n\n  	getProxy: function (keypath) {\n  		var _this = this;\n\n  		if (!this.proxies[keypath.str]) {\n  			this.proxies[keypath.str] = {\n  				update: function () {\n  					return _this.reallyUpdate(keypath);\n  				}\n  			};\n  		}\n\n  		return this.proxies[keypath.str];\n  	}\n  };\n\n  var observe_PatternObserver = PatternObserver;\n\n  var observe_getObserverFacade = getObserverFacade;\n  var emptyObject = {};\n  function getObserverFacade(ractive, keypath, callback, options) {\n  	var observer, isPatternObserver, cancelled;\n\n  	keypath = getKeypath(normalise(keypath));\n  	options = options || emptyObject;\n\n  	// pattern observers are treated differently\n  	if (keypath.isPattern) {\n  		observer = new observe_PatternObserver(ractive, keypath, callback, options);\n  		ractive.viewmodel.patternObservers.push(observer);\n  		isPatternObserver = true;\n  	} else {\n  		observer = new observe_Observer(ractive, keypath, callback, options);\n  	}\n\n  	observer.init(options.init);\n  	ractive.viewmodel.register(keypath, observer, isPatternObserver ? "patternObservers" : "observers");\n\n  	// This flag allows observers to initialise even with undefined values\n  	observer.ready = true;\n\n  	var facade = {\n  		cancel: function () {\n  			var index;\n\n  			if (cancelled) {\n  				return;\n  			}\n\n  			if (isPatternObserver) {\n  				index = ractive.viewmodel.patternObservers.indexOf(observer);\n\n  				ractive.viewmodel.patternObservers.splice(index, 1);\n  				ractive.viewmodel.unregister(keypath, observer, "patternObservers");\n  			} else {\n  				ractive.viewmodel.unregister(keypath, observer, "observers");\n  			}\n  			cancelled = true;\n  		}\n  	};\n\n  	ractive._observers.push(facade);\n  	return facade;\n  }\n\n  var observe = Ractive$observe;\n  function Ractive$observe(keypath, callback, options) {\n\n  	var observers, map, keypaths, i;\n\n  	// Allow a map of keypaths to handlers\n  	if (isObject(keypath)) {\n  		options = callback;\n  		map = keypath;\n\n  		observers = [];\n\n  		for (keypath in map) {\n  			if (map.hasOwnProperty(keypath)) {\n  				callback = map[keypath];\n  				observers.push(this.observe(keypath, callback, options));\n  			}\n  		}\n\n  		return {\n  			cancel: function () {\n  				while (observers.length) {\n  					observers.pop().cancel();\n  				}\n  			}\n  		};\n  	}\n\n  	// Allow `ractive.observe( callback )` - i.e. observe entire model\n  	if (typeof keypath === "function") {\n  		options = callback;\n  		callback = keypath;\n  		keypath = "";\n\n  		return observe_getObserverFacade(this, keypath, callback, options);\n  	}\n\n  	keypaths = keypath.split(" ");\n\n  	// Single keypath\n  	if (keypaths.length === 1) {\n  		return observe_getObserverFacade(this, keypath, callback, options);\n  	}\n\n  	// Multiple space-separated keypaths\n  	observers = [];\n\n  	i = keypaths.length;\n  	while (i--) {\n  		keypath = keypaths[i];\n\n  		if (keypath) {\n  			observers.push(observe_getObserverFacade(this, keypath, callback, options));\n  		}\n  	}\n\n  	return {\n  		cancel: function () {\n  			while (observers.length) {\n  				observers.pop().cancel();\n  			}\n  		}\n  	};\n  }\n\n  var observeOnce = Ractive$observeOnce;\n\n  function Ractive$observeOnce(property, callback, options) {\n\n  	var observer = this.observe(property, function () {\n  		callback.apply(this, arguments);\n  		observer.cancel();\n  	}, { init: false, defer: options && options.defer });\n\n  	return observer;\n  }\n\n  var shared_trim = function (str) {\n    return str.trim();\n  };\n\n  var notEmptyString = function (str) {\n    return str !== "";\n  };\n\n  var off = Ractive$off;\n  function Ractive$off(eventName, callback) {\n  	var _this = this;\n\n  	var eventNames;\n\n  	// if no arguments specified, remove all callbacks\n  	if (!eventName) {\n  		// TODO use this code instead, once the following issue has been resolved\n  		// in PhantomJS (tests are unpassable otherwise!)\n  		// https://github.com/ariya/phantomjs/issues/11856\n  		// defineProperty( this, \'_subs\', { value: create( null ), configurable: true });\n  		for (eventName in this._subs) {\n  			delete this._subs[eventName];\n  		}\n  	} else {\n  		// Handle multiple space-separated event names\n  		eventNames = eventName.split(" ").map(shared_trim).filter(notEmptyString);\n\n  		eventNames.forEach(function (eventName) {\n  			var subscribers, index;\n\n  			// If we have subscribers for this event...\n  			if (subscribers = _this._subs[eventName]) {\n  				// ...if a callback was specified, only remove that\n  				if (callback) {\n  					index = subscribers.indexOf(callback);\n  					if (index !== -1) {\n  						subscribers.splice(index, 1);\n  					}\n  				}\n\n  				// ...otherwise remove all callbacks\n  				else {\n  					_this._subs[eventName] = [];\n  				}\n  			}\n  		});\n  	}\n\n  	return this;\n  }\n\n  var on = Ractive$on;\n  function Ractive$on(eventName, callback) {\n  	var _this = this;\n\n  	var listeners, n, eventNames;\n\n  	// allow mutliple listeners to be bound in one go\n  	if (typeof eventName === "object") {\n  		listeners = [];\n\n  		for (n in eventName) {\n  			if (eventName.hasOwnProperty(n)) {\n  				listeners.push(this.on(n, eventName[n]));\n  			}\n  		}\n\n  		return {\n  			cancel: function () {\n  				var listener;\n\n  				while (listener = listeners.pop()) {\n  					listener.cancel();\n  				}\n  			}\n  		};\n  	}\n\n  	// Handle multiple space-separated event names\n  	eventNames = eventName.split(" ").map(shared_trim).filter(notEmptyString);\n\n  	eventNames.forEach(function (eventName) {\n  		(_this._subs[eventName] || (_this._subs[eventName] = [])).push(callback);\n  	});\n\n  	return {\n  		cancel: function () {\n  			return _this.off(eventName, callback);\n  		}\n  	};\n  }\n\n  var once = Ractive$once;\n\n  function Ractive$once(eventName, handler) {\n\n  	var listener = this.on(eventName, function () {\n  		handler.apply(this, arguments);\n  		listener.cancel();\n  	});\n\n  	// so we can still do listener.cancel() manually\n  	return listener;\n  }\n\n  // This function takes an array, the name of a mutator method, and the\n  // arguments to call that mutator method with, and returns an array that\n  // maps the old indices to their new indices.\n\n  // So if you had something like this...\n  //\n  //     array = [ \'a\', \'b\', \'c\', \'d\' ];\n  //     array.push( \'e\' );\n  //\n  // ...you\'d get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n  // have changed. If you then did this...\n  //\n  //     array.unshift( \'z\' );\n  //\n  // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n  // one higher to make room for the \'z\'. If you removed an item, the new index\n  // would be -1...\n  //\n  //     array.splice( 2, 2 );\n  //\n  // ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n  //\n  // This information is used to enable fast, non-destructive shuffling of list\n  // sections when you do e.g. `ractive.splice( \'items\', 2, 2 );\n\n  var shared_getNewIndices = getNewIndices;\n\n  function getNewIndices(array, methodName, args) {\n  	var spliceArguments,\n  	    len,\n  	    newIndices = [],\n  	    removeStart,\n  	    removeEnd,\n  	    balance,\n  	    i;\n\n  	spliceArguments = getSpliceEquivalent(array, methodName, args);\n\n  	if (!spliceArguments) {\n  		return null; // TODO support reverse and sort?\n  	}\n\n  	len = array.length;\n  	balance = spliceArguments.length - 2 - spliceArguments[1];\n\n  	removeStart = Math.min(len, spliceArguments[0]);\n  	removeEnd = removeStart + spliceArguments[1];\n\n  	for (i = 0; i < removeStart; i += 1) {\n  		newIndices.push(i);\n  	}\n\n  	for (; i < removeEnd; i += 1) {\n  		newIndices.push(-1);\n  	}\n\n  	for (; i < len; i += 1) {\n  		newIndices.push(i + balance);\n  	}\n\n  	// there is a net shift for the rest of the array starting with index + balance\n  	if (balance !== 0) {\n  		newIndices.touchedFrom = spliceArguments[0];\n  	} else {\n  		newIndices.touchedFrom = array.length;\n  	}\n\n  	return newIndices;\n  }\n\n  // The pop, push, shift an unshift methods can all be represented\n  // as an equivalent splice\n  function getSpliceEquivalent(array, methodName, args) {\n  	switch (methodName) {\n  		case "splice":\n  			if (args[0] !== undefined && args[0] < 0) {\n  				args[0] = array.length + Math.max(args[0], -array.length);\n  			}\n\n  			while (args.length < 2) {\n  				args.push(0);\n  			}\n\n  			// ensure we only remove elements that exist\n  			args[1] = Math.min(args[1], array.length - args[0]);\n\n  			return args;\n\n  		case "sort":\n  		case "reverse":\n  			return null;\n\n  		case "pop":\n  			if (array.length) {\n  				return [array.length - 1, 1];\n  			}\n  			return [0, 0];\n\n  		case "push":\n  			return [array.length, 0].concat(args);\n\n  		case "shift":\n  			return [0, array.length ? 1 : 0];\n\n  		case "unshift":\n  			return [0, 0].concat(args);\n  	}\n  }\n\n  var arrayProto = Array.prototype;\n\n  var makeArrayMethod = function (methodName) {\n  	return function (keypath) {\n  		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  			args[_key - 1] = arguments[_key];\n  		}\n\n  		var array,\n  		    newIndices = [],\n  		    len,\n  		    promise,\n  		    result;\n\n  		keypath = getKeypath(normalise(keypath));\n\n  		array = this.viewmodel.get(keypath);\n  		len = array.length;\n\n  		if (!isArray(array)) {\n  			throw new Error("Called ractive." + methodName + "(\'" + keypath.str + "\'), but \'" + keypath.str + "\' does not refer to an array");\n  		}\n\n  		newIndices = shared_getNewIndices(array, methodName, args);\n\n  		result = arrayProto[methodName].apply(array, args);\n  		promise = global_runloop.start(this, true).then(function () {\n  			return result;\n  		});\n\n  		if (!!newIndices) {\n  			this.viewmodel.smartUpdate(keypath, array, newIndices);\n  		} else {\n  			this.viewmodel.mark(keypath);\n  		}\n\n  		global_runloop.end();\n\n  		return promise;\n  	};\n  };\n\n  var pop = makeArrayMethod("pop");\n\n  var push = makeArrayMethod("push");\n\n  var css,\n      update,\n      styleElement,\n      head,\n      styleSheet,\n      inDom,\n      global_css__prefix = "/* Ractive.js component styles */\\n",\n      styles = [],\n      dirty = false;\n\n  if (!isClient) {\n  	css = null;\n  } else {\n  	styleElement = document.createElement("style");\n  	styleElement.type = "text/css";\n\n  	head = document.getElementsByTagName("head")[0];\n\n  	inDom = false;\n\n  	// Internet Exploder won\'t let you use styleSheet.innerHTML - we have to\n  	// use styleSheet.cssText instead\n  	styleSheet = styleElement.styleSheet;\n\n  	update = function () {\n  		var css = global_css__prefix + styles.map(function (s) {\n  			return "\\n/* {" + s.id + "} */\\n" + s.styles;\n  		}).join("\\n");\n\n  		if (styleSheet) {\n  			styleSheet.cssText = css;\n  		} else {\n  			styleElement.innerHTML = css;\n  		}\n\n  		if (!inDom) {\n  			head.appendChild(styleElement);\n  			inDom = true;\n  		}\n  	};\n\n  	css = {\n  		add: function (s) {\n  			styles.push(s);\n  			dirty = true;\n  		},\n\n  		apply: function () {\n  			if (dirty) {\n  				update();\n  				dirty = false;\n  			}\n  		}\n  	};\n  }\n\n  var global_css = css;\n\n  var prototype_render = Ractive$render;\n\n  var renderHook = new hooks_Hook("render"),\n      completeHook = new hooks_Hook("complete");\n  function Ractive$render(target, anchor) {\n  	var _this = this;\n\n  	var promise, instances, transitionsEnabled;\n\n  	// if `noIntro` is `true`, temporarily disable transitions\n  	transitionsEnabled = this.transitionsEnabled;\n  	if (this.noIntro) {\n  		this.transitionsEnabled = false;\n  	}\n\n  	promise = global_runloop.start(this, true);\n  	global_runloop.scheduleTask(function () {\n  		return renderHook.fire(_this);\n  	}, true);\n\n  	if (this.fragment.rendered) {\n  		throw new Error("You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first");\n  	}\n\n  	target = getElement(target) || this.el;\n  	anchor = getElement(anchor) || this.anchor;\n\n  	this.el = target;\n  	this.anchor = anchor;\n\n  	if (!this.append && target) {\n  		// Teardown any existing instances *before* trying to set up the new one -\n  		// avoids certain weird bugs\n  		var others = target.__ractive_instances__;\n  		if (others && others.length) {\n  			removeOtherInstances(others);\n  		}\n\n  		// make sure we are the only occupants\n  		target.innerHTML = ""; // TODO is this quicker than removeChild? Initial research inconclusive\n  	}\n\n  	if (this.cssId) {\n  		// ensure encapsulated CSS is up-to-date\n  		global_css.apply();\n  	}\n\n  	if (target) {\n  		if (!(instances = target.__ractive_instances__)) {\n  			target.__ractive_instances__ = [this];\n  		} else {\n  			instances.push(this);\n  		}\n\n  		if (anchor) {\n  			target.insertBefore(this.fragment.render(), anchor);\n  		} else {\n  			target.appendChild(this.fragment.render());\n  		}\n  	}\n\n  	global_runloop.end();\n\n  	this.transitionsEnabled = transitionsEnabled;\n\n  	return promise.then(function () {\n  		return completeHook.fire(_this);\n  	});\n  }\n\n  function removeOtherInstances(others) {\n  	others.splice(0, others.length).forEach(teardown);\n  }\n\n  var adaptConfigurator = {\n  	extend: function (Parent, proto, options) {\n  		proto.adapt = custom_adapt__combine(proto.adapt, ensureArray(options.adapt));\n  	},\n\n  	init: function () {}\n  };\n\n  var custom_adapt = adaptConfigurator;\n\n  function custom_adapt__combine(a, b) {\n  	var c = a.slice(),\n  	    i = b.length;\n\n  	while (i--) {\n  		if (! ~c.indexOf(b[i])) {\n  			c.push(b[i]);\n  		}\n  	}\n\n  	return c;\n  }\n\n  var transform = transformCss;\n\n  var selectorsPattern = /(?:^|\\})?\\s*([^\\{\\}]+)\\s*\\{/g,\n      commentsPattern = /\\/\\*.*?\\*\\//g,\n      selectorUnitPattern = /((?:(?:\\[[^\\]+]\\])|(?:[^\\s\\+\\>\\~:]))+)((?::[^\\s\\+\\>\\~\\(]+(?:\\([^\\)]+\\))?)?\\s*[\\s\\+\\>\\~]?)\\s*/g,\n      mediaQueryPattern = /^@media/,\n      dataRvcGuidPattern = /\\[data-ractive-css~="\\{[a-z0-9-]+\\}"]/g;\n  function transformCss(css, id) {\n  	var transformed, dataAttr, addGuid;\n\n  	dataAttr = "[data-ractive-css~=\\"{" + id + "}\\"]";\n\n  	addGuid = function (selector) {\n  		var selectorUnits,\n  		    match,\n  		    unit,\n  		    base,\n  		    prepended,\n  		    appended,\n  		    i,\n  		    transformed = [];\n\n  		selectorUnits = [];\n\n  		while (match = selectorUnitPattern.exec(selector)) {\n  			selectorUnits.push({\n  				str: match[0],\n  				base: match[1],\n  				modifiers: match[2]\n  			});\n  		}\n\n  		// For each simple selector within the selector, we need to create a version\n  		// that a) combines with the id, and b) is inside the id\n  		base = selectorUnits.map(extractString);\n\n  		i = selectorUnits.length;\n  		while (i--) {\n  			appended = base.slice();\n\n  			// Pseudo-selectors should go after the attribute selector\n  			unit = selectorUnits[i];\n  			appended[i] = unit.base + dataAttr + unit.modifiers || "";\n\n  			prepended = base.slice();\n  			prepended[i] = dataAttr + " " + prepended[i];\n\n  			transformed.push(appended.join(" "), prepended.join(" "));\n  		}\n\n  		return transformed.join(", ");\n  	};\n\n  	if (dataRvcGuidPattern.test(css)) {\n  		transformed = css.replace(dataRvcGuidPattern, dataAttr);\n  	} else {\n  		transformed = css.replace(commentsPattern, "").replace(selectorsPattern, function (match, $1) {\n  			var selectors, transformed;\n\n  			// don\'t transform media queries!\n  			if (mediaQueryPattern.test($1)) return match;\n\n  			selectors = $1.split(",").map(trim);\n  			transformed = selectors.map(addGuid).join(", ") + " ";\n\n  			return match.replace($1, transformed);\n  		});\n  	}\n\n  	return transformed;\n  }\n\n  function trim(str) {\n  	if (str.trim) {\n  		return str.trim();\n  	}\n\n  	return str.replace(/^\\s+/, "").replace(/\\s+$/, "");\n  }\n\n  function extractString(unit) {\n  	return unit.str;\n  }\n\n  var css_css__uid = 1;\n\n  var cssConfigurator = {\n  	name: "css",\n\n  	extend: function (Parent, proto, options) {\n  		if (options.css) {\n  			var id = css_css__uid++;\n  			var styles = options.noCssTransform ? options.css : transform(options.css, id);\n\n  			proto.cssId = id;\n  			global_css.add({ id: id, styles: styles });\n  		}\n  	},\n\n  	init: function () {}\n  };\n\n  var css_css = cssConfigurator;\n\n  function validate(data) {\n  	// Warn if userOptions.data is a non-POJO\n  	if (data && data.constructor !== Object) {\n  		if (typeof data === "function") {} else if (typeof data !== "object") {\n  			fatal("data option must be an object or a function, `" + data + "` is not valid");\n  		} else {\n  			warnIfDebug("If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged");\n  		}\n  	}\n  }\n\n  var dataConfigurator = {\n  	name: "data",\n\n  	extend: function (Parent, proto, options) {\n  		var key = undefined,\n  		    value = undefined;\n\n  		// check for non-primitives, which could cause mutation-related bugs\n  		if (options.data && isObject(options.data)) {\n  			for (key in options.data) {\n  				value = options.data[key];\n\n  				if (value && typeof value === "object") {\n  					if (isObject(value) || isArray(value)) {\n  						warnIfDebug("Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\\n\\n  // this...\\n  data: function () {\\n    return {\\n      myObject: {}\\n    };\\n  })\\n\\n  // instead of this:\\n  data: {\\n    myObject: {}\\n  }");\n  					}\n  				}\n  			}\n  		}\n\n  		proto.data = custom_data__combine(proto.data, options.data);\n  	},\n\n  	init: function (Parent, ractive, options) {\n  		var result = custom_data__combine(Parent.prototype.data, options.data);\n\n  		if (typeof result === "function") {\n  			result = result.call(ractive);\n  		}\n\n  		return result || {};\n  	},\n\n  	reset: function (ractive) {\n  		var result = this.init(ractive.constructor, ractive, ractive.viewmodel);\n\n  		ractive.viewmodel.reset(result);\n  		return true;\n  	}\n  };\n\n  var custom_data = dataConfigurator;\n\n  function custom_data__combine(parentValue, childValue) {\n  	validate(childValue);\n\n  	var parentIsFn = typeof parentValue === "function";\n  	var childIsFn = typeof childValue === "function";\n\n  	// Very important, otherwise child instance can become\n  	// the default data object on Ractive or a component.\n  	// then ractive.set() ends up setting on the prototype!\n  	if (!childValue && !parentIsFn) {\n  		childValue = {};\n  	}\n\n  	// Fast path, where we just need to copy properties from\n  	// parent to child\n  	if (!parentIsFn && !childIsFn) {\n  		return fromProperties(childValue, parentValue);\n  	}\n\n  	return function () {\n  		var child = childIsFn ? callDataFunction(childValue, this) : childValue;\n  		var parent = parentIsFn ? callDataFunction(parentValue, this) : parentValue;\n\n  		return fromProperties(child, parent);\n  	};\n  }\n\n  function callDataFunction(fn, context) {\n  	var data = fn.call(context);\n\n  	if (!data) return;\n\n  	if (typeof data !== "object") {\n  		fatal("Data function must return an object");\n  	}\n\n  	if (data.constructor !== Object) {\n  		warnOnceIfDebug("Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged");\n  	}\n\n  	return data;\n  }\n\n  function fromProperties(primary, secondary) {\n  	if (primary && secondary) {\n  		for (var key in secondary) {\n  			if (!(key in primary)) {\n  				primary[key] = secondary[key];\n  			}\n  		}\n\n  		return primary;\n  	}\n\n  	return primary || secondary;\n  }\n\n  // TODO do we need to support this in the new Ractive() case?\n\n  var Parser,\n      ParseError,\n      parse_Parser__leadingWhitespace = /^\\s+/;\n\n  ParseError = function (message) {\n  	this.name = "ParseError";\n  	this.message = message;\n  	try {\n  		throw new Error(message);\n  	} catch (e) {\n  		this.stack = e.stack;\n  	}\n  };\n\n  ParseError.prototype = Error.prototype;\n\n  Parser = function (str, options) {\n  	var items,\n  	    item,\n  	    lineStart = 0;\n\n  	this.str = str;\n  	this.options = options || {};\n  	this.pos = 0;\n\n  	this.lines = this.str.split("\\n");\n  	this.lineEnds = this.lines.map(function (line) {\n  		var lineEnd = lineStart + line.length + 1; // +1 for the newline\n\n  		lineStart = lineEnd;\n  		return lineEnd;\n  	}, 0);\n\n  	// Custom init logic\n  	if (this.init) this.init(str, options);\n\n  	items = [];\n\n  	while (this.pos < this.str.length && (item = this.read())) {\n  		items.push(item);\n  	}\n\n  	this.leftover = this.remaining();\n  	this.result = this.postProcess ? this.postProcess(items, options) : items;\n  };\n\n  Parser.prototype = {\n  	read: function (converters) {\n  		var pos, i, len, item;\n\n  		if (!converters) converters = this.converters;\n\n  		pos = this.pos;\n\n  		len = converters.length;\n  		for (i = 0; i < len; i += 1) {\n  			this.pos = pos; // reset for each attempt\n\n  			if (item = converters[i](this)) {\n  				return item;\n  			}\n  		}\n\n  		return null;\n  	},\n\n  	getLinePos: function (char) {\n  		var lineNum = 0,\n  		    lineStart = 0,\n  		    columnNum;\n\n  		while (char >= this.lineEnds[lineNum]) {\n  			lineStart = this.lineEnds[lineNum];\n  			lineNum += 1;\n  		}\n\n  		columnNum = char - lineStart;\n  		return [lineNum + 1, columnNum + 1, char]; // line/col should be one-based, not zero-based!\n  	},\n\n  	error: function (message) {\n  		var pos = this.getLinePos(this.pos);\n  		var lineNum = pos[0];\n  		var columnNum = pos[1];\n\n  		var line = this.lines[pos[0] - 1];\n  		var numTabs = 0;\n  		var annotation = line.replace(/\\t/g, function (match, char) {\n  			if (char < pos[1]) {\n  				numTabs += 1;\n  			}\n\n  			return "  ";\n  		}) + "\\n" + new Array(pos[1] + numTabs).join(" ") + "^----";\n\n  		var error = new ParseError("" + message + " at line " + lineNum + " character " + columnNum + ":\\n" + annotation);\n\n  		error.line = pos[0];\n  		error.character = pos[1];\n  		error.shortMessage = message;\n\n  		throw error;\n  	},\n\n  	matchString: function (string) {\n  		if (this.str.substr(this.pos, string.length) === string) {\n  			this.pos += string.length;\n  			return string;\n  		}\n  	},\n\n  	matchPattern: function (pattern) {\n  		var match;\n\n  		if (match = pattern.exec(this.remaining())) {\n  			this.pos += match[0].length;\n  			return match[1] || match[0];\n  		}\n  	},\n\n  	allowWhitespace: function () {\n  		this.matchPattern(parse_Parser__leadingWhitespace);\n  	},\n\n  	remaining: function () {\n  		return this.str.substring(this.pos);\n  	},\n\n  	nextChar: function () {\n  		return this.str.charAt(this.pos);\n  	}\n  };\n\n  Parser.extend = function (proto) {\n  	var Parent = this,\n  	    Child,\n  	    key;\n\n  	Child = function (str, options) {\n  		Parser.call(this, str, options);\n  	};\n\n  	Child.prototype = create(Parent.prototype);\n\n  	for (key in proto) {\n  		if (hasOwn.call(proto, key)) {\n  			Child.prototype[key] = proto[key];\n  		}\n  	}\n\n  	Child.extend = Parser.extend;\n  	return Child;\n  };\n\n  var parse_Parser = Parser;\n\n  var TEXT = 1;\n  var INTERPOLATOR = 2;\n  var TRIPLE = 3;\n  var SECTION = 4;\n  var INVERTED = 5;\n  var CLOSING = 6;\n  var ELEMENT = 7;\n  var PARTIAL = 8;\n  var COMMENT = 9;\n  var DELIMCHANGE = 10;\n  var ATTRIBUTE = 13;\n  var CLOSING_TAG = 14;\n  var COMPONENT = 15;\n  var YIELDER = 16;\n  var INLINE_PARTIAL = 17;\n  var DOCTYPE = 18;\n\n  var NUMBER_LITERAL = 20;\n  var STRING_LITERAL = 21;\n  var ARRAY_LITERAL = 22;\n  var OBJECT_LITERAL = 23;\n  var BOOLEAN_LITERAL = 24;\n  var REGEXP_LITERAL = 25;\n\n  var GLOBAL = 26;\n  var KEY_VALUE_PAIR = 27;\n\n  var REFERENCE = 30;\n  var REFINEMENT = 31;\n  var MEMBER = 32;\n  var PREFIX_OPERATOR = 33;\n  var BRACKETED = 34;\n  var CONDITIONAL = 35;\n  var INFIX_OPERATOR = 36;\n\n  var INVOCATION = 40;\n\n  var SECTION_IF = 50;\n  var SECTION_UNLESS = 51;\n  var SECTION_EACH = 52;\n  var SECTION_WITH = 53;\n  var SECTION_IF_WITH = 54;\n\n  var ELSE = 60;\n  var ELSEIF = 61;\n\n  var mustache_readDelimiterChange = readDelimiterChange;\n  var delimiterChangePattern = /^[^\\s=]+/,\n      whitespacePattern = /^\\s+/;\n  function readDelimiterChange(parser) {\n  	var start, opening, closing;\n\n  	if (!parser.matchString("=")) {\n  		return null;\n  	}\n\n  	start = parser.pos;\n\n  	// allow whitespace before new opening delimiter\n  	parser.allowWhitespace();\n\n  	opening = parser.matchPattern(delimiterChangePattern);\n  	if (!opening) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	// allow whitespace (in fact, it\'s necessary...)\n  	if (!parser.matchPattern(whitespacePattern)) {\n  		return null;\n  	}\n\n  	closing = parser.matchPattern(delimiterChangePattern);\n  	if (!closing) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	// allow whitespace before closing \'=\'\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("=")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	return [opening, closing];\n  }\n\n  var readRegexpLiteral = readRegexpLiteral__readNumberLiteral;\n  var regexpPattern = /^(\\/(?:[^\\n\\r\\u2028\\u2029/\\\\[]|\\\\.|\\[(?:[^\\n\\r\\u2028\\u2029\\]\\\\]|\\\\.)*])+\\/(?:([gimuy])(?![a-z]*\\2))*(?![a-zA-Z_$0-9]))/;\n  function readRegexpLiteral__readNumberLiteral(parser) {\n  	var result;\n\n  	if (result = parser.matchPattern(regexpPattern)) {\n  		return {\n  			t: REGEXP_LITERAL,\n  			v: result\n  		};\n  	}\n\n  	return null;\n  }\n\n  var converters_readMustache = readMustache;\n\n  var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };\n  function readMustache(parser) {\n  	var mustache, i;\n\n  	// If we\'re inside a <script> or <style> tag, and we\'re not\n  	// interpolating, bug out\n  	if (parser.interpolate[parser.inside] === false) {\n  		return null;\n  	}\n\n  	for (i = 0; i < parser.tags.length; i += 1) {\n  		if (mustache = readMustacheOfType(parser, parser.tags[i])) {\n  			return mustache;\n  		}\n  	}\n  }\n\n  function readMustacheOfType(parser, tag) {\n  	var start, mustache, reader, i;\n\n  	start = parser.pos;\n\n  	if (parser.matchString("\\\\" + tag.open)) {\n  		if (start === 0 || parser.str[start - 1] !== "\\\\") {\n  			return tag.open;\n  		}\n  	} else if (!parser.matchString(tag.open)) {\n  		return null;\n  	}\n\n  	// delimiter change?\n  	if (mustache = mustache_readDelimiterChange(parser)) {\n  		// find closing delimiter or abort...\n  		if (!parser.matchString(tag.close)) {\n  			return null;\n  		}\n\n  		// ...then make the switch\n  		tag.open = mustache[0];\n  		tag.close = mustache[1];\n  		parser.sortMustacheTags();\n\n  		return delimiterChangeToken;\n  	}\n\n  	parser.allowWhitespace();\n\n  	// illegal section closer\n  	if (parser.matchString("/")) {\n  		parser.pos -= 1;\n  		var rewind = parser.pos;\n  		if (!readRegexpLiteral(parser)) {\n  			parser.pos = rewind - tag.close.length;\n  			parser.error("Attempted to close a section that wasn\'t open");\n  		} else {\n  			parser.pos = rewind;\n  		}\n  	}\n\n  	for (i = 0; i < tag.readers.length; i += 1) {\n  		reader = tag.readers[i];\n\n  		if (mustache = reader(parser, tag)) {\n  			if (tag.isStatic) {\n  				mustache.s = true; // TODO make this `1` instead - more compact\n  			}\n\n  			if (parser.includeLinePositions) {\n  				mustache.p = parser.getLinePos(start);\n  			}\n\n  			return mustache;\n  		}\n  	}\n\n  	parser.pos = start;\n  	return null;\n  }\n\n  var expectedExpression = "Expected a JavaScript expression";\n  var expectedParen = "Expected closing paren";\n\n  var literal_readNumberLiteral = literal_readNumberLiteral__readNumberLiteral;\n  var literal_readNumberLiteral__numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n  function literal_readNumberLiteral__readNumberLiteral(parser) {\n  	var result;\n\n  	if (result = parser.matchPattern(literal_readNumberLiteral__numberPattern)) {\n  		return {\n  			t: NUMBER_LITERAL,\n  			v: result\n  		};\n  	}\n\n  	return null;\n  }\n\n  var literal_readBooleanLiteral = readBooleanLiteral;\n  function readBooleanLiteral(parser) {\n  	var remaining = parser.remaining();\n\n  	if (remaining.substr(0, 4) === "true") {\n  		parser.pos += 4;\n  		return {\n  			t: BOOLEAN_LITERAL,\n  			v: "true"\n  		};\n  	}\n\n  	if (remaining.substr(0, 5) === "false") {\n  		parser.pos += 5;\n  		return {\n  			t: BOOLEAN_LITERAL,\n  			v: "false"\n  		};\n  	}\n\n  	return null;\n  }\n\n  var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;\n\n  // Match one or more characters until: ", \', \\, or EOL/EOF.\n  // EOL/EOF is written as (?!.) (meaning there\'s no non-newline char next).\n  stringMiddlePattern = /^(?=.)[^"\'\\\\]+?(?:(?!.)|(?=["\'\\\\]))/;\n\n  // Match one escape sequence, including the backslash.\n  escapeSequencePattern = /^\\\\(?:[\'"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\n  // Match one ES5 line continuation (backslash + line terminator).\n  lineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\n  // Helper for defining getDoubleQuotedString and getSingleQuotedString.\n  var makeQuotedStringMatcher = function (okQuote) {\n  	return function (parser) {\n  		var start, literal, done, next;\n\n  		start = parser.pos;\n  		literal = "\\"";\n  		done = false;\n\n  		while (!done) {\n  			next = parser.matchPattern(stringMiddlePattern) || parser.matchPattern(escapeSequencePattern) || parser.matchString(okQuote);\n  			if (next) {\n  				if (next === "\\"") {\n  					literal += "\\\\\\"";\n  				} else if (next === "\\\\\'") {\n  					literal += "\'";\n  				} else {\n  					literal += next;\n  				}\n  			} else {\n  				next = parser.matchPattern(lineContinuationPattern);\n  				if (next) {\n  					// convert \\(newline-like) into a \\u escape, which is allowed in JSON\n  					literal += "\\\\u" + ("000" + next.charCodeAt(1).toString(16)).slice(-4);\n  				} else {\n  					done = true;\n  				}\n  			}\n  		}\n\n  		literal += "\\"";\n\n  		// use JSON.parse to interpret escapes\n  		return JSON.parse(literal);\n  	};\n  };\n\n  var getSingleQuotedString = makeQuotedStringMatcher("\\"");\n  var getDoubleQuotedString = makeQuotedStringMatcher("\'");\n\n  var readStringLiteral = function (parser) {\n  	var start, string;\n\n  	start = parser.pos;\n\n  	if (parser.matchString("\\"")) {\n  		string = getDoubleQuotedString(parser);\n\n  		if (!parser.matchString("\\"")) {\n  			parser.pos = start;\n  			return null;\n  		}\n\n  		return {\n  			t: STRING_LITERAL,\n  			v: string\n  		};\n  	}\n\n  	if (parser.matchString("\'")) {\n  		string = getSingleQuotedString(parser);\n\n  		if (!parser.matchString("\'")) {\n  			parser.pos = start;\n  			return null;\n  		}\n\n  		return {\n  			t: STRING_LITERAL,\n  			v: string\n  		};\n  	}\n\n  	return null;\n  };\n\n  var patterns__name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;\n\n  // http://mathiasbynens.be/notes/javascript-properties\n  // can be any name, string literal, or number literal\n  var shared_readKey = readKey;\n  var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n  function readKey(parser) {\n  	var token;\n\n  	if (token = readStringLiteral(parser)) {\n  		return identifier.test(token.v) ? token.v : "\\"" + token.v.replace(/"/g, "\\\\\\"") + "\\"";\n  	}\n\n  	if (token = literal_readNumberLiteral(parser)) {\n  		return token.v;\n  	}\n\n  	if (token = parser.matchPattern(patterns__name)) {\n  		return token;\n  	}\n  }\n\n  var keyValuePair = readKeyValuePair;\n  function readKeyValuePair(parser) {\n  	var start, key, value;\n\n  	start = parser.pos;\n\n  	// allow whitespace between \'{\' and key\n  	parser.allowWhitespace();\n\n  	key = shared_readKey(parser);\n  	if (key === null) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	// allow whitespace between key and \':\'\n  	parser.allowWhitespace();\n\n  	// next character must be \':\'\n  	if (!parser.matchString(":")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	// allow whitespace between \':\' and value\n  	parser.allowWhitespace();\n\n  	// next expression must be a, well... expression\n  	value = converters_readExpression(parser);\n  	if (value === null) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	return {\n  		t: KEY_VALUE_PAIR,\n  		k: key,\n  		v: value\n  	};\n  }\n\n  var objectLiteral_keyValuePairs = readKeyValuePairs;\n  function readKeyValuePairs(parser) {\n  	var start, pairs, pair, keyValuePairs;\n\n  	start = parser.pos;\n\n  	pair = keyValuePair(parser);\n  	if (pair === null) {\n  		return null;\n  	}\n\n  	pairs = [pair];\n\n  	if (parser.matchString(",")) {\n  		keyValuePairs = readKeyValuePairs(parser);\n\n  		if (!keyValuePairs) {\n  			parser.pos = start;\n  			return null;\n  		}\n\n  		return pairs.concat(keyValuePairs);\n  	}\n\n  	return pairs;\n  }\n\n  var readObjectLiteral = function (parser) {\n  	var start, keyValuePairs;\n\n  	start = parser.pos;\n\n  	// allow whitespace\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("{")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	keyValuePairs = objectLiteral_keyValuePairs(parser);\n\n  	// allow whitespace between final value and \'}\'\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("}")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	return {\n  		t: OBJECT_LITERAL,\n  		m: keyValuePairs\n  	};\n  };\n\n  var shared_readExpressionList = readExpressionList;\n  function readExpressionList(parser) {\n  	var start, expressions, expr, next;\n\n  	start = parser.pos;\n\n  	parser.allowWhitespace();\n\n  	expr = converters_readExpression(parser);\n\n  	if (expr === null) {\n  		return null;\n  	}\n\n  	expressions = [expr];\n\n  	// allow whitespace between expression and \',\'\n  	parser.allowWhitespace();\n\n  	if (parser.matchString(",")) {\n  		next = readExpressionList(parser);\n  		if (next === null) {\n  			parser.error(expectedExpression);\n  		}\n\n  		next.forEach(append);\n  	}\n\n  	function append(expression) {\n  		expressions.push(expression);\n  	}\n\n  	return expressions;\n  }\n\n  var readArrayLiteral = function (parser) {\n  	var start, expressionList;\n\n  	start = parser.pos;\n\n  	// allow whitespace before \'[\'\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("[")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	expressionList = shared_readExpressionList(parser);\n\n  	if (!parser.matchString("]")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	return {\n  		t: ARRAY_LITERAL,\n  		m: expressionList\n  	};\n  };\n\n  var primary_readLiteral = readLiteral;\n  function readLiteral(parser) {\n  	return literal_readNumberLiteral(parser) || literal_readBooleanLiteral(parser) || readStringLiteral(parser) || readObjectLiteral(parser) || readArrayLiteral(parser) || readRegexpLiteral(parser);\n  }\n\n  var primary_readReference = readReference;\n  var prefixPattern = /^(?:~\\/|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/,\n      globals,\n      keywords;\n\n  // if a reference is a browser global, we don\'t deference it later, so it needs special treatment\n  globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)\\b/;\n\n  // keywords are not valid references, with the exception of `this`\n  keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\n  var legalReference = /^[a-zA-Z$_0-9]+(?:(?:\\.[a-zA-Z$_0-9]+)|(?:\\[[0-9]+\\]))*/;\n  var relaxedName = /^[a-zA-Z_$][-a-zA-Z_$0-9]*/;\n  function readReference(parser) {\n  	var startPos, prefix, name, global, reference, lastDotIndex;\n\n  	startPos = parser.pos;\n\n  	name = parser.matchPattern(/^@(?:keypath|index|key)/);\n\n  	if (!name) {\n  		prefix = parser.matchPattern(prefixPattern) || "";\n  		name = !prefix && parser.relaxedNames && parser.matchPattern(relaxedName) || parser.matchPattern(legalReference);\n\n  		if (!name && prefix === ".") {\n  			prefix = "";\n  			name = ".";\n  		}\n  	}\n\n  	if (!name) {\n  		return null;\n  	}\n\n  	// bug out if it\'s a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)\n  	if (!prefix && !parser.relaxedNames && keywords.test(name)) {\n  		parser.pos = startPos;\n  		return null;\n  	}\n\n  	// if this is a browser global, stop here\n  	if (!prefix && globals.test(name)) {\n  		global = globals.exec(name)[0];\n  		parser.pos = startPos + global.length;\n\n  		return {\n  			t: GLOBAL,\n  			v: global\n  		};\n  	}\n\n  	reference = (prefix || "") + normalise(name);\n\n  	if (parser.matchString("(")) {\n  		// if this is a method invocation (as opposed to a function) we need\n  		// to strip the method name from the reference combo, else the context\n  		// will be wrong\n  		lastDotIndex = reference.lastIndexOf(".");\n  		if (lastDotIndex !== -1) {\n  			reference = reference.substr(0, lastDotIndex);\n  			parser.pos = startPos + reference.length;\n  		} else {\n  			parser.pos -= 1;\n  		}\n  	}\n\n  	return {\n  		t: REFERENCE,\n  		n: reference.replace(/^this\\./, "./").replace(/^this$/, ".")\n  	};\n  }\n\n  var primary_readBracketedExpression = readBracketedExpression;\n  function readBracketedExpression(parser) {\n  	var start, expr;\n\n  	start = parser.pos;\n\n  	if (!parser.matchString("(")) {\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	expr = converters_readExpression(parser);\n  	if (!expr) {\n  		parser.error(expectedExpression);\n  	}\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString(")")) {\n  		parser.error(expectedParen);\n  	}\n\n  	return {\n  		t: BRACKETED,\n  		x: expr\n  	};\n  }\n\n  var readPrimary = function (parser) {\n  	return primary_readLiteral(parser) || primary_readReference(parser) || primary_readBracketedExpression(parser);\n  };\n\n  var shared_readRefinement = readRefinement;\n  function readRefinement(parser) {\n  	var start, name, expr;\n\n  	start = parser.pos;\n\n  	parser.allowWhitespace();\n\n  	// "." name\n  	if (parser.matchString(".")) {\n  		parser.allowWhitespace();\n\n  		if (name = parser.matchPattern(patterns__name)) {\n  			return {\n  				t: REFINEMENT,\n  				n: name\n  			};\n  		}\n\n  		parser.error("Expected a property name");\n  	}\n\n  	// "[" expression "]"\n  	if (parser.matchString("[")) {\n  		parser.allowWhitespace();\n\n  		expr = converters_readExpression(parser);\n  		if (!expr) {\n  			parser.error(expectedExpression);\n  		}\n\n  		parser.allowWhitespace();\n\n  		if (!parser.matchString("]")) {\n  			parser.error("Expected \']\'");\n  		}\n\n  		return {\n  			t: REFINEMENT,\n  			x: expr\n  		};\n  	}\n\n  	return null;\n  }\n\n  var readMemberOrInvocation = function (parser) {\n  	var current, expression, refinement, expressionList;\n\n  	expression = readPrimary(parser);\n\n  	if (!expression) {\n  		return null;\n  	}\n\n  	while (expression) {\n  		current = parser.pos;\n\n  		if (refinement = shared_readRefinement(parser)) {\n  			expression = {\n  				t: MEMBER,\n  				x: expression,\n  				r: refinement\n  			};\n  		} else if (parser.matchString("(")) {\n  			parser.allowWhitespace();\n  			expressionList = shared_readExpressionList(parser);\n\n  			parser.allowWhitespace();\n\n  			if (!parser.matchString(")")) {\n  				parser.error(expectedParen);\n  			}\n\n  			expression = {\n  				t: INVOCATION,\n  				x: expression\n  			};\n\n  			if (expressionList) {\n  				expression.o = expressionList;\n  			}\n  		} else {\n  			break;\n  		}\n  	}\n\n  	return expression;\n  };\n\n  var readTypeOf, makePrefixSequenceMatcher;\n\n  makePrefixSequenceMatcher = function (symbol, fallthrough) {\n  	return function (parser) {\n  		var expression;\n\n  		if (expression = fallthrough(parser)) {\n  			return expression;\n  		}\n\n  		if (!parser.matchString(symbol)) {\n  			return null;\n  		}\n\n  		parser.allowWhitespace();\n\n  		expression = converters_readExpression(parser);\n  		if (!expression) {\n  			parser.error(expectedExpression);\n  		}\n\n  		return {\n  			s: symbol,\n  			o: expression,\n  			t: PREFIX_OPERATOR\n  		};\n  	};\n  };\n\n  // create all prefix sequence matchers, return readTypeOf\n  (function () {\n  	var i, len, matcher, prefixOperators, fallthrough;\n\n  	prefixOperators = "! ~ + - typeof".split(" ");\n\n  	fallthrough = readMemberOrInvocation;\n  	for (i = 0, len = prefixOperators.length; i < len; i += 1) {\n  		matcher = makePrefixSequenceMatcher(prefixOperators[i], fallthrough);\n  		fallthrough = matcher;\n  	}\n\n  	// typeof operator is higher precedence than multiplication, so provides the\n  	// fallthrough for the multiplication sequence matcher we\'re about to create\n  	// (we\'re skipping void and delete)\n  	readTypeOf = fallthrough;\n  })();\n\n  var readTypeof = readTypeOf;\n\n  var readLogicalOr, makeInfixSequenceMatcher;\n\n  makeInfixSequenceMatcher = function (symbol, fallthrough) {\n  	return function (parser) {\n  		var start, left, right;\n\n  		left = fallthrough(parser);\n  		if (!left) {\n  			return null;\n  		}\n\n  		// Loop to handle left-recursion in a case like `a * b * c` and produce\n  		// left association, i.e. `(a * b) * c`.  The matcher can\'t call itself\n  		// to parse `left` because that would be infinite regress.\n  		while (true) {\n  			start = parser.pos;\n\n  			parser.allowWhitespace();\n\n  			if (!parser.matchString(symbol)) {\n  				parser.pos = start;\n  				return left;\n  			}\n\n  			// special case - in operator must not be followed by [a-zA-Z_$0-9]\n  			if (symbol === "in" && /[a-zA-Z_$0-9]/.test(parser.remaining().charAt(0))) {\n  				parser.pos = start;\n  				return left;\n  			}\n\n  			parser.allowWhitespace();\n\n  			// right operand must also consist of only higher-precedence operators\n  			right = fallthrough(parser);\n  			if (!right) {\n  				parser.pos = start;\n  				return left;\n  			}\n\n  			left = {\n  				t: INFIX_OPERATOR,\n  				s: symbol,\n  				o: [left, right]\n  			};\n\n  			// Loop back around.  If we don\'t see another occurrence of the symbol,\n  			// we\'ll return left.\n  		}\n  	};\n  };\n\n  // create all infix sequence matchers, and return readLogicalOr\n  (function () {\n  	var i, len, matcher, infixOperators, fallthrough;\n\n  	// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n  	// Each sequence matcher will initially fall through to its higher precedence\n  	// neighbour, and only attempt to match if one of the higher precedence operators\n  	// (or, ultimately, a literal, reference, or bracketed expression) already matched\n  	infixOperators = "* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||".split(" ");\n\n  	// A typeof operator is higher precedence than multiplication\n  	fallthrough = readTypeof;\n  	for (i = 0, len = infixOperators.length; i < len; i += 1) {\n  		matcher = makeInfixSequenceMatcher(infixOperators[i], fallthrough);\n  		fallthrough = matcher;\n  	}\n\n  	// Logical OR is the fallthrough for the conditional matcher\n  	readLogicalOr = fallthrough;\n  })();\n\n  var expressions_readLogicalOr = readLogicalOr;\n\n  // The conditional operator is the lowest precedence operator, so we start here\n  var readConditional = getConditional;\n  function getConditional(parser) {\n  	var start, expression, ifTrue, ifFalse;\n\n  	expression = expressions_readLogicalOr(parser);\n  	if (!expression) {\n  		return null;\n  	}\n\n  	start = parser.pos;\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("?")) {\n  		parser.pos = start;\n  		return expression;\n  	}\n\n  	parser.allowWhitespace();\n\n  	ifTrue = converters_readExpression(parser);\n  	if (!ifTrue) {\n  		parser.error(expectedExpression);\n  	}\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString(":")) {\n  		parser.error("Expected \\":\\"");\n  	}\n\n  	parser.allowWhitespace();\n\n  	ifFalse = converters_readExpression(parser);\n  	if (!ifFalse) {\n  		parser.error(expectedExpression);\n  	}\n\n  	return {\n  		t: CONDITIONAL,\n  		o: [expression, ifTrue, ifFalse]\n  	};\n  }\n\n  var converters_readExpression = readExpression;\n  function readExpression(parser) {\n  	// The conditional operator is the lowest precedence operator (except yield,\n  	// assignment operators, and commas, none of which are supported), so we\n  	// start there. If it doesn\'t match, it \'falls through\' to progressively\n  	// higher precedence operators, until it eventually matches (or fails to\n  	// match) a \'primary\' - a literal or a reference. This way, the abstract syntax\n  	// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n  	return readConditional(parser);\n  }\n\n  var utils_flattenExpression = flattenExpression;\n\n  function flattenExpression(expression) {\n  	var refs;\n\n  	extractRefs(expression, refs = []);\n\n  	return {\n  		r: refs,\n  		s: stringify(expression)\n  	};\n\n  	function stringify(node) {\n  		switch (node.t) {\n  			case BOOLEAN_LITERAL:\n  			case GLOBAL:\n  			case NUMBER_LITERAL:\n  			case REGEXP_LITERAL:\n  				return node.v;\n\n  			case STRING_LITERAL:\n  				return JSON.stringify(String(node.v));\n\n  			case ARRAY_LITERAL:\n  				return "[" + (node.m ? node.m.map(stringify).join(",") : "") + "]";\n\n  			case OBJECT_LITERAL:\n  				return "{" + (node.m ? node.m.map(stringify).join(",") : "") + "}";\n\n  			case KEY_VALUE_PAIR:\n  				return node.k + ":" + stringify(node.v);\n\n  			case PREFIX_OPERATOR:\n  				return (node.s === "typeof" ? "typeof " : node.s) + stringify(node.o);\n\n  			case INFIX_OPERATOR:\n  				return stringify(node.o[0]) + (node.s.substr(0, 2) === "in" ? " " + node.s + " " : node.s) + stringify(node.o[1]);\n\n  			case INVOCATION:\n  				return stringify(node.x) + "(" + (node.o ? node.o.map(stringify).join(",") : "") + ")";\n\n  			case BRACKETED:\n  				return "(" + stringify(node.x) + ")";\n\n  			case MEMBER:\n  				return stringify(node.x) + stringify(node.r);\n\n  			case REFINEMENT:\n  				return node.n ? "." + node.n : "[" + stringify(node.x) + "]";\n\n  			case CONDITIONAL:\n  				return stringify(node.o[0]) + "?" + stringify(node.o[1]) + ":" + stringify(node.o[2]);\n\n  			case REFERENCE:\n  				return "_" + refs.indexOf(node.n);\n\n  			default:\n  				throw new Error("Expected legal JavaScript");\n  		}\n  	}\n  }\n\n  // TODO maybe refactor this?\n  function extractRefs(node, refs) {\n  	var i, list;\n\n  	if (node.t === REFERENCE) {\n  		if (refs.indexOf(node.n) === -1) {\n  			refs.unshift(node.n);\n  		}\n  	}\n\n  	list = node.o || node.m;\n  	if (list) {\n  		if (isObject(list)) {\n  			extractRefs(list, refs);\n  		} else {\n  			i = list.length;\n  			while (i--) {\n  				extractRefs(list[i], refs);\n  			}\n  		}\n  	}\n\n  	if (node.x) {\n  		extractRefs(node.x, refs);\n  	}\n\n  	if (node.r) {\n  		extractRefs(node.r, refs);\n  	}\n\n  	if (node.v) {\n  		extractRefs(node.v, refs);\n  	}\n  }\n\n  var utils_refineExpression = refineExpression;\n\n  var arrayMemberPattern = /^[0-9][1-9]*$/;\n  function refineExpression(expression, mustache) {\n  	var referenceExpression;\n\n  	if (expression) {\n  		while (expression.t === BRACKETED && expression.x) {\n  			expression = expression.x;\n  		}\n\n  		// special case - integers should be treated as array members references,\n  		// rather than as expressions in their own right\n  		if (expression.t === REFERENCE) {\n  			mustache.r = expression.n;\n  		} else {\n  			if (expression.t === NUMBER_LITERAL && arrayMemberPattern.test(expression.v)) {\n  				mustache.r = expression.v;\n  			} else if (referenceExpression = getReferenceExpression(expression)) {\n  				mustache.rx = referenceExpression;\n  			} else {\n  				mustache.x = utils_flattenExpression(expression);\n  			}\n  		}\n\n  		return mustache;\n  	}\n  }\n\n  // TODO refactor this! it\'s bewildering\n  function getReferenceExpression(expression) {\n  	var members = [],\n  	    refinement;\n\n  	while (expression.t === MEMBER && expression.r.t === REFINEMENT) {\n  		refinement = expression.r;\n\n  		if (refinement.x) {\n  			if (refinement.x.t === REFERENCE) {\n  				members.unshift(refinement.x);\n  			} else {\n  				members.unshift(utils_flattenExpression(refinement.x));\n  			}\n  		} else {\n  			members.unshift(refinement.n);\n  		}\n\n  		expression = expression.x;\n  	}\n\n  	if (expression.t !== REFERENCE) {\n  		return null;\n  	}\n\n  	return {\n  		r: expression.n,\n  		m: members\n  	};\n  }\n\n  var mustache_readTriple = readTriple;\n  function readTriple(parser, tag) {\n  	var expression = converters_readExpression(parser),\n  	    triple;\n\n  	if (!expression) {\n  		return null;\n  	}\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	triple = { t: TRIPLE };\n  	utils_refineExpression(expression, triple); // TODO handle this differently - it\'s mysterious\n\n  	return triple;\n  }\n\n  var mustache_readUnescaped = readUnescaped;\n  function readUnescaped(parser, tag) {\n  	var expression, triple;\n\n  	if (!parser.matchString("&")) {\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	expression = converters_readExpression(parser);\n\n  	if (!expression) {\n  		return null;\n  	}\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	triple = { t: TRIPLE };\n  	utils_refineExpression(expression, triple); // TODO handle this differently - it\'s mysterious\n\n  	return triple;\n  }\n\n  var mustache_readPartial = readPartial;\n  function readPartial(parser, tag) {\n  	var start, nameStart, expression, context, partial;\n\n  	start = parser.pos;\n\n  	if (!parser.matchString(">")) {\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n  	nameStart = parser.pos;\n\n  	// Partial names can include hyphens, so we can\'t use readExpression\n  	// blindly. Instead, we use the `relaxedNames` flag to indicate that\n  	// `foo-bar` should be read as a single name, rather than \'subtract\n  	// bar from foo\'\n  	parser.relaxedNames = true;\n  	expression = converters_readExpression(parser);\n  	parser.relaxedNames = false;\n\n  	parser.allowWhitespace();\n  	context = converters_readExpression(parser);\n  	parser.allowWhitespace();\n\n  	if (!expression) {\n  		return null;\n  	}\n\n  	partial = { t: PARTIAL };\n  	utils_refineExpression(expression, partial); // TODO...\n\n  	parser.allowWhitespace();\n\n  	// if we have another expression - e.g. `{{>foo bar}}` - then\n  	// we turn it into `{{#with bar}}{{>foo}}{{/with}}`\n  	if (context) {\n  		partial = {\n  			t: SECTION,\n  			n: SECTION_WITH,\n  			f: [partial]\n  		};\n\n  		utils_refineExpression(context, partial);\n  	}\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	return partial;\n  }\n\n  var readMustacheComment = readComment;\n  function readComment(parser, tag) {\n  	var index;\n\n  	if (!parser.matchString("!")) {\n  		return null;\n  	}\n\n  	index = parser.remaining().indexOf(tag.close);\n\n  	if (index !== -1) {\n  		parser.pos += index + tag.close.length;\n  		return { t: COMMENT };\n  	}\n  }\n\n  var converters_readExpressionOrReference = readExpressionOrReference;\n  function readExpressionOrReference(parser, expectedFollowers) {\n  	var start, expression, i;\n\n  	start = parser.pos;\n  	expression = converters_readExpression(parser);\n\n  	if (!expression) {\n  		return null;\n  	}\n\n  	for (i = 0; i < expectedFollowers.length; i += 1) {\n  		if (parser.remaining().substr(0, expectedFollowers[i].length) === expectedFollowers[i]) {\n  			return expression;\n  		}\n  	}\n\n  	parser.pos = start;\n  	return primary_readReference(parser);\n  }\n\n  var mustache_readInterpolator = readInterpolator;\n  function readInterpolator(parser, tag) {\n  	var start, expression, interpolator, err;\n\n  	start = parser.pos;\n\n  	// TODO would be good for perf if we could do away with the try-catch\n  	try {\n  		expression = converters_readExpressionOrReference(parser, [tag.close]);\n  	} catch (e) {\n  		err = e;\n  	}\n\n  	if (!expression) {\n  		if (parser.str.charAt(start) === "!") {\n  			// special case - comment\n  			parser.pos = start;\n  			return null;\n  		}\n\n  		if (err) {\n  			throw err;\n  		}\n  	}\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\' after reference");\n\n  		if (!expression) {\n  			// special case - comment\n  			if (parser.nextChar() === "!") {\n  				return null;\n  			}\n\n  			parser.error("Expected expression or legal reference");\n  		}\n  	}\n\n  	interpolator = { t: INTERPOLATOR };\n  	utils_refineExpression(expression, interpolator); // TODO handle this differently - it\'s mysterious\n\n  	return interpolator;\n  }\n\n  var mustache_readYielder = readYielder;\n  var yieldPattern = /^yield\\s*/;\n  function readYielder(parser, tag) {\n  	var start, name, yielder;\n\n  	if (!parser.matchPattern(yieldPattern)) {\n  		return null;\n  	}\n\n  	start = parser.pos;\n  	name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/);\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("expected legal partial name");\n  	}\n\n  	yielder = { t: YIELDER };\n\n  	if (name) {\n  		yielder.n = name;\n  	}\n\n  	return yielder;\n  }\n\n  var section_readClosing = readClosing;\n  function readClosing(parser, tag) {\n  	var start, remaining, index, closing;\n\n  	start = parser.pos;\n\n  	if (!parser.matchString(tag.open)) {\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("/")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	remaining = parser.remaining();\n  	index = remaining.indexOf(tag.close);\n\n  	if (index !== -1) {\n  		closing = {\n  			t: CLOSING,\n  			r: remaining.substr(0, index).split(" ")[0]\n  		};\n\n  		parser.pos += index;\n\n  		if (!parser.matchString(tag.close)) {\n  			parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  		}\n\n  		return closing;\n  	}\n\n  	parser.pos = start;\n  	return null;\n  }\n\n  var section_readElse = section_readElse__readElse;\n  var section_readElse__elsePattern = /^\\s*else\\s*/;\n  function section_readElse__readElse(parser, tag) {\n  	var start = parser.pos;\n\n  	if (!parser.matchString(tag.open)) {\n  		return null;\n  	}\n\n  	if (!parser.matchPattern(section_readElse__elsePattern)) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	return {\n  		t: ELSE\n  	};\n  }\n\n  var readElseIf = readElseIf__readElse;\n  var readElseIf__elsePattern = /^\\s*elseif\\s+/;\n  function readElseIf__readElse(parser, tag) {\n  	var start = parser.pos,\n  	    expression;\n\n  	if (!parser.matchString(tag.open)) {\n  		return null;\n  	}\n\n  	if (!parser.matchPattern(readElseIf__elsePattern)) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	expression = converters_readExpression(parser);\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	return {\n  		t: ELSEIF,\n  		x: expression\n  	};\n  }\n\n  var handlebarsBlockCodes = {\n  	each: SECTION_EACH,\n  	"if": SECTION_IF,\n  	"if-with": SECTION_IF_WITH,\n  	"with": SECTION_WITH,\n  	unless: SECTION_UNLESS\n  };\n\n  var mustache_readSection = readSection;\n\n  var indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n      keyIndexRefPattern = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n      handlebarsBlockPattern = new RegExp("^(" + Object.keys(handlebarsBlockCodes).join("|") + ")\\\\b");\n  function readSection(parser, tag) {\n  	var start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose;\n\n  	start = parser.pos;\n\n  	if (parser.matchString("^")) {\n  		section = { t: SECTION, f: [], n: SECTION_UNLESS };\n  	} else if (parser.matchString("#")) {\n  		section = { t: SECTION, f: [] };\n\n  		if (parser.matchString("partial")) {\n  			parser.pos = start - parser.standardDelimiters[0].length;\n  			parser.error("Partial definitions can only be at the top level of the template, or immediately inside components");\n  		}\n\n  		if (block = parser.matchPattern(handlebarsBlockPattern)) {\n  			expectedClose = block;\n  			section.n = handlebarsBlockCodes[block];\n  		}\n  	} else {\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	expression = converters_readExpression(parser);\n\n  	if (!expression) {\n  		parser.error("Expected expression");\n  	}\n\n  	// optional index and key references\n  	if (i = parser.matchPattern(indexRefPattern)) {\n  		var extra = undefined;\n\n  		if (extra = parser.matchPattern(keyIndexRefPattern)) {\n  			section.i = i + "," + extra;\n  		} else {\n  			section.i = i;\n  		}\n  	}\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	parser.sectionDepth += 1;\n  	children = section.f;\n\n  	conditions = [];\n\n  	do {\n  		if (child = section_readClosing(parser, tag)) {\n  			if (expectedClose && child.r !== expectedClose) {\n  				parser.error("Expected " + tag.open + "/" + expectedClose + "" + tag.close);\n  			}\n\n  			parser.sectionDepth -= 1;\n  			closed = true;\n  		} else if (child = readElseIf(parser, tag)) {\n  			if (section.n === SECTION_UNLESS) {\n  				parser.error("{{else}} not allowed in {{#unless}}");\n  			}\n\n  			if (hasElse) {\n  				parser.error("illegal {{elseif...}} after {{else}}");\n  			}\n\n  			if (!unlessBlock) {\n  				unlessBlock = createUnlessBlock(expression, section.n);\n  			}\n\n  			unlessBlock.f.push({\n  				t: SECTION,\n  				n: SECTION_IF,\n  				x: utils_flattenExpression(mustache_readSection__combine(conditions.concat(child.x))),\n  				f: children = []\n  			});\n\n  			conditions.push(invert(child.x));\n  		} else if (child = section_readElse(parser, tag)) {\n  			if (section.n === SECTION_UNLESS) {\n  				parser.error("{{else}} not allowed in {{#unless}}");\n  			}\n\n  			if (hasElse) {\n  				parser.error("there can only be one {{else}} block, at the end of a section");\n  			}\n\n  			hasElse = true;\n\n  			// use an unless block if there\'s no elseif\n  			if (!unlessBlock) {\n  				unlessBlock = createUnlessBlock(expression, section.n);\n  				children = unlessBlock.f;\n  			} else {\n  				unlessBlock.f.push({\n  					t: SECTION,\n  					n: SECTION_IF,\n  					x: utils_flattenExpression(mustache_readSection__combine(conditions)),\n  					f: children = []\n  				});\n  			}\n  		} else {\n  			child = parser.read(READERS);\n\n  			if (!child) {\n  				break;\n  			}\n\n  			children.push(child);\n  		}\n  	} while (!closed);\n\n  	if (unlessBlock) {\n  		// special case - `with` should become `if-with` (TODO is this right?\n  		// seems to me that `with` ought to behave consistently, regardless\n  		// of the presence/absence of `else`. In other words should always\n  		// be `if-with`\n  		if (section.n === SECTION_WITH) {\n  			section.n = SECTION_IF_WITH;\n  		}\n\n  		section.l = unlessBlock;\n  	}\n\n  	utils_refineExpression(expression, section);\n\n  	// TODO if a section is empty it should be discarded. Don\'t do\n  	// that here though - we need to clean everything up first, as\n  	// it may contain removeable whitespace. As a temporary measure,\n  	// to pass the existing tests, remove empty `f` arrays\n  	if (!section.f.length) {\n  		delete section.f;\n  	}\n\n  	return section;\n  }\n\n  function createUnlessBlock(expression, sectionType) {\n  	var unlessBlock;\n\n  	if (sectionType === SECTION_WITH) {\n  		// special case - a `{{#with foo}}` section will render if `foo` is\n  		// truthy, so the `{{else}}` section needs to render if `foo` is falsy,\n  		// rather than adhering to the normal `{{#unless foo}}` logic (which\n  		// treats empty arrays/objects as falsy)\n  		unlessBlock = {\n  			t: SECTION,\n  			n: SECTION_IF,\n  			f: []\n  		};\n\n  		utils_refineExpression(invert(expression), unlessBlock);\n  	} else {\n  		unlessBlock = {\n  			t: SECTION,\n  			n: SECTION_UNLESS,\n  			f: []\n  		};\n\n  		utils_refineExpression(expression, unlessBlock);\n  	}\n\n  	return unlessBlock;\n  }\n\n  function invert(expression) {\n  	if (expression.t === PREFIX_OPERATOR && expression.s === "!") {\n  		return expression.o;\n  	}\n\n  	return {\n  		t: PREFIX_OPERATOR,\n  		s: "!",\n  		o: parensIfNecessary(expression)\n  	};\n  }\n\n  function mustache_readSection__combine(expressions) {\n  	if (expressions.length === 1) {\n  		return expressions[0];\n  	}\n\n  	return {\n  		t: INFIX_OPERATOR,\n  		s: "&&",\n  		o: [parensIfNecessary(expressions[0]), parensIfNecessary(mustache_readSection__combine(expressions.slice(1)))]\n  	};\n  }\n\n  function parensIfNecessary(expression) {\n  	// TODO only wrap if necessary\n  	return {\n  		t: BRACKETED,\n  		x: expression\n  	};\n  }\n\n  var converters_readHtmlComment = readHtmlComment;\n  var OPEN_COMMENT = "<!--",\n      CLOSE_COMMENT = "-->";\n  function readHtmlComment(parser) {\n  	var start, content, remaining, endIndex, comment;\n\n  	start = parser.pos;\n\n  	if (!parser.matchString(OPEN_COMMENT)) {\n  		return null;\n  	}\n\n  	remaining = parser.remaining();\n  	endIndex = remaining.indexOf(CLOSE_COMMENT);\n\n  	if (endIndex === -1) {\n  		parser.error("Illegal HTML - expected closing comment sequence (\'-->\')");\n  	}\n\n  	content = remaining.substr(0, endIndex);\n  	parser.pos += endIndex + 3;\n\n  	comment = {\n  		t: COMMENT,\n  		c: content\n  	};\n\n  	if (parser.includeLinePositions) {\n  		comment.p = parser.getLinePos(start);\n  	}\n\n  	return comment;\n  }\n\n  var booleanAttributes, voidElementNames, htmlEntities, controlCharacters, entityPattern, lessThan, greaterThan, amp;\n\n  // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n  booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\n  voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\n\n  htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 };\n  controlCharacters = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376];\n  entityPattern = new RegExp("&(#?(?:x[\\\\w\\\\d]+|\\\\d+|" + Object.keys(htmlEntities).join("|") + "));?", "g");\n\n  function decodeCharacterReferences(html) {\n  	return html.replace(entityPattern, function (match, entity) {\n  		var code;\n\n  		// Handle named entities\n  		if (entity[0] !== "#") {\n  			code = htmlEntities[entity];\n  		} else if (entity[1] === "x") {\n  			code = parseInt(entity.substring(2), 16);\n  		} else {\n  			code = parseInt(entity.substring(1), 10);\n  		}\n\n  		if (!code) {\n  			return match;\n  		}\n\n  		return String.fromCharCode(validateCode(code));\n  	});\n  }\n\n  // some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n  // code points with alternatives in some cases - since we\'re bypassing that mechanism, we need\n  // to replace them ourselves\n  //\n  // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n  function validateCode(code) {\n  	if (!code) {\n  		return 65533;\n  	}\n\n  	// line feed becomes generic whitespace\n  	if (code === 10) {\n  		return 32;\n  	}\n\n  	// ASCII range. (Why someone would use HTML entities for ASCII characters I don\'t know, but...)\n  	if (code < 128) {\n  		return code;\n  	}\n\n  	// code points 128-159 are dealt with leniently by browsers, but they\'re incorrect. We need\n  	// to correct the mistake or we\'ll end up with missing  signs and so on\n  	if (code <= 159) {\n  		return controlCharacters[code - 128];\n  	}\n\n  	// basic multilingual plane\n  	if (code < 55296) {\n  		return code;\n  	}\n\n  	// UTF-16 surrogate halves\n  	if (code <= 57343) {\n  		return 65533;\n  	}\n\n  	// rest of the basic multilingual plane\n  	if (code <= 65535) {\n  		return code;\n  	}\n\n  	return 65533;\n  }\n\n  lessThan = /</g;\n  greaterThan = />/g;\n  amp = /&/g;\n\n  function escapeHtml(str) {\n  	return str.replace(amp, "&amp;").replace(lessThan, "&lt;").replace(greaterThan, "&gt;");\n  }\n\n  var leadingLinebreak = /^\\s*\\r?\\n/,\n      trailingLinebreak = /\\r?\\n\\s*$/;\n\n  var stripStandalones = function (items) {\n  	var i, current, backOne, backTwo, lastSectionItem;\n\n  	for (i = 1; i < items.length; i += 1) {\n  		current = items[i];\n  		backOne = items[i - 1];\n  		backTwo = items[i - 2];\n\n  		// if we\'re at the end of a [text][comment][text] sequence...\n  		if (isString(current) && isComment(backOne) && isString(backTwo)) {\n\n  			// ... and the comment is a standalone (i.e. line breaks either side)...\n  			if (trailingLinebreak.test(backTwo) && leadingLinebreak.test(current)) {\n\n  				// ... then we want to remove the whitespace after the first line break\n  				items[i - 2] = backTwo.replace(trailingLinebreak, "\\n");\n\n  				// and the leading line break of the second text token\n  				items[i] = current.replace(leadingLinebreak, "");\n  			}\n  		}\n\n  		// if the current item is a section, and it is preceded by a linebreak, and\n  		// its first item is a linebreak...\n  		if (isSection(current) && isString(backOne)) {\n  			if (trailingLinebreak.test(backOne) && isString(current.f[0]) && leadingLinebreak.test(current.f[0])) {\n  				items[i - 1] = backOne.replace(trailingLinebreak, "\\n");\n  				current.f[0] = current.f[0].replace(leadingLinebreak, "");\n  			}\n  		}\n\n  		// if the last item was a section, and it is followed by a linebreak, and\n  		// its last item is a linebreak...\n  		if (isString(current) && isSection(backOne)) {\n  			lastSectionItem = lastItem(backOne.f);\n\n  			if (isString(lastSectionItem) && trailingLinebreak.test(lastSectionItem) && leadingLinebreak.test(current)) {\n  				backOne.f[backOne.f.length - 1] = lastSectionItem.replace(trailingLinebreak, "\\n");\n  				items[i] = current.replace(leadingLinebreak, "");\n  			}\n  		}\n  	}\n\n  	return items;\n  };\n\n  function isString(item) {\n  	return typeof item === "string";\n  }\n\n  function isComment(item) {\n  	return item.t === COMMENT || item.t === DELIMCHANGE;\n  }\n\n  function isSection(item) {\n  	return (item.t === SECTION || item.t === INVERTED) && item.f;\n  }\n\n  var trimWhitespace__leadingWhitespace = /^[ \\t\\f\\r\\n]+/,\n      trimWhitespace__trailingWhitespace = /[ \\t\\f\\r\\n]+$/;\n\n  var trimWhitespace = function (items, leading, trailing) {\n  	var item;\n\n  	if (leading) {\n  		item = items[0];\n  		if (typeof item === "string") {\n  			item = item.replace(trimWhitespace__leadingWhitespace, "");\n\n  			if (!item) {\n  				items.shift();\n  			} else {\n  				items[0] = item;\n  			}\n  		}\n  	}\n\n  	if (trailing) {\n  		item = lastItem(items);\n  		if (typeof item === "string") {\n  			item = item.replace(trimWhitespace__trailingWhitespace, "");\n\n  			if (!item) {\n  				items.pop();\n  			} else {\n  				items[items.length - 1] = item;\n  			}\n  		}\n  	}\n  };\n\n  var utils_cleanup = cleanup;\n  var contiguousWhitespace = /[ \\t\\f\\r\\n]+/g;\n  var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;\n  var utils_cleanup__leadingWhitespace = /^\\s+/;\n  var utils_cleanup__trailingWhitespace = /\\s+$/;\n  function cleanup(items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace) {\n  	var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, key;\n\n  	// First pass - remove standalones and comments etc\n  	stripStandalones(items);\n\n  	i = items.length;\n  	while (i--) {\n  		item = items[i];\n\n  		// Remove delimiter changes, unsafe elements etc\n  		if (item.exclude) {\n  			items.splice(i, 1);\n  		}\n\n  		// Remove comments, unless we want to keep them\n  		else if (stripComments && item.t === COMMENT) {\n  			items.splice(i, 1);\n  		}\n  	}\n\n  	// If necessary, remove leading and trailing whitespace\n  	trimWhitespace(items, removeLeadingWhitespace, removeTrailingWhitespace);\n\n  	i = items.length;\n  	while (i--) {\n  		item = items[i];\n\n  		// Recurse\n  		if (item.f) {\n  			preserveWhitespaceInsideFragment = preserveWhitespace || item.t === ELEMENT && preserveWhitespaceElements.test(item.e);\n\n  			if (!preserveWhitespaceInsideFragment) {\n  				previousItem = items[i - 1];\n  				nextItem = items[i + 1];\n\n  				// if the previous item was a text item with trailing whitespace,\n  				// remove leading whitespace inside the fragment\n  				if (!previousItem || typeof previousItem === "string" && utils_cleanup__trailingWhitespace.test(previousItem)) {\n  					removeLeadingWhitespaceInsideFragment = true;\n  				}\n\n  				// and vice versa\n  				if (!nextItem || typeof nextItem === "string" && utils_cleanup__leadingWhitespace.test(nextItem)) {\n  					removeTrailingWhitespaceInsideFragment = true;\n  				}\n  			}\n\n  			cleanup(item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  		}\n\n  		// Split if-else blocks into two (an if, and an unless)\n  		if (item.l) {\n  			cleanup(item.l.f, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n\n  			items.splice(i + 1, 0, item.l);\n  			delete item.l; // TODO would be nice if there was a way around this\n  		}\n\n  		// Clean up element attributes\n  		if (item.a) {\n  			for (key in item.a) {\n  				if (item.a.hasOwnProperty(key) && typeof item.a[key] !== "string") {\n  					cleanup(item.a[key], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  				}\n  			}\n  		}\n\n  		// Clean up conditional attributes\n  		if (item.m) {\n  			cleanup(item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  		}\n\n  		// Clean up event handlers\n  		if (item.v) {\n  			for (key in item.v) {\n  				if (item.v.hasOwnProperty(key)) {\n  					// clean up names\n  					if (isArray(item.v[key].n)) {\n  						cleanup(item.v[key].n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  					}\n\n  					// clean up params\n  					if (isArray(item.v[key].d)) {\n  						cleanup(item.v[key].d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  					}\n  				}\n  			}\n  		}\n  	}\n\n  	// final pass - fuse text nodes together\n  	i = items.length;\n  	while (i--) {\n  		if (typeof items[i] === "string") {\n  			if (typeof items[i + 1] === "string") {\n  				items[i] = items[i] + items[i + 1];\n  				items.splice(i + 1, 1);\n  			}\n\n  			if (!preserveWhitespace) {\n  				items[i] = items[i].replace(contiguousWhitespace, " ");\n  			}\n\n  			if (items[i] === "") {\n  				items.splice(i, 1);\n  			}\n  		}\n  	}\n  }\n\n  var element_readClosingTag = readClosingTag;\n  var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n  function readClosingTag(parser) {\n  	var start, tag;\n\n  	start = parser.pos;\n\n  	// are we looking at a closing tag?\n  	if (!parser.matchString("</")) {\n  		return null;\n  	}\n\n  	if (tag = parser.matchPattern(closingTagPattern)) {\n  		if (parser.inside && tag !== parser.inside) {\n  			parser.pos = start;\n  			return null;\n  		}\n\n  		return {\n  			t: CLOSING_TAG,\n  			e: tag\n  		};\n  	}\n\n  	// We have an illegal closing tag, report it\n  	parser.pos -= 2;\n  	parser.error("Illegal closing tag");\n  }\n\n  var getLowestIndex = function (haystack, needles) {\n  	var i, index, lowest;\n\n  	i = needles.length;\n  	while (i--) {\n  		index = haystack.indexOf(needles[i]);\n\n  		// short circuit\n  		if (!index) {\n  			return 0;\n  		}\n\n  		if (index === -1) {\n  			continue;\n  		}\n\n  		if (!lowest || index < lowest) {\n  			lowest = index;\n  		}\n  	}\n\n  	return lowest || -1;\n  };\n\n  var element_readAttribute = readAttribute;\n\n  var attributeNamePattern = /^[^\\s"\'>\\/=]+/,\n      unquotedAttributeValueTextPattern = /^[^\\s"\'=<>`]+/;\n  function readAttribute(parser) {\n  	var attr, name, value;\n\n  	parser.allowWhitespace();\n\n  	name = parser.matchPattern(attributeNamePattern);\n  	if (!name) {\n  		return null;\n  	}\n\n  	attr = { name: name };\n\n  	value = readAttributeValue(parser);\n  	if (value != null) {\n  		// not null/undefined\n  		attr.value = value;\n  	}\n\n  	return attr;\n  }\n\n  function readAttributeValue(parser) {\n  	var start, valueStart, startDepth, value;\n\n  	start = parser.pos;\n\n  	// next character must be `=`, `/`, `>` or whitespace\n  	if (!/[=\\/>\\s]/.test(parser.nextChar())) {\n  		parser.error("Expected `=`, `/`, `>` or whitespace");\n  	}\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("=")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	valueStart = parser.pos;\n  	startDepth = parser.sectionDepth;\n\n  	value = readQuotedAttributeValue(parser, "\'") || readQuotedAttributeValue(parser, "\\"") || readUnquotedAttributeValue(parser);\n\n  	if (value === null) {\n  		parser.error("Expected valid attribute value");\n  	}\n\n  	if (parser.sectionDepth !== startDepth) {\n  		parser.pos = valueStart;\n  		parser.error("An attribute value must contain as many opening section tags as closing section tags");\n  	}\n\n  	if (!value.length) {\n  		return "";\n  	}\n\n  	if (value.length === 1 && typeof value[0] === "string") {\n  		return decodeCharacterReferences(value[0]);\n  	}\n\n  	return value;\n  }\n\n  function readUnquotedAttributeValueToken(parser) {\n  	var start, text, haystack, needles, index;\n\n  	start = parser.pos;\n\n  	text = parser.matchPattern(unquotedAttributeValueTextPattern);\n\n  	if (!text) {\n  		return null;\n  	}\n\n  	haystack = text;\n  	needles = parser.tags.map(function (t) {\n  		return t.open;\n  	}); // TODO refactor... we do this in readText.js as well\n\n  	if ((index = getLowestIndex(haystack, needles)) !== -1) {\n  		text = text.substr(0, index);\n  		parser.pos = start + text.length;\n  	}\n\n  	return text;\n  }\n\n  function readUnquotedAttributeValue(parser) {\n  	var tokens, token;\n\n  	parser.inAttribute = true;\n\n  	tokens = [];\n\n  	token = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  	while (token !== null) {\n  		tokens.push(token);\n  		token = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  	}\n\n  	if (!tokens.length) {\n  		return null;\n  	}\n\n  	parser.inAttribute = false;\n  	return tokens;\n  }\n\n  function readQuotedAttributeValue(parser, quoteMark) {\n  	var start, tokens, token;\n\n  	start = parser.pos;\n\n  	if (!parser.matchString(quoteMark)) {\n  		return null;\n  	}\n\n  	parser.inAttribute = quoteMark;\n\n  	tokens = [];\n\n  	token = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  	while (token !== null) {\n  		tokens.push(token);\n  		token = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  	}\n\n  	if (!parser.matchString(quoteMark)) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	parser.inAttribute = false;\n\n  	return tokens;\n  }\n\n  function readQuotedStringToken(parser, quoteMark) {\n  	var start, index, haystack, needles;\n\n  	start = parser.pos;\n  	haystack = parser.remaining();\n\n  	needles = parser.tags.map(function (t) {\n  		return t.open;\n  	}); // TODO refactor... we do this in readText.js as well\n  	needles.push(quoteMark);\n\n  	index = getLowestIndex(haystack, needles);\n\n  	if (index === -1) {\n  		parser.error("Quoted attribute value must have a closing quote");\n  	}\n\n  	if (!index) {\n  		return null;\n  	}\n\n  	parser.pos += index;\n  	return haystack.substr(0, index);\n  }\n\n  var JsonParser, specials, specialsPattern, parseJSON__numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;\n\n  specials = {\n  	"true": true,\n  	"false": false,\n  	undefined: undefined,\n  	"null": null\n  };\n\n  specialsPattern = new RegExp("^(?:" + Object.keys(specials).join("|") + ")");\n  parseJSON__numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n  placeholderPattern = /\\$\\{([^\\}]+)\\}/g;\n  placeholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\n  onlyWhitespace = /^\\s*$/;\n\n  JsonParser = parse_Parser.extend({\n  	init: function (str, options) {\n  		this.values = options.values;\n  		this.allowWhitespace();\n  	},\n\n  	postProcess: function (result) {\n  		if (result.length !== 1 || !onlyWhitespace.test(this.leftover)) {\n  			return null;\n  		}\n\n  		return { value: result[0].v };\n  	},\n\n  	converters: [function getPlaceholder(parser) {\n  		var placeholder;\n\n  		if (!parser.values) {\n  			return null;\n  		}\n\n  		placeholder = parser.matchPattern(placeholderAtStartPattern);\n\n  		if (placeholder && parser.values.hasOwnProperty(placeholder)) {\n  			return { v: parser.values[placeholder] };\n  		}\n  	}, function getSpecial(parser) {\n  		var special;\n\n  		if (special = parser.matchPattern(specialsPattern)) {\n  			return { v: specials[special] };\n  		}\n  	}, function getNumber(parser) {\n  		var number;\n\n  		if (number = parser.matchPattern(parseJSON__numberPattern)) {\n  			return { v: +number };\n  		}\n  	}, function getString(parser) {\n  		var stringLiteral = readStringLiteral(parser),\n  		    values;\n\n  		if (stringLiteral && (values = parser.values)) {\n  			return {\n  				v: stringLiteral.v.replace(placeholderPattern, function (match, $1) {\n  					return $1 in values ? values[$1] : $1;\n  				})\n  			};\n  		}\n\n  		return stringLiteral;\n  	}, function getObject(parser) {\n  		var result, pair;\n\n  		if (!parser.matchString("{")) {\n  			return null;\n  		}\n\n  		result = {};\n\n  		parser.allowWhitespace();\n\n  		if (parser.matchString("}")) {\n  			return { v: result };\n  		}\n\n  		while (pair = getKeyValuePair(parser)) {\n  			result[pair.key] = pair.value;\n\n  			parser.allowWhitespace();\n\n  			if (parser.matchString("}")) {\n  				return { v: result };\n  			}\n\n  			if (!parser.matchString(",")) {\n  				return null;\n  			}\n  		}\n\n  		return null;\n  	}, function getArray(parser) {\n  		var result, valueToken;\n\n  		if (!parser.matchString("[")) {\n  			return null;\n  		}\n\n  		result = [];\n\n  		parser.allowWhitespace();\n\n  		if (parser.matchString("]")) {\n  			return { v: result };\n  		}\n\n  		while (valueToken = parser.read()) {\n  			result.push(valueToken.v);\n\n  			parser.allowWhitespace();\n\n  			if (parser.matchString("]")) {\n  				return { v: result };\n  			}\n\n  			if (!parser.matchString(",")) {\n  				return null;\n  			}\n\n  			parser.allowWhitespace();\n  		}\n\n  		return null;\n  	}]\n  });\n\n  function getKeyValuePair(parser) {\n  	var key, valueToken, pair;\n\n  	parser.allowWhitespace();\n\n  	key = shared_readKey(parser);\n\n  	if (!key) {\n  		return null;\n  	}\n\n  	pair = { key: key };\n\n  	parser.allowWhitespace();\n  	if (!parser.matchString(":")) {\n  		return null;\n  	}\n  	parser.allowWhitespace();\n\n  	valueToken = parser.read();\n  	if (!valueToken) {\n  		return null;\n  	}\n\n  	pair.value = valueToken.v;\n\n  	return pair;\n  }\n\n  var parseJSON = function (str, values) {\n  	var parser = new JsonParser(str, {\n  		values: values\n  	});\n\n  	return parser.result;\n  };\n\n  // TODO clean this up, it\'s shocking\n  var element_processDirective = processDirective;\n  var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\\(/,\n      methodCallExcessPattern = /\\)\\s*$/,\n      ExpressionParser;\n\n  ExpressionParser = parse_Parser.extend({\n  	converters: [converters_readExpression]\n  });\n  function processDirective(tokens, parentParser) {\n  	var result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;\n\n  	if (typeof tokens === "string") {\n  		if (match = methodCallPattern.exec(tokens)) {\n  			var end = tokens.lastIndexOf(")");\n\n  			// check for invalid method calls\n  			if (!methodCallExcessPattern.test(tokens)) {\n  				parentParser.error("Invalid input after method call expression \'" + tokens.slice(end + 1) + "\'");\n  			}\n\n  			result = { m: match[1] };\n  			args = "[" + tokens.slice(result.m.length + 1, end) + "]";\n\n  			parser = new ExpressionParser(args);\n  			result.a = utils_flattenExpression(parser.result[0]);\n\n  			return result;\n  		}\n\n  		if (tokens.indexOf(":") === -1) {\n  			return tokens.trim();\n  		}\n\n  		tokens = [tokens];\n  	}\n\n  	result = {};\n\n  	directiveName = [];\n  	directiveArgs = [];\n\n  	if (tokens) {\n  		while (tokens.length) {\n  			token = tokens.shift();\n\n  			if (typeof token === "string") {\n  				colonIndex = token.indexOf(":");\n\n  				if (colonIndex === -1) {\n  					directiveName.push(token);\n  				} else {\n\n  					// is the colon the first character?\n  					if (colonIndex) {\n  						// no\n  						directiveName.push(token.substr(0, colonIndex));\n  					}\n\n  					// if there is anything after the colon in this token, treat\n  					// it as the first token of the directiveArgs fragment\n  					if (token.length > colonIndex + 1) {\n  						directiveArgs[0] = token.substring(colonIndex + 1);\n  					}\n\n  					break;\n  				}\n  			} else {\n  				directiveName.push(token);\n  			}\n  		}\n\n  		directiveArgs = directiveArgs.concat(tokens);\n  	}\n\n  	if (!directiveName.length) {\n  		result = "";\n  	} else if (directiveArgs.length || typeof directiveName !== "string") {\n  		result = {\n  			// TODO is this really necessary? just use the array\n  			n: directiveName.length === 1 && typeof directiveName[0] === "string" ? directiveName[0] : directiveName\n  		};\n\n  		if (directiveArgs.length === 1 && typeof directiveArgs[0] === "string") {\n  			parsed = parseJSON("[" + directiveArgs[0] + "]");\n  			result.a = parsed ? parsed.value : directiveArgs[0].trim();\n  		} else {\n  			result.d = directiveArgs;\n  		}\n  	} else {\n  		result = directiveName;\n  	}\n\n  	return result;\n  }\n\n  var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/,\n      validTagNameFollower = /^[\\s\\n\\/>]/,\n      onPattern = /^on/,\n      proxyEventPattern = /^on-([a-zA-Z\\\\*\\\\.$_][a-zA-Z\\\\*\\\\.$_0-9\\-]+)$/,\n      reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,\n      directives = { "intro-outro": "t0", intro: "t1", outro: "t2", decorator: "o" },\n      exclude = { exclude: true },\n      disallowedContents;\n\n  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\n  disallowedContents = {\n  	li: ["li"],\n  	dt: ["dt", "dd"],\n  	dd: ["dt", "dd"],\n  	p: "address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(" "),\n  	rt: ["rt", "rp"],\n  	rp: ["rt", "rp"],\n  	optgroup: ["optgroup"],\n  	option: ["option", "optgroup"],\n  	thead: ["tbody", "tfoot"],\n  	tbody: ["tbody", "tfoot"],\n  	tfoot: ["tbody"],\n  	tr: ["tr", "tbody"],\n  	td: ["td", "th", "tr"],\n  	th: ["td", "th", "tr"]\n  };\n\n  var converters_readElement = readElement;\n\n  function readElement(parser) {\n  	var start, element, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, partials, hasPartials, child, closed, pos, remaining, closingTag;\n\n  	start = parser.pos;\n\n  	if (parser.inside || parser.inAttribute) {\n  		return null;\n  	}\n\n  	if (!parser.matchString("<")) {\n  		return null;\n  	}\n\n  	// if this is a closing tag, abort straight away\n  	if (parser.nextChar() === "/") {\n  		return null;\n  	}\n\n  	element = {};\n  	if (parser.includeLinePositions) {\n  		element.p = parser.getLinePos(start);\n  	}\n\n  	if (parser.matchString("!")) {\n  		element.t = DOCTYPE;\n  		if (!parser.matchPattern(/^doctype/i)) {\n  			parser.error("Expected DOCTYPE declaration");\n  		}\n\n  		element.a = parser.matchPattern(/^(.+?)>/);\n  		return element;\n  	}\n\n  	element.t = ELEMENT;\n\n  	// element name\n  	element.e = parser.matchPattern(tagNamePattern);\n  	if (!element.e) {\n  		return null;\n  	}\n\n  	// next character must be whitespace, closing solidus or \'>\'\n  	if (!validTagNameFollower.test(parser.nextChar())) {\n  		parser.error("Illegal tag name");\n  	}\n\n  	addProxyEvent = function (name, directive) {\n  		var directiveName = directive.n || directive;\n\n  		if (reservedEventNames.test(directiveName)) {\n  			parser.pos -= directiveName.length;\n  			parser.error("Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)");\n  		}\n\n  		element.v[name] = directive;\n  	};\n\n  	parser.allowWhitespace();\n\n  	// directives and attributes\n  	while (attribute = converters_readMustache(parser) || element_readAttribute(parser)) {\n  		// regular attributes\n  		if (attribute.name) {\n  			// intro, outro, decorator\n  			if (directiveName = directives[attribute.name]) {\n  				element[directiveName] = element_processDirective(attribute.value, parser);\n  			}\n\n  			// on-click etc\n  			else if (match = proxyEventPattern.exec(attribute.name)) {\n  				if (!element.v) element.v = {};\n  				directive = element_processDirective(attribute.value, parser);\n  				addProxyEvent(match[1], directive);\n  			} else {\n  				if (!parser.sanitizeEventAttributes || !onPattern.test(attribute.name)) {\n  					if (!element.a) element.a = {};\n  					element.a[attribute.name] = attribute.value || (attribute.value === "" ? "" : 0);\n  				}\n  			}\n  		}\n\n  		// {{#if foo}}class=\'foo\'{{/if}}\n  		else {\n  			if (!element.m) element.m = [];\n  			element.m.push(attribute);\n  		}\n\n  		parser.allowWhitespace();\n  	}\n\n  	// allow whitespace before closing solidus\n  	parser.allowWhitespace();\n\n  	// self-closing solidus?\n  	if (parser.matchString("/")) {\n  		selfClosing = true;\n  	}\n\n  	// closing angle bracket\n  	if (!parser.matchString(">")) {\n  		return null;\n  	}\n\n  	var lowerCaseName = element.e.toLowerCase();\n  	var preserveWhitespace = parser.preserveWhitespace;\n\n  	if (!selfClosing && !voidElementNames.test(element.e)) {\n  		parser.elementStack.push(lowerCaseName);\n\n  		// Special case - if we open a script element, further tags should\n  		// be ignored unless they\'re a closing script element\n  		if (lowerCaseName === "script" || lowerCaseName === "style") {\n  			parser.inside = lowerCaseName;\n  		}\n\n  		children = [];\n  		partials = create(null);\n\n  		do {\n  			pos = parser.pos;\n  			remaining = parser.remaining();\n\n  			// if for example we\'re in an <li> element, and we see another\n  			// <li> tag, close the first so they become siblings\n  			if (!canContain(lowerCaseName, remaining)) {\n  				closed = true;\n  			}\n\n  			// closing tag\n  			else if (closingTag = element_readClosingTag(parser)) {\n  				closed = true;\n\n  				var closingTagName = closingTag.e.toLowerCase();\n\n  				// if this *isn\'t* the closing tag for the current element...\n  				if (closingTagName !== lowerCaseName) {\n  					// rewind parser\n  					parser.pos = pos;\n\n  					// if it doesn\'t close a parent tag, error\n  					if (! ~parser.elementStack.indexOf(closingTagName)) {\n  						var errorMessage = "Unexpected closing tag";\n\n  						// add additional help for void elements, since component names\n  						// might clash with them\n  						if (voidElementNames.test(closingTagName)) {\n  							errorMessage += " (<" + closingTagName + "> is a void element - it cannot contain children)";\n  						}\n\n  						parser.error(errorMessage);\n  					}\n  				}\n  			}\n\n  			// implicit close by closing section tag. TODO clean this up\n  			else if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {\n  				closed = true;\n  				parser.pos = pos;\n  			} else {\n  				if (child = parser.read(PARTIAL_READERS)) {\n  					if (partials[child.n]) {\n  						parser.pos = pos;\n  						parser.error("Duplicate partial definition");\n  					}\n\n  					utils_cleanup(child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);\n\n  					partials[child.n] = child.f;\n  					hasPartials = true;\n  				} else {\n  					if (child = parser.read(READERS)) {\n  						children.push(child);\n  					} else {\n  						closed = true;\n  					}\n  				}\n  			}\n  		} while (!closed);\n\n  		if (children.length) {\n  			element.f = children;\n  		}\n\n  		if (hasPartials) {\n  			element.p = partials;\n  		}\n\n  		parser.elementStack.pop();\n  	}\n\n  	parser.inside = null;\n\n  	if (parser.sanitizeElements && parser.sanitizeElements.indexOf(lowerCaseName) !== -1) {\n  		return exclude;\n  	}\n\n  	return element;\n  }\n\n  function canContain(name, remaining) {\n  	var match, disallowed;\n\n  	match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(remaining);\n  	disallowed = disallowedContents[name];\n\n  	if (!match || !disallowed) {\n  		return true;\n  	}\n\n  	return ! ~disallowed.indexOf(match[1].toLowerCase());\n  }\n\n  var converters_readText = readText;\n  function readText(parser) {\n  	var index, remaining, disallowed, barrier;\n\n  	remaining = parser.remaining();\n\n  	barrier = parser.inside ? "</" + parser.inside : "<";\n\n  	if (parser.inside && !parser.interpolate[parser.inside]) {\n  		index = remaining.indexOf(barrier);\n  	} else {\n  		disallowed = parser.tags.map(function (t) {\n  			return t.open;\n  		});\n  		disallowed = disallowed.concat(parser.tags.map(function (t) {\n  			return "\\\\" + t.open;\n  		}));\n\n  		// http://developers.whatwg.org/syntax.html#syntax-attributes\n  		if (parser.inAttribute === true) {\n  			// we\'re inside an unquoted attribute value\n  			disallowed.push("\\"", "\'", "=", "<", ">", "`");\n  		} else if (parser.inAttribute) {\n  			// quoted attribute value\n  			disallowed.push(parser.inAttribute);\n  		} else {\n  			disallowed.push(barrier);\n  		}\n\n  		index = getLowestIndex(remaining, disallowed);\n  	}\n\n  	if (!index) {\n  		return null;\n  	}\n\n  	if (index === -1) {\n  		index = remaining.length;\n  	}\n\n  	parser.pos += index;\n\n  	return parser.inside ? remaining.substr(0, index) : decodeCharacterReferences(remaining.substr(0, index));\n  }\n\n  var utils_escapeRegExp = escapeRegExp;\n  var utils_escapeRegExp__pattern = /[-/\\\\^$*+?.()|[\\]{}]/g;\n  function escapeRegExp(str) {\n  	return str.replace(utils_escapeRegExp__pattern, "\\\\$&");\n  }\n\n  var converters_readPartialDefinitionComment = readPartialDefinitionComment;\n\n  var startPattern = /^<!--\\s*/,\n      namePattern = /s*>\\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\\s*/,\n      finishPattern = /\\s*-->/,\n      child;\n\n  function readPartialDefinitionComment(parser) {\n  	var firstPos = parser.pos,\n  	    open = parser.standardDelimiters[0],\n  	    close = parser.standardDelimiters[1],\n  	    content = undefined,\n  	    closed = undefined;\n\n  	if (!parser.matchPattern(startPattern) || !parser.matchString(open)) {\n  		parser.pos = firstPos;\n  		return null;\n  	}\n\n  	var name = parser.matchPattern(namePattern);\n\n  	warnOnceIfDebug("Inline partial comments are deprecated.\\nUse this...\\n  {{#partial " + name + "}} ... {{/partial}}\\n\\n...instead of this:\\n  <!-- {{>" + name + "}} --> ... <!-- {{/" + name + "}} -->\'");\n\n  	// make sure the rest of the comment is in the correct place\n  	if (!parser.matchString(close) || !parser.matchPattern(finishPattern)) {\n  		parser.pos = firstPos;\n  		return null;\n  	}\n\n  	content = [];\n\n  	var endPattern = new RegExp("^<!--\\\\s*" + utils_escapeRegExp(open) + "\\\\s*\\\\/\\\\s*" + name + "\\\\s*" + utils_escapeRegExp(close) + "\\\\s*-->");\n\n  	do {\n  		if (parser.matchPattern(endPattern)) {\n  			closed = true;\n  		} else {\n  			child = parser.read(READERS);\n  			if (!child) {\n  				parser.error("expected closing comment (\'<!-- " + open + "/" + name + "" + close + " -->\')");\n  			}\n\n  			content.push(child);\n  		}\n  	} while (!closed);\n\n  	return {\n  		t: INLINE_PARTIAL,\n  		f: content,\n  		n: name\n  	};\n  }\n\n  var converters_readPartialDefinitionSection = readPartialDefinitionSection;\n  var partialDefinitionSectionPattern = /^#\\s*partial\\s+/;\n  function readPartialDefinitionSection(parser) {\n  	var start, name, content, child, closed;\n\n  	start = parser.pos;\n\n  	var delimiters = parser.standardDelimiters;\n\n  	if (!parser.matchString(delimiters[0])) {\n  		return null;\n  	}\n\n  	if (!parser.matchPattern(partialDefinitionSectionPattern)) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/);\n\n  	if (!name) {\n  		parser.error("expected legal partial name");\n  	}\n\n  	if (!parser.matchString(delimiters[1])) {\n  		parser.error("Expected closing delimiter \'" + delimiters[1] + "\'");\n  	}\n\n  	content = [];\n\n  	do {\n  		// TODO clean this up\n  		if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {\n  			if (!child.r === "partial") {\n  				parser.error("Expected " + delimiters[0] + "/partial" + delimiters[1]);\n  			}\n\n  			closed = true;\n  		} else {\n  			child = parser.read(READERS);\n\n  			if (!child) {\n  				parser.error("Expected " + delimiters[0] + "/partial" + delimiters[1]);\n  			}\n\n  			content.push(child);\n  		}\n  	} while (!closed);\n\n  	return {\n  		t: INLINE_PARTIAL,\n  		n: name,\n  		f: content\n  	};\n  }\n\n  var converters_readTemplate = readTemplate;\n  function readTemplate(parser) {\n  	var fragment = [];\n  	var partials = create(null);\n  	var hasPartials = false;\n\n  	var preserveWhitespace = parser.preserveWhitespace;\n\n  	while (parser.pos < parser.str.length) {\n  		var pos = parser.pos,\n  		    item = undefined,\n  		    partial = undefined;\n\n  		if (partial = parser.read(PARTIAL_READERS)) {\n  			if (partials[partial.n]) {\n  				parser.pos = pos;\n  				parser.error("Duplicated partial definition");\n  			}\n\n  			utils_cleanup(partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);\n\n  			partials[partial.n] = partial.f;\n  			hasPartials = true;\n  		} else if (item = parser.read(READERS)) {\n  			fragment.push(item);\n  		} else {\n  			parser.error("Unexpected template content");\n  		}\n  	}\n\n  	var result = {\n  		v: TEMPLATE_VERSION,\n  		t: fragment\n  	};\n\n  	if (hasPartials) {\n  		result.p = partials;\n  	}\n\n  	return result;\n  }\n\n  var _parse = parse;\n\n  var STANDARD_READERS = [mustache_readPartial, mustache_readUnescaped, mustache_readSection, mustache_readYielder, mustache_readInterpolator, readMustacheComment];\n  var TRIPLE_READERS = [mustache_readTriple];\n  var STATIC_READERS = [mustache_readUnescaped, mustache_readSection, mustache_readInterpolator]; // TODO does it make sense to have a static section?\n\n  var StandardParser = undefined;\n  function parse(template, options) {\n  	return new StandardParser(template, options || {}).result;\n  }\n\n  var READERS = [converters_readMustache, converters_readHtmlComment, converters_readElement, converters_readText];\n  var PARTIAL_READERS = [converters_readPartialDefinitionComment, converters_readPartialDefinitionSection];\n\n  StandardParser = parse_Parser.extend({\n  	init: function (str, options) {\n  		var tripleDelimiters = options.tripleDelimiters || ["{{{", "}}}"],\n  		    staticDelimiters = options.staticDelimiters || ["[[", "]]"],\n  		    staticTripleDelimiters = options.staticTripleDelimiters || ["[[[", "]]]"];\n\n  		this.standardDelimiters = options.delimiters || ["{{", "}}"];\n\n  		this.tags = [{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS }, { isStatic: false, isTriple: true, open: tripleDelimiters[0], close: tripleDelimiters[1], readers: TRIPLE_READERS }, { isStatic: true, isTriple: false, open: staticDelimiters[0], close: staticDelimiters[1], readers: STATIC_READERS }, { isStatic: true, isTriple: true, open: staticTripleDelimiters[0], close: staticTripleDelimiters[1], readers: TRIPLE_READERS }];\n\n  		this.sortMustacheTags();\n\n  		this.sectionDepth = 0;\n  		this.elementStack = [];\n\n  		this.interpolate = {\n  			script: !options.interpolate || options.interpolate.script !== false,\n  			style: !options.interpolate || options.interpolate.style !== false\n  		};\n\n  		if (options.sanitize === true) {\n  			options.sanitize = {\n  				// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n  				elements: "applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title".split(" "),\n  				eventAttributes: true\n  			};\n  		}\n\n  		this.stripComments = options.stripComments !== false;\n  		this.preserveWhitespace = options.preserveWhitespace;\n  		this.sanitizeElements = options.sanitize && options.sanitize.elements;\n  		this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n  		this.includeLinePositions = options.includeLinePositions;\n  	},\n\n  	postProcess: function (result) {\n  		// special case - empty string\n  		if (!result.length) {\n  			return { t: [], v: TEMPLATE_VERSION };\n  		}\n\n  		if (this.sectionDepth > 0) {\n  			this.error("A section was left open");\n  		}\n\n  		utils_cleanup(result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace);\n\n  		return result[0];\n  	},\n\n  	converters: [converters_readTemplate],\n\n  	sortMustacheTags: function () {\n  		// Sort in order of descending opening delimiter length (longer first),\n  		// to protect against opening delimiters being substrings of each other\n  		this.tags.sort(function (a, b) {\n  			return b.open.length - a.open.length;\n  		});\n  	}\n  });\n\n  var parseOptions = ["preserveWhitespace", "sanitize", "stripComments", "delimiters", "tripleDelimiters", "interpolate"];\n\n  var parser = {\n  	parse: doParse,\n  	fromId: fromId,\n  	isHashedId: isHashedId,\n  	isParsed: isParsed,\n  	getParseOptions: getParseOptions,\n  	createHelper: template_parser__createHelper\n  };\n\n  function template_parser__createHelper(parseOptions) {\n  	var helper = create(parser);\n  	helper.parse = function (template, options) {\n  		return doParse(template, options || parseOptions);\n  	};\n  	return helper;\n  }\n\n  function doParse(template, parseOptions) {\n  	if (!_parse) {\n  		throw new Error("Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser");\n  	}\n\n  	return _parse(template, parseOptions || this.options);\n  }\n\n  function fromId(id, options) {\n  	var template;\n\n  	if (!isClient) {\n  		if (options && options.noThrow) {\n  			return;\n  		}\n  		throw new Error("Cannot retrieve template #" + id + " as Ractive is not running in a browser.");\n  	}\n\n  	if (isHashedId(id)) {\n  		id = id.substring(1);\n  	}\n\n  	if (!(template = document.getElementById(id))) {\n  		if (options && options.noThrow) {\n  			return;\n  		}\n  		throw new Error("Could not find template element with id #" + id);\n  	}\n\n  	if (template.tagName.toUpperCase() !== "SCRIPT") {\n  		if (options && options.noThrow) {\n  			return;\n  		}\n  		throw new Error("Template element with id #" + id + ", must be a <script> element");\n  	}\n\n  	return template.textContent;\n  }\n\n  function isHashedId(id) {\n  	return id && id.charAt(0) === "#"; // TODO what about `id[0]`, does that work everywhere?\n  }\n\n  function isParsed(template) {\n  	return !(typeof template === "string");\n  }\n\n  function getParseOptions(ractive) {\n  	// Could be Ractive or a Component\n  	if (ractive.defaults) {\n  		ractive = ractive.defaults;\n  	}\n\n  	return parseOptions.reduce(function (val, key) {\n  		val[key] = ractive[key];\n  		return val;\n  	}, {});\n  }\n\n  var template_parser = parser;\n\n  var templateConfigurator = {\n  	name: "template",\n\n  	extend: function extend(Parent, proto, options) {\n  		var template;\n\n  		// only assign if exists\n  		if ("template" in options) {\n  			template = options.template;\n\n  			if (typeof template === "function") {\n  				proto.template = template;\n  			} else {\n  				proto.template = parseIfString(template, proto);\n  			}\n  		}\n  	},\n\n  	init: function init(Parent, ractive, options) {\n  		var template, fn;\n\n  		// TODO because of prototypal inheritance, we might just be able to use\n  		// ractive.template, and not bother passing through the Parent object.\n  		// At present that breaks the test mocks\' expectations\n  		template = "template" in options ? options.template : Parent.prototype.template;\n\n  		if (typeof template === "function") {\n  			fn = template;\n  			template = getDynamicTemplate(ractive, fn);\n\n  			ractive._config.template = {\n  				fn: fn,\n  				result: template\n  			};\n  		}\n\n  		template = parseIfString(template, ractive);\n\n  		// TODO the naming of this is confusing - ractive.template refers to [...],\n  		// but Component.prototype.template refers to {v:1,t:[],p:[]}...\n  		// it\'s unnecessary, because the developer never needs to access\n  		// ractive.template\n  		ractive.template = template.t;\n\n  		if (template.p) {\n  			extendPartials(ractive.partials, template.p);\n  		}\n  	},\n\n  	reset: function (ractive) {\n  		var result = resetValue(ractive),\n  		    parsed;\n\n  		if (result) {\n  			parsed = parseIfString(result, ractive);\n\n  			ractive.template = parsed.t;\n  			extendPartials(ractive.partials, parsed.p, true);\n\n  			return true;\n  		}\n  	}\n  };\n\n  function resetValue(ractive) {\n  	var initial = ractive._config.template,\n  	    result;\n\n  	// If this isn\'t a dynamic template, there\'s nothing to do\n  	if (!initial || !initial.fn) {\n  		return;\n  	}\n\n  	result = getDynamicTemplate(ractive, initial.fn);\n\n  	// TODO deep equality check to prevent unnecessary re-rendering\n  	// in the case of already-parsed templates\n  	if (result !== initial.result) {\n  		initial.result = result;\n  		result = parseIfString(result, ractive);\n  		return result;\n  	}\n  }\n\n  function getDynamicTemplate(ractive, fn) {\n  	var helper = template_template__createHelper(template_parser.getParseOptions(ractive));\n  	return fn.call(ractive, helper);\n  }\n\n  function template_template__createHelper(parseOptions) {\n  	var helper = create(template_parser);\n  	helper.parse = function (template, options) {\n  		return template_parser.parse(template, options || parseOptions);\n  	};\n  	return helper;\n  }\n\n  function parseIfString(template, ractive) {\n  	if (typeof template === "string") {\n  		// ID of an element containing the template?\n  		if (template[0] === "#") {\n  			template = template_parser.fromId(template);\n  		}\n\n  		template = _parse(template, template_parser.getParseOptions(ractive));\n  	}\n\n  	// Check the parsed template has a version at all\n  	else if (typeof template.v !== "number") {\n  		throw new Error("The template parser was passed a non-string template, but the template doesn\'t have a version.  Make sure you\'re passing in the template you think you are.");\n  	}\n\n  	// Check we\'re using the correct version\n  	else if (template.v !== TEMPLATE_VERSION) {\n  		throw new Error("Mismatched template version (expected " + TEMPLATE_VERSION + ", got " + template.v + ") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app");\n  	}\n\n  	return template;\n  }\n\n  function extendPartials(existingPartials, newPartials, overwrite) {\n  	if (!newPartials) return;\n\n  	// TODO there\'s an ambiguity here - we need to overwrite in the `reset()`\n  	// case, but not initially...\n\n  	for (var key in newPartials) {\n  		if (overwrite || !existingPartials.hasOwnProperty(key)) {\n  			existingPartials[key] = newPartials[key];\n  		}\n  	}\n  }\n\n  var template_template = templateConfigurator;\n\n  var config_registries__registryNames, Registry, registries;\n\n  config_registries__registryNames = ["adaptors", "components", "computed", "decorators", "easing", "events", "interpolators", "partials", "transitions"];\n\n  Registry = function (name, useDefaults) {\n  	this.name = name;\n  	this.useDefaults = useDefaults;\n  };\n\n  Registry.prototype = {\n  	constructor: Registry,\n\n  	extend: function (Parent, proto, options) {\n  		this.configure(this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options);\n  	},\n\n  	init: function () {},\n\n  	configure: function (Parent, target, options) {\n  		var name = this.name,\n  		    option = options[name],\n  		    registry;\n\n  		registry = create(Parent[name]);\n\n  		for (var key in option) {\n  			registry[key] = option[key];\n  		}\n\n  		target[name] = registry;\n  	},\n\n  	reset: function (ractive) {\n  		var registry = ractive[this.name];\n  		var changed = false;\n  		Object.keys(registry).forEach(function (key) {\n  			var item = registry[key];\n  			if (item._fn) {\n  				if (item._fn.isOwner) {\n  					registry[key] = item._fn;\n  				} else {\n  					delete registry[key];\n  				}\n  				changed = true;\n  			}\n  		});\n  		return changed;\n  	}\n  };\n\n  registries = config_registries__registryNames.map(function (name) {\n  	return new Registry(name, name === "computed");\n  });\n\n  var config_registries = registries;\n\n  /*this.configure(\n  	this.useDefaults ? Parent.defaults : Parent,\n  	ractive,\n  	options );*/\n\n  var wrapPrototype = wrap;\n\n  function wrap(parent, name, method) {\n  	if (!/_super/.test(method)) {\n  		return method;\n  	}\n\n  	var wrapper = function wrapSuper() {\n  		var superMethod = getSuperMethod(wrapper._parent, name),\n  		    hasSuper = ("_super" in this),\n  		    oldSuper = this._super,\n  		    result;\n\n  		this._super = superMethod;\n\n  		result = method.apply(this, arguments);\n\n  		if (hasSuper) {\n  			this._super = oldSuper;\n  		} else {\n  			delete this._super;\n  		}\n\n  		return result;\n  	};\n\n  	wrapper._parent = parent;\n  	wrapper._method = method;\n\n  	return wrapper;\n  }\n\n  function getSuperMethod(parent, name) {\n  	var value, method;\n\n  	if (name in parent) {\n  		value = parent[name];\n\n  		if (typeof value === "function") {\n  			method = value;\n  		} else {\n  			method = function returnValue() {\n  				return value;\n  			};\n  		}\n  	} else {\n  		method = noop;\n  	}\n\n  	return method;\n  }\n\n  var config_deprecate = deprecate;\n  function getMessage(deprecated, correct, isError) {\n  	return "options." + deprecated + " has been deprecated in favour of options." + correct + "." + (isError ? " You cannot specify both options, please use options." + correct + "." : "");\n  }\n\n  function deprecateOption(options, deprecatedOption, correct) {\n  	if (deprecatedOption in options) {\n  		if (!(correct in options)) {\n  			warnIfDebug(getMessage(deprecatedOption, correct));\n  			options[correct] = options[deprecatedOption];\n  		} else {\n  			throw new Error(getMessage(deprecatedOption, correct, true));\n  		}\n  	}\n  }\n  function deprecate(options) {\n  	deprecateOption(options, "beforeInit", "onconstruct");\n  	deprecateOption(options, "init", "onrender");\n  	deprecateOption(options, "complete", "oncomplete");\n  	deprecateOption(options, "eventDefinitions", "events");\n\n  	// Using extend with Component instead of options,\n  	// like Human.extend( Spider ) means adaptors as a registry\n  	// gets copied to options. So we have to check if actually an array\n  	if (isArray(options.adaptors)) {\n  		deprecateOption(options, "adaptors", "adapt");\n  	}\n  }\n\n  var config, order, defaultKeys, custom, isBlacklisted, isStandardKey;\n\n  custom = {\n  	adapt: custom_adapt,\n  	css: css_css,\n  	data: custom_data,\n  	template: template_template\n  };\n\n  defaultKeys = Object.keys(config_defaults);\n\n  isStandardKey = makeObj(defaultKeys.filter(function (key) {\n  	return !custom[key];\n  }));\n\n  // blacklisted keys that we don\'t double extend\n  isBlacklisted = makeObj(defaultKeys.concat(config_registries.map(function (r) {\n  	return r.name;\n  })));\n\n  order = [].concat(defaultKeys.filter(function (key) {\n  	return !config_registries[key] && !custom[key];\n  }), config_registries, custom.data, custom.template, custom.css);\n\n  config = {\n  	extend: function (Parent, proto, options) {\n  		return configure("extend", Parent, proto, options);\n  	},\n\n  	init: function (Parent, ractive, options) {\n  		return configure("init", Parent, ractive, options);\n  	},\n\n  	reset: function (ractive) {\n  		return order.filter(function (c) {\n  			return c.reset && c.reset(ractive);\n  		}).map(function (c) {\n  			return c.name;\n  		});\n  	},\n\n  	// this defines the order. TODO this isn\'t used anywhere in the codebase,\n  	// only in the test suite - should get rid of it\n  	order: order };\n\n  function configure(method, Parent, target, options) {\n  	config_deprecate(options);\n\n  	for (var key in options) {\n  		if (isStandardKey.hasOwnProperty(key)) {\n  			var value = options[key];\n\n  			// warn the developer if they passed a function and ignore its value\n\n  			// NOTE: we allow some functions on "el" because we duck type element lists\n  			// and some libraries or ef\'ed-up virtual browsers (phantomJS) return a\n  			// function object as the result of querySelector methods\n  			if (key !== "el" && typeof value === "function") {\n  				warnIfDebug("" + key + " is a Ractive option that does not expect a function and will be ignored", method === "init" ? target : null);\n  			} else {\n  				target[key] = value;\n  			}\n  		}\n  	}\n\n  	config_registries.forEach(function (registry) {\n  		registry[method](Parent, target, options);\n  	});\n\n  	custom_adapt[method](Parent, target, options);\n  	template_template[method](Parent, target, options);\n  	css_css[method](Parent, target, options);\n\n  	extendOtherMethods(Parent.prototype, target, options);\n  }\n\n  function extendOtherMethods(parent, target, options) {\n  	for (var key in options) {\n  		if (!isBlacklisted[key] && options.hasOwnProperty(key)) {\n  			var member = options[key];\n\n  			// if this is a method that overwrites a method, wrap it:\n  			if (typeof member === "function") {\n  				member = wrapPrototype(parent, key, member);\n  			}\n\n  			target[key] = member;\n  		}\n  	}\n  }\n\n  function makeObj(array) {\n  	var obj = {};\n  	array.forEach(function (x) {\n  		return obj[x] = true;\n  	});\n  	return obj;\n  }\n\n  var config_config = config;\n\n  var prototype_bubble = Fragment$bubble;\n\n  function Fragment$bubble() {\n  	this.dirtyValue = this.dirtyArgs = true;\n\n  	if (this.bound && typeof this.owner.bubble === "function") {\n  		this.owner.bubble();\n  	}\n  }\n\n  var Fragment_prototype_detach = Fragment$detach;\n\n  function Fragment$detach() {\n  	var docFrag;\n\n  	if (this.items.length === 1) {\n  		return this.items[0].detach();\n  	}\n\n  	docFrag = document.createDocumentFragment();\n\n  	this.items.forEach(function (item) {\n  		var node = item.detach();\n\n  		// TODO The if {...} wasn\'t previously required - it is now, because we\'re\n  		// forcibly detaching everything to reorder sections after an update. That\'s\n  		// a non-ideal brute force approach, implemented to get all the tests to pass\n  		// - as soon as it\'s replaced with something more elegant, this should\n  		// revert to `docFrag.appendChild( item.detach() )`\n  		if (node) {\n  			docFrag.appendChild(node);\n  		}\n  	});\n\n  	return docFrag;\n  }\n\n  var Fragment_prototype_find = Fragment$find;\n\n  function Fragment$find(selector) {\n  	var i, len, item, queryResult;\n\n  	if (this.items) {\n  		len = this.items.length;\n  		for (i = 0; i < len; i += 1) {\n  			item = this.items[i];\n\n  			if (item.find && (queryResult = item.find(selector))) {\n  				return queryResult;\n  			}\n  		}\n\n  		return null;\n  	}\n  }\n\n  var Fragment_prototype_findAll = Fragment$findAll;\n\n  function Fragment$findAll(selector, query) {\n  	var i, len, item;\n\n  	if (this.items) {\n  		len = this.items.length;\n  		for (i = 0; i < len; i += 1) {\n  			item = this.items[i];\n\n  			if (item.findAll) {\n  				item.findAll(selector, query);\n  			}\n  		}\n  	}\n\n  	return query;\n  }\n\n  var Fragment_prototype_findAllComponents = Fragment$findAllComponents;\n\n  function Fragment$findAllComponents(selector, query) {\n  	var i, len, item;\n\n  	if (this.items) {\n  		len = this.items.length;\n  		for (i = 0; i < len; i += 1) {\n  			item = this.items[i];\n\n  			if (item.findAllComponents) {\n  				item.findAllComponents(selector, query);\n  			}\n  		}\n  	}\n\n  	return query;\n  }\n\n  var Fragment_prototype_findComponent = Fragment$findComponent;\n\n  function Fragment$findComponent(selector) {\n  	var len, i, item, queryResult;\n\n  	if (this.items) {\n  		len = this.items.length;\n  		for (i = 0; i < len; i += 1) {\n  			item = this.items[i];\n\n  			if (item.findComponent && (queryResult = item.findComponent(selector))) {\n  				return queryResult;\n  			}\n  		}\n\n  		return null;\n  	}\n  }\n\n  var prototype_findNextNode = Fragment$findNextNode;\n\n  function Fragment$findNextNode(item) {\n  	var index = item.index,\n  	    node;\n\n  	if (this.items[index + 1]) {\n  		node = this.items[index + 1].firstNode();\n  	}\n\n  	// if this is the root fragment, and there are no more items,\n  	// it means we\'re at the end...\n  	else if (this.owner === this.root) {\n  		if (!this.owner.component) {\n  			// TODO but something else could have been appended to\n  			// this.root.el, no?\n  			node = null;\n  		}\n\n  		// ...unless this is a component\n  		else {\n  			node = this.owner.component.findNextNode();\n  		}\n  	} else {\n  		node = this.owner.findNextNode(this);\n  	}\n\n  	return node;\n  }\n\n  var prototype_firstNode = Fragment$firstNode;\n\n  function Fragment$firstNode() {\n  	if (this.items && this.items[0]) {\n  		return this.items[0].firstNode();\n  	}\n\n  	return null;\n  }\n\n  var shared_processItems = processItems;\n\n  function processItems(items, values, guid, counter) {\n  	counter = counter || 0;\n\n  	return items.map(function (item) {\n  		var placeholderId, wrapped, value;\n\n  		if (item.text) {\n  			return item.text;\n  		}\n\n  		if (item.fragments) {\n  			return item.fragments.map(function (fragment) {\n  				return processItems(fragment.items, values, guid, counter);\n  			}).join("");\n  		}\n\n  		placeholderId = guid + "-" + counter++;\n\n  		if (item.keypath && (wrapped = item.root.viewmodel.wrapped[item.keypath.str])) {\n  			value = wrapped.value;\n  		} else {\n  			value = item.getValue();\n  		}\n\n  		values[placeholderId] = value;\n\n  		return "${" + placeholderId + "}";\n  	}).join("");\n  }\n\n  var getArgsList = Fragment$getArgsList;\n  function Fragment$getArgsList() {\n  	var values, source, parsed, result;\n\n  	if (this.dirtyArgs) {\n  		source = shared_processItems(this.items, values = {}, this.root._guid);\n  		parsed = parseJSON("[" + source + "]", values);\n\n  		if (!parsed) {\n  			result = [this.toString()];\n  		} else {\n  			result = parsed.value;\n  		}\n\n  		this.argsList = result;\n  		this.dirtyArgs = false;\n  	}\n\n  	return this.argsList;\n  }\n\n  var getNode = Fragment$getNode;\n\n  function Fragment$getNode() {\n  	var fragment = this;\n\n  	do {\n  		if (fragment.pElement) {\n  			return fragment.pElement.node;\n  		}\n  	} while (fragment = fragment.parent);\n\n  	return this.root.detached || this.root.el;\n  }\n\n  var prototype_getValue = Fragment$getValue;\n  function Fragment$getValue() {\n  	var values, source, parsed, result;\n\n  	if (this.dirtyValue) {\n  		source = shared_processItems(this.items, values = {}, this.root._guid);\n  		parsed = parseJSON(source, values);\n\n  		if (!parsed) {\n  			result = this.toString();\n  		} else {\n  			result = parsed.value;\n  		}\n\n  		this.value = result;\n  		this.dirtyValue = false;\n  	}\n\n  	return this.value;\n  }\n\n  var shared_detach = function () {\n  	return detachNode(this.node);\n  };\n\n  var Text = function (options) {\n  	this.type = TEXT;\n  	this.text = options.template;\n  };\n\n  Text.prototype = {\n  	detach: shared_detach,\n\n  	firstNode: function () {\n  		return this.node;\n  	},\n\n  	render: function () {\n  		if (!this.node) {\n  			this.node = document.createTextNode(this.text);\n  		}\n\n  		return this.node;\n  	},\n\n  	toString: function (escape) {\n  		return escape ? escapeHtml(this.text) : this.text;\n  	},\n\n  	unrender: function (shouldDestroy) {\n  		if (shouldDestroy) {\n  			return this.detach();\n  		}\n  	}\n  };\n\n  var items_Text = Text;\n\n  var shared_unbind = shared_unbind__unbind;\n\n  function shared_unbind__unbind() {\n  	if (this.registered) {\n  		// this was registered as a dependant\n  		this.root.viewmodel.unregister(this.keypath, this);\n  	}\n\n  	if (this.resolver) {\n  		this.resolver.unbind();\n  	}\n  }\n\n  var Mustache_getValue = Mustache$getValue;\n\n  function Mustache$getValue() {\n  	return this.value;\n  }\n\n  var ReferenceResolver = function (owner, ref, callback) {\n  	var keypath;\n\n  	this.ref = ref;\n  	this.resolved = false;\n\n  	this.root = owner.root;\n  	this.parentFragment = owner.parentFragment;\n  	this.callback = callback;\n\n  	keypath = shared_resolveRef(owner.root, ref, owner.parentFragment);\n  	if (keypath != undefined) {\n  		this.resolve(keypath);\n  	} else {\n  		global_runloop.addUnresolved(this);\n  	}\n  };\n\n  ReferenceResolver.prototype = {\n  	resolve: function (keypath) {\n  		if (this.keypath && !keypath) {\n  			// it was resolved, and now it\'s not. Can happen if e.g. `bar` in\n  			// `{{foo[bar]}}` becomes undefined\n  			global_runloop.addUnresolved(this);\n  		}\n\n  		this.resolved = true;\n\n  		this.keypath = keypath;\n  		this.callback(keypath);\n  	},\n\n  	forceResolution: function () {\n  		this.resolve(getKeypath(this.ref));\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		var keypath;\n\n  		if (this.keypath != undefined) {\n  			keypath = this.keypath.replace(oldKeypath, newKeypath);\n  			// was a new keypath created?\n  			if (keypath !== undefined) {\n  				// resolve it\n  				this.resolve(keypath);\n  			}\n  		}\n  	},\n\n  	unbind: function () {\n  		if (!this.resolved) {\n  			global_runloop.removeUnresolved(this);\n  		}\n  	}\n  };\n\n  var Resolvers_ReferenceResolver = ReferenceResolver;\n\n  var SpecialResolver = function (owner, ref, callback) {\n  	this.parentFragment = owner.parentFragment;\n  	this.ref = ref;\n  	this.callback = callback;\n\n  	this.rebind();\n  };\n\n  var props = {\n  	"@keypath": { prefix: "c", prop: ["context"] },\n  	"@index": { prefix: "i", prop: ["index"] },\n  	"@key": { prefix: "k", prop: ["key", "index"] }\n  };\n\n  function getProp(target, prop) {\n  	var value;\n  	for (var i = 0; i < prop.prop.length; i++) {\n  		if ((value = target[prop.prop[i]]) !== undefined) {\n  			return value;\n  		}\n  	}\n  }\n\n  SpecialResolver.prototype = {\n  	rebind: function () {\n  		var ref = this.ref,\n  		    fragment = this.parentFragment,\n  		    prop = props[ref],\n  		    value;\n\n  		if (!prop) {\n  			throw new Error("Unknown special reference \\"" + ref + "\\" - valid references are @index, @key and @keypath");\n  		}\n\n  		// have we already found the nearest parent?\n  		if (this.cached) {\n  			return this.callback(getKeypath("@" + prop.prefix + getProp(this.cached, prop)));\n  		}\n\n  		// special case for indices, which may cross component boundaries\n  		if (prop.prop.indexOf("index") !== -1 || prop.prop.indexOf("key") !== -1) {\n  			while (fragment) {\n  				if (fragment.owner.currentSubtype === SECTION_EACH && (value = getProp(fragment, prop)) !== undefined) {\n  					this.cached = fragment;\n\n  					fragment.registerIndexRef(this);\n\n  					return this.callback(getKeypath("@" + prop.prefix + value));\n  				}\n\n  				// watch for component boundaries\n  				if (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {\n  					fragment = fragment.owner.component.parentFragment;\n  				} else {\n  					fragment = fragment.parent;\n  				}\n  			}\n  		} else {\n  			while (fragment) {\n  				if ((value = getProp(fragment, prop)) !== undefined) {\n  					return this.callback(getKeypath("@" + prop.prefix + value.str));\n  				}\n\n  				fragment = fragment.parent;\n  			}\n  		}\n  	},\n\n  	unbind: function () {\n  		if (this.cached) {\n  			this.cached.unregisterIndexRef(this);\n  		}\n  	}\n  };\n\n  var Resolvers_SpecialResolver = SpecialResolver;\n\n  var IndexResolver = function (owner, ref, callback) {\n  	this.parentFragment = owner.parentFragment;\n  	this.ref = ref;\n  	this.callback = callback;\n\n  	ref.ref.fragment.registerIndexRef(this);\n\n  	this.rebind();\n  };\n\n  IndexResolver.prototype = {\n  	rebind: function () {\n  		var index,\n  		    ref = this.ref.ref;\n\n  		if (ref.ref.t === "k") {\n  			index = "k" + ref.fragment.key;\n  		} else {\n  			index = "i" + ref.fragment.index;\n  		}\n\n  		if (index !== undefined) {\n  			this.callback(getKeypath("@" + index));\n  		}\n  	},\n\n  	unbind: function () {\n  		this.ref.ref.fragment.unregisterIndexRef(this);\n  	}\n  };\n\n  var Resolvers_IndexResolver = IndexResolver;\n\n  var Resolvers_findIndexRefs = findIndexRefs;\n\n  function findIndexRefs(fragment, refName) {\n  	var result = {},\n  	    refs,\n  	    fragRefs,\n  	    ref,\n  	    i,\n  	    owner,\n  	    hit = false;\n\n  	if (!refName) {\n  		result.refs = refs = {};\n  	}\n\n  	while (fragment) {\n  		if ((owner = fragment.owner) && (fragRefs = owner.indexRefs)) {\n\n  			// we\'re looking for a particular ref, and it\'s here\n  			if (refName && (ref = owner.getIndexRef(refName))) {\n  				result.ref = {\n  					fragment: fragment,\n  					ref: ref\n  				};\n  				return result;\n  			}\n\n  			// we\'re collecting refs up-tree\n  			else if (!refName) {\n  				for (i in fragRefs) {\n  					ref = fragRefs[i];\n\n  					// don\'t overwrite existing refs - they should shadow parents\n  					if (!refs[ref.n]) {\n  						hit = true;\n  						refs[ref.n] = {\n  							fragment: fragment,\n  							ref: ref\n  						};\n  					}\n  				}\n  			}\n  		}\n\n  		// watch for component boundaries\n  		if (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {\n  			result.componentBoundary = true;\n  			fragment = fragment.owner.component.parentFragment;\n  		} else {\n  			fragment = fragment.parent;\n  		}\n  	}\n\n  	if (!hit) {\n  		return undefined;\n  	} else {\n  		return result;\n  	}\n  }\n\n  findIndexRefs.resolve = function resolve(indices) {\n  	var refs = {},\n  	    k,\n  	    ref;\n\n  	for (k in indices.refs) {\n  		ref = indices.refs[k];\n  		refs[ref.ref.n] = ref.ref.t === "k" ? ref.fragment.key : ref.fragment.index;\n  	}\n\n  	return refs;\n  };\n\n  var Resolvers_createReferenceResolver = createReferenceResolver;\n  function createReferenceResolver(owner, ref, callback) {\n  	var indexRef;\n\n  	if (ref.charAt(0) === "@") {\n  		return new Resolvers_SpecialResolver(owner, ref, callback);\n  	}\n\n  	if (indexRef = Resolvers_findIndexRefs(owner.parentFragment, ref)) {\n  		return new Resolvers_IndexResolver(owner, indexRef, callback);\n  	}\n\n  	return new Resolvers_ReferenceResolver(owner, ref, callback);\n  }\n\n  var shared_getFunctionFromString = getFunctionFromString;\n  var cache = {};\n  function getFunctionFromString(str, i) {\n  	var fn, args;\n\n  	if (cache[str]) {\n  		return cache[str];\n  	}\n\n  	args = [];\n  	while (i--) {\n  		args[i] = "_" + i;\n  	}\n\n  	fn = new Function(args.join(","), "return(" + str + ")");\n\n  	cache[str] = fn;\n  	return fn;\n  }\n\n  var ExpressionResolver,\n      Resolvers_ExpressionResolver__bind = Function.prototype.bind;\n\n  ExpressionResolver = function (owner, parentFragment, expression, callback) {\n  	var _this = this;\n\n  	var ractive;\n\n  	ractive = owner.root;\n\n  	this.root = ractive;\n  	this.parentFragment = parentFragment;\n  	this.callback = callback;\n  	this.owner = owner;\n  	this.str = expression.s;\n  	this.keypaths = [];\n\n  	// Create resolvers for each reference\n  	this.pending = expression.r.length;\n  	this.refResolvers = expression.r.map(function (ref, i) {\n  		return Resolvers_createReferenceResolver(_this, ref, function (keypath) {\n  			_this.resolve(i, keypath);\n  		});\n  	});\n\n  	this.ready = true;\n  	this.bubble();\n  };\n\n  ExpressionResolver.prototype = {\n  	bubble: function () {\n  		if (!this.ready) {\n  			return;\n  		}\n\n  		this.uniqueString = getUniqueString(this.str, this.keypaths);\n  		this.keypath = createExpressionKeypath(this.uniqueString);\n\n  		this.createEvaluator();\n  		this.callback(this.keypath);\n  	},\n\n  	unbind: function () {\n  		var resolver;\n\n  		while (resolver = this.refResolvers.pop()) {\n  			resolver.unbind();\n  		}\n  	},\n\n  	resolve: function (index, keypath) {\n  		this.keypaths[index] = keypath;\n  		this.bubble();\n  	},\n\n  	createEvaluator: function () {\n  		var _this = this;\n\n  		var computation, valueGetters, signature, keypath, fn;\n\n  		keypath = this.keypath;\n  		computation = this.root.viewmodel.computations[keypath.str];\n\n  		// only if it doesn\'t exist yet!\n  		if (!computation) {\n  			fn = shared_getFunctionFromString(this.str, this.refResolvers.length);\n\n  			valueGetters = this.keypaths.map(function (keypath) {\n  				var value;\n\n  				if (keypath === "undefined") {\n  					return function () {\n  						return undefined;\n  					};\n  				}\n\n  				// \'special\' keypaths encode a value\n  				if (keypath.isSpecial) {\n  					value = keypath.value;\n  					return function () {\n  						return value;\n  					};\n  				}\n\n  				return function () {\n  					var value = _this.root.viewmodel.get(keypath, { noUnwrap: true, fullRootGet: true });\n  					if (typeof value === "function") {\n  						value = wrapFunction(value, _this.root);\n  					}\n  					return value;\n  				};\n  			});\n\n  			signature = {\n  				deps: this.keypaths.filter(isValidDependency),\n  				getter: function () {\n  					var args = valueGetters.map(call);\n  					return fn.apply(null, args);\n  				}\n  			};\n\n  			computation = this.root.viewmodel.compute(keypath, signature);\n  		} else {\n  			this.root.viewmodel.mark(keypath);\n  		}\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		// TODO only bubble once, no matter how many references are affected by the rebind\n  		this.refResolvers.forEach(function (r) {\n  			return r.rebind(oldKeypath, newKeypath);\n  		});\n  	}\n  };\n\n  var Resolvers_ExpressionResolver = ExpressionResolver;\n\n  function call(value) {\n  	return value.call();\n  }\n\n  function getUniqueString(str, keypaths) {\n  	// get string that is unique to this expression\n  	return str.replace(/_([0-9]+)/g, function (match, $1) {\n  		var keypath, value;\n\n  		// make sure we\'re not replacing a non-keypath _[0-9]\n  		if (+$1 >= keypaths.length) {\n  			return "_" + $1;\n  		}\n\n  		keypath = keypaths[$1];\n\n  		if (keypath === undefined) {\n  			return "undefined";\n  		}\n\n  		if (keypath.isSpecial) {\n  			value = keypath.value;\n  			return typeof value === "number" ? value : "\\"" + value + "\\"";\n  		}\n\n  		return keypath.str;\n  	});\n  }\n\n  function createExpressionKeypath(uniqueString) {\n  	// Sanitize by removing any periods or square brackets. Otherwise\n  	// we can\'t split the keypath into keys!\n  	// Remove asterisks too, since they mess with pattern observers\n  	return getKeypath("${" + uniqueString.replace(/[\\.\\[\\]]/g, "-").replace(/\\*/, "#MUL#") + "}");\n  }\n\n  function isValidDependency(keypath) {\n  	return keypath !== undefined && keypath[0] !== "@";\n  }\n\n  function wrapFunction(fn, ractive) {\n  	var wrapped, prop, key;\n\n  	if (fn.__ractive_nowrap) {\n  		return fn;\n  	}\n\n  	prop = "__ractive_" + ractive._guid;\n  	wrapped = fn[prop];\n\n  	if (wrapped) {\n  		return wrapped;\n  	} else if (/this/.test(fn.toString())) {\n  		defineProperty(fn, prop, {\n  			value: Resolvers_ExpressionResolver__bind.call(fn, ractive),\n  			configurable: true\n  		});\n\n  		// Add properties/methods to wrapped function\n  		for (key in fn) {\n  			if (fn.hasOwnProperty(key)) {\n  				fn[prop][key] = fn[key];\n  			}\n  		}\n\n  		ractive._boundFunctions.push({\n  			fn: fn,\n  			prop: prop\n  		});\n\n  		return fn[prop];\n  	}\n\n  	defineProperty(fn, "__ractive_nowrap", {\n  		value: fn\n  	});\n\n  	return fn.__ractive_nowrap;\n  }\n\n  var MemberResolver = function (template, resolver, parentFragment) {\n  	var _this = this;\n\n  	this.resolver = resolver;\n  	this.root = resolver.root;\n  	this.parentFragment = parentFragment;\n  	this.viewmodel = resolver.root.viewmodel;\n\n  	if (typeof template === "string") {\n  		this.value = template;\n  	}\n\n  	// Simple reference?\n  	else if (template.t === REFERENCE) {\n  		this.refResolver = Resolvers_createReferenceResolver(this, template.n, function (keypath) {\n  			_this.resolve(keypath);\n  		});\n  	}\n\n  	// Otherwise we have an expression in its own right\n  	else {\n  		new Resolvers_ExpressionResolver(resolver, parentFragment, template, function (keypath) {\n  			_this.resolve(keypath);\n  		});\n  	}\n  };\n\n  MemberResolver.prototype = {\n  	resolve: function (keypath) {\n  		if (this.keypath) {\n  			this.viewmodel.unregister(this.keypath, this);\n  		}\n\n  		this.keypath = keypath;\n  		this.value = this.viewmodel.get(keypath);\n\n  		this.bind();\n\n  		this.resolver.bubble();\n  	},\n\n  	bind: function () {\n  		this.viewmodel.register(this.keypath, this);\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		if (this.refResolver) {\n  			this.refResolver.rebind(oldKeypath, newKeypath);\n  		}\n  	},\n\n  	setValue: function (value) {\n  		this.value = value;\n  		this.resolver.bubble();\n  	},\n\n  	unbind: function () {\n  		if (this.keypath) {\n  			this.viewmodel.unregister(this.keypath, this);\n  		}\n\n  		if (this.refResolver) {\n  			this.refResolver.unbind();\n  		}\n  	},\n\n  	forceResolution: function () {\n  		if (this.refResolver) {\n  			this.refResolver.forceResolution();\n  		}\n  	}\n  };\n\n  var ReferenceExpressionResolver_MemberResolver = MemberResolver;\n\n  var ReferenceExpressionResolver = function (mustache, template, callback) {\n  	var _this = this;\n\n  	var ractive, ref, keypath, parentFragment;\n\n  	this.parentFragment = parentFragment = mustache.parentFragment;\n  	this.root = ractive = mustache.root;\n  	this.mustache = mustache;\n\n  	this.ref = ref = template.r;\n  	this.callback = callback;\n\n  	this.unresolved = [];\n\n  	// Find base keypath\n  	if (keypath = shared_resolveRef(ractive, ref, parentFragment)) {\n  		this.base = keypath;\n  	} else {\n  		this.baseResolver = new Resolvers_ReferenceResolver(this, ref, function (keypath) {\n  			_this.base = keypath;\n  			_this.baseResolver = null;\n  			_this.bubble();\n  		});\n  	}\n\n  	// Find values for members, or mark them as unresolved\n  	this.members = template.m.map(function (template) {\n  		return new ReferenceExpressionResolver_MemberResolver(template, _this, parentFragment);\n  	});\n\n  	this.ready = true;\n  	this.bubble(); // trigger initial resolution if possible\n  };\n\n  ReferenceExpressionResolver.prototype = {\n  	getKeypath: function () {\n  		var values = this.members.map(ReferenceExpressionResolver_ReferenceExpressionResolver__getValue);\n\n  		if (!values.every(isDefined) || this.baseResolver) {\n  			return null;\n  		}\n\n  		return this.base.join(values.join("."));\n  	},\n\n  	bubble: function () {\n  		if (!this.ready || this.baseResolver) {\n  			return;\n  		}\n\n  		this.callback(this.getKeypath());\n  	},\n\n  	unbind: function () {\n  		this.members.forEach(methodCallers__unbind);\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		var changed;\n\n  		if (this.base) {\n  			var newBase = this.base.replace(oldKeypath, newKeypath);\n  			if (newBase && newBase !== this.base) {\n  				this.base = newBase;\n  				changed = true;\n  			}\n  		}\n\n  		this.members.forEach(function (members) {\n  			if (members.rebind(oldKeypath, newKeypath)) {\n  				changed = true;\n  			}\n  		});\n\n  		if (changed) {\n  			this.bubble();\n  		}\n  	},\n\n  	forceResolution: function () {\n  		if (this.baseResolver) {\n  			this.base = getKeypath(this.ref);\n\n  			this.baseResolver.unbind();\n  			this.baseResolver = null;\n  		}\n\n  		this.members.forEach(forceResolution);\n  		this.bubble();\n  	}\n  };\n\n  function ReferenceExpressionResolver_ReferenceExpressionResolver__getValue(member) {\n  	return member.value;\n  }\n\n  function isDefined(value) {\n  	return value != undefined;\n  }\n\n  function forceResolution(member) {\n  	member.forceResolution();\n  }\n\n  var ReferenceExpressionResolver_ReferenceExpressionResolver = ReferenceExpressionResolver;\n\n  var Mustache_initialise = Mustache$init;\n  function Mustache$init(mustache, options) {\n\n  	var ref, parentFragment, template;\n\n  	parentFragment = options.parentFragment;\n  	template = options.template;\n\n  	mustache.root = parentFragment.root;\n  	mustache.parentFragment = parentFragment;\n  	mustache.pElement = parentFragment.pElement;\n\n  	mustache.template = options.template;\n  	mustache.index = options.index || 0;\n  	mustache.isStatic = options.template.s;\n\n  	mustache.type = options.template.t;\n\n  	mustache.registered = false;\n\n  	// if this is a simple mustache, with a reference, we just need to resolve\n  	// the reference to a keypath\n  	if (ref = template.r) {\n  		mustache.resolver = Resolvers_createReferenceResolver(mustache, ref, resolve);\n  	}\n\n  	// if it\'s an expression, we have a bit more work to do\n  	if (options.template.x) {\n  		mustache.resolver = new Resolvers_ExpressionResolver(mustache, parentFragment, options.template.x, resolveAndRebindChildren);\n  	}\n\n  	if (options.template.rx) {\n  		mustache.resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(mustache, options.template.rx, resolveAndRebindChildren);\n  	}\n\n  	// Special case - inverted sections\n  	if (mustache.template.n === SECTION_UNLESS && !mustache.hasOwnProperty("value")) {\n  		mustache.setValue(undefined);\n  	}\n\n  	function resolve(keypath) {\n  		mustache.resolve(keypath);\n  	}\n\n  	function resolveAndRebindChildren(newKeypath) {\n  		var oldKeypath = mustache.keypath;\n\n  		if (newKeypath != oldKeypath) {\n  			mustache.resolve(newKeypath);\n\n  			if (oldKeypath !== undefined) {\n  				mustache.fragments && mustache.fragments.forEach(function (f) {\n  					f.rebind(oldKeypath, newKeypath);\n  				});\n  			}\n  		}\n  	}\n  }\n\n  var Mustache_resolve = Mustache$resolve;\n\n  function Mustache$resolve(keypath) {\n  	var wasResolved, value, twowayBinding;\n\n  	// \'Special\' keypaths, e.g. @foo or @7, encode a value\n  	if (keypath && keypath.isSpecial) {\n  		this.keypath = keypath;\n  		this.setValue(keypath.value);\n  		return;\n  	}\n\n  	// If we resolved previously, we need to unregister\n  	if (this.registered) {\n  		// undefined or null\n  		this.root.viewmodel.unregister(this.keypath, this);\n  		this.registered = false;\n\n  		wasResolved = true;\n  	}\n\n  	this.keypath = keypath;\n\n  	// If the new keypath exists, we need to register\n  	// with the viewmodel\n  	if (keypath != undefined) {\n  		// undefined or null\n  		value = this.root.viewmodel.get(keypath);\n  		this.root.viewmodel.register(keypath, this);\n\n  		this.registered = true;\n  	}\n\n  	// Either way we need to queue up a render (`value`\n  	// will be `undefined` if there\'s no keypath)\n  	this.setValue(value);\n\n  	// Two-way bindings need to point to their new target keypath\n  	if (wasResolved && (twowayBinding = this.twowayBinding)) {\n  		twowayBinding.rebound();\n  	}\n  }\n\n  var Mustache_rebind = Mustache$rebind;\n\n  function Mustache$rebind(oldKeypath, newKeypath) {\n  	// Children first\n  	if (this.fragments) {\n  		this.fragments.forEach(function (f) {\n  			return f.rebind(oldKeypath, newKeypath);\n  		});\n  	}\n\n  	// Expression mustache?\n  	if (this.resolver) {\n  		this.resolver.rebind(oldKeypath, newKeypath);\n  	}\n  }\n\n  var Mustache = {\n  	getValue: Mustache_getValue,\n  	init: Mustache_initialise,\n  	resolve: Mustache_resolve,\n  	rebind: Mustache_rebind\n  };\n\n  var Interpolator = function (options) {\n  	this.type = INTERPOLATOR;\n  	Mustache.init(this, options);\n  };\n\n  Interpolator.prototype = {\n  	update: function () {\n  		this.node.data = this.value == undefined ? "" : this.value;\n  	},\n  	resolve: Mustache.resolve,\n  	rebind: Mustache.rebind,\n  	detach: shared_detach,\n\n  	unbind: shared_unbind,\n\n  	render: function () {\n  		if (!this.node) {\n  			this.node = document.createTextNode(safeToStringValue(this.value));\n  		}\n\n  		return this.node;\n  	},\n\n  	unrender: function (shouldDestroy) {\n  		if (shouldDestroy) {\n  			detachNode(this.node);\n  		}\n  	},\n\n  	getValue: Mustache.getValue,\n\n  	// TEMP\n  	setValue: function (value) {\n  		var wrapper;\n\n  		// TODO is there a better way to approach this?\n  		if (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {\n  			value = wrapper.get();\n  		}\n\n  		if (!isEqual(value, this.value)) {\n  			this.value = value;\n  			this.parentFragment.bubble();\n\n  			if (this.node) {\n  				global_runloop.addView(this);\n  			}\n  		}\n  	},\n\n  	firstNode: function () {\n  		return this.node;\n  	},\n\n  	toString: function (escape) {\n  		var string = "" + safeToStringValue(this.value);\n  		return escape ? escapeHtml(string) : string;\n  	}\n  };\n\n  var items_Interpolator = Interpolator;\n\n  var Section_prototype_bubble = Section$bubble;\n\n  function Section$bubble() {\n  	this.parentFragment.bubble();\n  }\n\n  var Section_prototype_detach = Section$detach;\n\n  function Section$detach() {\n  	var docFrag;\n\n  	if (this.fragments.length === 1) {\n  		return this.fragments[0].detach();\n  	}\n\n  	docFrag = document.createDocumentFragment();\n\n  	this.fragments.forEach(function (item) {\n  		docFrag.appendChild(item.detach());\n  	});\n\n  	return docFrag;\n  }\n\n  var find = Section$find;\n\n  function Section$find(selector) {\n  	var i, len, queryResult;\n\n  	len = this.fragments.length;\n  	for (i = 0; i < len; i += 1) {\n  		if (queryResult = this.fragments[i].find(selector)) {\n  			return queryResult;\n  		}\n  	}\n\n  	return null;\n  }\n\n  var findAll = Section$findAll;\n\n  function Section$findAll(selector, query) {\n  	var i, len;\n\n  	len = this.fragments.length;\n  	for (i = 0; i < len; i += 1) {\n  		this.fragments[i].findAll(selector, query);\n  	}\n  }\n\n  var findAllComponents = Section$findAllComponents;\n\n  function Section$findAllComponents(selector, query) {\n  	var i, len;\n\n  	len = this.fragments.length;\n  	for (i = 0; i < len; i += 1) {\n  		this.fragments[i].findAllComponents(selector, query);\n  	}\n  }\n\n  var findComponent = Section$findComponent;\n\n  function Section$findComponent(selector) {\n  	var i, len, queryResult;\n\n  	len = this.fragments.length;\n  	for (i = 0; i < len; i += 1) {\n  		if (queryResult = this.fragments[i].findComponent(selector)) {\n  			return queryResult;\n  		}\n  	}\n\n  	return null;\n  }\n\n  var findNextNode = Section$findNextNode;\n\n  function Section$findNextNode(fragment) {\n  	if (this.fragments[fragment.index + 1]) {\n  		return this.fragments[fragment.index + 1].firstNode();\n  	}\n\n  	return this.parentFragment.findNextNode(this);\n  }\n\n  var firstNode = Section$firstNode;\n\n  function Section$firstNode() {\n  	var len, i, node;\n\n  	if (len = this.fragments.length) {\n  		for (i = 0; i < len; i += 1) {\n  			if (node = this.fragments[i].firstNode()) {\n  				return node;\n  			}\n  		}\n  	}\n\n  	return this.parentFragment.findNextNode(this);\n  }\n\n  var shuffle = Section$shuffle;\n\n  function Section$shuffle(newIndices) {\n  	var _this = this;\n\n  	var parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;\n\n  	// short circuit any double-updates, and ensure that this isn\'t applied to\n  	// non-list sections\n  	if (this.shuffling || this.unbound || this.currentSubtype !== SECTION_EACH) {\n  		return;\n  	}\n\n  	this.shuffling = true;\n  	global_runloop.scheduleTask(function () {\n  		return _this.shuffling = false;\n  	});\n\n  	parentFragment = this.parentFragment;\n\n  	reboundFragments = [];\n\n  	// TODO: need to update this\n  	// first, rebind existing fragments\n  	newIndices.forEach(function (newIndex, oldIndex) {\n  		var fragment, by, oldKeypath, newKeypath, deps;\n\n  		if (newIndex === oldIndex) {\n  			reboundFragments[newIndex] = _this.fragments[oldIndex];\n  			return;\n  		}\n\n  		fragment = _this.fragments[oldIndex];\n\n  		if (firstChange === undefined) {\n  			firstChange = oldIndex;\n  		}\n\n  		// does this fragment need to be torn down?\n  		if (newIndex === -1) {\n  			_this.fragmentsToUnrender.push(fragment);\n  			fragment.unbind();\n  			return;\n  		}\n\n  		// Otherwise, it needs to be rebound to a new index\n  		by = newIndex - oldIndex;\n  		oldKeypath = _this.keypath.join(oldIndex);\n  		newKeypath = _this.keypath.join(newIndex);\n\n  		fragment.index = newIndex;\n\n  		// notify any registered index refs directly\n  		if (deps = fragment.registeredIndexRefs) {\n  			deps.forEach(shuffle__blindRebind);\n  		}\n\n  		fragment.rebind(oldKeypath, newKeypath);\n  		reboundFragments[newIndex] = fragment;\n  	});\n\n  	newLength = this.root.viewmodel.get(this.keypath).length;\n\n  	// If nothing changed with the existing fragments, then we start adding\n  	// new fragments at the end...\n  	if (firstChange === undefined) {\n  		// ...unless there are no new fragments to add\n  		if (this.length === newLength) {\n  			return;\n  		}\n\n  		firstChange = this.length;\n  	}\n\n  	this.length = this.fragments.length = newLength;\n\n  	if (this.rendered) {\n  		global_runloop.addView(this);\n  	}\n\n  	// Prepare new fragment options\n  	fragmentOptions = {\n  		template: this.template.f,\n  		root: this.root,\n  		owner: this\n  	};\n\n  	// Add as many new fragments as we need to, or add back existing\n  	// (detached) fragments\n  	for (i = firstChange; i < newLength; i += 1) {\n  		fragment = reboundFragments[i];\n\n  		if (!fragment) {\n  			this.fragmentsToCreate.push(i);\n  		}\n\n  		this.fragments[i] = fragment;\n  	}\n  }\n\n  function shuffle__blindRebind(dep) {\n  	// the keypath doesn\'t actually matter here as it won\'t have changed\n  	dep.rebind("", "");\n  }\n\n  var prototype_rebind = function (oldKeypath, newKeypath) {\n  	Mustache.rebind.call(this, oldKeypath, newKeypath);\n  };\n\n  var Section_prototype_render = Section$render;\n\n  function Section$render() {\n  	var _this = this;\n\n  	this.docFrag = document.createDocumentFragment();\n\n  	this.fragments.forEach(function (f) {\n  		return _this.docFrag.appendChild(f.render());\n  	});\n\n  	this.renderedFragments = this.fragments.slice();\n  	this.fragmentsToRender = [];\n\n  	this.rendered = true;\n  	return this.docFrag;\n  }\n\n  var setValue = Section$setValue;\n\n  function Section$setValue(value) {\n  	var _this = this;\n\n  	var wrapper, fragmentOptions;\n\n  	if (this.updating) {\n  		// If a child of this section causes a re-evaluation - for example, an\n  		// expression refers to a function that mutates the array that this\n  		// section depends on - we\'ll end up with a double rendering bug (see\n  		// https://github.com/ractivejs/ractive/issues/748). This prevents it.\n  		return;\n  	}\n\n  	this.updating = true;\n\n  	// with sections, we need to get the fake value if we have a wrapped object\n  	if (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {\n  		value = wrapper.get();\n  	}\n\n  	// If any fragments are awaiting creation after a splice,\n  	// this is the place to do it\n  	if (this.fragmentsToCreate.length) {\n  		fragmentOptions = {\n  			template: this.template.f || [],\n  			root: this.root,\n  			pElement: this.pElement,\n  			owner: this\n  		};\n\n  		this.fragmentsToCreate.forEach(function (index) {\n  			var fragment;\n\n  			fragmentOptions.context = _this.keypath.join(index);\n  			fragmentOptions.index = index;\n\n  			fragment = new virtualdom_Fragment(fragmentOptions);\n  			_this.fragmentsToRender.push(_this.fragments[index] = fragment);\n  		});\n\n  		this.fragmentsToCreate.length = 0;\n  	} else if (reevaluateSection(this, value)) {\n  		this.bubble();\n\n  		if (this.rendered) {\n  			global_runloop.addView(this);\n  		}\n  	}\n\n  	this.value = value;\n  	this.updating = false;\n  }\n\n  function changeCurrentSubtype(section, value, obj) {\n  	if (value === SECTION_EACH) {\n  		// make sure ref type is up to date for key or value indices\n  		if (section.indexRefs && section.indexRefs[0]) {\n  			var ref = section.indexRefs[0];\n\n  			// when switching flavors, make sure the section gets updated\n  			if (obj && ref.t === "i" || !obj && ref.t === "k") {\n  				// if switching from object to list, unbind all of the old fragments\n  				if (!obj) {\n  					section.length = 0;\n  					section.fragmentsToUnrender = section.fragments.slice(0);\n  					section.fragmentsToUnrender.forEach(function (f) {\n  						return f.unbind();\n  					});\n  				}\n  			}\n\n  			ref.t = obj ? "k" : "i";\n  		}\n  	}\n\n  	section.currentSubtype = value;\n  }\n\n  function reevaluateSection(section, value) {\n  	var fragmentOptions = {\n  		template: section.template.f || [],\n  		root: section.root,\n  		pElement: section.parentFragment.pElement,\n  		owner: section\n  	};\n\n  	section.hasContext = true;\n\n  	// If we already know the section type, great\n  	// TODO can this be optimised? i.e. pick an reevaluateSection function during init\n  	// and avoid doing this each time?\n  	if (section.subtype) {\n  		switch (section.subtype) {\n  			case SECTION_IF:\n  				section.hasContext = false;\n  				return reevaluateConditionalSection(section, value, false, fragmentOptions);\n\n  			case SECTION_UNLESS:\n  				section.hasContext = false;\n  				return reevaluateConditionalSection(section, value, true, fragmentOptions);\n\n  			case SECTION_WITH:\n  				return reevaluateContextSection(section, fragmentOptions);\n\n  			case SECTION_IF_WITH:\n  				return reevaluateConditionalContextSection(section, value, fragmentOptions);\n\n  			case SECTION_EACH:\n  				if (isObject(value)) {\n  					changeCurrentSubtype(section, section.subtype, true);\n  					return reevaluateListObjectSection(section, value, fragmentOptions);\n  				}\n\n  				// Fallthrough - if it\'s a conditional or an array we need to continue\n  		}\n  	}\n\n  	// Otherwise we need to work out what sort of section we\'re dealing with\n  	section.ordered = !!isArrayLike(value);\n\n  	// Ordered list section\n  	if (section.ordered) {\n  		changeCurrentSubtype(section, SECTION_EACH, false);\n  		return reevaluateListSection(section, value, fragmentOptions);\n  	}\n\n  	// Unordered list, or context\n  	if (isObject(value) || typeof value === "function") {\n  		// Index reference indicates section should be treated as a list\n  		if (section.template.i) {\n  			changeCurrentSubtype(section, SECTION_EACH, true);\n  			return reevaluateListObjectSection(section, value, fragmentOptions);\n  		}\n\n  		// Otherwise, object provides context for contents\n  		changeCurrentSubtype(section, SECTION_WITH, false);\n  		return reevaluateContextSection(section, fragmentOptions);\n  	}\n\n  	// Conditional section\n  	changeCurrentSubtype(section, SECTION_IF, false);\n  	section.hasContext = false;\n  	return reevaluateConditionalSection(section, value, false, fragmentOptions);\n  }\n\n  function reevaluateListSection(section, value, fragmentOptions) {\n  	var i, length, fragment;\n\n  	length = value.length;\n\n  	if (length === section.length) {\n  		// Nothing to do\n  		return false;\n  	}\n\n  	// if the array is shorter than it was previously, remove items\n  	if (length < section.length) {\n  		section.fragmentsToUnrender = section.fragments.splice(length, section.length - length);\n  		section.fragmentsToUnrender.forEach(methodCallers__unbind);\n  	}\n\n  	// otherwise...\n  	else {\n  		if (length > section.length) {\n  			// add any new ones\n  			for (i = section.length; i < length; i += 1) {\n  				// append list item to context stack\n  				fragmentOptions.context = section.keypath.join(i);\n  				fragmentOptions.index = i;\n\n  				fragment = new virtualdom_Fragment(fragmentOptions);\n  				section.fragmentsToRender.push(section.fragments[i] = fragment);\n  			}\n  		}\n  	}\n\n  	section.length = length;\n  	return true;\n  }\n\n  function reevaluateListObjectSection(section, value, fragmentOptions) {\n  	var id, i, hasKey, fragment, changed, deps;\n\n  	hasKey = section.hasKey || (section.hasKey = {});\n\n  	// remove any fragments that should no longer exist\n  	i = section.fragments.length;\n  	while (i--) {\n  		fragment = section.fragments[i];\n\n  		if (!(fragment.key in value)) {\n  			changed = true;\n\n  			fragment.unbind();\n  			section.fragmentsToUnrender.push(fragment);\n  			section.fragments.splice(i, 1);\n\n  			hasKey[fragment.key] = false;\n  		}\n  	}\n\n  	// notify any dependents about changed indices\n  	i = section.fragments.length;\n  	while (i--) {\n  		fragment = section.fragments[i];\n\n  		if (fragment.index !== i) {\n  			fragment.index = i;\n  			if (deps = fragment.registeredIndexRefs) {\n  				deps.forEach(setValue__blindRebind);\n  			}\n  		}\n  	}\n\n  	// add any that haven\'t been created yet\n  	i = section.fragments.length;\n  	for (id in value) {\n  		if (!hasKey[id]) {\n  			changed = true;\n\n  			fragmentOptions.context = section.keypath.join(id);\n  			fragmentOptions.key = id;\n  			fragmentOptions.index = i++;\n\n  			fragment = new virtualdom_Fragment(fragmentOptions);\n\n  			section.fragmentsToRender.push(fragment);\n  			section.fragments.push(fragment);\n  			hasKey[id] = true;\n  		}\n  	}\n\n  	section.length = section.fragments.length;\n  	return changed;\n  }\n\n  function reevaluateConditionalContextSection(section, value, fragmentOptions) {\n  	if (value) {\n  		return reevaluateContextSection(section, fragmentOptions);\n  	} else {\n  		return removeSectionFragments(section);\n  	}\n  }\n\n  function reevaluateContextSection(section, fragmentOptions) {\n  	var fragment;\n\n  	// ...then if it isn\'t rendered, render it, adding section.keypath to the context stack\n  	// (if it is already rendered, then any children dependent on the context stack\n  	// will update themselves without any prompting)\n  	if (!section.length) {\n  		// append this section to the context stack\n  		fragmentOptions.context = section.keypath;\n  		fragmentOptions.index = 0;\n\n  		fragment = new virtualdom_Fragment(fragmentOptions);\n\n  		section.fragmentsToRender.push(section.fragments[0] = fragment);\n  		section.length = 1;\n\n  		return true;\n  	}\n  }\n\n  function reevaluateConditionalSection(section, value, inverted, fragmentOptions) {\n  	var doRender, emptyArray, emptyObject, fragment, name;\n\n  	emptyArray = isArrayLike(value) && value.length === 0;\n  	emptyObject = false;\n  	if (!isArrayLike(value) && isObject(value)) {\n  		emptyObject = true;\n  		for (name in value) {\n  			emptyObject = false;\n  			break;\n  		}\n  	}\n\n  	if (inverted) {\n  		doRender = emptyArray || emptyObject || !value;\n  	} else {\n  		doRender = value && !emptyArray && !emptyObject;\n  	}\n\n  	if (doRender) {\n  		if (!section.length) {\n  			// no change to context stack\n  			fragmentOptions.index = 0;\n\n  			fragment = new virtualdom_Fragment(fragmentOptions);\n  			section.fragmentsToRender.push(section.fragments[0] = fragment);\n  			section.length = 1;\n\n  			return true;\n  		}\n\n  		if (section.length > 1) {\n  			section.fragmentsToUnrender = section.fragments.splice(1);\n  			section.fragmentsToUnrender.forEach(methodCallers__unbind);\n\n  			return true;\n  		}\n  	} else {\n  		return removeSectionFragments(section);\n  	}\n  }\n\n  function removeSectionFragments(section) {\n  	if (section.length) {\n  		section.fragmentsToUnrender = section.fragments.splice(0, section.fragments.length).filter(isRendered);\n  		section.fragmentsToUnrender.forEach(methodCallers__unbind);\n  		section.length = section.fragmentsToRender.length = 0;\n  		return true;\n  	}\n  }\n\n  function isRendered(fragment) {\n  	return fragment.rendered;\n  }\n\n  function setValue__blindRebind(dep) {\n  	// the keypath doesn\'t actually matter here as it won\'t have changed\n  	dep.rebind("", "");\n  }\n\n  var prototype_toString = Section$toString;\n\n  function Section$toString(escape) {\n  	var str, i, len;\n\n  	str = "";\n\n  	i = 0;\n  	len = this.length;\n\n  	for (i = 0; i < len; i += 1) {\n  		str += this.fragments[i].toString(escape);\n  	}\n\n  	return str;\n  }\n\n  var prototype_unbind = Section$unbind;\n  function Section$unbind() {\n  	var _this = this;\n\n  	this.fragments.forEach(methodCallers__unbind);\n  	this.fragmentsToRender.forEach(function (f) {\n  		return removeFromArray(_this.fragments, f);\n  	});\n  	this.fragmentsToRender = [];\n  	shared_unbind.call(this);\n\n  	this.length = 0;\n  	this.unbound = true;\n  }\n\n  var prototype_unrender = Section$unrender;\n\n  function Section$unrender(shouldDestroy) {\n  	this.fragments.forEach(shouldDestroy ? unrenderAndDestroy : prototype_unrender__unrender);\n  	this.renderedFragments = [];\n  	this.rendered = false;\n  }\n\n  function unrenderAndDestroy(fragment) {\n  	fragment.unrender(true);\n  }\n\n  function prototype_unrender__unrender(fragment) {\n  	fragment.unrender(false);\n  }\n\n  var prototype_update = Section$update;\n\n  function Section$update() {\n  	var fragment, renderIndex, renderedFragments, anchor, target, i, len;\n\n  	// `this.renderedFragments` is in the order of the previous render.\n  	// If fragments have shuffled about, this allows us to quickly\n  	// reinsert them in the correct place\n  	renderedFragments = this.renderedFragments;\n\n  	// Remove fragments that have been marked for destruction\n  	while (fragment = this.fragmentsToUnrender.pop()) {\n  		fragment.unrender(true);\n  		renderedFragments.splice(renderedFragments.indexOf(fragment), 1);\n  	}\n\n  	// Render new fragments (but don\'t insert them yet)\n  	while (fragment = this.fragmentsToRender.shift()) {\n  		fragment.render();\n  	}\n\n  	if (this.rendered) {\n  		target = this.parentFragment.getNode();\n  	}\n\n  	len = this.fragments.length;\n  	for (i = 0; i < len; i += 1) {\n  		fragment = this.fragments[i];\n  		renderIndex = renderedFragments.indexOf(fragment, i); // search from current index - it\'s guaranteed to be the same or higher\n\n  		if (renderIndex === i) {\n  			// already in the right place. insert accumulated nodes (if any) and carry on\n  			if (this.docFrag.childNodes.length) {\n  				anchor = fragment.firstNode();\n  				target.insertBefore(this.docFrag, anchor);\n  			}\n\n  			continue;\n  		}\n\n  		this.docFrag.appendChild(fragment.detach());\n\n  		// update renderedFragments\n  		if (renderIndex !== -1) {\n  			renderedFragments.splice(renderIndex, 1);\n  		}\n  		renderedFragments.splice(i, 0, fragment);\n  	}\n\n  	if (this.rendered && this.docFrag.childNodes.length) {\n  		anchor = this.parentFragment.findNextNode(this);\n  		target.insertBefore(this.docFrag, anchor);\n  	}\n\n  	// Save the rendering order for next time\n  	this.renderedFragments = this.fragments.slice();\n  }\n\n  var Section = function (options) {\n  	this.type = SECTION;\n  	this.subtype = this.currentSubtype = options.template.n;\n  	this.inverted = this.subtype === SECTION_UNLESS;\n\n  	this.pElement = options.pElement;\n\n  	this.fragments = [];\n  	this.fragmentsToCreate = [];\n  	this.fragmentsToRender = [];\n  	this.fragmentsToUnrender = [];\n\n  	if (options.template.i) {\n  		this.indexRefs = options.template.i.split(",").map(function (k, i) {\n  			return { n: k, t: i === 0 ? "k" : "i" };\n  		});\n  	}\n\n  	this.renderedFragments = [];\n\n  	this.length = 0; // number of times this section is rendered\n\n  	Mustache.init(this, options);\n  };\n\n  Section.prototype = {\n  	bubble: Section_prototype_bubble,\n  	detach: Section_prototype_detach,\n  	find: find,\n  	findAll: findAll,\n  	findAllComponents: findAllComponents,\n  	findComponent: findComponent,\n  	findNextNode: findNextNode,\n  	firstNode: firstNode,\n  	getIndexRef: function (name) {\n  		if (this.indexRefs) {\n  			var i = this.indexRefs.length;\n  			while (i--) {\n  				var ref = this.indexRefs[i];\n  				if (ref.n === name) {\n  					return ref;\n  				}\n  			}\n  		}\n  	},\n  	getValue: Mustache.getValue,\n  	shuffle: shuffle,\n  	rebind: prototype_rebind,\n  	render: Section_prototype_render,\n  	resolve: Mustache.resolve,\n  	setValue: setValue,\n  	toString: prototype_toString,\n  	unbind: prototype_unbind,\n  	unrender: prototype_unrender,\n  	update: prototype_update\n  };\n\n  var _Section = Section;\n\n  var Triple_prototype_detach = Triple$detach;\n\n  function Triple$detach() {\n  	var len, i;\n\n  	if (this.docFrag) {\n  		len = this.nodes.length;\n  		for (i = 0; i < len; i += 1) {\n  			this.docFrag.appendChild(this.nodes[i]);\n  		}\n\n  		return this.docFrag;\n  	}\n  }\n\n  var Triple_prototype_find = Triple$find;\n  function Triple$find(selector) {\n  	var i, len, node, queryResult;\n\n  	len = this.nodes.length;\n  	for (i = 0; i < len; i += 1) {\n  		node = this.nodes[i];\n\n  		if (node.nodeType !== 1) {\n  			continue;\n  		}\n\n  		if (matches(node, selector)) {\n  			return node;\n  		}\n\n  		if (queryResult = node.querySelector(selector)) {\n  			return queryResult;\n  		}\n  	}\n\n  	return null;\n  }\n\n  var Triple_prototype_findAll = Triple$findAll;\n  function Triple$findAll(selector, queryResult) {\n  	var i, len, node, queryAllResult, numNodes, j;\n\n  	len = this.nodes.length;\n  	for (i = 0; i < len; i += 1) {\n  		node = this.nodes[i];\n\n  		if (node.nodeType !== 1) {\n  			continue;\n  		}\n\n  		if (matches(node, selector)) {\n  			queryResult.push(node);\n  		}\n\n  		if (queryAllResult = node.querySelectorAll(selector)) {\n  			numNodes = queryAllResult.length;\n  			for (j = 0; j < numNodes; j += 1) {\n  				queryResult.push(queryAllResult[j]);\n  			}\n  		}\n  	}\n  }\n\n  var Triple_prototype_firstNode = Triple$firstNode;\n\n  function Triple$firstNode() {\n  	if (this.rendered && this.nodes[0]) {\n  		return this.nodes[0];\n  	}\n\n  	return this.parentFragment.findNextNode(this);\n  }\n\n  var elementCache = {},\n      ieBug,\n      ieBlacklist;\n\n  try {\n  	createElement("table").innerHTML = "foo";\n  } catch (err) {\n  	ieBug = true;\n\n  	ieBlacklist = {\n  		TABLE: ["<table class=\\"x\\">", "</table>"],\n  		THEAD: ["<table><thead class=\\"x\\">", "</thead></table>"],\n  		TBODY: ["<table><tbody class=\\"x\\">", "</tbody></table>"],\n  		TR: ["<table><tr class=\\"x\\">", "</tr></table>"],\n  		SELECT: ["<select class=\\"x\\">", "</select>"]\n  	};\n  }\n\n  var insertHtml = function (html, node, docFrag) {\n  	var container,\n  	    nodes = [],\n  	    wrapper,\n  	    selectedOption,\n  	    child,\n  	    i;\n\n  	// render 0 and false\n  	if (html != null && html !== "") {\n  		if (ieBug && (wrapper = ieBlacklist[node.tagName])) {\n  			container = element("DIV");\n  			container.innerHTML = wrapper[0] + html + wrapper[1];\n  			container = container.querySelector(".x");\n\n  			if (container.tagName === "SELECT") {\n  				selectedOption = container.options[container.selectedIndex];\n  			}\n  		} else if (node.namespaceURI === namespaces.svg) {\n  			container = element("DIV");\n  			container.innerHTML = "<svg class=\\"x\\">" + html + "</svg>";\n  			container = container.querySelector(".x");\n  		} else {\n  			container = element(node.tagName);\n  			container.innerHTML = html;\n\n  			if (container.tagName === "SELECT") {\n  				selectedOption = container.options[container.selectedIndex];\n  			}\n  		}\n\n  		while (child = container.firstChild) {\n  			nodes.push(child);\n  			docFrag.appendChild(child);\n  		}\n\n  		// This is really annoying. Extracting <option> nodes from the\n  		// temporary container <select> causes the remaining ones to\n  		// become selected. So now we have to deselect them. IE8, you\n  		// amaze me. You really do\n  		// ...and now Chrome too\n  		if (node.tagName === "SELECT") {\n  			i = nodes.length;\n  			while (i--) {\n  				if (nodes[i] !== selectedOption) {\n  					nodes[i].selected = false;\n  				}\n  			}\n  		}\n  	}\n\n  	return nodes;\n  };\n\n  function element(tagName) {\n  	return elementCache[tagName] || (elementCache[tagName] = createElement(tagName));\n  }\n\n  var helpers_updateSelect = updateSelect;\n\n  function updateSelect(parentElement) {\n  	var selectedOptions, option, value;\n\n  	if (!parentElement || parentElement.name !== "select" || !parentElement.binding) {\n  		return;\n  	}\n\n  	selectedOptions = toArray(parentElement.node.options).filter(isSelected);\n\n  	// If one of them had a `selected` attribute, we need to sync\n  	// the model to the view\n  	if (parentElement.getAttribute("multiple")) {\n  		value = selectedOptions.map(function (o) {\n  			return o.value;\n  		});\n  	} else if (option = selectedOptions[0]) {\n  		value = option.value;\n  	}\n\n  	if (value !== undefined) {\n  		parentElement.binding.setValue(value);\n  	}\n\n  	parentElement.bubble();\n  }\n\n  function isSelected(option) {\n  	return option.selected;\n  }\n\n  var Triple_prototype_render = Triple$render;\n  function Triple$render() {\n  	if (this.rendered) {\n  		throw new Error("Attempted to render an item that was already rendered");\n  	}\n\n  	this.docFrag = document.createDocumentFragment();\n  	this.nodes = insertHtml(this.value, this.parentFragment.getNode(), this.docFrag);\n\n  	// Special case - we\'re inserting the contents of a <select>\n  	helpers_updateSelect(this.pElement);\n\n  	this.rendered = true;\n  	return this.docFrag;\n  }\n\n  var prototype_setValue = Triple$setValue;\n  function Triple$setValue(value) {\n  	var wrapper;\n\n  	// TODO is there a better way to approach this?\n  	if (wrapper = this.root.viewmodel.wrapped[this.keypath.str]) {\n  		value = wrapper.get();\n  	}\n\n  	if (value !== this.value) {\n  		this.value = value;\n  		this.parentFragment.bubble();\n\n  		if (this.rendered) {\n  			global_runloop.addView(this);\n  		}\n  	}\n  }\n\n  var Triple_prototype_toString = Triple$toString;\n  function Triple$toString() {\n  	return this.value != undefined ? decodeCharacterReferences("" + this.value) : "";\n  }\n\n  var Triple_prototype_unrender = Triple$unrender;\n  function Triple$unrender(shouldDestroy) {\n  	if (this.rendered && shouldDestroy) {\n  		this.nodes.forEach(detachNode);\n  		this.rendered = false;\n  	}\n\n  	// TODO update live queries\n  }\n\n  var Triple_prototype_update = Triple$update;\n  function Triple$update() {\n  	var node, parentNode;\n\n  	if (!this.rendered) {\n  		return;\n  	}\n\n  	// Remove existing nodes\n  	while (this.nodes && this.nodes.length) {\n  		node = this.nodes.pop();\n  		node.parentNode.removeChild(node);\n  	}\n\n  	// Insert new nodes\n  	parentNode = this.parentFragment.getNode();\n\n  	this.nodes = insertHtml(this.value, parentNode, this.docFrag);\n  	parentNode.insertBefore(this.docFrag, this.parentFragment.findNextNode(this));\n\n  	// Special case - we\'re inserting the contents of a <select>\n  	helpers_updateSelect(this.pElement);\n  }\n\n  var Triple = function (options) {\n  	this.type = TRIPLE;\n  	Mustache.init(this, options);\n  };\n\n  Triple.prototype = {\n  	detach: Triple_prototype_detach,\n  	find: Triple_prototype_find,\n  	findAll: Triple_prototype_findAll,\n  	firstNode: Triple_prototype_firstNode,\n  	getValue: Mustache.getValue,\n  	rebind: Mustache.rebind,\n  	render: Triple_prototype_render,\n  	resolve: Mustache.resolve,\n  	setValue: prototype_setValue,\n  	toString: Triple_prototype_toString,\n  	unbind: shared_unbind,\n  	unrender: Triple_prototype_unrender,\n  	update: Triple_prototype_update\n  };\n\n  var _Triple = Triple;\n\n  var Element_prototype_bubble = function () {\n  	this.parentFragment.bubble();\n  };\n\n  var Element_prototype_detach = Element$detach;\n\n  function Element$detach() {\n  	var node = this.node,\n  	    parentNode;\n\n  	if (node) {\n  		// need to check for parent node - DOM may have been altered\n  		// by something other than Ractive! e.g. jQuery UI...\n  		if (parentNode = node.parentNode) {\n  			parentNode.removeChild(node);\n  		}\n\n  		return node;\n  	}\n  }\n\n  var Element_prototype_find = function (selector) {\n  	if (!this.node) {\n  		// this element hasn\'t been rendered yet\n  		return null;\n  	}\n\n  	if (matches(this.node, selector)) {\n  		return this.node;\n  	}\n\n  	if (this.fragment && this.fragment.find) {\n  		return this.fragment.find(selector);\n  	}\n  };\n\n  var Element_prototype_findAll = function (selector, query) {\n  	// Add this node to the query, if applicable, and register the\n  	// query on this element\n  	if (query._test(this, true) && query.live) {\n  		(this.liveQueries || (this.liveQueries = [])).push(query);\n  	}\n\n  	if (this.fragment) {\n  		this.fragment.findAll(selector, query);\n  	}\n  };\n\n  var Element_prototype_findAllComponents = function (selector, query) {\n  	if (this.fragment) {\n  		this.fragment.findAllComponents(selector, query);\n  	}\n  };\n\n  var Element_prototype_findComponent = function (selector) {\n  	if (this.fragment) {\n  		return this.fragment.findComponent(selector);\n  	}\n  };\n\n  var Element_prototype_findNextNode = Element$findNextNode;\n\n  function Element$findNextNode() {\n  	return null;\n  }\n\n  var Element_prototype_firstNode = Element$firstNode;\n\n  function Element$firstNode() {\n  	return this.node;\n  }\n\n  var getAttribute = Element$getAttribute;\n\n  function Element$getAttribute(name) {\n  	if (!this.attributes || !this.attributes[name]) {\n  		return;\n  	}\n\n  	return this.attributes[name].value;\n  }\n\n  var truthy = /^true|on|yes|1$/i;\n  var processBindingAttributes__isNumeric = /^[0-9]+$/;\n\n  var processBindingAttributes = function (element, template) {\n  	var val, attrs, attributes;\n\n  	attributes = template.a || {};\n  	attrs = {};\n\n  	// attributes that are present but don\'t have a value (=)\n  	// will be set to the number 0, which we condider to be true\n  	// the string \'0\', however is false\n\n  	val = attributes.twoway;\n  	if (val !== undefined) {\n  		attrs.twoway = val === 0 || truthy.test(val);\n  	}\n\n  	val = attributes.lazy;\n  	if (val !== undefined) {\n  		// check for timeout value\n  		if (val !== 0 && processBindingAttributes__isNumeric.test(val)) {\n  			attrs.lazy = parseInt(val);\n  		} else {\n  			attrs.lazy = val === 0 || truthy.test(val);\n  		}\n  	}\n\n  	return attrs;\n  };\n\n  var Attribute_prototype_bubble = Attribute$bubble;\n  function Attribute$bubble() {\n  	var value = this.useProperty || !this.rendered ? this.fragment.getValue() : this.fragment.toString();\n\n  	// TODO this can register the attribute multiple times (see render test\n  	// \'Attribute with nested mustaches\')\n  	if (!isEqual(value, this.value)) {\n\n  		// Need to clear old id from ractive.nodes\n  		if (this.name === "id" && this.value) {\n  			delete this.root.nodes[this.value];\n  		}\n\n  		this.value = value;\n\n  		if (this.name === "value" && this.node) {\n  			// We need to store the value on the DOM like this so we\n  			// can retrieve it later without it being coerced to a string\n  			this.node._ractive.value = value;\n  		}\n\n  		if (this.rendered) {\n  			global_runloop.addView(this);\n  		}\n  	}\n  }\n\n  var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;\n  svgCamelCaseElements = "altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern".split(" ");\n  svgCamelCaseAttributes = "attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan".split(" ");\n\n  createMap = function (items) {\n  	var map = {},\n  	    i = items.length;\n  	while (i--) {\n  		map[items[i].toLowerCase()] = items[i];\n  	}\n  	return map;\n  };\n\n  map = createMap(svgCamelCaseElements.concat(svgCamelCaseAttributes));\n\n  var enforceCase = function (elementName) {\n  	var lowerCaseElementName = elementName.toLowerCase();\n  	return map[lowerCaseElementName] || lowerCaseElementName;\n  };\n\n  var determineNameAndNamespace = function (attribute, name) {\n  	var colonIndex, namespacePrefix;\n\n  	// are we dealing with a namespaced attribute, e.g. xlink:href?\n  	colonIndex = name.indexOf(":");\n  	if (colonIndex !== -1) {\n\n  		// looks like we are, yes...\n  		namespacePrefix = name.substr(0, colonIndex);\n\n  		// ...unless it\'s a namespace *declaration*, which we ignore (on the assumption\n  		// that only valid namespaces will be used)\n  		if (namespacePrefix !== "xmlns") {\n  			name = name.substring(colonIndex + 1);\n\n  			attribute.name = enforceCase(name);\n  			attribute.namespace = namespaces[namespacePrefix.toLowerCase()];\n  			attribute.namespacePrefix = namespacePrefix;\n\n  			if (!attribute.namespace) {\n  				throw "Unknown namespace (\\"" + namespacePrefix + "\\")";\n  			}\n\n  			return;\n  		}\n  	}\n\n  	// SVG attribute names are case sensitive\n  	attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase(name) : name;\n  };\n\n  var helpers_getInterpolator = getInterpolator;\n  function getInterpolator(attribute) {\n  	var items = attribute.fragment.items;\n\n  	if (items.length !== 1) {\n  		return;\n  	}\n\n  	if (items[0].type === INTERPOLATOR) {\n  		return items[0];\n  	}\n  }\n\n  var prototype_init = Attribute$init;\n  function Attribute$init(options) {\n  	this.type = ATTRIBUTE;\n  	this.element = options.element;\n  	this.root = options.root;\n\n  	determineNameAndNamespace(this, options.name);\n  	this.isBoolean = booleanAttributes.test(this.name);\n\n  	// if it\'s an empty attribute, or just a straight key-value pair, with no\n  	// mustache shenanigans, set the attribute accordingly and go home\n  	if (!options.value || typeof options.value === "string") {\n  		this.value = this.isBoolean ? true : options.value || "";\n  		return;\n  	}\n\n  	// otherwise we need to do some work\n\n  	// share parentFragment with parent element\n  	this.parentFragment = this.element.parentFragment;\n\n  	this.fragment = new virtualdom_Fragment({\n  		template: options.value,\n  		root: this.root,\n  		owner: this\n  	});\n\n  	// TODO can we use this.fragment.toString() in some cases? It\'s quicker\n  	this.value = this.fragment.getValue();\n\n  	// Store a reference to this attribute\'s interpolator, if its fragment\n  	// takes the form `{{foo}}`. This is necessary for two-way binding and\n  	// for correctly rendering HTML later\n  	this.interpolator = helpers_getInterpolator(this);\n  	this.isBindable = !!this.interpolator && !this.interpolator.isStatic;\n\n  	// mark as ready\n  	this.ready = true;\n  }\n\n  var Attribute_prototype_rebind = Attribute$rebind;\n\n  function Attribute$rebind(oldKeypath, newKeypath) {\n  	if (this.fragment) {\n  		this.fragment.rebind(oldKeypath, newKeypath);\n  	}\n  }\n\n  var Attribute_prototype_render = Attribute$render;\n  var propertyNames = {\n  	"accept-charset": "acceptCharset",\n  	accesskey: "accessKey",\n  	bgcolor: "bgColor",\n  	"class": "className",\n  	codebase: "codeBase",\n  	colspan: "colSpan",\n  	contenteditable: "contentEditable",\n  	datetime: "dateTime",\n  	dirname: "dirName",\n  	"for": "htmlFor",\n  	"http-equiv": "httpEquiv",\n  	ismap: "isMap",\n  	maxlength: "maxLength",\n  	novalidate: "noValidate",\n  	pubdate: "pubDate",\n  	readonly: "readOnly",\n  	rowspan: "rowSpan",\n  	tabindex: "tabIndex",\n  	usemap: "useMap"\n  };\n  function Attribute$render(node) {\n  	var propertyName;\n\n  	this.node = node;\n\n  	// should we use direct property access, or setAttribute?\n  	if (!node.namespaceURI || node.namespaceURI === namespaces.html) {\n  		propertyName = propertyNames[this.name] || this.name;\n\n  		if (node[propertyName] !== undefined) {\n  			this.propertyName = propertyName;\n  		}\n\n  		// is attribute a boolean attribute or \'value\'? If so we\'re better off doing e.g.\n  		// node.selected = true rather than node.setAttribute( \'selected\', \'\' )\n  		if (this.isBoolean || this.isTwoway) {\n  			this.useProperty = true;\n  		}\n\n  		if (propertyName === "value") {\n  			node._ractive.value = this.value;\n  		}\n  	}\n\n  	this.rendered = true;\n  	this.update();\n  }\n\n  var Attribute_prototype_toString = Attribute$toString;\n\n  function Attribute$toString() {\n  	var _ref = this;\n\n  	var name = _ref.name;\n  	var namespacePrefix = _ref.namespacePrefix;\n  	var value = _ref.value;\n  	var interpolator = _ref.interpolator;\n  	var fragment = _ref.fragment;\n\n  	// Special case - select and textarea values (should not be stringified)\n  	if (name === "value" && (this.element.name === "select" || this.element.name === "textarea")) {\n  		return;\n  	}\n\n  	// Special case - content editable\n  	if (name === "value" && this.element.getAttribute("contenteditable") !== undefined) {\n  		return;\n  	}\n\n  	// Special case - radio names\n  	if (name === "name" && this.element.name === "input" && interpolator) {\n  		return "name={{" + (interpolator.keypath.str || interpolator.ref) + "}}";\n  	}\n\n  	// Boolean attributes\n  	if (this.isBoolean) {\n  		return value ? name : "";\n  	}\n\n  	if (fragment) {\n  		// special case - this catches undefined/null values (#1211)\n  		if (fragment.items.length === 1 && fragment.items[0].value == null) {\n  			return "";\n  		}\n\n  		value = fragment.toString();\n  	}\n\n  	if (namespacePrefix) {\n  		name = namespacePrefix + ":" + name;\n  	}\n\n  	return value ? name + "=\\"" + Attribute_prototype_toString__escape(value) + "\\"" : name;\n  }\n\n  function Attribute_prototype_toString__escape(value) {\n  	return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/\'/g, "&#39;");\n  }\n\n  var Attribute_prototype_unbind = Attribute$unbind;\n\n  function Attribute$unbind() {\n  	// ignore non-dynamic attributes\n  	if (this.fragment) {\n  		this.fragment.unbind();\n  	}\n\n  	if (this.name === "id") {\n  		delete this.root.nodes[this.value];\n  	}\n  }\n\n  var updateSelectValue = Attribute$updateSelect;\n\n  function Attribute$updateSelect() {\n  	var value = this.value,\n  	    options,\n  	    option,\n  	    optionValue,\n  	    i;\n\n  	if (!this.locked) {\n  		this.node._ractive.value = value;\n\n  		options = this.node.options;\n  		i = options.length;\n\n  		while (i--) {\n  			option = options[i];\n  			optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don\'t have _ractive\n\n  			if (optionValue == value) {\n  				// double equals as we may be comparing numbers with strings\n  				option.selected = true;\n  				break;\n  			}\n  		}\n  	}\n\n  	// if we\'re still here, it means the new value didn\'t match any of the options...\n  	// TODO figure out what to do in this situation\n  }\n\n  var updateMultipleSelectValue = Attribute$updateMultipleSelect;\n  function Attribute$updateMultipleSelect() {\n  	var value = this.value,\n  	    options,\n  	    i,\n  	    option,\n  	    optionValue;\n\n  	if (!isArray(value)) {\n  		value = [value];\n  	}\n\n  	options = this.node.options;\n  	i = options.length;\n\n  	while (i--) {\n  		option = options[i];\n  		optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don\'t have _ractive\n  		option.selected = arrayContains(value, optionValue);\n  	}\n  }\n\n  var updateRadioName = Attribute$updateRadioName;\n\n  function Attribute$updateRadioName() {\n  	var _ref = this;\n\n  	var node = _ref.node;\n  	var value = _ref.value;\n\n  	node.checked = value == node._ractive.value;\n  }\n\n  var updateRadioValue = Attribute$updateRadioValue;\n  function Attribute$updateRadioValue() {\n  	var wasChecked,\n  	    node = this.node,\n  	    binding,\n  	    bindings,\n  	    i;\n\n  	wasChecked = node.checked;\n\n  	node.value = this.element.getAttribute("value");\n  	node.checked = this.element.getAttribute("value") === this.element.getAttribute("name");\n\n  	// This is a special case - if the input was checked, and the value\n  	// changed so that it\'s no longer checked, the twoway binding is\n  	// most likely out of date. To fix it we have to jump through some\n  	// hoops... this is a little kludgy but it works\n  	if (wasChecked && !node.checked && this.element.binding) {\n  		bindings = this.element.binding.siblings;\n\n  		if (i = bindings.length) {\n  			while (i--) {\n  				binding = bindings[i];\n\n  				if (!binding.element.node) {\n  					// this is the initial render, siblings are still rendering!\n  					// we\'ll come back later...\n  					return;\n  				}\n\n  				if (binding.element.node.checked) {\n  					global_runloop.addRactive(binding.root);\n  					return binding.handleChange();\n  				}\n  			}\n\n  			this.root.viewmodel.set(binding.keypath, undefined);\n  		}\n  	}\n  }\n\n  var updateCheckboxName = Attribute$updateCheckboxName;\n  function Attribute$updateCheckboxName() {\n  	var _ref = this;\n\n  	var element = _ref.element;\n  	var node = _ref.node;\n  	var value = _ref.value;var binding = element.binding;var valueAttribute;var i;\n\n  	valueAttribute = element.getAttribute("value");\n\n  	if (!isArray(value)) {\n  		binding.isChecked = node.checked = value == valueAttribute;\n  	} else {\n  		i = value.length;\n  		while (i--) {\n  			if (valueAttribute == value[i]) {\n  				binding.isChecked = node.checked = true;\n  				return;\n  			}\n  		}\n  		binding.isChecked = node.checked = false;\n  	}\n  }\n\n  var updateClassName = Attribute$updateClassName;\n  function Attribute$updateClassName() {\n  	this.node.className = safeToStringValue(this.value);\n  }\n\n  var updateIdAttribute = Attribute$updateIdAttribute;\n\n  function Attribute$updateIdAttribute() {\n  	var _ref = this;\n\n  	var node = _ref.node;\n  	var value = _ref.value;\n\n  	this.root.nodes[value] = node;\n  	node.id = value;\n  }\n\n  var updateIEStyleAttribute = Attribute$updateIEStyleAttribute;\n\n  function Attribute$updateIEStyleAttribute() {\n  	var node, value;\n\n  	node = this.node;\n  	value = this.value;\n\n  	if (value === undefined) {\n  		value = "";\n  	}\n\n  	node.style.setAttribute("cssText", value);\n  }\n\n  var updateContentEditableValue = Attribute$updateContentEditableValue;\n\n  function Attribute$updateContentEditableValue() {\n  	var value = this.value;\n\n  	if (value === undefined) {\n  		value = "";\n  	}\n\n  	if (!this.locked) {\n  		this.node.innerHTML = value;\n  	}\n  }\n\n  var updateValue = Attribute$updateValue;\n\n  function Attribute$updateValue() {\n  	var _ref = this;\n\n  	var node = _ref.node;\n  	var value = _ref.value;\n\n  	// store actual value, so it doesn\'t get coerced to a string\n  	node._ractive.value = value;\n\n  	// with two-way binding, only update if the change wasn\'t initiated by the user\n  	// otherwise the cursor will often be sent to the wrong place\n  	if (!this.locked) {\n  		node.value = value == undefined ? "" : value;\n  	}\n  }\n\n  var updateBoolean = Attribute$updateBooleanAttribute;\n\n  function Attribute$updateBooleanAttribute() {\n  	// with two-way binding, only update if the change wasn\'t initiated by the user\n  	// otherwise the cursor will often be sent to the wrong place\n  	if (!this.locked) {\n  		this.node[this.propertyName] = this.value;\n  	}\n  }\n\n  var updateEverythingElse = Attribute$updateEverythingElse;\n\n  function Attribute$updateEverythingElse() {\n  	var _ref = this;\n\n  	var node = _ref.node;\n  	var namespace = _ref.namespace;\n  	var name = _ref.name;\n  	var value = _ref.value;\n  	var fragment = _ref.fragment;\n\n  	if (namespace) {\n  		node.setAttributeNS(namespace, name, (fragment || value).toString());\n  	} else if (!this.isBoolean) {\n  		if (value == null) {\n  			node.removeAttribute(name);\n  		} else {\n  			node.setAttribute(name, (fragment || value).toString());\n  		}\n  	}\n\n  	// Boolean attributes - truthy becomes \'\', falsy means \'remove attribute\'\n  	else {\n  		if (value) {\n  			node.setAttribute(name, "");\n  		} else {\n  			node.removeAttribute(name);\n  		}\n  	}\n  }\n\n  // There are a few special cases when it comes to updating attributes. For this reason,\n  // the prototype .update() method points to this method, which waits until the\n  // attribute has finished initialising, then replaces the prototype method with a more\n  // suitable one. That way, we save ourselves doing a bunch of tests on each call\n  var Attribute_prototype_update = Attribute$update;\n  function Attribute$update() {\n  	var _ref = this;\n\n  	var name = _ref.name;\n  	var element = _ref.element;\n  	var node = _ref.node;var type;var updateMethod;\n\n  	if (name === "id") {\n  		updateMethod = updateIdAttribute;\n  	} else if (name === "value") {\n  		// special case - selects\n  		if (element.name === "select" && name === "value") {\n  			updateMethod = element.getAttribute("multiple") ? updateMultipleSelectValue : updateSelectValue;\n  		} else if (element.name === "textarea") {\n  			updateMethod = updateValue;\n  		}\n\n  		// special case - contenteditable\n  		else if (element.getAttribute("contenteditable") != null) {\n  			updateMethod = updateContentEditableValue;\n  		}\n\n  		// special case - <input>\n  		else if (element.name === "input") {\n  			type = element.getAttribute("type");\n\n  			// type=\'file\' value=\'{{fileList}}\'>\n  			if (type === "file") {\n  				updateMethod = noop; // read-only\n  			}\n\n  			// type=\'radio\' name=\'{{twoway}}\'\n  			else if (type === "radio" && element.binding && element.binding.name === "name") {\n  				updateMethod = updateRadioValue;\n  			} else {\n  				updateMethod = updateValue;\n  			}\n  		}\n  	}\n\n  	// special case - <input type=\'radio\' name=\'{{twoway}}\' value=\'foo\'>\n  	else if (this.isTwoway && name === "name") {\n  		if (node.type === "radio") {\n  			updateMethod = updateRadioName;\n  		} else if (node.type === "checkbox") {\n  			updateMethod = updateCheckboxName;\n  		}\n  	}\n\n  	// special case - style attributes in Internet Exploder\n  	else if (name === "style" && node.style.setAttribute) {\n  		updateMethod = updateIEStyleAttribute;\n  	}\n\n  	// special case - class names. IE fucks things up, again\n  	else if (name === "class" && (!node.namespaceURI || node.namespaceURI === namespaces.html)) {\n  		updateMethod = updateClassName;\n  	} else if (this.useProperty) {\n  		updateMethod = updateBoolean;\n  	}\n\n  	if (!updateMethod) {\n  		updateMethod = updateEverythingElse;\n  	}\n\n  	this.update = updateMethod;\n  	this.update();\n  }\n\n  var Attribute = function (options) {\n  	this.init(options);\n  };\n\n  Attribute.prototype = {\n  	bubble: Attribute_prototype_bubble,\n  	init: prototype_init,\n  	rebind: Attribute_prototype_rebind,\n  	render: Attribute_prototype_render,\n  	toString: Attribute_prototype_toString,\n  	unbind: Attribute_prototype_unbind,\n  	update: Attribute_prototype_update\n  };\n\n  var _Attribute = Attribute;\n\n  var createAttributes = function (element, attributes) {\n  	var name,\n  	    attribute,\n  	    result = [];\n\n  	for (name in attributes) {\n  		// skip binding attributes\n  		if (name === "twoway" || name === "lazy") {\n  			continue;\n  		}\n\n  		if (attributes.hasOwnProperty(name)) {\n  			attribute = new _Attribute({\n  				element: element,\n  				name: name,\n  				value: attributes[name],\n  				root: element.root\n  			});\n\n  			result[name] = attribute;\n\n  			if (name !== "value") {\n  				result.push(attribute);\n  			}\n  		}\n  	}\n\n  	// value attribute goes last. This is because it\n  	// may get clamped on render otherwise, e.g. in\n  	// `<input type=\'range\' value=\'999\' min=\'0\' max=\'1000\'>`\n  	// since default max is 100\n  	if (attribute = result.value) {\n  		result.push(attribute);\n  	}\n\n  	return result;\n  };\n\n  var _ConditionalAttribute__div;\n\n  if (typeof document !== "undefined") {\n  	_ConditionalAttribute__div = createElement("div");\n  }\n\n  var ConditionalAttribute = function (element, template) {\n  	this.element = element;\n  	this.root = element.root;\n  	this.parentFragment = element.parentFragment;\n\n  	this.attributes = [];\n\n  	this.fragment = new virtualdom_Fragment({\n  		root: element.root,\n  		owner: this,\n  		template: [template]\n  	});\n  };\n\n  ConditionalAttribute.prototype = {\n  	bubble: function () {\n  		if (this.node) {\n  			this.update();\n  		}\n\n  		this.element.bubble();\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		this.fragment.rebind(oldKeypath, newKeypath);\n  	},\n\n  	render: function (node) {\n  		this.node = node;\n  		this.isSvg = node.namespaceURI === namespaces.svg;\n\n  		this.update();\n  	},\n\n  	unbind: function () {\n  		this.fragment.unbind();\n  	},\n\n  	update: function () {\n  		var _this = this;\n\n  		var str, attrs;\n\n  		str = this.fragment.toString();\n  		attrs = parseAttributes(str, this.isSvg);\n\n  		// any attributes that previously existed but no longer do\n  		// must be removed\n  		this.attributes.filter(function (a) {\n  			return notIn(attrs, a);\n  		}).forEach(function (a) {\n  			_this.node.removeAttribute(a.name);\n  		});\n\n  		attrs.forEach(function (a) {\n  			_this.node.setAttribute(a.name, a.value);\n  		});\n\n  		this.attributes = attrs;\n  	},\n\n  	toString: function () {\n  		return this.fragment.toString();\n  	}\n  };\n\n  var _ConditionalAttribute = ConditionalAttribute;\n\n  function parseAttributes(str, isSvg) {\n  	var tag = isSvg ? "svg" : "div";\n  	_ConditionalAttribute__div.innerHTML = "<" + tag + " " + str + "></" + tag + ">";\n\n  	return toArray(_ConditionalAttribute__div.childNodes[0].attributes);\n  }\n\n  function notIn(haystack, needle) {\n  	var i = haystack.length;\n\n  	while (i--) {\n  		if (haystack[i].name === needle.name) {\n  			return false;\n  		}\n  	}\n\n  	return true;\n  }\n\n  var createConditionalAttributes = function (element, attributes) {\n  	if (!attributes) {\n  		return [];\n  	}\n\n  	return attributes.map(function (a) {\n  		return new _ConditionalAttribute(element, a);\n  	});\n  };\n\n  var Binding = function (element) {\n  	var interpolator, keypath, value, parentForm;\n\n  	this.element = element;\n  	this.root = element.root;\n  	this.attribute = element.attributes[this.name || "value"];\n\n  	interpolator = this.attribute.interpolator;\n  	interpolator.twowayBinding = this;\n\n  	if (keypath = interpolator.keypath) {\n  		if (keypath.str.slice(-1) === "}") {\n  			warnOnceIfDebug("Two-way binding does not work with expressions (`%s` on <%s>)", interpolator.resolver.uniqueString, element.name, { ractive: this.root });\n  			return false;\n  		}\n\n  		if (keypath.isSpecial) {\n  			warnOnceIfDebug("Two-way binding does not work with %s", interpolator.resolver.ref, { ractive: this.root });\n  			return false;\n  		}\n  	} else {\n  		// A mustache may be *ambiguous*. Let\'s say we were given\n  		// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`\n  		// *wasn\'t* `undefined`, the keypath would be `foo.bar`.\n  		// Then, any user input would result in `foo.bar` being updated.\n  		//\n  		// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be\n  		// left with an unresolved partial keypath - so we are forced to make an\n  		// assumption. That assumption is that the input in question should\n  		// be forced to resolve to `bar`, and any user input would affect `bar`\n  		// and not `foo.bar`.\n  		//\n  		// Did that make any sense? No? Oh. Sorry. Well the moral of the story is\n  		// be explicit when using two-way data-binding about what keypath you\'re\n  		// updating. Using it in lists is probably a recipe for confusion...\n  		var ref = interpolator.template.r ? "\'" + interpolator.template.r + "\' reference" : "expression";\n  		warnIfDebug("The %s being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity", ref, { ractive: this.root });\n  		interpolator.resolver.forceResolution();\n  		keypath = interpolator.keypath;\n  	}\n\n  	this.attribute.isTwoway = true;\n  	this.keypath = keypath;\n\n  	// initialise value, if it\'s undefined\n  	value = this.root.viewmodel.get(keypath);\n\n  	if (value === undefined && this.getInitialValue) {\n  		value = this.getInitialValue();\n\n  		if (value !== undefined) {\n  			this.root.viewmodel.set(keypath, value);\n  		}\n  	}\n\n  	if (parentForm = findParentForm(element)) {\n  		this.resetValue = value;\n  		parentForm.formBindings.push(this);\n  	}\n  };\n\n  Binding.prototype = {\n  	handleChange: function () {\n  		var _this = this;\n\n  		global_runloop.start(this.root);\n  		this.attribute.locked = true;\n  		this.root.viewmodel.set(this.keypath, this.getValue());\n  		global_runloop.scheduleTask(function () {\n  			return _this.attribute.locked = false;\n  		});\n  		global_runloop.end();\n  	},\n\n  	rebound: function () {\n  		var bindings, oldKeypath, newKeypath;\n\n  		oldKeypath = this.keypath;\n  		newKeypath = this.attribute.interpolator.keypath;\n\n  		// The attribute this binding is linked to has already done the work\n  		if (oldKeypath === newKeypath) {\n  			return;\n  		}\n\n  		removeFromArray(this.root._twowayBindings[oldKeypath.str], this);\n\n  		this.keypath = newKeypath;\n\n  		bindings = this.root._twowayBindings[newKeypath.str] || (this.root._twowayBindings[newKeypath.str] = []);\n  		bindings.push(this);\n  	},\n\n  	unbind: function () {}\n  };\n\n  Binding.extend = function (properties) {\n  	var Parent = this,\n  	    SpecialisedBinding;\n\n  	SpecialisedBinding = function (element) {\n  		Binding.call(this, element);\n\n  		if (this.init) {\n  			this.init();\n  		}\n  	};\n\n  	SpecialisedBinding.prototype = create(Parent.prototype);\n  	utils_object__extend(SpecialisedBinding.prototype, properties);\n\n  	SpecialisedBinding.extend = Binding.extend;\n\n  	return SpecialisedBinding;\n  };\n\n  var Binding_Binding = Binding;\n\n  function findParentForm(element) {\n  	while (element = element.parent) {\n  		if (element.name === "form") {\n  			return element;\n  		}\n  	}\n  }\n\n  // this is called when the element is unbound.\n  // Specialised bindings can override it\n\n  // This is the handler for DOM events that would lead to a change in the model\n  // (i.e. change, sometimes, input, and occasionally click and keyup)\n  var handleDomEvent = handleChange;\n\n  function handleChange() {\n  	this._ractive.binding.handleChange();\n  }\n\n  var ContentEditableBinding = Binding_Binding.extend({\n  	getInitialValue: function () {\n  		return this.element.fragment ? this.element.fragment.toString() : "";\n  	},\n\n  	render: function () {\n  		var node = this.element.node;\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		if (!this.root.lazy) {\n  			node.addEventListener("input", handleDomEvent, false);\n\n  			if (node.attachEvent) {\n  				node.addEventListener("keyup", handleDomEvent, false);\n  			}\n  		}\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("input", handleDomEvent, false);\n  		node.removeEventListener("keyup", handleDomEvent, false);\n  	},\n\n  	getValue: function () {\n  		return this.element.node.innerHTML;\n  	}\n  });\n\n  var Binding_ContentEditableBinding = ContentEditableBinding;\n\n  var shared_getSiblings = getSiblings;\n  var sets = {};\n  function getSiblings(id, group, keypath) {\n  	var hash = id + group + keypath;\n  	return sets[hash] || (sets[hash] = []);\n  }\n\n  var RadioBinding = Binding_Binding.extend({\n  	name: "checked",\n\n  	init: function () {\n  		this.siblings = shared_getSiblings(this.root._guid, "radio", this.element.getAttribute("name"));\n  		this.siblings.push(this);\n  	},\n\n  	render: function () {\n  		var node = this.element.node;\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		if (node.attachEvent) {\n  			node.addEventListener("click", handleDomEvent, false);\n  		}\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("click", handleDomEvent, false);\n  	},\n\n  	handleChange: function () {\n  		global_runloop.start(this.root);\n\n  		this.siblings.forEach(function (binding) {\n  			binding.root.viewmodel.set(binding.keypath, binding.getValue());\n  		});\n\n  		global_runloop.end();\n  	},\n\n  	getValue: function () {\n  		return this.element.node.checked;\n  	},\n\n  	unbind: function () {\n  		removeFromArray(this.siblings, this);\n  	}\n  });\n\n  var Binding_RadioBinding = RadioBinding;\n\n  var RadioNameBinding = Binding_Binding.extend({\n  	name: "name",\n\n  	init: function () {\n  		this.siblings = shared_getSiblings(this.root._guid, "radioname", this.keypath.str);\n  		this.siblings.push(this);\n\n  		this.radioName = true; // so that ractive.updateModel() knows what to do with this\n  	},\n\n  	getInitialValue: function () {\n  		if (this.element.getAttribute("checked")) {\n  			return this.element.getAttribute("value");\n  		}\n  	},\n\n  	render: function () {\n  		var node = this.element.node;\n\n  		node.name = "{{" + this.keypath.str + "}}";\n  		node.checked = this.root.viewmodel.get(this.keypath) == this.element.getAttribute("value");\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		if (node.attachEvent) {\n  			node.addEventListener("click", handleDomEvent, false);\n  		}\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("click", handleDomEvent, false);\n  	},\n\n  	getValue: function () {\n  		var node = this.element.node;\n  		return node._ractive ? node._ractive.value : node.value;\n  	},\n\n  	handleChange: function () {\n  		// If this <input> is the one that\'s checked, then the value of its\n  		// `name` keypath gets set to its value\n  		if (this.element.node.checked) {\n  			Binding_Binding.prototype.handleChange.call(this);\n  		}\n  	},\n\n  	rebound: function (oldKeypath, newKeypath) {\n  		var node;\n\n  		Binding_Binding.prototype.rebound.call(this, oldKeypath, newKeypath);\n\n  		if (node = this.element.node) {\n  			node.name = "{{" + this.keypath.str + "}}";\n  		}\n  	},\n\n  	unbind: function () {\n  		removeFromArray(this.siblings, this);\n  	}\n  });\n\n  var Binding_RadioNameBinding = RadioNameBinding;\n\n  var CheckboxNameBinding = Binding_Binding.extend({\n  	name: "name",\n\n  	getInitialValue: function () {\n  		// This only gets called once per group (of inputs that\n  		// share a name), because it only gets called if there\n  		// isn\'t an initial value. By the same token, we can make\n  		// a note of that fact that there was no initial value,\n  		// and populate it using any `checked` attributes that\n  		// exist (which users should avoid, but which we should\n  		// support anyway to avoid breaking expectations)\n  		this.noInitialValue = true;\n  		return [];\n  	},\n\n  	init: function () {\n  		var existingValue, bindingValue;\n\n  		this.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\n  		// Each input has a reference to an array containing it and its\n  		// siblings, as two-way binding depends on being able to ascertain\n  		// the status of all inputs within the group\n  		this.siblings = shared_getSiblings(this.root._guid, "checkboxes", this.keypath.str);\n  		this.siblings.push(this);\n\n  		if (this.noInitialValue) {\n  			this.siblings.noInitialValue = true;\n  		}\n\n  		// If no initial value was set, and this input is checked, we\n  		// update the model\n  		if (this.siblings.noInitialValue && this.element.getAttribute("checked")) {\n  			existingValue = this.root.viewmodel.get(this.keypath);\n  			bindingValue = this.element.getAttribute("value");\n\n  			existingValue.push(bindingValue);\n  		}\n  	},\n\n  	unbind: function () {\n  		removeFromArray(this.siblings, this);\n  	},\n\n  	render: function () {\n  		var node = this.element.node,\n  		    existingValue,\n  		    bindingValue;\n\n  		existingValue = this.root.viewmodel.get(this.keypath);\n  		bindingValue = this.element.getAttribute("value");\n\n  		if (isArray(existingValue)) {\n  			this.isChecked = arrayContains(existingValue, bindingValue);\n  		} else {\n  			this.isChecked = existingValue == bindingValue;\n  		}\n\n  		node.name = "{{" + this.keypath.str + "}}";\n  		node.checked = this.isChecked;\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		// in case of IE emergency, bind to click event as well\n  		if (node.attachEvent) {\n  			node.addEventListener("click", handleDomEvent, false);\n  		}\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("click", handleDomEvent, false);\n  	},\n\n  	changed: function () {\n  		var wasChecked = !!this.isChecked;\n  		this.isChecked = this.element.node.checked;\n  		return this.isChecked === wasChecked;\n  	},\n\n  	handleChange: function () {\n  		this.isChecked = this.element.node.checked;\n  		Binding_Binding.prototype.handleChange.call(this);\n  	},\n\n  	getValue: function () {\n  		return this.siblings.filter(isChecked).map(Binding_CheckboxNameBinding__getValue);\n  	}\n  });\n\n  function isChecked(binding) {\n  	return binding.isChecked;\n  }\n\n  function Binding_CheckboxNameBinding__getValue(binding) {\n  	return binding.element.getAttribute("value");\n  }\n\n  var Binding_CheckboxNameBinding = CheckboxNameBinding;\n\n  var CheckboxBinding = Binding_Binding.extend({\n  	name: "checked",\n\n  	render: function () {\n  		var node = this.element.node;\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		if (node.attachEvent) {\n  			node.addEventListener("click", handleDomEvent, false);\n  		}\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("click", handleDomEvent, false);\n  	},\n\n  	getValue: function () {\n  		return this.element.node.checked;\n  	}\n  });\n\n  var Binding_CheckboxBinding = CheckboxBinding;\n\n  var SelectBinding = Binding_Binding.extend({\n  	getInitialValue: function () {\n  		var options = this.element.options,\n  		    len,\n  		    i,\n  		    value,\n  		    optionWasSelected;\n\n  		if (this.element.getAttribute("value") !== undefined) {\n  			return;\n  		}\n\n  		i = len = options.length;\n\n  		if (!len) {\n  			return;\n  		}\n\n  		// take the final selected option...\n  		while (i--) {\n  			if (options[i].getAttribute("selected")) {\n  				value = options[i].getAttribute("value");\n  				optionWasSelected = true;\n  				break;\n  			}\n  		}\n\n  		// or the first non-disabled option, if none are selected\n  		if (!optionWasSelected) {\n  			while (++i < len) {\n  				if (!options[i].getAttribute("disabled")) {\n  					value = options[i].getAttribute("value");\n  					break;\n  				}\n  			}\n  		}\n\n  		// This is an optimisation (aka hack) that allows us to forgo some\n  		// other more expensive work\n  		if (value !== undefined) {\n  			this.element.attributes.value.value = value;\n  		}\n\n  		return value;\n  	},\n\n  	render: function () {\n  		this.element.node.addEventListener("change", handleDomEvent, false);\n  	},\n\n  	unrender: function () {\n  		this.element.node.removeEventListener("change", handleDomEvent, false);\n  	},\n\n  	// TODO this method is an anomaly... is it necessary?\n  	setValue: function (value) {\n  		this.root.viewmodel.set(this.keypath, value);\n  	},\n\n  	getValue: function () {\n  		var options, i, len, option, optionValue;\n\n  		options = this.element.node.options;\n  		len = options.length;\n\n  		for (i = 0; i < len; i += 1) {\n  			option = options[i];\n\n  			if (options[i].selected) {\n  				optionValue = option._ractive ? option._ractive.value : option.value;\n  				return optionValue;\n  			}\n  		}\n  	},\n\n  	forceUpdate: function () {\n  		var _this = this;\n\n  		var value = this.getValue();\n\n  		if (value !== undefined) {\n  			this.attribute.locked = true;\n  			global_runloop.scheduleTask(function () {\n  				return _this.attribute.locked = false;\n  			});\n  			this.root.viewmodel.set(this.keypath, value);\n  		}\n  	}\n  });\n\n  var Binding_SelectBinding = SelectBinding;\n\n  var MultipleSelectBinding = Binding_SelectBinding.extend({\n  	getInitialValue: function () {\n  		return this.element.options.filter(function (option) {\n  			return option.getAttribute("selected");\n  		}).map(function (option) {\n  			return option.getAttribute("value");\n  		});\n  	},\n\n  	render: function () {\n  		var valueFromModel;\n\n  		this.element.node.addEventListener("change", handleDomEvent, false);\n\n  		valueFromModel = this.root.viewmodel.get(this.keypath);\n\n  		if (valueFromModel === undefined) {\n  			// get value from DOM, if possible\n  			this.handleChange();\n  		}\n  	},\n\n  	unrender: function () {\n  		this.element.node.removeEventListener("change", handleDomEvent, false);\n  	},\n\n  	setValue: function () {\n  		throw new Error("TODO not implemented yet");\n  	},\n\n  	getValue: function () {\n  		var selectedValues, options, i, len, option, optionValue;\n\n  		selectedValues = [];\n  		options = this.element.node.options;\n  		len = options.length;\n\n  		for (i = 0; i < len; i += 1) {\n  			option = options[i];\n\n  			if (option.selected) {\n  				optionValue = option._ractive ? option._ractive.value : option.value;\n  				selectedValues.push(optionValue);\n  			}\n  		}\n\n  		return selectedValues;\n  	},\n\n  	handleChange: function () {\n  		var attribute, previousValue, value;\n\n  		attribute = this.attribute;\n  		previousValue = attribute.value;\n\n  		value = this.getValue();\n\n  		if (previousValue === undefined || !arrayContentsMatch(value, previousValue)) {\n  			Binding_SelectBinding.prototype.handleChange.call(this);\n  		}\n\n  		return this;\n  	},\n\n  	forceUpdate: function () {\n  		var _this = this;\n\n  		var value = this.getValue();\n\n  		if (value !== undefined) {\n  			this.attribute.locked = true;\n  			global_runloop.scheduleTask(function () {\n  				return _this.attribute.locked = false;\n  			});\n  			this.root.viewmodel.set(this.keypath, value);\n  		}\n  	},\n\n  	updateModel: function () {\n  		if (this.attribute.value === undefined || !this.attribute.value.length) {\n  			this.root.viewmodel.set(this.keypath, this.initialValue);\n  		}\n  	}\n  });\n\n  var Binding_MultipleSelectBinding = MultipleSelectBinding;\n\n  var FileListBinding = Binding_Binding.extend({\n  	render: function () {\n  		this.element.node.addEventListener("change", handleDomEvent, false);\n  	},\n\n  	unrender: function () {\n  		this.element.node.removeEventListener("change", handleDomEvent, false);\n  	},\n\n  	getValue: function () {\n  		return this.element.node.files;\n  	}\n  });\n\n  var Binding_FileListBinding = FileListBinding;\n\n  var GenericBinding;\n\n  GenericBinding = Binding_Binding.extend({\n  	getInitialValue: function () {\n  		return "";\n  	},\n\n  	getValue: function () {\n  		return this.element.node.value;\n  	},\n\n  	render: function () {\n  		var node = this.element.node,\n  		    lazy,\n  		    timeout = false;\n  		this.rendered = true;\n\n  		// any lazy setting for this element overrides the root\n  		// if the value is a number, it\'s a timeout\n  		lazy = this.root.lazy;\n  		if (this.element.lazy === true) {\n  			lazy = true;\n  		} else if (this.element.lazy === false) {\n  			lazy = false;\n  		} else if (is__isNumeric(this.element.lazy)) {\n  			lazy = false;\n  			timeout = +this.element.lazy;\n  		} else if (is__isNumeric(lazy || "")) {\n  			timeout = +lazy;\n  			lazy = false;\n\n  			// make sure the timeout is available to the handler\n  			this.element.lazy = timeout;\n  		}\n\n  		this.handler = timeout ? handleDelay : handleDomEvent;\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		if (!lazy) {\n  			node.addEventListener("input", this.handler, false);\n\n  			if (node.attachEvent) {\n  				node.addEventListener("keyup", this.handler, false);\n  			}\n  		}\n\n  		node.addEventListener("blur", handleBlur, false);\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n  		this.rendered = false;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("input", this.handler, false);\n  		node.removeEventListener("keyup", this.handler, false);\n  		node.removeEventListener("blur", handleBlur, false);\n  	}\n  });\n\n  var Binding_GenericBinding = GenericBinding;\n\n  function handleBlur() {\n  	var value;\n\n  	handleDomEvent.call(this);\n\n  	value = this._ractive.root.viewmodel.get(this._ractive.binding.keypath);\n  	this.value = value == undefined ? "" : value;\n  }\n\n  function handleDelay() {\n  	var binding = this._ractive.binding,\n  	    el = this;\n\n  	if (!!binding._timeout) clearTimeout(binding._timeout);\n\n  	binding._timeout = setTimeout(function () {\n  		if (binding.rendered) handleDomEvent.call(el);\n  		binding._timeout = undefined;\n  	}, binding.element.lazy);\n  }\n\n  var NumericBinding = Binding_GenericBinding.extend({\n  	getInitialValue: function () {\n  		return undefined;\n  	},\n\n  	getValue: function () {\n  		var value = parseFloat(this.element.node.value);\n  		return isNaN(value) ? undefined : value;\n  	}\n  });\n\n  var init_createTwowayBinding = createTwowayBinding;\n\n  function createTwowayBinding(element) {\n  	var attributes = element.attributes,\n  	    type,\n  	    Binding,\n  	    bindName,\n  	    bindChecked,\n  	    binding;\n\n  	// if this is a late binding, and there\'s already one, it\n  	// needs to be torn down\n  	if (element.binding) {\n  		element.binding.teardown();\n  		element.binding = null;\n  	}\n\n  	// contenteditable\n  	if (\n  	// if the contenteditable attribute is true or is bindable and may thus become true\n  	(element.getAttribute("contenteditable") || !!attributes.contenteditable && isBindable(attributes.contenteditable)) && isBindable(attributes.value)) {\n  		Binding = Binding_ContentEditableBinding;\n  	}\n\n  	// <input>\n  	else if (element.name === "input") {\n  		type = element.getAttribute("type");\n\n  		if (type === "radio" || type === "checkbox") {\n  			bindName = isBindable(attributes.name);\n  			bindChecked = isBindable(attributes.checked);\n\n  			// we can either bind the name attribute, or the checked attribute - not both\n  			if (bindName && bindChecked) {\n  				warnIfDebug("A radio input can have two-way binding on its name attribute, or its checked attribute - not both", { ractive: element.root });\n  			}\n\n  			if (bindName) {\n  				Binding = type === "radio" ? Binding_RadioNameBinding : Binding_CheckboxNameBinding;\n  			} else if (bindChecked) {\n  				Binding = type === "radio" ? Binding_RadioBinding : Binding_CheckboxBinding;\n  			}\n  		} else if (type === "file" && isBindable(attributes.value)) {\n  			Binding = Binding_FileListBinding;\n  		} else if (isBindable(attributes.value)) {\n  			Binding = type === "number" || type === "range" ? NumericBinding : Binding_GenericBinding;\n  		}\n  	}\n\n  	// <select>\n  	else if (element.name === "select" && isBindable(attributes.value)) {\n  		Binding = element.getAttribute("multiple") ? Binding_MultipleSelectBinding : Binding_SelectBinding;\n  	}\n\n  	// <textarea>\n  	else if (element.name === "textarea" && isBindable(attributes.value)) {\n  		Binding = Binding_GenericBinding;\n  	}\n\n  	if (Binding && (binding = new Binding(element)) && binding.keypath) {\n  		return binding;\n  	}\n  }\n\n  function isBindable(attribute) {\n  	return attribute && attribute.isBindable;\n  }\n\n  // and this element also has a value attribute to bind\n\n  var EventHandler_prototype_bubble = EventHandler$bubble;\n\n  function EventHandler$bubble() {\n  	var hasAction = this.getAction();\n\n  	if (hasAction && !this.hasListener) {\n  		this.listen();\n  	} else if (!hasAction && this.hasListener) {\n  		this.unrender();\n  	}\n  }\n\n  // This function may be overwritten, if the event directive\n  // includes parameters\n  var EventHandler_prototype_fire = EventHandler$fire;\n  function EventHandler$fire(event) {\n  	shared_fireEvent(this.root, this.getAction(), { event: event });\n  }\n\n  var getAction = EventHandler$getAction;\n\n  function EventHandler$getAction() {\n  	return this.action.toString().trim();\n  }\n\n  var EventHandler_prototype_init = EventHandler$init;\n\n  var eventPattern = /^event(?:\\.(.+))?/;\n  function EventHandler$init(element, name, template) {\n  	var _this = this;\n\n  	var action, refs, ractive;\n\n  	this.element = element;\n  	this.root = element.root;\n  	this.parentFragment = element.parentFragment;\n  	this.name = name;\n\n  	if (name.indexOf("*") !== -1) {\n  		fatal("Only component proxy-events may contain \\"*\\" wildcards, <%s on-%s=\\"...\\"/> is not valid", element.name, name);\n  		this.invalid = true;\n  	}\n\n  	if (template.m) {\n  		refs = template.a.r;\n\n  		// This is a method call\n  		this.method = template.m;\n  		this.keypaths = [];\n  		this.fn = shared_getFunctionFromString(template.a.s, refs.length);\n\n  		this.parentFragment = element.parentFragment;\n  		ractive = this.root;\n\n  		// Create resolvers for each reference\n  		this.refResolvers = [];\n  		refs.forEach(function (ref, i) {\n  			var match = undefined;\n\n  			// special case - the `event` object\n  			if (match = eventPattern.exec(ref)) {\n  				_this.keypaths[i] = {\n  					eventObject: true,\n  					refinements: match[1] ? match[1].split(".") : []\n  				};\n  			} else {\n  				_this.refResolvers.push(Resolvers_createReferenceResolver(_this, ref, function (keypath) {\n  					return _this.resolve(i, keypath);\n  				}));\n  			}\n  		});\n\n  		this.fire = fireMethodCall;\n  	} else {\n  		// Get action (\'foo\' in \'on-click=\'foo\')\n  		action = template.n || template;\n  		if (typeof action !== "string") {\n  			action = new virtualdom_Fragment({\n  				template: action,\n  				root: this.root,\n  				owner: this\n  			});\n  		}\n\n  		this.action = action;\n\n  		// Get parameters\n  		if (template.d) {\n  			this.dynamicParams = new virtualdom_Fragment({\n  				template: template.d,\n  				root: this.root,\n  				owner: this.element\n  			});\n\n  			this.fire = fireEventWithDynamicParams;\n  		} else if (template.a) {\n  			this.params = template.a;\n  			this.fire = fireEventWithParams;\n  		}\n  	}\n  }\n\n  function fireMethodCall(event) {\n  	var ractive, values, args;\n\n  	ractive = this.root;\n\n  	if (typeof ractive[this.method] !== "function") {\n  		throw new Error("Attempted to call a non-existent method (\\"" + this.method + "\\")");\n  	}\n\n  	values = this.keypaths.map(function (keypath) {\n  		var value, len, i;\n\n  		if (keypath === undefined) {\n  			// not yet resolved\n  			return undefined;\n  		}\n\n  		// TODO the refinements stuff would be better handled at parse time\n  		if (keypath.eventObject) {\n  			value = event;\n\n  			if (len = keypath.refinements.length) {\n  				for (i = 0; i < len; i += 1) {\n  					value = value[keypath.refinements[i]];\n  				}\n  			}\n  		} else {\n  			value = ractive.viewmodel.get(keypath);\n  		}\n\n  		return value;\n  	});\n\n  	shared_eventStack.enqueue(ractive, event);\n\n  	args = this.fn.apply(null, values);\n  	ractive[this.method].apply(ractive, args);\n\n  	shared_eventStack.dequeue(ractive);\n  }\n\n  function fireEventWithParams(event) {\n  	shared_fireEvent(this.root, this.getAction(), { event: event, args: this.params });\n  }\n\n  function fireEventWithDynamicParams(event) {\n  	var args = this.dynamicParams.getArgsList();\n\n  	// need to strip [] from ends if a string!\n  	if (typeof args === "string") {\n  		args = args.substr(1, args.length - 2);\n  	}\n\n  	shared_fireEvent(this.root, this.getAction(), { event: event, args: args });\n  }\n\n  var shared_genericHandler = genericHandler;\n  function genericHandler(event) {\n  	var storage,\n  	    handler,\n  	    indices,\n  	    index = {};\n\n  	storage = this._ractive;\n  	handler = storage.events[event.type];\n\n  	if (indices = Resolvers_findIndexRefs(handler.element.parentFragment)) {\n  		index = Resolvers_findIndexRefs.resolve(indices);\n  	}\n\n  	handler.fire({\n  		node: this,\n  		original: event,\n  		index: index,\n  		keypath: storage.keypath.str,\n  		context: storage.root.viewmodel.get(storage.keypath)\n  	});\n  }\n\n  var listen = EventHandler$listen;\n\n  var customHandlers = {},\n      touchEvents = {\n  	touchstart: true,\n  	touchmove: true,\n  	touchend: true,\n  	touchcancel: true,\n  	//not w3c, but supported in some browsers\n  	touchleave: true\n  };\n  function EventHandler$listen() {\n  	var definition,\n  	    name = this.name;\n\n  	if (this.invalid) {\n  		return;\n  	}\n\n  	if (definition = findInViewHierarchy("events", this.root, name)) {\n  		this.custom = definition(this.node, getCustomHandler(name));\n  	} else {\n  		// Looks like we\'re dealing with a standard DOM event... but let\'s check\n  		if (!("on" + name in this.node) && !(window && "on" + name in window) && !isJsdom) {\n\n  			// okay to use touch events if this browser doesn\'t support them\n  			if (!touchEvents[name]) {\n  				warnOnceIfDebug(missingPlugin(name, "event"), { node: this.node });\n  			}\n\n  			return;\n  		}\n\n  		this.node.addEventListener(name, shared_genericHandler, false);\n  	}\n\n  	this.hasListener = true;\n  }\n\n  function getCustomHandler(name) {\n  	if (!customHandlers[name]) {\n  		customHandlers[name] = function (event) {\n  			var storage = event.node._ractive;\n\n  			event.index = storage.index;\n  			event.keypath = storage.keypath.str;\n  			event.context = storage.root.viewmodel.get(storage.keypath);\n\n  			storage.events[name].fire(event);\n  		};\n  	}\n\n  	return customHandlers[name];\n  }\n\n  var EventHandler_prototype_rebind = EventHandler$rebind;\n\n  function EventHandler$rebind(oldKeypath, newKeypath) {\n  	var fragment;\n  	if (this.method) {\n  		fragment = this.element.parentFragment;\n  		this.refResolvers.forEach(rebind);\n\n  		return;\n  	}\n\n  	if (typeof this.action !== "string") {\n  		rebind(this.action);\n  	}\n\n  	if (this.dynamicParams) {\n  		rebind(this.dynamicParams);\n  	}\n\n  	function rebind(thing) {\n  		thing && thing.rebind(oldKeypath, newKeypath);\n  	}\n  }\n\n  var EventHandler_prototype_render = EventHandler$render;\n\n  function EventHandler$render() {\n  	this.node = this.element.node;\n  	// store this on the node itself, so it can be retrieved by a\n  	// universal handler\n  	this.node._ractive.events[this.name] = this;\n\n  	if (this.method || this.getAction()) {\n  		this.listen();\n  	}\n  }\n\n  var prototype_resolve = EventHandler$resolve;\n\n  function EventHandler$resolve(index, keypath) {\n  	this.keypaths[index] = keypath;\n  }\n\n  var EventHandler_prototype_unbind = EventHandler$unbind;\n  function EventHandler$unbind() {\n  	if (this.method) {\n  		this.refResolvers.forEach(methodCallers__unbind);\n  		return;\n  	}\n\n  	// Tear down dynamic name\n  	if (typeof this.action !== "string") {\n  		this.action.unbind();\n  	}\n\n  	// Tear down dynamic parameters\n  	if (this.dynamicParams) {\n  		this.dynamicParams.unbind();\n  	}\n  }\n\n  var EventHandler_prototype_unrender = EventHandler$unrender;\n  function EventHandler$unrender() {\n\n  	if (this.custom) {\n  		this.custom.teardown();\n  	} else {\n  		this.node.removeEventListener(this.name, shared_genericHandler, false);\n  	}\n\n  	this.hasListener = false;\n  }\n\n  var EventHandler = function (element, name, template) {\n  	this.init(element, name, template);\n  };\n\n  EventHandler.prototype = {\n  	bubble: EventHandler_prototype_bubble,\n  	fire: EventHandler_prototype_fire,\n  	getAction: getAction,\n  	init: EventHandler_prototype_init,\n  	listen: listen,\n  	rebind: EventHandler_prototype_rebind,\n  	render: EventHandler_prototype_render,\n  	resolve: prototype_resolve,\n  	unbind: EventHandler_prototype_unbind,\n  	unrender: EventHandler_prototype_unrender\n  };\n\n  var _EventHandler = EventHandler;\n\n  var createEventHandlers = function (element, template) {\n  	var i,\n  	    name,\n  	    names,\n  	    handler,\n  	    result = [];\n\n  	for (name in template) {\n  		if (template.hasOwnProperty(name)) {\n  			names = name.split("-");\n  			i = names.length;\n\n  			while (i--) {\n  				handler = new _EventHandler(element, names[i], template[name]);\n  				result.push(handler);\n  			}\n  		}\n  	}\n\n  	return result;\n  };\n\n  var Decorator = function (element, template) {\n  	var self = this,\n  	    ractive,\n  	    name,\n  	    fragment;\n\n  	this.element = element;\n  	this.root = ractive = element.root;\n\n  	name = template.n || template;\n\n  	if (typeof name !== "string") {\n  		fragment = new virtualdom_Fragment({\n  			template: name,\n  			root: ractive,\n  			owner: element\n  		});\n\n  		name = fragment.toString();\n  		fragment.unbind();\n\n  		if (name === "") {\n  			// empty string okay, just no decorator\n  			return;\n  		}\n  	}\n\n  	if (template.a) {\n  		this.params = template.a;\n  	} else if (template.d) {\n  		this.fragment = new virtualdom_Fragment({\n  			template: template.d,\n  			root: ractive,\n  			owner: element\n  		});\n\n  		this.params = this.fragment.getArgsList();\n\n  		this.fragment.bubble = function () {\n  			this.dirtyArgs = this.dirtyValue = true;\n  			self.params = this.getArgsList();\n\n  			if (self.ready) {\n  				self.update();\n  			}\n  		};\n  	}\n\n  	this.fn = findInViewHierarchy("decorators", ractive, name);\n\n  	if (!this.fn) {\n  		fatal(missingPlugin(name, "decorator"));\n  	}\n  };\n\n  Decorator.prototype = {\n  	init: function () {\n  		var node, result, args;\n\n  		node = this.element.node;\n\n  		if (this.params) {\n  			args = [node].concat(this.params);\n  			result = this.fn.apply(this.root, args);\n  		} else {\n  			result = this.fn.call(this.root, node);\n  		}\n\n  		if (!result || !result.teardown) {\n  			throw new Error("Decorator definition must return an object with a teardown method");\n  		}\n\n  		// TODO does this make sense?\n  		this.actual = result;\n  		this.ready = true;\n  	},\n\n  	update: function () {\n  		if (this.actual.update) {\n  			this.actual.update.apply(this.root, this.params);\n  		} else {\n  			this.actual.teardown(true);\n  			this.init();\n  		}\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		if (this.fragment) {\n  			this.fragment.rebind(oldKeypath, newKeypath);\n  		}\n  	},\n\n  	teardown: function (updating) {\n  		this.torndown = true;\n  		if (this.ready) {\n  			this.actual.teardown();\n  		}\n\n  		if (!updating && this.fragment) {\n  			this.fragment.unbind();\n  		}\n  	}\n  };\n\n  var _Decorator = Decorator;\n\n  function select__bubble() {\n  	var _this = this;\n\n  	if (!this.dirty) {\n  		this.dirty = true;\n\n  		global_runloop.scheduleTask(function () {\n  			sync(_this);\n  			_this.dirty = false;\n  		});\n  	}\n\n  	this.parentFragment.bubble(); // default behaviour\n  }\n\n  function sync(selectElement) {\n  	var selectNode, selectValue, isMultiple, options, optionWasSelected;\n\n  	selectNode = selectElement.node;\n\n  	if (!selectNode) {\n  		return;\n  	}\n\n  	options = toArray(selectNode.options);\n\n  	selectValue = selectElement.getAttribute("value");\n  	isMultiple = selectElement.getAttribute("multiple");\n\n  	// If the <select> has a specified value, that should override\n  	// these options\n  	if (selectValue !== undefined) {\n  		options.forEach(function (o) {\n  			var optionValue, shouldSelect;\n\n  			optionValue = o._ractive ? o._ractive.value : o.value;\n  			shouldSelect = isMultiple ? valueContains(selectValue, optionValue) : selectValue == optionValue;\n\n  			if (shouldSelect) {\n  				optionWasSelected = true;\n  			}\n\n  			o.selected = shouldSelect;\n  		});\n\n  		if (!optionWasSelected) {\n  			if (options[0]) {\n  				options[0].selected = true;\n  			}\n\n  			if (selectElement.binding) {\n  				selectElement.binding.forceUpdate();\n  			}\n  		}\n  	}\n\n  	// Otherwise the value should be initialised according to which\n  	// <option> element is selected, if twoway binding is in effect\n  	else if (selectElement.binding) {\n  		selectElement.binding.forceUpdate();\n  	}\n  }\n\n  function valueContains(selectValue, optionValue) {\n  	var i = selectValue.length;\n  	while (i--) {\n  		if (selectValue[i] == optionValue) {\n  			return true;\n  		}\n  	}\n  }\n\n  function special_option__init(option, template) {\n  	option.select = findParentSelect(option.parent);\n\n  	// we might be inside a <datalist> element\n  	if (!option.select) {\n  		return;\n  	}\n\n  	option.select.options.push(option);\n\n  	// If the value attribute is missing, use the element\'s content\n  	if (!template.a) {\n  		template.a = {};\n  	}\n\n  	// ...as long as it isn\'t disabled\n  	if (template.a.value === undefined && !template.a.hasOwnProperty("disabled")) {\n  		template.a.value = template.f;\n  	}\n\n  	// If there is a `selected` attribute, but the <select>\n  	// already has a value, delete it\n  	if ("selected" in template.a && option.select.getAttribute("value") !== undefined) {\n  		delete template.a.selected;\n  	}\n  }\n\n  function special_option__unbind(option) {\n  	if (option.select) {\n  		removeFromArray(option.select.options, option);\n  	}\n  }\n\n  function findParentSelect(element) {\n  	if (!element) {\n  		return;\n  	}\n\n  	do {\n  		if (element.name === "select") {\n  			return element;\n  		}\n  	} while (element = element.parent);\n  }\n\n  var Element_prototype_init = Element$init;\n  function Element$init(options) {\n  	var parentFragment, template, ractive, binding, bindings, twoway, bindingAttrs;\n\n  	this.type = ELEMENT;\n\n  	// stuff we\'ll need later\n  	parentFragment = this.parentFragment = options.parentFragment;\n  	template = this.template = options.template;\n\n  	this.parent = options.pElement || parentFragment.pElement;\n\n  	this.root = ractive = parentFragment.root;\n  	this.index = options.index;\n  	this.key = options.key;\n\n  	this.name = enforceCase(template.e);\n\n  	// Special case - <option> elements\n  	if (this.name === "option") {\n  		special_option__init(this, template);\n  	}\n\n  	// Special case - <select> elements\n  	if (this.name === "select") {\n  		this.options = [];\n  		this.bubble = select__bubble; // TODO this is a kludge\n  	}\n\n  	// Special case - <form> elements\n  	if (this.name === "form") {\n  		this.formBindings = [];\n  	}\n\n  	// handle binding attributes first (twoway, lazy)\n  	bindingAttrs = processBindingAttributes(this, template);\n\n  	// create attributes\n  	this.attributes = createAttributes(this, template.a);\n  	this.conditionalAttributes = createConditionalAttributes(this, template.m);\n\n  	// append children, if there are any\n  	if (template.f) {\n  		this.fragment = new virtualdom_Fragment({\n  			template: template.f,\n  			root: ractive,\n  			owner: this,\n  			pElement: this,\n  			cssIds: null\n  		});\n  	}\n\n  	// the element setting should override the ractive setting\n  	twoway = ractive.twoway;\n  	if (bindingAttrs.twoway === false) twoway = false;else if (bindingAttrs.twoway === true) twoway = true;\n\n  	this.twoway = twoway;\n  	this.lazy = bindingAttrs.lazy;\n\n  	// create twoway binding\n  	if (twoway && (binding = init_createTwowayBinding(this, template.a))) {\n  		this.binding = binding;\n\n  		// register this with the root, so that we can do ractive.updateModel()\n  		bindings = this.root._twowayBindings[binding.keypath.str] || (this.root._twowayBindings[binding.keypath.str] = []);\n  		bindings.push(binding);\n  	}\n\n  	// create event proxies\n  	if (template.v) {\n  		this.eventHandlers = createEventHandlers(this, template.v);\n  	}\n\n  	// create decorator\n  	if (template.o) {\n  		this.decorator = new _Decorator(this, template.o);\n  	}\n\n  	// create transitions\n  	this.intro = template.t0 || template.t1;\n  	this.outro = template.t0 || template.t2;\n  }\n\n  var Element_prototype_rebind = Element$rebind;\n  function Element$rebind(oldKeypath, newKeypath) {\n  	var i, storage, liveQueries, ractive;\n\n  	if (this.attributes) {\n  		this.attributes.forEach(rebind);\n  	}\n\n  	if (this.conditionalAttributes) {\n  		this.conditionalAttributes.forEach(rebind);\n  	}\n\n  	if (this.eventHandlers) {\n  		this.eventHandlers.forEach(rebind);\n  	}\n\n  	if (this.decorator) {\n  		rebind(this.decorator);\n  	}\n\n  	// rebind children\n  	if (this.fragment) {\n  		rebind(this.fragment);\n  	}\n\n  	// Update live queries, if necessary\n  	if (liveQueries = this.liveQueries) {\n  		ractive = this.root;\n\n  		i = liveQueries.length;\n  		while (i--) {\n  			liveQueries[i]._makeDirty();\n  		}\n  	}\n\n  	if (this.node && (storage = this.node._ractive)) {\n\n  		// adjust keypath if needed\n  		assignNewKeypath(storage, "keypath", oldKeypath, newKeypath);\n  	}\n\n  	function rebind(thing) {\n  		thing.rebind(oldKeypath, newKeypath);\n  	}\n  }\n\n  function special_img__render(img) {\n  	var loadHandler;\n\n  	// if this is an <img>, and we\'re in a crap browser, we may need to prevent it\n  	// from overriding width and height when it loads the src\n  	if (img.attributes.width || img.attributes.height) {\n  		img.node.addEventListener("load", loadHandler = function () {\n  			var width = img.getAttribute("width"),\n  			    height = img.getAttribute("height");\n\n  			if (width !== undefined) {\n  				img.node.setAttribute("width", width);\n  			}\n\n  			if (height !== undefined) {\n  				img.node.setAttribute("height", height);\n  			}\n\n  			img.node.removeEventListener("load", loadHandler, false);\n  		}, false);\n  	}\n  }\n\n  function form__render(element) {\n  	element.node.addEventListener("reset", handleReset, false);\n  }\n\n  function form__unrender(element) {\n  	element.node.removeEventListener("reset", handleReset, false);\n  }\n\n  function handleReset() {\n  	var element = this._ractive.proxy;\n\n  	global_runloop.start();\n  	element.formBindings.forEach(updateModel);\n  	global_runloop.end();\n  }\n\n  function updateModel(binding) {\n  	binding.root.viewmodel.set(binding.keypath, binding.resetValue);\n  }\n\n  var Transition_prototype_init = Transition$init;\n  function Transition$init(element, template, isIntro) {\n  	var ractive, name, fragment;\n\n  	this.element = element;\n  	this.root = ractive = element.root;\n  	this.isIntro = isIntro;\n\n  	name = template.n || template;\n\n  	if (typeof name !== "string") {\n  		fragment = new virtualdom_Fragment({\n  			template: name,\n  			root: ractive,\n  			owner: element\n  		});\n\n  		name = fragment.toString();\n  		fragment.unbind();\n\n  		if (name === "") {\n  			// empty string okay, just no transition\n  			return;\n  		}\n  	}\n\n  	this.name = name;\n\n  	if (template.a) {\n  		this.params = template.a;\n  	} else if (template.d) {\n  		// TODO is there a way to interpret dynamic arguments without all the\n  		// \'dependency thrashing\'?\n  		fragment = new virtualdom_Fragment({\n  			template: template.d,\n  			root: ractive,\n  			owner: element\n  		});\n\n  		this.params = fragment.getArgsList();\n  		fragment.unbind();\n  	}\n\n  	this._fn = findInViewHierarchy("transitions", ractive, name);\n\n  	if (!this._fn) {\n  		warnOnceIfDebug(missingPlugin(name, "transition"), { ractive: this.root });\n  	}\n  }\n\n  var camelCase = function (hyphenatedStr) {\n  	return hyphenatedStr.replace(/-([a-zA-Z])/g, function (match, $1) {\n  		return $1.toUpperCase();\n  	});\n  };\n\n  var helpers_prefix__prefix, prefixCache, helpers_prefix__testStyle;\n\n  if (!isClient) {\n  	helpers_prefix__prefix = null;\n  } else {\n  	prefixCache = {};\n  	helpers_prefix__testStyle = createElement("div").style;\n\n  	helpers_prefix__prefix = function (prop) {\n  		var i, vendor, capped;\n\n  		prop = camelCase(prop);\n\n  		if (!prefixCache[prop]) {\n  			if (helpers_prefix__testStyle[prop] !== undefined) {\n  				prefixCache[prop] = prop;\n  			} else {\n  				// test vendors...\n  				capped = prop.charAt(0).toUpperCase() + prop.substring(1);\n\n  				i = vendors.length;\n  				while (i--) {\n  					vendor = vendors[i];\n  					if (helpers_prefix__testStyle[vendor + capped] !== undefined) {\n  						prefixCache[prop] = vendor + capped;\n  						break;\n  					}\n  				}\n  			}\n  		}\n\n  		return prefixCache[prop];\n  	};\n  }\n\n  var helpers_prefix = helpers_prefix__prefix;\n\n  var getStyle, prototype_getStyle__getComputedStyle;\n\n  if (!isClient) {\n  	getStyle = null;\n  } else {\n  	prototype_getStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n  	getStyle = function (props) {\n  		var computedStyle, styles, i, prop, value;\n\n  		computedStyle = prototype_getStyle__getComputedStyle(this.node);\n\n  		if (typeof props === "string") {\n  			value = computedStyle[helpers_prefix(props)];\n  			if (value === "0px") {\n  				value = 0;\n  			}\n  			return value;\n  		}\n\n  		if (!isArray(props)) {\n  			throw new Error("Transition$getStyle must be passed a string, or an array of strings representing CSS properties");\n  		}\n\n  		styles = {};\n\n  		i = props.length;\n  		while (i--) {\n  			prop = props[i];\n  			value = computedStyle[helpers_prefix(prop)];\n  			if (value === "0px") {\n  				value = 0;\n  			}\n  			styles[prop] = value;\n  		}\n\n  		return styles;\n  	};\n  }\n\n  var prototype_getStyle = getStyle;\n\n  var setStyle = function (style, value) {\n  	var prop;\n\n  	if (typeof style === "string") {\n  		this.node.style[helpers_prefix(style)] = value;\n  	} else {\n  		for (prop in style) {\n  			if (style.hasOwnProperty(prop)) {\n  				this.node.style[helpers_prefix(prop)] = style[prop];\n  			}\n  		}\n  	}\n\n  	return this;\n  };\n\n  var Ticker = function (options) {\n  	var easing;\n\n  	this.duration = options.duration;\n  	this.step = options.step;\n  	this.complete = options.complete;\n\n  	// easing\n  	if (typeof options.easing === "string") {\n  		easing = options.root.easing[options.easing];\n\n  		if (!easing) {\n  			warnOnceIfDebug(missingPlugin(options.easing, "easing"));\n  			easing = linear;\n  		}\n  	} else if (typeof options.easing === "function") {\n  		easing = options.easing;\n  	} else {\n  		easing = linear;\n  	}\n\n  	this.easing = easing;\n\n  	this.start = utils_getTime();\n  	this.end = this.start + this.duration;\n\n  	this.running = true;\n  	shared_animations.add(this);\n  };\n\n  Ticker.prototype = {\n  	tick: function (now) {\n  		var elapsed, eased;\n\n  		if (!this.running) {\n  			return false;\n  		}\n\n  		if (now > this.end) {\n  			if (this.step) {\n  				this.step(1);\n  			}\n\n  			if (this.complete) {\n  				this.complete(1);\n  			}\n\n  			return false;\n  		}\n\n  		elapsed = now - this.start;\n  		eased = this.easing(elapsed / this.duration);\n\n  		if (this.step) {\n  			this.step(eased);\n  		}\n\n  		return true;\n  	},\n\n  	stop: function () {\n  		if (this.abort) {\n  			this.abort();\n  		}\n\n  		this.running = false;\n  	}\n  };\n\n  var shared_Ticker = Ticker;\n  function linear(t) {\n  	return t;\n  }\n\n  var unprefixPattern = new RegExp("^-(?:" + vendors.join("|") + ")-");\n\n  var unprefix = function (prop) {\n  	return prop.replace(unprefixPattern, "");\n  };\n\n  var vendorPattern = new RegExp("^(?:" + vendors.join("|") + ")([A-Z])");\n\n  var hyphenate = function (str) {\n  	var hyphenated;\n\n  	if (!str) {\n  		return ""; // edge case\n  	}\n\n  	if (vendorPattern.test(str)) {\n  		str = "-" + str;\n  	}\n\n  	hyphenated = str.replace(/[A-Z]/g, function (match) {\n  		return "-" + match.toLowerCase();\n  	});\n\n  	return hyphenated;\n  };\n\n  var createTransitions,\n      animateStyle_createTransitions__testStyle,\n      TRANSITION,\n      TRANSITIONEND,\n      CSS_TRANSITIONS_ENABLED,\n      TRANSITION_DURATION,\n      TRANSITION_PROPERTY,\n      TRANSITION_TIMING_FUNCTION,\n      canUseCssTransitions = {},\n      cannotUseCssTransitions = {};\n\n  if (!isClient) {\n  	createTransitions = null;\n  } else {\n  	animateStyle_createTransitions__testStyle = createElement("div").style;\n\n  	// determine some facts about our environment\n  	(function () {\n  		if (animateStyle_createTransitions__testStyle.transition !== undefined) {\n  			TRANSITION = "transition";\n  			TRANSITIONEND = "transitionend";\n  			CSS_TRANSITIONS_ENABLED = true;\n  		} else if (animateStyle_createTransitions__testStyle.webkitTransition !== undefined) {\n  			TRANSITION = "webkitTransition";\n  			TRANSITIONEND = "webkitTransitionEnd";\n  			CSS_TRANSITIONS_ENABLED = true;\n  		} else {\n  			CSS_TRANSITIONS_ENABLED = false;\n  		}\n  	})();\n\n  	if (TRANSITION) {\n  		TRANSITION_DURATION = TRANSITION + "Duration";\n  		TRANSITION_PROPERTY = TRANSITION + "Property";\n  		TRANSITION_TIMING_FUNCTION = TRANSITION + "TimingFunction";\n  	}\n\n  	createTransitions = function (t, to, options, changedProperties, resolve) {\n\n  		// Wait a beat (otherwise the target styles will be applied immediately)\n  		// TODO use a fastdom-style mechanism?\n  		setTimeout(function () {\n\n  			var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;\n\n  			checkComplete = function () {\n  				if (jsTransitionsComplete && cssTransitionsComplete) {\n  					// will changes to events and fire have an unexpected consequence here?\n  					t.root.fire(t.name + ":end", t.node, t.isIntro);\n  					resolve();\n  				}\n  			};\n\n  			// this is used to keep track of which elements can use CSS to animate\n  			// which properties\n  			hashPrefix = (t.node.namespaceURI || "") + t.node.tagName;\n\n  			t.node.style[TRANSITION_PROPERTY] = changedProperties.map(helpers_prefix).map(hyphenate).join(",");\n  			t.node.style[TRANSITION_TIMING_FUNCTION] = hyphenate(options.easing || "linear");\n  			t.node.style[TRANSITION_DURATION] = options.duration / 1000 + "s";\n\n  			transitionEndHandler = function (event) {\n  				var index;\n\n  				index = changedProperties.indexOf(camelCase(unprefix(event.propertyName)));\n  				if (index !== -1) {\n  					changedProperties.splice(index, 1);\n  				}\n\n  				if (changedProperties.length) {\n  					// still transitioning...\n  					return;\n  				}\n\n  				t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n  				cssTransitionsComplete = true;\n  				checkComplete();\n  			};\n\n  			t.node.addEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n  			setTimeout(function () {\n  				var i = changedProperties.length,\n  				    hash,\n  				    originalValue,\n  				    index,\n  				    propertiesToTransitionInJs = [],\n  				    prop,\n  				    suffix;\n\n  				while (i--) {\n  					prop = changedProperties[i];\n  					hash = hashPrefix + prop;\n\n  					if (CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[hash]) {\n  						t.node.style[helpers_prefix(prop)] = to[prop];\n\n  						// If we\'re not sure if CSS transitions are supported for\n  						// this tag/property combo, find out now\n  						if (!canUseCssTransitions[hash]) {\n  							originalValue = t.getStyle(prop);\n\n  							// if this property is transitionable in this browser,\n  							// the current style will be different from the target style\n  							canUseCssTransitions[hash] = t.getStyle(prop) != to[prop];\n  							cannotUseCssTransitions[hash] = !canUseCssTransitions[hash];\n\n  							// Reset, if we\'re going to use timers after all\n  							if (cannotUseCssTransitions[hash]) {\n  								t.node.style[helpers_prefix(prop)] = originalValue;\n  							}\n  						}\n  					}\n\n  					if (!CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[hash]) {\n  						// we need to fall back to timer-based stuff\n  						if (originalValue === undefined) {\n  							originalValue = t.getStyle(prop);\n  						}\n\n  						// need to remove this from changedProperties, otherwise transitionEndHandler\n  						// will get confused\n  						index = changedProperties.indexOf(prop);\n  						if (index === -1) {\n  							warnIfDebug("Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!", { node: t.node });\n  						} else {\n  							changedProperties.splice(index, 1);\n  						}\n\n  						// TODO Determine whether this property is animatable at all\n\n  						suffix = /[^\\d]*$/.exec(to[prop])[0];\n\n  						// ...then kick off a timer-based transition\n  						propertiesToTransitionInJs.push({\n  							name: helpers_prefix(prop),\n  							interpolator: shared_interpolate(parseFloat(originalValue), parseFloat(to[prop])),\n  							suffix: suffix\n  						});\n  					}\n  				}\n\n  				// javascript transitions\n  				if (propertiesToTransitionInJs.length) {\n  					new shared_Ticker({\n  						root: t.root,\n  						duration: options.duration,\n  						easing: camelCase(options.easing || ""),\n  						step: function (pos) {\n  							var prop, i;\n\n  							i = propertiesToTransitionInJs.length;\n  							while (i--) {\n  								prop = propertiesToTransitionInJs[i];\n  								t.node.style[prop.name] = prop.interpolator(pos) + prop.suffix;\n  							}\n  						},\n  						complete: function () {\n  							jsTransitionsComplete = true;\n  							checkComplete();\n  						}\n  					});\n  				} else {\n  					jsTransitionsComplete = true;\n  				}\n\n  				if (!changedProperties.length) {\n  					// We need to cancel the transitionEndHandler, and deal with\n  					// the fact that it will never fire\n  					t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n  					cssTransitionsComplete = true;\n  					checkComplete();\n  				}\n  			}, 0);\n  		}, options.delay || 0);\n  	};\n  }\n\n  var animateStyle_createTransitions = createTransitions;\n\n  var hidden, vendor, animateStyle_visibility__prefix, animateStyle_visibility__i, visibility;\n\n  if (typeof document !== "undefined") {\n  	hidden = "hidden";\n\n  	visibility = {};\n\n  	if (hidden in document) {\n  		animateStyle_visibility__prefix = "";\n  	} else {\n  		animateStyle_visibility__i = vendors.length;\n  		while (animateStyle_visibility__i--) {\n  			vendor = vendors[animateStyle_visibility__i];\n  			hidden = vendor + "Hidden";\n\n  			if (hidden in document) {\n  				animateStyle_visibility__prefix = vendor;\n  			}\n  		}\n  	}\n\n  	if (animateStyle_visibility__prefix !== undefined) {\n  		document.addEventListener(animateStyle_visibility__prefix + "visibilitychange", onChange);\n\n  		// initialise\n  		onChange();\n  	} else {\n  		// gah, we\'re in an old browser\n  		if ("onfocusout" in document) {\n  			document.addEventListener("focusout", onHide);\n  			document.addEventListener("focusin", onShow);\n  		} else {\n  			window.addEventListener("pagehide", onHide);\n  			window.addEventListener("blur", onHide);\n\n  			window.addEventListener("pageshow", onShow);\n  			window.addEventListener("focus", onShow);\n  		}\n\n  		visibility.hidden = false; // until proven otherwise. Not ideal but hey\n  	}\n  }\n\n  function onChange() {\n  	visibility.hidden = document[hidden];\n  }\n\n  function onHide() {\n  	visibility.hidden = true;\n  }\n\n  function onShow() {\n  	visibility.hidden = false;\n  }\n\n  var animateStyle_visibility = visibility;\n\n  var animateStyle, _animateStyle__getComputedStyle, resolved;\n\n  if (!isClient) {\n  	animateStyle = null;\n  } else {\n  	_animateStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n  	animateStyle = function (style, value, options) {\n  		var _this = this;\n\n  		var to;\n\n  		if (arguments.length === 4) {\n  			throw new Error("t.animateStyle() returns a promise - use .then() instead of passing a callback");\n  		}\n\n  		// Special case - page isn\'t visible. Don\'t animate anything, because\n  		// that way you\'ll never get CSS transitionend events\n  		if (animateStyle_visibility.hidden) {\n  			this.setStyle(style, value);\n  			return resolved || (resolved = utils_Promise.resolve());\n  		}\n\n  		if (typeof style === "string") {\n  			to = {};\n  			to[style] = value;\n  		} else {\n  			to = style;\n\n  			// shuffle arguments\n  			options = value;\n  		}\n\n  		// As of 0.3.9, transition authors should supply an `option` object with\n  		// `duration` and `easing` properties (and optional `delay`), plus a\n  		// callback function that gets called after the animation completes\n\n  		// TODO remove this check in a future version\n  		if (!options) {\n  			warnOnceIfDebug("The \\"%s\\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340", this.name);\n  			options = this;\n  		}\n\n  		var promise = new utils_Promise(function (resolve) {\n  			var propertyNames, changedProperties, computedStyle, current, from, i, prop;\n\n  			// Edge case - if duration is zero, set style synchronously and complete\n  			if (!options.duration) {\n  				_this.setStyle(to);\n  				resolve();\n  				return;\n  			}\n\n  			// Get a list of the properties we\'re animating\n  			propertyNames = Object.keys(to);\n  			changedProperties = [];\n\n  			// Store the current styles\n  			computedStyle = _animateStyle__getComputedStyle(_this.node);\n\n  			from = {};\n  			i = propertyNames.length;\n  			while (i--) {\n  				prop = propertyNames[i];\n  				current = computedStyle[helpers_prefix(prop)];\n\n  				if (current === "0px") {\n  					current = 0;\n  				}\n\n  				// we need to know if we\'re actually changing anything\n  				if (current != to[prop]) {\n  					// use != instead of !==, so we can compare strings with numbers\n  					changedProperties.push(prop);\n\n  					// make the computed style explicit, so we can animate where\n  					// e.g. height=\'auto\'\n  					_this.node.style[helpers_prefix(prop)] = current;\n  				}\n  			}\n\n  			// If we\'re not actually changing anything, the transitionend event\n  			// will never fire! So we complete early\n  			if (!changedProperties.length) {\n  				resolve();\n  				return;\n  			}\n\n  			animateStyle_createTransitions(_this, to, options, changedProperties, resolve);\n  		});\n\n  		return promise;\n  	};\n  }\n\n  var _animateStyle = animateStyle;\n\n  var processParams = function (params, defaults) {\n  	if (typeof params === "number") {\n  		params = { duration: params };\n  	} else if (typeof params === "string") {\n  		if (params === "slow") {\n  			params = { duration: 600 };\n  		} else if (params === "fast") {\n  			params = { duration: 200 };\n  		} else {\n  			params = { duration: 400 };\n  		}\n  	} else if (!params) {\n  		params = {};\n  	}\n\n  	return fillGaps({}, params, defaults);\n  };\n\n  var prototype_start = Transition$start;\n\n  function Transition$start() {\n  	var _this = this;\n\n  	var node, originalStyle, completed;\n\n  	node = this.node = this.element.node;\n  	originalStyle = node.getAttribute("style");\n\n  	// create t.complete() - we don\'t want this on the prototype,\n  	// because we don\'t want `this` silliness when passing it as\n  	// an argument\n  	this.complete = function (noReset) {\n  		if (completed) {\n  			return;\n  		}\n\n  		if (!noReset && _this.isIntro) {\n  			resetStyle(node, originalStyle);\n  		}\n\n  		node._ractive.transition = null;\n  		_this._manager.remove(_this);\n\n  		completed = true;\n  	};\n\n  	// If the transition function doesn\'t exist, abort\n  	if (!this._fn) {\n  		this.complete();\n  		return;\n  	}\n\n  	this._fn.apply(this.root, [this].concat(this.params));\n  }\n\n  function resetStyle(node, style) {\n  	if (style) {\n  		node.setAttribute("style", style);\n  	} else {\n\n  		// Next line is necessary, to remove empty style attribute!\n  		// See http://stackoverflow.com/a/7167553\n  		node.getAttribute("style");\n  		node.removeAttribute("style");\n  	}\n  }\n\n  var Transition = function (owner, template, isIntro) {\n  	this.init(owner, template, isIntro);\n  };\n\n  Transition.prototype = {\n  	init: Transition_prototype_init,\n  	start: prototype_start,\n  	getStyle: prototype_getStyle,\n  	setStyle: setStyle,\n  	animateStyle: _animateStyle,\n  	processParams: processParams\n  };\n\n  var _Transition = Transition;\n\n  var Element_prototype_render = Element$render;\n\n  var updateCss, updateScript;\n\n  updateCss = function () {\n  	var node = this.node,\n  	    content = this.fragment.toString(false);\n\n  	// IE8 has no styleSheet unless there\'s a type text/css\n  	if (window && window.appearsToBeIELessEqual8) {\n  		node.type = "text/css";\n  	}\n\n  	if (node.styleSheet) {\n  		node.styleSheet.cssText = content;\n  	} else {\n\n  		while (node.hasChildNodes()) {\n  			node.removeChild(node.firstChild);\n  		}\n\n  		node.appendChild(document.createTextNode(content));\n  	}\n  };\n\n  updateScript = function () {\n  	if (!this.node.type || this.node.type === "text/javascript") {\n  		warnIfDebug("Script tag was updated. This does not cause the code to be re-evaluated!", { ractive: this.root });\n  		// As it happens, we ARE in a position to re-evaluate the code if we wanted\n  		// to - we could eval() it, or insert it into a fresh (temporary) script tag.\n  		// But this would be a terrible idea with unpredictable results, so let\'s not.\n  	}\n\n  	this.node.text = this.fragment.toString(false);\n  };\n  function Element$render() {\n  	var _this = this;\n\n  	var root = this.root,\n  	    namespace,\n  	    node,\n  	    transition;\n\n  	namespace = getNamespace(this);\n  	node = this.node = createElement(this.name, namespace);\n\n  	// Is this a top-level node of a component? If so, we may need to add\n  	// a data-ractive-css attribute, for CSS encapsulation\n  	if (this.parentFragment.cssIds) {\n  		this.node.setAttribute("data-ractive-css", this.parentFragment.cssIds.map(function (x) {\n  			return "{" + x + "}";\n  		}).join(" "));\n  	}\n\n  	// Add _ractive property to the node - we use this object to store stuff\n  	// related to proxy events, two-way bindings etc\n  	defineProperty(this.node, "_ractive", {\n  		value: {\n  			proxy: this,\n  			keypath: getInnerContext(this.parentFragment),\n  			events: create(null),\n  			root: root\n  		}\n  	});\n\n  	// Render attributes\n  	this.attributes.forEach(function (a) {\n  		return a.render(node);\n  	});\n  	this.conditionalAttributes.forEach(function (a) {\n  		return a.render(node);\n  	});\n\n  	// Render children\n  	if (this.fragment) {\n  		// Special case - <script> element\n  		if (this.name === "script") {\n  			this.bubble = updateScript;\n  			this.node.text = this.fragment.toString(false); // bypass warning initially\n  			this.fragment.unrender = noop; // TODO this is a kludge\n  		}\n\n  		// Special case - <style> element\n  		else if (this.name === "style") {\n  			this.bubble = updateCss;\n  			this.bubble();\n  			this.fragment.unrender = noop;\n  		}\n\n  		// Special case - contenteditable\n  		else if (this.binding && this.getAttribute("contenteditable")) {\n  			this.fragment.unrender = noop;\n  		} else {\n  			this.node.appendChild(this.fragment.render());\n  		}\n  	}\n\n  	// deal with two-way bindings\n  	if (this.binding) {\n  		this.binding.render();\n  		this.node._ractive.binding = this.binding;\n  	}\n\n  	// Add proxy event handlers\n  	if (this.eventHandlers) {\n  		this.eventHandlers.forEach(function (h) {\n  			return h.render();\n  		});\n  	}\n\n  	if (this.name === "option") {\n  		processOption(this);\n  	}\n\n  	// Special cases\n  	if (this.name === "img") {\n  		// if this is an <img>, and we\'re in a crap browser, we may\n  		// need to prevent it from overriding width and height when\n  		// it loads the src\n  		special_img__render(this);\n  	} else if (this.name === "form") {\n  		// forms need to keep track of their bindings, in case of reset\n  		form__render(this);\n  	} else if (this.name === "input" || this.name === "textarea") {\n  		// inputs and textareas should store their initial value as\n  		// `defaultValue` in case of reset\n  		this.node.defaultValue = this.node.value;\n  	} else if (this.name === "option") {\n  		// similarly for option nodes\n  		this.node.defaultSelected = this.node.selected;\n  	}\n\n  	// apply decorator(s)\n  	if (this.decorator && this.decorator.fn) {\n  		global_runloop.scheduleTask(function () {\n  			if (!_this.decorator.torndown) {\n  				_this.decorator.init();\n  			}\n  		}, true);\n  	}\n\n  	// trigger intro transition\n  	if (root.transitionsEnabled && this.intro) {\n  		transition = new _Transition(this, this.intro, true);\n  		global_runloop.registerTransition(transition);\n  		global_runloop.scheduleTask(function () {\n  			return transition.start();\n  		}, true);\n\n  		this.transition = transition;\n  	}\n\n  	if (this.node.autofocus) {\n  		// Special case. Some browsers (*cough* Firefix *cough*) have a problem\n  		// with dynamically-generated elements having autofocus, and they won\'t\n  		// allow you to programmatically focus the element until it\'s in the DOM\n  		global_runloop.scheduleTask(function () {\n  			return _this.node.focus();\n  		}, true);\n  	}\n\n  	updateLiveQueries(this);\n  	return this.node;\n  }\n\n  function getNamespace(element) {\n  	var namespace, xmlns, parent;\n\n  	// Use specified namespace...\n  	if (xmlns = element.getAttribute("xmlns")) {\n  		namespace = xmlns;\n  	}\n\n  	// ...or SVG namespace, if this is an <svg> element\n  	else if (element.name === "svg") {\n  		namespace = namespaces.svg;\n  	} else if (parent = element.parent) {\n  		// ...or HTML, if the parent is a <foreignObject>\n  		if (parent.name === "foreignObject") {\n  			namespace = namespaces.html;\n  		}\n\n  		// ...or inherit from the parent node\n  		else {\n  			namespace = parent.node.namespaceURI;\n  		}\n  	} else {\n  		namespace = element.root.el.namespaceURI;\n  	}\n\n  	return namespace;\n  }\n\n  function processOption(option) {\n  	var optionValue, selectValue, i;\n\n  	if (!option.select) {\n  		return;\n  	}\n\n  	selectValue = option.select.getAttribute("value");\n  	if (selectValue === undefined) {\n  		return;\n  	}\n\n  	optionValue = option.getAttribute("value");\n\n  	if (option.select.node.multiple && isArray(selectValue)) {\n  		i = selectValue.length;\n  		while (i--) {\n  			if (optionValue == selectValue[i]) {\n  				option.node.selected = true;\n  				break;\n  			}\n  		}\n  	} else {\n  		option.node.selected = optionValue == selectValue;\n  	}\n  }\n\n  function updateLiveQueries(element) {\n  	var instance, liveQueries, i, selector, query;\n\n  	// Does this need to be added to any live queries?\n  	instance = element.root;\n\n  	do {\n  		liveQueries = instance._liveQueries;\n\n  		i = liveQueries.length;\n  		while (i--) {\n  			selector = liveQueries[i];\n  			query = liveQueries["_" + selector];\n\n  			if (query._test(element)) {\n  				// keep register of applicable selectors, for when we teardown\n  				(element.liveQueries || (element.liveQueries = [])).push(query);\n  			}\n  		}\n  	} while (instance = instance.parent);\n  }\n\n  var Element_prototype_toString = function () {\n  	var str, escape;\n\n  	if (this.template.y) {\n  		// DOCTYPE declaration\n  		return "<!DOCTYPE" + this.template.dd + ">";\n  	}\n\n  	str = "<" + this.template.e;\n\n  	str += this.attributes.map(stringifyAttribute).join("") + this.conditionalAttributes.map(stringifyAttribute).join("");\n\n  	// Special case - selected options\n  	if (this.name === "option" && optionIsSelected(this)) {\n  		str += " selected";\n  	}\n\n  	// Special case - two-way radio name bindings\n  	if (this.name === "input" && inputIsCheckedRadio(this)) {\n  		str += " checked";\n  	}\n\n  	str += ">";\n\n  	// Special case - textarea\n  	if (this.name === "textarea" && this.getAttribute("value") !== undefined) {\n  		str += escapeHtml(this.getAttribute("value"));\n  	}\n\n  	// Special case - contenteditable\n  	else if (this.getAttribute("contenteditable") !== undefined) {\n  		str += this.getAttribute("value") || "";\n  	}\n\n  	if (this.fragment) {\n  		escape = this.name !== "script" && this.name !== "style";\n  		str += this.fragment.toString(escape);\n  	}\n\n  	// add a closing tag if this isn\'t a void element\n  	if (!voidElementNames.test(this.template.e)) {\n  		str += "</" + this.template.e + ">";\n  	}\n\n  	return str;\n  };\n\n  function optionIsSelected(element) {\n  	var optionValue, selectValue, i;\n\n  	optionValue = element.getAttribute("value");\n\n  	if (optionValue === undefined || !element.select) {\n  		return false;\n  	}\n\n  	selectValue = element.select.getAttribute("value");\n\n  	if (selectValue == optionValue) {\n  		return true;\n  	}\n\n  	if (element.select.getAttribute("multiple") && isArray(selectValue)) {\n  		i = selectValue.length;\n  		while (i--) {\n  			if (selectValue[i] == optionValue) {\n  				return true;\n  			}\n  		}\n  	}\n  }\n\n  function inputIsCheckedRadio(element) {\n  	var attributes, typeAttribute, valueAttribute, nameAttribute;\n\n  	attributes = element.attributes;\n\n  	typeAttribute = attributes.type;\n  	valueAttribute = attributes.value;\n  	nameAttribute = attributes.name;\n\n  	if (!typeAttribute || typeAttribute.value !== "radio" || !valueAttribute || !nameAttribute.interpolator) {\n  		return;\n  	}\n\n  	if (valueAttribute.value === nameAttribute.interpolator.value) {\n  		return true;\n  	}\n  }\n\n  function stringifyAttribute(attribute) {\n  	var str = attribute.toString();\n  	return str ? " " + str : "";\n  }\n\n  var Element_prototype_unbind = Element$unbind;\n  function Element$unbind() {\n  	if (this.fragment) {\n  		this.fragment.unbind();\n  	}\n\n  	if (this.binding) {\n  		this.binding.unbind();\n  	}\n\n  	if (this.eventHandlers) {\n  		this.eventHandlers.forEach(methodCallers__unbind);\n  	}\n\n  	// Special case - <option>\n  	if (this.name === "option") {\n  		special_option__unbind(this);\n  	}\n\n  	this.attributes.forEach(methodCallers__unbind);\n  	this.conditionalAttributes.forEach(methodCallers__unbind);\n  }\n\n  var Element_prototype_unrender = Element$unrender;\n\n  function Element$unrender(shouldDestroy) {\n  	var binding, bindings, transition;\n\n  	if (transition = this.transition) {\n  		transition.complete();\n  	}\n\n  	// Detach as soon as we can\n  	if (this.name === "option") {\n  		// <option> elements detach immediately, so that\n  		// their parent <select> element syncs correctly, and\n  		// since option elements can\'t have transitions anyway\n  		this.detach();\n  	} else if (shouldDestroy) {\n  		global_runloop.detachWhenReady(this);\n  	}\n\n  	// Children first. that way, any transitions on child elements will be\n  	// handled by the current transitionManager\n  	if (this.fragment) {\n  		this.fragment.unrender(false);\n  	}\n\n  	if (binding = this.binding) {\n  		this.binding.unrender();\n\n  		this.node._ractive.binding = null;\n  		bindings = this.root._twowayBindings[binding.keypath.str];\n  		bindings.splice(bindings.indexOf(binding), 1);\n  	}\n\n  	// Remove event handlers\n  	if (this.eventHandlers) {\n  		this.eventHandlers.forEach(methodCallers__unrender);\n  	}\n\n  	if (this.decorator) {\n  		global_runloop.registerDecorator(this.decorator);\n  	}\n\n  	// trigger outro transition if necessary\n  	if (this.root.transitionsEnabled && this.outro) {\n  		transition = new _Transition(this, this.outro, false);\n  		global_runloop.registerTransition(transition);\n  		global_runloop.scheduleTask(function () {\n  			return transition.start();\n  		});\n  	}\n\n  	// Remove this node from any live queries\n  	if (this.liveQueries) {\n  		removeFromLiveQueries(this);\n  	}\n\n  	if (this.name === "form") {\n  		form__unrender(this);\n  	}\n  }\n\n  function removeFromLiveQueries(element) {\n  	var query, selector, i;\n\n  	i = element.liveQueries.length;\n  	while (i--) {\n  		query = element.liveQueries[i];\n  		selector = query.selector;\n\n  		query._remove(element.node);\n  	}\n  }\n\n  var Element = function (options) {\n  	this.init(options);\n  };\n\n  Element.prototype = {\n  	bubble: Element_prototype_bubble,\n  	detach: Element_prototype_detach,\n  	find: Element_prototype_find,\n  	findAll: Element_prototype_findAll,\n  	findAllComponents: Element_prototype_findAllComponents,\n  	findComponent: Element_prototype_findComponent,\n  	findNextNode: Element_prototype_findNextNode,\n  	firstNode: Element_prototype_firstNode,\n  	getAttribute: getAttribute,\n  	init: Element_prototype_init,\n  	rebind: Element_prototype_rebind,\n  	render: Element_prototype_render,\n  	toString: Element_prototype_toString,\n  	unbind: Element_prototype_unbind,\n  	unrender: Element_prototype_unrender\n  };\n\n  var _Element = Element;\n\n  var deIndent__empty = /^\\s*$/,\n      deIndent__leadingWhitespace = /^\\s*/;\n\n  var deIndent = function (str) {\n  	var lines, firstLine, lastLine, minIndent;\n\n  	lines = str.split("\\n");\n\n  	// remove first and last line, if they only contain whitespace\n  	firstLine = lines[0];\n  	if (firstLine !== undefined && deIndent__empty.test(firstLine)) {\n  		lines.shift();\n  	}\n\n  	lastLine = lastItem(lines);\n  	if (lastLine !== undefined && deIndent__empty.test(lastLine)) {\n  		lines.pop();\n  	}\n\n  	minIndent = lines.reduce(reducer, null);\n\n  	if (minIndent) {\n  		str = lines.map(function (line) {\n  			return line.replace(minIndent, "");\n  		}).join("\\n");\n  	}\n\n  	return str;\n  };\n\n  function reducer(previous, line) {\n  	var lineIndent = deIndent__leadingWhitespace.exec(line)[0];\n\n  	if (previous === null || lineIndent.length < previous.length) {\n  		return lineIndent;\n  	}\n\n  	return previous;\n  }\n\n  var Partial_getPartialTemplate = getPartialTemplate;\n\n  function getPartialTemplate(ractive, name, parentFragment) {\n  	var partial;\n\n  	// If the partial in instance or view heirarchy instances, great\n  	if (partial = getPartialFromRegistry(ractive, name, parentFragment || {})) {\n  		return partial;\n  	}\n\n  	// Does it exist on the page as a script tag?\n  	partial = template_parser.fromId(name, { noThrow: true });\n\n  	if (partial) {\n  		// is this necessary?\n  		partial = deIndent(partial);\n\n  		// parse and register to this ractive instance\n  		var parsed = template_parser.parse(partial, template_parser.getParseOptions(ractive));\n\n  		// register (and return main partial if there are others in the template)\n  		return ractive.partials[name] = parsed.t;\n  	}\n  }\n\n  function getPartialFromRegistry(ractive, name, parentFragment) {\n  	var fn = undefined,\n  	    partial = findParentPartial(name, parentFragment.owner);\n\n  	// if there was an instance up-hierarchy, cool\n  	if (partial) return partial;\n\n  	// find first instance in the ractive or view hierarchy that has this partial\n  	var instance = findInstance("partials", ractive, name);\n\n  	if (!instance) {\n  		return;\n  	}\n\n  	partial = instance.partials[name];\n\n  	// partial is a function?\n  	if (typeof partial === "function") {\n  		fn = partial.bind(instance);\n  		fn.isOwner = instance.partials.hasOwnProperty(name);\n  		partial = fn.call(ractive, template_parser);\n  	}\n\n  	if (!partial && partial !== "") {\n  		warnIfDebug(noRegistryFunctionReturn, name, "partial", "partial", { ractive: ractive });\n  		return;\n  	}\n\n  	// If this was added manually to the registry,\n  	// but hasn\'t been parsed, parse it now\n  	if (!template_parser.isParsed(partial)) {\n\n  		// use the parseOptions of the ractive instance on which it was found\n  		var parsed = template_parser.parse(partial, template_parser.getParseOptions(instance));\n\n  		// Partials cannot contain nested partials!\n  		// TODO add a test for this\n  		if (parsed.p) {\n  			warnIfDebug("Partials ({{>%s}}) cannot contain nested inline partials", name, { ractive: ractive });\n  		}\n\n  		// if fn, use instance to store result, otherwise needs to go\n  		// in the correct point in prototype chain on instance or constructor\n  		var target = fn ? instance : findOwner(instance, name);\n\n  		// may be a template with partials, which need to be registered and main template extracted\n  		target.partials[name] = partial = parsed.t;\n  	}\n\n  	// store for reset\n  	if (fn) {\n  		partial._fn = fn;\n  	}\n\n  	return partial.v ? partial.t : partial;\n  }\n\n  function findOwner(ractive, key) {\n  	return ractive.partials.hasOwnProperty(key) ? ractive : findConstructor(ractive.constructor, key);\n  }\n\n  function findConstructor(constructor, key) {\n  	if (!constructor) {\n  		return;\n  	}\n  	return constructor.partials.hasOwnProperty(key) ? constructor : findConstructor(constructor._Parent, key);\n  }\n\n  function findParentPartial(name, parent) {\n  	if (parent) {\n  		if (parent.template && parent.template.p && parent.template.p[name]) {\n  			return parent.template.p[name];\n  		} else if (parent.parentFragment && parent.parentFragment.owner) {\n  			return findParentPartial(name, parent.parentFragment.owner);\n  		}\n  	}\n  }\n\n  var applyIndent = function (string, indent) {\n  	var indented;\n\n  	if (!indent) {\n  		return string;\n  	}\n\n  	indented = string.split("\\n").map(function (line, notFirstLine) {\n  		return notFirstLine ? indent + line : line;\n  	}).join("\\n");\n\n  	return indented;\n  };\n\n  var missingPartialMessage = "Could not find template for partial \\"%s\\"";\n\n  var Partial = function (options) {\n  	var parentFragment, template;\n\n  	parentFragment = this.parentFragment = options.parentFragment;\n\n  	this.root = parentFragment.root;\n  	this.type = PARTIAL;\n  	this.index = options.index;\n  	this.name = options.template.r;\n  	this.rendered = false;\n\n  	this.fragment = this.fragmentToRender = this.fragmentToUnrender = null;\n\n  	Mustache.init(this, options);\n\n  	// If this didn\'t resolve, it most likely means we have a named partial\n  	// (i.e. `{{>foo}}` means \'use the foo partial\', not \'use the partial\n  	// whose name is the value of `foo`\')\n  	if (!this.keypath) {\n  		if (template = Partial_getPartialTemplate(this.root, this.name, parentFragment)) {\n  			shared_unbind.call(this); // prevent any further changes\n  			this.isNamed = true;\n  			this.setTemplate(template);\n  		} else {\n  			warnOnceIfDebug(missingPartialMessage, this.name);\n  		}\n  	}\n  };\n\n  Partial.prototype = {\n  	bubble: function () {\n  		this.parentFragment.bubble();\n  	},\n\n  	detach: function () {\n  		return this.fragment.detach();\n  	},\n\n  	find: function (selector) {\n  		return this.fragment.find(selector);\n  	},\n\n  	findAll: function (selector, query) {\n  		return this.fragment.findAll(selector, query);\n  	},\n\n  	findComponent: function (selector) {\n  		return this.fragment.findComponent(selector);\n  	},\n\n  	findAllComponents: function (selector, query) {\n  		return this.fragment.findAllComponents(selector, query);\n  	},\n\n  	firstNode: function () {\n  		return this.fragment.firstNode();\n  	},\n\n  	findNextNode: function () {\n  		return this.parentFragment.findNextNode(this);\n  	},\n\n  	getPartialName: function () {\n  		if (this.isNamed && this.name) return this.name;else if (this.value === undefined) return this.name;else return this.value;\n  	},\n\n  	getValue: function () {\n  		return this.fragment.getValue();\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		// named partials aren\'t bound, so don\'t rebind\n  		if (!this.isNamed) {\n  			Mustache_rebind.call(this, oldKeypath, newKeypath);\n  		}\n\n  		if (this.fragment) {\n  			this.fragment.rebind(oldKeypath, newKeypath);\n  		}\n  	},\n\n  	render: function () {\n  		this.docFrag = document.createDocumentFragment();\n  		this.update();\n\n  		this.rendered = true;\n  		return this.docFrag;\n  	},\n\n  	resolve: Mustache.resolve,\n\n  	setValue: function (value) {\n  		var template;\n\n  		if (value !== undefined && value === this.value) {\n  			// nothing has changed, so no work to be done\n  			return;\n  		}\n\n  		if (value !== undefined) {\n  			template = Partial_getPartialTemplate(this.root, "" + value, this.parentFragment);\n  		}\n\n  		// we may be here if we have a partial like `{{>foo}}` and `foo` is the\n  		// name of both a data property (whose value ISN\'T the name of a partial)\n  		// and a partial. In those cases, this becomes a named partial\n  		if (!template && this.name && (template = Partial_getPartialTemplate(this.root, this.name, this.parentFragment))) {\n  			shared_unbind.call(this);\n  			this.isNamed = true;\n  		}\n\n  		if (!template) {\n  			warnOnceIfDebug(missingPartialMessage, this.name, { ractive: this.root });\n  		}\n\n  		this.value = value;\n\n  		this.setTemplate(template || []);\n\n  		this.bubble();\n\n  		if (this.rendered) {\n  			global_runloop.addView(this);\n  		}\n  	},\n\n  	setTemplate: function (template) {\n  		if (this.fragment) {\n  			this.fragment.unbind();\n  			if (this.rendered) {\n  				this.fragmentToUnrender = this.fragment;\n  			}\n  		}\n\n  		this.fragment = new virtualdom_Fragment({\n  			template: template,\n  			root: this.root,\n  			owner: this,\n  			pElement: this.parentFragment.pElement\n  		});\n\n  		this.fragmentToRender = this.fragment;\n  	},\n\n  	toString: function (toString) {\n  		var string, previousItem, lastLine, match;\n\n  		string = this.fragment.toString(toString);\n\n  		previousItem = this.parentFragment.items[this.index - 1];\n\n  		if (!previousItem || previousItem.type !== TEXT) {\n  			return string;\n  		}\n\n  		lastLine = previousItem.text.split("\\n").pop();\n\n  		if (match = /^\\s+$/.exec(lastLine)) {\n  			return applyIndent(string, match[0]);\n  		}\n\n  		return string;\n  	},\n\n  	unbind: function () {\n  		if (!this.isNamed) {\n  			// dynamic partial - need to unbind self\n  			shared_unbind.call(this);\n  		}\n\n  		if (this.fragment) {\n  			this.fragment.unbind();\n  		}\n  	},\n\n  	unrender: function (shouldDestroy) {\n  		if (this.rendered) {\n  			if (this.fragment) {\n  				this.fragment.unrender(shouldDestroy);\n  			}\n  			this.rendered = false;\n  		}\n  	},\n\n  	update: function () {\n  		var target, anchor;\n\n  		if (this.fragmentToUnrender) {\n  			this.fragmentToUnrender.unrender(true);\n  			this.fragmentToUnrender = null;\n  		}\n\n  		if (this.fragmentToRender) {\n  			this.docFrag.appendChild(this.fragmentToRender.render());\n  			this.fragmentToRender = null;\n  		}\n\n  		if (this.rendered) {\n  			target = this.parentFragment.getNode();\n  			anchor = this.parentFragment.findNextNode(this);\n  			target.insertBefore(this.docFrag, anchor);\n  		}\n  	}\n  };\n\n  var _Partial = Partial;\n\n  // finds the component constructor in the registry or view hierarchy registries\n\n  var Component_getComponent = getComponent;\n  function getComponent(ractive, name) {\n\n  	var Component,\n  	    instance = findInstance("components", ractive, name);\n\n  	if (instance) {\n  		Component = instance.components[name];\n\n  		// best test we have for not Ractive.extend\n  		if (!Component._Parent) {\n  			// function option, execute and store for reset\n  			var fn = Component.bind(instance);\n  			fn.isOwner = instance.components.hasOwnProperty(name);\n  			Component = fn();\n\n  			if (!Component) {\n  				warnIfDebug(noRegistryFunctionReturn, name, "component", "component", { ractive: ractive });\n\n  				return;\n  			}\n\n  			if (typeof Component === "string") {\n  				// allow string lookup\n  				Component = getComponent(ractive, Component);\n  			}\n\n  			Component._fn = fn;\n  			instance.components[name] = Component;\n  		}\n  	}\n\n  	return Component;\n  }\n\n  var Component_prototype_detach = Component$detach;\n  var Component_prototype_detach__detachHook = new hooks_Hook("detach");\n  function Component$detach() {\n  	var detached = this.instance.fragment.detach();\n  	Component_prototype_detach__detachHook.fire(this.instance);\n  	return detached;\n  }\n\n  var Component_prototype_find = Component$find;\n\n  function Component$find(selector) {\n  	return this.instance.fragment.find(selector);\n  }\n\n  var Component_prototype_findAll = Component$findAll;\n\n  function Component$findAll(selector, query) {\n  	return this.instance.fragment.findAll(selector, query);\n  }\n\n  var Component_prototype_findAllComponents = Component$findAllComponents;\n\n  function Component$findAllComponents(selector, query) {\n  	query._test(this, true);\n\n  	if (this.instance.fragment) {\n  		this.instance.fragment.findAllComponents(selector, query);\n  	}\n  }\n\n  var Component_prototype_findComponent = Component$findComponent;\n\n  function Component$findComponent(selector) {\n  	if (!selector || selector === this.name) {\n  		return this.instance;\n  	}\n\n  	if (this.instance.fragment) {\n  		return this.instance.fragment.findComponent(selector);\n  	}\n\n  	return null;\n  }\n\n  var Component_prototype_findNextNode = Component$findNextNode;\n\n  function Component$findNextNode() {\n  	return this.parentFragment.findNextNode(this);\n  }\n\n  var Component_prototype_firstNode = Component$firstNode;\n\n  function Component$firstNode() {\n  	if (this.rendered) {\n  		return this.instance.fragment.firstNode();\n  	}\n\n  	return null;\n  }\n\n  var processWrapper = function (wrapper, array, methodName, newIndices) {\n  	var root = wrapper.root;\n  	var keypath = wrapper.keypath;\n\n  	if (!!newIndices) {\n  		root.viewmodel.smartUpdate(keypath, array, newIndices);\n  	} else {\n  		// If this is a sort or reverse, we just do root.set()...\n  		// TODO use merge logic?\n  		root.viewmodel.mark(keypath);\n  	}\n  };\n\n  var patchedArrayProto = [],\n      mutatorMethods = ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"],\n      testObj,\n      patchArrayMethods,\n      unpatchArrayMethods;\n\n  mutatorMethods.forEach(function (methodName) {\n  	var method = function () {\n  		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n  			args[_key] = arguments[_key];\n  		}\n\n  		var newIndices, result, wrapper, i;\n\n  		newIndices = shared_getNewIndices(this, methodName, args);\n\n  		// apply the underlying method\n  		result = Array.prototype[methodName].apply(this, arguments);\n\n  		// trigger changes\n  		global_runloop.start();\n\n  		this._ractive.setting = true;\n  		i = this._ractive.wrappers.length;\n  		while (i--) {\n  			wrapper = this._ractive.wrappers[i];\n\n  			global_runloop.addRactive(wrapper.root);\n  			processWrapper(wrapper, this, methodName, newIndices);\n  		}\n\n  		global_runloop.end();\n\n  		this._ractive.setting = false;\n  		return result;\n  	};\n\n  	defineProperty(patchedArrayProto, methodName, {\n  		value: method\n  	});\n  });\n\n  // can we use prototype chain injection?\n  // http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\n  testObj = {};\n\n  if (testObj.__proto__) {\n  	// yes, we can\n  	patchArrayMethods = function (array) {\n  		array.__proto__ = patchedArrayProto;\n  	};\n\n  	unpatchArrayMethods = function (array) {\n  		array.__proto__ = Array.prototype;\n  	};\n  } else {\n  	// no, we can\'t\n  	patchArrayMethods = function (array) {\n  		var i, methodName;\n\n  		i = mutatorMethods.length;\n  		while (i--) {\n  			methodName = mutatorMethods[i];\n  			defineProperty(array, methodName, {\n  				value: patchedArrayProto[methodName],\n  				configurable: true\n  			});\n  		}\n  	};\n\n  	unpatchArrayMethods = function (array) {\n  		var i;\n\n  		i = mutatorMethods.length;\n  		while (i--) {\n  			delete array[mutatorMethods[i]];\n  		}\n  	};\n  }\n\n  patchArrayMethods.unpatch = unpatchArrayMethods;\n  var patch = patchArrayMethods;\n\n  var arrayAdaptor,\n\n  // helpers\n  ArrayWrapper, array_index__errorMessage;\n\n  arrayAdaptor = {\n  	filter: function (object) {\n  		// wrap the array if a) b) it\'s an array, and b) either it hasn\'t been wrapped already,\n  		// or the array didn\'t trigger the get() itself\n  		return isArray(object) && (!object._ractive || !object._ractive.setting);\n  	},\n  	wrap: function (ractive, array, keypath) {\n  		return new ArrayWrapper(ractive, array, keypath);\n  	}\n  };\n\n  ArrayWrapper = function (ractive, array, keypath) {\n  	this.root = ractive;\n  	this.value = array;\n  	this.keypath = getKeypath(keypath);\n\n  	// if this array hasn\'t already been ractified, ractify it\n  	if (!array._ractive) {\n\n  		// define a non-enumerable _ractive property to store the wrappers\n  		defineProperty(array, "_ractive", {\n  			value: {\n  				wrappers: [],\n  				instances: [],\n  				setting: false\n  			},\n  			configurable: true\n  		});\n\n  		patch(array);\n  	}\n\n  	// store the ractive instance, so we can handle transitions later\n  	if (!array._ractive.instances[ractive._guid]) {\n  		array._ractive.instances[ractive._guid] = 0;\n  		array._ractive.instances.push(ractive);\n  	}\n\n  	array._ractive.instances[ractive._guid] += 1;\n  	array._ractive.wrappers.push(this);\n  };\n\n  ArrayWrapper.prototype = {\n  	get: function () {\n  		return this.value;\n  	},\n  	teardown: function () {\n  		var array, storage, wrappers, instances, index;\n\n  		array = this.value;\n  		storage = array._ractive;\n  		wrappers = storage.wrappers;\n  		instances = storage.instances;\n\n  		// if teardown() was invoked because we\'re clearing the cache as a result of\n  		// a change that the array itself triggered, we can save ourselves the teardown\n  		// and immediate setup\n  		if (storage.setting) {\n  			return false; // so that we don\'t remove it from this.root.viewmodel.wrapped\n  		}\n\n  		index = wrappers.indexOf(this);\n  		if (index === -1) {\n  			throw new Error(array_index__errorMessage);\n  		}\n\n  		wrappers.splice(index, 1);\n\n  		// if nothing else depends on this array, we can revert it to its\n  		// natural state\n  		if (!wrappers.length) {\n  			delete array._ractive;\n  			patch.unpatch(this.value);\n  		} else {\n  			// remove ractive instance if possible\n  			instances[this.root._guid] -= 1;\n  			if (!instances[this.root._guid]) {\n  				index = instances.indexOf(this.root);\n\n  				if (index === -1) {\n  					throw new Error(array_index__errorMessage);\n  				}\n\n  				instances.splice(index, 1);\n  			}\n  		}\n  	}\n  };\n\n  array_index__errorMessage = "Something went wrong in a rather interesting way";\n  var array_index = arrayAdaptor;\n\n  var numeric = /^\\s*[0-9]+\\s*$/;\n\n  var createBranch = function (key) {\n  	return numeric.test(key) ? [] : {};\n  };\n\n  var magicAdaptor, MagicWrapper;\n\n  try {\n  	Object.defineProperty({}, "test", { value: 0 });\n\n  	magicAdaptor = {\n  		filter: function (object, keypath, ractive) {\n  			var parentWrapper, parentValue;\n\n  			if (!keypath) {\n  				return false;\n  			}\n\n  			keypath = getKeypath(keypath);\n\n  			// If the parent value is a wrapper, other than a magic wrapper,\n  			// we shouldn\'t wrap this property\n  			if ((parentWrapper = ractive.viewmodel.wrapped[keypath.parent.str]) && !parentWrapper.magic) {\n  				return false;\n  			}\n\n  			parentValue = ractive.viewmodel.get(keypath.parent);\n\n  			// if parentValue is an array that doesn\'t include this member,\n  			// we should return false otherwise lengths will get messed up\n  			if (isArray(parentValue) && /^[0-9]+$/.test(keypath.lastKey)) {\n  				return false;\n  			}\n\n  			return parentValue && (typeof parentValue === "object" || typeof parentValue === "function");\n  		},\n  		wrap: function (ractive, property, keypath) {\n  			return new MagicWrapper(ractive, property, keypath);\n  		}\n  	};\n\n  	MagicWrapper = function (ractive, value, keypath) {\n  		var objKeypath, template, siblings;\n\n  		keypath = getKeypath(keypath);\n\n  		this.magic = true;\n\n  		this.ractive = ractive;\n  		this.keypath = keypath;\n  		this.value = value;\n\n  		this.prop = keypath.lastKey;\n\n  		objKeypath = keypath.parent;\n  		this.obj = objKeypath.isRoot ? ractive.viewmodel.data : ractive.viewmodel.get(objKeypath);\n\n  		template = this.originalDescriptor = Object.getOwnPropertyDescriptor(this.obj, this.prop);\n\n  		// Has this property already been wrapped?\n  		if (template && template.set && (siblings = template.set._ractiveWrappers)) {\n\n  			// Yes. Register this wrapper to this property, if it hasn\'t been already\n  			if (siblings.indexOf(this) === -1) {\n  				siblings.push(this);\n  			}\n\n  			return; // already wrapped\n  		}\n\n  		// No, it hasn\'t been wrapped\n  		createAccessors(this, value, template);\n  	};\n\n  	MagicWrapper.prototype = {\n  		get: function () {\n  			return this.value;\n  		},\n  		reset: function (value) {\n  			if (this.updating) {\n  				return;\n  			}\n\n  			this.updating = true;\n  			this.obj[this.prop] = value; // trigger set() accessor\n  			global_runloop.addRactive(this.ractive);\n  			this.ractive.viewmodel.mark(this.keypath, { keepExistingWrapper: true });\n  			this.updating = false;\n  			return true;\n  		},\n  		set: function (key, value) {\n  			if (this.updating) {\n  				return;\n  			}\n\n  			if (!this.obj[this.prop]) {\n  				this.updating = true;\n  				this.obj[this.prop] = createBranch(key);\n  				this.updating = false;\n  			}\n\n  			this.obj[this.prop][key] = value;\n  		},\n  		teardown: function () {\n  			var template, set, value, wrappers, index;\n\n  			// If this method was called because the cache was being cleared as a\n  			// result of a set()/update() call made by this wrapper, we return false\n  			// so that it doesn\'t get torn down\n  			if (this.updating) {\n  				return false;\n  			}\n\n  			template = Object.getOwnPropertyDescriptor(this.obj, this.prop);\n  			set = template && template.set;\n\n  			if (!set) {\n  				// most likely, this was an array member that was spliced out\n  				return;\n  			}\n\n  			wrappers = set._ractiveWrappers;\n\n  			index = wrappers.indexOf(this);\n  			if (index !== -1) {\n  				wrappers.splice(index, 1);\n  			}\n\n  			// Last one out, turn off the lights\n  			if (!wrappers.length) {\n  				value = this.obj[this.prop];\n\n  				Object.defineProperty(this.obj, this.prop, this.originalDescriptor || {\n  					writable: true,\n  					enumerable: true,\n  					configurable: true\n  				});\n\n  				this.obj[this.prop] = value;\n  			}\n  		}\n  	};\n  } catch (err) {\n  	magicAdaptor = false; // no magic in this browser\n  }\n\n  var adaptors_magic = magicAdaptor;\n\n  function createAccessors(originalWrapper, value, template) {\n\n  	var object, property, oldGet, oldSet, get, set;\n\n  	object = originalWrapper.obj;\n  	property = originalWrapper.prop;\n\n  	// Is this template configurable?\n  	if (template && !template.configurable) {\n  		// Special case - array length\n  		if (property === "length") {\n  			return;\n  		}\n\n  		throw new Error("Cannot use magic mode with property \\"" + property + "\\" - object is not configurable");\n  	}\n\n  	// Time to wrap this property\n  	if (template) {\n  		oldGet = template.get;\n  		oldSet = template.set;\n  	}\n\n  	get = oldGet || function () {\n  		return value;\n  	};\n\n  	set = function (v) {\n  		if (oldSet) {\n  			oldSet(v);\n  		}\n\n  		value = oldGet ? oldGet() : v;\n  		set._ractiveWrappers.forEach(updateWrapper);\n  	};\n\n  	function updateWrapper(wrapper) {\n  		var keypath, ractive;\n\n  		wrapper.value = value;\n\n  		if (wrapper.updating) {\n  			return;\n  		}\n\n  		ractive = wrapper.ractive;\n  		keypath = wrapper.keypath;\n\n  		wrapper.updating = true;\n  		global_runloop.start(ractive);\n\n  		ractive.viewmodel.mark(keypath);\n\n  		global_runloop.end();\n  		wrapper.updating = false;\n  	}\n\n  	// Create an array of wrappers, in case other keypaths/ractives depend on this property.\n  	// Handily, we can store them as a property of the set function. Yay JavaScript.\n  	set._ractiveWrappers = [originalWrapper];\n  	Object.defineProperty(object, property, { get: get, set: set, enumerable: true, configurable: true });\n  }\n\n  var magicArrayAdaptor, MagicArrayWrapper;\n\n  if (adaptors_magic) {\n  	magicArrayAdaptor = {\n  		filter: function (object, keypath, ractive) {\n  			return adaptors_magic.filter(object, keypath, ractive) && array_index.filter(object);\n  		},\n\n  		wrap: function (ractive, array, keypath) {\n  			return new MagicArrayWrapper(ractive, array, keypath);\n  		}\n  	};\n\n  	MagicArrayWrapper = function (ractive, array, keypath) {\n  		this.value = array;\n\n  		this.magic = true;\n\n  		this.magicWrapper = adaptors_magic.wrap(ractive, array, keypath);\n  		this.arrayWrapper = array_index.wrap(ractive, array, keypath);\n  	};\n\n  	MagicArrayWrapper.prototype = {\n  		get: function () {\n  			return this.value;\n  		},\n  		teardown: function () {\n  			this.arrayWrapper.teardown();\n  			this.magicWrapper.teardown();\n  		},\n  		reset: function (value) {\n  			return this.magicWrapper.reset(value);\n  		}\n  	};\n  }\n\n  var magicArray = magicArrayAdaptor;\n\n  var prototype_adapt = Viewmodel$adapt;\n\n  var prefixers = {};\n  function Viewmodel$adapt(keypath, value) {\n  	var len, i, adaptor, wrapped;\n\n  	if (!this.adaptors) return;\n\n  	// Do we have an adaptor for this value?\n  	len = this.adaptors.length;\n  	for (i = 0; i < len; i += 1) {\n  		adaptor = this.adaptors[i];\n\n  		if (adaptor.filter(value, keypath, this.ractive)) {\n  			wrapped = this.wrapped[keypath] = adaptor.wrap(this.ractive, value, keypath, getPrefixer(keypath));\n  			wrapped.value = value;\n  			return;\n  		}\n  	}\n  }\n\n  function prefixKeypath(obj, prefix) {\n  	var prefixed = {},\n  	    key;\n\n  	if (!prefix) {\n  		return obj;\n  	}\n\n  	prefix += ".";\n\n  	for (key in obj) {\n  		if (obj.hasOwnProperty(key)) {\n  			prefixed[prefix + key] = obj[key];\n  		}\n  	}\n\n  	return prefixed;\n  }\n\n  function getPrefixer(rootKeypath) {\n  	var rootDot;\n\n  	if (!prefixers[rootKeypath]) {\n  		rootDot = rootKeypath ? rootKeypath + "." : "";\n\n  		prefixers[rootKeypath] = function (relativeKeypath, value) {\n  			var obj;\n\n  			if (typeof relativeKeypath === "string") {\n  				obj = {};\n  				obj[rootDot + relativeKeypath] = value;\n  				return obj;\n  			}\n\n  			if (typeof relativeKeypath === "object") {\n  				// \'relativeKeypath\' is in fact a hash, not a keypath\n  				return rootDot ? prefixKeypath(relativeKeypath, rootKeypath) : relativeKeypath;\n  			}\n  		};\n  	}\n\n  	return prefixers[rootKeypath];\n  }\n\n  // TEMP\n\n  var helpers_getUpstreamChanges = getUpstreamChanges;\n  function getUpstreamChanges(changes) {\n  	var upstreamChanges = [rootKeypath],\n  	    i,\n  	    keypath;\n\n  	i = changes.length;\n  	while (i--) {\n  		keypath = changes[i].parent;\n\n  		while (keypath && !keypath.isRoot) {\n  			if (changes.indexOf(keypath) === -1) {\n  				addToArray(upstreamChanges, keypath);\n  			}\n  			keypath = keypath.parent;\n  		}\n  	}\n\n  	return upstreamChanges;\n  }\n\n  var applyChanges_notifyPatternObservers = notifyPatternObservers;\n\n  function notifyPatternObservers(viewmodel, keypath, onlyDirect) {\n  	var potentialWildcardMatches;\n\n  	updateMatchingPatternObservers(viewmodel, keypath);\n\n  	if (onlyDirect) {\n  		return;\n  	}\n\n  	potentialWildcardMatches = keypath.wildcardMatches();\n  	potentialWildcardMatches.forEach(function (upstreamPattern) {\n  		cascade(viewmodel, upstreamPattern, keypath);\n  	});\n  }\n\n  function cascade(viewmodel, upstreamPattern, keypath) {\n  	var group, map, actualChildKeypath;\n\n  	// TODO should be one or the other\n  	upstreamPattern = upstreamPattern.str || upstreamPattern;\n\n  	group = viewmodel.depsMap.patternObservers;\n  	map = group && group[upstreamPattern];\n\n  	if (!map) {\n  		return;\n  	}\n\n  	map.forEach(function (childKeypath) {\n  		actualChildKeypath = keypath.join(childKeypath.lastKey); // \'foo.bar.baz\'\n\n  		updateMatchingPatternObservers(viewmodel, actualChildKeypath);\n  		cascade(viewmodel, childKeypath, actualChildKeypath);\n  	});\n  }\n\n  function updateMatchingPatternObservers(viewmodel, keypath) {\n  	viewmodel.patternObservers.forEach(function (observer) {\n  		if (observer.regex.test(keypath.str)) {\n  			observer.update(keypath);\n  		}\n  	});\n  }\n\n  var applyChanges = Viewmodel$applyChanges;\n\n  function Viewmodel$applyChanges() {\n  	var _this = this;\n\n  	var self = this,\n  	    changes,\n  	    upstreamChanges,\n  	    hash = {},\n  	    bindings;\n\n  	changes = this.changes;\n\n  	if (!changes.length) {\n  		// TODO we end up here on initial render. Perhaps we shouldn\'t?\n  		return;\n  	}\n\n  	function invalidateComputation(computation) {\n  		var key = computation.key;\n\n  		if (computation.viewmodel === self) {\n  			self.clearCache(key.str);\n  			computation.invalidate();\n\n  			changes.push(key);\n  			cascade(key);\n  		} else {\n  			computation.viewmodel.mark(key);\n  		}\n  	}\n\n  	function cascade(keypath) {\n  		var map, computations;\n\n  		if (self.noCascade.hasOwnProperty(keypath.str)) {\n  			return;\n  		}\n\n  		if (computations = self.deps.computed[keypath.str]) {\n  			computations.forEach(invalidateComputation);\n  		}\n\n  		if (map = self.depsMap.computed[keypath.str]) {\n  			map.forEach(cascade);\n  		}\n  	}\n\n  	changes.slice().forEach(cascade);\n\n  	upstreamChanges = helpers_getUpstreamChanges(changes);\n  	upstreamChanges.forEach(function (keypath) {\n  		var computations;\n\n  		// make sure we haven\'t already been down this particular keypath in this turn\n  		if (changes.indexOf(keypath) === -1 && (computations = self.deps.computed[keypath.str])) {\n  			computations.forEach(invalidateComputation);\n  		}\n  	});\n\n  	this.changes = [];\n\n  	// Pattern observers are a weird special case\n  	if (this.patternObservers.length) {\n  		upstreamChanges.forEach(function (keypath) {\n  			return applyChanges_notifyPatternObservers(_this, keypath, true);\n  		});\n  		changes.forEach(function (keypath) {\n  			return applyChanges_notifyPatternObservers(_this, keypath);\n  		});\n  	}\n\n  	if (this.deps.observers) {\n  		upstreamChanges.forEach(function (keypath) {\n  			return notifyUpstreamDependants(_this, null, keypath, "observers");\n  		});\n  		notifyAllDependants(this, changes, "observers");\n  	}\n\n  	if (this.deps["default"]) {\n  		bindings = [];\n  		upstreamChanges.forEach(function (keypath) {\n  			return notifyUpstreamDependants(_this, bindings, keypath, "default");\n  		});\n\n  		if (bindings.length) {\n  			notifyBindings(this, bindings, changes);\n  		}\n\n  		notifyAllDependants(this, changes, "default");\n  	}\n\n  	// Return a hash of keypaths to updated values\n  	changes.forEach(function (keypath) {\n  		hash[keypath.str] = _this.get(keypath);\n  	});\n\n  	this.implicitChanges = {};\n  	this.noCascade = {};\n\n  	return hash;\n  }\n\n  function notifyUpstreamDependants(viewmodel, bindings, keypath, groupName) {\n  	var dependants, value;\n\n  	if (dependants = findDependants(viewmodel, keypath, groupName)) {\n  		value = viewmodel.get(keypath);\n\n  		dependants.forEach(function (d) {\n  			// don\'t "set" the parent value, refine it\n  			// i.e. not data = value, but data[foo] = fooValue\n  			if (bindings && d.refineValue) {\n  				bindings.push(d);\n  			} else {\n  				d.setValue(value);\n  			}\n  		});\n  	}\n  }\n\n  function notifyBindings(viewmodel, bindings, changes) {\n\n  	bindings.forEach(function (binding) {\n  		var useSet = false,\n  		    i = 0,\n  		    length = changes.length,\n  		    refinements = [];\n\n  		while (i < length) {\n  			var keypath = changes[i];\n\n  			if (keypath === binding.keypath) {\n  				useSet = true;\n  				break;\n  			}\n\n  			if (keypath.slice(0, binding.keypath.length) === binding.keypath) {\n  				refinements.push(keypath);\n  			}\n\n  			i++;\n  		}\n\n  		if (useSet) {\n  			binding.setValue(viewmodel.get(binding.keypath));\n  		}\n\n  		if (refinements.length) {\n  			binding.refineValue(refinements);\n  		}\n  	});\n  }\n\n  function notifyAllDependants(viewmodel, keypaths, groupName) {\n  	var queue = [];\n\n  	addKeypaths(keypaths);\n  	queue.forEach(dispatch);\n\n  	function addKeypaths(keypaths) {\n  		keypaths.forEach(addKeypath);\n  		keypaths.forEach(cascade);\n  	}\n\n  	function addKeypath(keypath) {\n  		var deps = findDependants(viewmodel, keypath, groupName);\n\n  		if (deps) {\n  			queue.push({\n  				keypath: keypath,\n  				deps: deps\n  			});\n  		}\n  	}\n\n  	function cascade(keypath) {\n  		var childDeps;\n\n  		if (childDeps = viewmodel.depsMap[groupName][keypath.str]) {\n  			addKeypaths(childDeps);\n  		}\n  	}\n\n  	function dispatch(set) {\n  		var value = viewmodel.get(set.keypath);\n  		set.deps.forEach(function (d) {\n  			return d.setValue(value);\n  		});\n  	}\n  }\n\n  function findDependants(viewmodel, keypath, groupName) {\n  	var group = viewmodel.deps[groupName];\n  	return group ? group[keypath.str] : null;\n  }\n\n  var capture = Viewmodel$capture;\n\n  function Viewmodel$capture() {\n  	this.captureGroups.push([]);\n  }\n\n  var clearCache = Viewmodel$clearCache;\n\n  function Viewmodel$clearCache(keypath, keepExistingWrapper) {\n  	var cacheMap, wrapper;\n\n  	if (!keepExistingWrapper) {\n  		// Is there a wrapped property at this keypath?\n  		if (wrapper = this.wrapped[keypath]) {\n  			// Did we unwrap it?\n  			if (wrapper.teardown() !== false) {\n  				// Is this right?\n  				// What\'s the meaning of returning false from teardown?\n  				// Could there be a GC ramification if this is a "real" ractive.teardown()?\n  				this.wrapped[keypath] = null;\n  			}\n  		}\n  	}\n\n  	this.cache[keypath] = undefined;\n\n  	if (cacheMap = this.cacheMap[keypath]) {\n  		while (cacheMap.length) {\n  			this.clearCache(cacheMap.pop());\n  		}\n  	}\n  }\n\n  var UnresolvedDependency = function (computation, ref) {\n  	this.computation = computation;\n  	this.viewmodel = computation.viewmodel;\n  	this.ref = ref;\n\n  	// TODO this seems like a red flag!\n  	this.root = this.viewmodel.ractive;\n  	this.parentFragment = this.root.component && this.root.component.parentFragment;\n  };\n\n  UnresolvedDependency.prototype = {\n  	resolve: function (keypath) {\n  		this.computation.softDeps.push(keypath);\n  		this.computation.unresolvedDeps[keypath.str] = null;\n  		this.viewmodel.register(keypath, this.computation, "computed");\n  	}\n  };\n\n  var Computation_UnresolvedDependency = UnresolvedDependency;\n\n  var Computation = function (key, signature) {\n  	this.key = key;\n\n  	this.getter = signature.getter;\n  	this.setter = signature.setter;\n\n  	this.hardDeps = signature.deps || [];\n  	this.softDeps = [];\n  	this.unresolvedDeps = {};\n\n  	this.depValues = {};\n\n  	this._dirty = this._firstRun = true;\n  };\n\n  Computation.prototype = {\n  	constructor: Computation,\n\n  	init: function (viewmodel) {\n  		var _this = this;\n\n  		var initial;\n\n  		this.viewmodel = viewmodel;\n  		this.bypass = true;\n\n  		initial = viewmodel.get(this.key);\n  		viewmodel.clearCache(this.key.str);\n\n  		this.bypass = false;\n\n  		if (this.setter && initial !== undefined) {\n  			this.set(initial);\n  		}\n\n  		if (this.hardDeps) {\n  			this.hardDeps.forEach(function (d) {\n  				return viewmodel.register(d, _this, "computed");\n  			});\n  		}\n  	},\n\n  	invalidate: function () {\n  		this._dirty = true;\n  	},\n\n  	get: function () {\n  		var _this = this;\n\n  		var newDeps,\n  		    dependenciesChanged,\n  		    dependencyValuesChanged = false;\n\n  		if (this.getting) {\n  			// prevent double-computation (e.g. caused by array mutation inside computation)\n  			var msg = "The " + this.key.str + " computation indirectly called itself. This probably indicates a bug in the computation. It is commonly caused by `array.sort(...)` - if that\'s the case, clone the array first with `array.slice().sort(...)`";\n  			warnOnce(msg);\n  			return this.value;\n  		}\n\n  		this.getting = true;\n\n  		if (this._dirty) {\n  			// determine whether the inputs have changed, in case this depends on\n  			// other computed values\n  			if (this._firstRun || !this.hardDeps.length && !this.softDeps.length) {\n  				dependencyValuesChanged = true;\n  			} else {\n  				[this.hardDeps, this.softDeps].forEach(function (deps) {\n  					var keypath, value, i;\n\n  					if (dependencyValuesChanged) {\n  						return;\n  					}\n\n  					i = deps.length;\n  					while (i--) {\n  						keypath = deps[i];\n  						value = _this.viewmodel.get(keypath);\n\n  						if (!isEqual(value, _this.depValues[keypath.str])) {\n  							_this.depValues[keypath.str] = value;\n  							dependencyValuesChanged = true;\n\n  							return;\n  						}\n  					}\n  				});\n  			}\n\n  			if (dependencyValuesChanged) {\n  				this.viewmodel.capture();\n\n  				try {\n  					this.value = this.getter();\n  				} catch (err) {\n  					warnIfDebug("Failed to compute \\"%s\\"", this.key.str);\n  					logIfDebug(err.stack || err);\n\n  					this.value = void 0;\n  				}\n\n  				newDeps = this.viewmodel.release();\n  				dependenciesChanged = this.updateDependencies(newDeps);\n\n  				if (dependenciesChanged) {\n  					[this.hardDeps, this.softDeps].forEach(function (deps) {\n  						deps.forEach(function (keypath) {\n  							_this.depValues[keypath.str] = _this.viewmodel.get(keypath);\n  						});\n  					});\n  				}\n  			}\n\n  			this._dirty = false;\n  		}\n\n  		this.getting = this._firstRun = false;\n  		return this.value;\n  	},\n\n  	set: function (value) {\n  		if (this.setting) {\n  			this.value = value;\n  			return;\n  		}\n\n  		if (!this.setter) {\n  			throw new Error("Computed properties without setters are read-only. (This may change in a future version of Ractive!)");\n  		}\n\n  		this.setter(value);\n  	},\n\n  	updateDependencies: function (newDeps) {\n  		var i, oldDeps, keypath, dependenciesChanged, unresolved;\n\n  		oldDeps = this.softDeps;\n\n  		// remove dependencies that are no longer used\n  		i = oldDeps.length;\n  		while (i--) {\n  			keypath = oldDeps[i];\n\n  			if (newDeps.indexOf(keypath) === -1) {\n  				dependenciesChanged = true;\n  				this.viewmodel.unregister(keypath, this, "computed");\n  			}\n  		}\n\n  		// create references for any new dependencies\n  		i = newDeps.length;\n  		while (i--) {\n  			keypath = newDeps[i];\n\n  			if (oldDeps.indexOf(keypath) === -1 && (!this.hardDeps || this.hardDeps.indexOf(keypath) === -1)) {\n  				dependenciesChanged = true;\n\n  				// if this keypath is currently unresolved, we need to mark\n  				// it as such. TODO this is a bit muddy...\n  				if (isUnresolved(this.viewmodel, keypath) && !this.unresolvedDeps[keypath.str]) {\n  					unresolved = new Computation_UnresolvedDependency(this, keypath.str);\n  					newDeps.splice(i, 1);\n\n  					this.unresolvedDeps[keypath.str] = unresolved;\n  					global_runloop.addUnresolved(unresolved);\n  				} else {\n  					this.viewmodel.register(keypath, this, "computed");\n  				}\n  			}\n  		}\n\n  		if (dependenciesChanged) {\n  			this.softDeps = newDeps.slice();\n  		}\n\n  		return dependenciesChanged;\n  	}\n  };\n\n  function isUnresolved(viewmodel, keypath) {\n  	var key = keypath.firstKey;\n\n  	return !(key in viewmodel.data) && !(key in viewmodel.computations) && !(key in viewmodel.mappings);\n  }\n\n  var Computation_Computation = Computation;\n\n  var compute = Viewmodel$compute;\n  function Viewmodel$compute(key, signature) {\n  	var computation = new Computation_Computation(key, signature);\n\n  	if (this.ready) {\n  		computation.init(this);\n  	}\n\n  	return this.computations[key.str] = computation;\n  }\n\n  var FAILED_LOOKUP = { FAILED_LOOKUP: true };\n\n  var viewmodel_prototype_get = Viewmodel$get;\n\n  var viewmodel_prototype_get__empty = {};\n  function Viewmodel$get(keypath, options) {\n  	var cache = this.cache,\n  	    value,\n  	    computation,\n  	    wrapped,\n  	    captureGroup,\n  	    keypathStr = keypath.str,\n  	    key;\n\n  	options = options || viewmodel_prototype_get__empty;\n\n  	// capture the keypath, if we\'re inside a computation\n  	if (options.capture && (captureGroup = lastItem(this.captureGroups))) {\n  		if (! ~captureGroup.indexOf(keypath)) {\n  			captureGroup.push(keypath);\n  		}\n  	}\n\n  	if (hasOwn.call(this.mappings, keypath.firstKey)) {\n  		return this.mappings[keypath.firstKey].get(keypath, options);\n  	}\n\n  	if (keypath.isSpecial) {\n  		return keypath.value;\n  	}\n\n  	if (cache[keypathStr] === undefined) {\n\n  		// Is this a computed property?\n  		if ((computation = this.computations[keypathStr]) && !computation.bypass) {\n  			value = computation.get();\n  			this.adapt(keypathStr, value);\n  		}\n\n  		// Is this a wrapped property?\n  		else if (wrapped = this.wrapped[keypathStr]) {\n  			value = wrapped.value;\n  		}\n\n  		// Is it the root?\n  		else if (keypath.isRoot) {\n  			this.adapt("", this.data);\n  			value = this.data;\n  		}\n\n  		// No? Then we need to retrieve the value one key at a time\n  		else {\n  			value = retrieve(this, keypath);\n  		}\n\n  		cache[keypathStr] = value;\n  	} else {\n  		value = cache[keypathStr];\n  	}\n\n  	if (!options.noUnwrap && (wrapped = this.wrapped[keypathStr])) {\n  		value = wrapped.get();\n  	}\n\n  	if (keypath.isRoot && options.fullRootGet) {\n  		for (key in this.mappings) {\n  			value[key] = this.mappings[key].getValue();\n  		}\n  	}\n\n  	return value === FAILED_LOOKUP ? void 0 : value;\n  }\n\n  function retrieve(viewmodel, keypath) {\n\n  	var parentValue, cacheMap, value, wrapped;\n\n  	parentValue = viewmodel.get(keypath.parent);\n\n  	if (wrapped = viewmodel.wrapped[keypath.parent.str]) {\n  		parentValue = wrapped.get();\n  	}\n\n  	if (parentValue === null || parentValue === undefined) {\n  		return;\n  	}\n\n  	// update cache map\n  	if (!(cacheMap = viewmodel.cacheMap[keypath.parent.str])) {\n  		viewmodel.cacheMap[keypath.parent.str] = [keypath.str];\n  	} else {\n  		if (cacheMap.indexOf(keypath.str) === -1) {\n  			cacheMap.push(keypath.str);\n  		}\n  	}\n\n  	// If this property doesn\'t exist, we return a sentinel value\n  	// so that we know to query parent scope (if such there be)\n  	if (typeof parentValue === "object" && !(keypath.lastKey in parentValue)) {\n  		return viewmodel.cache[keypath.str] = FAILED_LOOKUP;\n  	}\n\n  	value = parentValue[keypath.lastKey];\n\n  	// Do we have an adaptor for this value?\n  	viewmodel.adapt(keypath.str, value, false);\n\n  	// Update cache\n  	viewmodel.cache[keypath.str] = value;\n  	return value;\n  }\n\n  var viewmodel_prototype_init = Viewmodel$init;\n\n  function Viewmodel$init() {\n  	var key;\n\n  	for (key in this.computations) {\n  		this.computations[key].init(this);\n  	}\n  }\n\n  var prototype_map = Viewmodel$map;\n\n  function Viewmodel$map(key, options) {\n  	var mapping = this.mappings[key.str] = new Mapping(key, options);\n  	mapping.initViewmodel(this);\n  	return mapping;\n  }\n\n  var Mapping = function (localKey, options) {\n  	this.localKey = localKey;\n  	this.keypath = options.keypath;\n  	this.origin = options.origin;\n\n  	this.deps = [];\n  	this.unresolved = [];\n\n  	this.resolved = false;\n  };\n\n  Mapping.prototype = {\n  	forceResolution: function () {\n  		// TODO warn, as per #1692?\n  		this.keypath = this.localKey;\n  		this.setup();\n  	},\n\n  	get: function (keypath, options) {\n  		if (!this.resolved) {\n  			return undefined;\n  		}\n  		return this.origin.get(this.map(keypath), options);\n  	},\n\n  	getValue: function () {\n  		if (!this.keypath) {\n  			return undefined;\n  		}\n  		return this.origin.get(this.keypath);\n  	},\n\n  	initViewmodel: function (viewmodel) {\n  		this.local = viewmodel;\n  		this.setup();\n  	},\n\n  	map: function (keypath) {\n  		if (typeof this.keypath === undefined) {\n  			return this.localKey;\n  		}\n  		return keypath.replace(this.localKey, this.keypath);\n  	},\n\n  	register: function (keypath, dependant, group) {\n  		this.deps.push({ keypath: keypath, dep: dependant, group: group });\n\n  		if (this.resolved) {\n  			this.origin.register(this.map(keypath), dependant, group);\n  		}\n  	},\n\n  	resolve: function (keypath) {\n  		if (this.keypath !== undefined) {\n  			this.unbind(true);\n  		}\n\n  		this.keypath = keypath;\n  		this.setup();\n  	},\n\n  	set: function (keypath, value) {\n  		if (!this.resolved) {\n  			this.forceResolution();\n  		}\n\n  		this.origin.set(this.map(keypath), value);\n  	},\n\n  	setup: function () {\n  		var _this = this;\n\n  		if (this.keypath === undefined) {\n  			return;\n  		}\n\n  		this.resolved = true;\n\n  		// accumulated dependants can now be registered\n  		if (this.deps.length) {\n  			this.deps.forEach(function (d) {\n  				var keypath = _this.map(d.keypath);\n  				_this.origin.register(keypath, d.dep, d.group);\n\n  				// TODO this is a bit of a red flag... all deps should be the same?\n  				if (d.dep.setValue) {\n  					d.dep.setValue(_this.origin.get(keypath));\n  				} else if (d.dep.invalidate) {\n  					d.dep.invalidate();\n  				} else {\n  					throw new Error("An unexpected error occurred. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!");\n  				}\n  			});\n\n  			this.origin.mark(this.keypath);\n  		}\n  	},\n\n  	setValue: function (value) {\n  		if (!this.keypath) {\n  			throw new Error("Mapping does not have keypath, cannot set value. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!");\n  		}\n\n  		this.origin.set(this.keypath, value);\n  	},\n\n  	unbind: function (keepLocal) {\n  		var _this = this;\n\n  		if (!keepLocal) {\n  			delete this.local.mappings[this.localKey];\n  		}\n\n  		if (!this.resolved) {\n  			return;\n  		}\n\n  		this.deps.forEach(function (d) {\n  			_this.origin.unregister(_this.map(d.keypath), d.dep, d.group);\n  		});\n\n  		if (this.tracker) {\n  			this.origin.unregister(this.keypath, this.tracker);\n  		}\n  	},\n\n  	unregister: function (keypath, dependant, group) {\n  		var deps, i;\n\n  		if (!this.resolved) {\n  			return;\n  		}\n\n  		deps = this.deps;\n  		i = deps.length;\n\n  		while (i--) {\n  			if (deps[i].dep === dependant) {\n  				deps.splice(i, 1);\n  				break;\n  			}\n  		}\n  		this.origin.unregister(this.map(keypath), dependant, group);\n  	}\n  };\n\n  var mark = Viewmodel$mark;\n\n  function Viewmodel$mark(keypath, options) {\n  	var computation,\n  	    keypathStr = keypath.str;\n\n  	// implicit changes (i.e. `foo.length` on `ractive.push(\'foo\',42)`)\n  	// should not be picked up by pattern observers\n  	if (options) {\n  		if (options.implicit) {\n  			this.implicitChanges[keypathStr] = true;\n  		}\n  		if (options.noCascade) {\n  			this.noCascade[keypathStr] = true;\n  		}\n  	}\n\n  	if (computation = this.computations[keypathStr]) {\n  		computation.invalidate();\n  	}\n\n  	if (this.changes.indexOf(keypath) === -1) {\n  		this.changes.push(keypath);\n  	}\n\n  	// pass on keepExistingWrapper, if we can\n  	var keepExistingWrapper = options ? options.keepExistingWrapper : false;\n\n  	this.clearCache(keypathStr, keepExistingWrapper);\n\n  	if (this.ready) {\n  		this.onchange();\n  	}\n  }\n\n  var mapOldToNewIndex = function (oldArray, newArray) {\n  	var usedIndices, firstUnusedIndex, newIndices, changed;\n\n  	usedIndices = {};\n  	firstUnusedIndex = 0;\n\n  	newIndices = oldArray.map(function (item, i) {\n  		var index, start, len;\n\n  		start = firstUnusedIndex;\n  		len = newArray.length;\n\n  		do {\n  			index = newArray.indexOf(item, start);\n\n  			if (index === -1) {\n  				changed = true;\n  				return -1;\n  			}\n\n  			start = index + 1;\n  		} while (usedIndices[index] && start < len);\n\n  		// keep track of the first unused index, so we don\'t search\n  		// the whole of newArray for each item in oldArray unnecessarily\n  		if (index === firstUnusedIndex) {\n  			firstUnusedIndex += 1;\n  		}\n\n  		if (index !== i) {\n  			changed = true;\n  		}\n\n  		usedIndices[index] = true;\n  		return index;\n  	});\n\n  	return newIndices;\n  };\n\n  var merge = Viewmodel$merge;\n\n  var comparators = {};\n  function Viewmodel$merge(keypath, currentArray, array, options) {\n  	var oldArray, newArray, comparator, newIndices;\n\n  	this.mark(keypath);\n\n  	if (options && options.compare) {\n\n  		comparator = getComparatorFunction(options.compare);\n\n  		try {\n  			oldArray = currentArray.map(comparator);\n  			newArray = array.map(comparator);\n  		} catch (err) {\n  			// fallback to an identity check - worst case scenario we have\n  			// to do more DOM manipulation than we thought...\n  			warnIfDebug("merge(): \\"%s\\" comparison failed. Falling back to identity checking", keypath);\n\n  			oldArray = currentArray;\n  			newArray = array;\n  		}\n  	} else {\n  		oldArray = currentArray;\n  		newArray = array;\n  	}\n\n  	// find new indices for members of oldArray\n  	newIndices = mapOldToNewIndex(oldArray, newArray);\n\n  	this.smartUpdate(keypath, array, newIndices, currentArray.length !== array.length);\n  }\n\n  function stringify(item) {\n  	return JSON.stringify(item);\n  }\n\n  function getComparatorFunction(comparator) {\n  	// If `compare` is `true`, we use JSON.stringify to compare\n  	// objects that are the same shape, but non-identical - i.e.\n  	// { foo: \'bar\' } !== { foo: \'bar\' }\n  	if (comparator === true) {\n  		return stringify;\n  	}\n\n  	if (typeof comparator === "string") {\n  		if (!comparators[comparator]) {\n  			comparators[comparator] = function (item) {\n  				return item[comparator];\n  			};\n  		}\n\n  		return comparators[comparator];\n  	}\n\n  	if (typeof comparator === "function") {\n  		return comparator;\n  	}\n\n  	throw new Error("The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)");\n  }\n\n  var register = Viewmodel$register;\n\n  function Viewmodel$register(keypath, dependant) {\n  	var group = arguments[2] === undefined ? "default" : arguments[2];\n\n  	var mapping, depsByKeypath, deps;\n\n  	if (dependant.isStatic) {\n  		return; // TODO we should never get here if a dependant is static...\n  	}\n\n  	if (mapping = this.mappings[keypath.firstKey]) {\n  		mapping.register(keypath, dependant, group);\n  	} else {\n  		depsByKeypath = this.deps[group] || (this.deps[group] = {});\n  		deps = depsByKeypath[keypath.str] || (depsByKeypath[keypath.str] = []);\n\n  		deps.push(dependant);\n\n  		if (!this.depsMap[group]) {\n  			this.depsMap[group] = {};\n  		}\n\n  		if (!keypath.isRoot) {\n  			register__updateDependantsMap(this, keypath, group);\n  		}\n  	}\n  }\n\n  function register__updateDependantsMap(viewmodel, keypath, group) {\n  	var map, parent, keypathStr;\n\n  	// update dependants map\n  	while (!keypath.isRoot) {\n  		map = viewmodel.depsMap[group];\n  		parent = map[keypath.parent.str] || (map[keypath.parent.str] = []);\n\n  		keypathStr = keypath.str;\n\n  		// TODO find an alternative to this nasty approach\n  		if (parent["_" + keypathStr] === undefined) {\n  			parent["_" + keypathStr] = 0;\n  			parent.push(keypath);\n  		}\n\n  		parent["_" + keypathStr] += 1;\n  		keypath = keypath.parent;\n  	}\n  }\n\n  var release = Viewmodel$release;\n\n  function Viewmodel$release() {\n  	return this.captureGroups.pop();\n  }\n\n  var reset = Viewmodel$reset;\n\n  function Viewmodel$reset(data) {\n  	this.data = data;\n  	this.clearCache("");\n  }\n\n  var prototype_set = Viewmodel$set;\n\n  function Viewmodel$set(keypath, value) {\n  	var options = arguments[2] === undefined ? {} : arguments[2];\n\n  	var mapping, computation, wrapper, keepExistingWrapper;\n\n  	// unless data is being set for data tracking purposes\n  	if (!options.noMapping) {\n  		// If this data belongs to a different viewmodel,\n  		// pass the change along\n  		if (mapping = this.mappings[keypath.firstKey]) {\n  			return mapping.set(keypath, value);\n  		}\n  	}\n\n  	computation = this.computations[keypath.str];\n  	if (computation) {\n  		if (computation.setting) {\n  			// let the other computation set() handle things...\n  			return;\n  		}\n  		computation.set(value);\n  		value = computation.get();\n  	}\n\n  	if (isEqual(this.cache[keypath.str], value)) {\n  		return;\n  	}\n\n  	wrapper = this.wrapped[keypath.str];\n\n  	// If we have a wrapper with a `reset()` method, we try and use it. If the\n  	// `reset()` method returns false, the wrapper should be torn down, and\n  	// (most likely) a new one should be created later\n  	if (wrapper && wrapper.reset) {\n  		keepExistingWrapper = wrapper.reset(value) !== false;\n\n  		if (keepExistingWrapper) {\n  			value = wrapper.get();\n  		}\n  	}\n\n  	if (!computation && !keepExistingWrapper) {\n  		resolveSet(this, keypath, value);\n  	}\n\n  	if (!options.silent) {\n  		this.mark(keypath);\n  	} else {\n  		// We\'re setting a parent of the original target keypath (i.e.\n  		// creating a fresh branch) - we need to clear the cache, but\n  		// not mark it as a change\n  		this.clearCache(keypath.str);\n  	}\n  }\n\n  function resolveSet(viewmodel, keypath, value) {\n  	var wrapper, parentValue, wrapperSet, valueSet;\n\n  	wrapperSet = function () {\n  		if (wrapper.set) {\n  			wrapper.set(keypath.lastKey, value);\n  		} else {\n  			parentValue = wrapper.get();\n  			valueSet();\n  		}\n  	};\n\n  	valueSet = function () {\n  		if (!parentValue) {\n  			parentValue = createBranch(keypath.lastKey);\n  			viewmodel.set(keypath.parent, parentValue, { silent: true });\n  		}\n  		parentValue[keypath.lastKey] = value;\n  	};\n\n  	wrapper = viewmodel.wrapped[keypath.parent.str];\n\n  	if (wrapper) {\n  		wrapperSet();\n  	} else {\n  		parentValue = viewmodel.get(keypath.parent);\n\n  		// may have been wrapped via the above .get()\n  		// call on viewmodel if this is first access via .set()!\n  		if (wrapper = viewmodel.wrapped[keypath.parent.str]) {\n  			wrapperSet();\n  		} else {\n  			valueSet();\n  		}\n  	}\n  }\n\n  var smartUpdate = Viewmodel$smartUpdate;\n\n  var implicitOption = { implicit: true },\n      noCascadeOption = { noCascade: true };\n  function Viewmodel$smartUpdate(keypath, array, newIndices) {\n  	var _this = this;\n\n  	var dependants, oldLength, i;\n\n  	oldLength = newIndices.length;\n\n  	// Indices that are being removed should be marked as dirty\n  	newIndices.forEach(function (newIndex, oldIndex) {\n  		if (newIndex === -1) {\n  			_this.mark(keypath.join(oldIndex), noCascadeOption);\n  		}\n  	});\n\n  	// Update the model\n  	// TODO allow existing array to be updated in place, rather than replaced?\n  	this.set(keypath, array, { silent: true });\n\n  	if (dependants = this.deps["default"][keypath.str]) {\n  		dependants.filter(canShuffle).forEach(function (d) {\n  			return d.shuffle(newIndices, array);\n  		});\n  	}\n\n  	if (oldLength !== array.length) {\n  		this.mark(keypath.join("length"), implicitOption);\n\n  		for (i = newIndices.touchedFrom; i < array.length; i += 1) {\n  			this.mark(keypath.join(i));\n  		}\n\n  		// don\'t allow removed indexes beyond end of new array to trigger recomputations\n  		// TODO is this still necessary, now that computations are lazy?\n  		for (i = array.length; i < oldLength; i += 1) {\n  			this.mark(keypath.join(i), noCascadeOption);\n  		}\n  	}\n  }\n\n  function canShuffle(dependant) {\n  	return typeof dependant.shuffle === "function";\n  }\n\n  var prototype_teardown = Viewmodel$teardown;\n\n  function Viewmodel$teardown() {\n  	var _this = this;\n\n  	var unresolvedImplicitDependency;\n\n  	// Clear entire cache - this has the desired side-effect\n  	// of unwrapping adapted values (e.g. arrays)\n  	Object.keys(this.cache).forEach(function (keypath) {\n  		return _this.clearCache(keypath);\n  	});\n\n  	// Teardown any failed lookups - we don\'t need them to resolve any more\n  	while (unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop()) {\n  		unresolvedImplicitDependency.teardown();\n  	}\n  }\n\n  var unregister = Viewmodel$unregister;\n\n  function Viewmodel$unregister(keypath, dependant) {\n  	var group = arguments[2] === undefined ? "default" : arguments[2];\n\n  	var mapping, deps, index;\n\n  	if (dependant.isStatic) {\n  		return;\n  	}\n\n  	if (mapping = this.mappings[keypath.firstKey]) {\n  		return mapping.unregister(keypath, dependant, group);\n  	}\n\n  	deps = this.deps[group][keypath.str];\n  	index = deps.indexOf(dependant);\n\n  	if (index === -1) {\n  		throw new Error("Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks");\n  	}\n\n  	deps.splice(index, 1);\n\n  	if (keypath.isRoot) {\n  		return;\n  	}\n\n  	unregister__updateDependantsMap(this, keypath, group);\n  }\n\n  function unregister__updateDependantsMap(viewmodel, keypath, group) {\n  	var map, parent;\n\n  	// update dependants map\n  	while (!keypath.isRoot) {\n  		map = viewmodel.depsMap[group];\n  		parent = map[keypath.parent.str];\n\n  		parent["_" + keypath.str] -= 1;\n\n  		if (!parent["_" + keypath.str]) {\n  			// remove from parent deps map\n  			removeFromArray(parent, keypath);\n  			parent["_" + keypath.str] = undefined;\n  		}\n\n  		keypath = keypath.parent;\n  	}\n  }\n\n  var Viewmodel = function (options) {\n  	var adapt = options.adapt;\n  	var data = options.data;\n  	var ractive = options.ractive;\n  	var computed = options.computed;\n  	var mappings = options.mappings;\n  	var key;\n  	var mapping;\n\n  	// TODO is it possible to remove this reference?\n  	this.ractive = ractive;\n\n  	this.adaptors = adapt;\n  	this.onchange = options.onchange;\n\n  	this.cache = {}; // we need to be able to use hasOwnProperty, so can\'t inherit from null\n  	this.cacheMap = create(null);\n\n  	this.deps = {\n  		computed: create(null),\n  		"default": create(null)\n  	};\n  	this.depsMap = {\n  		computed: create(null),\n  		"default": create(null)\n  	};\n\n  	this.patternObservers = [];\n\n  	this.specials = create(null);\n\n  	this.wrapped = create(null);\n  	this.computations = create(null);\n\n  	this.captureGroups = [];\n  	this.unresolvedImplicitDependencies = [];\n\n  	this.changes = [];\n  	this.implicitChanges = {};\n  	this.noCascade = {};\n\n  	this.data = data;\n\n  	// set up explicit mappings\n  	this.mappings = create(null);\n  	for (key in mappings) {\n  		this.map(getKeypath(key), mappings[key]);\n  	}\n\n  	if (data) {\n  		// if data exists locally, but is missing on the parent,\n  		// we transfer ownership to the parent\n  		for (key in data) {\n  			if ((mapping = this.mappings[key]) && mapping.getValue() === undefined) {\n  				mapping.setValue(data[key]);\n  			}\n  		}\n  	}\n\n  	for (key in computed) {\n  		if (mappings && key in mappings) {\n  			fatal("Cannot map to a computed property (\'%s\')", key);\n  		}\n\n  		this.compute(getKeypath(key), computed[key]);\n  	}\n\n  	this.ready = true;\n  };\n\n  Viewmodel.prototype = {\n  	adapt: prototype_adapt,\n  	applyChanges: applyChanges,\n  	capture: capture,\n  	clearCache: clearCache,\n  	compute: compute,\n  	get: viewmodel_prototype_get,\n  	init: viewmodel_prototype_init,\n  	map: prototype_map,\n  	mark: mark,\n  	merge: merge,\n  	register: register,\n  	release: release,\n  	reset: reset,\n  	set: prototype_set,\n  	smartUpdate: smartUpdate,\n  	teardown: prototype_teardown,\n  	unregister: unregister\n  };\n\n  var viewmodel_Viewmodel = Viewmodel;\n\n  function HookQueue(event) {\n  	this.hook = new hooks_Hook(event);\n  	this.inProcess = {};\n  	this.queue = {};\n  }\n\n  HookQueue.prototype = {\n\n  	constructor: HookQueue,\n\n  	begin: function (ractive) {\n  		this.inProcess[ractive._guid] = true;\n  	},\n\n  	end: function (ractive) {\n\n  		var parent = ractive.parent;\n\n  		// If this is *isn\'t* a child of a component that\'s in process,\n  		// it should call methods or fire at this point\n  		if (!parent || !this.inProcess[parent._guid]) {\n  			fire(this, ractive);\n  		}\n  		// elsewise, handoff to parent to fire when ready\n  		else {\n  			getChildQueue(this.queue, parent).push(ractive);\n  		}\n\n  		delete this.inProcess[ractive._guid];\n  	}\n  };\n\n  function getChildQueue(queue, ractive) {\n  	return queue[ractive._guid] || (queue[ractive._guid] = []);\n  }\n\n  function fire(hookQueue, ractive) {\n\n  	var childQueue = getChildQueue(hookQueue.queue, ractive);\n\n  	hookQueue.hook.fire(ractive);\n\n  	// queue is "live" because components can end up being\n  	// added while hooks fire on parents that modify data values.\n  	while (childQueue.length) {\n  		fire(hookQueue, childQueue.shift());\n  	}\n\n  	delete hookQueue.queue[ractive._guid];\n  }\n\n  var hooks_HookQueue = HookQueue;\n\n  var helpers_getComputationSignatures = getComputationSignatures;\n\n  var helpers_getComputationSignatures__pattern = /\\$\\{([^\\}]+)\\}/g;\n  function getComputationSignatures(ractive, computed) {\n  	var signatures = {},\n  	    key;\n\n  	for (key in computed) {\n  		signatures[key] = getComputationSignature(ractive, key, computed[key]);\n  	}\n\n  	return signatures;\n  }\n\n  function getComputationSignature(ractive, key, signature) {\n  	var getter, setter;\n\n  	if (typeof signature === "function") {\n  		getter = helpers_getComputationSignatures__bind(signature, ractive);\n  	}\n\n  	if (typeof signature === "string") {\n  		getter = createFunctionFromString(ractive, signature);\n  	}\n\n  	if (typeof signature === "object") {\n  		if (typeof signature.get === "string") {\n  			getter = createFunctionFromString(ractive, signature.get);\n  		} else if (typeof signature.get === "function") {\n  			getter = helpers_getComputationSignatures__bind(signature.get, ractive);\n  		} else {\n  			fatal("`%s` computation must have a `get()` method", key);\n  		}\n\n  		if (typeof signature.set === "function") {\n  			setter = helpers_getComputationSignatures__bind(signature.set, ractive);\n  		}\n  	}\n\n  	return { getter: getter, setter: setter };\n  }\n\n  function createFunctionFromString(ractive, str) {\n  	var functionBody, hasThis, fn;\n\n  	functionBody = "return (" + str.replace(helpers_getComputationSignatures__pattern, function (match, keypath) {\n  		hasThis = true;\n  		return "__ractive.get(\\"" + keypath + "\\")";\n  	}) + ");";\n\n  	if (hasThis) {\n  		functionBody = "var __ractive = this; " + functionBody;\n  	}\n\n  	fn = new Function(functionBody);\n  	return hasThis ? fn.bind(ractive) : fn;\n  }\n\n  function helpers_getComputationSignatures__bind(fn, context) {\n  	return /this/.test(fn.toString()) ? fn.bind(context) : fn;\n  }\n\n  var constructHook = new hooks_Hook("construct");\n  var configHook = new hooks_Hook("config");\n  var initHook = new hooks_HookQueue("init");\n  var initialise__uid = 0;\n\n  var initialise__registryNames = ["adaptors", "components", "decorators", "easing", "events", "interpolators", "partials", "transitions"];\n\n  var initialise = initialiseRactiveInstance;\n\n  function initialiseRactiveInstance(ractive) {\n  	var userOptions = arguments[1] === undefined ? {} : arguments[1];\n  	var options = arguments[2] === undefined ? {} : arguments[2];\n\n  	var el, viewmodel;\n\n  	if (_Ractive.DEBUG) {\n  		welcome();\n  	}\n\n  	initialiseProperties(ractive, options);\n\n  	// TODO remove this, eventually\n  	defineProperty(ractive, "data", { get: deprecateRactiveData });\n\n  	// TODO don\'t allow `onconstruct` with `new Ractive()`, there\'s no need for it\n  	constructHook.fire(ractive, userOptions);\n\n  	// Add registries\n  	initialise__registryNames.forEach(function (name) {\n  		ractive[name] = utils_object__extend(create(ractive.constructor[name] || null), userOptions[name]);\n  	});\n\n  	// Create a viewmodel\n  	viewmodel = new viewmodel_Viewmodel({\n  		adapt: getAdaptors(ractive, ractive.adapt, userOptions),\n  		data: custom_data.init(ractive.constructor, ractive, userOptions),\n  		computed: helpers_getComputationSignatures(ractive, utils_object__extend(create(ractive.constructor.prototype.computed), userOptions.computed)),\n  		mappings: options.mappings,\n  		ractive: ractive,\n  		onchange: function () {\n  			return global_runloop.addRactive(ractive);\n  		}\n  	});\n\n  	ractive.viewmodel = viewmodel;\n\n  	// This can\'t happen earlier, because computed properties may call `ractive.get()`, etc\n  	viewmodel.init();\n\n  	// init config from Parent and options\n  	config_config.init(ractive.constructor, ractive, userOptions);\n\n  	configHook.fire(ractive);\n  	initHook.begin(ractive);\n\n  	// // If this is a component with a function `data` property, call the function\n  	// // with `ractive` as context (unless the child was also a function)\n  	// if ( typeof ractive.constructor.prototype.data === \'function\' && typeof userOptions.data !== \'function\' ) {\n  	// 	viewmodel.reset( ractive.constructor.prototype.data.call( ractive ) || fatal( \'`data` functions must return a data object\' ) );\n  	// }\n\n  	// Render virtual DOM\n  	if (ractive.template) {\n  		var cssIds = undefined;\n\n  		if (options.cssIds || ractive.cssId) {\n  			cssIds = options.cssIds ? options.cssIds.slice() : [];\n\n  			if (ractive.cssId) {\n  				cssIds.push(ractive.cssId);\n  			}\n  		}\n\n  		ractive.fragment = new virtualdom_Fragment({\n  			template: ractive.template,\n  			root: ractive,\n  			owner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on\n  			cssIds: cssIds\n  		});\n  	}\n\n  	initHook.end(ractive);\n\n  	// render automatically ( if `el` is specified )\n  	if (el = getElement(ractive.el)) {\n  		var promise = ractive.render(el, ractive.append);\n\n  		if (_Ractive.DEBUG_PROMISES) {\n  			promise["catch"](function (err) {\n  				warnOnceIfDebug("Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;");\n  				warnIfDebug("An error happened during rendering", { ractive: ractive });\n  				err.stack && logIfDebug(err.stack);\n\n  				throw err;\n  			});\n  		}\n  	}\n  }\n\n  function getAdaptors(ractive, protoAdapt, userOptions) {\n  	var adapt, magic, modifyArrays;\n\n  	protoAdapt = protoAdapt.map(lookup);\n  	adapt = ensureArray(userOptions.adapt).map(lookup);\n\n  	adapt = initialise__combine(protoAdapt, adapt);\n\n  	magic = "magic" in userOptions ? userOptions.magic : ractive.magic;\n  	modifyArrays = "modifyArrays" in userOptions ? userOptions.modifyArrays : ractive.modifyArrays;\n\n  	if (magic) {\n  		if (!environment__magic) {\n  			throw new Error("Getters and setters (magic mode) are not supported in this browser");\n  		}\n\n  		if (modifyArrays) {\n  			adapt.push(magicArray);\n  		}\n\n  		adapt.push(adaptors_magic);\n  	}\n\n  	if (modifyArrays) {\n  		adapt.push(array_index);\n  	}\n\n  	return adapt;\n\n  	function lookup(adaptor) {\n  		if (typeof adaptor === "string") {\n  			adaptor = findInViewHierarchy("adaptors", ractive, adaptor);\n\n  			if (!adaptor) {\n  				fatal(missingPlugin(adaptor, "adaptor"));\n  			}\n  		}\n\n  		return adaptor;\n  	}\n  }\n\n  function initialise__combine(a, b) {\n  	var c = a.slice(),\n  	    i = b.length;\n\n  	while (i--) {\n  		if (! ~c.indexOf(b[i])) {\n  			c.push(b[i]);\n  		}\n  	}\n\n  	return c;\n  }\n\n  function initialiseProperties(ractive, options) {\n  	// Generate a unique identifier, for places where you\'d use a weak map if it\n  	// existed\n  	ractive._guid = "r-" + initialise__uid++;\n\n  	// events\n  	ractive._subs = create(null);\n\n  	// storage for item configuration from instantiation to reset,\n  	// like dynamic functions or original values\n  	ractive._config = {};\n\n  	// two-way bindings\n  	ractive._twowayBindings = create(null);\n\n  	// animations (so we can stop any in progress at teardown)\n  	ractive._animations = [];\n\n  	// nodes registry\n  	ractive.nodes = {};\n\n  	// live queries\n  	ractive._liveQueries = [];\n  	ractive._liveComponentQueries = [];\n\n  	// bound data functions\n  	ractive._boundFunctions = [];\n\n  	// observers\n  	ractive._observers = [];\n\n  	// properties specific to inline components\n  	if (options.component) {\n  		ractive.parent = options.parent;\n  		ractive.container = options.container || null;\n  		ractive.root = ractive.parent.root;\n\n  		ractive.component = options.component;\n  		options.component.instance = ractive;\n\n  		// for hackability, this could be an open option\n  		// for any ractive instance, but for now, just\n  		// for components and just for ractive...\n  		ractive._inlinePartials = options.inlinePartials;\n  	} else {\n  		ractive.root = ractive;\n  		ractive.parent = ractive.container = null;\n  	}\n  }\n\n  function deprecateRactiveData() {\n  	throw new Error("Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead");\n  }\n\n  function ComplexParameter(component, template, callback) {\n  	this.parentFragment = component.parentFragment;\n  	this.callback = callback;\n\n  	this.fragment = new virtualdom_Fragment({\n  		template: template,\n  		root: component.root,\n  		owner: this\n  	});\n\n  	this.update();\n  }\n\n  var initialise_ComplexParameter = ComplexParameter;\n\n  ComplexParameter.prototype = {\n  	bubble: function () {\n  		if (!this.dirty) {\n  			this.dirty = true;\n  			global_runloop.addView(this);\n  		}\n  	},\n\n  	update: function () {\n  		this.callback(this.fragment.getValue());\n  		this.dirty = false;\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		this.fragment.rebind(oldKeypath, newKeypath);\n  	},\n\n  	unbind: function () {\n  		this.fragment.unbind();\n  	}\n  };\n\n  var createInstance = function (component, Component, attributes, yieldTemplate, partials) {\n  	var instance,\n  	    parentFragment,\n  	    ractive,\n  	    fragment,\n  	    container,\n  	    inlinePartials = {},\n  	    data = {},\n  	    mappings = {},\n  	    ready,\n  	    resolvers = [];\n\n  	parentFragment = component.parentFragment;\n  	ractive = component.root;\n\n  	partials = partials || {};\n  	utils_object__extend(inlinePartials, partials);\n\n  	// Make contents available as a {{>content}} partial\n  	partials.content = yieldTemplate || [];\n\n  	// set a default partial for yields with no name\n  	inlinePartials[""] = partials.content;\n\n  	if (Component.defaults.el) {\n  		warnIfDebug("The <%s/> component has a default `el` property; it has been disregarded", component.name);\n  	}\n\n  	// find container\n  	fragment = parentFragment;\n  	while (fragment) {\n  		if (fragment.owner.type === YIELDER) {\n  			container = fragment.owner.container;\n  			break;\n  		}\n\n  		fragment = fragment.parent;\n  	}\n\n  	// each attribute represents either a) data or b) a mapping\n  	if (attributes) {\n  		Object.keys(attributes).forEach(function (key) {\n  			var attribute = attributes[key],\n  			    parsed,\n  			    resolver;\n\n  			if (typeof attribute === "string") {\n  				// it\'s static data\n  				parsed = parseJSON(attribute);\n  				data[key] = parsed ? parsed.value : attribute;\n  			} else if (attribute === 0) {\n  				// it had no \'=\', so we\'ll call it true\n  				data[key] = true;\n  			} else if (isArray(attribute)) {\n  				// this represents dynamic data\n  				if (isSingleInterpolator(attribute)) {\n  					mappings[key] = {\n  						origin: component.root.viewmodel,\n  						keypath: undefined\n  					};\n\n  					resolver = createResolver(component, attribute[0], function (keypath) {\n  						if (keypath.isSpecial) {\n  							if (ready) {\n  								instance.set(key, keypath.value); // TODO use viewmodel?\n  							} else {\n  								data[key] = keypath.value;\n\n  								// TODO errr.... would be better if we didn\'t have to do this\n  								delete mappings[key];\n  							}\n  						} else {\n  							if (ready) {\n  								instance.viewmodel.mappings[key].resolve(keypath);\n  							} else {\n  								// resolved immediately\n  								mappings[key].keypath = keypath;\n  							}\n  						}\n  					});\n  				} else {\n  					resolver = new initialise_ComplexParameter(component, attribute, function (value) {\n  						if (ready) {\n  							instance.set(key, value); // TODO use viewmodel?\n  						} else {\n  							data[key] = value;\n  						}\n  					});\n  				}\n\n  				resolvers.push(resolver);\n  			} else {\n  				throw new Error("erm wut");\n  			}\n  		});\n  	}\n\n  	instance = create(Component.prototype);\n\n  	initialise(instance, {\n  		el: null,\n  		append: true,\n  		data: data,\n  		partials: partials,\n  		magic: ractive.magic || Component.defaults.magic,\n  		modifyArrays: ractive.modifyArrays,\n  		// need to inherit runtime parent adaptors\n  		adapt: ractive.adapt\n  	}, {\n  		parent: ractive,\n  		component: component,\n  		container: container,\n  		mappings: mappings,\n  		inlinePartials: inlinePartials,\n  		cssIds: parentFragment.cssIds\n  	});\n\n  	ready = true;\n  	component.resolvers = resolvers;\n\n  	return instance;\n  };\n\n  function createResolver(component, template, callback) {\n  	var resolver;\n\n  	if (template.r) {\n  		resolver = Resolvers_createReferenceResolver(component, template.r, callback);\n  	} else if (template.x) {\n  		resolver = new Resolvers_ExpressionResolver(component, component.parentFragment, template.x, callback);\n  	} else if (template.rx) {\n  		resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(component, template.rx, callback);\n  	}\n\n  	return resolver;\n  }\n\n  function isSingleInterpolator(template) {\n  	return template.length === 1 && template[0].t === INTERPOLATOR;\n  }\n\n  // TODO how should event arguments be handled? e.g.\n  // <widget on-foo=\'bar:1,2,3\'/>\n  // The event \'bar\' will be fired on the parent instance\n  // when \'foo\' fires on the child, but the 1,2,3 arguments\n  // will be lost\n\n  var initialise_propagateEvents = propagateEvents;\n\n  function propagateEvents(component, eventsDescriptor) {\n  	var eventName;\n\n  	for (eventName in eventsDescriptor) {\n  		if (eventsDescriptor.hasOwnProperty(eventName)) {\n  			propagateEvent(component.instance, component.root, eventName, eventsDescriptor[eventName]);\n  		}\n  	}\n  }\n\n  function propagateEvent(childInstance, parentInstance, eventName, proxyEventName) {\n  	if (typeof proxyEventName !== "string") {\n  		fatal("Components currently only support simple events - you cannot include arguments. Sorry!");\n  	}\n\n  	childInstance.on(eventName, function () {\n  		var event, args;\n\n  		// semi-weak test, but what else? tag the event obj ._isEvent ?\n  		if (arguments.length && arguments[0] && arguments[0].node) {\n  			event = Array.prototype.shift.call(arguments);\n  		}\n\n  		args = Array.prototype.slice.call(arguments);\n\n  		shared_fireEvent(parentInstance, proxyEventName, { event: event, args: args });\n\n  		// cancel bubbling\n  		return false;\n  	});\n  }\n\n  var initialise_updateLiveQueries = function (component) {\n  	var ancestor, query;\n\n  	// If there\'s a live query for this component type, add it\n  	ancestor = component.root;\n  	while (ancestor) {\n  		if (query = ancestor._liveComponentQueries["_" + component.name]) {\n  			query.push(component.instance);\n  		}\n\n  		ancestor = ancestor.parent;\n  	}\n  };\n\n  var Component_prototype_init = Component$init;\n  function Component$init(options, Component) {\n  	var parentFragment, root;\n\n  	if (!Component) {\n  		throw new Error("Component \\"" + this.name + "\\" not found");\n  	}\n\n  	parentFragment = this.parentFragment = options.parentFragment;\n  	root = parentFragment.root;\n\n  	this.root = root;\n  	this.type = COMPONENT;\n  	this.name = options.template.e;\n  	this.index = options.index;\n  	this.indexRefBindings = {};\n  	this.yielders = {};\n  	this.resolvers = [];\n\n  	createInstance(this, Component, options.template.a, options.template.f, options.template.p);\n  	initialise_propagateEvents(this, options.template.v);\n\n  	// intro, outro and decorator directives have no effect\n  	if (options.template.t0 || options.template.t1 || options.template.t2 || options.template.o) {\n  		warnIfDebug("The \\"intro\\", \\"outro\\" and \\"decorator\\" directives have no effect on components", { ractive: this.instance });\n  	}\n\n  	initialise_updateLiveQueries(this);\n  }\n\n  var Component_prototype_rebind = Component$rebind;\n\n  function Component$rebind(oldKeypath, newKeypath) {\n  	var query;\n\n  	this.resolvers.forEach(rebind);\n\n  	for (var k in this.yielders) {\n  		if (this.yielders[k][0]) {\n  			rebind(this.yielders[k][0]);\n  		}\n  	}\n\n  	if (query = this.root._liveComponentQueries["_" + this.name]) {\n  		query._makeDirty();\n  	}\n\n  	function rebind(x) {\n  		x.rebind(oldKeypath, newKeypath);\n  	}\n  }\n\n  var Component_prototype_render = Component$render;\n\n  function Component$render() {\n  	var instance = this.instance;\n\n  	instance.render(this.parentFragment.getNode());\n\n  	this.rendered = true;\n  	return instance.fragment.detach();\n  }\n\n  var Component_prototype_toString = Component$toString;\n\n  function Component$toString() {\n  	return this.instance.fragment.toString();\n  }\n\n  var Component_prototype_unbind = Component$unbind;\n\n  var Component_prototype_unbind__teardownHook = new hooks_Hook("teardown");\n  function Component$unbind() {\n  	var instance = this.instance;\n\n  	this.resolvers.forEach(methodCallers__unbind);\n\n  	removeFromLiveComponentQueries(this);\n\n  	instance._observers.forEach(cancel);\n\n  	// teardown the instance\n  	instance.fragment.unbind();\n  	instance.viewmodel.teardown();\n\n  	if (instance.fragment.rendered && instance.el.__ractive_instances__) {\n  		removeFromArray(instance.el.__ractive_instances__, instance);\n  	}\n\n  	Component_prototype_unbind__teardownHook.fire(instance);\n  }\n\n  function removeFromLiveComponentQueries(component) {\n  	var instance, query;\n\n  	instance = component.root;\n\n  	do {\n  		if (query = instance._liveComponentQueries["_" + component.name]) {\n  			query._remove(component);\n  		}\n  	} while (instance = instance.parent);\n  }\n\n  var Component_prototype_unrender = Component$unrender;\n\n  function Component$unrender(shouldDestroy) {\n  	this.shouldDestroy = shouldDestroy;\n  	this.instance.unrender();\n  }\n\n  var Component = function (options, Constructor) {\n  	this.init(options, Constructor);\n  };\n\n  Component.prototype = {\n  	detach: Component_prototype_detach,\n  	find: Component_prototype_find,\n  	findAll: Component_prototype_findAll,\n  	findAllComponents: Component_prototype_findAllComponents,\n  	findComponent: Component_prototype_findComponent,\n  	findNextNode: Component_prototype_findNextNode,\n  	firstNode: Component_prototype_firstNode,\n  	init: Component_prototype_init,\n  	rebind: Component_prototype_rebind,\n  	render: Component_prototype_render,\n  	toString: Component_prototype_toString,\n  	unbind: Component_prototype_unbind,\n  	unrender: Component_prototype_unrender\n  };\n\n  var _Component = Component;\n\n  var Comment = function (options) {\n  	this.type = COMMENT;\n  	this.value = options.template.c;\n  };\n\n  Comment.prototype = {\n  	detach: shared_detach,\n\n  	firstNode: function () {\n  		return this.node;\n  	},\n\n  	render: function () {\n  		if (!this.node) {\n  			this.node = document.createComment(this.value);\n  		}\n\n  		return this.node;\n  	},\n\n  	toString: function () {\n  		return "<!--" + this.value + "-->";\n  	},\n\n  	unrender: function (shouldDestroy) {\n  		if (shouldDestroy) {\n  			this.node.parentNode.removeChild(this.node);\n  		}\n  	}\n  };\n\n  var items_Comment = Comment;\n\n  var Yielder = function (options) {\n  	var container, component;\n\n  	this.type = YIELDER;\n\n  	this.container = container = options.parentFragment.root;\n  	this.component = component = container.component;\n\n  	this.container = container;\n  	this.containerFragment = options.parentFragment;\n  	this.parentFragment = component.parentFragment;\n\n  	var name = this.name = options.template.n || "";\n\n  	var template = container._inlinePartials[name];\n\n  	if (!template) {\n  		warnIfDebug("Could not find template for partial \\"" + name + "\\"", { ractive: options.root });\n  		template = [];\n  	}\n\n  	this.fragment = new virtualdom_Fragment({\n  		owner: this,\n  		root: container.parent,\n  		template: template,\n  		pElement: this.containerFragment.pElement\n  	});\n\n  	// even though only one yielder is allowed, we need to have an array of them\n  	// as it\'s possible to cause a yielder to be created before the last one\n  	// was destroyed in the same turn of the runloop\n  	if (!isArray(component.yielders[name])) {\n  		component.yielders[name] = [this];\n  	} else {\n  		component.yielders[name].push(this);\n  	}\n\n  	global_runloop.scheduleTask(function () {\n  		if (component.yielders[name].length > 1) {\n  			throw new Error("A component template can only have one {{yield" + (name ? " " + name : "") + "}} declaration at a time");\n  		}\n  	});\n  };\n\n  Yielder.prototype = {\n  	detach: function () {\n  		return this.fragment.detach();\n  	},\n\n  	find: function (selector) {\n  		return this.fragment.find(selector);\n  	},\n\n  	findAll: function (selector, query) {\n  		return this.fragment.findAll(selector, query);\n  	},\n\n  	findComponent: function (selector) {\n  		return this.fragment.findComponent(selector);\n  	},\n\n  	findAllComponents: function (selector, query) {\n  		return this.fragment.findAllComponents(selector, query);\n  	},\n\n  	findNextNode: function () {\n  		return this.containerFragment.findNextNode(this);\n  	},\n\n  	firstNode: function () {\n  		return this.fragment.firstNode();\n  	},\n\n  	getValue: function (options) {\n  		return this.fragment.getValue(options);\n  	},\n\n  	render: function () {\n  		return this.fragment.render();\n  	},\n\n  	unbind: function () {\n  		this.fragment.unbind();\n  	},\n\n  	unrender: function (shouldDestroy) {\n  		this.fragment.unrender(shouldDestroy);\n  		removeFromArray(this.component.yielders[this.name], this);\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		this.fragment.rebind(oldKeypath, newKeypath);\n  	},\n\n  	toString: function () {\n  		return this.fragment.toString();\n  	}\n  };\n\n  var items_Yielder = Yielder;\n\n  var Doctype = function (options) {\n  	this.declaration = options.template.a;\n  };\n\n  Doctype.prototype = {\n  	init: noop,\n  	render: noop,\n  	unrender: noop,\n  	teardown: noop,\n  	toString: function () {\n  		return "<!DOCTYPE" + this.declaration + ">";\n  	}\n  };\n\n  var items_Doctype = Doctype;\n\n  var Fragment_prototype_init = Fragment$init;\n\n  function Fragment$init(options) {\n  	var _this = this;\n\n  	this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n  	this.parent = this.owner.parentFragment;\n\n  	// inherited properties\n  	this.root = options.root;\n  	this.pElement = options.pElement;\n  	this.context = options.context;\n  	this.index = options.index;\n  	this.key = options.key;\n  	this.registeredIndexRefs = [];\n\n  	// encapsulated styles should be inherited until they get applied by an element\n  	this.cssIds = "cssIds" in options ? options.cssIds : this.parent ? this.parent.cssIds : null;\n\n  	this.items = options.template.map(function (template, i) {\n  		return createItem({\n  			parentFragment: _this,\n  			pElement: options.pElement,\n  			template: template,\n  			index: i\n  		});\n  	});\n\n  	this.value = this.argsList = null;\n  	this.dirtyArgs = this.dirtyValue = true;\n\n  	this.bound = true;\n  }\n\n  function createItem(options) {\n  	if (typeof options.template === "string") {\n  		return new items_Text(options);\n  	}\n\n  	switch (options.template.t) {\n  		case YIELDER:\n  			return new items_Yielder(options);\n  		case INTERPOLATOR:\n  			return new items_Interpolator(options);\n  		case SECTION:\n  			return new _Section(options);\n  		case TRIPLE:\n  			return new _Triple(options);\n  		case ELEMENT:\n  			var constructor = undefined;\n  			if (constructor = Component_getComponent(options.parentFragment.root, options.template.e)) {\n  				return new _Component(options, constructor);\n  			}\n  			return new _Element(options);\n  		case PARTIAL:\n  			return new _Partial(options);\n  		case COMMENT:\n  			return new items_Comment(options);\n  		case DOCTYPE:\n  			return new items_Doctype(options);\n\n  		default:\n  			throw new Error("Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!");\n  	}\n  }\n\n  var Fragment_prototype_rebind = Fragment$rebind;\n  function Fragment$rebind(oldKeypath, newKeypath) {\n\n  	// assign new context keypath if needed\n  	if (!this.owner || this.owner.hasContext) {\n  		assignNewKeypath(this, "context", oldKeypath, newKeypath);\n  	}\n\n  	this.items.forEach(function (item) {\n  		if (item.rebind) {\n  			item.rebind(oldKeypath, newKeypath);\n  		}\n  	});\n  }\n\n  var Fragment_prototype_render = Fragment$render;\n\n  function Fragment$render() {\n  	var result;\n\n  	if (this.items.length === 1) {\n  		result = this.items[0].render();\n  	} else {\n  		result = document.createDocumentFragment();\n\n  		this.items.forEach(function (item) {\n  			result.appendChild(item.render());\n  		});\n  	}\n\n  	this.rendered = true;\n  	return result;\n  }\n\n  var Fragment_prototype_toString = Fragment$toString;\n\n  function Fragment$toString(escape) {\n  	if (!this.items) {\n  		return "";\n  	}\n\n  	return this.items.map(escape ? toEscapedString : Fragment_prototype_toString__toString).join("");\n  }\n\n  function Fragment_prototype_toString__toString(item) {\n  	return item.toString();\n  }\n\n  function toEscapedString(item) {\n  	return item.toString(true);\n  }\n\n  var Fragment_prototype_unbind = Fragment$unbind;\n\n  function Fragment$unbind() {\n  	if (!this.bound) {\n  		return;\n  	}\n\n  	this.items.forEach(unbindItem);\n  	this.bound = false;\n  }\n\n  function unbindItem(item) {\n  	if (item.unbind) {\n  		item.unbind();\n  	}\n  }\n\n  var Fragment_prototype_unrender = Fragment$unrender;\n\n  function Fragment$unrender(shouldDestroy) {\n  	if (!this.rendered) {\n  		throw new Error("Attempted to unrender a fragment that was not rendered");\n  	}\n\n  	this.items.forEach(function (i) {\n  		return i.unrender(shouldDestroy);\n  	});\n  	this.rendered = false;\n  }\n\n  var Fragment = function (options) {\n  	this.init(options);\n  };\n\n  Fragment.prototype = {\n  	bubble: prototype_bubble,\n  	detach: Fragment_prototype_detach,\n  	find: Fragment_prototype_find,\n  	findAll: Fragment_prototype_findAll,\n  	findAllComponents: Fragment_prototype_findAllComponents,\n  	findComponent: Fragment_prototype_findComponent,\n  	findNextNode: prototype_findNextNode,\n  	firstNode: prototype_firstNode,\n  	getArgsList: getArgsList,\n  	getNode: getNode,\n  	getValue: prototype_getValue,\n  	init: Fragment_prototype_init,\n  	rebind: Fragment_prototype_rebind,\n  	registerIndexRef: function (idx) {\n  		var idxs = this.registeredIndexRefs;\n  		if (idxs.indexOf(idx) === -1) {\n  			idxs.push(idx);\n  		}\n  	},\n  	render: Fragment_prototype_render,\n  	toString: Fragment_prototype_toString,\n  	unbind: Fragment_prototype_unbind,\n  	unregisterIndexRef: function (idx) {\n  		var idxs = this.registeredIndexRefs;\n  		idxs.splice(idxs.indexOf(idx), 1);\n  	},\n  	unrender: Fragment_prototype_unrender\n  };\n\n  var virtualdom_Fragment = Fragment;\n\n  var prototype_reset = Ractive$reset;\n  var shouldRerender = ["template", "partials", "components", "decorators", "events"],\n      resetHook = new hooks_Hook("reset");\n  function Ractive$reset(data) {\n  	var promise, wrapper, changes, i, rerender;\n\n  	data = data || {};\n\n  	if (typeof data !== "object") {\n  		throw new Error("The reset method takes either no arguments, or an object containing new data");\n  	}\n\n  	// If the root object is wrapped, try and use the wrapper\'s reset value\n  	if ((wrapper = this.viewmodel.wrapped[""]) && wrapper.reset) {\n  		if (wrapper.reset(data) === false) {\n  			// reset was rejected, we need to replace the object\n  			this.viewmodel.reset(data);\n  		}\n  	} else {\n  		this.viewmodel.reset(data);\n  	}\n\n  	// reset config items and track if need to rerender\n  	changes = config_config.reset(this);\n\n  	i = changes.length;\n  	while (i--) {\n  		if (shouldRerender.indexOf(changes[i]) > -1) {\n  			rerender = true;\n  			break;\n  		}\n  	}\n\n  	if (rerender) {\n  		var component = undefined;\n\n  		this.viewmodel.mark(rootKeypath);\n\n  		// Is this is a component, we need to set the `shouldDestroy`\n  		// flag, otherwise it will assume by default that a parent node\n  		// will be detached, and therefore it doesn\'t need to bother\n  		// detaching its own nodes\n  		if (component = this.component) {\n  			component.shouldDestroy = true;\n  		}\n\n  		this.unrender();\n\n  		if (component) {\n  			component.shouldDestroy = false;\n  		}\n\n  		// If the template changed, we need to destroy the parallel DOM\n  		// TODO if we\'re here, presumably it did?\n  		if (this.fragment.template !== this.template) {\n  			this.fragment.unbind();\n\n  			this.fragment = new virtualdom_Fragment({\n  				template: this.template,\n  				root: this,\n  				owner: this\n  			});\n  		}\n\n  		promise = this.render(this.el, this.anchor);\n  	} else {\n  		promise = global_runloop.start(this, true);\n  		this.viewmodel.mark(rootKeypath);\n  		global_runloop.end();\n  	}\n\n  	resetHook.fire(this, data);\n\n  	return promise;\n  }\n\n  var resetPartial = function (name, partial) {\n  	var promise,\n  	    collection = [];\n\n  	function collect(source, dest, ractive) {\n  		// if this is a component and it has its own partial, bail\n  		if (ractive && ractive.partials[name]) return;\n\n  		source.forEach(function (item) {\n  			// queue to rerender if the item is a partial and the current name matches\n  			if (item.type === PARTIAL && item.getPartialName() === name) {\n  				dest.push(item);\n  			}\n\n  			// if it has a fragment, process its items\n  			if (item.fragment) {\n  				collect(item.fragment.items, dest, ractive);\n  			}\n\n  			// or if it has fragments\n  			if (isArray(item.fragments)) {\n  				collect(item.fragments, dest, ractive);\n  			}\n\n  			// or if it is itself a fragment, process its items\n  			else if (isArray(item.items)) {\n  				collect(item.items, dest, ractive);\n  			}\n\n  			// or if it is a component, step in and process its items\n  			else if (item.type === COMPONENT && item.instance) {\n  				collect(item.instance.fragment.items, dest, item.instance);\n  			}\n\n  			// if the item is an element, process its attributes too\n  			if (item.type === ELEMENT) {\n  				if (isArray(item.attributes)) {\n  					collect(item.attributes, dest, ractive);\n  				}\n\n  				if (isArray(item.conditionalAttributes)) {\n  					collect(item.conditionalAttributes, dest, ractive);\n  				}\n  			}\n  		});\n  	}\n\n  	collect(this.fragment.items, collection);\n  	this.partials[name] = partial;\n\n  	promise = global_runloop.start(this, true);\n\n  	collection.forEach(function (item) {\n  		item.value = undefined;\n  		item.setValue(name);\n  	});\n\n  	global_runloop.end();\n\n  	return promise;\n  };\n\n  // TODO should resetTemplate be asynchronous? i.e. should it be a case\n  // of outro, update template, intro? I reckon probably not, since that\n  // could be achieved with unrender-resetTemplate-render. Also, it should\n  // conceptually be similar to resetPartial, which couldn\'t be async\n\n  var resetTemplate = Ractive$resetTemplate;\n  function Ractive$resetTemplate(template) {\n  	var transitionsEnabled, component;\n\n  	template_template.init(null, this, { template: template });\n\n  	transitionsEnabled = this.transitionsEnabled;\n  	this.transitionsEnabled = false;\n\n  	// Is this is a component, we need to set the `shouldDestroy`\n  	// flag, otherwise it will assume by default that a parent node\n  	// will be detached, and therefore it doesn\'t need to bother\n  	// detaching its own nodes\n  	if (component = this.component) {\n  		component.shouldDestroy = true;\n  	}\n\n  	this.unrender();\n\n  	if (component) {\n  		component.shouldDestroy = false;\n  	}\n\n  	// remove existing fragment and create new one\n  	this.fragment.unbind();\n  	this.fragment = new virtualdom_Fragment({\n  		template: this.template,\n  		root: this,\n  		owner: this\n  	});\n\n  	this.render(this.el, this.anchor);\n\n  	this.transitionsEnabled = transitionsEnabled;\n  }\n\n  var reverse = makeArrayMethod("reverse");\n\n  var Ractive_prototype_set = Ractive$set;\n\n  function Ractive$set(keypath, value) {\n  	var map, promise;\n\n  	promise = global_runloop.start(this, true);\n\n  	// Set multiple keypaths in one go\n  	if (isObject(keypath)) {\n  		map = keypath;\n\n  		for (keypath in map) {\n  			if (map.hasOwnProperty(keypath)) {\n  				value = map[keypath];\n  				set(this, keypath, value);\n  			}\n  		}\n  	}\n\n  	// Set a single keypath\n  	else {\n  		set(this, keypath, value);\n  	}\n\n  	global_runloop.end();\n\n  	return promise;\n  }\n\n  function set(ractive, keypath, value) {\n  	keypath = getKeypath(normalise(keypath));\n\n  	if (keypath.isPattern) {\n  		getMatchingKeypaths(ractive, keypath).forEach(function (keypath) {\n  			ractive.viewmodel.set(keypath, value);\n  		});\n  	} else {\n  		ractive.viewmodel.set(keypath, value);\n  	}\n  }\n\n  var shift = makeArrayMethod("shift");\n\n  var prototype_sort = makeArrayMethod("sort");\n\n  var splice = makeArrayMethod("splice");\n\n  var subtract = Ractive$subtract;\n  function Ractive$subtract(keypath, d) {\n  	return shared_add(this, keypath, d === undefined ? -1 : -d);\n  }\n\n  // Teardown. This goes through the root fragment and all its children, removing observers\n  // and generally cleaning up after itself\n\n  var Ractive_prototype_teardown = Ractive$teardown;\n\n  var Ractive_prototype_teardown__teardownHook = new hooks_Hook("teardown");\n  function Ractive$teardown() {\n  	var promise;\n\n  	this.fragment.unbind();\n  	this.viewmodel.teardown();\n\n  	this._observers.forEach(cancel);\n\n  	if (this.fragment.rendered && this.el.__ractive_instances__) {\n  		removeFromArray(this.el.__ractive_instances__, this);\n  	}\n\n  	this.shouldDestroy = true;\n  	promise = this.fragment.rendered ? this.unrender() : utils_Promise.resolve();\n\n  	Ractive_prototype_teardown__teardownHook.fire(this);\n\n  	this._boundFunctions.forEach(deleteFunctionCopy);\n\n  	return promise;\n  }\n\n  function deleteFunctionCopy(bound) {\n  	delete bound.fn[bound.prop];\n  }\n\n  var toggle = Ractive$toggle;\n  function Ractive$toggle(keypath) {\n  	var _this = this;\n\n  	if (typeof keypath !== "string") {\n  		throw new TypeError(badArguments);\n  	}\n\n  	var changes = undefined;\n\n  	if (/\\*/.test(keypath)) {\n  		changes = {};\n\n  		getMatchingKeypaths(this, getKeypath(normalise(keypath))).forEach(function (keypath) {\n  			changes[keypath.str] = !_this.viewmodel.get(keypath);\n  		});\n\n  		return this.set(changes);\n  	}\n\n  	return this.set(keypath, !this.get(keypath));\n  }\n\n  var toHTML = Ractive$toHTML;\n\n  function Ractive$toHTML() {\n  	return this.fragment.toString(true);\n  }\n\n  var Ractive_prototype_unrender = Ractive$unrender;\n  var unrenderHook = new hooks_Hook("unrender");\n  function Ractive$unrender() {\n  	var promise, shouldDestroy;\n\n  	if (!this.fragment.rendered) {\n  		warnIfDebug("ractive.unrender() was called on a Ractive instance that was not rendered");\n  		return utils_Promise.resolve();\n  	}\n\n  	promise = global_runloop.start(this, true);\n\n  	// If this is a component, and the component isn\'t marked for destruction,\n  	// don\'t detach nodes from the DOM unnecessarily\n  	shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\n  	// Cancel any animations in progress\n  	while (this._animations[0]) {\n  		this._animations[0].stop(); // it will remove itself from the index\n  	}\n\n  	this.fragment.unrender(shouldDestroy);\n\n  	removeFromArray(this.el.__ractive_instances__, this);\n\n  	unrenderHook.fire(this);\n\n  	global_runloop.end();\n  	return promise;\n  }\n\n  var unshift = makeArrayMethod("unshift");\n\n  var Ractive_prototype_update = Ractive$update;\n  var updateHook = new hooks_Hook("update");\n  function Ractive$update(keypath) {\n  	var promise;\n\n  	keypath = getKeypath(keypath) || rootKeypath;\n\n  	promise = global_runloop.start(this, true);\n  	this.viewmodel.mark(keypath);\n  	global_runloop.end();\n\n  	updateHook.fire(this, keypath);\n\n  	return promise;\n  }\n\n  var prototype_updateModel = Ractive$updateModel;\n\n  function Ractive$updateModel(keypath, cascade) {\n  	var values, key, bindings;\n\n  	if (typeof keypath === "string" && !cascade) {\n  		bindings = this._twowayBindings[keypath];\n  	} else {\n  		bindings = [];\n\n  		for (key in this._twowayBindings) {\n  			if (!keypath || getKeypath(key).equalsOrStartsWith(keypath)) {\n  				// TODO is this right?\n  				bindings.push.apply(bindings, this._twowayBindings[key]);\n  			}\n  		}\n  	}\n\n  	values = consolidate(this, bindings);\n  	return this.set(values);\n  }\n\n  function consolidate(ractive, bindings) {\n  	var values = {},\n  	    checkboxGroups = [];\n\n  	bindings.forEach(function (b) {\n  		var oldValue, newValue;\n\n  		// special case - radio name bindings\n  		if (b.radioName && !b.element.node.checked) {\n  			return;\n  		}\n\n  		// special case - checkbox name bindings come in groups, so\n  		// we want to get the value once at most\n  		if (b.checkboxName) {\n  			if (!checkboxGroups[b.keypath.str] && !b.changed()) {\n  				checkboxGroups.push(b.keypath);\n  				checkboxGroups[b.keypath.str] = b;\n  			}\n\n  			return;\n  		}\n\n  		oldValue = b.attribute.value;\n  		newValue = b.getValue();\n\n  		if (arrayContentsMatch(oldValue, newValue)) {\n  			return;\n  		}\n\n  		if (!isEqual(oldValue, newValue)) {\n  			values[b.keypath.str] = newValue;\n  		}\n  	});\n\n  	// Handle groups of `<input type=\'checkbox\' name=\'{{foo}}\' ...>`\n  	if (checkboxGroups.length) {\n  		checkboxGroups.forEach(function (keypath) {\n  			var binding, oldValue, newValue;\n\n  			binding = checkboxGroups[keypath.str]; // one to represent the entire group\n  			oldValue = binding.attribute.value;\n  			newValue = binding.getValue();\n\n  			if (!arrayContentsMatch(oldValue, newValue)) {\n  				values[keypath.str] = newValue;\n  			}\n  		});\n  	}\n\n  	return values;\n  }\n\n  var prototype = {\n  	add: prototype_add,\n  	animate: prototype_animate,\n  	detach: prototype_detach,\n  	find: prototype_find,\n  	findAll: prototype_findAll,\n  	findAllComponents: prototype_findAllComponents,\n  	findComponent: prototype_findComponent,\n  	findContainer: findContainer,\n  	findParent: findParent,\n  	fire: prototype_fire,\n  	get: prototype_get,\n  	insert: insert,\n  	merge: prototype_merge,\n  	observe: observe,\n  	observeOnce: observeOnce,\n  	off: off,\n  	on: on,\n  	once: once,\n  	pop: pop,\n  	push: push,\n  	render: prototype_render,\n  	reset: prototype_reset,\n  	resetPartial: resetPartial,\n  	resetTemplate: resetTemplate,\n  	reverse: reverse,\n  	set: Ractive_prototype_set,\n  	shift: shift,\n  	sort: prototype_sort,\n  	splice: splice,\n  	subtract: subtract,\n  	teardown: Ractive_prototype_teardown,\n  	toggle: toggle,\n  	toHTML: toHTML,\n  	toHtml: toHTML,\n  	unrender: Ractive_prototype_unrender,\n  	unshift: unshift,\n  	update: Ractive_prototype_update,\n  	updateModel: prototype_updateModel\n  };\n\n  var wrapMethod = function (method, superMethod, force) {\n\n  	if (force || needsSuper(method, superMethod)) {\n\n  		return function () {\n\n  			var hasSuper = ("_super" in this),\n  			    _super = this._super,\n  			    result;\n\n  			this._super = superMethod;\n\n  			result = method.apply(this, arguments);\n\n  			if (hasSuper) {\n  				this._super = _super;\n  			}\n\n  			return result;\n  		};\n  	} else {\n  		return method;\n  	}\n  };\n\n  function needsSuper(method, superMethod) {\n  	return typeof superMethod === "function" && /_super/.test(method);\n  }\n\n  var unwrapExtended = unwrap;\n\n  function unwrap(Child) {\n  	var options = {};\n\n  	while (Child) {\n  		addRegistries(Child, options);\n  		addOtherOptions(Child, options);\n\n  		if (Child._Parent !== _Ractive) {\n  			Child = Child._Parent;\n  		} else {\n  			Child = false;\n  		}\n  	}\n\n  	return options;\n  }\n\n  function addRegistries(Child, options) {\n  	config_registries.forEach(function (r) {\n  		addRegistry(r.useDefaults ? Child.prototype : Child, options, r.name);\n  	});\n  }\n\n  function addRegistry(target, options, name) {\n  	var registry,\n  	    keys = Object.keys(target[name]);\n\n  	if (!keys.length) {\n  		return;\n  	}\n\n  	if (!(registry = options[name])) {\n  		registry = options[name] = {};\n  	}\n\n  	keys.filter(function (key) {\n  		return !(key in registry);\n  	}).forEach(function (key) {\n  		return registry[key] = target[name][key];\n  	});\n  }\n\n  function addOtherOptions(Child, options) {\n  	Object.keys(Child.prototype).forEach(function (key) {\n  		if (key === "computed") {\n  			return;\n  		}\n\n  		var value = Child.prototype[key];\n\n  		if (!(key in options)) {\n  			options[key] = value._method ? value._method : value;\n  		}\n\n  		// is it a wrapped function?\n  		else if (typeof options[key] === "function" && typeof value === "function" && options[key]._method) {\n\n  			var result = undefined,\n  			    needsSuper = value._method;\n\n  			if (needsSuper) {\n  				value = value._method;\n  			}\n\n  			// rewrap bound directly to parent fn\n  			result = wrapMethod(options[key]._method, value);\n\n  			if (needsSuper) {\n  				result._method = result;\n  			}\n\n  			options[key] = result;\n  		}\n  	});\n  }\n\n  var _extend = _extend__extend;\n\n  function _extend__extend() {\n  	for (var _len = arguments.length, options = Array(_len), _key = 0; _key < _len; _key++) {\n  		options[_key] = arguments[_key];\n  	}\n\n  	if (!options.length) {\n  		return extendOne(this);\n  	} else {\n  		return options.reduce(extendOne, this);\n  	}\n  }\n\n  function extendOne(Parent) {\n  	var options = arguments[1] === undefined ? {} : arguments[1];\n\n  	var Child, proto;\n\n  	// if we\'re extending with another Ractive instance...\n  	//\n  	//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);\n  	//   var Spiderman = Human.extend( Spider );\n  	//\n  	// ...inherit prototype methods and default options as well\n  	if (options.prototype instanceof _Ractive) {\n  		options = unwrapExtended(options);\n  	}\n\n  	Child = function (options) {\n  		if (!(this instanceof Child)) return new Child(options);\n  		initialise(this, options);\n  	};\n\n  	proto = create(Parent.prototype);\n  	proto.constructor = Child;\n\n  	// Static properties\n  	defineProperties(Child, {\n  		// alias prototype as defaults\n  		defaults: { value: proto },\n\n  		// extendable\n  		extend: { value: _extend__extend, writable: true, configurable: true },\n\n  		// Parent - for IE8, can\'t use Object.getPrototypeOf\n  		_Parent: { value: Parent }\n  	});\n\n  	// extend configuration\n  	config_config.extend(Parent, proto, options);\n\n  	custom_data.extend(Parent, proto, options);\n\n  	if (options.computed) {\n  		proto.computed = utils_object__extend(create(Parent.prototype.computed), options.computed);\n  	}\n\n  	Child.prototype = proto;\n\n  	return Child;\n  }\n\n  var getNodeInfo = function (node) {\n  	var info = {},\n  	    priv,\n  	    indices;\n\n  	if (!node || !(priv = node._ractive)) {\n  		return info;\n  	}\n\n  	info.ractive = priv.root;\n  	info.keypath = priv.keypath.str;\n  	info.index = {};\n\n  	// find all index references and resolve them\n  	if (indices = Resolvers_findIndexRefs(priv.proxy.parentFragment)) {\n  		info.index = Resolvers_findIndexRefs.resolve(indices);\n  	}\n\n  	return info;\n  };\n\n  var Ractive, properties;\n\n  // Main Ractive required object\n  Ractive = function (options) {\n  	if (!(this instanceof Ractive)) return new Ractive(options);\n  	initialise(this, options);\n  };\n\n  // Ractive properties\n  properties = {\n\n  	// debug flag\n  	DEBUG: { writable: true, value: true },\n  	DEBUG_PROMISES: { writable: true, value: true },\n\n  	// static methods:\n  	extend: { value: _extend },\n  	getNodeInfo: { value: getNodeInfo },\n  	parse: { value: _parse },\n\n  	// Namespaced constructors\n  	Promise: { value: utils_Promise },\n\n  	// support\n  	svg: { value: svg },\n  	magic: { value: environment__magic },\n\n  	// version\n  	VERSION: { value: "0.7.2" },\n\n  	// Plugins\n  	adaptors: { writable: true, value: {} },\n  	components: { writable: true, value: {} },\n  	decorators: { writable: true, value: {} },\n  	easing: { writable: true, value: static_easing },\n  	events: { writable: true, value: {} },\n  	interpolators: { writable: true, value: static_interpolators },\n  	partials: { writable: true, value: {} },\n  	transitions: { writable: true, value: {} }\n  };\n\n  // Ractive properties\n  defineProperties(Ractive, properties);\n\n  Ractive.prototype = utils_object__extend(prototype, config_defaults);\n\n  Ractive.prototype.constructor = Ractive;\n\n  // alias prototype as defaults\n  Ractive.defaults = Ractive.prototype;\n\n  // Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n  // older browsers, these are made available via a shim - here, we do a quick\n  // pre-flight check to make sure that either a) we\'re not in a shit browser,\n  // or b) we\'re using a Ractive-legacy.js build\n  var FUNCTION = "function";\n\n  if (typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== "undefined" && typeof window.addEventListener !== FUNCTION) {\n  	throw new Error("It looks like you\'re attempting to use Ractive.js in an older browser. You\'ll need to use one of the \'legacy builds\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.");\n  }\n\n  var _Ractive = Ractive;\n\n  return _Ractive;\n\n}));\n//# sourceMappingURL=ractive.js.map\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JhY3RpdmUvcmFjdGl2ZS5qcz9mMGIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjs7QUFFckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyw2QkFBNkI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekIsMEJBQTBCLE9BQU87QUFDakM7O0FBRUE7QUFDQSxXQUFXO0FBQ1gsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCLFdBQVcsV0FBVztBQUNqRDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsV0FBVyxXQUFXOztBQUVqRDtBQUNBLGtFQUFrRSxXQUFXO0FBQzdFOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLEdBQUcsUUFBUSxXQUFXLEVBQUU7QUFDdEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxRQUFRLFdBQVcsRUFBRTtBQUN4RTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSx3RkFBd0YsYUFBYTtBQUNyRztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3RkFBd0YsYUFBYTtBQUNyRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxR0FBcUcscUJBQXFCLDJCQUEyQixxQkFBcUIsMkJBQTJCLHFCQUFxQiw2QkFBNkIscUJBQXFCLDRCQUE0QjtBQUN4UyxrUUFBa1EsdUhBQXVILGVBQWUsRUFBRTs7QUFFMVk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRkFBMEYsMkJBQTJCO0FBQ3JIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxxRkFBcUYsYUFBYTtBQUNsRztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUZBQXFGLGFBQWE7QUFDbEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRkFBcUYsYUFBYTtBQUNsRztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBOztBQUVBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHFEQUFxRDtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVTtBQUNWLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0wsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7O0FBRUEsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsa0JBQWtCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBLGlCQUFpQjtBQUNqQixJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxXQUFXLGNBQWM7O0FBRXpCLHdCQUF3QiwwQkFBMEI7QUFDbEQsWUFBWTtBQUNaLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSwwQkFBMEI7O0FBRXZDLFlBQVksaUJBQWlCO0FBQzdCLFlBQVksY0FBYztBQUMxQixpQkFBaUIseUJBQXlCO0FBQzFDLGNBQWMsZ0JBQWdCOztBQUU5QixhQUFhO0FBQ2IsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhCQUE4QixRQUFRO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEdBQUcsK0NBQStDOztBQUV0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNENBQTRDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBOztBQUVBLFNBQVMsZUFBZTtBQUN4QjtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNGQUFzRixhQUFhO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWlDLFVBQVUsRUFBRSxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxZQUFZO0FBQy9EO0FBQ0E7O0FBRUEscUNBQXFDLFdBQVc7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBPQUEwTyxjQUFjLG9CQUFvQixRQUFRLEtBQUsscUNBQXFDLGtCQUFrQixLQUFLO0FBQ3JWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLGNBQWMsd0JBQXdCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUUsRUFBRSxjQUFjLEVBQUU7O0FBRXZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpREFBaUQ7QUFDakQ7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx3REFBd0Q7O0FBRXZFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYiw4Q0FBOEM7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYiw4Q0FBOEM7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLCtDQUErQzs7QUFFL0M7O0FBRUEsOENBQThDLFVBQVU7QUFDeEQseUJBQXlCLGFBQWEsUUFBUSxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixvREFBb0Q7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGVBQWU7QUFDZixJQUFJO0FBQ0osZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLE1BQU0sa0JBQWtCLFNBQVM7QUFDdkQ7O0FBRUE7QUFDQSw4QkFBOEIsV0FBVyxTQUFTLE1BQU07QUFDeEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLE1BQU0sa0JBQWtCLFNBQVM7QUFDdkQ7O0FBRUE7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEMseUJBQXlCLE1BQU07QUFDL0IsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0EsbUdBQW1HOztBQUVuRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLDBCQUEwQiw2QkFBNkI7QUFDeEY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxHQUFHO0FBQ3pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksRUFBRTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksRUFBRTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUssS0FBSztBQUN0QyxvQ0FBb0MsS0FBSyxLQUFLO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1osSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNkJBQTZCO0FBQzdCLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDhCQUE4QjtBQUM5QixjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0MsR0FBRztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnRUFBZ0U7QUFDcEYsaUJBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsU0FBUyxhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCwwRUFBMEU7QUFDN0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhFQUE4RSx1QkFBdUIsT0FBTyxVQUFVLGtDQUFrQyxlQUFlLGdCQUFnQixlQUFlOztBQUV0TTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QywwRUFBMEU7QUFDdkg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpR0FBaUc7O0FBRWpHO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTRELE9BQU87QUFDbkU7QUFDQTs7QUFFQSx3REFBd0QsTUFBTTs7QUFFOUQsa0JBQWtCLG1JQUFtSSxHQUFHLGtIQUFrSCxHQUFHLGtIQUFrSCxHQUFHLDZIQUE2SDs7QUFFL2Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbURBQW1ELGNBQWM7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxzQkFBc0I7QUFDcEMsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQsY0FBYywrQkFBK0I7QUFDN0MsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCxvQ0FBb0M7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNFQUFzRTtBQUM5Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7O0FBRUE7O0FBRUEsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHdEQUF3RDtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0Msd0JBQXdCLHVCQUF1QjtBQUNuRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCLG1CQUFtQjs7QUFFM0U7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixTQUFTOztBQUVqQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDLHlJQUF5SSxxQkFBcUI7QUFDOUo7QUFDQTs7QUFFQTtBQUNBLDBGQUEwRixxQkFBcUI7QUFDL0c7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGlCQUFpQixLQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEtBQTBLLHFCQUFxQjtBQUMvTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQixJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBLG1CQUFtQiwwQkFBMEI7QUFDN0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxtQkFBbUIsMEJBQTBCO0FBQzdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3SEFBd0gsd0JBQXdCO0FBQ2hKOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCxrQ0FBa0M7QUFDcEY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsMkJBQTJCO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFELGtCQUFrQjtBQUN2RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSkFBMEosZUFBZTtBQUN6SyxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxJQUFJO0FBQ0o7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMLGVBQWU7QUFDZixLQUFLO0FBQ0wsZUFBZTtBQUNmO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkZBQTZGLHFCQUFxQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxnQkFBZ0I7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVFQUF1RSxtQkFBbUI7QUFDMUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSyxpREFBaUQsbUJBQW1CO0FBQ3ZHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxvREFBb0Qsb0RBQW9EO0FBQ3hHLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZFQUE2RSxtQkFBbUI7O0FBRWhHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsV0FBVyxXQUFXOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxnREFBZ0QsNEJBQTRCO0FBQzVFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCO0FBQ3hCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJEQUEyRDtBQUN2Rzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLG9CQUFvQixpREFBaUQ7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxhQUFhLE1BQU07QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSiw4REFBOEQ7QUFDOUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUFnRDs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxlQUFlO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixpQkFBaUI7QUFDekMseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLDZCQUE2QixlQUFlOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVEQUF1RCxLQUFLLEtBQUs7QUFDakU7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTzs7QUFFWDtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BELGdEQUFnRDs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DLDRCQUE0Qjs7QUFFaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxVQUFVO0FBQ25FO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscVBBQXFQO0FBQ3JQLHlEQUF5RCxtQkFBbUI7QUFDNUU7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLFVBQVU7QUFDL0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRTtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzREFBc0QsMkJBQTJCOztBQUVqRjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUdBQXVHLHlCQUF5QjtBQUNoSTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EseUVBQXlFLHdCQUF3QjtBQUNqRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStELHVDQUF1QztBQUN0RztBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMscUJBQXFCOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosdURBQXVELEtBQUs7QUFDNUQ7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0EscUVBQXFFLGFBQWE7QUFDbEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlOztBQUU5QjtBQUNBLGFBQWEsNkRBQTZEOztBQUUxRTtBQUNBLGNBQWM7QUFDZCxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyw4QkFBOEI7QUFDekMsb0JBQW9CLDhCQUE4Qjs7QUFFbEQ7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixpQkFBaUIscUJBQXFCO0FBQ3RDLFdBQVcsZ0JBQWdCOztBQUUzQjtBQUNBLGFBQWEsdUJBQXVCOztBQUVwQztBQUNBLFNBQVMsYUFBYTtBQUN0QixXQUFXLDRCQUE0Qjs7QUFFdkM7QUFDQSxhQUFhLGlCQUFpQjs7QUFFOUI7QUFDQSxjQUFjLDBCQUEwQixFQUFFO0FBQzFDLGdCQUFnQiwwQkFBMEIsRUFBRTtBQUM1QyxnQkFBZ0IsMEJBQTBCLEVBQUU7QUFDNUMsWUFBWSx1Q0FBdUM7QUFDbkQsWUFBWSwwQkFBMEIsRUFBRTtBQUN4QyxtQkFBbUIsOENBQThDO0FBQ2pFLGNBQWMsMEJBQTBCLEVBQUU7QUFDMUMsaUJBQWlCLDBCQUEwQjtBQUMzQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEIiwiZmlsZSI6IjU2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0UmFjdGl2ZS5qcyB2MC43LjJcblx0VGh1IEFwciAwMiAyMDE1IDEzOjUzOjU2IEdNVC0wNDAwIChFRFQpIC0gY29tbWl0IDhiYWU0Njg5ZGIxYmI1NGNlMDgwNDY5N2I2NmM2NTg2MzlhNTNlOTNcblxuXHRodHRwOi8vcmFjdGl2ZWpzLm9yZ1xuXHRodHRwOi8vdHdpdHRlci5jb20vUmFjdGl2ZUpTXG5cblx0UmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICBnbG9iYWwuUmFjdGl2ZSA9IGZhY3RvcnkoKVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgVEVNUExBVEVfVkVSU0lPTiA9IDM7XG5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuXG4gIFx0Ly8gcmVuZGVyIHBsYWNlbWVudDpcbiAgXHRlbDogdm9pZCAwLFxuICBcdGFwcGVuZDogZmFsc2UsXG5cbiAgXHQvLyB0ZW1wbGF0ZTpcbiAgXHR0ZW1wbGF0ZTogeyB2OiBURU1QTEFURV9WRVJTSU9OLCB0OiBbXSB9LFxuXG4gIFx0Ly8gcGFyc2U6ICAgICAvLyBUT0RPIHN0YXRpYyBkZWxpbWl0ZXJzP1xuICBcdHByZXNlcnZlV2hpdGVzcGFjZTogZmFsc2UsXG4gIFx0c2FuaXRpemU6IGZhbHNlLFxuICBcdHN0cmlwQ29tbWVudHM6IHRydWUsXG4gIFx0ZGVsaW1pdGVyczogW1wie3tcIiwgXCJ9fVwiXSxcbiAgXHR0cmlwbGVEZWxpbWl0ZXJzOiBbXCJ7e3tcIiwgXCJ9fX1cIl0sXG4gIFx0aW50ZXJwb2xhdGU6IGZhbHNlLFxuXG4gIFx0Ly8gZGF0YSAmIGJpbmRpbmc6XG4gIFx0ZGF0YToge30sXG4gIFx0Y29tcHV0ZWQ6IHt9LFxuICBcdG1hZ2ljOiBmYWxzZSxcbiAgXHRtb2RpZnlBcnJheXM6IHRydWUsXG4gIFx0YWRhcHQ6IFtdLFxuICBcdGlzb2xhdGVkOiBmYWxzZSxcbiAgXHR0d293YXk6IHRydWUsXG4gIFx0bGF6eTogZmFsc2UsXG5cbiAgXHQvLyB0cmFuc2l0aW9uczpcbiAgXHRub0ludHJvOiBmYWxzZSxcbiAgXHR0cmFuc2l0aW9uc0VuYWJsZWQ6IHRydWUsXG4gIFx0Y29tcGxldGU6IHZvaWQgMCxcblxuICBcdC8vIGNzczpcbiAgXHRjc3M6IG51bGwsXG4gIFx0bm9Dc3NUcmFuc2Zvcm06IGZhbHNlXG4gIH07XG5cbiAgdmFyIGNvbmZpZ19kZWZhdWx0cyA9IGRlZmF1bHRPcHRpb25zO1xuXG4gIC8vIFRoZXNlIGFyZSBhIHN1YnNldCBvZiB0aGUgZWFzaW5nIGVxdWF0aW9ucyBmb3VuZCBhdFxuICAvLyBodHRwczovL3Jhdy5naXRodWIuY29tL2RhbnJvL2Vhc2luZy1qcyAtIGxpY2Vuc2UgaW5mb1xuICAvLyBmb2xsb3dzOlxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGVhc2luZy5qcyB2MC41LjRcbiAgLy8gR2VuZXJpYyBzZXQgb2YgZWFzaW5nIGZ1bmN0aW9ucyB3aXRoIEFNRCBzdXBwb3J0XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5yby9lYXNpbmctanNcbiAgLy8gVGhpcyBjb2RlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gIC8vIGh0dHA6Ly9kYW5yby5taXQtbGljZW5zZS5vcmcvXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEFsbCBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFRob21hcyBGdWNocyAmIEplcmVteSBLYWhuXG4gIC8vIEVhc2luZyBFcXVhdGlvbnMgKGMpIDIwMDMgUm9iZXJ0IFBlbm5lciwgQlNEIGxpY2Vuc2VcbiAgLy8gaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9kYW5yby9lYXNpbmctanMvbWFzdGVyL0xJQ0VOU0VcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBJbiB0aGF0IGxpYnJhcnksIHRoZSBmdW5jdGlvbnMgbmFtZWQgZWFzZUluLCBlYXNlT3V0LCBhbmRcbiAgLy8gZWFzZUluT3V0IGJlbG93IGFyZSBuYW1lZCBlYXNlSW5DdWJpYywgZWFzZU91dEN1YmljLCBhbmRcbiAgLy8gKHlvdSBndWVzc2VkIGl0KSBlYXNlSW5PdXRDdWJpYy5cbiAgLy9cbiAgLy8gWW91IGNhbiBhZGQgYWRkaXRpb25hbCBlYXNpbmcgZnVuY3Rpb25zIHRvIHRoaXMgbGlzdCwgYW5kIHRoZXlcbiAgLy8gd2lsbCBiZSBnbG9iYWxseSBhdmFpbGFibGUuXG5cbiAgdmFyIHN0YXRpY19lYXNpbmcgPSB7XG4gIFx0bGluZWFyOiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHRyZXR1cm4gcG9zO1xuICBcdH0sXG4gIFx0ZWFzZUluOiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHRyZXR1cm4gTWF0aC5wb3cocG9zLCAzKTtcbiAgXHR9LFxuICBcdGVhc2VPdXQ6IGZ1bmN0aW9uIChwb3MpIHtcbiAgXHRcdHJldHVybiBNYXRoLnBvdyhwb3MgLSAxLCAzKSArIDE7XG4gIFx0fSxcbiAgXHRlYXNlSW5PdXQ6IGZ1bmN0aW9uIChwb3MpIHtcbiAgXHRcdGlmICgocG9zIC89IDAuNSkgPCAxKSB7XG4gIFx0XHRcdHJldHVybiAwLjUgKiBNYXRoLnBvdyhwb3MsIDMpO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIDAuNSAqIChNYXRoLnBvdyhwb3MgLSAyLCAzKSArIDIpO1xuICBcdH1cbiAgfTtcblxuICAvKmdsb2JhbCBjb25zb2xlLCBuYXZpZ2F0b3IgKi9cbiAgdmFyIGlzQ2xpZW50LCBpc0pzZG9tLCBoYXNDb25zb2xlLCBlbnZpcm9ubWVudF9fbWFnaWMsIG5hbWVzcGFjZXMsIHN2ZywgdmVuZG9ycztcblxuICBpc0NsaWVudCA9IHR5cGVvZiBkb2N1bWVudCA9PT0gXCJvYmplY3RcIjtcblxuICBpc0pzZG9tID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvanNEb20vLnRlc3QobmF2aWdhdG9yLmFwcE5hbWUpO1xuXG4gIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS53YXJuID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGNvbnNvbGUud2Fybi5hcHBseSA9PT0gXCJmdW5jdGlvblwiO1xuXG4gIHRyeSB7XG4gIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInRlc3RcIiwgeyB2YWx1ZTogMCB9KTtcbiAgXHRlbnZpcm9ubWVudF9fbWFnaWMgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gIFx0ZW52aXJvbm1lbnRfX21hZ2ljID0gZmFsc2U7XG4gIH1cblxuICBuYW1lc3BhY2VzID0ge1xuICBcdGh0bWw6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLFxuICBcdG1hdGhtbDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIsXG4gIFx0c3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIFx0eGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICBcdHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgXHR4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG4gIH07XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBcdHN2ZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICBcdHN2ZyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0Jhc2ljU3RydWN0dXJlXCIsIFwiMS4xXCIpO1xuICB9XG5cbiAgdmVuZG9ycyA9IFtcIm9cIiwgXCJtc1wiLCBcIm1velwiLCBcIndlYmtpdFwiXTtcblxuICB2YXIgY3JlYXRlRWxlbWVudCwgbWF0Y2hlcywgZG9tX19kaXYsIG1ldGhvZE5hbWVzLCB1bnByZWZpeGVkLCBwcmVmaXhlZCwgZG9tX19pLCBqLCBtYWtlRnVuY3Rpb247XG5cbiAgLy8gVGVzdCBmb3IgU1ZHIHN1cHBvcnRcbiAgaWYgKCFzdmcpIHtcbiAgXHRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIG5zKSB7XG4gIFx0XHRpZiAobnMgJiYgbnMgIT09IG5hbWVzcGFjZXMuaHRtbCkge1xuICBcdFx0XHR0aHJvdyBcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG5hbWVzcGFjZXMgb3RoZXIgdGhhbiBodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sLiBUaGUgbW9zdCBsaWtlbHkgY2F1c2Ugb2YgdGhpcyBlcnJvciBpcyB0aGF0IHlvdSdyZSB0cnlpbmcgdG8gcmVuZGVyIFNWRyBpbiBhbiBvbGRlciBicm93c2VyLiBTZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3Qvc3ZnLWFuZC1vbGRlci1icm93c2VycyBmb3IgbW9yZSBpbmZvcm1hdGlvblwiO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgXHR9O1xuICB9IGVsc2Uge1xuICBcdGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgbnMpIHtcbiAgXHRcdGlmICghbnMgfHwgbnMgPT09IG5hbWVzcGFjZXMuaHRtbCkge1xuICBcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgdHlwZSk7XG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnQoaW5wdXQpIHtcbiAgXHR2YXIgb3V0cHV0O1xuXG4gIFx0aWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgPT09IFwiYm9vbGVhblwiKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgIWRvY3VtZW50IHx8ICFpbnB1dCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gV2UgYWxyZWFkeSBoYXZlIGEgRE9NIG5vZGUgLSBubyB3b3JrIHRvIGRvLiAoRHVjayB0eXBpbmcgYWxlcnQhKVxuICBcdGlmIChpbnB1dC5ub2RlVHlwZSkge1xuICBcdFx0cmV0dXJuIGlucHV0O1xuICBcdH1cblxuICBcdC8vIEdldCBub2RlIGZyb20gc3RyaW5nXG4gIFx0aWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0Ly8gdHJ5IElEIGZpcnN0XG4gIFx0XHRvdXRwdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpbnB1dCk7XG5cbiAgXHRcdC8vIHRoZW4gYXMgc2VsZWN0b3IsIGlmIHBvc3NpYmxlXG4gIFx0XHRpZiAoIW91dHB1dCAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKSB7XG4gIFx0XHRcdG91dHB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaW5wdXQpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBkaWQgaXQgd29yaz9cbiAgXHRcdGlmIChvdXRwdXQgJiYgb3V0cHV0Lm5vZGVUeXBlKSB7XG4gIFx0XHRcdHJldHVybiBvdXRwdXQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gSWYgd2UndmUgYmVlbiBnaXZlbiBhIGNvbGxlY3Rpb24gKGpRdWVyeSwgWmVwdG8gZXRjKSwgZXh0cmFjdCB0aGUgZmlyc3QgaXRlbVxuICBcdGlmIChpbnB1dFswXSAmJiBpbnB1dFswXS5ub2RlVHlwZSkge1xuICBcdFx0cmV0dXJuIGlucHV0WzBdO1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCFpc0NsaWVudCkge1xuICBcdG1hdGNoZXMgPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdGRvbV9fZGl2ID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgXHRtZXRob2ROYW1lcyA9IFtcIm1hdGNoZXNcIiwgXCJtYXRjaGVzU2VsZWN0b3JcIl07XG5cbiAgXHRtYWtlRnVuY3Rpb24gPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICBcdFx0cmV0dXJuIGZ1bmN0aW9uIChub2RlLCBzZWxlY3Rvcikge1xuICBcdFx0XHRyZXR1cm4gbm9kZVttZXRob2ROYW1lXShzZWxlY3Rvcik7XG4gIFx0XHR9O1xuICBcdH07XG5cbiAgXHRkb21fX2kgPSBtZXRob2ROYW1lcy5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoZG9tX19pLS0gJiYgIW1hdGNoZXMpIHtcbiAgXHRcdHVucHJlZml4ZWQgPSBtZXRob2ROYW1lc1tkb21fX2ldO1xuXG4gIFx0XHRpZiAoZG9tX19kaXZbdW5wcmVmaXhlZF0pIHtcbiAgXHRcdFx0bWF0Y2hlcyA9IG1ha2VGdW5jdGlvbih1bnByZWZpeGVkKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGogPSB2ZW5kb3JzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGotLSkge1xuICBcdFx0XHRcdHByZWZpeGVkID0gdmVuZG9yc1tkb21fX2ldICsgdW5wcmVmaXhlZC5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIHVucHJlZml4ZWQuc3Vic3RyaW5nKDEpO1xuXG4gIFx0XHRcdFx0aWYgKGRvbV9fZGl2W3ByZWZpeGVkXSkge1xuICBcdFx0XHRcdFx0bWF0Y2hlcyA9IG1ha2VGdW5jdGlvbihwcmVmaXhlZCk7XG4gIFx0XHRcdFx0XHRicmVhaztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBJRTguLi5cbiAgXHRpZiAoIW1hdGNoZXMpIHtcbiAgXHRcdG1hdGNoZXMgPSBmdW5jdGlvbiAobm9kZSwgc2VsZWN0b3IpIHtcbiAgXHRcdFx0dmFyIG5vZGVzLCBwYXJlbnROb2RlLCBpO1xuXG4gIFx0XHRcdHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cbiAgXHRcdFx0aWYgKCFwYXJlbnROb2RlKSB7XG4gIFx0XHRcdFx0Ly8gZW1wdHkgZHVtbXkgPGRpdj5cbiAgXHRcdFx0XHRkb21fX2Rpdi5pbm5lckhUTUwgPSBcIlwiO1xuXG4gIFx0XHRcdFx0cGFyZW50Tm9kZSA9IGRvbV9fZGl2O1xuICBcdFx0XHRcdG5vZGUgPSBub2RlLmNsb25lTm9kZSgpO1xuXG4gIFx0XHRcdFx0ZG9tX19kaXYuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRub2RlcyA9IHBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cbiAgXHRcdFx0aSA9IG5vZGVzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGlmIChub2Rlc1tpXSA9PT0gbm9kZSkge1xuICBcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hOb2RlKG5vZGUpIHtcbiAgXHRpZiAobm9kZSAmJiB0eXBlb2Ygbm9kZS5wYXJlbnROb2RlICE9PSBcInVua25vd25cIiAmJiBub2RlLnBhcmVudE5vZGUpIHtcbiAgXHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVUb1N0cmluZ1ZhbHVlKHZhbHVlKSB7XG4gIFx0cmV0dXJuIHZhbHVlID09IG51bGwgfHwgIXZhbHVlLnRvU3RyaW5nID8gXCJcIiA6IHZhbHVlO1xuICB9XG5cbiAgdmFyIGxlZ2FjeSA9IG51bGw7XG5cbiAgdmFyIGNyZWF0ZSwgZGVmaW5lUHJvcGVydHksIGRlZmluZVByb3BlcnRpZXM7XG5cbiAgdHJ5IHtcbiAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwidGVzdFwiLCB7IHZhbHVlOiAwIH0pO1xuXG4gIFx0aWYgKGlzQ2xpZW50KSB7XG4gIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgXCJ0ZXN0XCIsIHsgdmFsdWU6IDAgfSk7XG4gIFx0fVxuXG4gIFx0ZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIH0gY2F0Y2ggKGVycikge1xuICBcdC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBkb2Vzbid0IGV4aXN0LCBvciB3ZSdyZSBpbiBJRTggd2hlcmUgeW91IGNhblxuICBcdC8vIG9ubHkgdXNlIGl0IHdpdGggRE9NIG9iamVjdHMgKHdoYXQgd2VyZSB5b3Ugc21va2luZywgTVNGVD8pXG4gIFx0ZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBkZXNjKSB7XG4gIFx0XHRvYmpbcHJvcF0gPSBkZXNjLnZhbHVlO1xuICBcdH07XG4gIH1cblxuICB0cnkge1xuICBcdHRyeSB7XG4gIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwgeyB0ZXN0OiB7IHZhbHVlOiAwIH0gfSk7XG4gIFx0fSBjYXRjaCAoZXJyKSB7XG4gIFx0XHQvLyBUT0RPIGhvdyBkbyB3ZSBhY2NvdW50IGZvciB0aGlzPyBub01hZ2ljID0gdHJ1ZTtcbiAgXHRcdHRocm93IGVycjtcbiAgXHR9XG5cbiAgXHRpZiAoaXNDbGllbnQpIHtcbiAgXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHsgdGVzdDogeyB2YWx1ZTogMCB9IH0pO1xuICBcdH1cblxuICBcdGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIFx0ZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIHByb3BzKSB7XG4gIFx0XHR2YXIgcHJvcDtcblxuICBcdFx0Zm9yIChwcm9wIGluIHByb3BzKSB7XG4gIFx0XHRcdGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICBcdFx0XHRcdGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgcHJvcHNbcHJvcF0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIHRyeSB7XG4gIFx0T2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBcdGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG4gIH0gY2F0Y2ggKGVycikge1xuICBcdC8vIHNpZ2hcbiAgXHRjcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIEYgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBcdFx0cmV0dXJuIGZ1bmN0aW9uIChwcm90bywgcHJvcHMpIHtcbiAgXHRcdFx0dmFyIG9iajtcblxuICBcdFx0XHRpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgXHRcdFx0XHRyZXR1cm4ge307XG4gIFx0XHRcdH1cblxuICBcdFx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xuICBcdFx0XHRvYmogPSBuZXcgRigpO1xuXG4gIFx0XHRcdGlmIChwcm9wcykge1xuICBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iaiwgcHJvcHMpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIG9iajtcbiAgXHRcdH07XG4gIFx0fSkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHV0aWxzX29iamVjdF9fZXh0ZW5kKHRhcmdldCkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0c291cmNlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0fVxuXG4gIFx0dmFyIHByb3AsIHNvdXJjZTtcblxuICBcdHdoaWxlIChzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCkpIHtcbiAgXHRcdGZvciAocHJvcCBpbiBzb3VyY2UpIHtcbiAgXHRcdFx0aWYgKGhhc093bi5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgXHRcdFx0XHR0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsbEdhcHModGFyZ2V0KSB7XG4gIFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRzb3VyY2VzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHR9XG5cbiAgXHRzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgXHRcdGZvciAodmFyIGtleSBpbiBzKSB7XG4gIFx0XHRcdGlmIChzLmhhc093blByb3BlcnR5KGtleSkgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICBcdFx0XHRcdHRhcmdldFtrZXldID0gc1trZXldO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gdGhhbmtzLCBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9pbnN0YW5jZW9mLWNvbnNpZGVyZWQtaGFybWZ1bC1vci1ob3ctdG8td3JpdGUtYS1yb2J1c3QtaXNhcnJheS9cbiAgdmFyIGlzX190b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICBhcnJheUxpa2VQYXR0ZXJuID0gL15cXFtvYmplY3QgKD86QXJyYXl8RmlsZUxpc3QpXFxdJC87XG4gIGZ1bmN0aW9uIGlzQXJyYXkodGhpbmcpIHtcbiAgXHRyZXR1cm4gaXNfX3RvU3RyaW5nLmNhbGwodGhpbmcpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc0FycmF5TGlrZShvYmopIHtcbiAgXHRyZXR1cm4gYXJyYXlMaWtlUGF0dGVybi50ZXN0KGlzX190b1N0cmluZy5jYWxsKG9iaikpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIFx0aWYgKGEgPT09IG51bGwgJiYgYiA9PT0gbnVsbCkge1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiBhID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBiID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGEgPT09IGI7XG4gIH1cblxuICBmdW5jdGlvbiBpc19faXNOdW1lcmljKHRoaW5nKSB7XG4gIFx0cmV0dXJuICFpc05hTihwYXJzZUZsb2F0KHRoaW5nKSkgJiYgaXNGaW5pdGUodGhpbmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNPYmplY3QodGhpbmcpIHtcbiAgXHRyZXR1cm4gdGhpbmcgJiYgaXNfX3RvU3RyaW5nLmNhbGwodGhpbmcpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuICB9XG5cbiAgdmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAvKiBnbG9iYWwgY29uc29sZSAqL1xuICB2YXIgYWxyZWFkeVdhcm5lZCA9IHt9LFxuICAgICAgbG9nLFxuICAgICAgcHJpbnRXYXJuaW5nLFxuICAgICAgd2VsY29tZTtcblxuICBpZiAoaGFzQ29uc29sZSkge1xuICBcdChmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgd2VsY29tZUludHJvID0gW1wiJWNSYWN0aXZlLmpzICVjMC43LjIgJWNpbiBkZWJ1ZyBtb2RlLCAlY21vcmUuLi5cIiwgXCJjb2xvcjogcmdiKDExNCwgMTU3LCA1Mik7IGZvbnQtd2VpZ2h0OiBub3JtYWw7XCIsIFwiY29sb3I6IHJnYig4NSwgODUsIDg1KTsgZm9udC13ZWlnaHQ6IG5vcm1hbDtcIiwgXCJjb2xvcjogcmdiKDg1LCA4NSwgODUpOyBmb250LXdlaWdodDogbm9ybWFsO1wiLCBcImNvbG9yOiByZ2IoODIsIDE0MCwgMjI0KTsgZm9udC13ZWlnaHQ6IG5vcm1hbDsgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XCJdO1xuICBcdFx0dmFyIHdlbGNvbWVNZXNzYWdlID0gXCJZb3UncmUgcnVubmluZyBSYWN0aXZlIDAuNy4yIGluIGRlYnVnIG1vZGUgLSBtZXNzYWdlcyB3aWxsIGJlIHByaW50ZWQgdG8gdGhlIGNvbnNvbGUgdG8gaGVscCB5b3UgZml4IHByb2JsZW1zIGFuZCBvcHRpbWlzZSB5b3VyIGFwcGxpY2F0aW9uLlxcblxcblRvIGRpc2FibGUgZGVidWcgbW9kZSwgYWRkIHRoaXMgbGluZSBhdCB0aGUgc3RhcnQgb2YgeW91ciBhcHA6XFxuICBSYWN0aXZlLkRFQlVHID0gZmFsc2U7XFxuXFxuVG8gZGlzYWJsZSBkZWJ1ZyBtb2RlIHdoZW4geW91ciBhcHAgaXMgbWluaWZpZWQsIGFkZCB0aGlzIHNuaXBwZXQ6XFxuICBSYWN0aXZlLkRFQlVHID0gL3VubWluaWZpZWQvLnRlc3QoZnVuY3Rpb24oKXsvKnVubWluaWZpZWQqL30pO1xcblxcbkdldCBoZWxwIGFuZCBzdXBwb3J0OlxcbiAgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZ1xcbiAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy90YWdnZWQvcmFjdGl2ZWpzXFxuICBodHRwOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyFmb3J1bS9yYWN0aXZlLWpzXFxuICBodHRwOi8vdHdpdHRlci5jb20vcmFjdGl2ZWpzXFxuXFxuRm91bmQgYSBidWc/IFJhaXNlIGFuIGlzc3VlOlxcbiAgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlc1xcblxcblwiO1xuXG4gIFx0XHR3ZWxjb21lID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHR2YXIgaGFzR3JvdXAgPSAhIWNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gIFx0XHRcdGNvbnNvbGVbaGFzR3JvdXAgPyBcImdyb3VwQ29sbGFwc2VkXCIgOiBcImxvZ1wiXS5hcHBseShjb25zb2xlLCB3ZWxjb21lSW50cm8pO1xuICBcdFx0XHRjb25zb2xlLmxvZyh3ZWxjb21lTWVzc2FnZSk7XG4gIFx0XHRcdGlmIChoYXNHcm91cCkge1xuICBcdFx0XHRcdGNvbnNvbGUuZ3JvdXBFbmQod2VsY29tZUludHJvKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHdlbGNvbWUgPSBub29wO1xuICBcdFx0fTtcblxuICBcdFx0cHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGFyZ3MpIHtcbiAgXHRcdFx0d2VsY29tZSgpO1xuXG4gIFx0XHRcdC8vIGV4dHJhY3QgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGluc3RhbmNlIHRoaXMgbWVzc2FnZSBwZXJ0YWlucyB0bywgaWYgYXBwbGljYWJsZVxuICBcdFx0XHRpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0XHRcdHZhciBvcHRpb25zID0gYXJncy5wb3AoKTtcbiAgXHRcdFx0XHR2YXIgcmFjdGl2ZSA9IG9wdGlvbnMgPyBvcHRpb25zLnJhY3RpdmUgOiBudWxsO1xuXG4gIFx0XHRcdFx0aWYgKHJhY3RpdmUpIHtcbiAgXHRcdFx0XHRcdC8vIGlmIHRoaXMgaXMgYW4gaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQgdGhhdCB3ZSBrbm93IHRoZSBuYW1lIG9mLCBhZGRcbiAgXHRcdFx0XHRcdC8vIGl0IHRvIHRoZSBtZXNzYWdlXG4gIFx0XHRcdFx0XHR2YXIgX25hbWUgPSB1bmRlZmluZWQ7XG4gIFx0XHRcdFx0XHRpZiAocmFjdGl2ZS5jb21wb25lbnQgJiYgKF9uYW1lID0gcmFjdGl2ZS5jb21wb25lbnQubmFtZSkpIHtcbiAgXHRcdFx0XHRcdFx0bWVzc2FnZSA9IFwiPFwiICsgX25hbWUgKyBcIj4gXCIgKyBtZXNzYWdlO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHR2YXIgbm9kZSA9IHVuZGVmaW5lZDtcbiAgXHRcdFx0XHRcdGlmIChub2RlID0gb3B0aW9ucy5ub2RlIHx8IHJhY3RpdmUuZnJhZ21lbnQgJiYgcmFjdGl2ZS5mcmFnbWVudC5yZW5kZXJlZCAmJiByYWN0aXZlLmZpbmQoXCIqXCIpKSB7XG4gIFx0XHRcdFx0XHRcdGFyZ3MucHVzaChub2RlKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgW1wiJWNSYWN0aXZlLmpzOiAlY1wiICsgbWVzc2FnZSwgXCJjb2xvcjogcmdiKDExNCwgMTU3LCA1Mik7XCIsIFwiY29sb3I6IHJnYig4NSwgODUsIDg1KTtcIl0uY29uY2F0KGFyZ3MpKTtcbiAgXHRcdH07XG5cbiAgXHRcdGxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0Y29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgXHRcdH07XG4gIFx0fSkoKTtcbiAgfSBlbHNlIHtcbiAgXHRwcmludFdhcm5pbmcgPSBsb2cgPSB3ZWxjb21lID0gbm9vcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdChtZXNzYWdlLCBhcmdzKSB7XG4gIFx0cmV0dXJuIG1lc3NhZ2UucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGFyZ3Muc2hpZnQoKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhdGFsKG1lc3NhZ2UpIHtcbiAgXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdG1lc3NhZ2UgPSBmb3JtYXQobWVzc2FnZSwgYXJncyk7XG4gIFx0dGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9nSWZEZWJ1ZygpIHtcbiAgXHRpZiAoX1JhY3RpdmUuREVCVUcpIHtcbiAgXHRcdGxvZy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4obWVzc2FnZSkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0YXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0fVxuXG4gIFx0bWVzc2FnZSA9IGZvcm1hdChtZXNzYWdlLCBhcmdzKTtcbiAgXHRwcmludFdhcm5pbmcobWVzc2FnZSwgYXJncyk7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuT25jZShtZXNzYWdlKSB7XG4gIFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHR9XG5cbiAgXHRtZXNzYWdlID0gZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpO1xuXG4gIFx0aWYgKGFscmVhZHlXYXJuZWRbbWVzc2FnZV0pIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRhbHJlYWR5V2FybmVkW21lc3NhZ2VdID0gdHJ1ZTtcbiAgXHRwcmludFdhcm5pbmcobWVzc2FnZSwgYXJncyk7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuSWZEZWJ1ZygpIHtcbiAgXHRpZiAoX1JhY3RpdmUuREVCVUcpIHtcbiAgXHRcdHdhcm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuT25jZUlmRGVidWcoKSB7XG4gIFx0aWYgKF9SYWN0aXZlLkRFQlVHKSB7XG4gIFx0XHR3YXJuT25jZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICBcdH1cbiAgfVxuXG4gIC8vIEVycm9yIG1lc3NhZ2VzIHRoYXQgYXJlIHVzZWQgKG9yIGNvdWxkIGJlKSBpbiBtdWx0aXBsZSBwbGFjZXNcbiAgdmFyIGJhZEFyZ3VtZW50cyA9IFwiQmFkIGFyZ3VtZW50c1wiO1xuICB2YXIgbm9SZWdpc3RyeUZ1bmN0aW9uUmV0dXJuID0gXCJBIGZ1bmN0aW9uIHdhcyBzcGVjaWZpZWQgZm9yIFxcXCIlc1xcXCIgJXMsIGJ1dCBubyAlcyB3YXMgcmV0dXJuZWRcIjtcbiAgdmFyIG1pc3NpbmdQbHVnaW4gPSBmdW5jdGlvbiAobmFtZSwgdHlwZSkge1xuICAgIHJldHVybiBcIk1pc3NpbmcgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBcIiArIHR5cGUgKyBcIiBwbHVnaW4uIFlvdSBtYXkgbmVlZCB0byBkb3dubG9hZCBhIHBsdWdpbiB2aWEgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvcGx1Z2lucyNcIiArIHR5cGUgKyBcInNcIjtcbiAgfTtcblxuICBmdW5jdGlvbiBmaW5kSW5WaWV3SGllcmFyY2h5KHJlZ2lzdHJ5TmFtZSwgcmFjdGl2ZSwgbmFtZSkge1xuICBcdHZhciBpbnN0YW5jZSA9IGZpbmRJbnN0YW5jZShyZWdpc3RyeU5hbWUsIHJhY3RpdmUsIG5hbWUpO1xuICBcdHJldHVybiBpbnN0YW5jZSA/IGluc3RhbmNlW3JlZ2lzdHJ5TmFtZV1bbmFtZV0gOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEluc3RhbmNlKHJlZ2lzdHJ5TmFtZSwgcmFjdGl2ZSwgbmFtZSkge1xuICBcdHdoaWxlIChyYWN0aXZlKSB7XG4gIFx0XHRpZiAobmFtZSBpbiByYWN0aXZlW3JlZ2lzdHJ5TmFtZV0pIHtcbiAgXHRcdFx0cmV0dXJuIHJhY3RpdmU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChyYWN0aXZlLmlzb2xhdGVkKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyYWN0aXZlID0gcmFjdGl2ZS5wYXJlbnQ7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24gKGZyb20sIHRvLCByYWN0aXZlLCB0eXBlKSB7XG4gIFx0aWYgKGZyb20gPT09IHRvKSB7XG4gIFx0XHRyZXR1cm4gc25hcCh0byk7XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGUpIHtcblxuICBcdFx0dmFyIGludGVycG9sID0gZmluZEluVmlld0hpZXJhcmNoeShcImludGVycG9sYXRvcnNcIiwgcmFjdGl2ZSwgdHlwZSk7XG4gIFx0XHRpZiAoaW50ZXJwb2wpIHtcbiAgXHRcdFx0cmV0dXJuIGludGVycG9sKGZyb20sIHRvKSB8fCBzbmFwKHRvKTtcbiAgXHRcdH1cblxuICBcdFx0ZmF0YWwobWlzc2luZ1BsdWdpbih0eXBlLCBcImludGVycG9sYXRvclwiKSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0YXRpY19pbnRlcnBvbGF0b3JzLm51bWJlcihmcm9tLCB0bykgfHwgc3RhdGljX2ludGVycG9sYXRvcnMuYXJyYXkoZnJvbSwgdG8pIHx8IHN0YXRpY19pbnRlcnBvbGF0b3JzLm9iamVjdChmcm9tLCB0bykgfHwgc25hcCh0byk7XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9pbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlO1xuXG4gIGZ1bmN0aW9uIHNuYXAodG8pIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRvO1xuICBcdH07XG4gIH1cblxuICB2YXIgaW50ZXJwb2xhdG9ycyA9IHtcbiAgXHRudW1iZXI6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICBcdFx0dmFyIGRlbHRhO1xuXG4gIFx0XHRpZiAoIWlzX19pc051bWVyaWMoZnJvbSkgfHwgIWlzX19pc051bWVyaWModG8pKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRmcm9tID0gK2Zyb207XG4gIFx0XHR0byA9ICt0bztcblxuICBcdFx0ZGVsdGEgPSB0byAtIGZyb207XG5cbiAgXHRcdGlmICghZGVsdGEpIHtcbiAgXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZnJvbTtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdHJldHVybiBmcm9tICsgdCAqIGRlbHRhO1xuICBcdFx0fTtcbiAgXHR9LFxuXG4gIFx0YXJyYXk6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICBcdFx0dmFyIGludGVybWVkaWF0ZSwgaW50ZXJwb2xhdG9ycywgbGVuLCBpO1xuXG4gIFx0XHRpZiAoIWlzQXJyYXkoZnJvbSkgfHwgIWlzQXJyYXkodG8pKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpbnRlcm1lZGlhdGUgPSBbXTtcbiAgXHRcdGludGVycG9sYXRvcnMgPSBbXTtcblxuICBcdFx0aSA9IGxlbiA9IE1hdGgubWluKGZyb20ubGVuZ3RoLCB0by5sZW5ndGgpO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpbnRlcnBvbGF0b3JzW2ldID0gc2hhcmVkX2ludGVycG9sYXRlKGZyb21baV0sIHRvW2ldKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3VycGx1cyB2YWx1ZXMgLSBkb24ndCBpbnRlcnBvbGF0ZSwgYnV0IGRvbid0IGV4Y2x1ZGUgdGhlbSBlaXRoZXJcbiAgXHRcdGZvciAoaSA9IGxlbjsgaSA8IGZyb20ubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0aW50ZXJtZWRpYXRlW2ldID0gZnJvbVtpXTtcbiAgXHRcdH1cblxuICBcdFx0Zm9yIChpID0gbGVuOyBpIDwgdG8ubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0aW50ZXJtZWRpYXRlW2ldID0gdG9baV07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAodCkge1xuICBcdFx0XHR2YXIgaSA9IGxlbjtcblxuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0aW50ZXJtZWRpYXRlW2ldID0gaW50ZXJwb2xhdG9yc1tpXSh0KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBpbnRlcm1lZGlhdGU7XG4gIFx0XHR9O1xuICBcdH0sXG5cbiAgXHRvYmplY3Q6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICBcdFx0dmFyIHByb3BlcnRpZXMsIGxlbiwgaW50ZXJwb2xhdG9ycywgaW50ZXJtZWRpYXRlLCBwcm9wO1xuXG4gIFx0XHRpZiAoIWlzT2JqZWN0KGZyb20pIHx8ICFpc09iamVjdCh0bykpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHByb3BlcnRpZXMgPSBbXTtcbiAgXHRcdGludGVybWVkaWF0ZSA9IHt9O1xuICBcdFx0aW50ZXJwb2xhdG9ycyA9IHt9O1xuXG4gIFx0XHRmb3IgKHByb3AgaW4gZnJvbSkge1xuICBcdFx0XHRpZiAoaGFzT3duLmNhbGwoZnJvbSwgcHJvcCkpIHtcbiAgXHRcdFx0XHRpZiAoaGFzT3duLmNhbGwodG8sIHByb3ApKSB7XG4gIFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gIFx0XHRcdFx0XHRpbnRlcnBvbGF0b3JzW3Byb3BdID0gc2hhcmVkX2ludGVycG9sYXRlKGZyb21bcHJvcF0sIHRvW3Byb3BdKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0aW50ZXJtZWRpYXRlW3Byb3BdID0gZnJvbVtwcm9wXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Zm9yIChwcm9wIGluIHRvKSB7XG4gIFx0XHRcdGlmIChoYXNPd24uY2FsbCh0bywgcHJvcCkgJiYgIWhhc093bi5jYWxsKGZyb20sIHByb3ApKSB7XG4gIFx0XHRcdFx0aW50ZXJtZWRpYXRlW3Byb3BdID0gdG9bcHJvcF07XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0bGVuID0gcHJvcGVydGllcy5sZW5ndGg7XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAodCkge1xuICBcdFx0XHR2YXIgaSA9IGxlbixcbiAgXHRcdFx0ICAgIHByb3A7XG5cbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdHByb3AgPSBwcm9wZXJ0aWVzW2ldO1xuXG4gIFx0XHRcdFx0aW50ZXJtZWRpYXRlW3Byb3BdID0gaW50ZXJwb2xhdG9yc1twcm9wXSh0KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBpbnRlcm1lZGlhdGU7XG4gIFx0XHR9O1xuICBcdH1cbiAgfTtcblxuICB2YXIgc3RhdGljX2ludGVycG9sYXRvcnMgPSBpbnRlcnBvbGF0b3JzO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBrZXlwYXRoIHN1Y2ggYXMgJ2Zvby5iYXIuYmF6JywgYW5kIHJldHVybnNcbiAgLy8gYWxsIHRoZSB2YXJpYW50cyBvZiB0aGF0IGtleXBhdGggdGhhdCBpbmNsdWRlIGEgd2lsZGNhcmQgaW4gcGxhY2VcbiAgLy8gb2YgYSBrZXksIHN1Y2ggYXMgJ2Zvby5iYXIuKicsICdmb28uKi5iYXonLCAnZm9vLiouKicgYW5kIHNvIG9uLlxuICAvLyBUaGVzZSBhcmUgdGhlbiBjaGVja2VkIGFnYWluc3QgdGhlIGRlcGVuZGFudHMgbWFwIChyYWN0aXZlLnZpZXdtb2RlbC5kZXBzTWFwKVxuICAvLyB0byBzZWUgaWYgYW55IHBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSBkb3duc3RyZWFtIG9mIG9uZSBvciBtb3JlIG9mXG4gIC8vIHRoZXNlIHdpbGRjYXJkIGtleXBhdGhzIChlLmcuICdmb28uYmFyLiouc3RhdHVzJylcbiAgdmFyIHV0aWxzX2dldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyA9IGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcztcblxuICB2YXIgc3Rhck1hcHMgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzKGtleXBhdGgpIHtcbiAgXHR2YXIga2V5cywgc3Rhck1hcCwgbWFwcGVyLCBpLCByZXN1bHQsIHdpbGRjYXJkS2V5cGF0aDtcblxuICBcdGtleXMgPSBrZXlwYXRoLnNwbGl0KFwiLlwiKTtcbiAgXHRpZiAoIShzdGFyTWFwID0gc3Rhck1hcHNba2V5cy5sZW5ndGhdKSkge1xuICBcdFx0c3Rhck1hcCA9IGdldFN0YXJNYXAoa2V5cy5sZW5ndGgpO1xuICBcdH1cblxuICBcdHJlc3VsdCA9IFtdO1xuXG4gIFx0bWFwcGVyID0gZnVuY3Rpb24gKHN0YXIsIGkpIHtcbiAgXHRcdHJldHVybiBzdGFyID8gXCIqXCIgOiBrZXlzW2ldO1xuICBcdH07XG5cbiAgXHRpID0gc3Rhck1hcC5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0d2lsZGNhcmRLZXlwYXRoID0gc3Rhck1hcFtpXS5tYXAobWFwcGVyKS5qb2luKFwiLlwiKTtcblxuICBcdFx0aWYgKCFyZXN1bHQuaGFzT3duUHJvcGVydHkod2lsZGNhcmRLZXlwYXRoKSkge1xuICBcdFx0XHRyZXN1bHQucHVzaCh3aWxkY2FyZEtleXBhdGgpO1xuICBcdFx0XHRyZXN1bHRbd2lsZGNhcmRLZXlwYXRoXSA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbGwgdGhlIHBvc3NpYmxlIHRydWUvZmFsc2UgY29tYmluYXRpb25zIGZvclxuICAvLyBhIGdpdmVuIG51bWJlciAtIGUuZy4gZm9yIHR3bywgdGhlIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBhcmVcbiAgLy8gWyB0cnVlLCB0cnVlIF0sIFsgdHJ1ZSwgZmFsc2UgXSwgWyBmYWxzZSwgdHJ1ZSBdLCBbIGZhbHNlLCBmYWxzZSBdLlxuICAvLyBJdCBkb2VzIHNvIGJ5IGdldHRpbmcgYWxsIHRoZSBiaW5hcnkgdmFsdWVzIGJldHdlZW4gMCBhbmQgZS5nLiAxMVxuICBmdW5jdGlvbiBnZXRTdGFyTWFwKG51bSkge1xuICBcdHZhciBvbmVzID0gXCJcIixcbiAgXHQgICAgbWF4LFxuICBcdCAgICBiaW5hcnksXG4gIFx0ICAgIHN0YXJNYXAsXG4gIFx0ICAgIG1hcHBlcixcbiAgXHQgICAgaSxcbiAgXHQgICAgaixcbiAgXHQgICAgbCxcbiAgXHQgICAgbWFwO1xuXG4gIFx0aWYgKCFzdGFyTWFwc1tudW1dKSB7XG4gIFx0XHRzdGFyTWFwID0gW107XG5cbiAgXHRcdHdoaWxlIChvbmVzLmxlbmd0aCA8IG51bSkge1xuICBcdFx0XHRvbmVzICs9IDE7XG4gIFx0XHR9XG5cbiAgXHRcdG1heCA9IHBhcnNlSW50KG9uZXMsIDIpO1xuXG4gIFx0XHRtYXBwZXIgPSBmdW5jdGlvbiAoZGlnaXQpIHtcbiAgXHRcdFx0cmV0dXJuIGRpZ2l0ID09PSBcIjFcIjtcbiAgXHRcdH07XG5cbiAgXHRcdGZvciAoaSA9IDA7IGkgPD0gbWF4OyBpICs9IDEpIHtcbiAgXHRcdFx0YmluYXJ5ID0gaS50b1N0cmluZygyKTtcbiAgXHRcdFx0d2hpbGUgKGJpbmFyeS5sZW5ndGggPCBudW0pIHtcbiAgXHRcdFx0XHRiaW5hcnkgPSBcIjBcIiArIGJpbmFyeTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdG1hcCA9IFtdO1xuICBcdFx0XHRsID0gYmluYXJ5Lmxlbmd0aDtcbiAgXHRcdFx0Zm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuICBcdFx0XHRcdG1hcC5wdXNoKG1hcHBlcihiaW5hcnlbal0pKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRzdGFyTWFwW2ldID0gbWFwO1xuICBcdFx0fVxuXG4gIFx0XHRzdGFyTWFwc1tudW1dID0gc3Rhck1hcDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3Rhck1hcHNbbnVtXTtcbiAgfVxuXG4gIHZhciByZWZQYXR0ZXJuID0gL1xcW1xccyooXFwqfFswLTldfFsxLTldWzAtOV0rKVxccypcXF0vZztcbiAgdmFyIHBhdHRlcm5QYXR0ZXJuID0gL1xcKi87XG4gIHZhciBrZXlwYXRoQ2FjaGUgPSB7fTtcblxuICB2YXIgS2V5cGF0aCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgXHR2YXIga2V5cyA9IHN0ci5zcGxpdChcIi5cIik7XG5cbiAgXHR0aGlzLnN0ciA9IHN0cjtcblxuICBcdGlmIChzdHJbMF0gPT09IFwiQFwiKSB7XG4gIFx0XHR0aGlzLmlzU3BlY2lhbCA9IHRydWU7XG4gIFx0XHR0aGlzLnZhbHVlID0gZGVjb2RlS2V5cGF0aChzdHIpO1xuICBcdH1cblxuICBcdHRoaXMuZmlyc3RLZXkgPSBrZXlzWzBdO1xuICBcdHRoaXMubGFzdEtleSA9IGtleXMucG9wKCk7XG5cbiAgXHR0aGlzLmlzUGF0dGVybiA9IHBhdHRlcm5QYXR0ZXJuLnRlc3Qoc3RyKTtcblxuICBcdHRoaXMucGFyZW50ID0gc3RyID09PSBcIlwiID8gbnVsbCA6IGdldEtleXBhdGgoa2V5cy5qb2luKFwiLlwiKSk7XG4gIFx0dGhpcy5pc1Jvb3QgPSAhc3RyO1xuICB9O1xuXG4gIEtleXBhdGgucHJvdG90eXBlID0ge1xuICBcdGVxdWFsc09yU3RhcnRzV2l0aDogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHJldHVybiBrZXlwYXRoID09PSB0aGlzIHx8IHRoaXMuc3RhcnRzV2l0aChrZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0am9pbjogZnVuY3Rpb24gKHN0cikge1xuICBcdFx0cmV0dXJuIGdldEtleXBhdGgodGhpcy5pc1Jvb3QgPyBTdHJpbmcoc3RyKSA6IHRoaXMuc3RyICsgXCIuXCIgKyBzdHIpO1xuICBcdH0sXG5cbiAgXHRyZXBsYWNlOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMgPT09IG9sZEtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIG5ld0tleXBhdGg7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLnN0YXJ0c1dpdGgob2xkS2V5cGF0aCkpIHtcbiAgXHRcdFx0cmV0dXJuIG5ld0tleXBhdGggPT09IG51bGwgPyBuZXdLZXlwYXRoIDogZ2V0S2V5cGF0aCh0aGlzLnN0ci5yZXBsYWNlKG9sZEtleXBhdGguc3RyICsgXCIuXCIsIG5ld0tleXBhdGguc3RyICsgXCIuXCIpKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0c3RhcnRzV2l0aDogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGlmICgha2V5cGF0aCkge1xuICBcdFx0XHQvLyBUT0RPIHVuZGVyIHdoYXQgY2lyY3Vtc3RhbmNlcyBkb2VzIHRoaXMgaGFwcGVuP1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBrZXlwYXRoICYmIHRoaXMuc3RyLnN1YnN0cigwLCBrZXlwYXRoLnN0ci5sZW5ndGggKyAxKSA9PT0ga2V5cGF0aC5zdHIgKyBcIi5cIjtcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkJhZCBjb2VyY2lvblwiKTtcbiAgXHR9LFxuXG4gIFx0dmFsdWVPZjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQmFkIGNvZXJjaW9uXCIpO1xuICBcdH0sXG5cbiAgXHR3aWxkY2FyZE1hdGNoZXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLl93aWxkY2FyZE1hdGNoZXMgfHwgKHRoaXMuX3dpbGRjYXJkTWF0Y2hlcyA9IHV0aWxzX2dldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyh0aGlzLnN0cikpO1xuICBcdH1cbiAgfTtcbiAgZnVuY3Rpb24gYXNzaWduTmV3S2V5cGF0aCh0YXJnZXQsIHByb3BlcnR5LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0dmFyIGV4aXN0aW5nS2V5cGF0aCA9IHRhcmdldFtwcm9wZXJ0eV07XG5cbiAgXHRpZiAoZXhpc3RpbmdLZXlwYXRoICYmIChleGlzdGluZ0tleXBhdGguZXF1YWxzT3JTdGFydHNXaXRoKG5ld0tleXBhdGgpIHx8ICFleGlzdGluZ0tleXBhdGguZXF1YWxzT3JTdGFydHNXaXRoKG9sZEtleXBhdGgpKSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHRhcmdldFtwcm9wZXJ0eV0gPSBleGlzdGluZ0tleXBhdGggPyBleGlzdGluZ0tleXBhdGgucmVwbGFjZShvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSA6IG5ld0tleXBhdGg7XG4gIFx0cmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGVLZXlwYXRoKGtleXBhdGgpIHtcbiAgXHR2YXIgdmFsdWUgPSBrZXlwYXRoLnNsaWNlKDIpO1xuXG4gIFx0aWYgKGtleXBhdGhbMV0gPT09IFwiaVwiKSB7XG4gIFx0XHRyZXR1cm4gaXNfX2lzTnVtZXJpYyh2YWx1ZSkgPyArdmFsdWUgOiB2YWx1ZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIHZhbHVlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEtleXBhdGgoc3RyKSB7XG4gIFx0aWYgKHN0ciA9PSBudWxsKSB7XG4gIFx0XHRyZXR1cm4gc3RyO1xuICBcdH1cblxuICBcdC8vIFRPRE8gaXQgKm1heSogYmUgd29ydGggaGF2aW5nIHR3byB2ZXJzaW9ucyBvZiB0aGlzIGZ1bmN0aW9uIC0gb25lIHdoZXJlXG4gIFx0Ly8ga2V5cGF0aENhY2hlIGluaGVyaXRzIGZyb20gbnVsbCwgYW5kIG9uZSBmb3IgSUU4LiBEZXBlbmRzIG9uIGhvd1xuICBcdC8vIG11Y2ggb2YgYW4gb3ZlcmhlYWQgaGFzT3duUHJvcGVydHkgaXMgLSBwcm9iYWJseSBuZWdsaWdpYmxlXG4gIFx0aWYgKCFrZXlwYXRoQ2FjaGUuaGFzT3duUHJvcGVydHkoc3RyKSkge1xuICBcdFx0a2V5cGF0aENhY2hlW3N0cl0gPSBuZXcgS2V5cGF0aChzdHIpO1xuICBcdH1cblxuICBcdHJldHVybiBrZXlwYXRoQ2FjaGVbc3RyXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1hdGNoaW5nS2V5cGF0aHMocmFjdGl2ZSwga2V5cGF0aCkge1xuICBcdHZhciBrZXlzLCBrZXksIG1hdGNoaW5nS2V5cGF0aHM7XG5cbiAgXHRrZXlzID0ga2V5cGF0aC5zdHIuc3BsaXQoXCIuXCIpO1xuICBcdG1hdGNoaW5nS2V5cGF0aHMgPSBbcm9vdEtleXBhdGhdO1xuXG4gIFx0d2hpbGUgKGtleSA9IGtleXMuc2hpZnQoKSkge1xuICBcdFx0aWYgKGtleSA9PT0gXCIqXCIpIHtcbiAgXHRcdFx0Ly8gZXhwYW5kIHRvIGZpbmQgYWxsIHZhbGlkIGNoaWxkIGtleXBhdGhzXG4gIFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBtYXRjaGluZ0tleXBhdGhzLnJlZHVjZShleHBhbmQsIFtdKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGlmIChtYXRjaGluZ0tleXBhdGhzWzBdID09PSByb290S2V5cGF0aCkge1xuICBcdFx0XHRcdC8vIGZpcnN0IGtleVxuICBcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHNbMF0gPSBnZXRLZXlwYXRoKGtleSk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRocyA9IG1hdGNoaW5nS2V5cGF0aHMubWFwKGNvbmNhdGVuYXRlKGtleSkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG1hdGNoaW5nS2V5cGF0aHM7XG5cbiAgXHRmdW5jdGlvbiBleHBhbmQobWF0Y2hpbmdLZXlwYXRocywga2V5cGF0aCkge1xuICBcdFx0dmFyIHdyYXBwZXIsIHZhbHVlLCBrZXlzO1xuXG4gIFx0XHRpZiAoa2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdFx0a2V5cyA9IFtdLmNvbmNhdChPYmplY3Qua2V5cyhyYWN0aXZlLnZpZXdtb2RlbC5kYXRhKSwgT2JqZWN0LmtleXMocmFjdGl2ZS52aWV3bW9kZWwubWFwcGluZ3MpLCBPYmplY3Qua2V5cyhyYWN0aXZlLnZpZXdtb2RlbC5jb21wdXRhdGlvbnMpKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdyYXBwZXIgPSByYWN0aXZlLnZpZXdtb2RlbC53cmFwcGVkW2tleXBhdGguc3RyXTtcbiAgXHRcdFx0dmFsdWUgPSB3cmFwcGVyID8gd3JhcHBlci5nZXQoKSA6IHJhY3RpdmUudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdFx0XHRrZXlzID0gdmFsdWUgPyBPYmplY3Qua2V5cyh2YWx1ZSkgOiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoa2V5cykge1xuICBcdFx0XHRrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBcdFx0XHRcdGlmIChrZXkgIT09IFwiX3JhY3RpdmVcIiB8fCAhaXNBcnJheSh2YWx1ZSkpIHtcbiAgXHRcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMucHVzaChrZXlwYXRoLmpvaW4oa2V5KSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG1hdGNoaW5nS2V5cGF0aHM7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gY29uY2F0ZW5hdGUoa2V5KSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRyZXR1cm4ga2V5cGF0aC5qb2luKGtleSk7XG4gIFx0fTtcbiAgfVxuICBmdW5jdGlvbiBub3JtYWxpc2UocmVmKSB7XG4gIFx0cmV0dXJuIHJlZiA/IHJlZi5yZXBsYWNlKHJlZlBhdHRlcm4sIFwiLiQxXCIpIDogXCJcIjtcbiAgfVxuXG4gIHZhciByb290S2V5cGF0aCA9IGdldEtleXBhdGgoXCJcIik7XG5cbiAgdmFyIHNoYXJlZF9hZGQgPSBhZGQ7XG4gIHZhciBzaGFyZWRfYWRkX19lcnJvck1lc3NhZ2UgPSBcIkNhbm5vdCBhZGQgdG8gYSBub24tbnVtZXJpYyB2YWx1ZVwiO1xuICBmdW5jdGlvbiBhZGQocm9vdCwga2V5cGF0aCwgZCkge1xuICBcdGlmICh0eXBlb2Yga2V5cGF0aCAhPT0gXCJzdHJpbmdcIiB8fCAhaXNfX2lzTnVtZXJpYyhkKSkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQmFkIGFyZ3VtZW50c1wiKTtcbiAgXHR9XG5cbiAgXHR2YXIgdmFsdWUgPSB1bmRlZmluZWQsXG4gIFx0ICAgIGNoYW5nZXMgPSB1bmRlZmluZWQ7XG5cbiAgXHRpZiAoL1xcKi8udGVzdChrZXlwYXRoKSkge1xuICBcdFx0Y2hhbmdlcyA9IHt9O1xuXG4gIFx0XHRnZXRNYXRjaGluZ0tleXBhdGhzKHJvb3QsIGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHR2YXIgdmFsdWUgPSByb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdFx0aWYgKCFpc19faXNOdW1lcmljKHZhbHVlKSkge1xuICBcdFx0XHRcdHRocm93IG5ldyBFcnJvcihzaGFyZWRfYWRkX19lcnJvck1lc3NhZ2UpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y2hhbmdlc1trZXlwYXRoLnN0cl0gPSB2YWx1ZSArIGQ7XG4gIFx0XHR9KTtcblxuICBcdFx0cmV0dXJuIHJvb3Quc2V0KGNoYW5nZXMpO1xuICBcdH1cblxuICBcdHZhbHVlID0gcm9vdC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRpZiAoIWlzX19pc051bWVyaWModmFsdWUpKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3Ioc2hhcmVkX2FkZF9fZXJyb3JNZXNzYWdlKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcm9vdC5zZXQoa2V5cGF0aCwgK3ZhbHVlICsgZCk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2FkZCA9IFJhY3RpdmUkYWRkO1xuICBmdW5jdGlvbiBSYWN0aXZlJGFkZChrZXlwYXRoLCBkKSB7XG4gIFx0cmV0dXJuIHNoYXJlZF9hZGQodGhpcywga2V5cGF0aCwgZCA9PT0gdW5kZWZpbmVkID8gMSA6ICtkKTtcbiAgfVxuXG4gIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cbiAgLy8gSWYgd2luZG93IGRvZXNuJ3QgZXhpc3QsIHdlIGRvbid0IG5lZWQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHQvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvMTU3OTY3MVxuICBcdChmdW5jdGlvbiAodmVuZG9ycywgbGFzdFRpbWUsIHdpbmRvdykge1xuXG4gIFx0XHR2YXIgeCwgc2V0VGltZW91dDtcblxuICBcdFx0aWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRmb3IgKHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xuICBcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyBcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gIFx0XHRcdHNldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dDtcblxuICBcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIFx0XHRcdFx0dmFyIGN1cnJUaW1lLCB0aW1lVG9DYWxsLCBpZDtcblxuICBcdFx0XHRcdGN1cnJUaW1lID0gRGF0ZS5ub3coKTtcbiAgXHRcdFx0XHR0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICBcdFx0XHRcdGlkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICBcdFx0XHRcdH0sIHRpbWVUb0NhbGwpO1xuXG4gIFx0XHRcdFx0bGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gIFx0XHRcdFx0cmV0dXJuIGlkO1xuICBcdFx0XHR9O1xuICBcdFx0fVxuICBcdH0pKHZlbmRvcnMsIDAsIHdpbmRvdyk7XG5cbiAgXHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICB9XG5cbiAgdmFyIHJBRiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblxuICB2YXIgZ2V0VGltZTtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgdHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdGdldFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICBcdH07XG4gIH0gZWxzZSB7XG4gIFx0Z2V0VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBEYXRlLm5vdygpO1xuICBcdH07XG4gIH1cblxuICB2YXIgdXRpbHNfZ2V0VGltZSA9IGdldFRpbWU7XG5cbiAgdmFyIGRlcHJlY2F0aW9ucyA9IHtcbiAgXHRjb25zdHJ1Y3Q6IHtcbiAgXHRcdGRlcHJlY2F0ZWQ6IFwiYmVmb3JlSW5pdFwiLFxuICBcdFx0cmVwbGFjZW1lbnQ6IFwib25jb25zdHJ1Y3RcIlxuICBcdH0sXG4gIFx0cmVuZGVyOiB7XG4gIFx0XHRkZXByZWNhdGVkOiBcImluaXRcIixcbiAgXHRcdG1lc3NhZ2U6IFwiVGhlIFxcXCJpbml0XFxcIiBtZXRob2QgaGFzIGJlZW4gZGVwcmVjYXRlZCBcIiArIFwiYW5kIHdpbGwgbGlrZWx5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4gXCIgKyBcIllvdSBjYW4gZWl0aGVyIHVzZSB0aGUgXFxcIm9uaW5pdFxcXCIgbWV0aG9kIHdoaWNoIHdpbGwgZmlyZSBcIiArIFwib25seSBvbmNlIHByaW9yIHRvLCBhbmQgcmVnYXJkbGVzcyBvZiwgYW55IGV2ZW50dWFsIHJhY3RpdmUgXCIgKyBcImluc3RhbmNlIGJlaW5nIHJlbmRlcmVkLCBvciBpZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIFwiICsgXCJyZW5kZXJlZCBET00sIHVzZSBcXFwib25yZW5kZXJcXFwiIGluc3RlYWQuIFwiICsgXCJTZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbWlncmF0aW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gIFx0fSxcbiAgXHRjb21wbGV0ZToge1xuICBcdFx0ZGVwcmVjYXRlZDogXCJjb21wbGV0ZVwiLFxuICBcdFx0cmVwbGFjZW1lbnQ6IFwib25jb21wbGV0ZVwiXG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIEhvb2soZXZlbnQpIHtcbiAgXHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gIFx0dGhpcy5tZXRob2QgPSBcIm9uXCIgKyBldmVudDtcbiAgXHR0aGlzLmRlcHJlY2F0ZSA9IGRlcHJlY2F0aW9uc1tldmVudF07XG4gIH1cblxuICBIb29rLnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24gKHJhY3RpdmUsIGFyZykge1xuICBcdGZ1bmN0aW9uIGNhbGwobWV0aG9kKSB7XG4gIFx0XHRpZiAocmFjdGl2ZVttZXRob2RdKSB7XG4gIFx0XHRcdGFyZyA/IHJhY3RpdmVbbWV0aG9kXShhcmcpIDogcmFjdGl2ZVttZXRob2RdKCk7XG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGNhbGwodGhpcy5tZXRob2QpO1xuXG4gIFx0aWYgKCFyYWN0aXZlW3RoaXMubWV0aG9kXSAmJiB0aGlzLmRlcHJlY2F0ZSAmJiBjYWxsKHRoaXMuZGVwcmVjYXRlLmRlcHJlY2F0ZWQpKSB7XG4gIFx0XHRpZiAodGhpcy5kZXByZWNhdGUubWVzc2FnZSkge1xuICBcdFx0XHR3YXJuSWZEZWJ1Zyh0aGlzLmRlcHJlY2F0ZS5tZXNzYWdlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKFwiVGhlIG1ldGhvZCBcXFwiJXNcXFwiIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgXFxcIiVzXFxcIiBhbmQgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiBTZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbWlncmF0aW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiLCB0aGlzLmRlcHJlY2F0ZS5kZXByZWNhdGVkLCB0aGlzLmRlcHJlY2F0ZS5yZXBsYWNlbWVudCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0YXJnID8gcmFjdGl2ZS5maXJlKHRoaXMuZXZlbnQsIGFyZykgOiByYWN0aXZlLmZpcmUodGhpcy5ldmVudCk7XG4gIH07XG5cbiAgdmFyIGhvb2tzX0hvb2sgPSBIb29rO1xuXG4gIGZ1bmN0aW9uIGFkZFRvQXJyYXkoYXJyYXksIHZhbHVlKSB7XG4gIFx0dmFyIGluZGV4ID0gYXJyYXkuaW5kZXhPZih2YWx1ZSk7XG5cbiAgXHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRhcnJheS5wdXNoKHZhbHVlKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUNvbnRhaW5zKGFycmF5LCB2YWx1ZSkge1xuICBcdGZvciAodmFyIGkgPSAwLCBjID0gYXJyYXkubGVuZ3RoOyBpIDwgYzsgaSsrKSB7XG4gIFx0XHRpZiAoYXJyYXlbaV0gPT0gdmFsdWUpIHtcbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlDb250ZW50c01hdGNoKGEsIGIpIHtcbiAgXHR2YXIgaTtcblxuICBcdGlmICghaXNBcnJheShhKSB8fCAhaXNBcnJheShiKSkge1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG5cbiAgXHRpID0gYS5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlQXJyYXkoeCkge1xuICBcdGlmICh0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0cmV0dXJuIFt4XTtcbiAgXHR9XG5cbiAgXHRpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRyZXR1cm4gW107XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHg7XG4gIH1cblxuICBmdW5jdGlvbiBsYXN0SXRlbShhcnJheSkge1xuICBcdHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUZyb21BcnJheShhcnJheSwgbWVtYmVyKSB7XG4gIFx0dmFyIGluZGV4ID0gYXJyYXkuaW5kZXhPZihtZW1iZXIpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0YXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB0b0FycmF5KGFycmF5TGlrZSkge1xuICBcdHZhciBhcnJheSA9IFtdLFxuICBcdCAgICBpID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRhcnJheVtpXSA9IGFycmF5TGlrZVtpXTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYXJyYXk7XG4gIH1cblxuICB2YXIgX1Byb21pc2UsXG4gICAgICBQRU5ESU5HID0ge30sXG4gICAgICBGVUxGSUxMRUQgPSB7fSxcbiAgICAgIFJFSkVDVEVEID0ge307XG5cbiAgaWYgKHR5cGVvZiBQcm9taXNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHQvLyB1c2UgbmF0aXZlIFByb21pc2VcbiAgXHRfUHJvbWlzZSA9IFByb21pc2U7XG4gIH0gZWxzZSB7XG4gIFx0X1Byb21pc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgXHRcdHZhciBmdWxmaWxsZWRIYW5kbGVycyA9IFtdLFxuICBcdFx0ICAgIHJlamVjdGVkSGFuZGxlcnMgPSBbXSxcbiAgXHRcdCAgICBzdGF0ZSA9IFBFTkRJTkcsXG4gIFx0XHQgICAgcmVzdWx0LFxuICBcdFx0ICAgIGRpc3BhdGNoSGFuZGxlcnMsXG4gIFx0XHQgICAgbWFrZVJlc29sdmVyLFxuICBcdFx0ICAgIGZ1bGZpbCxcbiAgXHRcdCAgICByZWplY3QsXG4gIFx0XHQgICAgcHJvbWlzZTtcblxuICBcdFx0bWFrZVJlc29sdmVyID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gIFx0XHRcdHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0XHRpZiAoc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRyZXN1bHQgPSB2YWx1ZTtcbiAgXHRcdFx0XHRzdGF0ZSA9IG5ld1N0YXRlO1xuXG4gIFx0XHRcdFx0ZGlzcGF0Y2hIYW5kbGVycyA9IG1ha2VEaXNwYXRjaGVyKHN0YXRlID09PSBGVUxGSUxMRUQgPyBmdWxmaWxsZWRIYW5kbGVycyA6IHJlamVjdGVkSGFuZGxlcnMsIHJlc3VsdCk7XG5cbiAgXHRcdFx0XHQvLyBkaXNwYXRjaCBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBoYW5kbGVycyBhc3luY2hyb25vdXNseVxuICBcdFx0XHRcdHdhaXQoZGlzcGF0Y2hIYW5kbGVycyk7XG4gIFx0XHRcdH07XG4gIFx0XHR9O1xuXG4gIFx0XHRmdWxmaWwgPSBtYWtlUmVzb2x2ZXIoRlVMRklMTEVEKTtcbiAgXHRcdHJlamVjdCA9IG1ha2VSZXNvbHZlcihSRUpFQ1RFRCk7XG5cbiAgXHRcdHRyeSB7XG4gIFx0XHRcdGNhbGxiYWNrKGZ1bGZpbCwgcmVqZWN0KTtcbiAgXHRcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0XHRyZWplY3QoZXJyKTtcbiAgXHRcdH1cblxuICBcdFx0cHJvbWlzZSA9IHtcbiAgXHRcdFx0Ly8gYHRoZW4oKWAgcmV0dXJucyBhIFByb21pc2UgLSAyLjIuN1xuICBcdFx0XHR0aGVuOiBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgXHRcdFx0XHR2YXIgcHJvbWlzZTIgPSBuZXcgX1Byb21pc2UoZnVuY3Rpb24gKGZ1bGZpbCwgcmVqZWN0KSB7XG5cbiAgXHRcdFx0XHRcdHZhciBwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAoaGFuZGxlciwgaGFuZGxlcnMsIGZvcndhcmQpIHtcblxuICBcdFx0XHRcdFx0XHQvLyAyLjIuMS4xXG4gIFx0XHRcdFx0XHRcdGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdFx0XHRcdFx0aGFuZGxlcnMucHVzaChmdW5jdGlvbiAocDFyZXN1bHQpIHtcbiAgXHRcdFx0XHRcdFx0XHRcdHZhciB4O1xuXG4gIFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuICBcdFx0XHRcdFx0XHRcdFx0XHR4ID0gaGFuZGxlcihwMXJlc3VsdCk7XG4gIFx0XHRcdFx0XHRcdFx0XHRcdHV0aWxzX1Byb21pc2VfX3Jlc29sdmUocHJvbWlzZTIsIHgsIGZ1bGZpbCwgcmVqZWN0KTtcbiAgXHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0XHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyKTtcbiAgXHRcdFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHQvLyBGb3J3YXJkIHRoZSByZXN1bHQgb2YgcHJvbWlzZTEgdG8gcHJvbWlzZTIsIGlmIHJlc29sdXRpb24gaGFuZGxlcnNcbiAgXHRcdFx0XHRcdFx0XHQvLyBhcmUgbm90IGdpdmVuXG4gIFx0XHRcdFx0XHRcdFx0aGFuZGxlcnMucHVzaChmb3J3YXJkKTtcbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fTtcblxuICBcdFx0XHRcdFx0Ly8gMi4yXG4gIFx0XHRcdFx0XHRwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIob25GdWxmaWxsZWQsIGZ1bGZpbGxlZEhhbmRsZXJzLCBmdWxmaWwpO1xuICBcdFx0XHRcdFx0cHJvY2Vzc1Jlc29sdXRpb25IYW5kbGVyKG9uUmVqZWN0ZWQsIHJlamVjdGVkSGFuZGxlcnMsIHJlamVjdCk7XG5cbiAgXHRcdFx0XHRcdGlmIChzdGF0ZSAhPT0gUEVORElORykge1xuICBcdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJvbWlzZSBoYXMgcmVzb2x2ZWQgYWxyZWFkeSwgZGlzcGF0Y2ggdGhlIGFwcHJvcHJpYXRlIGhhbmRsZXJzIGFzeW5jaHJvbm91c2x5XG4gIFx0XHRcdFx0XHRcdHdhaXQoZGlzcGF0Y2hIYW5kbGVycyk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fSk7XG5cbiAgXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTI7XG4gIFx0XHRcdH1cbiAgXHRcdH07XG5cbiAgXHRcdHByb21pc2VbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gIFx0XHR9O1xuXG4gIFx0XHRyZXR1cm4gcHJvbWlzZTtcbiAgXHR9O1xuXG4gIFx0X1Byb21pc2UuYWxsID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gIFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWwsIHJlamVjdCkge1xuICBcdFx0XHR2YXIgcmVzdWx0ID0gW10sXG4gIFx0XHRcdCAgICBwZW5kaW5nLFxuICBcdFx0XHQgICAgaSxcbiAgXHRcdFx0ICAgIHByb2Nlc3NQcm9taXNlO1xuXG4gIFx0XHRcdGlmICghcHJvbWlzZXMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0ZnVsZmlsKHJlc3VsdCk7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cHJvY2Vzc1Byb21pc2UgPSBmdW5jdGlvbiAocHJvbWlzZSwgaSkge1xuICBcdFx0XHRcdGlmIChwcm9taXNlICYmIHR5cGVvZiBwcm9taXNlLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRcdFx0cHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0XHRcdFx0XHRyZXN1bHRbaV0gPSB2YWx1ZTtcbiAgXHRcdFx0XHRcdFx0LS1wZW5kaW5nIHx8IGZ1bGZpbChyZXN1bHQpO1xuICBcdFx0XHRcdFx0fSwgcmVqZWN0KTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0cmVzdWx0W2ldID0gcHJvbWlzZTtcbiAgXHRcdFx0XHRcdC0tcGVuZGluZyB8fCBmdWxmaWwocmVzdWx0KTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0cGVuZGluZyA9IGkgPSBwcm9taXNlcy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRwcm9jZXNzUHJvbWlzZShwcm9taXNlc1tpXSwgaSk7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdH07XG5cbiAgXHRfUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWwpIHtcbiAgXHRcdFx0ZnVsZmlsKHZhbHVlKTtcbiAgXHRcdH0pO1xuICBcdH07XG5cbiAgXHRfUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gIFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChmdWxmaWwsIHJlamVjdCkge1xuICBcdFx0XHRyZWplY3QocmVhc29uKTtcbiAgXHRcdH0pO1xuICBcdH07XG4gIH1cblxuICB2YXIgdXRpbHNfUHJvbWlzZSA9IF9Qcm9taXNlO1xuXG4gIC8vIFRPRE8gdXNlIE11dGF0aW9uT2JzZXJ2ZXJzIG9yIHNvbWV0aGluZyB0byBzaW11bGF0ZSBzZXRJbW1lZGlhdGVcbiAgZnVuY3Rpb24gd2FpdChjYWxsYmFjaykge1xuICBcdHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZURpc3BhdGNoZXIoaGFuZGxlcnMsIHJlc3VsdCkge1xuICBcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgaGFuZGxlcjtcblxuICBcdFx0d2hpbGUgKGhhbmRsZXIgPSBoYW5kbGVycy5zaGlmdCgpKSB7XG4gIFx0XHRcdGhhbmRsZXIocmVzdWx0KTtcbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gdXRpbHNfUHJvbWlzZV9fcmVzb2x2ZShwcm9taXNlLCB4LCBmdWxmaWwsIHJlamVjdCkge1xuICBcdC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmVcbiAgXHR2YXIgdGhlbjtcblxuICBcdC8vIDIuMy4xXG4gIFx0aWYgKHggPT09IHByb21pc2UpIHtcbiAgXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHByb21pc2UncyBmdWxmaWxsbWVudCBoYW5kbGVyIGNhbm5vdCByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZVwiKTtcbiAgXHR9XG5cbiAgXHQvLyAyLjMuMlxuICBcdGlmICh4IGluc3RhbmNlb2YgX1Byb21pc2UpIHtcbiAgXHRcdHgudGhlbihmdWxmaWwsIHJlamVjdCk7XG4gIFx0fVxuXG4gIFx0Ly8gMi4zLjNcbiAgXHRlbHNlIGlmICh4ICYmICh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICBcdFx0dHJ5IHtcbiAgXHRcdFx0dGhlbiA9IHgudGhlbjsgLy8gMi4zLjMuMVxuICBcdFx0fSBjYXRjaCAoZSkge1xuICBcdFx0XHRyZWplY3QoZSk7IC8vIDIuMy4zLjJcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyAyLjMuMy4zXG4gIFx0XHRpZiAodHlwZW9mIHRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHR2YXIgY2FsbGVkLCByZXNvbHZlUHJvbWlzZSwgcmVqZWN0UHJvbWlzZTtcblxuICBcdFx0XHRyZXNvbHZlUHJvbWlzZSA9IGZ1bmN0aW9uICh5KSB7XG4gIFx0XHRcdFx0aWYgKGNhbGxlZCkge1xuICBcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHRjYWxsZWQgPSB0cnVlO1xuICBcdFx0XHRcdHV0aWxzX1Byb21pc2VfX3Jlc29sdmUocHJvbWlzZSwgeSwgZnVsZmlsLCByZWplY3QpO1xuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHJlamVjdFByb21pc2UgPSBmdW5jdGlvbiAocikge1xuICBcdFx0XHRcdGlmIChjYWxsZWQpIHtcbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRyZWplY3Qocik7XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0dHJ5IHtcbiAgXHRcdFx0XHR0aGVuLmNhbGwoeCwgcmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2UpO1xuICBcdFx0XHR9IGNhdGNoIChlKSB7XG4gIFx0XHRcdFx0aWYgKCFjYWxsZWQpIHtcbiAgXHRcdFx0XHRcdC8vIDIuMy4zLjMuNC4xXG4gIFx0XHRcdFx0XHRyZWplY3QoZSk7IC8vIDIuMy4zLjMuNC4yXG4gIFx0XHRcdFx0XHRjYWxsZWQgPSB0cnVlO1xuICBcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZnVsZmlsKHgpO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRmdWxmaWwoeCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGdldElubmVyQ29udGV4dCA9IGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICBcdGRvIHtcbiAgXHRcdGlmIChmcmFnbWVudC5jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuIGZyYWdtZW50LmNvbnRleHQ7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQpO1xuXG4gIFx0cmV0dXJuIHJvb3RLZXlwYXRoO1xuICB9O1xuXG4gIHZhciBzaGFyZWRfcmVzb2x2ZVJlZiA9IHJlc29sdmVSZWY7XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVJlZihyYWN0aXZlLCByZWYsIGZyYWdtZW50KSB7XG4gIFx0dmFyIGtleXBhdGg7XG5cbiAgXHRyZWYgPSBub3JtYWxpc2UocmVmKTtcblxuICBcdC8vIElmIGEgcmVmZXJlbmNlIGJlZ2lucyAnfi8nLCBpdCdzIGEgdG9wLWxldmVsIHJlZmVyZW5jZVxuICBcdGlmIChyZWYuc3Vic3RyKDAsIDIpID09PSBcIn4vXCIpIHtcbiAgXHRcdGtleXBhdGggPSBnZXRLZXlwYXRoKHJlZi5zdWJzdHJpbmcoMikpO1xuICBcdFx0Y3JlYXRlTWFwcGluZ0lmTmVjZXNzYXJ5KHJhY3RpdmUsIGtleXBhdGguZmlyc3RLZXksIGZyYWdtZW50KTtcbiAgXHR9XG5cbiAgXHQvLyBJZiBhIHJlZmVyZW5jZSBiZWdpbnMgd2l0aCAnLicsIGl0J3MgZWl0aGVyIGEgcmVzdHJpY3RlZCByZWZlcmVuY2Ugb3JcbiAgXHQvLyBhbiBhbmNlc3RvciByZWZlcmVuY2UuLi5cbiAgXHRlbHNlIGlmIChyZWZbMF0gPT09IFwiLlwiKSB7XG4gIFx0XHRrZXlwYXRoID0gcmVzb2x2ZUFuY2VzdG9yUmVmKGdldElubmVyQ29udGV4dChmcmFnbWVudCksIHJlZik7XG5cbiAgXHRcdGlmIChrZXlwYXRoKSB7XG4gIFx0XHRcdGNyZWF0ZU1hcHBpbmdJZk5lY2Vzc2FyeShyYWN0aXZlLCBrZXlwYXRoLmZpcnN0S2V5LCBmcmFnbWVudCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gLi4ub3RoZXJ3aXNlIHdlIG5lZWQgdG8gZmlndXJlIG91dCB0aGUga2V5cGF0aCBiYXNlZCBvbiBjb250ZXh0XG4gIFx0ZWxzZSB7XG4gIFx0XHRrZXlwYXRoID0gcmVzb2x2ZUFtYmlndW91c1JlZmVyZW5jZShyYWN0aXZlLCBnZXRLZXlwYXRoKHJlZiksIGZyYWdtZW50KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ga2V5cGF0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVBbmNlc3RvclJlZihiYXNlQ29udGV4dCwgcmVmKSB7XG4gIFx0dmFyIGNvbnRleHRLZXlzO1xuXG4gIFx0Ly8gVE9ETy4uLlxuICBcdGlmIChiYXNlQ29udGV4dCAhPSB1bmRlZmluZWQgJiYgdHlwZW9mIGJhc2VDb250ZXh0ICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRiYXNlQ29udGV4dCA9IGJhc2VDb250ZXh0LnN0cjtcbiAgXHR9XG5cbiAgXHQvLyB7ey59fSBtZWFucyAnY3VycmVudCBjb250ZXh0J1xuICBcdGlmIChyZWYgPT09IFwiLlwiKSByZXR1cm4gZ2V0S2V5cGF0aChiYXNlQ29udGV4dCk7XG5cbiAgXHRjb250ZXh0S2V5cyA9IGJhc2VDb250ZXh0ID8gYmFzZUNvbnRleHQuc3BsaXQoXCIuXCIpIDogW107XG5cbiAgXHQvLyBhbmNlc3RvciByZWZlcmVuY2VzIChzdGFydGluZyBcIi4uL1wiKSBnbyB1cCB0aGUgdHJlZVxuICBcdGlmIChyZWYuc3Vic3RyKDAsIDMpID09PSBcIi4uL1wiKSB7XG4gIFx0XHR3aGlsZSAocmVmLnN1YnN0cigwLCAzKSA9PT0gXCIuLi9cIikge1xuICBcdFx0XHRpZiAoIWNvbnRleHRLZXlzLmxlbmd0aCkge1xuICBcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIHJlZmVyZW5jZSAtIHRvbyBtYW55IFxcXCIuLi9cXFwiIHByZWZpeGVzXCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y29udGV4dEtleXMucG9wKCk7XG4gIFx0XHRcdHJlZiA9IHJlZi5zdWJzdHJpbmcoMyk7XG4gIFx0XHR9XG5cbiAgXHRcdGNvbnRleHRLZXlzLnB1c2gocmVmKTtcbiAgXHRcdHJldHVybiBnZXRLZXlwYXRoKGNvbnRleHRLZXlzLmpvaW4oXCIuXCIpKTtcbiAgXHR9XG5cbiAgXHQvLyBub3QgYW4gYW5jZXN0b3IgcmVmZXJlbmNlIC0gbXVzdCBiZSBhIHJlc3RyaWN0ZWQgcmVmZXJlbmNlIChwcmVwZW5kZWQgd2l0aCBcIi5cIiBvciBcIi4vXCIpXG4gIFx0aWYgKCFiYXNlQ29udGV4dCkge1xuICBcdFx0cmV0dXJuIGdldEtleXBhdGgocmVmLnJlcGxhY2UoL15cXC5cXC8/LywgXCJcIikpO1xuICBcdH1cblxuICBcdHJldHVybiBnZXRLZXlwYXRoKGJhc2VDb250ZXh0ICsgcmVmLnJlcGxhY2UoL15cXC5cXC8vLCBcIi5cIikpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUFtYmlndW91c1JlZmVyZW5jZShyYWN0aXZlLCByZWYsIGZyYWdtZW50LCBpc1BhcmVudExvb2t1cCkge1xuICBcdHZhciBjb250ZXh0LCBrZXksIHBhcmVudFZhbHVlLCBoYXNDb250ZXh0Q2hhaW4sIHBhcmVudEtleXBhdGg7XG5cbiAgXHRpZiAocmVmLmlzUm9vdCkge1xuICBcdFx0cmV0dXJuIHJlZjtcbiAgXHR9XG5cbiAgXHRrZXkgPSByZWYuZmlyc3RLZXk7XG5cbiAgXHR3aGlsZSAoZnJhZ21lbnQpIHtcbiAgXHRcdGNvbnRleHQgPSBmcmFnbWVudC5jb250ZXh0O1xuICBcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG5cbiAgXHRcdGlmICghY29udGV4dCkge1xuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0aGFzQ29udGV4dENoYWluID0gdHJ1ZTtcbiAgXHRcdHBhcmVudFZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KGNvbnRleHQpO1xuXG4gIFx0XHRpZiAocGFyZW50VmFsdWUgJiYgKHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcGFyZW50VmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYga2V5IGluIHBhcmVudFZhbHVlKSB7XG4gIFx0XHRcdHJldHVybiBjb250ZXh0LmpvaW4ocmVmLnN0cik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gUm9vdC9jb21wdXRlZC9tYXBwZWQgcHJvcGVydHk/XG4gIFx0aWYgKGlzUm9vdFByb3BlcnR5KHJhY3RpdmUudmlld21vZGVsLCBrZXkpKSB7XG4gIFx0XHRyZXR1cm4gcmVmO1xuICBcdH1cblxuICBcdC8vIElmIHRoaXMgaXMgYW4gaW5saW5lIGNvbXBvbmVudCwgYW5kIGl0J3Mgbm90IGlzb2xhdGVkLCB3ZVxuICBcdC8vIGNhbiB0cnkgZ29pbmcgdXAgdGhlIHNjb3BlIGNoYWluXG4gIFx0aWYgKHJhY3RpdmUucGFyZW50ICYmICFyYWN0aXZlLmlzb2xhdGVkKSB7XG4gIFx0XHRoYXNDb250ZXh0Q2hhaW4gPSB0cnVlO1xuICBcdFx0ZnJhZ21lbnQgPSByYWN0aXZlLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblxuICBcdFx0a2V5ID0gZ2V0S2V5cGF0aChrZXkpO1xuXG4gIFx0XHRpZiAocGFyZW50S2V5cGF0aCA9IHJlc29sdmVBbWJpZ3VvdXNSZWZlcmVuY2UocmFjdGl2ZS5wYXJlbnQsIGtleSwgZnJhZ21lbnQsIHRydWUpKSB7XG4gIFx0XHRcdC8vIFdlIG5lZWQgdG8gY3JlYXRlIGFuIGludGVyLWNvbXBvbmVudCBiaW5kaW5nXG4gIFx0XHRcdHJhY3RpdmUudmlld21vZGVsLm1hcChrZXksIHtcbiAgXHRcdFx0XHRvcmlnaW46IHJhY3RpdmUucGFyZW50LnZpZXdtb2RlbCxcbiAgXHRcdFx0XHRrZXlwYXRoOiBwYXJlbnRLZXlwYXRoXG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHJldHVybiByZWY7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gSWYgdGhlcmUncyBubyBjb250ZXh0IGNoYWluLCBhbmQgdGhlIGluc3RhbmNlIGlzIGVpdGhlciBhKSBpc29sYXRlZCBvclxuICBcdC8vIGIpIGFuIG9ycGhhbiwgdGhlbiB3ZSBrbm93IHRoYXQgdGhlIGtleXBhdGggaXMgaWRlbnRpY2FsIHRvIHRoZSByZWZlcmVuY2VcbiAgXHRpZiAoIWlzUGFyZW50TG9va3VwICYmICFoYXNDb250ZXh0Q2hhaW4pIHtcbiAgXHRcdC8vIHRoZSBkYXRhIG9iamVjdCBuZWVkcyB0byBoYXZlIGEgcHJvcGVydHkgYnkgdGhpcyBuYW1lLFxuICBcdFx0Ly8gdG8gcHJldmVudCBmdXR1cmUgZmFpbGVkIGxvb2t1cHNcbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLnNldChyZWYsIHVuZGVmaW5lZCk7XG4gIFx0XHRyZXR1cm4gcmVmO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1hcHBpbmdJZk5lY2Vzc2FyeShyYWN0aXZlLCBrZXkpIHtcbiAgXHR2YXIgcGFyZW50S2V5cGF0aDtcblxuICBcdGlmICghcmFjdGl2ZS5wYXJlbnQgfHwgcmFjdGl2ZS5pc29sYXRlZCB8fCBpc1Jvb3RQcm9wZXJ0eShyYWN0aXZlLnZpZXdtb2RlbCwga2V5KSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGtleSA9IGdldEtleXBhdGgoa2V5KTtcblxuICBcdGlmIChwYXJlbnRLZXlwYXRoID0gcmVzb2x2ZUFtYmlndW91c1JlZmVyZW5jZShyYWN0aXZlLnBhcmVudCwga2V5LCByYWN0aXZlLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCwgdHJ1ZSkpIHtcbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLm1hcChrZXksIHtcbiAgXHRcdFx0b3JpZ2luOiByYWN0aXZlLnBhcmVudC52aWV3bW9kZWwsXG4gIFx0XHRcdGtleXBhdGg6IHBhcmVudEtleXBhdGhcbiAgXHRcdH0pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUm9vdFByb3BlcnR5KHZpZXdtb2RlbCwga2V5KSB7XG4gIFx0Ly8gc3BlY2lhbCBjYXNlIGZvciByZWZlcmVuY2UgdG8gcm9vdFxuICBcdHJldHVybiBrZXkgPT09IFwiXCIgfHwga2V5IGluIHZpZXdtb2RlbC5kYXRhIHx8IGtleSBpbiB2aWV3bW9kZWwuY29tcHV0YXRpb25zIHx8IGtleSBpbiB2aWV3bW9kZWwubWFwcGluZ3M7XG4gIH1cblxuICBmdW5jdGlvbiB0ZWFyZG93bih4KSB7XG4gICAgeC50ZWFyZG93bigpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWV0aG9kQ2FsbGVyc19fdW5iaW5kKHgpIHtcbiAgICB4LnVuYmluZCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWV0aG9kQ2FsbGVyc19fdW5yZW5kZXIoeCkge1xuICAgIHgudW5yZW5kZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCh4KSB7XG4gICAgeC5jYW5jZWwoKTtcbiAgfVxuXG4gIHZhciBUcmFuc2l0aW9uTWFuYWdlciA9IGZ1bmN0aW9uIChjYWxsYmFjaywgcGFyZW50KSB7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICBcdHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gIFx0dGhpcy5pbnRyb3MgPSBbXTtcbiAgXHR0aGlzLm91dHJvcyA9IFtdO1xuXG4gIFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xuICBcdHRoaXMudG90YWxDaGlsZHJlbiA9IHRoaXMub3V0cm9DaGlsZHJlbiA9IDA7XG5cbiAgXHR0aGlzLmRldGFjaFF1ZXVlID0gW107XG4gIFx0dGhpcy5kZWNvcmF0b3JRdWV1ZSA9IFtdO1xuICBcdHRoaXMub3V0cm9zQ29tcGxldGUgPSBmYWxzZTtcblxuICBcdGlmIChwYXJlbnQpIHtcbiAgXHRcdHBhcmVudC5hZGRDaGlsZCh0aGlzKTtcbiAgXHR9XG4gIH07XG5cbiAgVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlID0ge1xuICBcdGFkZENoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgXHRcdHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cbiAgXHRcdHRoaXMudG90YWxDaGlsZHJlbiArPSAxO1xuICBcdFx0dGhpcy5vdXRyb0NoaWxkcmVuICs9IDE7XG4gIFx0fSxcblxuICBcdGRlY3JlbWVudE91dHJvczogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5vdXRyb0NoaWxkcmVuIC09IDE7XG4gIFx0XHRjaGVjayh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0ZGVjcmVtZW50VG90YWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMudG90YWxDaGlsZHJlbiAtPSAxO1xuICBcdFx0Y2hlY2sodGhpcyk7XG4gIFx0fSxcblxuICBcdGFkZDogZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgXHRcdHZhciBsaXN0ID0gdHJhbnNpdGlvbi5pc0ludHJvID8gdGhpcy5pbnRyb3MgOiB0aGlzLm91dHJvcztcbiAgXHRcdGxpc3QucHVzaCh0cmFuc2l0aW9uKTtcbiAgXHR9LFxuXG4gIFx0YWRkRGVjb3JhdG9yOiBmdW5jdGlvbiAoZGVjb3JhdG9yKSB7XG4gIFx0XHR0aGlzLmRlY29yYXRvclF1ZXVlLnB1c2goZGVjb3JhdG9yKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlOiBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICBcdFx0dmFyIGxpc3QgPSB0cmFuc2l0aW9uLmlzSW50cm8gPyB0aGlzLmludHJvcyA6IHRoaXMub3V0cm9zO1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KGxpc3QsIHRyYW5zaXRpb24pO1xuICBcdFx0Y2hlY2sodGhpcyk7XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMucmVhZHkgPSB0cnVlO1xuICBcdFx0Y2hlY2sodGhpcyk7XG4gIFx0fSxcblxuICBcdGRldGFjaE5vZGVzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmRlY29yYXRvclF1ZXVlLmZvckVhY2godGVhcmRvd24pO1xuICBcdFx0dGhpcy5kZXRhY2hRdWV1ZS5mb3JFYWNoKGRldGFjaCk7XG4gIFx0XHR0aGlzLmNoaWxkcmVuLmZvckVhY2goZGV0YWNoTm9kZXMpO1xuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBkZXRhY2goZWxlbWVudCkge1xuICBcdGVsZW1lbnQuZGV0YWNoKCk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hOb2Rlcyh0bSkge1xuICBcdHRtLmRldGFjaE5vZGVzKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVjayh0bSkge1xuICBcdGlmICghdG0ucmVhZHkgfHwgdG0ub3V0cm9zLmxlbmd0aCB8fCB0bS5vdXRyb0NoaWxkcmVuKSByZXR1cm47XG5cbiAgXHQvLyBJZiBhbGwgb3V0cm9zIGFyZSBjb21wbGV0ZSwgYW5kIHdlIGhhdmVuJ3QgYWxyZWFkeSBkb25lIHRoaXMsXG4gIFx0Ly8gd2Ugbm90aWZ5IHRoZSBwYXJlbnQgaWYgdGhlcmUgaXMgb25lLCBvdGhlcndpc2VcbiAgXHQvLyBzdGFydCBkZXRhY2hpbmcgbm9kZXNcbiAgXHRpZiAoIXRtLm91dHJvc0NvbXBsZXRlKSB7XG4gIFx0XHRpZiAodG0ucGFyZW50KSB7XG4gIFx0XHRcdHRtLnBhcmVudC5kZWNyZW1lbnRPdXRyb3ModG0pO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dG0uZGV0YWNoTm9kZXMoKTtcbiAgXHRcdH1cblxuICBcdFx0dG0ub3V0cm9zQ29tcGxldGUgPSB0cnVlO1xuICBcdH1cblxuICBcdC8vIE9uY2UgZXZlcnl0aGluZyBpcyBkb25lLCB3ZSBjYW4gbm90aWZ5IHBhcmVudCB0cmFuc2l0aW9uXG4gIFx0Ly8gbWFuYWdlciBhbmQgY2FsbCB0aGUgY2FsbGJhY2tcbiAgXHRpZiAoIXRtLmludHJvcy5sZW5ndGggJiYgIXRtLnRvdGFsQ2hpbGRyZW4pIHtcbiAgXHRcdGlmICh0eXBlb2YgdG0uY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHR0bS5jYWxsYmFjaygpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodG0ucGFyZW50KSB7XG4gIFx0XHRcdHRtLnBhcmVudC5kZWNyZW1lbnRUb3RhbCgpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBnbG9iYWxfVHJhbnNpdGlvbk1hbmFnZXIgPSBUcmFuc2l0aW9uTWFuYWdlcjtcblxuICB2YXIgYmF0Y2gsXG4gICAgICBydW5sb29wLFxuICAgICAgdW5yZXNvbHZlZCA9IFtdLFxuICAgICAgY2hhbmdlSG9vayA9IG5ldyBob29rc19Ib29rKFwiY2hhbmdlXCIpO1xuXG4gIHJ1bmxvb3AgPSB7XG4gIFx0c3RhcnQ6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcmV0dXJuUHJvbWlzZSkge1xuICBcdFx0dmFyIHByb21pc2UsIGZ1bGZpbFByb21pc2U7XG5cbiAgXHRcdGlmIChyZXR1cm5Qcm9taXNlKSB7XG4gIFx0XHRcdHByb21pc2UgPSBuZXcgdXRpbHNfUHJvbWlzZShmdW5jdGlvbiAoZikge1xuICBcdFx0XHRcdHJldHVybiBmdWxmaWxQcm9taXNlID0gZjtcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdGJhdGNoID0ge1xuICBcdFx0XHRwcmV2aW91c0JhdGNoOiBiYXRjaCxcbiAgXHRcdFx0dHJhbnNpdGlvbk1hbmFnZXI6IG5ldyBnbG9iYWxfVHJhbnNpdGlvbk1hbmFnZXIoZnVsZmlsUHJvbWlzZSwgYmF0Y2ggJiYgYmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIpLFxuICBcdFx0XHR2aWV3czogW10sXG4gIFx0XHRcdHRhc2tzOiBbXSxcbiAgXHRcdFx0cmFjdGl2ZXM6IFtdLFxuICBcdFx0XHRpbnN0YW5jZTogaW5zdGFuY2VcbiAgXHRcdH07XG5cbiAgXHRcdGlmIChpbnN0YW5jZSkge1xuICBcdFx0XHRiYXRjaC5yYWN0aXZlcy5wdXNoKGluc3RhbmNlKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHByb21pc2U7XG4gIFx0fSxcblxuICBcdGVuZDogZnVuY3Rpb24gKCkge1xuICBcdFx0Zmx1c2hDaGFuZ2VzKCk7XG5cbiAgXHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmluaXQoKTtcbiAgXHRcdGlmICghYmF0Y2gucHJldmlvdXNCYXRjaCAmJiAhIWJhdGNoLmluc3RhbmNlKSBiYXRjaC5pbnN0YW5jZS52aWV3bW9kZWwuY2hhbmdlcyA9IFtdO1xuICBcdFx0YmF0Y2ggPSBiYXRjaC5wcmV2aW91c0JhdGNoO1xuICBcdH0sXG5cbiAgXHRhZGRSYWN0aXZlOiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0aWYgKGJhdGNoKSB7XG4gIFx0XHRcdGFkZFRvQXJyYXkoYmF0Y2gucmFjdGl2ZXMsIHJhY3RpdmUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZWdpc3RlclRyYW5zaXRpb246IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gIFx0XHR0cmFuc2l0aW9uLl9tYW5hZ2VyID0gYmF0Y2gudHJhbnNpdGlvbk1hbmFnZXI7XG4gIFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5hZGQodHJhbnNpdGlvbik7XG4gIFx0fSxcblxuICBcdHJlZ2lzdGVyRGVjb3JhdG9yOiBmdW5jdGlvbiAoZGVjb3JhdG9yKSB7XG4gIFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5hZGREZWNvcmF0b3IoZGVjb3JhdG9yKTtcbiAgXHR9LFxuXG4gIFx0YWRkVmlldzogZnVuY3Rpb24gKHZpZXcpIHtcbiAgXHRcdGJhdGNoLnZpZXdzLnB1c2godmlldyk7XG4gIFx0fSxcblxuICBcdGFkZFVucmVzb2x2ZWQ6IGZ1bmN0aW9uICh0aGluZykge1xuICBcdFx0dW5yZXNvbHZlZC5wdXNoKHRoaW5nKTtcbiAgXHR9LFxuXG4gIFx0cmVtb3ZlVW5yZXNvbHZlZDogZnVuY3Rpb24gKHRoaW5nKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodW5yZXNvbHZlZCwgdGhpbmcpO1xuICBcdH0sXG5cbiAgXHQvLyBzeW5jaHJvbmlzZSBub2RlIGRldGFjaG1lbnRzIHdpdGggdHJhbnNpdGlvbiBlbmRzXG4gIFx0ZGV0YWNoV2hlblJlYWR5OiBmdW5jdGlvbiAodGhpbmcpIHtcbiAgXHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmRldGFjaFF1ZXVlLnB1c2godGhpbmcpO1xuICBcdH0sXG5cbiAgXHRzY2hlZHVsZVRhc2s6IGZ1bmN0aW9uICh0YXNrLCBwb3N0UmVuZGVyKSB7XG4gIFx0XHR2YXIgX2JhdGNoO1xuXG4gIFx0XHRpZiAoIWJhdGNoKSB7XG4gIFx0XHRcdHRhc2soKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdF9iYXRjaCA9IGJhdGNoO1xuICBcdFx0XHR3aGlsZSAocG9zdFJlbmRlciAmJiBfYmF0Y2gucHJldmlvdXNCYXRjaCkge1xuICBcdFx0XHRcdC8vIHRoaXMgY2FuJ3QgaGFwcGVuIHVudGlsIHRoZSBET00gaGFzIGJlZW4gZnVsbHkgdXBkYXRlZFxuICBcdFx0XHRcdC8vIG90aGVyd2lzZSBpbiBzb21lIHNpdHVhdGlvbnMgKHdpdGggY29tcG9uZW50cyBpbnNpZGUgZWxlbWVudHMpXG4gIFx0XHRcdFx0Ly8gdHJhbnNpdGlvbnMgYW5kIGRlY29yYXRvcnMgd2lsbCBpbml0aWFsaXNlIHByZW1hdHVyZWx5XG4gIFx0XHRcdFx0X2JhdGNoID0gX2JhdGNoLnByZXZpb3VzQmF0Y2g7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRfYmF0Y2gudGFza3MucHVzaCh0YXNrKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIGdsb2JhbF9ydW5sb29wID0gcnVubG9vcDtcblxuICBmdW5jdGlvbiBmbHVzaENoYW5nZXMoKSB7XG4gIFx0dmFyIGksIHRoaW5nLCBjaGFuZ2VIYXNoO1xuXG4gIFx0d2hpbGUgKGJhdGNoLnJhY3RpdmVzLmxlbmd0aCkge1xuICBcdFx0dGhpbmcgPSBiYXRjaC5yYWN0aXZlcy5wb3AoKTtcbiAgXHRcdGNoYW5nZUhhc2ggPSB0aGluZy52aWV3bW9kZWwuYXBwbHlDaGFuZ2VzKCk7XG5cbiAgXHRcdGlmIChjaGFuZ2VIYXNoKSB7XG4gIFx0XHRcdGNoYW5nZUhvb2suZmlyZSh0aGluZywgY2hhbmdlSGFzaCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0YXR0ZW1wdEtleXBhdGhSZXNvbHV0aW9uKCk7XG5cbiAgXHQvLyBOb3cgdGhhdCBjaGFuZ2VzIGhhdmUgYmVlbiBmdWxseSBwcm9wYWdhdGVkLCB3ZSBjYW4gdXBkYXRlIHRoZSBET01cbiAgXHQvLyBhbmQgY29tcGxldGUgb3RoZXIgdGFza3NcbiAgXHRmb3IgKGkgPSAwOyBpIDwgYmF0Y2gudmlld3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdGJhdGNoLnZpZXdzW2ldLnVwZGF0ZSgpO1xuICBcdH1cbiAgXHRiYXRjaC52aWV3cy5sZW5ndGggPSAwO1xuXG4gIFx0Zm9yIChpID0gMDsgaSA8IGJhdGNoLnRhc2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRiYXRjaC50YXNrc1tpXSgpO1xuICBcdH1cbiAgXHRiYXRjaC50YXNrcy5sZW5ndGggPSAwO1xuXG4gIFx0Ly8gSWYgdXBkYXRpbmcgdGhlIHZpZXcgY2F1c2VkIHNvbWUgbW9kZWwgYmxvd2JhY2sgLSBlLmcuIGEgdHJpcGxlXG4gIFx0Ly8gY29udGFpbmluZyA8b3B0aW9uPiBlbGVtZW50cyBjYXVzZWQgdGhlIGJpbmRpbmcgb24gdGhlIDxzZWxlY3Q+XG4gIFx0Ly8gdG8gdXBkYXRlIC0gdGhlbiB3ZSBzdGFydCBvdmVyXG4gIFx0aWYgKGJhdGNoLnJhY3RpdmVzLmxlbmd0aCkgcmV0dXJuIGZsdXNoQ2hhbmdlcygpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXR0ZW1wdEtleXBhdGhSZXNvbHV0aW9uKCkge1xuICBcdHZhciBpLCBpdGVtLCBrZXlwYXRoLCByZXNvbHZlZDtcblxuICBcdGkgPSB1bnJlc29sdmVkLmxlbmd0aDtcblxuICBcdC8vIHNlZSBpZiB3ZSBjYW4gcmVzb2x2ZSBhbnkgdW5yZXNvbHZlZCByZWZlcmVuY2VzXG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aXRlbSA9IHVucmVzb2x2ZWRbaV07XG5cbiAgXHRcdGlmIChpdGVtLmtleXBhdGgpIHtcbiAgXHRcdFx0Ly8gaXQgcmVzb2x2ZWQgc29tZSBvdGhlciB3YXkuIFRPRE8gaG93PyB0d28td2F5IGJpbmRpbmc/IFNlZW1zXG4gIFx0XHRcdC8vIHdlaXJkIHRoYXQgd2UnZCBzdGlsbCBlbmQgdXAgaGVyZVxuICBcdFx0XHR1bnJlc29sdmVkLnNwbGljZShpLCAxKTtcbiAgXHRcdFx0Y29udGludWU7IC8vIGF2b2lkIHJlbW92aW5nIHRoZSB3cm9uZyB0aGluZyBzaG91bGQgdGhlIG5leHQgY29uZGl0aW9uIGJlIHRydWVcbiAgXHRcdH1cblxuICBcdFx0aWYgKGtleXBhdGggPSBzaGFyZWRfcmVzb2x2ZVJlZihpdGVtLnJvb3QsIGl0ZW0ucmVmLCBpdGVtLnBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0XHQocmVzb2x2ZWQgfHwgKHJlc29sdmVkID0gW10pKS5wdXNoKHtcbiAgXHRcdFx0XHRpdGVtOiBpdGVtLFxuICBcdFx0XHRcdGtleXBhdGg6IGtleXBhdGhcbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0dW5yZXNvbHZlZC5zcGxpY2UoaSwgMSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHJlc29sdmVkKSB7XG4gIFx0XHRyZXNvbHZlZC5mb3JFYWNoKGdsb2JhbF9ydW5sb29wX19yZXNvbHZlKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnbG9iYWxfcnVubG9vcF9fcmVzb2x2ZShyZXNvbHZlZCkge1xuICBcdHJlc29sdmVkLml0ZW0ucmVzb2x2ZShyZXNvbHZlZC5rZXlwYXRoKTtcbiAgfVxuXG4gIHZhciBxdWV1ZSA9IFtdO1xuXG4gIHZhciBhbmltYXRpb25zID0ge1xuICBcdHRpY2s6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBpLCBhbmltYXRpb24sIG5vdztcblxuICBcdFx0bm93ID0gdXRpbHNfZ2V0VGltZSgpO1xuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCgpO1xuXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0YW5pbWF0aW9uID0gcXVldWVbaV07XG5cbiAgXHRcdFx0aWYgKCFhbmltYXRpb24udGljayhub3cpKSB7XG4gIFx0XHRcdFx0Ly8gYW5pbWF0aW9uIGlzIGNvbXBsZXRlLCByZW1vdmUgaXQgZnJvbSB0aGUgc3RhY2ssIGFuZCBkZWNyZW1lbnQgaSBzbyB3ZSBkb24ndCBtaXNzIG9uZVxuICBcdFx0XHRcdHF1ZXVlLnNwbGljZShpLS0sIDEpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0XHRpZiAocXVldWUubGVuZ3RoKSB7XG4gIFx0XHRcdHJBRihhbmltYXRpb25zLnRpY2spO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0YW5pbWF0aW9ucy5ydW5uaW5nID0gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGFkZDogZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICBcdFx0cXVldWUucHVzaChhbmltYXRpb24pO1xuXG4gIFx0XHRpZiAoIWFuaW1hdGlvbnMucnVubmluZykge1xuICBcdFx0XHRhbmltYXRpb25zLnJ1bm5pbmcgPSB0cnVlO1xuICBcdFx0XHRyQUYoYW5pbWF0aW9ucy50aWNrKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Ly8gVE9ETyBvcHRpbWlzZSB0aGlzXG4gIFx0YWJvcnQ6IGZ1bmN0aW9uIChrZXlwYXRoLCByb290KSB7XG4gIFx0XHR2YXIgaSA9IHF1ZXVlLmxlbmd0aCxcbiAgXHRcdCAgICBhbmltYXRpb247XG5cbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0YW5pbWF0aW9uID0gcXVldWVbaV07XG5cbiAgXHRcdFx0aWYgKGFuaW1hdGlvbi5yb290ID09PSByb290ICYmIGFuaW1hdGlvbi5rZXlwYXRoID09PSBrZXlwYXRoKSB7XG4gIFx0XHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgc2hhcmVkX2FuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuXG4gIHZhciBBbmltYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHZhciBrZXk7XG5cbiAgXHR0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgXHQvLyBmcm9tIGFuZCB0b1xuICBcdGZvciAoa2V5IGluIG9wdGlvbnMpIHtcbiAgXHRcdGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0dGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHRoaXMuaW50ZXJwb2xhdG9yID0gc2hhcmVkX2ludGVycG9sYXRlKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5yb290LCB0aGlzLmludGVycG9sYXRvcik7XG4gIFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuICBcdHRoaXMudGljaygpO1xuICB9O1xuXG4gIEFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG4gIFx0dGljazogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGVsYXBzZWQsIHQsIHZhbHVlLCB0aW1lTm93LCBpbmRleCwga2V5cGF0aDtcblxuICBcdFx0a2V5cGF0aCA9IHRoaXMua2V5cGF0aDtcblxuICBcdFx0aWYgKHRoaXMucnVubmluZykge1xuICBcdFx0XHR0aW1lTm93ID0gRGF0ZS5ub3coKTtcbiAgXHRcdFx0ZWxhcHNlZCA9IHRpbWVOb3cgLSB0aGlzLnN0YXJ0VGltZTtcblxuICBcdFx0XHRpZiAoZWxhcHNlZCA+PSB0aGlzLmR1cmF0aW9uKSB7XG4gIFx0XHRcdFx0aWYgKGtleXBhdGggIT09IG51bGwpIHtcbiAgXHRcdFx0XHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMucm9vdCk7XG4gIFx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldChrZXlwYXRoLCB0aGlzLnRvKTtcbiAgXHRcdFx0XHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmICh0aGlzLnN0ZXApIHtcbiAgXHRcdFx0XHRcdHRoaXMuc3RlcCgxLCB0aGlzLnRvKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHR0aGlzLmNvbXBsZXRlKHRoaXMudG8pO1xuXG4gIFx0XHRcdFx0aW5kZXggPSB0aGlzLnJvb3QuX2FuaW1hdGlvbnMuaW5kZXhPZih0aGlzKTtcblxuICBcdFx0XHRcdC8vIFRPRE8gaW52ZXN0aWdhdGUgd2h5IHRoaXMgaGFwcGVuc1xuICBcdFx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0XHRcdHdhcm5JZkRlYnVnKFwiQW5pbWF0aW9uIHdhcyBub3QgZm91bmRcIik7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0dGhpcy5yb290Ll9hbmltYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG5cbiAgXHRcdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgXHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIHJlbW92ZSBmcm9tIHRoZSBzdGFja1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dCA9IHRoaXMuZWFzaW5nID8gdGhpcy5lYXNpbmcoZWxhcHNlZCAvIHRoaXMuZHVyYXRpb24pIDogZWxhcHNlZCAvIHRoaXMuZHVyYXRpb247XG5cbiAgXHRcdFx0aWYgKGtleXBhdGggIT09IG51bGwpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IHRoaXMuaW50ZXJwb2xhdG9yKHQpO1xuICBcdFx0XHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMucm9vdCk7XG4gIFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoa2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0XHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHRoaXMuc3RlcCkge1xuICBcdFx0XHRcdHRoaXMuc3RlcCh0LCB2YWx1ZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gdHJ1ZTsgLy8ga2VlcCBpbiB0aGUgc3RhY2tcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGZhbHNlOyAvLyByZW1vdmUgZnJvbSB0aGUgc3RhY2tcbiAgXHR9LFxuXG4gIFx0c3RvcDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGluZGV4O1xuXG4gIFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuICBcdFx0aW5kZXggPSB0aGlzLnJvb3QuX2FuaW1hdGlvbnMuaW5kZXhPZih0aGlzKTtcblxuICBcdFx0Ly8gVE9ETyBpbnZlc3RpZ2F0ZSB3aHkgdGhpcyBoYXBwZW5zXG4gIFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKFwiQW5pbWF0aW9uIHdhcyBub3QgZm91bmRcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMucm9vdC5fYW5pbWF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgYW5pbWF0ZV9BbmltYXRpb24gPSBBbmltYXRpb247XG5cbiAgdmFyIHByb3RvdHlwZV9hbmltYXRlID0gUmFjdGl2ZSRhbmltYXRlO1xuXG4gIHZhciBub0FuaW1hdGlvbiA9IHsgc3RvcDogbm9vcCB9O1xuICBmdW5jdGlvbiBSYWN0aXZlJGFuaW1hdGUoa2V5cGF0aCwgdG8sIG9wdGlvbnMpIHtcbiAgXHR2YXIgcHJvbWlzZSwgZnVsZmlsUHJvbWlzZSwgaywgYW5pbWF0aW9uLCBhbmltYXRpb25zLCBlYXNpbmcsIGR1cmF0aW9uLCBzdGVwLCBjb21wbGV0ZSwgbWFrZVZhbHVlQ29sbGVjdG9yLCBjdXJyZW50VmFsdWVzLCBjb2xsZWN0VmFsdWUsIGR1bW15LCBkdW1teU9wdGlvbnM7XG5cbiAgXHRwcm9taXNlID0gbmV3IHV0aWxzX1Byb21pc2UoZnVuY3Rpb24gKGZ1bGZpbCkge1xuICBcdFx0cmV0dXJuIGZ1bGZpbFByb21pc2UgPSBmdWxmaWw7XG4gIFx0fSk7XG5cbiAgXHQvLyBhbmltYXRlIG11bHRpcGxlIGtleXBhdGhzXG4gIFx0aWYgKHR5cGVvZiBrZXlwYXRoID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRvcHRpb25zID0gdG8gfHwge307XG4gIFx0XHRlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcbiAgXHRcdGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcblxuICBcdFx0YW5pbWF0aW9ucyA9IFtdO1xuXG4gIFx0XHQvLyB3ZSBkb24ndCB3YW50IHRvIHBhc3MgdGhlIGBzdGVwYCBhbmQgYGNvbXBsZXRlYCBoYW5kbGVycywgYXMgdGhleSB3aWxsXG4gIFx0XHQvLyBydW4gZm9yIGVhY2ggYW5pbWF0aW9uISBTbyBpbnN0ZWFkIHdlJ2xsIHN0b3JlIHRoZSBoYW5kbGVycyBhbmQgY3JlYXRlXG4gIFx0XHQvLyBvdXIgb3duLi4uXG4gIFx0XHRzdGVwID0gb3B0aW9ucy5zdGVwO1xuICBcdFx0Y29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xuXG4gIFx0XHRpZiAoc3RlcCB8fCBjb21wbGV0ZSkge1xuICBcdFx0XHRjdXJyZW50VmFsdWVzID0ge307XG5cbiAgXHRcdFx0b3B0aW9ucy5zdGVwID0gbnVsbDtcbiAgXHRcdFx0b3B0aW9ucy5jb21wbGV0ZSA9IG51bGw7XG5cbiAgXHRcdFx0bWFrZVZhbHVlQ29sbGVjdG9yID0gZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKHQsIHZhbHVlKSB7XG4gIFx0XHRcdFx0XHRjdXJyZW50VmFsdWVzW2tleXBhdGhdID0gdmFsdWU7XG4gIFx0XHRcdFx0fTtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0Zm9yIChrIGluIGtleXBhdGgpIHtcbiAgXHRcdFx0aWYgKGtleXBhdGguaGFzT3duUHJvcGVydHkoaykpIHtcbiAgXHRcdFx0XHRpZiAoc3RlcCB8fCBjb21wbGV0ZSkge1xuICBcdFx0XHRcdFx0Y29sbGVjdFZhbHVlID0gbWFrZVZhbHVlQ29sbGVjdG9yKGspO1xuICBcdFx0XHRcdFx0b3B0aW9ucyA9IHsgZWFzaW5nOiBlYXNpbmcsIGR1cmF0aW9uOiBkdXJhdGlvbiB9O1xuXG4gIFx0XHRcdFx0XHRpZiAoc3RlcCkge1xuICBcdFx0XHRcdFx0XHRvcHRpb25zLnN0ZXAgPSBjb2xsZWN0VmFsdWU7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGNvbXBsZXRlID8gY29sbGVjdFZhbHVlIDogbm9vcDtcbiAgXHRcdFx0XHRhbmltYXRpb25zLnB1c2goYW5pbWF0ZSh0aGlzLCBrLCBrZXlwYXRoW2tdLCBvcHRpb25zKSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gQ3JlYXRlIGEgZHVtbXkgYW5pbWF0aW9uLCB0byBmYWNpbGl0YXRlIHN0ZXAvY29tcGxldGVcbiAgXHRcdC8vIGNhbGxiYWNrcywgYW5kIFByb21pc2UgZnVsZmlsbWVudFxuICBcdFx0ZHVtbXlPcHRpb25zID0geyBlYXNpbmc6IGVhc2luZywgZHVyYXRpb246IGR1cmF0aW9uIH07XG5cbiAgXHRcdGlmIChzdGVwKSB7XG4gIFx0XHRcdGR1bW15T3B0aW9ucy5zdGVwID0gZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0XHRyZXR1cm4gc3RlcCh0LCBjdXJyZW50VmFsdWVzKTtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGNvbXBsZXRlKSB7XG4gIFx0XHRcdHByb21pc2UudGhlbihmdW5jdGlvbiAodCkge1xuICBcdFx0XHRcdHJldHVybiBjb21wbGV0ZSh0LCBjdXJyZW50VmFsdWVzKTtcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdGR1bW15T3B0aW9ucy5jb21wbGV0ZSA9IGZ1bGZpbFByb21pc2U7XG5cbiAgXHRcdGR1bW15ID0gYW5pbWF0ZSh0aGlzLCBudWxsLCBudWxsLCBkdW1teU9wdGlvbnMpO1xuICBcdFx0YW5pbWF0aW9ucy5wdXNoKGR1bW15KTtcblxuICBcdFx0cHJvbWlzZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHR2YXIgYW5pbWF0aW9uO1xuXG4gIFx0XHRcdHdoaWxlIChhbmltYXRpb24gPSBhbmltYXRpb25zLnBvcCgpKSB7XG4gIFx0XHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChkdW1teSkge1xuICBcdFx0XHRcdGR1bW15LnN0b3AoKTtcbiAgXHRcdFx0fVxuICBcdFx0fTtcblxuICBcdFx0cmV0dXJuIHByb21pc2U7XG4gIFx0fVxuXG4gIFx0Ly8gYW5pbWF0ZSBhIHNpbmdsZSBrZXlwYXRoXG4gIFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgXHRpZiAob3B0aW9ucy5jb21wbGV0ZSkge1xuICBcdFx0cHJvbWlzZS50aGVuKG9wdGlvbnMuY29tcGxldGUpO1xuICBcdH1cblxuICBcdG9wdGlvbnMuY29tcGxldGUgPSBmdWxmaWxQcm9taXNlO1xuICBcdGFuaW1hdGlvbiA9IGFuaW1hdGUodGhpcywga2V5cGF0aCwgdG8sIG9wdGlvbnMpO1xuXG4gIFx0cHJvbWlzZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGFuaW1hdGlvbi5zdG9wKCk7XG4gIFx0fTtcbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFuaW1hdGUocm9vdCwga2V5cGF0aCwgdG8sIG9wdGlvbnMpIHtcbiAgXHR2YXIgZWFzaW5nLCBkdXJhdGlvbiwgYW5pbWF0aW9uLCBmcm9tO1xuXG4gIFx0aWYgKGtleXBhdGgpIHtcbiAgXHRcdGtleXBhdGggPSBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSk7XG4gIFx0fVxuXG4gIFx0aWYgKGtleXBhdGggIT09IG51bGwpIHtcbiAgXHRcdGZyb20gPSByb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0fVxuXG4gIFx0Ly8gY2FuY2VsIGFueSBleGlzdGluZyBhbmltYXRpb25cbiAgXHQvLyBUT0RPIHdoYXQgYWJvdXQgdXBzdHJlYW0vZG93bnN0cmVhbSBrZXlwYXRocz9cbiAgXHRzaGFyZWRfYW5pbWF0aW9ucy5hYm9ydChrZXlwYXRoLCByb290KTtcblxuICBcdC8vIGRvbid0IGJvdGhlciBhbmltYXRpbmcgdmFsdWVzIHRoYXQgc3RheSB0aGUgc2FtZVxuICBcdGlmIChpc0VxdWFsKGZyb20sIHRvKSkge1xuICBcdFx0aWYgKG9wdGlvbnMuY29tcGxldGUpIHtcbiAgXHRcdFx0b3B0aW9ucy5jb21wbGV0ZShvcHRpb25zLnRvKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG5vQW5pbWF0aW9uO1xuICBcdH1cblxuICBcdC8vIGVhc2luZyBmdW5jdGlvblxuICBcdGlmIChvcHRpb25zLmVhc2luZykge1xuICBcdFx0aWYgKHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZWFzaW5nID0gcm9vdC5lYXNpbmdbb3B0aW9ucy5lYXNpbmddO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodHlwZW9mIGVhc2luZyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdGVhc2luZyA9IG51bGw7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gZHVyYXRpb25cbiAgXHRkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPT09IHVuZGVmaW5lZCA/IDQwMCA6IG9wdGlvbnMuZHVyYXRpb247XG5cbiAgXHQvLyBUT0RPIHN0b3JlIGtleXMsIHVzZSBhbiBpbnRlcm5hbCBzZXQgbWV0aG9kXG4gIFx0YW5pbWF0aW9uID0gbmV3IGFuaW1hdGVfQW5pbWF0aW9uKHtcbiAgXHRcdGtleXBhdGg6IGtleXBhdGgsXG4gIFx0XHRmcm9tOiBmcm9tLFxuICBcdFx0dG86IHRvLFxuICBcdFx0cm9vdDogcm9vdCxcbiAgXHRcdGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgXHRcdGVhc2luZzogZWFzaW5nLFxuICBcdFx0aW50ZXJwb2xhdG9yOiBvcHRpb25zLmludGVycG9sYXRvcixcblxuICBcdFx0Ly8gVE9ETyB3cmFwIGNhbGxiYWNrcyBpZiBuZWNlc3NhcnksIHRvIHVzZSBpbnN0YW5jZSBhcyBjb250ZXh0XG4gIFx0XHRzdGVwOiBvcHRpb25zLnN0ZXAsXG4gIFx0XHRjb21wbGV0ZTogb3B0aW9ucy5jb21wbGV0ZVxuICBcdH0pO1xuXG4gIFx0c2hhcmVkX2FuaW1hdGlvbnMuYWRkKGFuaW1hdGlvbik7XG4gIFx0cm9vdC5fYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG5cbiAgXHRyZXR1cm4gYW5pbWF0aW9uO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9kZXRhY2ggPSBSYWN0aXZlJGRldGFjaDtcbiAgdmFyIHByb3RvdHlwZV9kZXRhY2hfX2RldGFjaEhvb2sgPSBuZXcgaG9va3NfSG9vayhcImRldGFjaFwiKTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRkZXRhY2goKSB7XG4gIFx0aWYgKHRoaXMuZGV0YWNoZWQpIHtcbiAgXHRcdHJldHVybiB0aGlzLmRldGFjaGVkO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmVsKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIHRoaXMpO1xuICBcdH1cbiAgXHR0aGlzLmRldGFjaGVkID0gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcbiAgXHRwcm90b3R5cGVfZGV0YWNoX19kZXRhY2hIb29rLmZpcmUodGhpcyk7XG4gIFx0cmV0dXJuIHRoaXMuZGV0YWNoZWQ7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpbmQgPSBSYWN0aXZlJGZpbmQ7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kKHNlbGVjdG9yKSB7XG4gIFx0aWYgKCF0aGlzLmVsKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKHNlbGVjdG9yKTtcbiAgfVxuXG4gIHZhciB0ZXN0ID0gUXVlcnkkdGVzdDtcbiAgZnVuY3Rpb24gUXVlcnkkdGVzdChpdGVtLCBub0RpcnR5KSB7XG4gIFx0dmFyIGl0ZW1NYXRjaGVzO1xuXG4gIFx0aWYgKHRoaXMuX2lzQ29tcG9uZW50UXVlcnkpIHtcbiAgXHRcdGl0ZW1NYXRjaGVzID0gIXRoaXMuc2VsZWN0b3IgfHwgaXRlbS5uYW1lID09PSB0aGlzLnNlbGVjdG9yO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRpdGVtTWF0Y2hlcyA9IGl0ZW0ubm9kZSA/IG1hdGNoZXMoaXRlbS5ub2RlLCB0aGlzLnNlbGVjdG9yKSA6IG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKGl0ZW1NYXRjaGVzKSB7XG4gIFx0XHR0aGlzLnB1c2goaXRlbS5ub2RlIHx8IGl0ZW0uaW5zdGFuY2UpO1xuXG4gIFx0XHRpZiAoIW5vRGlydHkpIHtcbiAgXHRcdFx0dGhpcy5fbWFrZURpcnR5KCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cbiAgfVxuXG4gIHZhciBtYWtlUXVlcnlfY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICBcdHZhciBsaXZlUXVlcmllcywgc2VsZWN0b3IsIGluZGV4O1xuXG4gIFx0bGl2ZVF1ZXJpZXMgPSB0aGlzLl9yb290W3RoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyBcImxpdmVDb21wb25lbnRRdWVyaWVzXCIgOiBcImxpdmVRdWVyaWVzXCJdO1xuICBcdHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcblxuICBcdGluZGV4ID0gbGl2ZVF1ZXJpZXMuaW5kZXhPZihzZWxlY3Rvcik7XG5cbiAgXHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRsaXZlUXVlcmllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0bGl2ZVF1ZXJpZXNbc2VsZWN0b3JdID0gbnVsbDtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIHNvcnRCeUl0ZW1Qb3NpdGlvbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIFx0dmFyIGFuY2VzdHJ5QSwgYW5jZXN0cnlCLCBvbGRlc3RBLCBvbGRlc3RCLCBtdXR1YWxBbmNlc3RvciwgaW5kZXhBLCBpbmRleEIsIGZyYWdtZW50cywgZnJhZ21lbnRBLCBmcmFnbWVudEI7XG5cbiAgXHRhbmNlc3RyeUEgPSBnZXRBbmNlc3RyeShhLmNvbXBvbmVudCB8fCBhLl9yYWN0aXZlLnByb3h5KTtcbiAgXHRhbmNlc3RyeUIgPSBnZXRBbmNlc3RyeShiLmNvbXBvbmVudCB8fCBiLl9yYWN0aXZlLnByb3h5KTtcblxuICBcdG9sZGVzdEEgPSBsYXN0SXRlbShhbmNlc3RyeUEpO1xuICBcdG9sZGVzdEIgPSBsYXN0SXRlbShhbmNlc3RyeUIpO1xuXG4gIFx0Ly8gcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIGVuZCBvZiBib3RoIGFuY2VzdHJpZXMgYXMgbG9uZyBhcyB0aGV5IGFyZSBpZGVudGljYWxcbiAgXHQvLyAtIHRoZSBmaW5hbCBvbmUgcmVtb3ZlZCBpcyB0aGUgY2xvc2VzdCBtdXR1YWwgYW5jZXN0b3JcbiAgXHR3aGlsZSAob2xkZXN0QSAmJiBvbGRlc3RBID09PSBvbGRlc3RCKSB7XG4gIFx0XHRhbmNlc3RyeUEucG9wKCk7XG4gIFx0XHRhbmNlc3RyeUIucG9wKCk7XG5cbiAgXHRcdG11dHVhbEFuY2VzdG9yID0gb2xkZXN0QTtcblxuICBcdFx0b2xkZXN0QSA9IGxhc3RJdGVtKGFuY2VzdHJ5QSk7XG4gIFx0XHRvbGRlc3RCID0gbGFzdEl0ZW0oYW5jZXN0cnlCKTtcbiAgXHR9XG5cbiAgXHQvLyBub3cgdGhhdCB3ZSBoYXZlIHRoZSBtdXR1YWwgYW5jZXN0b3IsIHdlIGNhbiBmaW5kIHdoaWNoIGlzIGVhcmxpZXN0XG4gIFx0b2xkZXN0QSA9IG9sZGVzdEEuY29tcG9uZW50IHx8IG9sZGVzdEE7XG4gIFx0b2xkZXN0QiA9IG9sZGVzdEIuY29tcG9uZW50IHx8IG9sZGVzdEI7XG5cbiAgXHRmcmFnbWVudEEgPSBvbGRlc3RBLnBhcmVudEZyYWdtZW50O1xuICBcdGZyYWdtZW50QiA9IG9sZGVzdEIucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHQvLyBpZiBib3RoIGl0ZW1zIHNoYXJlIGEgcGFyZW50IGZyYWdtZW50LCBvdXIgam9iIGlzIGVhc3lcbiAgXHRpZiAoZnJhZ21lbnRBID09PSBmcmFnbWVudEIpIHtcbiAgXHRcdGluZGV4QSA9IGZyYWdtZW50QS5pdGVtcy5pbmRleE9mKG9sZGVzdEEpO1xuICBcdFx0aW5kZXhCID0gZnJhZ21lbnRCLml0ZW1zLmluZGV4T2Yob2xkZXN0Qik7XG5cbiAgXHRcdC8vIGlmIGl0J3MgdGhlIHNhbWUgaW5kZXgsIGl0IG1lYW5zIG9uZSBjb250YWlucyB0aGUgb3RoZXIsXG4gIFx0XHQvLyBzbyB3ZSBzZWUgd2hpY2ggaGFzIHRoZSBsb25nZXN0IGFuY2VzdHJ5XG4gIFx0XHRyZXR1cm4gaW5kZXhBIC0gaW5kZXhCIHx8IGFuY2VzdHJ5QS5sZW5ndGggLSBhbmNlc3RyeUIubGVuZ3RoO1xuICBcdH1cblxuICBcdC8vIGlmIG11dHVhbCBhbmNlc3RvciBpcyBhIHNlY3Rpb24sIHdlIGZpcnN0IHRlc3QgdG8gc2VlIHdoaWNoIHNlY3Rpb25cbiAgXHQvLyBmcmFnbWVudCBjb21lcyBmaXJzdFxuICBcdGlmIChmcmFnbWVudHMgPSBtdXR1YWxBbmNlc3Rvci5mcmFnbWVudHMpIHtcbiAgXHRcdGluZGV4QSA9IGZyYWdtZW50cy5pbmRleE9mKGZyYWdtZW50QSk7XG4gIFx0XHRpbmRleEIgPSBmcmFnbWVudHMuaW5kZXhPZihmcmFnbWVudEIpO1xuXG4gIFx0XHRyZXR1cm4gaW5kZXhBIC0gaW5kZXhCIHx8IGFuY2VzdHJ5QS5sZW5ndGggLSBhbmNlc3RyeUIubGVuZ3RoO1xuICBcdH1cblxuICBcdHRocm93IG5ldyBFcnJvcihcIkFuIHVuZXhwZWN0ZWQgY29uZGl0aW9uIHdhcyBtZXQgd2hpbGUgY29tcGFyaW5nIHRoZSBwb3NpdGlvbiBvZiB0d28gY29tcG9uZW50cy4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3VlcyAtIHRoYW5rcyFcIik7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0UGFyZW50KGl0ZW0pIHtcbiAgXHR2YXIgcGFyZW50RnJhZ21lbnQ7XG5cbiAgXHRpZiAocGFyZW50RnJhZ21lbnQgPSBpdGVtLnBhcmVudEZyYWdtZW50KSB7XG4gIFx0XHRyZXR1cm4gcGFyZW50RnJhZ21lbnQub3duZXI7XG4gIFx0fVxuXG4gIFx0aWYgKGl0ZW0uY29tcG9uZW50ICYmIChwYXJlbnRGcmFnbWVudCA9IGl0ZW0uY29tcG9uZW50LnBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0cmV0dXJuIHBhcmVudEZyYWdtZW50Lm93bmVyO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFuY2VzdHJ5KGl0ZW0pIHtcbiAgXHR2YXIgYW5jZXN0cnksIGFuY2VzdG9yO1xuXG4gIFx0YW5jZXN0cnkgPSBbaXRlbV07XG5cbiAgXHRhbmNlc3RvciA9IGdldFBhcmVudChpdGVtKTtcblxuICBcdHdoaWxlIChhbmNlc3Rvcikge1xuICBcdFx0YW5jZXN0cnkucHVzaChhbmNlc3Rvcik7XG4gIFx0XHRhbmNlc3RvciA9IGdldFBhcmVudChhbmNlc3Rvcik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGFuY2VzdHJ5O1xuICB9XG5cbiAgdmFyIHNvcnRCeURvY3VtZW50UG9zaXRpb24gPSBmdW5jdGlvbiAobm9kZSwgb3RoZXJOb2RlKSB7XG4gIFx0dmFyIGJpdG1hc2s7XG5cbiAgXHRpZiAobm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICBcdFx0Yml0bWFzayA9IG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24ob3RoZXJOb2RlKTtcbiAgXHRcdHJldHVybiBiaXRtYXNrICYgMiA/IDEgOiAtMTtcbiAgXHR9XG5cbiAgXHQvLyBJbiBvbGQgSUUsIHdlIGNhbiBwaWdneSBiYWNrIG9uIHRoZSBtZWNoYW5pc20gZm9yXG4gIFx0Ly8gY29tcGFyaW5nIGNvbXBvbmVudCBwb3NpdGlvbnNcbiAgXHRyZXR1cm4gc29ydEJ5SXRlbVBvc2l0aW9uKG5vZGUsIG90aGVyTm9kZSk7XG4gIH07XG5cbiAgdmFyIHNvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIFx0dGhpcy5zb3J0KHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyBzb3J0QnlJdGVtUG9zaXRpb24gOiBzb3J0QnlEb2N1bWVudFBvc2l0aW9uKTtcbiAgXHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBtYWtlUXVlcnlfZGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdGlmICghdGhpcy5fZGlydHkpIHtcbiAgXHRcdHRoaXMuX2RpcnR5ID0gdHJ1ZTtcblxuICBcdFx0Ly8gT25jZSB0aGUgRE9NIGhhcyBiZWVuIHVwZGF0ZWQsIGVuc3VyZSB0aGUgcXVlcnlcbiAgXHRcdC8vIGlzIGNvcnJlY3RseSBvcmRlcmVkXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRfdGhpcy5fc29ydCgpO1xuICBcdFx0fSk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciByZW1vdmUgPSBmdW5jdGlvbiAobm9kZU9yQ29tcG9uZW50KSB7XG4gIFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleE9mKHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyBub2RlT3JDb21wb25lbnQuaW5zdGFuY2UgOiBub2RlT3JDb21wb25lbnQpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0dGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgX21ha2VRdWVyeSA9IG1ha2VRdWVyeTtcbiAgZnVuY3Rpb24gbWFrZVF1ZXJ5KHJhY3RpdmUsIHNlbGVjdG9yLCBsaXZlLCBpc0NvbXBvbmVudFF1ZXJ5KSB7XG4gIFx0dmFyIHF1ZXJ5ID0gW107XG5cbiAgXHRkZWZpbmVQcm9wZXJ0aWVzKHF1ZXJ5LCB7XG4gIFx0XHRzZWxlY3RvcjogeyB2YWx1ZTogc2VsZWN0b3IgfSxcbiAgXHRcdGxpdmU6IHsgdmFsdWU6IGxpdmUgfSxcblxuICBcdFx0X2lzQ29tcG9uZW50UXVlcnk6IHsgdmFsdWU6IGlzQ29tcG9uZW50UXVlcnkgfSxcbiAgXHRcdF90ZXN0OiB7IHZhbHVlOiB0ZXN0IH1cbiAgXHR9KTtcblxuICBcdGlmICghbGl2ZSkge1xuICBcdFx0cmV0dXJuIHF1ZXJ5O1xuICBcdH1cblxuICBcdGRlZmluZVByb3BlcnRpZXMocXVlcnksIHtcbiAgXHRcdGNhbmNlbDogeyB2YWx1ZTogbWFrZVF1ZXJ5X2NhbmNlbCB9LFxuXG4gIFx0XHRfcm9vdDogeyB2YWx1ZTogcmFjdGl2ZSB9LFxuICBcdFx0X3NvcnQ6IHsgdmFsdWU6IHNvcnQgfSxcbiAgXHRcdF9tYWtlRGlydHk6IHsgdmFsdWU6IG1ha2VRdWVyeV9kaXJ0eSB9LFxuICBcdFx0X3JlbW92ZTogeyB2YWx1ZTogcmVtb3ZlIH0sXG5cbiAgXHRcdF9kaXJ0eTogeyB2YWx1ZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH1cbiAgXHR9KTtcblxuICBcdHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmluZEFsbCA9IFJhY3RpdmUkZmluZEFsbDtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQWxsKHNlbGVjdG9yLCBvcHRpb25zKSB7XG4gIFx0dmFyIGxpdmVRdWVyaWVzLCBxdWVyeTtcblxuICBcdGlmICghdGhpcy5lbCkge1xuICBcdFx0cmV0dXJuIFtdO1xuICBcdH1cblxuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBcdGxpdmVRdWVyaWVzID0gdGhpcy5fbGl2ZVF1ZXJpZXM7XG5cbiAgXHQvLyBTaG9ydGN1dDogaWYgd2UncmUgbWFpbnRhaW5pbmcgYSBsaXZlIHF1ZXJ5IHdpdGggdGhpc1xuICBcdC8vIHNlbGVjdG9yLCB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSBwYXJhbGxlbCBET01cbiAgXHRpZiAocXVlcnkgPSBsaXZlUXVlcmllc1tzZWxlY3Rvcl0pIHtcblxuICBcdFx0Ly8gRWl0aGVyIHJldHVybiB0aGUgZXhhY3Qgc2FtZSBxdWVyeSwgb3IgKGlmIG5vdCBsaXZlKSBhIHNuYXBzaG90XG4gIFx0XHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmxpdmUgPyBxdWVyeSA6IHF1ZXJ5LnNsaWNlKCk7XG4gIFx0fVxuXG4gIFx0cXVlcnkgPSBfbWFrZVF1ZXJ5KHRoaXMsIHNlbGVjdG9yLCAhIW9wdGlvbnMubGl2ZSwgZmFsc2UpO1xuXG4gIFx0Ly8gQWRkIHRoaXMgdG8gdGhlIGxpc3Qgb2YgbGl2ZSBxdWVyaWVzIFJhY3RpdmUgbmVlZHMgdG8gbWFpbnRhaW4sXG4gIFx0Ly8gaWYgYXBwbGljYWJsZVxuICBcdGlmIChxdWVyeS5saXZlKSB7XG4gIFx0XHRsaXZlUXVlcmllcy5wdXNoKHNlbGVjdG9yKTtcbiAgXHRcdGxpdmVRdWVyaWVzW1wiX1wiICsgc2VsZWN0b3JdID0gcXVlcnk7XG4gIFx0fVxuXG4gIFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0cmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyA9IFJhY3RpdmUkZmluZEFsbENvbXBvbmVudHM7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgXHR2YXIgbGl2ZVF1ZXJpZXMsIHF1ZXJ5O1xuXG4gIFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFx0bGl2ZVF1ZXJpZXMgPSB0aGlzLl9saXZlQ29tcG9uZW50UXVlcmllcztcblxuICBcdC8vIFNob3J0Y3V0OiBpZiB3ZSdyZSBtYWludGFpbmluZyBhIGxpdmUgcXVlcnkgd2l0aCB0aGlzXG4gIFx0Ly8gc2VsZWN0b3IsIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHBhcmFsbGVsIERPTVxuICBcdGlmIChxdWVyeSA9IGxpdmVRdWVyaWVzW3NlbGVjdG9yXSkge1xuXG4gIFx0XHQvLyBFaXRoZXIgcmV0dXJuIHRoZSBleGFjdCBzYW1lIHF1ZXJ5LCBvciAoaWYgbm90IGxpdmUpIGEgc25hcHNob3RcbiAgXHRcdHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMubGl2ZSA/IHF1ZXJ5IDogcXVlcnkuc2xpY2UoKTtcbiAgXHR9XG5cbiAgXHRxdWVyeSA9IF9tYWtlUXVlcnkodGhpcywgc2VsZWN0b3IsICEhb3B0aW9ucy5saXZlLCB0cnVlKTtcblxuICBcdC8vIEFkZCB0aGlzIHRvIHRoZSBsaXN0IG9mIGxpdmUgcXVlcmllcyBSYWN0aXZlIG5lZWRzIHRvIG1haW50YWluLFxuICBcdC8vIGlmIGFwcGxpY2FibGVcbiAgXHRpZiAocXVlcnkubGl2ZSkge1xuICBcdFx0bGl2ZVF1ZXJpZXMucHVzaChzZWxlY3Rvcik7XG4gIFx0XHRsaXZlUXVlcmllc1tcIl9cIiArIHNlbGVjdG9yXSA9IHF1ZXJ5O1xuICBcdH1cblxuICBcdHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHRyZXR1cm4gcXVlcnk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpbmRDb21wb25lbnQgPSBSYWN0aXZlJGZpbmRDb21wb25lbnQ7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQ29tcG9uZW50KHNlbGVjdG9yKSB7XG4gIFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudChzZWxlY3Rvcik7XG4gIH1cblxuICB2YXIgZmluZENvbnRhaW5lciA9IFJhY3RpdmUkZmluZENvbnRhaW5lcjtcblxuICBmdW5jdGlvbiBSYWN0aXZlJGZpbmRDb250YWluZXIoc2VsZWN0b3IpIHtcbiAgXHRpZiAodGhpcy5jb250YWluZXIpIHtcbiAgXHRcdGlmICh0aGlzLmNvbnRhaW5lci5jb21wb25lbnQgJiYgdGhpcy5jb250YWluZXIuY29tcG9uZW50Lm5hbWUgPT09IHNlbGVjdG9yKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmNvbnRhaW5lci5maW5kQ29udGFpbmVyKHNlbGVjdG9yKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBmaW5kUGFyZW50ID0gUmFjdGl2ZSRmaW5kUGFyZW50O1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZFBhcmVudChzZWxlY3Rvcikge1xuXG4gIFx0aWYgKHRoaXMucGFyZW50KSB7XG4gIFx0XHRpZiAodGhpcy5wYXJlbnQuY29tcG9uZW50ICYmIHRoaXMucGFyZW50LmNvbXBvbmVudC5uYW1lID09PSBzZWxlY3Rvcikge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQuZmluZFBhcmVudChzZWxlY3Rvcik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnRTdGFjayA9IHtcbiAgXHRlbnF1ZXVlOiBmdW5jdGlvbiAocmFjdGl2ZSwgZXZlbnQpIHtcbiAgXHRcdGlmIChyYWN0aXZlLmV2ZW50KSB7XG4gIFx0XHRcdHJhY3RpdmUuX2V2ZW50UXVldWUgPSByYWN0aXZlLl9ldmVudFF1ZXVlIHx8IFtdO1xuICBcdFx0XHRyYWN0aXZlLl9ldmVudFF1ZXVlLnB1c2gocmFjdGl2ZS5ldmVudCk7XG4gIFx0XHR9XG4gIFx0XHRyYWN0aXZlLmV2ZW50ID0gZXZlbnQ7XG4gIFx0fSxcbiAgXHRkZXF1ZXVlOiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0aWYgKHJhY3RpdmUuX2V2ZW50UXVldWUgJiYgcmFjdGl2ZS5fZXZlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgXHRcdFx0cmFjdGl2ZS5ldmVudCA9IHJhY3RpdmUuX2V2ZW50UXVldWUucG9wKCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRkZWxldGUgcmFjdGl2ZS5ldmVudDtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9ldmVudFN0YWNrID0gZXZlbnRTdGFjaztcblxuICB2YXIgc2hhcmVkX2ZpcmVFdmVudCA9IGZpcmVFdmVudDtcblxuICBmdW5jdGlvbiBmaXJlRXZlbnQocmFjdGl2ZSwgZXZlbnROYW1lKSB7XG4gIFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdO1xuXG4gIFx0aWYgKCFldmVudE5hbWUpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAoIW9wdGlvbnMuZXZlbnQpIHtcbiAgXHRcdG9wdGlvbnMuZXZlbnQgPSB7XG4gIFx0XHRcdG5hbWU6IGV2ZW50TmFtZSxcbiAgXHRcdFx0Ly8gdW50aWwgZXZlbnQgbm90IGluY2x1ZGVkIGFzIGFyZ3VtZW50IGRlZmF1bHRcbiAgXHRcdFx0X25vQXJnOiB0cnVlXG4gIFx0XHR9O1xuICBcdH0gZWxzZSB7XG4gIFx0XHRvcHRpb25zLmV2ZW50Lm5hbWUgPSBldmVudE5hbWU7XG4gIFx0fVxuXG4gIFx0dmFyIGV2ZW50TmFtZXMgPSBnZXRLZXlwYXRoKGV2ZW50TmFtZSkud2lsZGNhcmRNYXRjaGVzKCk7XG4gIFx0ZmlyZUV2ZW50QXMocmFjdGl2ZSwgZXZlbnROYW1lcywgb3B0aW9ucy5ldmVudCwgb3B0aW9ucy5hcmdzLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVFdmVudEFzKHJhY3RpdmUsIGV2ZW50TmFtZXMsIGV2ZW50LCBhcmdzKSB7XG4gIFx0dmFyIGluaXRpYWxGaXJlID0gYXJndW1lbnRzWzRdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1s0XTtcblxuICBcdHZhciBzdWJzY3JpYmVycyxcbiAgXHQgICAgaSxcbiAgXHQgICAgYnViYmxlID0gdHJ1ZTtcblxuICBcdHNoYXJlZF9ldmVudFN0YWNrLmVucXVldWUocmFjdGl2ZSwgZXZlbnQpO1xuXG4gIFx0Zm9yIChpID0gZXZlbnROYW1lcy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gIFx0XHRzdWJzY3JpYmVycyA9IHJhY3RpdmUuX3N1YnNbZXZlbnROYW1lc1tpXV07XG5cbiAgXHRcdGlmIChzdWJzY3JpYmVycykge1xuICBcdFx0XHRidWJibGUgPSBub3RpZnlTdWJzY3JpYmVycyhyYWN0aXZlLCBzdWJzY3JpYmVycywgZXZlbnQsIGFyZ3MpICYmIGJ1YmJsZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRzaGFyZWRfZXZlbnRTdGFjay5kZXF1ZXVlKHJhY3RpdmUpO1xuXG4gIFx0aWYgKHJhY3RpdmUucGFyZW50ICYmIGJ1YmJsZSkge1xuXG4gIFx0XHRpZiAoaW5pdGlhbEZpcmUgJiYgcmFjdGl2ZS5jb21wb25lbnQpIHtcbiAgXHRcdFx0dmFyIGZ1bGxOYW1lID0gcmFjdGl2ZS5jb21wb25lbnQubmFtZSArIFwiLlwiICsgZXZlbnROYW1lc1tldmVudE5hbWVzLmxlbmd0aCAtIDFdO1xuICBcdFx0XHRldmVudE5hbWVzID0gZ2V0S2V5cGF0aChmdWxsTmFtZSkud2lsZGNhcmRNYXRjaGVzKCk7XG5cbiAgXHRcdFx0aWYgKGV2ZW50KSB7XG4gIFx0XHRcdFx0ZXZlbnQuY29tcG9uZW50ID0gcmFjdGl2ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRmaXJlRXZlbnRBcyhyYWN0aXZlLnBhcmVudCwgZXZlbnROYW1lcywgZXZlbnQsIGFyZ3MpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeVN1YnNjcmliZXJzKHJhY3RpdmUsIHN1YnNjcmliZXJzLCBldmVudCwgYXJncykge1xuICBcdHZhciBvcmlnaW5hbEV2ZW50ID0gbnVsbCxcbiAgXHQgICAgc3RvcEV2ZW50ID0gZmFsc2U7XG5cbiAgXHRpZiAoZXZlbnQgJiYgIWV2ZW50Ll9ub0FyZykge1xuICBcdFx0YXJncyA9IFtldmVudF0uY29uY2F0KGFyZ3MpO1xuICBcdH1cblxuICBcdC8vIHN1YnNjcmliZXJzIGNhbiBiZSBtb2RpZmllZCBpbmZsaWdodCwgZS5nLiBcIm9uY2VcIiBmdW5jdGlvbmFsaXR5XG4gIFx0Ly8gc28gd2UgbmVlZCB0byBjb3B5IHRvIG1ha2Ugc3VyZSBldmVyeW9uZSBnZXRzIGNhbGxlZFxuICBcdHN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuc2xpY2UoKTtcblxuICBcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdWJzY3JpYmVycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0aWYgKHN1YnNjcmliZXJzW2ldLmFwcGx5KHJhY3RpdmUsIGFyZ3MpID09PSBmYWxzZSkge1xuICBcdFx0XHRzdG9wRXZlbnQgPSB0cnVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChldmVudCAmJiAhZXZlbnQuX25vQXJnICYmIHN0b3BFdmVudCAmJiAob3JpZ2luYWxFdmVudCA9IGV2ZW50Lm9yaWdpbmFsKSkge1xuICBcdFx0b3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCAmJiBvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIFx0XHRvcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbiAmJiBvcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICBcdH1cblxuICBcdHJldHVybiAhc3RvcEV2ZW50O1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maXJlID0gUmFjdGl2ZSRmaXJlO1xuICBmdW5jdGlvbiBSYWN0aXZlJGZpcmUoZXZlbnROYW1lKSB7XG5cbiAgXHR2YXIgb3B0aW9ucyA9IHtcbiAgXHRcdGFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgXHR9O1xuXG4gIFx0c2hhcmVkX2ZpcmVFdmVudCh0aGlzLCBldmVudE5hbWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9nZXQgPSBSYWN0aXZlJGdldDtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gIFx0Y2FwdHVyZTogdHJ1ZSwgLy8gdG9wLWxldmVsIGNhbGxzIHNob3VsZCBiZSBpbnRlcmNlcHRlZFxuICBcdG5vVW53cmFwOiB0cnVlLCAvLyB3cmFwcGVkIHZhbHVlcyBzaG91bGQgTk9UIGJlIHVud3JhcHBlZFxuICBcdGZ1bGxSb290R2V0OiB0cnVlIC8vIHJvb3QgZ2V0IHNob3VsZCByZXR1cm4gbWFwcGluZ3NcbiAgfTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRnZXQoa2V5cGF0aCkge1xuICBcdHZhciB2YWx1ZTtcblxuICBcdGtleXBhdGggPSBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSk7XG4gIFx0dmFsdWUgPSB0aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCwgb3B0aW9ucyk7XG5cbiAgXHQvLyBDcmVhdGUgaW50ZXItY29tcG9uZW50IGJpbmRpbmcsIGlmIG5lY2Vzc2FyeVxuICBcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMucGFyZW50ICYmICF0aGlzLmlzb2xhdGVkKSB7XG4gIFx0XHRpZiAoc2hhcmVkX3Jlc29sdmVSZWYodGhpcywga2V5cGF0aC5zdHIsIHRoaXMuY29tcG9uZW50LnBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0XHQvLyBjcmVhdGVzIGJpbmRpbmcgYXMgc2lkZS1lZmZlY3QsIGlmIGFwcHJvcHJpYXRlXG4gIFx0XHRcdHZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHZhciBpbnNlcnQgPSBSYWN0aXZlJGluc2VydDtcblxuICB2YXIgaW5zZXJ0SG9vayA9IG5ldyBob29rc19Ib29rKFwiaW5zZXJ0XCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJGluc2VydCh0YXJnZXQsIGFuY2hvcikge1xuICBcdGlmICghdGhpcy5mcmFnbWVudC5yZW5kZXJlZCkge1xuICBcdFx0Ly8gVE9ETyBjcmVhdGUsIGFuZCBsaW5rIHRvLCBkb2N1bWVudGF0aW9uIGV4cGxhaW5pbmcgdGhpc1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIEFQSSBoYXMgY2hhbmdlZCAtIHlvdSBtdXN0IGNhbGwgYHJhY3RpdmUucmVuZGVyKHRhcmdldFssIGFuY2hvcl0pYCB0byByZW5kZXIgeW91ciBSYWN0aXZlIGluc3RhbmNlLiBPbmNlIHJlbmRlcmVkIHlvdSBjYW4gdXNlIGByYWN0aXZlLmluc2VydCgpYC5cIik7XG4gIFx0fVxuXG4gIFx0dGFyZ2V0ID0gZ2V0RWxlbWVudCh0YXJnZXQpO1xuICBcdGFuY2hvciA9IGdldEVsZW1lbnQoYW5jaG9yKSB8fCBudWxsO1xuXG4gIFx0aWYgKCF0YXJnZXQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHNwZWNpZnkgYSB2YWxpZCB0YXJnZXQgdG8gaW5zZXJ0IGludG9cIik7XG4gIFx0fVxuXG4gIFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLmRldGFjaCgpLCBhbmNob3IpO1xuICBcdHRoaXMuZWwgPSB0YXJnZXQ7XG5cbiAgXHQodGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyB8fCAodGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyA9IFtdKSkucHVzaCh0aGlzKTtcbiAgXHR0aGlzLmRldGFjaGVkID0gbnVsbDtcblxuICBcdGZpcmVJbnNlcnRIb29rKHRoaXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUluc2VydEhvb2socmFjdGl2ZSkge1xuICBcdGluc2VydEhvb2suZmlyZShyYWN0aXZlKTtcblxuICBcdHJhY3RpdmUuZmluZEFsbENvbXBvbmVudHMoXCIqXCIpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gIFx0XHRmaXJlSW5zZXJ0SG9vayhjaGlsZC5pbnN0YW5jZSk7XG4gIFx0fSk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX21lcmdlID0gUmFjdGl2ZSRtZXJnZTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRtZXJnZShrZXlwYXRoLCBhcnJheSwgb3B0aW9ucykge1xuICBcdHZhciBjdXJyZW50QXJyYXksIHByb21pc2U7XG5cbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuICBcdGN1cnJlbnRBcnJheSA9IHRoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdC8vIElmIGVpdGhlciB0aGUgZXhpc3RpbmcgdmFsdWUgb3IgdGhlIG5ldyB2YWx1ZSBpc24ndCBhblxuICBcdC8vIGFycmF5LCBqdXN0IGRvIGEgcmVndWxhciBzZXRcbiAgXHRpZiAoIWlzQXJyYXkoY3VycmVudEFycmF5KSB8fCAhaXNBcnJheShhcnJheSkpIHtcbiAgXHRcdHJldHVybiB0aGlzLnNldChrZXlwYXRoLCBhcnJheSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBsZXRlKTtcbiAgXHR9XG5cbiAgXHQvLyBNYW5hZ2UgdHJhbnNpdGlvbnNcbiAgXHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG4gIFx0dGhpcy52aWV3bW9kZWwubWVyZ2Uoa2V5cGF0aCwgY3VycmVudEFycmF5LCBhcnJheSwgb3B0aW9ucyk7XG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIChyYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG4gIFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIFx0dGhpcy5kZWZlciA9IG9wdGlvbnMuZGVmZXI7XG5cbiAgXHQvLyBkZWZhdWx0IHRvIHJvb3QgYXMgY29udGV4dCwgYnV0IGFsbG93IGl0IHRvIGJlIG92ZXJyaWRkZW5cbiAgXHR0aGlzLmNvbnRleHQgPSBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA/IG9wdGlvbnMuY29udGV4dCA6IHJhY3RpdmU7XG4gIH07XG5cbiAgT2JzZXJ2ZXIucHJvdG90eXBlID0ge1xuICBcdGluaXQ6IGZ1bmN0aW9uIChpbW1lZGlhdGUpIHtcbiAgXHRcdHRoaXMudmFsdWUgPSB0aGlzLnJvb3QuZ2V0KHRoaXMua2V5cGF0aC5zdHIpO1xuXG4gIFx0XHRpZiAoaW1tZWRpYXRlICE9PSBmYWxzZSkge1xuICBcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5vbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdGlmICghaXNFcXVhbCh2YWx1ZSwgdGhpcy52YWx1ZSkpIHtcbiAgXHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0XHRcdGlmICh0aGlzLmRlZmVyICYmIHRoaXMucmVhZHkpIHtcbiAgXHRcdFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0cmV0dXJuIF90aGlzLnVwZGF0ZSgpO1xuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHRoaXMudXBkYXRlKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBQcmV2ZW50IGluZmluaXRlIGxvb3BzXG4gIFx0XHRpZiAodGhpcy51cGRhdGluZykge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXG4gIFx0XHR0aGlzLmNhbGxiYWNrLmNhbGwodGhpcy5jb250ZXh0LCB0aGlzLnZhbHVlLCB0aGlzLm9sZFZhbHVlLCB0aGlzLmtleXBhdGguc3RyKTtcbiAgXHRcdHRoaXMub2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gIFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBvYnNlcnZlX09ic2VydmVyID0gT2JzZXJ2ZXI7XG5cbiAgdmFyIG9ic2VydmVfZ2V0UGF0dGVybiA9IGdldFBhdHRlcm47XG4gIGZ1bmN0aW9uIGdldFBhdHRlcm4ocmFjdGl2ZSwgcGF0dGVybikge1xuICBcdHZhciBtYXRjaGluZ0tleXBhdGhzLCB2YWx1ZXM7XG5cbiAgXHRtYXRjaGluZ0tleXBhdGhzID0gZ2V0TWF0Y2hpbmdLZXlwYXRocyhyYWN0aXZlLCBwYXR0ZXJuKTtcblxuICBcdHZhbHVlcyA9IHt9O1xuICBcdG1hdGNoaW5nS2V5cGF0aHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFsdWVzW2tleXBhdGguc3RyXSA9IHJhY3RpdmUuZ2V0KGtleXBhdGguc3RyKTtcbiAgXHR9KTtcblxuICBcdHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICB2YXIgUGF0dGVybk9ic2VydmVyLFxuICAgICAgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgUGF0dGVybk9ic2VydmVyID0gZnVuY3Rpb24gKHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblxuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgXHR0aGlzLmRlZmVyID0gb3B0aW9ucy5kZWZlcjtcblxuICBcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0dGhpcy5yZWdleCA9IG5ldyBSZWdFeHAoXCJeXCIgKyBrZXlwYXRoLnN0ci5yZXBsYWNlKC9cXC4vZywgXCJcXFxcLlwiKS5yZXBsYWNlKC9cXCovZywgXCIoW15cXFxcLl0rKVwiKSArIFwiJFwiKTtcbiAgXHR0aGlzLnZhbHVlcyA9IHt9O1xuXG4gIFx0aWYgKHRoaXMuZGVmZXIpIHtcbiAgXHRcdHRoaXMucHJveGllcyA9IFtdO1xuICBcdH1cblxuICBcdC8vIGRlZmF1bHQgdG8gcm9vdCBhcyBjb250ZXh0LCBidXQgYWxsb3cgaXQgdG8gYmUgb3ZlcnJpZGRlblxuICBcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID8gb3B0aW9ucy5jb250ZXh0IDogcmFjdGl2ZTtcbiAgfTtcblxuICBQYXR0ZXJuT2JzZXJ2ZXIucHJvdG90eXBlID0ge1xuICBcdGluaXQ6IGZ1bmN0aW9uIChpbW1lZGlhdGUpIHtcbiAgXHRcdHZhciB2YWx1ZXMsIGtleXBhdGg7XG5cbiAgXHRcdHZhbHVlcyA9IG9ic2VydmVfZ2V0UGF0dGVybih0aGlzLnJvb3QsIHRoaXMua2V5cGF0aCk7XG5cbiAgXHRcdGlmIChpbW1lZGlhdGUgIT09IGZhbHNlKSB7XG4gIFx0XHRcdGZvciAoa2V5cGF0aCBpbiB2YWx1ZXMpIHtcbiAgXHRcdFx0XHRpZiAodmFsdWVzLmhhc093blByb3BlcnR5KGtleXBhdGgpKSB7XG4gIFx0XHRcdFx0XHR0aGlzLnVwZGF0ZShnZXRLZXlwYXRoKGtleXBhdGgpKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1cGRhdGU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgdmFsdWVzO1xuXG4gIFx0XHRpZiAoa2V5cGF0aC5pc1BhdHRlcm4pIHtcbiAgXHRcdFx0dmFsdWVzID0gb2JzZXJ2ZV9nZXRQYXR0ZXJuKHRoaXMucm9vdCwga2V5cGF0aCk7XG5cbiAgXHRcdFx0Zm9yIChrZXlwYXRoIGluIHZhbHVlcykge1xuICBcdFx0XHRcdGlmICh2YWx1ZXMuaGFzT3duUHJvcGVydHkoa2V5cGF0aCkpIHtcbiAgXHRcdFx0XHRcdHRoaXMudXBkYXRlKGdldEtleXBhdGgoa2V5cGF0aCkpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gYXJyYXkgbXV0YXRpb24gc2hvdWxkIG5vdCB0cmlnZ2VyIGBhcnJheS4qYFxuICBcdFx0Ly8gcGF0dGVybiBvYnNlcnZlciB3aXRoIGBhcnJheS5sZW5ndGhgXG4gIFx0XHRpZiAodGhpcy5yb290LnZpZXdtb2RlbC5pbXBsaWNpdENoYW5nZXNba2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuZGVmZXIgJiYgdGhpcy5yZWFkeSkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHJldHVybiBfdGhpcy5nZXRQcm94eShrZXlwYXRoKS51cGRhdGUoKTtcbiAgXHRcdFx0fSk7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5yZWFsbHlVcGRhdGUoa2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHJlYWxseVVwZGF0ZTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHZhciBrZXlwYXRoU3RyLCB2YWx1ZSwga2V5cywgYXJncztcblxuICBcdFx0a2V5cGF0aFN0ciA9IGtleXBhdGguc3RyO1xuICBcdFx0dmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdFx0Ly8gUHJldmVudCBpbmZpbml0ZSBsb29wc1xuICBcdFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdFx0dGhpcy52YWx1ZXNba2V5cGF0aFN0cl0gPSB2YWx1ZTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblxuICBcdFx0aWYgKCFpc0VxdWFsKHZhbHVlLCB0aGlzLnZhbHVlc1trZXlwYXRoU3RyXSkgfHwgIXRoaXMucmVhZHkpIHtcbiAgXHRcdFx0a2V5cyA9IHNsaWNlLmNhbGwodGhpcy5yZWdleC5leGVjKGtleXBhdGhTdHIpLCAxKTtcbiAgXHRcdFx0YXJncyA9IFt2YWx1ZSwgdGhpcy52YWx1ZXNba2V5cGF0aFN0cl0sIGtleXBhdGhTdHJdLmNvbmNhdChrZXlzKTtcblxuICBcdFx0XHR0aGlzLnZhbHVlc1trZXlwYXRoU3RyXSA9IHZhbHVlO1xuICBcdFx0XHR0aGlzLmNhbGxiYWNrLmFwcGx5KHRoaXMuY29udGV4dCwgYXJncyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcbiAgXHR9LFxuXG4gIFx0Z2V0UHJveHk6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHRpZiAoIXRoaXMucHJveGllc1trZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0dGhpcy5wcm94aWVzW2tleXBhdGguc3RyXSA9IHtcbiAgXHRcdFx0XHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdHJldHVybiBfdGhpcy5yZWFsbHlVcGRhdGUoa2V5cGF0aCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5wcm94aWVzW2tleXBhdGguc3RyXTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIG9ic2VydmVfUGF0dGVybk9ic2VydmVyID0gUGF0dGVybk9ic2VydmVyO1xuXG4gIHZhciBvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlID0gZ2V0T2JzZXJ2ZXJGYWNhZGU7XG4gIHZhciBlbXB0eU9iamVjdCA9IHt9O1xuICBmdW5jdGlvbiBnZXRPYnNlcnZlckZhY2FkZShyYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICBcdHZhciBvYnNlcnZlciwgaXNQYXR0ZXJuT2JzZXJ2ZXIsIGNhbmNlbGxlZDtcblxuICBcdGtleXBhdGggPSBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSk7XG4gIFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgXHQvLyBwYXR0ZXJuIG9ic2VydmVycyBhcmUgdHJlYXRlZCBkaWZmZXJlbnRseVxuICBcdGlmIChrZXlwYXRoLmlzUGF0dGVybikge1xuICBcdFx0b2JzZXJ2ZXIgPSBuZXcgb2JzZXJ2ZV9QYXR0ZXJuT2JzZXJ2ZXIocmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICBcdFx0cmFjdGl2ZS52aWV3bW9kZWwucGF0dGVybk9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgXHRcdGlzUGF0dGVybk9ic2VydmVyID0gdHJ1ZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0b2JzZXJ2ZXIgPSBuZXcgb2JzZXJ2ZV9PYnNlcnZlcihyYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0b2JzZXJ2ZXIuaW5pdChvcHRpb25zLmluaXQpO1xuICBcdHJhY3RpdmUudmlld21vZGVsLnJlZ2lzdGVyKGtleXBhdGgsIG9ic2VydmVyLCBpc1BhdHRlcm5PYnNlcnZlciA/IFwicGF0dGVybk9ic2VydmVyc1wiIDogXCJvYnNlcnZlcnNcIik7XG5cbiAgXHQvLyBUaGlzIGZsYWcgYWxsb3dzIG9ic2VydmVycyB0byBpbml0aWFsaXNlIGV2ZW4gd2l0aCB1bmRlZmluZWQgdmFsdWVzXG4gIFx0b2JzZXJ2ZXIucmVhZHkgPSB0cnVlO1xuXG4gIFx0dmFyIGZhY2FkZSA9IHtcbiAgXHRcdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHR2YXIgaW5kZXg7XG5cbiAgXHRcdFx0aWYgKGNhbmNlbGxlZCkge1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChpc1BhdHRlcm5PYnNlcnZlcikge1xuICBcdFx0XHRcdGluZGV4ID0gcmFjdGl2ZS52aWV3bW9kZWwucGF0dGVybk9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcblxuICBcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC51bnJlZ2lzdGVyKGtleXBhdGgsIG9ic2VydmVyLCBcInBhdHRlcm5PYnNlcnZlcnNcIik7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwudW5yZWdpc3RlcihrZXlwYXRoLCBvYnNlcnZlciwgXCJvYnNlcnZlcnNcIik7XG4gIFx0XHRcdH1cbiAgXHRcdFx0Y2FuY2VsbGVkID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0cmFjdGl2ZS5fb2JzZXJ2ZXJzLnB1c2goZmFjYWRlKTtcbiAgXHRyZXR1cm4gZmFjYWRlO1xuICB9XG5cbiAgdmFyIG9ic2VydmUgPSBSYWN0aXZlJG9ic2VydmU7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkb2JzZXJ2ZShrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykge1xuXG4gIFx0dmFyIG9ic2VydmVycywgbWFwLCBrZXlwYXRocywgaTtcblxuICBcdC8vIEFsbG93IGEgbWFwIG9mIGtleXBhdGhzIHRvIGhhbmRsZXJzXG4gIFx0aWYgKGlzT2JqZWN0KGtleXBhdGgpKSB7XG4gIFx0XHRvcHRpb25zID0gY2FsbGJhY2s7XG4gIFx0XHRtYXAgPSBrZXlwYXRoO1xuXG4gIFx0XHRvYnNlcnZlcnMgPSBbXTtcblxuICBcdFx0Zm9yIChrZXlwYXRoIGluIG1hcCkge1xuICBcdFx0XHRpZiAobWFwLmhhc093blByb3BlcnR5KGtleXBhdGgpKSB7XG4gIFx0XHRcdFx0Y2FsbGJhY2sgPSBtYXBba2V5cGF0aF07XG4gIFx0XHRcdFx0b2JzZXJ2ZXJzLnB1c2godGhpcy5vYnNlcnZlKGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0Y2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0d2hpbGUgKG9ic2VydmVycy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRcdG9ic2VydmVycy5wb3AoKS5jYW5jZWwoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0Ly8gQWxsb3cgYHJhY3RpdmUub2JzZXJ2ZSggY2FsbGJhY2sgKWAgLSBpLmUuIG9ic2VydmUgZW50aXJlIG1vZGVsXG4gIFx0aWYgKHR5cGVvZiBrZXlwYXRoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdG9wdGlvbnMgPSBjYWxsYmFjaztcbiAgXHRcdGNhbGxiYWNrID0ga2V5cGF0aDtcbiAgXHRcdGtleXBhdGggPSBcIlwiO1xuXG4gIFx0XHRyZXR1cm4gb2JzZXJ2ZV9nZXRPYnNlcnZlckZhY2FkZSh0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0a2V5cGF0aHMgPSBrZXlwYXRoLnNwbGl0KFwiIFwiKTtcblxuICBcdC8vIFNpbmdsZSBrZXlwYXRoXG4gIFx0aWYgKGtleXBhdGhzLmxlbmd0aCA9PT0gMSkge1xuICBcdFx0cmV0dXJuIG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUodGhpcywga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICBcdH1cblxuICBcdC8vIE11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBrZXlwYXRoc1xuICBcdG9ic2VydmVycyA9IFtdO1xuXG4gIFx0aSA9IGtleXBhdGhzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRrZXlwYXRoID0ga2V5cGF0aHNbaV07XG5cbiAgXHRcdGlmIChrZXlwYXRoKSB7XG4gIFx0XHRcdG9ic2VydmVycy5wdXNoKG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUodGhpcywga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0Y2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHdoaWxlIChvYnNlcnZlcnMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0b2JzZXJ2ZXJzLnBvcCgpLmNhbmNlbCgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBvYnNlcnZlT25jZSA9IFJhY3RpdmUkb2JzZXJ2ZU9uY2U7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRvYnNlcnZlT25jZShwcm9wZXJ0eSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcblxuICBcdHZhciBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZShwcm9wZXJ0eSwgZnVuY3Rpb24gKCkge1xuICBcdFx0Y2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXHRcdG9ic2VydmVyLmNhbmNlbCgpO1xuICBcdH0sIHsgaW5pdDogZmFsc2UsIGRlZmVyOiBvcHRpb25zICYmIG9wdGlvbnMuZGVmZXIgfSk7XG5cbiAgXHRyZXR1cm4gb2JzZXJ2ZXI7XG4gIH1cblxuICB2YXIgc2hhcmVkX3RyaW0gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCk7XG4gIH07XG5cbiAgdmFyIG5vdEVtcHR5U3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIgIT09IFwiXCI7XG4gIH07XG5cbiAgdmFyIG9mZiA9IFJhY3RpdmUkb2ZmO1xuICBmdW5jdGlvbiBSYWN0aXZlJG9mZihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBldmVudE5hbWVzO1xuXG4gIFx0Ly8gaWYgbm8gYXJndW1lbnRzIHNwZWNpZmllZCwgcmVtb3ZlIGFsbCBjYWxsYmFja3NcbiAgXHRpZiAoIWV2ZW50TmFtZSkge1xuICBcdFx0Ly8gVE9ETyB1c2UgdGhpcyBjb2RlIGluc3RlYWQsIG9uY2UgdGhlIGZvbGxvd2luZyBpc3N1ZSBoYXMgYmVlbiByZXNvbHZlZFxuICBcdFx0Ly8gaW4gUGhhbnRvbUpTICh0ZXN0cyBhcmUgdW5wYXNzYWJsZSBvdGhlcndpc2UhKVxuICBcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTE4NTZcbiAgXHRcdC8vIGRlZmluZVByb3BlcnR5KCB0aGlzLCAnX3N1YnMnLCB7IHZhbHVlOiBjcmVhdGUoIG51bGwgKSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICBcdFx0Zm9yIChldmVudE5hbWUgaW4gdGhpcy5fc3Vicykge1xuICBcdFx0XHRkZWxldGUgdGhpcy5fc3Vic1tldmVudE5hbWVdO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGV2ZW50IG5hbWVzXG4gIFx0XHRldmVudE5hbWVzID0gZXZlbnROYW1lLnNwbGl0KFwiIFwiKS5tYXAoc2hhcmVkX3RyaW0pLmZpbHRlcihub3RFbXB0eVN0cmluZyk7XG5cbiAgXHRcdGV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gIFx0XHRcdHZhciBzdWJzY3JpYmVycywgaW5kZXg7XG5cbiAgXHRcdFx0Ly8gSWYgd2UgaGF2ZSBzdWJzY3JpYmVycyBmb3IgdGhpcyBldmVudC4uLlxuICBcdFx0XHRpZiAoc3Vic2NyaWJlcnMgPSBfdGhpcy5fc3Vic1tldmVudE5hbWVdKSB7XG4gIFx0XHRcdFx0Ly8gLi4uaWYgYSBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCBvbmx5IHJlbW92ZSB0aGF0XG4gIFx0XHRcdFx0aWYgKGNhbGxiYWNrKSB7XG4gIFx0XHRcdFx0XHRpbmRleCA9IHN1YnNjcmliZXJzLmluZGV4T2YoY2FsbGJhY2spO1xuICBcdFx0XHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0XHRcdFx0XHRzdWJzY3JpYmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSByZW1vdmUgYWxsIGNhbGxiYWNrc1xuICBcdFx0XHRcdGVsc2Uge1xuICBcdFx0XHRcdFx0X3RoaXMuX3N1YnNbZXZlbnROYW1lXSA9IFtdO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgb24gPSBSYWN0aXZlJG9uO1xuICBmdW5jdGlvbiBSYWN0aXZlJG9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIGxpc3RlbmVycywgbiwgZXZlbnROYW1lcztcblxuICBcdC8vIGFsbG93IG11dGxpcGxlIGxpc3RlbmVycyB0byBiZSBib3VuZCBpbiBvbmUgZ29cbiAgXHRpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0bGlzdGVuZXJzID0gW107XG5cbiAgXHRcdGZvciAobiBpbiBldmVudE5hbWUpIHtcbiAgXHRcdFx0aWYgKGV2ZW50TmFtZS5oYXNPd25Qcm9wZXJ0eShuKSkge1xuICBcdFx0XHRcdGxpc3RlbmVycy5wdXNoKHRoaXMub24obiwgZXZlbnROYW1lW25dKSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0Y2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0dmFyIGxpc3RlbmVyO1xuXG4gIFx0XHRcdFx0d2hpbGUgKGxpc3RlbmVyID0gbGlzdGVuZXJzLnBvcCgpKSB7XG4gIFx0XHRcdFx0XHRsaXN0ZW5lci5jYW5jZWwoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0Ly8gSGFuZGxlIG11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lc1xuICBcdGV2ZW50TmFtZXMgPSBldmVudE5hbWUuc3BsaXQoXCIgXCIpLm1hcChzaGFyZWRfdHJpbSkuZmlsdGVyKG5vdEVtcHR5U3RyaW5nKTtcblxuICBcdGV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gIFx0XHQoX3RoaXMuX3N1YnNbZXZlbnROYW1lXSB8fCAoX3RoaXMuX3N1YnNbZXZlbnROYW1lXSA9IFtdKSkucHVzaChjYWxsYmFjayk7XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0Y2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiBfdGhpcy5vZmYoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBvbmNlID0gUmFjdGl2ZSRvbmNlO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkb25jZShldmVudE5hbWUsIGhhbmRsZXIpIHtcblxuICBcdHZhciBsaXN0ZW5lciA9IHRoaXMub24oZXZlbnROYW1lLCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIFx0XHRsaXN0ZW5lci5jYW5jZWwoKTtcbiAgXHR9KTtcblxuICBcdC8vIHNvIHdlIGNhbiBzdGlsbCBkbyBsaXN0ZW5lci5jYW5jZWwoKSBtYW51YWxseVxuICBcdHJldHVybiBsaXN0ZW5lcjtcbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4gYXJyYXksIHRoZSBuYW1lIG9mIGEgbXV0YXRvciBtZXRob2QsIGFuZCB0aGVcbiAgLy8gYXJndW1lbnRzIHRvIGNhbGwgdGhhdCBtdXRhdG9yIG1ldGhvZCB3aXRoLCBhbmQgcmV0dXJucyBhbiBhcnJheSB0aGF0XG4gIC8vIG1hcHMgdGhlIG9sZCBpbmRpY2VzIHRvIHRoZWlyIG5ldyBpbmRpY2VzLlxuXG4gIC8vIFNvIGlmIHlvdSBoYWQgc29tZXRoaW5nIGxpa2UgdGhpcy4uLlxuICAvL1xuICAvLyAgICAgYXJyYXkgPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xuICAvLyAgICAgYXJyYXkucHVzaCggJ2UnICk7XG4gIC8vXG4gIC8vIC4uLnlvdSdkIGdldCBgWyAwLCAxLCAyLCAzIF1gIC0gaW4gb3RoZXIgd29yZHMsIG5vbmUgb2YgdGhlIG9sZCBpbmRpY2VzXG4gIC8vIGhhdmUgY2hhbmdlZC4gSWYgeW91IHRoZW4gZGlkIHRoaXMuLi5cbiAgLy9cbiAgLy8gICAgIGFycmF5LnVuc2hpZnQoICd6JyApO1xuICAvL1xuICAvLyAuLi50aGUgaW5kaWNlcyB3b3VsZCBiZSBgWyAxLCAyLCAzLCA0LCA1IF1gIC0gZXZlcnkgaXRlbSBoYXMgYmVlbiBtb3ZlZFxuICAvLyBvbmUgaGlnaGVyIHRvIG1ha2Ugcm9vbSBmb3IgdGhlICd6Jy4gSWYgeW91IHJlbW92ZWQgYW4gaXRlbSwgdGhlIG5ldyBpbmRleFxuICAvLyB3b3VsZCBiZSAtMS4uLlxuICAvL1xuICAvLyAgICAgYXJyYXkuc3BsaWNlKCAyLCAyICk7XG4gIC8vXG4gIC8vIC4uLnRoaXMgd291bGQgcmVzdWx0IGluIFsgMCwgMSwgLTEsIC0xLCAyLCAzIF0uXG4gIC8vXG4gIC8vIFRoaXMgaW5mb3JtYXRpb24gaXMgdXNlZCB0byBlbmFibGUgZmFzdCwgbm9uLWRlc3RydWN0aXZlIHNodWZmbGluZyBvZiBsaXN0XG4gIC8vIHNlY3Rpb25zIHdoZW4geW91IGRvIGUuZy4gYHJhY3RpdmUuc3BsaWNlKCAnaXRlbXMnLCAyLCAyICk7XG5cbiAgdmFyIHNoYXJlZF9nZXROZXdJbmRpY2VzID0gZ2V0TmV3SW5kaWNlcztcblxuICBmdW5jdGlvbiBnZXROZXdJbmRpY2VzKGFycmF5LCBtZXRob2ROYW1lLCBhcmdzKSB7XG4gIFx0dmFyIHNwbGljZUFyZ3VtZW50cyxcbiAgXHQgICAgbGVuLFxuICBcdCAgICBuZXdJbmRpY2VzID0gW10sXG4gIFx0ICAgIHJlbW92ZVN0YXJ0LFxuICBcdCAgICByZW1vdmVFbmQsXG4gIFx0ICAgIGJhbGFuY2UsXG4gIFx0ICAgIGk7XG5cbiAgXHRzcGxpY2VBcmd1bWVudHMgPSBnZXRTcGxpY2VFcXVpdmFsZW50KGFycmF5LCBtZXRob2ROYW1lLCBhcmdzKTtcblxuICBcdGlmICghc3BsaWNlQXJndW1lbnRzKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDsgLy8gVE9ETyBzdXBwb3J0IHJldmVyc2UgYW5kIHNvcnQ/XG4gIFx0fVxuXG4gIFx0bGVuID0gYXJyYXkubGVuZ3RoO1xuICBcdGJhbGFuY2UgPSBzcGxpY2VBcmd1bWVudHMubGVuZ3RoIC0gMiAtIHNwbGljZUFyZ3VtZW50c1sxXTtcblxuICBcdHJlbW92ZVN0YXJ0ID0gTWF0aC5taW4obGVuLCBzcGxpY2VBcmd1bWVudHNbMF0pO1xuICBcdHJlbW92ZUVuZCA9IHJlbW92ZVN0YXJ0ICsgc3BsaWNlQXJndW1lbnRzWzFdO1xuXG4gIFx0Zm9yIChpID0gMDsgaSA8IHJlbW92ZVN0YXJ0OyBpICs9IDEpIHtcbiAgXHRcdG5ld0luZGljZXMucHVzaChpKTtcbiAgXHR9XG5cbiAgXHRmb3IgKDsgaSA8IHJlbW92ZUVuZDsgaSArPSAxKSB7XG4gIFx0XHRuZXdJbmRpY2VzLnB1c2goLTEpO1xuICBcdH1cblxuICBcdGZvciAoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG5ld0luZGljZXMucHVzaChpICsgYmFsYW5jZSk7XG4gIFx0fVxuXG4gIFx0Ly8gdGhlcmUgaXMgYSBuZXQgc2hpZnQgZm9yIHRoZSByZXN0IG9mIHRoZSBhcnJheSBzdGFydGluZyB3aXRoIGluZGV4ICsgYmFsYW5jZVxuICBcdGlmIChiYWxhbmNlICE9PSAwKSB7XG4gIFx0XHRuZXdJbmRpY2VzLnRvdWNoZWRGcm9tID0gc3BsaWNlQXJndW1lbnRzWzBdO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRuZXdJbmRpY2VzLnRvdWNoZWRGcm9tID0gYXJyYXkubGVuZ3RoO1xuICBcdH1cblxuICBcdHJldHVybiBuZXdJbmRpY2VzO1xuICB9XG5cbiAgLy8gVGhlIHBvcCwgcHVzaCwgc2hpZnQgYW4gdW5zaGlmdCBtZXRob2RzIGNhbiBhbGwgYmUgcmVwcmVzZW50ZWRcbiAgLy8gYXMgYW4gZXF1aXZhbGVudCBzcGxpY2VcbiAgZnVuY3Rpb24gZ2V0U3BsaWNlRXF1aXZhbGVudChhcnJheSwgbWV0aG9kTmFtZSwgYXJncykge1xuICBcdHN3aXRjaCAobWV0aG9kTmFtZSkge1xuICBcdFx0Y2FzZSBcInNwbGljZVwiOlxuICBcdFx0XHRpZiAoYXJnc1swXSAhPT0gdW5kZWZpbmVkICYmIGFyZ3NbMF0gPCAwKSB7XG4gIFx0XHRcdFx0YXJnc1swXSA9IGFycmF5Lmxlbmd0aCArIE1hdGgubWF4KGFyZ3NbMF0sIC1hcnJheS5sZW5ndGgpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0d2hpbGUgKGFyZ3MubGVuZ3RoIDwgMikge1xuICBcdFx0XHRcdGFyZ3MucHVzaCgwKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGVuc3VyZSB3ZSBvbmx5IHJlbW92ZSBlbGVtZW50cyB0aGF0IGV4aXN0XG4gIFx0XHRcdGFyZ3NbMV0gPSBNYXRoLm1pbihhcmdzWzFdLCBhcnJheS5sZW5ndGggLSBhcmdzWzBdKTtcblxuICBcdFx0XHRyZXR1cm4gYXJncztcblxuICBcdFx0Y2FzZSBcInNvcnRcIjpcbiAgXHRcdGNhc2UgXCJyZXZlcnNlXCI6XG4gIFx0XHRcdHJldHVybiBudWxsO1xuXG4gIFx0XHRjYXNlIFwicG9wXCI6XG4gIFx0XHRcdGlmIChhcnJheS5sZW5ndGgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gW2FycmF5Lmxlbmd0aCAtIDEsIDFdO1xuICBcdFx0XHR9XG4gIFx0XHRcdHJldHVybiBbMCwgMF07XG5cbiAgXHRcdGNhc2UgXCJwdXNoXCI6XG4gIFx0XHRcdHJldHVybiBbYXJyYXkubGVuZ3RoLCAwXS5jb25jYXQoYXJncyk7XG5cbiAgXHRcdGNhc2UgXCJzaGlmdFwiOlxuICBcdFx0XHRyZXR1cm4gWzAsIGFycmF5Lmxlbmd0aCA/IDEgOiAwXTtcblxuICBcdFx0Y2FzZSBcInVuc2hpZnRcIjpcbiAgXHRcdFx0cmV0dXJuIFswLCAwXS5jb25jYXQoYXJncyk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgdmFyIG1ha2VBcnJheU1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdFx0YXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBhcnJheSxcbiAgXHRcdCAgICBuZXdJbmRpY2VzID0gW10sXG4gIFx0XHQgICAgbGVuLFxuICBcdFx0ICAgIHByb21pc2UsXG4gIFx0XHQgICAgcmVzdWx0O1xuXG4gIFx0XHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuXG4gIFx0XHRhcnJheSA9IHRoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcbiAgXHRcdGxlbiA9IGFycmF5Lmxlbmd0aDtcblxuICBcdFx0aWYgKCFpc0FycmF5KGFycmF5KSkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgcmFjdGl2ZS5cIiArIG1ldGhvZE5hbWUgKyBcIignXCIgKyBrZXlwYXRoLnN0ciArIFwiJyksIGJ1dCAnXCIgKyBrZXlwYXRoLnN0ciArIFwiJyBkb2VzIG5vdCByZWZlciB0byBhbiBhcnJheVwiKTtcbiAgXHRcdH1cblxuICBcdFx0bmV3SW5kaWNlcyA9IHNoYXJlZF9nZXROZXdJbmRpY2VzKGFycmF5LCBtZXRob2ROYW1lLCBhcmdzKTtcblxuICBcdFx0cmVzdWx0ID0gYXJyYXlQcm90b1ttZXRob2ROYW1lXS5hcHBseShhcnJheSwgYXJncyk7XG4gIFx0XHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSkudGhlbihmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiByZXN1bHQ7XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKCEhbmV3SW5kaWNlcykge1xuICBcdFx0XHR0aGlzLnZpZXdtb2RlbC5zbWFydFVwZGF0ZShrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKGtleXBhdGgpO1xuICBcdFx0fVxuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdFx0cmV0dXJuIHByb21pc2U7XG4gIFx0fTtcbiAgfTtcblxuICB2YXIgcG9wID0gbWFrZUFycmF5TWV0aG9kKFwicG9wXCIpO1xuXG4gIHZhciBwdXNoID0gbWFrZUFycmF5TWV0aG9kKFwicHVzaFwiKTtcblxuICB2YXIgY3NzLFxuICAgICAgdXBkYXRlLFxuICAgICAgc3R5bGVFbGVtZW50LFxuICAgICAgaGVhZCxcbiAgICAgIHN0eWxlU2hlZXQsXG4gICAgICBpbkRvbSxcbiAgICAgIGdsb2JhbF9jc3NfX3ByZWZpeCA9IFwiLyogUmFjdGl2ZS5qcyBjb21wb25lbnQgc3R5bGVzICovXFxuXCIsXG4gICAgICBzdHlsZXMgPSBbXSxcbiAgICAgIGRpcnR5ID0gZmFsc2U7XG5cbiAgaWYgKCFpc0NsaWVudCkge1xuICBcdGNzcyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gIFx0c3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBcdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG4gIFx0aGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcblxuICBcdGluRG9tID0gZmFsc2U7XG5cbiAgXHQvLyBJbnRlcm5ldCBFeHBsb2RlciB3b24ndCBsZXQgeW91IHVzZSBzdHlsZVNoZWV0LmlubmVySFRNTCAtIHdlIGhhdmUgdG9cbiAgXHQvLyB1c2Ugc3R5bGVTaGVldC5jc3NUZXh0IGluc3RlYWRcbiAgXHRzdHlsZVNoZWV0ID0gc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQ7XG5cbiAgXHR1cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgY3NzID0gZ2xvYmFsX2Nzc19fcHJlZml4ICsgc3R5bGVzLm1hcChmdW5jdGlvbiAocykge1xuICBcdFx0XHRyZXR1cm4gXCJcXG4vKiB7XCIgKyBzLmlkICsgXCJ9ICovXFxuXCIgKyBzLnN0eWxlcztcbiAgXHRcdH0pLmpvaW4oXCJcXG5cIik7XG5cbiAgXHRcdGlmIChzdHlsZVNoZWV0KSB7XG4gIFx0XHRcdHN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBjc3M7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghaW5Eb20pIHtcbiAgXHRcdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICBcdFx0XHRpbkRvbSA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdGNzcyA9IHtcbiAgXHRcdGFkZDogZnVuY3Rpb24gKHMpIHtcbiAgXHRcdFx0c3R5bGVzLnB1c2gocyk7XG4gIFx0XHRcdGRpcnR5ID0gdHJ1ZTtcbiAgXHRcdH0sXG5cbiAgXHRcdGFwcGx5OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdGlmIChkaXJ0eSkge1xuICBcdFx0XHRcdHVwZGF0ZSgpO1xuICBcdFx0XHRcdGRpcnR5ID0gZmFsc2U7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgdmFyIGdsb2JhbF9jc3MgPSBjc3M7XG5cbiAgdmFyIHByb3RvdHlwZV9yZW5kZXIgPSBSYWN0aXZlJHJlbmRlcjtcblxuICB2YXIgcmVuZGVySG9vayA9IG5ldyBob29rc19Ib29rKFwicmVuZGVyXCIpLFxuICAgICAgY29tcGxldGVIb29rID0gbmV3IGhvb2tzX0hvb2soXCJjb21wbGV0ZVwiKTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRyZW5kZXIodGFyZ2V0LCBhbmNob3IpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHByb21pc2UsIGluc3RhbmNlcywgdHJhbnNpdGlvbnNFbmFibGVkO1xuXG4gIFx0Ly8gaWYgYG5vSW50cm9gIGlzIGB0cnVlYCwgdGVtcG9yYXJpbHkgZGlzYWJsZSB0cmFuc2l0aW9uc1xuICBcdHRyYW5zaXRpb25zRW5hYmxlZCA9IHRoaXMudHJhbnNpdGlvbnNFbmFibGVkO1xuICBcdGlmICh0aGlzLm5vSW50cm8pIHtcbiAgXHRcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuICBcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gcmVuZGVySG9vay5maXJlKF90aGlzKTtcbiAgXHR9LCB0cnVlKTtcblxuICBcdGlmICh0aGlzLmZyYWdtZW50LnJlbmRlcmVkKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IGNhbGwgcmFjdGl2ZS5yZW5kZXIoKSBvbiBhbiBhbHJlYWR5IHJlbmRlcmVkIGluc3RhbmNlISBDYWxsIHJhY3RpdmUudW5yZW5kZXIoKSBmaXJzdFwiKTtcbiAgXHR9XG5cbiAgXHR0YXJnZXQgPSBnZXRFbGVtZW50KHRhcmdldCkgfHwgdGhpcy5lbDtcbiAgXHRhbmNob3IgPSBnZXRFbGVtZW50KGFuY2hvcikgfHwgdGhpcy5hbmNob3I7XG5cbiAgXHR0aGlzLmVsID0gdGFyZ2V0O1xuICBcdHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuXG4gIFx0aWYgKCF0aGlzLmFwcGVuZCAmJiB0YXJnZXQpIHtcbiAgXHRcdC8vIFRlYXJkb3duIGFueSBleGlzdGluZyBpbnN0YW5jZXMgKmJlZm9yZSogdHJ5aW5nIHRvIHNldCB1cCB0aGUgbmV3IG9uZSAtXG4gIFx0XHQvLyBhdm9pZHMgY2VydGFpbiB3ZWlyZCBidWdzXG4gIFx0XHR2YXIgb3RoZXJzID0gdGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXztcbiAgXHRcdGlmIChvdGhlcnMgJiYgb3RoZXJzLmxlbmd0aCkge1xuICBcdFx0XHRyZW1vdmVPdGhlckluc3RhbmNlcyhvdGhlcnMpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBtYWtlIHN1cmUgd2UgYXJlIHRoZSBvbmx5IG9jY3VwYW50c1xuICBcdFx0dGFyZ2V0LmlubmVySFRNTCA9IFwiXCI7IC8vIFRPRE8gaXMgdGhpcyBxdWlja2VyIHRoYW4gcmVtb3ZlQ2hpbGQ/IEluaXRpYWwgcmVzZWFyY2ggaW5jb25jbHVzaXZlXG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuY3NzSWQpIHtcbiAgXHRcdC8vIGVuc3VyZSBlbmNhcHN1bGF0ZWQgQ1NTIGlzIHVwLXRvLWRhdGVcbiAgXHRcdGdsb2JhbF9jc3MuYXBwbHkoKTtcbiAgXHR9XG5cbiAgXHRpZiAodGFyZ2V0KSB7XG4gIFx0XHRpZiAoIShpbnN0YW5jZXMgPSB0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fKSkge1xuICBcdFx0XHR0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fID0gW3RoaXNdO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0aW5zdGFuY2VzLnB1c2godGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChhbmNob3IpIHtcbiAgXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLmZyYWdtZW50LnJlbmRlcigpLCBhbmNob3IpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHRoaXMuZnJhZ21lbnQucmVuZGVyKCkpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSB0cmFuc2l0aW9uc0VuYWJsZWQ7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBjb21wbGV0ZUhvb2suZmlyZShfdGhpcyk7XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVPdGhlckluc3RhbmNlcyhvdGhlcnMpIHtcbiAgXHRvdGhlcnMuc3BsaWNlKDAsIG90aGVycy5sZW5ndGgpLmZvckVhY2godGVhcmRvd24pO1xuICB9XG5cbiAgdmFyIGFkYXB0Q29uZmlndXJhdG9yID0ge1xuICBcdGV4dGVuZDogZnVuY3Rpb24gKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdHByb3RvLmFkYXB0ID0gY3VzdG9tX2FkYXB0X19jb21iaW5lKHByb3RvLmFkYXB0LCBlbnN1cmVBcnJheShvcHRpb25zLmFkYXB0KSk7XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHt9XG4gIH07XG5cbiAgdmFyIGN1c3RvbV9hZGFwdCA9IGFkYXB0Q29uZmlndXJhdG9yO1xuXG4gIGZ1bmN0aW9uIGN1c3RvbV9hZGFwdF9fY29tYmluZShhLCBiKSB7XG4gIFx0dmFyIGMgPSBhLnNsaWNlKCksXG4gIFx0ICAgIGkgPSBiLmxlbmd0aDtcblxuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmICghIH5jLmluZGV4T2YoYltpXSkpIHtcbiAgXHRcdFx0Yy5wdXNoKGJbaV0pO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBjO1xuICB9XG5cbiAgdmFyIHRyYW5zZm9ybSA9IHRyYW5zZm9ybUNzcztcblxuICB2YXIgc2VsZWN0b3JzUGF0dGVybiA9IC8oPzpefFxcfSk/XFxzKihbXlxce1xcfV0rKVxccypcXHsvZyxcbiAgICAgIGNvbW1lbnRzUGF0dGVybiA9IC9cXC9cXCouKj9cXCpcXC8vZyxcbiAgICAgIHNlbGVjdG9yVW5pdFBhdHRlcm4gPSAvKCg/Oig/OlxcW1teXFxdK11cXF0pfCg/OlteXFxzXFwrXFw+XFx+Ol0pKSspKCg/OjpbXlxcc1xcK1xcPlxcflxcKF0rKD86XFwoW15cXCldK1xcKSk/KT9cXHMqW1xcc1xcK1xcPlxcfl0/KVxccyovZyxcbiAgICAgIG1lZGlhUXVlcnlQYXR0ZXJuID0gL15AbWVkaWEvLFxuICAgICAgZGF0YVJ2Y0d1aWRQYXR0ZXJuID0gL1xcW2RhdGEtcmFjdGl2ZS1jc3N+PVwiXFx7W2EtejAtOS1dK1xcfVwiXS9nO1xuICBmdW5jdGlvbiB0cmFuc2Zvcm1Dc3MoY3NzLCBpZCkge1xuICBcdHZhciB0cmFuc2Zvcm1lZCwgZGF0YUF0dHIsIGFkZEd1aWQ7XG5cbiAgXHRkYXRhQXR0ciA9IFwiW2RhdGEtcmFjdGl2ZS1jc3N+PVxcXCJ7XCIgKyBpZCArIFwifVxcXCJdXCI7XG5cbiAgXHRhZGRHdWlkID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0XHR2YXIgc2VsZWN0b3JVbml0cyxcbiAgXHRcdCAgICBtYXRjaCxcbiAgXHRcdCAgICB1bml0LFxuICBcdFx0ICAgIGJhc2UsXG4gIFx0XHQgICAgcHJlcGVuZGVkLFxuICBcdFx0ICAgIGFwcGVuZGVkLFxuICBcdFx0ICAgIGksXG4gIFx0XHQgICAgdHJhbnNmb3JtZWQgPSBbXTtcblxuICBcdFx0c2VsZWN0b3JVbml0cyA9IFtdO1xuXG4gIFx0XHR3aGlsZSAobWF0Y2ggPSBzZWxlY3RvclVuaXRQYXR0ZXJuLmV4ZWMoc2VsZWN0b3IpKSB7XG4gIFx0XHRcdHNlbGVjdG9yVW5pdHMucHVzaCh7XG4gIFx0XHRcdFx0c3RyOiBtYXRjaFswXSxcbiAgXHRcdFx0XHRiYXNlOiBtYXRjaFsxXSxcbiAgXHRcdFx0XHRtb2RpZmllcnM6IG1hdGNoWzJdXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBGb3IgZWFjaCBzaW1wbGUgc2VsZWN0b3Igd2l0aGluIHRoZSBzZWxlY3Rvciwgd2UgbmVlZCB0byBjcmVhdGUgYSB2ZXJzaW9uXG4gIFx0XHQvLyB0aGF0IGEpIGNvbWJpbmVzIHdpdGggdGhlIGlkLCBhbmQgYikgaXMgaW5zaWRlIHRoZSBpZFxuICBcdFx0YmFzZSA9IHNlbGVjdG9yVW5pdHMubWFwKGV4dHJhY3RTdHJpbmcpO1xuXG4gIFx0XHRpID0gc2VsZWN0b3JVbml0cy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGFwcGVuZGVkID0gYmFzZS5zbGljZSgpO1xuXG4gIFx0XHRcdC8vIFBzZXVkby1zZWxlY3RvcnMgc2hvdWxkIGdvIGFmdGVyIHRoZSBhdHRyaWJ1dGUgc2VsZWN0b3JcbiAgXHRcdFx0dW5pdCA9IHNlbGVjdG9yVW5pdHNbaV07XG4gIFx0XHRcdGFwcGVuZGVkW2ldID0gdW5pdC5iYXNlICsgZGF0YUF0dHIgKyB1bml0Lm1vZGlmaWVycyB8fCBcIlwiO1xuXG4gIFx0XHRcdHByZXBlbmRlZCA9IGJhc2Uuc2xpY2UoKTtcbiAgXHRcdFx0cHJlcGVuZGVkW2ldID0gZGF0YUF0dHIgKyBcIiBcIiArIHByZXBlbmRlZFtpXTtcblxuICBcdFx0XHR0cmFuc2Zvcm1lZC5wdXNoKGFwcGVuZGVkLmpvaW4oXCIgXCIpLCBwcmVwZW5kZWQuam9pbihcIiBcIikpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdHJhbnNmb3JtZWQuam9pbihcIiwgXCIpO1xuICBcdH07XG5cbiAgXHRpZiAoZGF0YVJ2Y0d1aWRQYXR0ZXJuLnRlc3QoY3NzKSkge1xuICBcdFx0dHJhbnNmb3JtZWQgPSBjc3MucmVwbGFjZShkYXRhUnZjR3VpZFBhdHRlcm4sIGRhdGFBdHRyKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0dHJhbnNmb3JtZWQgPSBjc3MucmVwbGFjZShjb21tZW50c1BhdHRlcm4sIFwiXCIpLnJlcGxhY2Uoc2VsZWN0b3JzUGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoLCAkMSkge1xuICBcdFx0XHR2YXIgc2VsZWN0b3JzLCB0cmFuc2Zvcm1lZDtcblxuICBcdFx0XHQvLyBkb24ndCB0cmFuc2Zvcm0gbWVkaWEgcXVlcmllcyFcbiAgXHRcdFx0aWYgKG1lZGlhUXVlcnlQYXR0ZXJuLnRlc3QoJDEpKSByZXR1cm4gbWF0Y2g7XG5cbiAgXHRcdFx0c2VsZWN0b3JzID0gJDEuc3BsaXQoXCIsXCIpLm1hcCh0cmltKTtcbiAgXHRcdFx0dHJhbnNmb3JtZWQgPSBzZWxlY3RvcnMubWFwKGFkZEd1aWQpLmpvaW4oXCIsIFwiKSArIFwiIFwiO1xuXG4gIFx0XHRcdHJldHVybiBtYXRjaC5yZXBsYWNlKCQxLCB0cmFuc2Zvcm1lZCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdHJhbnNmb3JtZWQ7XG4gIH1cblxuICBmdW5jdGlvbiB0cmltKHN0cikge1xuICBcdGlmIChzdHIudHJpbSkge1xuICBcdFx0cmV0dXJuIHN0ci50cmltKCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKy8sIFwiXCIpLnJlcGxhY2UoL1xccyskLywgXCJcIik7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0U3RyaW5nKHVuaXQpIHtcbiAgXHRyZXR1cm4gdW5pdC5zdHI7XG4gIH1cblxuICB2YXIgY3NzX2Nzc19fdWlkID0gMTtcblxuICB2YXIgY3NzQ29uZmlndXJhdG9yID0ge1xuICBcdG5hbWU6IFwiY3NzXCIsXG5cbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIChQYXJlbnQsIHByb3RvLCBvcHRpb25zKSB7XG4gIFx0XHRpZiAob3B0aW9ucy5jc3MpIHtcbiAgXHRcdFx0dmFyIGlkID0gY3NzX2Nzc19fdWlkKys7XG4gIFx0XHRcdHZhciBzdHlsZXMgPSBvcHRpb25zLm5vQ3NzVHJhbnNmb3JtID8gb3B0aW9ucy5jc3MgOiB0cmFuc2Zvcm0ob3B0aW9ucy5jc3MsIGlkKTtcblxuICBcdFx0XHRwcm90by5jc3NJZCA9IGlkO1xuICBcdFx0XHRnbG9iYWxfY3NzLmFkZCh7IGlkOiBpZCwgc3R5bGVzOiBzdHlsZXMgfSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHt9XG4gIH07XG5cbiAgdmFyIGNzc19jc3MgPSBjc3NDb25maWd1cmF0b3I7XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUoZGF0YSkge1xuICBcdC8vIFdhcm4gaWYgdXNlck9wdGlvbnMuZGF0YSBpcyBhIG5vbi1QT0pPXG4gIFx0aWYgKGRhdGEgJiYgZGF0YS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gIFx0XHRpZiAodHlwZW9mIGRhdGEgPT09IFwiZnVuY3Rpb25cIikge30gZWxzZSBpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdFx0ZmF0YWwoXCJkYXRhIG9wdGlvbiBtdXN0IGJlIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uLCBgXCIgKyBkYXRhICsgXCJgIGlzIG5vdCB2YWxpZFwiKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKFwiSWYgc3VwcGxpZWQsIG9wdGlvbnMuZGF0YSBzaG91bGQgYmUgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCAtIHVzaW5nIGEgbm9uLVBPSk8gYXMgdGhlIHJvb3Qgb2JqZWN0IG1heSB3b3JrLCBidXQgaXMgZGlzY291cmFnZWRcIik7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIGRhdGFDb25maWd1cmF0b3IgPSB7XG4gIFx0bmFtZTogXCJkYXRhXCIsXG5cbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIChQYXJlbnQsIHByb3RvLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIga2V5ID0gdW5kZWZpbmVkLFxuICBcdFx0ICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuXG4gIFx0XHQvLyBjaGVjayBmb3Igbm9uLXByaW1pdGl2ZXMsIHdoaWNoIGNvdWxkIGNhdXNlIG11dGF0aW9uLXJlbGF0ZWQgYnVnc1xuICBcdFx0aWYgKG9wdGlvbnMuZGF0YSAmJiBpc09iamVjdChvcHRpb25zLmRhdGEpKSB7XG4gIFx0XHRcdGZvciAoa2V5IGluIG9wdGlvbnMuZGF0YSkge1xuICBcdFx0XHRcdHZhbHVlID0gb3B0aW9ucy5kYXRhW2tleV07XG5cbiAgXHRcdFx0XHRpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRcdFx0XHRpZiAoaXNPYmplY3QodmFsdWUpIHx8IGlzQXJyYXkodmFsdWUpKSB7XG4gIFx0XHRcdFx0XHRcdHdhcm5JZkRlYnVnKFwiUGFzc2luZyBhIGBkYXRhYCBvcHRpb24gd2l0aCBvYmplY3QgYW5kIGFycmF5IHByb3BlcnRpZXMgdG8gUmFjdGl2ZS5leHRlbmQoKSBpcyBkaXNjb3VyYWdlZCwgYXMgbXV0YXRpbmcgdGhlbSBpcyBsaWtlbHkgdG8gY2F1c2UgYnVncy4gQ29uc2lkZXIgdXNpbmcgYSBkYXRhIGZ1bmN0aW9uIGluc3RlYWQ6XFxuXFxuICAvLyB0aGlzLi4uXFxuICBkYXRhOiBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgbXlPYmplY3Q6IHt9XFxuICAgIH07XFxuICB9KVxcblxcbiAgLy8gaW5zdGVhZCBvZiB0aGlzOlxcbiAgZGF0YToge1xcbiAgICBteU9iamVjdDoge31cXG4gIH1cIik7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHByb3RvLmRhdGEgPSBjdXN0b21fZGF0YV9fY29tYmluZShwcm90by5kYXRhLCBvcHRpb25zLmRhdGEpO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoUGFyZW50LCByYWN0aXZlLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgcmVzdWx0ID0gY3VzdG9tX2RhdGFfX2NvbWJpbmUoUGFyZW50LnByb3RvdHlwZS5kYXRhLCBvcHRpb25zLmRhdGEpO1xuXG4gIFx0XHRpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5jYWxsKHJhY3RpdmUpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gcmVzdWx0IHx8IHt9O1xuICBcdH0sXG5cbiAgXHRyZXNldDogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdHZhciByZXN1bHQgPSB0aGlzLmluaXQocmFjdGl2ZS5jb25zdHJ1Y3RvciwgcmFjdGl2ZSwgcmFjdGl2ZS52aWV3bW9kZWwpO1xuXG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5yZXNldChyZXN1bHQpO1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBjdXN0b21fZGF0YSA9IGRhdGFDb25maWd1cmF0b3I7XG5cbiAgZnVuY3Rpb24gY3VzdG9tX2RhdGFfX2NvbWJpbmUocGFyZW50VmFsdWUsIGNoaWxkVmFsdWUpIHtcbiAgXHR2YWxpZGF0ZShjaGlsZFZhbHVlKTtcblxuICBcdHZhciBwYXJlbnRJc0ZuID0gdHlwZW9mIHBhcmVudFZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG4gIFx0dmFyIGNoaWxkSXNGbiA9IHR5cGVvZiBjaGlsZFZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG5cbiAgXHQvLyBWZXJ5IGltcG9ydGFudCwgb3RoZXJ3aXNlIGNoaWxkIGluc3RhbmNlIGNhbiBiZWNvbWVcbiAgXHQvLyB0aGUgZGVmYXVsdCBkYXRhIG9iamVjdCBvbiBSYWN0aXZlIG9yIGEgY29tcG9uZW50LlxuICBcdC8vIHRoZW4gcmFjdGl2ZS5zZXQoKSBlbmRzIHVwIHNldHRpbmcgb24gdGhlIHByb3RvdHlwZSFcbiAgXHRpZiAoIWNoaWxkVmFsdWUgJiYgIXBhcmVudElzRm4pIHtcbiAgXHRcdGNoaWxkVmFsdWUgPSB7fTtcbiAgXHR9XG5cbiAgXHQvLyBGYXN0IHBhdGgsIHdoZXJlIHdlIGp1c3QgbmVlZCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICBcdC8vIHBhcmVudCB0byBjaGlsZFxuICBcdGlmICghcGFyZW50SXNGbiAmJiAhY2hpbGRJc0ZuKSB7XG4gIFx0XHRyZXR1cm4gZnJvbVByb3BlcnRpZXMoY2hpbGRWYWx1ZSwgcGFyZW50VmFsdWUpO1xuICBcdH1cblxuICBcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgY2hpbGQgPSBjaGlsZElzRm4gPyBjYWxsRGF0YUZ1bmN0aW9uKGNoaWxkVmFsdWUsIHRoaXMpIDogY2hpbGRWYWx1ZTtcbiAgXHRcdHZhciBwYXJlbnQgPSBwYXJlbnRJc0ZuID8gY2FsbERhdGFGdW5jdGlvbihwYXJlbnRWYWx1ZSwgdGhpcykgOiBwYXJlbnRWYWx1ZTtcblxuICBcdFx0cmV0dXJuIGZyb21Qcm9wZXJ0aWVzKGNoaWxkLCBwYXJlbnQpO1xuICBcdH07XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsRGF0YUZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XG4gIFx0dmFyIGRhdGEgPSBmbi5jYWxsKGNvbnRleHQpO1xuXG4gIFx0aWYgKCFkYXRhKSByZXR1cm47XG5cbiAgXHRpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdGZhdGFsKFwiRGF0YSBmdW5jdGlvbiBtdXN0IHJldHVybiBhbiBvYmplY3RcIik7XG4gIFx0fVxuXG4gIFx0aWYgKGRhdGEuY29uc3RydWN0b3IgIT09IE9iamVjdCkge1xuICBcdFx0d2Fybk9uY2VJZkRlYnVnKFwiRGF0YSBmdW5jdGlvbiByZXR1cm5lZCBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LiBUaGlzIG1pZ2h0IHdvcmssIGJ1dCBpcyBzdHJvbmdseSBkaXNjb3VyYWdlZFwiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21Qcm9wZXJ0aWVzKHByaW1hcnksIHNlY29uZGFyeSkge1xuICBcdGlmIChwcmltYXJ5ICYmIHNlY29uZGFyeSkge1xuICBcdFx0Zm9yICh2YXIga2V5IGluIHNlY29uZGFyeSkge1xuICBcdFx0XHRpZiAoIShrZXkgaW4gcHJpbWFyeSkpIHtcbiAgXHRcdFx0XHRwcmltYXJ5W2tleV0gPSBzZWNvbmRhcnlba2V5XTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gcHJpbWFyeTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcHJpbWFyeSB8fCBzZWNvbmRhcnk7XG4gIH1cblxuICAvLyBUT0RPIGRvIHdlIG5lZWQgdG8gc3VwcG9ydCB0aGlzIGluIHRoZSBuZXcgUmFjdGl2ZSgpIGNhc2U/XG5cbiAgdmFyIFBhcnNlcixcbiAgICAgIFBhcnNlRXJyb3IsXG4gICAgICBwYXJzZV9QYXJzZXJfX2xlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMrLztcblxuICBQYXJzZUVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgXHR0aGlzLm5hbWUgPSBcIlBhcnNlRXJyb3JcIjtcbiAgXHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICBcdHRyeSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIFx0fSBjYXRjaCAoZSkge1xuICBcdFx0dGhpcy5zdGFjayA9IGUuc3RhY2s7XG4gIFx0fVxuICB9O1xuXG4gIFBhcnNlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIFBhcnNlciA9IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcbiAgXHR2YXIgaXRlbXMsXG4gIFx0ICAgIGl0ZW0sXG4gIFx0ICAgIGxpbmVTdGFydCA9IDA7XG5cbiAgXHR0aGlzLnN0ciA9IHN0cjtcbiAgXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBcdHRoaXMucG9zID0gMDtcblxuICBcdHRoaXMubGluZXMgPSB0aGlzLnN0ci5zcGxpdChcIlxcblwiKTtcbiAgXHR0aGlzLmxpbmVFbmRzID0gdGhpcy5saW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgXHRcdHZhciBsaW5lRW5kID0gbGluZVN0YXJ0ICsgbGluZS5sZW5ndGggKyAxOyAvLyArMSBmb3IgdGhlIG5ld2xpbmVcblxuICBcdFx0bGluZVN0YXJ0ID0gbGluZUVuZDtcbiAgXHRcdHJldHVybiBsaW5lRW5kO1xuICBcdH0sIDApO1xuXG4gIFx0Ly8gQ3VzdG9tIGluaXQgbG9naWNcbiAgXHRpZiAodGhpcy5pbml0KSB0aGlzLmluaXQoc3RyLCBvcHRpb25zKTtcblxuICBcdGl0ZW1zID0gW107XG5cbiAgXHR3aGlsZSAodGhpcy5wb3MgPCB0aGlzLnN0ci5sZW5ndGggJiYgKGl0ZW0gPSB0aGlzLnJlYWQoKSkpIHtcbiAgXHRcdGl0ZW1zLnB1c2goaXRlbSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5sZWZ0b3ZlciA9IHRoaXMucmVtYWluaW5nKCk7XG4gIFx0dGhpcy5yZXN1bHQgPSB0aGlzLnBvc3RQcm9jZXNzID8gdGhpcy5wb3N0UHJvY2VzcyhpdGVtcywgb3B0aW9ucykgOiBpdGVtcztcbiAgfTtcblxuICBQYXJzZXIucHJvdG90eXBlID0ge1xuICBcdHJlYWQ6IGZ1bmN0aW9uIChjb252ZXJ0ZXJzKSB7XG4gIFx0XHR2YXIgcG9zLCBpLCBsZW4sIGl0ZW07XG5cbiAgXHRcdGlmICghY29udmVydGVycykgY29udmVydGVycyA9IHRoaXMuY29udmVydGVycztcblxuICBcdFx0cG9zID0gdGhpcy5wb3M7XG5cbiAgXHRcdGxlbiA9IGNvbnZlcnRlcnMubGVuZ3RoO1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdHRoaXMucG9zID0gcG9zOyAvLyByZXNldCBmb3IgZWFjaCBhdHRlbXB0XG5cbiAgXHRcdFx0aWYgKGl0ZW0gPSBjb252ZXJ0ZXJzW2ldKHRoaXMpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGl0ZW07XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fSxcblxuICBcdGdldExpbmVQb3M6IGZ1bmN0aW9uIChjaGFyKSB7XG4gIFx0XHR2YXIgbGluZU51bSA9IDAsXG4gIFx0XHQgICAgbGluZVN0YXJ0ID0gMCxcbiAgXHRcdCAgICBjb2x1bW5OdW07XG5cbiAgXHRcdHdoaWxlIChjaGFyID49IHRoaXMubGluZUVuZHNbbGluZU51bV0pIHtcbiAgXHRcdFx0bGluZVN0YXJ0ID0gdGhpcy5saW5lRW5kc1tsaW5lTnVtXTtcbiAgXHRcdFx0bGluZU51bSArPSAxO1xuICBcdFx0fVxuXG4gIFx0XHRjb2x1bW5OdW0gPSBjaGFyIC0gbGluZVN0YXJ0O1xuICBcdFx0cmV0dXJuIFtsaW5lTnVtICsgMSwgY29sdW1uTnVtICsgMSwgY2hhcl07IC8vIGxpbmUvY29sIHNob3VsZCBiZSBvbmUtYmFzZWQsIG5vdCB6ZXJvLWJhc2VkIVxuICBcdH0sXG5cbiAgXHRlcnJvcjogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgXHRcdHZhciBwb3MgPSB0aGlzLmdldExpbmVQb3ModGhpcy5wb3MpO1xuICBcdFx0dmFyIGxpbmVOdW0gPSBwb3NbMF07XG4gIFx0XHR2YXIgY29sdW1uTnVtID0gcG9zWzFdO1xuXG4gIFx0XHR2YXIgbGluZSA9IHRoaXMubGluZXNbcG9zWzBdIC0gMV07XG4gIFx0XHR2YXIgbnVtVGFicyA9IDA7XG4gIFx0XHR2YXIgYW5ub3RhdGlvbiA9IGxpbmUucmVwbGFjZSgvXFx0L2csIGZ1bmN0aW9uIChtYXRjaCwgY2hhcikge1xuICBcdFx0XHRpZiAoY2hhciA8IHBvc1sxXSkge1xuICBcdFx0XHRcdG51bVRhYnMgKz0gMTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBcIiAgXCI7XG4gIFx0XHR9KSArIFwiXFxuXCIgKyBuZXcgQXJyYXkocG9zWzFdICsgbnVtVGFicykuam9pbihcIiBcIikgKyBcIl4tLS0tXCI7XG5cbiAgXHRcdHZhciBlcnJvciA9IG5ldyBQYXJzZUVycm9yKFwiXCIgKyBtZXNzYWdlICsgXCIgYXQgbGluZSBcIiArIGxpbmVOdW0gKyBcIiBjaGFyYWN0ZXIgXCIgKyBjb2x1bW5OdW0gKyBcIjpcXG5cIiArIGFubm90YXRpb24pO1xuXG4gIFx0XHRlcnJvci5saW5lID0gcG9zWzBdO1xuICBcdFx0ZXJyb3IuY2hhcmFjdGVyID0gcG9zWzFdO1xuICBcdFx0ZXJyb3Iuc2hvcnRNZXNzYWdlID0gbWVzc2FnZTtcblxuICBcdFx0dGhyb3cgZXJyb3I7XG4gIFx0fSxcblxuICBcdG1hdGNoU3RyaW5nOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIFx0XHRpZiAodGhpcy5zdHIuc3Vic3RyKHRoaXMucG9zLCBzdHJpbmcubGVuZ3RoKSA9PT0gc3RyaW5nKSB7XG4gIFx0XHRcdHRoaXMucG9zICs9IHN0cmluZy5sZW5ndGg7XG4gIFx0XHRcdHJldHVybiBzdHJpbmc7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdG1hdGNoUGF0dGVybjogZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgXHRcdHZhciBtYXRjaDtcblxuICBcdFx0aWYgKG1hdGNoID0gcGF0dGVybi5leGVjKHRoaXMucmVtYWluaW5nKCkpKSB7XG4gIFx0XHRcdHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgXHRcdFx0cmV0dXJuIG1hdGNoWzFdIHx8IG1hdGNoWzBdO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRhbGxvd1doaXRlc3BhY2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMubWF0Y2hQYXR0ZXJuKHBhcnNlX1BhcnNlcl9fbGVhZGluZ1doaXRlc3BhY2UpO1xuICBcdH0sXG5cbiAgXHRyZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLnN0ci5zdWJzdHJpbmcodGhpcy5wb3MpO1xuICBcdH0sXG5cbiAgXHRuZXh0Q2hhcjogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuc3RyLmNoYXJBdCh0aGlzLnBvcyk7XG4gIFx0fVxuICB9O1xuXG4gIFBhcnNlci5leHRlbmQgPSBmdW5jdGlvbiAocHJvdG8pIHtcbiAgXHR2YXIgUGFyZW50ID0gdGhpcyxcbiAgXHQgICAgQ2hpbGQsXG4gIFx0ICAgIGtleTtcblxuICBcdENoaWxkID0gZnVuY3Rpb24gKHN0ciwgb3B0aW9ucykge1xuICBcdFx0UGFyc2VyLmNhbGwodGhpcywgc3RyLCBvcHRpb25zKTtcbiAgXHR9O1xuXG4gIFx0Q2hpbGQucHJvdG90eXBlID0gY3JlYXRlKFBhcmVudC5wcm90b3R5cGUpO1xuXG4gIFx0Zm9yIChrZXkgaW4gcHJvdG8pIHtcbiAgXHRcdGlmIChoYXNPd24uY2FsbChwcm90bywga2V5KSkge1xuICBcdFx0XHRDaGlsZC5wcm90b3R5cGVba2V5XSA9IHByb3RvW2tleV07XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Q2hpbGQuZXh0ZW5kID0gUGFyc2VyLmV4dGVuZDtcbiAgXHRyZXR1cm4gQ2hpbGQ7XG4gIH07XG5cbiAgdmFyIHBhcnNlX1BhcnNlciA9IFBhcnNlcjtcblxuICB2YXIgVEVYVCA9IDE7XG4gIHZhciBJTlRFUlBPTEFUT1IgPSAyO1xuICB2YXIgVFJJUExFID0gMztcbiAgdmFyIFNFQ1RJT04gPSA0O1xuICB2YXIgSU5WRVJURUQgPSA1O1xuICB2YXIgQ0xPU0lORyA9IDY7XG4gIHZhciBFTEVNRU5UID0gNztcbiAgdmFyIFBBUlRJQUwgPSA4O1xuICB2YXIgQ09NTUVOVCA9IDk7XG4gIHZhciBERUxJTUNIQU5HRSA9IDEwO1xuICB2YXIgQVRUUklCVVRFID0gMTM7XG4gIHZhciBDTE9TSU5HX1RBRyA9IDE0O1xuICB2YXIgQ09NUE9ORU5UID0gMTU7XG4gIHZhciBZSUVMREVSID0gMTY7XG4gIHZhciBJTkxJTkVfUEFSVElBTCA9IDE3O1xuICB2YXIgRE9DVFlQRSA9IDE4O1xuXG4gIHZhciBOVU1CRVJfTElURVJBTCA9IDIwO1xuICB2YXIgU1RSSU5HX0xJVEVSQUwgPSAyMTtcbiAgdmFyIEFSUkFZX0xJVEVSQUwgPSAyMjtcbiAgdmFyIE9CSkVDVF9MSVRFUkFMID0gMjM7XG4gIHZhciBCT09MRUFOX0xJVEVSQUwgPSAyNDtcbiAgdmFyIFJFR0VYUF9MSVRFUkFMID0gMjU7XG5cbiAgdmFyIEdMT0JBTCA9IDI2O1xuICB2YXIgS0VZX1ZBTFVFX1BBSVIgPSAyNztcblxuICB2YXIgUkVGRVJFTkNFID0gMzA7XG4gIHZhciBSRUZJTkVNRU5UID0gMzE7XG4gIHZhciBNRU1CRVIgPSAzMjtcbiAgdmFyIFBSRUZJWF9PUEVSQVRPUiA9IDMzO1xuICB2YXIgQlJBQ0tFVEVEID0gMzQ7XG4gIHZhciBDT05ESVRJT05BTCA9IDM1O1xuICB2YXIgSU5GSVhfT1BFUkFUT1IgPSAzNjtcblxuICB2YXIgSU5WT0NBVElPTiA9IDQwO1xuXG4gIHZhciBTRUNUSU9OX0lGID0gNTA7XG4gIHZhciBTRUNUSU9OX1VOTEVTUyA9IDUxO1xuICB2YXIgU0VDVElPTl9FQUNIID0gNTI7XG4gIHZhciBTRUNUSU9OX1dJVEggPSA1MztcbiAgdmFyIFNFQ1RJT05fSUZfV0lUSCA9IDU0O1xuXG4gIHZhciBFTFNFID0gNjA7XG4gIHZhciBFTFNFSUYgPSA2MTtcblxuICB2YXIgbXVzdGFjaGVfcmVhZERlbGltaXRlckNoYW5nZSA9IHJlYWREZWxpbWl0ZXJDaGFuZ2U7XG4gIHZhciBkZWxpbWl0ZXJDaGFuZ2VQYXR0ZXJuID0gL15bXlxccz1dKy8sXG4gICAgICB3aGl0ZXNwYWNlUGF0dGVybiA9IC9eXFxzKy87XG4gIGZ1bmN0aW9uIHJlYWREZWxpbWl0ZXJDaGFuZ2UocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBvcGVuaW5nLCBjbG9zaW5nO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI9XCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBuZXcgb3BlbmluZyBkZWxpbWl0ZXJcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRvcGVuaW5nID0gcGFyc2VyLm1hdGNoUGF0dGVybihkZWxpbWl0ZXJDaGFuZ2VQYXR0ZXJuKTtcbiAgXHRpZiAoIW9wZW5pbmcpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgKGluIGZhY3QsIGl0J3MgbmVjZXNzYXJ5Li4uKVxuICBcdGlmICghcGFyc2VyLm1hdGNoUGF0dGVybih3aGl0ZXNwYWNlUGF0dGVybikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGNsb3NpbmcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGRlbGltaXRlckNoYW5nZVBhdHRlcm4pO1xuICBcdGlmICghY2xvc2luZykge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgY2xvc2luZyAnPSdcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj1cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiBbb3BlbmluZywgY2xvc2luZ107XG4gIH1cblxuICB2YXIgcmVhZFJlZ2V4cExpdGVyYWwgPSByZWFkUmVnZXhwTGl0ZXJhbF9fcmVhZE51bWJlckxpdGVyYWw7XG4gIHZhciByZWdleHBQYXR0ZXJuID0gL14oXFwvKD86W15cXG5cXHJcXHUyMDI4XFx1MjAyOS9cXFxcW118XFxcXC58XFxbKD86W15cXG5cXHJcXHUyMDI4XFx1MjAyOVxcXVxcXFxdfFxcXFwuKSpdKStcXC8oPzooW2dpbXV5XSkoPyFbYS16XSpcXDIpKSooPyFbYS16QS1aXyQwLTldKSkvO1xuICBmdW5jdGlvbiByZWFkUmVnZXhwTGl0ZXJhbF9fcmVhZE51bWJlckxpdGVyYWwocGFyc2VyKSB7XG4gIFx0dmFyIHJlc3VsdDtcblxuICBcdGlmIChyZXN1bHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHJlZ2V4cFBhdHRlcm4pKSB7XG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBSRUdFWFBfTElURVJBTCxcbiAgXHRcdFx0djogcmVzdWx0XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlID0gcmVhZE11c3RhY2hlO1xuXG4gIHZhciBkZWxpbWl0ZXJDaGFuZ2VUb2tlbiA9IHsgdDogREVMSU1DSEFOR0UsIGV4Y2x1ZGU6IHRydWUgfTtcbiAgZnVuY3Rpb24gcmVhZE11c3RhY2hlKHBhcnNlcikge1xuICBcdHZhciBtdXN0YWNoZSwgaTtcblxuICBcdC8vIElmIHdlJ3JlIGluc2lkZSBhIDxzY3JpcHQ+IG9yIDxzdHlsZT4gdGFnLCBhbmQgd2UncmUgbm90XG4gIFx0Ly8gaW50ZXJwb2xhdGluZywgYnVnIG91dFxuICBcdGlmIChwYXJzZXIuaW50ZXJwb2xhdGVbcGFyc2VyLmluc2lkZV0gPT09IGZhbHNlKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgcGFyc2VyLnRhZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdGlmIChtdXN0YWNoZSA9IHJlYWRNdXN0YWNoZU9mVHlwZShwYXJzZXIsIHBhcnNlci50YWdzW2ldKSkge1xuICBcdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZE11c3RhY2hlT2ZUeXBlKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIHN0YXJ0LCBtdXN0YWNoZSwgcmVhZGVyLCBpO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIlxcXFxcIiArIHRhZy5vcGVuKSkge1xuICBcdFx0aWYgKHN0YXJ0ID09PSAwIHx8IHBhcnNlci5zdHJbc3RhcnQgLSAxXSAhPT0gXCJcXFxcXCIpIHtcbiAgXHRcdFx0cmV0dXJuIHRhZy5vcGVuO1xuICBcdFx0fVxuICBcdH0gZWxzZSBpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcub3BlbikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGRlbGltaXRlciBjaGFuZ2U/XG4gIFx0aWYgKG11c3RhY2hlID0gbXVzdGFjaGVfcmVhZERlbGltaXRlckNoYW5nZShwYXJzZXIpKSB7XG4gIFx0XHQvLyBmaW5kIGNsb3NpbmcgZGVsaW1pdGVyIG9yIGFib3J0Li4uXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHQvLyAuLi50aGVuIG1ha2UgdGhlIHN3aXRjaFxuICBcdFx0dGFnLm9wZW4gPSBtdXN0YWNoZVswXTtcbiAgXHRcdHRhZy5jbG9zZSA9IG11c3RhY2hlWzFdO1xuICBcdFx0cGFyc2VyLnNvcnRNdXN0YWNoZVRhZ3MoKTtcblxuICBcdFx0cmV0dXJuIGRlbGltaXRlckNoYW5nZVRva2VuO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIGlsbGVnYWwgc2VjdGlvbiBjbG9zZXJcbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiL1wiKSkge1xuICBcdFx0cGFyc2VyLnBvcyAtPSAxO1xuICBcdFx0dmFyIHJld2luZCA9IHBhcnNlci5wb3M7XG4gIFx0XHRpZiAoIXJlYWRSZWdleHBMaXRlcmFsKHBhcnNlcikpIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHJld2luZCAtIHRhZy5jbG9zZS5sZW5ndGg7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkF0dGVtcHRlZCB0byBjbG9zZSBhIHNlY3Rpb24gdGhhdCB3YXNuJ3Qgb3BlblwiKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSByZXdpbmQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Zm9yIChpID0gMDsgaSA8IHRhZy5yZWFkZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRyZWFkZXIgPSB0YWcucmVhZGVyc1tpXTtcblxuICBcdFx0aWYgKG11c3RhY2hlID0gcmVhZGVyKHBhcnNlciwgdGFnKSkge1xuICBcdFx0XHRpZiAodGFnLmlzU3RhdGljKSB7XG4gIFx0XHRcdFx0bXVzdGFjaGUucyA9IHRydWU7IC8vIFRPRE8gbWFrZSB0aGlzIGAxYCBpbnN0ZWFkIC0gbW9yZSBjb21wYWN0XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAocGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zKSB7XG4gIFx0XHRcdFx0bXVzdGFjaGUucCA9IHBhcnNlci5nZXRMaW5lUG9zKHN0YXJ0KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBtdXN0YWNoZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXhwZWN0ZWRFeHByZXNzaW9uID0gXCJFeHBlY3RlZCBhIEphdmFTY3JpcHQgZXhwcmVzc2lvblwiO1xuICB2YXIgZXhwZWN0ZWRQYXJlbiA9IFwiRXhwZWN0ZWQgY2xvc2luZyBwYXJlblwiO1xuXG4gIHZhciBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsID0gbGl0ZXJhbF9yZWFkTnVtYmVyTGl0ZXJhbF9fcmVhZE51bWJlckxpdGVyYWw7XG4gIHZhciBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsX19udW1iZXJQYXR0ZXJuID0gL14oPzpbKy1dPykwKig/Oig/Oig/OlsxLTldXFxkKik/XFwuXFxkKyl8KD86KD86MHxbMS05XVxcZCopXFwuKXwoPzowfFsxLTldXFxkKikpKD86W2VFXVsrLV0/XFxkKyk/LztcbiAgZnVuY3Rpb24gbGl0ZXJhbF9yZWFkTnVtYmVyTGl0ZXJhbF9fcmVhZE51bWJlckxpdGVyYWwocGFyc2VyKSB7XG4gIFx0dmFyIHJlc3VsdDtcblxuICBcdGlmIChyZXN1bHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWxfX251bWJlclBhdHRlcm4pKSB7XG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBOVU1CRVJfTElURVJBTCxcbiAgXHRcdFx0djogcmVzdWx0XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxpdGVyYWxfcmVhZEJvb2xlYW5MaXRlcmFsID0gcmVhZEJvb2xlYW5MaXRlcmFsO1xuICBmdW5jdGlvbiByZWFkQm9vbGVhbkxpdGVyYWwocGFyc2VyKSB7XG4gIFx0dmFyIHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblxuICBcdGlmIChyZW1haW5pbmcuc3Vic3RyKDAsIDQpID09PSBcInRydWVcIikge1xuICBcdFx0cGFyc2VyLnBvcyArPSA0O1xuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogQk9PTEVBTl9MSVRFUkFMLFxuICBcdFx0XHR2OiBcInRydWVcIlxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRpZiAocmVtYWluaW5nLnN1YnN0cigwLCA1KSA9PT0gXCJmYWxzZVwiKSB7XG4gIFx0XHRwYXJzZXIucG9zICs9IDU7XG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBCT09MRUFOX0xJVEVSQUwsXG4gIFx0XHRcdHY6IFwiZmFsc2VcIlxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzdHJpbmdNaWRkbGVQYXR0ZXJuLCBlc2NhcGVTZXF1ZW5jZVBhdHRlcm4sIGxpbmVDb250aW51YXRpb25QYXR0ZXJuO1xuXG4gIC8vIE1hdGNoIG9uZSBvciBtb3JlIGNoYXJhY3RlcnMgdW50aWw6IFwiLCAnLCBcXCwgb3IgRU9ML0VPRi5cbiAgLy8gRU9ML0VPRiBpcyB3cml0dGVuIGFzICg/IS4pIChtZWFuaW5nIHRoZXJlJ3Mgbm8gbm9uLW5ld2xpbmUgY2hhciBuZXh0KS5cbiAgc3RyaW5nTWlkZGxlUGF0dGVybiA9IC9eKD89LilbXlwiJ1xcXFxdKz8oPzooPyEuKXwoPz1bXCInXFxcXF0pKS87XG5cbiAgLy8gTWF0Y2ggb25lIGVzY2FwZSBzZXF1ZW5jZSwgaW5jbHVkaW5nIHRoZSBiYWNrc2xhc2guXG4gIGVzY2FwZVNlcXVlbmNlUGF0dGVybiA9IC9eXFxcXCg/OlsnXCJcXFxcYmZucnRdfDAoPyFbMC05XSl8eFswLTlhLWZBLUZdezJ9fHVbMC05YS1mQS1GXXs0fXwoPz0uKVtedXgwLTldKS87XG5cbiAgLy8gTWF0Y2ggb25lIEVTNSBsaW5lIGNvbnRpbnVhdGlvbiAoYmFja3NsYXNoICsgbGluZSB0ZXJtaW5hdG9yKS5cbiAgbGluZUNvbnRpbnVhdGlvblBhdHRlcm4gPSAvXlxcXFwoPzpcXHJcXG58W1xcdTAwMEFcXHUwMDBEXFx1MjAyOFxcdTIwMjldKS87XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyBnZXREb3VibGVRdW90ZWRTdHJpbmcgYW5kIGdldFNpbmdsZVF1b3RlZFN0cmluZy5cbiAgdmFyIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyID0gZnVuY3Rpb24gKG9rUXVvdGUpIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdFx0dmFyIHN0YXJ0LCBsaXRlcmFsLCBkb25lLCBuZXh0O1xuXG4gIFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG4gIFx0XHRsaXRlcmFsID0gXCJcXFwiXCI7XG4gIFx0XHRkb25lID0gZmFsc2U7XG5cbiAgXHRcdHdoaWxlICghZG9uZSkge1xuICBcdFx0XHRuZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybihzdHJpbmdNaWRkbGVQYXR0ZXJuKSB8fCBwYXJzZXIubWF0Y2hQYXR0ZXJuKGVzY2FwZVNlcXVlbmNlUGF0dGVybikgfHwgcGFyc2VyLm1hdGNoU3RyaW5nKG9rUXVvdGUpO1xuICBcdFx0XHRpZiAobmV4dCkge1xuICBcdFx0XHRcdGlmIChuZXh0ID09PSBcIlxcXCJcIikge1xuICBcdFx0XHRcdFx0bGl0ZXJhbCArPSBcIlxcXFxcXFwiXCI7XG4gIFx0XHRcdFx0fSBlbHNlIGlmIChuZXh0ID09PSBcIlxcXFwnXCIpIHtcbiAgXHRcdFx0XHRcdGxpdGVyYWwgKz0gXCInXCI7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGxpdGVyYWwgKz0gbmV4dDtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0bmV4dCA9IHBhcnNlci5tYXRjaFBhdHRlcm4obGluZUNvbnRpbnVhdGlvblBhdHRlcm4pO1xuICBcdFx0XHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdFx0XHQvLyBjb252ZXJ0IFxcKG5ld2xpbmUtbGlrZSkgaW50byBhIFxcdSBlc2NhcGUsIHdoaWNoIGlzIGFsbG93ZWQgaW4gSlNPTlxuICBcdFx0XHRcdFx0bGl0ZXJhbCArPSBcIlxcXFx1XCIgKyAoXCIwMDBcIiArIG5leHQuY2hhckNvZGVBdCgxKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0ZG9uZSA9IHRydWU7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGxpdGVyYWwgKz0gXCJcXFwiXCI7XG5cbiAgXHRcdC8vIHVzZSBKU09OLnBhcnNlIHRvIGludGVycHJldCBlc2NhcGVzXG4gIFx0XHRyZXR1cm4gSlNPTi5wYXJzZShsaXRlcmFsKTtcbiAgXHR9O1xuICB9O1xuXG4gIHZhciBnZXRTaW5nbGVRdW90ZWRTdHJpbmcgPSBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlcihcIlxcXCJcIik7XG4gIHZhciBnZXREb3VibGVRdW90ZWRTdHJpbmcgPSBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlcihcIidcIik7XG5cbiAgdmFyIHJlYWRTdHJpbmdMaXRlcmFsID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgc3RyaW5nO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIlxcXCJcIikpIHtcbiAgXHRcdHN0cmluZyA9IGdldERvdWJsZVF1b3RlZFN0cmluZyhwYXJzZXIpO1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIlxcXCJcIikpIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogU1RSSU5HX0xJVEVSQUwsXG4gIFx0XHRcdHY6IHN0cmluZ1xuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiJ1wiKSkge1xuICBcdFx0c3RyaW5nID0gZ2V0U2luZ2xlUXVvdGVkU3RyaW5nKHBhcnNlcik7XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiJ1wiKSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBTVFJJTkdfTElURVJBTCxcbiAgXHRcdFx0djogc3RyaW5nXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBwYXR0ZXJuc19fbmFtZSA9IC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qLztcblxuICAvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXByb3BlcnRpZXNcbiAgLy8gY2FuIGJlIGFueSBuYW1lLCBzdHJpbmcgbGl0ZXJhbCwgb3IgbnVtYmVyIGxpdGVyYWxcbiAgdmFyIHNoYXJlZF9yZWFkS2V5ID0gcmVhZEtleTtcbiAgdmFyIGlkZW50aWZpZXIgPSAvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKiQvO1xuICBmdW5jdGlvbiByZWFkS2V5KHBhcnNlcikge1xuICBcdHZhciB0b2tlbjtcblxuICBcdGlmICh0b2tlbiA9IHJlYWRTdHJpbmdMaXRlcmFsKHBhcnNlcikpIHtcbiAgXHRcdHJldHVybiBpZGVudGlmaWVyLnRlc3QodG9rZW4udikgPyB0b2tlbi52IDogXCJcXFwiXCIgKyB0b2tlbi52LnJlcGxhY2UoL1wiL2csIFwiXFxcXFxcXCJcIikgKyBcIlxcXCJcIjtcbiAgXHR9XG5cbiAgXHRpZiAodG9rZW4gPSBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsKHBhcnNlcikpIHtcbiAgXHRcdHJldHVybiB0b2tlbi52O1xuICBcdH1cblxuICBcdGlmICh0b2tlbiA9IHBhcnNlci5tYXRjaFBhdHRlcm4ocGF0dGVybnNfX25hbWUpKSB7XG4gIFx0XHRyZXR1cm4gdG9rZW47XG4gIFx0fVxuICB9XG5cbiAgdmFyIGtleVZhbHVlUGFpciA9IHJlYWRLZXlWYWx1ZVBhaXI7XG4gIGZ1bmN0aW9uIHJlYWRLZXlWYWx1ZVBhaXIocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBrZXksIHZhbHVlO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuICd7JyBhbmQga2V5XG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0a2V5ID0gc2hhcmVkX3JlYWRLZXkocGFyc2VyKTtcbiAgXHRpZiAoa2V5ID09PSBudWxsKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4ga2V5IGFuZCAnOidcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBuZXh0IGNoYXJhY3RlciBtdXN0IGJlICc6J1xuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiOlwiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuICc6JyBhbmQgdmFsdWVcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBuZXh0IGV4cHJlc3Npb24gbXVzdCBiZSBhLCB3ZWxsLi4uIGV4cHJlc3Npb25cbiAgXHR2YWx1ZSA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBLRVlfVkFMVUVfUEFJUixcbiAgXHRcdGs6IGtleSxcbiAgXHRcdHY6IHZhbHVlXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBvYmplY3RMaXRlcmFsX2tleVZhbHVlUGFpcnMgPSByZWFkS2V5VmFsdWVQYWlycztcbiAgZnVuY3Rpb24gcmVhZEtleVZhbHVlUGFpcnMocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBwYWlycywgcGFpciwga2V5VmFsdWVQYWlycztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdHBhaXIgPSBrZXlWYWx1ZVBhaXIocGFyc2VyKTtcbiAgXHRpZiAocGFpciA9PT0gbnVsbCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFpcnMgPSBbcGFpcl07XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiLFwiKSkge1xuICBcdFx0a2V5VmFsdWVQYWlycyA9IHJlYWRLZXlWYWx1ZVBhaXJzKHBhcnNlcik7XG5cbiAgXHRcdGlmICgha2V5VmFsdWVQYWlycykge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gcGFpcnMuY29uY2F0KGtleVZhbHVlUGFpcnMpO1xuICBcdH1cblxuICBcdHJldHVybiBwYWlycztcbiAgfVxuXG4gIHZhciByZWFkT2JqZWN0TGl0ZXJhbCA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGtleVZhbHVlUGFpcnM7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJ7XCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRrZXlWYWx1ZVBhaXJzID0gb2JqZWN0TGl0ZXJhbF9rZXlWYWx1ZVBhaXJzKHBhcnNlcik7XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gZmluYWwgdmFsdWUgYW5kICd9J1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwifVwiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IE9CSkVDVF9MSVRFUkFMLFxuICBcdFx0bToga2V5VmFsdWVQYWlyc1xuICBcdH07XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9yZWFkRXhwcmVzc2lvbkxpc3QgPSByZWFkRXhwcmVzc2lvbkxpc3Q7XG4gIGZ1bmN0aW9uIHJlYWRFeHByZXNzaW9uTGlzdChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb25zLCBleHByLCBuZXh0O1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0ZXhwciA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcblxuICBcdGlmIChleHByID09PSBudWxsKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRleHByZXNzaW9ucyA9IFtleHByXTtcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBleHByZXNzaW9uIGFuZCAnLCdcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiLFwiKSkge1xuICBcdFx0bmV4dCA9IHJlYWRFeHByZXNzaW9uTGlzdChwYXJzZXIpO1xuICBcdFx0aWYgKG5leHQgPT09IG51bGwpIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkRXhwcmVzc2lvbik7XG4gIFx0XHR9XG5cbiAgXHRcdG5leHQuZm9yRWFjaChhcHBlbmQpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIGFwcGVuZChleHByZXNzaW9uKSB7XG4gIFx0XHRleHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xuICBcdH1cblxuICBcdHJldHVybiBleHByZXNzaW9ucztcbiAgfVxuXG4gIHZhciByZWFkQXJyYXlMaXRlcmFsID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbkxpc3Q7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSAnWydcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIltcIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGV4cHJlc3Npb25MaXN0ID0gc2hhcmVkX3JlYWRFeHByZXNzaW9uTGlzdChwYXJzZXIpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJdXCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogQVJSQVlfTElURVJBTCxcbiAgXHRcdG06IGV4cHJlc3Npb25MaXN0XG4gIFx0fTtcbiAgfTtcblxuICB2YXIgcHJpbWFyeV9yZWFkTGl0ZXJhbCA9IHJlYWRMaXRlcmFsO1xuICBmdW5jdGlvbiByZWFkTGl0ZXJhbChwYXJzZXIpIHtcbiAgXHRyZXR1cm4gbGl0ZXJhbF9yZWFkTnVtYmVyTGl0ZXJhbChwYXJzZXIpIHx8IGxpdGVyYWxfcmVhZEJvb2xlYW5MaXRlcmFsKHBhcnNlcikgfHwgcmVhZFN0cmluZ0xpdGVyYWwocGFyc2VyKSB8fCByZWFkT2JqZWN0TGl0ZXJhbChwYXJzZXIpIHx8IHJlYWRBcnJheUxpdGVyYWwocGFyc2VyKSB8fCByZWFkUmVnZXhwTGl0ZXJhbChwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHByaW1hcnlfcmVhZFJlZmVyZW5jZSA9IHJlYWRSZWZlcmVuY2U7XG4gIHZhciBwcmVmaXhQYXR0ZXJuID0gL14oPzp+XFwvfCg/OlxcLlxcLlxcLykrfFxcLlxcLyg/OlxcLlxcLlxcLykqfFxcLikvLFxuICAgICAgZ2xvYmFscyxcbiAgICAgIGtleXdvcmRzO1xuXG4gIC8vIGlmIGEgcmVmZXJlbmNlIGlzIGEgYnJvd3NlciBnbG9iYWwsIHdlIGRvbid0IGRlZmVyZW5jZSBpdCBsYXRlciwgc28gaXQgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnRcbiAgZ2xvYmFscyA9IC9eKD86QXJyYXl8Y29uc29sZXxEYXRlfFJlZ0V4cHxkZWNvZGVVUklDb21wb25lbnR8ZGVjb2RlVVJJfGVuY29kZVVSSUNvbXBvbmVudHxlbmNvZGVVUkl8aXNGaW5pdGV8aXNOYU58cGFyc2VGbG9hdHxwYXJzZUludHxKU09OfE1hdGh8TmFOfHVuZGVmaW5lZHxudWxsKVxcYi87XG5cbiAgLy8ga2V5d29yZHMgYXJlIG5vdCB2YWxpZCByZWZlcmVuY2VzLCB3aXRoIHRoZSBleGNlcHRpb24gb2YgYHRoaXNgXG4gIGtleXdvcmRzID0gL14oPzpicmVha3xjYXNlfGNhdGNofGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZmluYWxseXxmb3J8ZnVuY3Rpb258aWZ8aW58aW5zdGFuY2VvZnxuZXd8cmV0dXJufHN3aXRjaHx0aHJvd3x0cnl8dHlwZW9mfHZhcnx2b2lkfHdoaWxlfHdpdGgpJC87XG5cbiAgdmFyIGxlZ2FsUmVmZXJlbmNlID0gL15bYS16QS1aJF8wLTldKyg/Oig/OlxcLlthLXpBLVokXzAtOV0rKXwoPzpcXFtbMC05XStcXF0pKSovO1xuICB2YXIgcmVsYXhlZE5hbWUgPSAvXlthLXpBLVpfJF1bLWEtekEtWl8kMC05XSovO1xuICBmdW5jdGlvbiByZWFkUmVmZXJlbmNlKHBhcnNlcikge1xuICBcdHZhciBzdGFydFBvcywgcHJlZml4LCBuYW1lLCBnbG9iYWwsIHJlZmVyZW5jZSwgbGFzdERvdEluZGV4O1xuXG4gIFx0c3RhcnRQb3MgPSBwYXJzZXIucG9zO1xuXG4gIFx0bmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oL15AKD86a2V5cGF0aHxpbmRleHxrZXkpLyk7XG5cbiAgXHRpZiAoIW5hbWUpIHtcbiAgXHRcdHByZWZpeCA9IHBhcnNlci5tYXRjaFBhdHRlcm4ocHJlZml4UGF0dGVybikgfHwgXCJcIjtcbiAgXHRcdG5hbWUgPSAhcHJlZml4ICYmIHBhcnNlci5yZWxheGVkTmFtZXMgJiYgcGFyc2VyLm1hdGNoUGF0dGVybihyZWxheGVkTmFtZSkgfHwgcGFyc2VyLm1hdGNoUGF0dGVybihsZWdhbFJlZmVyZW5jZSk7XG5cbiAgXHRcdGlmICghbmFtZSAmJiBwcmVmaXggPT09IFwiLlwiKSB7XG4gIFx0XHRcdHByZWZpeCA9IFwiXCI7XG4gIFx0XHRcdG5hbWUgPSBcIi5cIjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoIW5hbWUpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGJ1ZyBvdXQgaWYgaXQncyBhIGtleXdvcmQgKGV4Y2VwdGlvbiBmb3IgYW5jZXN0b3IvcmVzdHJpY3RlZCByZWZzIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMvMTQ5NylcbiAgXHRpZiAoIXByZWZpeCAmJiAhcGFyc2VyLnJlbGF4ZWROYW1lcyAmJiBrZXl3b3Jkcy50ZXN0KG5hbWUpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3M7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBpZiB0aGlzIGlzIGEgYnJvd3NlciBnbG9iYWwsIHN0b3AgaGVyZVxuICBcdGlmICghcHJlZml4ICYmIGdsb2JhbHMudGVzdChuYW1lKSkge1xuICBcdFx0Z2xvYmFsID0gZ2xvYmFscy5leGVjKG5hbWUpWzBdO1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0UG9zICsgZ2xvYmFsLmxlbmd0aDtcblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogR0xPQkFMLFxuICBcdFx0XHR2OiBnbG9iYWxcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmVmZXJlbmNlID0gKHByZWZpeCB8fCBcIlwiKSArIG5vcm1hbGlzZShuYW1lKTtcblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIoXCIpKSB7XG4gIFx0XHQvLyBpZiB0aGlzIGlzIGEgbWV0aG9kIGludm9jYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBmdW5jdGlvbikgd2UgbmVlZFxuICBcdFx0Ly8gdG8gc3RyaXAgdGhlIG1ldGhvZCBuYW1lIGZyb20gdGhlIHJlZmVyZW5jZSBjb21ibywgZWxzZSB0aGUgY29udGV4dFxuICBcdFx0Ly8gd2lsbCBiZSB3cm9uZ1xuICBcdFx0bGFzdERvdEluZGV4ID0gcmVmZXJlbmNlLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgXHRcdGlmIChsYXN0RG90SW5kZXggIT09IC0xKSB7XG4gIFx0XHRcdHJlZmVyZW5jZSA9IHJlZmVyZW5jZS5zdWJzdHIoMCwgbGFzdERvdEluZGV4KTtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0UG9zICsgcmVmZXJlbmNlLmxlbmd0aDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgLT0gMTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogUkVGRVJFTkNFLFxuICBcdFx0bjogcmVmZXJlbmNlLnJlcGxhY2UoL150aGlzXFwuLywgXCIuL1wiKS5yZXBsYWNlKC9edGhpcyQvLCBcIi5cIilcbiAgXHR9O1xuICB9XG5cbiAgdmFyIHByaW1hcnlfcmVhZEJyYWNrZXRlZEV4cHJlc3Npb24gPSByZWFkQnJhY2tldGVkRXhwcmVzc2lvbjtcbiAgZnVuY3Rpb24gcmVhZEJyYWNrZXRlZEV4cHJlc3Npb24ocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIoXCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRleHByID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdGlmICghZXhwcikge1xuICBcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkRXhwcmVzc2lvbik7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIpXCIpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRQYXJlbik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IEJSQUNLRVRFRCxcbiAgXHRcdHg6IGV4cHJcbiAgXHR9O1xuICB9XG5cbiAgdmFyIHJlYWRQcmltYXJ5ID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdHJldHVybiBwcmltYXJ5X3JlYWRMaXRlcmFsKHBhcnNlcikgfHwgcHJpbWFyeV9yZWFkUmVmZXJlbmNlKHBhcnNlcikgfHwgcHJpbWFyeV9yZWFkQnJhY2tldGVkRXhwcmVzc2lvbihwYXJzZXIpO1xuICB9O1xuXG4gIHZhciBzaGFyZWRfcmVhZFJlZmluZW1lbnQgPSByZWFkUmVmaW5lbWVudDtcbiAgZnVuY3Rpb24gcmVhZFJlZmluZW1lbnQocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBuYW1lLCBleHByO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gXCIuXCIgbmFtZVxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIuXCIpKSB7XG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGlmIChuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybihwYXR0ZXJuc19fbmFtZSkpIHtcbiAgXHRcdFx0cmV0dXJuIHtcbiAgXHRcdFx0XHR0OiBSRUZJTkVNRU5ULFxuICBcdFx0XHRcdG46IG5hbWVcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgYSBwcm9wZXJ0eSBuYW1lXCIpO1xuICBcdH1cblxuICBcdC8vIFwiW1wiIGV4cHJlc3Npb24gXCJdXCJcbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiW1wiKSkge1xuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRleHByID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdFx0aWYgKCFleHByKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihleHBlY3RlZEV4cHJlc3Npb24pO1xuICBcdFx0fVxuXG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiXVwiKSkge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCAnXSdcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IFJFRklORU1FTlQsXG4gIFx0XHRcdHg6IGV4cHJcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcmVhZE1lbWJlck9ySW52b2NhdGlvbiA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHR2YXIgY3VycmVudCwgZXhwcmVzc2lvbiwgcmVmaW5lbWVudCwgZXhwcmVzc2lvbkxpc3Q7XG5cbiAgXHRleHByZXNzaW9uID0gcmVhZFByaW1hcnkocGFyc2VyKTtcblxuICBcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0d2hpbGUgKGV4cHJlc3Npb24pIHtcbiAgXHRcdGN1cnJlbnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0XHRpZiAocmVmaW5lbWVudCA9IHNoYXJlZF9yZWFkUmVmaW5lbWVudChwYXJzZXIpKSB7XG4gIFx0XHRcdGV4cHJlc3Npb24gPSB7XG4gIFx0XHRcdFx0dDogTUVNQkVSLFxuICBcdFx0XHRcdHg6IGV4cHJlc3Npb24sXG4gIFx0XHRcdFx0cjogcmVmaW5lbWVudFxuICBcdFx0XHR9O1xuICBcdFx0fSBlbHNlIGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIoXCIpKSB7XG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHRcdFx0ZXhwcmVzc2lvbkxpc3QgPSBzaGFyZWRfcmVhZEV4cHJlc3Npb25MaXN0KHBhcnNlcik7XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiKVwiKSkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihleHBlY3RlZFBhcmVuKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGV4cHJlc3Npb24gPSB7XG4gIFx0XHRcdFx0dDogSU5WT0NBVElPTixcbiAgXHRcdFx0XHR4OiBleHByZXNzaW9uXG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0aWYgKGV4cHJlc3Npb25MaXN0KSB7XG4gIFx0XHRcdFx0ZXhwcmVzc2lvbi5vID0gZXhwcmVzc2lvbkxpc3Q7XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGJyZWFrO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBleHByZXNzaW9uO1xuICB9O1xuXG4gIHZhciByZWFkVHlwZU9mLCBtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyO1xuXG4gIG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXIgPSBmdW5jdGlvbiAoc3ltYm9sLCBmYWxsdGhyb3VnaCkge1xuICBcdHJldHVybiBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0XHR2YXIgZXhwcmVzc2lvbjtcblxuICBcdFx0aWYgKGV4cHJlc3Npb24gPSBmYWxsdGhyb3VnaChwYXJzZXIpKSB7XG4gIFx0XHRcdHJldHVybiBleHByZXNzaW9uO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhzeW1ib2wpKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0XHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkRXhwcmVzc2lvbik7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHM6IHN5bWJvbCxcbiAgXHRcdFx0bzogZXhwcmVzc2lvbixcbiAgXHRcdFx0dDogUFJFRklYX09QRVJBVE9SXG4gIFx0XHR9O1xuICBcdH07XG4gIH07XG5cbiAgLy8gY3JlYXRlIGFsbCBwcmVmaXggc2VxdWVuY2UgbWF0Y2hlcnMsIHJldHVybiByZWFkVHlwZU9mXG4gIChmdW5jdGlvbiAoKSB7XG4gIFx0dmFyIGksIGxlbiwgbWF0Y2hlciwgcHJlZml4T3BlcmF0b3JzLCBmYWxsdGhyb3VnaDtcblxuICBcdHByZWZpeE9wZXJhdG9ycyA9IFwiISB+ICsgLSB0eXBlb2ZcIi5zcGxpdChcIiBcIik7XG5cbiAgXHRmYWxsdGhyb3VnaCA9IHJlYWRNZW1iZXJPckludm9jYXRpb247XG4gIFx0Zm9yIChpID0gMCwgbGVuID0gcHJlZml4T3BlcmF0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRtYXRjaGVyID0gbWFrZVByZWZpeFNlcXVlbmNlTWF0Y2hlcihwcmVmaXhPcGVyYXRvcnNbaV0sIGZhbGx0aHJvdWdoKTtcbiAgXHRcdGZhbGx0aHJvdWdoID0gbWF0Y2hlcjtcbiAgXHR9XG5cbiAgXHQvLyB0eXBlb2Ygb3BlcmF0b3IgaXMgaGlnaGVyIHByZWNlZGVuY2UgdGhhbiBtdWx0aXBsaWNhdGlvbiwgc28gcHJvdmlkZXMgdGhlXG4gIFx0Ly8gZmFsbHRocm91Z2ggZm9yIHRoZSBtdWx0aXBsaWNhdGlvbiBzZXF1ZW5jZSBtYXRjaGVyIHdlJ3JlIGFib3V0IHRvIGNyZWF0ZVxuICBcdC8vICh3ZSdyZSBza2lwcGluZyB2b2lkIGFuZCBkZWxldGUpXG4gIFx0cmVhZFR5cGVPZiA9IGZhbGx0aHJvdWdoO1xuICB9KSgpO1xuXG4gIHZhciByZWFkVHlwZW9mID0gcmVhZFR5cGVPZjtcblxuICB2YXIgcmVhZExvZ2ljYWxPciwgbWFrZUluZml4U2VxdWVuY2VNYXRjaGVyO1xuXG4gIG1ha2VJbmZpeFNlcXVlbmNlTWF0Y2hlciA9IGZ1bmN0aW9uIChzeW1ib2wsIGZhbGx0aHJvdWdoKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHRcdHZhciBzdGFydCwgbGVmdCwgcmlnaHQ7XG5cbiAgXHRcdGxlZnQgPSBmYWxsdGhyb3VnaChwYXJzZXIpO1xuICBcdFx0aWYgKCFsZWZ0KSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBMb29wIHRvIGhhbmRsZSBsZWZ0LXJlY3Vyc2lvbiBpbiBhIGNhc2UgbGlrZSBgYSAqIGIgKiBjYCBhbmQgcHJvZHVjZVxuICBcdFx0Ly8gbGVmdCBhc3NvY2lhdGlvbiwgaS5lLiBgKGEgKiBiKSAqIGNgLiAgVGhlIG1hdGNoZXIgY2FuJ3QgY2FsbCBpdHNlbGZcbiAgXHRcdC8vIHRvIHBhcnNlIGBsZWZ0YCBiZWNhdXNlIHRoYXQgd291bGQgYmUgaW5maW5pdGUgcmVncmVzcy5cbiAgXHRcdHdoaWxlICh0cnVlKSB7XG4gIFx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoc3ltYm9sKSkge1xuICBcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0XHRyZXR1cm4gbGVmdDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGluIG9wZXJhdG9yIG11c3Qgbm90IGJlIGZvbGxvd2VkIGJ5IFthLXpBLVpfJDAtOV1cbiAgXHRcdFx0aWYgKHN5bWJvbCA9PT0gXCJpblwiICYmIC9bYS16QS1aXyQwLTldLy50ZXN0KHBhcnNlci5yZW1haW5pbmcoKS5jaGFyQXQoMCkpKSB7XG4gIFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRcdHJldHVybiBsZWZ0O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRcdC8vIHJpZ2h0IG9wZXJhbmQgbXVzdCBhbHNvIGNvbnNpc3Qgb2Ygb25seSBoaWdoZXItcHJlY2VkZW5jZSBvcGVyYXRvcnNcbiAgXHRcdFx0cmlnaHQgPSBmYWxsdGhyb3VnaChwYXJzZXIpO1xuICBcdFx0XHRpZiAoIXJpZ2h0KSB7XG4gIFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRcdHJldHVybiBsZWZ0O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0bGVmdCA9IHtcbiAgXHRcdFx0XHR0OiBJTkZJWF9PUEVSQVRPUixcbiAgXHRcdFx0XHRzOiBzeW1ib2wsXG4gIFx0XHRcdFx0bzogW2xlZnQsIHJpZ2h0XVxuICBcdFx0XHR9O1xuXG4gIFx0XHRcdC8vIExvb3AgYmFjayBhcm91bmQuICBJZiB3ZSBkb24ndCBzZWUgYW5vdGhlciBvY2N1cnJlbmNlIG9mIHRoZSBzeW1ib2wsXG4gIFx0XHRcdC8vIHdlJ2xsIHJldHVybiBsZWZ0LlxuICBcdFx0fVxuICBcdH07XG4gIH07XG5cbiAgLy8gY3JlYXRlIGFsbCBpbmZpeCBzZXF1ZW5jZSBtYXRjaGVycywgYW5kIHJldHVybiByZWFkTG9naWNhbE9yXG4gIChmdW5jdGlvbiAoKSB7XG4gIFx0dmFyIGksIGxlbiwgbWF0Y2hlciwgaW5maXhPcGVyYXRvcnMsIGZhbGx0aHJvdWdoO1xuXG4gIFx0Ly8gQWxsIHRoZSBpbmZpeCBvcGVyYXRvcnMgb24gb3JkZXIgb2YgcHJlY2VkZW5jZSAoc291cmNlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9PcGVyYXRvcl9QcmVjZWRlbmNlKVxuICBcdC8vIEVhY2ggc2VxdWVuY2UgbWF0Y2hlciB3aWxsIGluaXRpYWxseSBmYWxsIHRocm91Z2ggdG8gaXRzIGhpZ2hlciBwcmVjZWRlbmNlXG4gIFx0Ly8gbmVpZ2hib3VyLCBhbmQgb25seSBhdHRlbXB0IHRvIG1hdGNoIGlmIG9uZSBvZiB0aGUgaGlnaGVyIHByZWNlZGVuY2Ugb3BlcmF0b3JzXG4gIFx0Ly8gKG9yLCB1bHRpbWF0ZWx5LCBhIGxpdGVyYWwsIHJlZmVyZW5jZSwgb3IgYnJhY2tldGVkIGV4cHJlc3Npb24pIGFscmVhZHkgbWF0Y2hlZFxuICBcdGluZml4T3BlcmF0b3JzID0gXCIqIC8gJSArIC0gPDwgPj4gPj4+IDwgPD0gPiA+PSBpbiBpbnN0YW5jZW9mID09ICE9ID09PSAhPT0gJiBeIHwgJiYgfHxcIi5zcGxpdChcIiBcIik7XG5cbiAgXHQvLyBBIHR5cGVvZiBvcGVyYXRvciBpcyBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuIG11bHRpcGxpY2F0aW9uXG4gIFx0ZmFsbHRocm91Z2ggPSByZWFkVHlwZW9mO1xuICBcdGZvciAoaSA9IDAsIGxlbiA9IGluZml4T3BlcmF0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRtYXRjaGVyID0gbWFrZUluZml4U2VxdWVuY2VNYXRjaGVyKGluZml4T3BlcmF0b3JzW2ldLCBmYWxsdGhyb3VnaCk7XG4gIFx0XHRmYWxsdGhyb3VnaCA9IG1hdGNoZXI7XG4gIFx0fVxuXG4gIFx0Ly8gTG9naWNhbCBPUiBpcyB0aGUgZmFsbHRocm91Z2ggZm9yIHRoZSBjb25kaXRpb25hbCBtYXRjaGVyXG4gIFx0cmVhZExvZ2ljYWxPciA9IGZhbGx0aHJvdWdoO1xuICB9KSgpO1xuXG4gIHZhciBleHByZXNzaW9uc19yZWFkTG9naWNhbE9yID0gcmVhZExvZ2ljYWxPcjtcblxuICAvLyBUaGUgY29uZGl0aW9uYWwgb3BlcmF0b3IgaXMgdGhlIGxvd2VzdCBwcmVjZWRlbmNlIG9wZXJhdG9yLCBzbyB3ZSBzdGFydCBoZXJlXG4gIHZhciByZWFkQ29uZGl0aW9uYWwgPSBnZXRDb25kaXRpb25hbDtcbiAgZnVuY3Rpb24gZ2V0Q29uZGl0aW9uYWwocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uLCBpZlRydWUsIGlmRmFsc2U7XG5cbiAgXHRleHByZXNzaW9uID0gZXhwcmVzc2lvbnNfcmVhZExvZ2ljYWxPcihwYXJzZXIpO1xuICBcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI/XCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZlRydWUgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0aWYgKCFpZlRydWUpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihleHBlY3RlZEV4cHJlc3Npb24pO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiOlwiKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgXFxcIjpcXFwiXCIpO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmRmFsc2UgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0aWYgKCFpZkZhbHNlKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogQ09ORElUSU9OQUwsXG4gIFx0XHRvOiBbZXhwcmVzc2lvbiwgaWZUcnVlLCBpZkZhbHNlXVxuICBcdH07XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkRXhwcmVzc2lvbiA9IHJlYWRFeHByZXNzaW9uO1xuICBmdW5jdGlvbiByZWFkRXhwcmVzc2lvbihwYXJzZXIpIHtcbiAgXHQvLyBUaGUgY29uZGl0aW9uYWwgb3BlcmF0b3IgaXMgdGhlIGxvd2VzdCBwcmVjZWRlbmNlIG9wZXJhdG9yIChleGNlcHQgeWllbGQsXG4gIFx0Ly8gYXNzaWdubWVudCBvcGVyYXRvcnMsIGFuZCBjb21tYXMsIG5vbmUgb2Ygd2hpY2ggYXJlIHN1cHBvcnRlZCksIHNvIHdlXG4gIFx0Ly8gc3RhcnQgdGhlcmUuIElmIGl0IGRvZXNuJ3QgbWF0Y2gsIGl0ICdmYWxscyB0aHJvdWdoJyB0byBwcm9ncmVzc2l2ZWx5XG4gIFx0Ly8gaGlnaGVyIHByZWNlZGVuY2Ugb3BlcmF0b3JzLCB1bnRpbCBpdCBldmVudHVhbGx5IG1hdGNoZXMgKG9yIGZhaWxzIHRvXG4gIFx0Ly8gbWF0Y2gpIGEgJ3ByaW1hcnknIC0gYSBsaXRlcmFsIG9yIGEgcmVmZXJlbmNlLiBUaGlzIHdheSwgdGhlIGFic3RyYWN0IHN5bnRheFxuICBcdC8vIHRyZWUgaGFzIGV2ZXJ5dGhpbmcgaW4gaXRzIHByb3BlciBwbGFjZSwgaS5lLiAyICsgMyAqIDQgPT09IDE0LCBub3QgMjAuXG4gIFx0cmV0dXJuIHJlYWRDb25kaXRpb25hbChwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHV0aWxzX2ZsYXR0ZW5FeHByZXNzaW9uID0gZmxhdHRlbkV4cHJlc3Npb247XG5cbiAgZnVuY3Rpb24gZmxhdHRlbkV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICBcdHZhciByZWZzO1xuXG4gIFx0ZXh0cmFjdFJlZnMoZXhwcmVzc2lvbiwgcmVmcyA9IFtdKTtcblxuICBcdHJldHVybiB7XG4gIFx0XHRyOiByZWZzLFxuICBcdFx0czogc3RyaW5naWZ5KGV4cHJlc3Npb24pXG4gIFx0fTtcblxuICBcdGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlKSB7XG4gIFx0XHRzd2l0Y2ggKG5vZGUudCkge1xuICBcdFx0XHRjYXNlIEJPT0xFQU5fTElURVJBTDpcbiAgXHRcdFx0Y2FzZSBHTE9CQUw6XG4gIFx0XHRcdGNhc2UgTlVNQkVSX0xJVEVSQUw6XG4gIFx0XHRcdGNhc2UgUkVHRVhQX0xJVEVSQUw6XG4gIFx0XHRcdFx0cmV0dXJuIG5vZGUudjtcblxuICBcdFx0XHRjYXNlIFNUUklOR19MSVRFUkFMOlxuICBcdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShTdHJpbmcobm9kZS52KSk7XG5cbiAgXHRcdFx0Y2FzZSBBUlJBWV9MSVRFUkFMOlxuICBcdFx0XHRcdHJldHVybiBcIltcIiArIChub2RlLm0gPyBub2RlLm0ubWFwKHN0cmluZ2lmeSkuam9pbihcIixcIikgOiBcIlwiKSArIFwiXVwiO1xuXG4gIFx0XHRcdGNhc2UgT0JKRUNUX0xJVEVSQUw6XG4gIFx0XHRcdFx0cmV0dXJuIFwie1wiICsgKG5vZGUubSA/IG5vZGUubS5tYXAoc3RyaW5naWZ5KS5qb2luKFwiLFwiKSA6IFwiXCIpICsgXCJ9XCI7XG5cbiAgXHRcdFx0Y2FzZSBLRVlfVkFMVUVfUEFJUjpcbiAgXHRcdFx0XHRyZXR1cm4gbm9kZS5rICsgXCI6XCIgKyBzdHJpbmdpZnkobm9kZS52KTtcblxuICBcdFx0XHRjYXNlIFBSRUZJWF9PUEVSQVRPUjpcbiAgXHRcdFx0XHRyZXR1cm4gKG5vZGUucyA9PT0gXCJ0eXBlb2ZcIiA/IFwidHlwZW9mIFwiIDogbm9kZS5zKSArIHN0cmluZ2lmeShub2RlLm8pO1xuXG4gIFx0XHRcdGNhc2UgSU5GSVhfT1BFUkFUT1I6XG4gIFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeShub2RlLm9bMF0pICsgKG5vZGUucy5zdWJzdHIoMCwgMikgPT09IFwiaW5cIiA/IFwiIFwiICsgbm9kZS5zICsgXCIgXCIgOiBub2RlLnMpICsgc3RyaW5naWZ5KG5vZGUub1sxXSk7XG5cbiAgXHRcdFx0Y2FzZSBJTlZPQ0FUSU9OOlxuICBcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkobm9kZS54KSArIFwiKFwiICsgKG5vZGUubyA/IG5vZGUuby5tYXAoc3RyaW5naWZ5KS5qb2luKFwiLFwiKSA6IFwiXCIpICsgXCIpXCI7XG5cbiAgXHRcdFx0Y2FzZSBCUkFDS0VURUQ6XG4gIFx0XHRcdFx0cmV0dXJuIFwiKFwiICsgc3RyaW5naWZ5KG5vZGUueCkgKyBcIilcIjtcblxuICBcdFx0XHRjYXNlIE1FTUJFUjpcbiAgXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KG5vZGUueCkgKyBzdHJpbmdpZnkobm9kZS5yKTtcblxuICBcdFx0XHRjYXNlIFJFRklORU1FTlQ6XG4gIFx0XHRcdFx0cmV0dXJuIG5vZGUubiA/IFwiLlwiICsgbm9kZS5uIDogXCJbXCIgKyBzdHJpbmdpZnkobm9kZS54KSArIFwiXVwiO1xuXG4gIFx0XHRcdGNhc2UgQ09ORElUSU9OQUw6XG4gIFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeShub2RlLm9bMF0pICsgXCI/XCIgKyBzdHJpbmdpZnkobm9kZS5vWzFdKSArIFwiOlwiICsgc3RyaW5naWZ5KG5vZGUub1syXSk7XG5cbiAgXHRcdFx0Y2FzZSBSRUZFUkVOQ0U6XG4gIFx0XHRcdFx0cmV0dXJuIFwiX1wiICsgcmVmcy5pbmRleE9mKG5vZGUubik7XG5cbiAgXHRcdFx0ZGVmYXVsdDpcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBsZWdhbCBKYXZhU2NyaXB0XCIpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIC8vIFRPRE8gbWF5YmUgcmVmYWN0b3IgdGhpcz9cbiAgZnVuY3Rpb24gZXh0cmFjdFJlZnMobm9kZSwgcmVmcykge1xuICBcdHZhciBpLCBsaXN0O1xuXG4gIFx0aWYgKG5vZGUudCA9PT0gUkVGRVJFTkNFKSB7XG4gIFx0XHRpZiAocmVmcy5pbmRleE9mKG5vZGUubikgPT09IC0xKSB7XG4gIFx0XHRcdHJlZnMudW5zaGlmdChub2RlLm4pO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGxpc3QgPSBub2RlLm8gfHwgbm9kZS5tO1xuICBcdGlmIChsaXN0KSB7XG4gIFx0XHRpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgXHRcdFx0ZXh0cmFjdFJlZnMobGlzdCwgcmVmcyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpID0gbGlzdC5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRleHRyYWN0UmVmcyhsaXN0W2ldLCByZWZzKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChub2RlLngpIHtcbiAgXHRcdGV4dHJhY3RSZWZzKG5vZGUueCwgcmVmcyk7XG4gIFx0fVxuXG4gIFx0aWYgKG5vZGUucikge1xuICBcdFx0ZXh0cmFjdFJlZnMobm9kZS5yLCByZWZzKTtcbiAgXHR9XG5cbiAgXHRpZiAobm9kZS52KSB7XG4gIFx0XHRleHRyYWN0UmVmcyhub2RlLnYsIHJlZnMpO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1dGlsc19yZWZpbmVFeHByZXNzaW9uID0gcmVmaW5lRXhwcmVzc2lvbjtcblxuICB2YXIgYXJyYXlNZW1iZXJQYXR0ZXJuID0gL15bMC05XVsxLTldKiQvO1xuICBmdW5jdGlvbiByZWZpbmVFeHByZXNzaW9uKGV4cHJlc3Npb24sIG11c3RhY2hlKSB7XG4gIFx0dmFyIHJlZmVyZW5jZUV4cHJlc3Npb247XG5cbiAgXHRpZiAoZXhwcmVzc2lvbikge1xuICBcdFx0d2hpbGUgKGV4cHJlc3Npb24udCA9PT0gQlJBQ0tFVEVEICYmIGV4cHJlc3Npb24ueCkge1xuICBcdFx0XHRleHByZXNzaW9uID0gZXhwcmVzc2lvbi54O1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBpbnRlZ2VycyBzaG91bGQgYmUgdHJlYXRlZCBhcyBhcnJheSBtZW1iZXJzIHJlZmVyZW5jZXMsXG4gIFx0XHQvLyByYXRoZXIgdGhhbiBhcyBleHByZXNzaW9ucyBpbiB0aGVpciBvd24gcmlnaHRcbiAgXHRcdGlmIChleHByZXNzaW9uLnQgPT09IFJFRkVSRU5DRSkge1xuICBcdFx0XHRtdXN0YWNoZS5yID0gZXhwcmVzc2lvbi5uO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0aWYgKGV4cHJlc3Npb24udCA9PT0gTlVNQkVSX0xJVEVSQUwgJiYgYXJyYXlNZW1iZXJQYXR0ZXJuLnRlc3QoZXhwcmVzc2lvbi52KSkge1xuICBcdFx0XHRcdG11c3RhY2hlLnIgPSBleHByZXNzaW9uLnY7XG4gIFx0XHRcdH0gZWxzZSBpZiAocmVmZXJlbmNlRXhwcmVzc2lvbiA9IGdldFJlZmVyZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbikpIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS5yeCA9IHJlZmVyZW5jZUV4cHJlc3Npb247XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0bXVzdGFjaGUueCA9IHV0aWxzX2ZsYXR0ZW5FeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBtdXN0YWNoZTtcbiAgXHR9XG4gIH1cblxuICAvLyBUT0RPIHJlZmFjdG9yIHRoaXMhIGl0J3MgYmV3aWxkZXJpbmdcbiAgZnVuY3Rpb24gZ2V0UmVmZXJlbmNlRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gIFx0dmFyIG1lbWJlcnMgPSBbXSxcbiAgXHQgICAgcmVmaW5lbWVudDtcblxuICBcdHdoaWxlIChleHByZXNzaW9uLnQgPT09IE1FTUJFUiAmJiBleHByZXNzaW9uLnIudCA9PT0gUkVGSU5FTUVOVCkge1xuICBcdFx0cmVmaW5lbWVudCA9IGV4cHJlc3Npb24ucjtcblxuICBcdFx0aWYgKHJlZmluZW1lbnQueCkge1xuICBcdFx0XHRpZiAocmVmaW5lbWVudC54LnQgPT09IFJFRkVSRU5DRSkge1xuICBcdFx0XHRcdG1lbWJlcnMudW5zaGlmdChyZWZpbmVtZW50LngpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdG1lbWJlcnMudW5zaGlmdCh1dGlsc19mbGF0dGVuRXhwcmVzc2lvbihyZWZpbmVtZW50LngpKTtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bWVtYmVycy51bnNoaWZ0KHJlZmluZW1lbnQubik7XG4gIFx0XHR9XG5cbiAgXHRcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uLng7XG4gIFx0fVxuXG4gIFx0aWYgKGV4cHJlc3Npb24udCAhPT0gUkVGRVJFTkNFKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0cjogZXhwcmVzc2lvbi5uLFxuICBcdFx0bTogbWVtYmVyc1xuICBcdH07XG4gIH1cblxuICB2YXIgbXVzdGFjaGVfcmVhZFRyaXBsZSA9IHJlYWRUcmlwbGU7XG4gIGZ1bmN0aW9uIHJlYWRUcmlwbGUocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKSxcbiAgXHQgICAgdHJpcGxlO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0dHJpcGxlID0geyB0OiBUUklQTEUgfTtcbiAgXHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHRyaXBsZSk7IC8vIFRPRE8gaGFuZGxlIHRoaXMgZGlmZmVyZW50bHkgLSBpdCdzIG15c3RlcmlvdXNcblxuICBcdHJldHVybiB0cmlwbGU7XG4gIH1cblxuICB2YXIgbXVzdGFjaGVfcmVhZFVuZXNjYXBlZCA9IHJlYWRVbmVzY2FwZWQ7XG4gIGZ1bmN0aW9uIHJlYWRVbmVzY2FwZWQocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgZXhwcmVzc2lvbiwgdHJpcGxlO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCImXCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0dHJpcGxlID0geyB0OiBUUklQTEUgfTtcbiAgXHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHRyaXBsZSk7IC8vIFRPRE8gaGFuZGxlIHRoaXMgZGlmZmVyZW50bHkgLSBpdCdzIG15c3RlcmlvdXNcblxuICBcdHJldHVybiB0cmlwbGU7XG4gIH1cblxuICB2YXIgbXVzdGFjaGVfcmVhZFBhcnRpYWwgPSByZWFkUGFydGlhbDtcbiAgZnVuY3Rpb24gcmVhZFBhcnRpYWwocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIG5hbWVTdGFydCwgZXhwcmVzc2lvbiwgY29udGV4dCwgcGFydGlhbDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPlwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdG5hbWVTdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBQYXJ0aWFsIG5hbWVzIGNhbiBpbmNsdWRlIGh5cGhlbnMsIHNvIHdlIGNhbid0IHVzZSByZWFkRXhwcmVzc2lvblxuICBcdC8vIGJsaW5kbHkuIEluc3RlYWQsIHdlIHVzZSB0aGUgYHJlbGF4ZWROYW1lc2AgZmxhZyB0byBpbmRpY2F0ZSB0aGF0XG4gIFx0Ly8gYGZvby1iYXJgIHNob3VsZCBiZSByZWFkIGFzIGEgc2luZ2xlIG5hbWUsIHJhdGhlciB0aGFuICdzdWJ0cmFjdFxuICBcdC8vIGJhciBmcm9tIGZvbydcbiAgXHRwYXJzZXIucmVsYXhlZE5hbWVzID0gdHJ1ZTtcbiAgXHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdHBhcnNlci5yZWxheGVkTmFtZXMgPSBmYWxzZTtcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHRjb250ZXh0ID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFydGlhbCA9IHsgdDogUEFSVElBTCB9O1xuICBcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgcGFydGlhbCk7IC8vIFRPRE8uLi5cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIGlmIHdlIGhhdmUgYW5vdGhlciBleHByZXNzaW9uIC0gZS5nLiBge3s+Zm9vIGJhcn19YCAtIHRoZW5cbiAgXHQvLyB3ZSB0dXJuIGl0IGludG8gYHt7I3dpdGggYmFyfX17ez5mb299fXt7L3dpdGh9fWBcbiAgXHRpZiAoY29udGV4dCkge1xuICBcdFx0cGFydGlhbCA9IHtcbiAgXHRcdFx0dDogU0VDVElPTixcbiAgXHRcdFx0bjogU0VDVElPTl9XSVRILFxuICBcdFx0XHRmOiBbcGFydGlhbF1cbiAgXHRcdH07XG5cbiAgXHRcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oY29udGV4dCwgcGFydGlhbCk7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInXCIpO1xuICBcdH1cblxuICBcdHJldHVybiBwYXJ0aWFsO1xuICB9XG5cbiAgdmFyIHJlYWRNdXN0YWNoZUNvbW1lbnQgPSByZWFkQ29tbWVudDtcbiAgZnVuY3Rpb24gcmVhZENvbW1lbnQocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgaW5kZXg7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIiFcIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGluZGV4ID0gcGFyc2VyLnJlbWFpbmluZygpLmluZGV4T2YodGFnLmNsb3NlKTtcblxuICBcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdHBhcnNlci5wb3MgKz0gaW5kZXggKyB0YWcuY2xvc2UubGVuZ3RoO1xuICBcdFx0cmV0dXJuIHsgdDogQ09NTUVOVCB9O1xuICBcdH1cbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uT3JSZWZlcmVuY2UgPSByZWFkRXhwcmVzc2lvbk9yUmVmZXJlbmNlO1xuICBmdW5jdGlvbiByZWFkRXhwcmVzc2lvbk9yUmVmZXJlbmNlKHBhcnNlciwgZXhwZWN0ZWRGb2xsb3dlcnMpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb24sIGk7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG4gIFx0ZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcblxuICBcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Zm9yIChpID0gMDsgaSA8IGV4cGVjdGVkRm9sbG93ZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRpZiAocGFyc2VyLnJlbWFpbmluZygpLnN1YnN0cigwLCBleHBlY3RlZEZvbGxvd2Vyc1tpXS5sZW5ndGgpID09PSBleHBlY3RlZEZvbGxvd2Vyc1tpXSkge1xuICBcdFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0cmV0dXJuIHByaW1hcnlfcmVhZFJlZmVyZW5jZShwYXJzZXIpO1xuICB9XG5cbiAgdmFyIG11c3RhY2hlX3JlYWRJbnRlcnBvbGF0b3IgPSByZWFkSW50ZXJwb2xhdG9yO1xuICBmdW5jdGlvbiByZWFkSW50ZXJwb2xhdG9yKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uLCBpbnRlcnBvbGF0b3IsIGVycjtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIFRPRE8gd291bGQgYmUgZ29vZCBmb3IgcGVyZiBpZiB3ZSBjb3VsZCBkbyBhd2F5IHdpdGggdGhlIHRyeS1jYXRjaFxuICBcdHRyeSB7XG4gIFx0XHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbk9yUmVmZXJlbmNlKHBhcnNlciwgW3RhZy5jbG9zZV0pO1xuICBcdH0gY2F0Y2ggKGUpIHtcbiAgXHRcdGVyciA9IGU7XG4gIFx0fVxuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRpZiAocGFyc2VyLnN0ci5jaGFyQXQoc3RhcnQpID09PSBcIiFcIikge1xuICBcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBjb21tZW50XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChlcnIpIHtcbiAgXHRcdFx0dGhyb3cgZXJyO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJyBhZnRlciByZWZlcmVuY2VcIik7XG5cbiAgXHRcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBjb21tZW50XG4gIFx0XHRcdGlmIChwYXJzZXIubmV4dENoYXIoKSA9PT0gXCIhXCIpIHtcbiAgXHRcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGV4cHJlc3Npb24gb3IgbGVnYWwgcmVmZXJlbmNlXCIpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGludGVycG9sYXRvciA9IHsgdDogSU5URVJQT0xBVE9SIH07XG4gIFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCBpbnRlcnBvbGF0b3IpOyAvLyBUT0RPIGhhbmRsZSB0aGlzIGRpZmZlcmVudGx5IC0gaXQncyBteXN0ZXJpb3VzXG5cbiAgXHRyZXR1cm4gaW50ZXJwb2xhdG9yO1xuICB9XG5cbiAgdmFyIG11c3RhY2hlX3JlYWRZaWVsZGVyID0gcmVhZFlpZWxkZXI7XG4gIHZhciB5aWVsZFBhdHRlcm4gPSAvXnlpZWxkXFxzKi87XG4gIGZ1bmN0aW9uIHJlYWRZaWVsZGVyKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIHN0YXJ0LCBuYW1lLCB5aWVsZGVyO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHlpZWxkUGF0dGVybikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybigvXlthLXpBLVpfJF1bYS16QS1aXyQwLTlcXC1dKi8pO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiZXhwZWN0ZWQgbGVnYWwgcGFydGlhbCBuYW1lXCIpO1xuICBcdH1cblxuICBcdHlpZWxkZXIgPSB7IHQ6IFlJRUxERVIgfTtcblxuICBcdGlmIChuYW1lKSB7XG4gIFx0XHR5aWVsZGVyLm4gPSBuYW1lO1xuICBcdH1cblxuICBcdHJldHVybiB5aWVsZGVyO1xuICB9XG5cbiAgdmFyIHNlY3Rpb25fcmVhZENsb3NpbmcgPSByZWFkQ2xvc2luZztcbiAgZnVuY3Rpb24gcmVhZENsb3NpbmcocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIHJlbWFpbmluZywgaW5kZXgsIGNsb3Npbmc7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcub3BlbikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiL1wiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuICBcdGluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YodGFnLmNsb3NlKTtcblxuICBcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdGNsb3NpbmcgPSB7XG4gIFx0XHRcdHQ6IENMT1NJTkcsXG4gIFx0XHRcdHI6IHJlbWFpbmluZy5zdWJzdHIoMCwgaW5kZXgpLnNwbGl0KFwiIFwiKVswXVxuICBcdFx0fTtcblxuICBcdFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBjbG9zaW5nO1xuICBcdH1cblxuICBcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzZWN0aW9uX3JlYWRFbHNlID0gc2VjdGlvbl9yZWFkRWxzZV9fcmVhZEVsc2U7XG4gIHZhciBzZWN0aW9uX3JlYWRFbHNlX19lbHNlUGF0dGVybiA9IC9eXFxzKmVsc2VcXHMqLztcbiAgZnVuY3Rpb24gc2VjdGlvbl9yZWFkRWxzZV9fcmVhZEVsc2UocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLm9wZW4pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4oc2VjdGlvbl9yZWFkRWxzZV9fZWxzZVBhdHRlcm4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IEVMU0VcbiAgXHR9O1xuICB9XG5cbiAgdmFyIHJlYWRFbHNlSWYgPSByZWFkRWxzZUlmX19yZWFkRWxzZTtcbiAgdmFyIHJlYWRFbHNlSWZfX2Vsc2VQYXR0ZXJuID0gL15cXHMqZWxzZWlmXFxzKy87XG4gIGZ1bmN0aW9uIHJlYWRFbHNlSWZfX3JlYWRFbHNlKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIHN0YXJ0ID0gcGFyc2VyLnBvcyxcbiAgXHQgICAgZXhwcmVzc2lvbjtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5vcGVuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHJlYWRFbHNlSWZfX2Vsc2VQYXR0ZXJuKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0ZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogRUxTRUlGLFxuICBcdFx0eDogZXhwcmVzc2lvblxuICBcdH07XG4gIH1cblxuICB2YXIgaGFuZGxlYmFyc0Jsb2NrQ29kZXMgPSB7XG4gIFx0ZWFjaDogU0VDVElPTl9FQUNILFxuICBcdFwiaWZcIjogU0VDVElPTl9JRixcbiAgXHRcImlmLXdpdGhcIjogU0VDVElPTl9JRl9XSVRILFxuICBcdFwid2l0aFwiOiBTRUNUSU9OX1dJVEgsXG4gIFx0dW5sZXNzOiBTRUNUSU9OX1VOTEVTU1xuICB9O1xuXG4gIHZhciBtdXN0YWNoZV9yZWFkU2VjdGlvbiA9IHJlYWRTZWN0aW9uO1xuXG4gIHZhciBpbmRleFJlZlBhdHRlcm4gPSAvXlxccyo6XFxzKihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopLyxcbiAgICAgIGtleUluZGV4UmVmUGF0dGVybiA9IC9eXFxzKixcXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKikvLFxuICAgICAgaGFuZGxlYmFyc0Jsb2NrUGF0dGVybiA9IG5ldyBSZWdFeHAoXCJeKFwiICsgT2JqZWN0LmtleXMoaGFuZGxlYmFyc0Jsb2NrQ29kZXMpLmpvaW4oXCJ8XCIpICsgXCIpXFxcXGJcIik7XG4gIGZ1bmN0aW9uIHJlYWRTZWN0aW9uKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uLCBzZWN0aW9uLCBjaGlsZCwgY2hpbGRyZW4sIGhhc0Vsc2UsIGJsb2NrLCB1bmxlc3NCbG9jaywgY29uZGl0aW9ucywgY2xvc2VkLCBpLCBleHBlY3RlZENsb3NlO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIl5cIikpIHtcbiAgXHRcdHNlY3Rpb24gPSB7IHQ6IFNFQ1RJT04sIGY6IFtdLCBuOiBTRUNUSU9OX1VOTEVTUyB9O1xuICBcdH0gZWxzZSBpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiI1wiKSkge1xuICBcdFx0c2VjdGlvbiA9IHsgdDogU0VDVElPTiwgZjogW10gfTtcblxuICBcdFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcInBhcnRpYWxcIikpIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0IC0gcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1swXS5sZW5ndGg7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIlBhcnRpYWwgZGVmaW5pdGlvbnMgY2FuIG9ubHkgYmUgYXQgdGhlIHRvcCBsZXZlbCBvZiB0aGUgdGVtcGxhdGUsIG9yIGltbWVkaWF0ZWx5IGluc2lkZSBjb21wb25lbnRzXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoYmxvY2sgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGhhbmRsZWJhcnNCbG9ja1BhdHRlcm4pKSB7XG4gIFx0XHRcdGV4cGVjdGVkQ2xvc2UgPSBibG9jaztcbiAgXHRcdFx0c2VjdGlvbi5uID0gaGFuZGxlYmFyc0Jsb2NrQ29kZXNbYmxvY2tdO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBleHByZXNzaW9uXCIpO1xuICBcdH1cblxuICBcdC8vIG9wdGlvbmFsIGluZGV4IGFuZCBrZXkgcmVmZXJlbmNlc1xuICBcdGlmIChpID0gcGFyc2VyLm1hdGNoUGF0dGVybihpbmRleFJlZlBhdHRlcm4pKSB7XG4gIFx0XHR2YXIgZXh0cmEgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdGlmIChleHRyYSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oa2V5SW5kZXhSZWZQYXR0ZXJuKSkge1xuICBcdFx0XHRzZWN0aW9uLmkgPSBpICsgXCIsXCIgKyBleHRyYTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHNlY3Rpb24uaSA9IGk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInXCIpO1xuICBcdH1cblxuICBcdHBhcnNlci5zZWN0aW9uRGVwdGggKz0gMTtcbiAgXHRjaGlsZHJlbiA9IHNlY3Rpb24uZjtcblxuICBcdGNvbmRpdGlvbnMgPSBbXTtcblxuICBcdGRvIHtcbiAgXHRcdGlmIChjaGlsZCA9IHNlY3Rpb25fcmVhZENsb3NpbmcocGFyc2VyLCB0YWcpKSB7XG4gIFx0XHRcdGlmIChleHBlY3RlZENsb3NlICYmIGNoaWxkLnIgIT09IGV4cGVjdGVkQ2xvc2UpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBcIiArIHRhZy5vcGVuICsgXCIvXCIgKyBleHBlY3RlZENsb3NlICsgXCJcIiArIHRhZy5jbG9zZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwYXJzZXIuc2VjdGlvbkRlcHRoIC09IDE7XG4gIFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHR9IGVsc2UgaWYgKGNoaWxkID0gcmVhZEVsc2VJZihwYXJzZXIsIHRhZykpIHtcbiAgXHRcdFx0aWYgKHNlY3Rpb24ubiA9PT0gU0VDVElPTl9VTkxFU1MpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJ7e2Vsc2V9fSBub3QgYWxsb3dlZCBpbiB7eyN1bmxlc3N9fVwiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChoYXNFbHNlKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiaWxsZWdhbCB7e2Vsc2VpZi4uLn19IGFmdGVyIHt7ZWxzZX19XCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCF1bmxlc3NCbG9jaykge1xuICBcdFx0XHRcdHVubGVzc0Jsb2NrID0gY3JlYXRlVW5sZXNzQmxvY2soZXhwcmVzc2lvbiwgc2VjdGlvbi5uKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHVubGVzc0Jsb2NrLmYucHVzaCh7XG4gIFx0XHRcdFx0dDogU0VDVElPTixcbiAgXHRcdFx0XHRuOiBTRUNUSU9OX0lGLFxuICBcdFx0XHRcdHg6IHV0aWxzX2ZsYXR0ZW5FeHByZXNzaW9uKG11c3RhY2hlX3JlYWRTZWN0aW9uX19jb21iaW5lKGNvbmRpdGlvbnMuY29uY2F0KGNoaWxkLngpKSksXG4gIFx0XHRcdFx0ZjogY2hpbGRyZW4gPSBbXVxuICBcdFx0XHR9KTtcblxuICBcdFx0XHRjb25kaXRpb25zLnB1c2goaW52ZXJ0KGNoaWxkLngpKTtcbiAgXHRcdH0gZWxzZSBpZiAoY2hpbGQgPSBzZWN0aW9uX3JlYWRFbHNlKHBhcnNlciwgdGFnKSkge1xuICBcdFx0XHRpZiAoc2VjdGlvbi5uID09PSBTRUNUSU9OX1VOTEVTUykge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcInt7ZWxzZX19IG5vdCBhbGxvd2VkIGluIHt7I3VubGVzc319XCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGhhc0Vsc2UpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJ0aGVyZSBjYW4gb25seSBiZSBvbmUge3tlbHNlfX0gYmxvY2ssIGF0IHRoZSBlbmQgb2YgYSBzZWN0aW9uXCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aGFzRWxzZSA9IHRydWU7XG5cbiAgXHRcdFx0Ly8gdXNlIGFuIHVubGVzcyBibG9jayBpZiB0aGVyZSdzIG5vIGVsc2VpZlxuICBcdFx0XHRpZiAoIXVubGVzc0Jsb2NrKSB7XG4gIFx0XHRcdFx0dW5sZXNzQmxvY2sgPSBjcmVhdGVVbmxlc3NCbG9jayhleHByZXNzaW9uLCBzZWN0aW9uLm4pO1xuICBcdFx0XHRcdGNoaWxkcmVuID0gdW5sZXNzQmxvY2suZjtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR1bmxlc3NCbG9jay5mLnB1c2goe1xuICBcdFx0XHRcdFx0dDogU0VDVElPTixcbiAgXHRcdFx0XHRcdG46IFNFQ1RJT05fSUYsXG4gIFx0XHRcdFx0XHR4OiB1dGlsc19mbGF0dGVuRXhwcmVzc2lvbihtdXN0YWNoZV9yZWFkU2VjdGlvbl9fY29tYmluZShjb25kaXRpb25zKSksXG4gIFx0XHRcdFx0XHRmOiBjaGlsZHJlbiA9IFtdXG4gIFx0XHRcdFx0fSk7XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNoaWxkID0gcGFyc2VyLnJlYWQoUkVBREVSUyk7XG5cbiAgXHRcdFx0aWYgKCFjaGlsZCkge1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoIWNsb3NlZCk7XG5cbiAgXHRpZiAodW5sZXNzQmxvY2spIHtcbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGB3aXRoYCBzaG91bGQgYmVjb21lIGBpZi13aXRoYCAoVE9ETyBpcyB0aGlzIHJpZ2h0P1xuICBcdFx0Ly8gc2VlbXMgdG8gbWUgdGhhdCBgd2l0aGAgb3VnaHQgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSwgcmVnYXJkbGVzc1xuICBcdFx0Ly8gb2YgdGhlIHByZXNlbmNlL2Fic2VuY2Ugb2YgYGVsc2VgLiBJbiBvdGhlciB3b3JkcyBzaG91bGQgYWx3YXlzXG4gIFx0XHQvLyBiZSBgaWYtd2l0aGBcbiAgXHRcdGlmIChzZWN0aW9uLm4gPT09IFNFQ1RJT05fV0lUSCkge1xuICBcdFx0XHRzZWN0aW9uLm4gPSBTRUNUSU9OX0lGX1dJVEg7XG4gIFx0XHR9XG5cbiAgXHRcdHNlY3Rpb24ubCA9IHVubGVzc0Jsb2NrO1xuICBcdH1cblxuICBcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgc2VjdGlvbik7XG5cbiAgXHQvLyBUT0RPIGlmIGEgc2VjdGlvbiBpcyBlbXB0eSBpdCBzaG91bGQgYmUgZGlzY2FyZGVkLiBEb24ndCBkb1xuICBcdC8vIHRoYXQgaGVyZSB0aG91Z2ggLSB3ZSBuZWVkIHRvIGNsZWFuIGV2ZXJ5dGhpbmcgdXAgZmlyc3QsIGFzXG4gIFx0Ly8gaXQgbWF5IGNvbnRhaW4gcmVtb3ZlYWJsZSB3aGl0ZXNwYWNlLiBBcyBhIHRlbXBvcmFyeSBtZWFzdXJlLFxuICBcdC8vIHRvIHBhc3MgdGhlIGV4aXN0aW5nIHRlc3RzLCByZW1vdmUgZW1wdHkgYGZgIGFycmF5c1xuICBcdGlmICghc2VjdGlvbi5mLmxlbmd0aCkge1xuICBcdFx0ZGVsZXRlIHNlY3Rpb24uZjtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc2VjdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVubGVzc0Jsb2NrKGV4cHJlc3Npb24sIHNlY3Rpb25UeXBlKSB7XG4gIFx0dmFyIHVubGVzc0Jsb2NrO1xuXG4gIFx0aWYgKHNlY3Rpb25UeXBlID09PSBTRUNUSU9OX1dJVEgpIHtcbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGEgYHt7I3dpdGggZm9vfX1gIHNlY3Rpb24gd2lsbCByZW5kZXIgaWYgYGZvb2AgaXNcbiAgXHRcdC8vIHRydXRoeSwgc28gdGhlIGB7e2Vsc2V9fWAgc2VjdGlvbiBuZWVkcyB0byByZW5kZXIgaWYgYGZvb2AgaXMgZmFsc3ksXG4gIFx0XHQvLyByYXRoZXIgdGhhbiBhZGhlcmluZyB0byB0aGUgbm9ybWFsIGB7eyN1bmxlc3MgZm9vfX1gIGxvZ2ljICh3aGljaFxuICBcdFx0Ly8gdHJlYXRzIGVtcHR5IGFycmF5cy9vYmplY3RzIGFzIGZhbHN5KVxuICBcdFx0dW5sZXNzQmxvY2sgPSB7XG4gIFx0XHRcdHQ6IFNFQ1RJT04sXG4gIFx0XHRcdG46IFNFQ1RJT05fSUYsXG4gIFx0XHRcdGY6IFtdXG4gIFx0XHR9O1xuXG4gIFx0XHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGludmVydChleHByZXNzaW9uKSwgdW5sZXNzQmxvY2spO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR1bmxlc3NCbG9jayA9IHtcbiAgXHRcdFx0dDogU0VDVElPTixcbiAgXHRcdFx0bjogU0VDVElPTl9VTkxFU1MsXG4gIFx0XHRcdGY6IFtdXG4gIFx0XHR9O1xuXG4gIFx0XHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHVubGVzc0Jsb2NrKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdW5sZXNzQmxvY2s7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZlcnQoZXhwcmVzc2lvbikge1xuICBcdGlmIChleHByZXNzaW9uLnQgPT09IFBSRUZJWF9PUEVSQVRPUiAmJiBleHByZXNzaW9uLnMgPT09IFwiIVwiKSB7XG4gIFx0XHRyZXR1cm4gZXhwcmVzc2lvbi5vO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBQUkVGSVhfT1BFUkFUT1IsXG4gIFx0XHRzOiBcIiFcIixcbiAgXHRcdG86IHBhcmVuc0lmTmVjZXNzYXJ5KGV4cHJlc3Npb24pXG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG11c3RhY2hlX3JlYWRTZWN0aW9uX19jb21iaW5lKGV4cHJlc3Npb25zKSB7XG4gIFx0aWYgKGV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMSkge1xuICBcdFx0cmV0dXJuIGV4cHJlc3Npb25zWzBdO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBJTkZJWF9PUEVSQVRPUixcbiAgXHRcdHM6IFwiJiZcIixcbiAgXHRcdG86IFtwYXJlbnNJZk5lY2Vzc2FyeShleHByZXNzaW9uc1swXSksIHBhcmVuc0lmTmVjZXNzYXJ5KG11c3RhY2hlX3JlYWRTZWN0aW9uX19jb21iaW5lKGV4cHJlc3Npb25zLnNsaWNlKDEpKSldXG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcmVuc0lmTmVjZXNzYXJ5KGV4cHJlc3Npb24pIHtcbiAgXHQvLyBUT0RPIG9ubHkgd3JhcCBpZiBuZWNlc3NhcnlcbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogQlJBQ0tFVEVELFxuICBcdFx0eDogZXhwcmVzc2lvblxuICBcdH07XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkSHRtbENvbW1lbnQgPSByZWFkSHRtbENvbW1lbnQ7XG4gIHZhciBPUEVOX0NPTU1FTlQgPSBcIjwhLS1cIixcbiAgICAgIENMT1NFX0NPTU1FTlQgPSBcIi0tPlwiO1xuICBmdW5jdGlvbiByZWFkSHRtbENvbW1lbnQocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBjb250ZW50LCByZW1haW5pbmcsIGVuZEluZGV4LCBjb21tZW50O1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoT1BFTl9DT01NRU5UKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuICBcdGVuZEluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YoQ0xPU0VfQ09NTUVOVCk7XG5cbiAgXHRpZiAoZW5kSW5kZXggPT09IC0xKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJJbGxlZ2FsIEhUTUwgLSBleHBlY3RlZCBjbG9zaW5nIGNvbW1lbnQgc2VxdWVuY2UgKCctLT4nKVwiKTtcbiAgXHR9XG5cbiAgXHRjb250ZW50ID0gcmVtYWluaW5nLnN1YnN0cigwLCBlbmRJbmRleCk7XG4gIFx0cGFyc2VyLnBvcyArPSBlbmRJbmRleCArIDM7XG5cbiAgXHRjb21tZW50ID0ge1xuICBcdFx0dDogQ09NTUVOVCxcbiAgXHRcdGM6IGNvbnRlbnRcbiAgXHR9O1xuXG4gIFx0aWYgKHBhcnNlci5pbmNsdWRlTGluZVBvc2l0aW9ucykge1xuICBcdFx0Y29tbWVudC5wID0gcGFyc2VyLmdldExpbmVQb3Moc3RhcnQpO1xuICBcdH1cblxuICBcdHJldHVybiBjb21tZW50O1xuICB9XG5cbiAgdmFyIGJvb2xlYW5BdHRyaWJ1dGVzLCB2b2lkRWxlbWVudE5hbWVzLCBodG1sRW50aXRpZXMsIGNvbnRyb2xDaGFyYWN0ZXJzLCBlbnRpdHlQYXR0ZXJuLCBsZXNzVGhhbiwgZ3JlYXRlclRoYW4sIGFtcDtcblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2h0bWwtbWluaWZpZXIvaXNzdWVzLzYzI2lzc3VlY29tbWVudC0zNzc2MzMxNlxuICBib29sZWFuQXR0cmlidXRlcyA9IC9eKGFsbG93RnVsbHNjcmVlbnxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y2hlY2tlZHxjb21wYWN0fGNvbnRyb2xzfGRlY2xhcmV8ZGVmYXVsdHxkZWZhdWx0Q2hlY2tlZHxkZWZhdWx0TXV0ZWR8ZGVmYXVsdFNlbGVjdGVkfGRlZmVyfGRpc2FibGVkfGVuYWJsZWR8Zm9ybU5vVmFsaWRhdGV8aGlkZGVufGluZGV0ZXJtaW5hdGV8aW5lcnR8aXNNYXB8aXRlbVNjb3BlfGxvb3B8bXVsdGlwbGV8bXV0ZWR8bm9IcmVmfG5vUmVzaXplfG5vU2hhZGV8bm9WYWxpZGF0ZXxub1dyYXB8b3BlbnxwYXVzZU9uRXhpdHxyZWFkT25seXxyZXF1aXJlZHxyZXZlcnNlZHxzY29wZWR8c2VhbWxlc3N8c2VsZWN0ZWR8c29ydGFibGV8dHJhbnNsYXRlfHRydWVTcGVlZHx0eXBlTXVzdE1hdGNofHZpc2libGUpJC9pO1xuICB2b2lkRWxlbWVudE5hbWVzID0gL14oPzphcmVhfGJhc2V8YnJ8Y29sfGNvbW1hbmR8ZG9jdHlwZXxlbWJlZHxocnxpbWd8aW5wdXR8a2V5Z2VufGxpbmt8bWV0YXxwYXJhbXxzb3VyY2V8dHJhY2t8d2JyKSQvaTtcblxuICBodG1sRW50aXRpZXMgPSB7IHF1b3Q6IDM0LCBhbXA6IDM4LCBhcG9zOiAzOSwgbHQ6IDYwLCBndDogNjIsIG5ic3A6IDE2MCwgaWV4Y2w6IDE2MSwgY2VudDogMTYyLCBwb3VuZDogMTYzLCBjdXJyZW46IDE2NCwgeWVuOiAxNjUsIGJydmJhcjogMTY2LCBzZWN0OiAxNjcsIHVtbDogMTY4LCBjb3B5OiAxNjksIG9yZGY6IDE3MCwgbGFxdW86IDE3MSwgbm90OiAxNzIsIHNoeTogMTczLCByZWc6IDE3NCwgbWFjcjogMTc1LCBkZWc6IDE3NiwgcGx1c21uOiAxNzcsIHN1cDI6IDE3OCwgc3VwMzogMTc5LCBhY3V0ZTogMTgwLCBtaWNybzogMTgxLCBwYXJhOiAxODIsIG1pZGRvdDogMTgzLCBjZWRpbDogMTg0LCBzdXAxOiAxODUsIG9yZG06IDE4NiwgcmFxdW86IDE4NywgZnJhYzE0OiAxODgsIGZyYWMxMjogMTg5LCBmcmFjMzQ6IDE5MCwgaXF1ZXN0OiAxOTEsIEFncmF2ZTogMTkyLCBBYWN1dGU6IDE5MywgQWNpcmM6IDE5NCwgQXRpbGRlOiAxOTUsIEF1bWw6IDE5NiwgQXJpbmc6IDE5NywgQUVsaWc6IDE5OCwgQ2NlZGlsOiAxOTksIEVncmF2ZTogMjAwLCBFYWN1dGU6IDIwMSwgRWNpcmM6IDIwMiwgRXVtbDogMjAzLCBJZ3JhdmU6IDIwNCwgSWFjdXRlOiAyMDUsIEljaXJjOiAyMDYsIEl1bWw6IDIwNywgRVRIOiAyMDgsIE50aWxkZTogMjA5LCBPZ3JhdmU6IDIxMCwgT2FjdXRlOiAyMTEsIE9jaXJjOiAyMTIsIE90aWxkZTogMjEzLCBPdW1sOiAyMTQsIHRpbWVzOiAyMTUsIE9zbGFzaDogMjE2LCBVZ3JhdmU6IDIxNywgVWFjdXRlOiAyMTgsIFVjaXJjOiAyMTksIFV1bWw6IDIyMCwgWWFjdXRlOiAyMjEsIFRIT1JOOiAyMjIsIHN6bGlnOiAyMjMsIGFncmF2ZTogMjI0LCBhYWN1dGU6IDIyNSwgYWNpcmM6IDIyNiwgYXRpbGRlOiAyMjcsIGF1bWw6IDIyOCwgYXJpbmc6IDIyOSwgYWVsaWc6IDIzMCwgY2NlZGlsOiAyMzEsIGVncmF2ZTogMjMyLCBlYWN1dGU6IDIzMywgZWNpcmM6IDIzNCwgZXVtbDogMjM1LCBpZ3JhdmU6IDIzNiwgaWFjdXRlOiAyMzcsIGljaXJjOiAyMzgsIGl1bWw6IDIzOSwgZXRoOiAyNDAsIG50aWxkZTogMjQxLCBvZ3JhdmU6IDI0Miwgb2FjdXRlOiAyNDMsIG9jaXJjOiAyNDQsIG90aWxkZTogMjQ1LCBvdW1sOiAyNDYsIGRpdmlkZTogMjQ3LCBvc2xhc2g6IDI0OCwgdWdyYXZlOiAyNDksIHVhY3V0ZTogMjUwLCB1Y2lyYzogMjUxLCB1dW1sOiAyNTIsIHlhY3V0ZTogMjUzLCB0aG9ybjogMjU0LCB5dW1sOiAyNTUsIE9FbGlnOiAzMzgsIG9lbGlnOiAzMzksIFNjYXJvbjogMzUyLCBzY2Fyb246IDM1MywgWXVtbDogMzc2LCBmbm9mOiA0MDIsIGNpcmM6IDcxMCwgdGlsZGU6IDczMiwgQWxwaGE6IDkxMywgQmV0YTogOTE0LCBHYW1tYTogOTE1LCBEZWx0YTogOTE2LCBFcHNpbG9uOiA5MTcsIFpldGE6IDkxOCwgRXRhOiA5MTksIFRoZXRhOiA5MjAsIElvdGE6IDkyMSwgS2FwcGE6IDkyMiwgTGFtYmRhOiA5MjMsIE11OiA5MjQsIE51OiA5MjUsIFhpOiA5MjYsIE9taWNyb246IDkyNywgUGk6IDkyOCwgUmhvOiA5MjksIFNpZ21hOiA5MzEsIFRhdTogOTMyLCBVcHNpbG9uOiA5MzMsIFBoaTogOTM0LCBDaGk6IDkzNSwgUHNpOiA5MzYsIE9tZWdhOiA5MzcsIGFscGhhOiA5NDUsIGJldGE6IDk0NiwgZ2FtbWE6IDk0NywgZGVsdGE6IDk0OCwgZXBzaWxvbjogOTQ5LCB6ZXRhOiA5NTAsIGV0YTogOTUxLCB0aGV0YTogOTUyLCBpb3RhOiA5NTMsIGthcHBhOiA5NTQsIGxhbWJkYTogOTU1LCBtdTogOTU2LCBudTogOTU3LCB4aTogOTU4LCBvbWljcm9uOiA5NTksIHBpOiA5NjAsIHJobzogOTYxLCBzaWdtYWY6IDk2Miwgc2lnbWE6IDk2MywgdGF1OiA5NjQsIHVwc2lsb246IDk2NSwgcGhpOiA5NjYsIGNoaTogOTY3LCBwc2k6IDk2OCwgb21lZ2E6IDk2OSwgdGhldGFzeW06IDk3NywgdXBzaWg6IDk3OCwgcGl2OiA5ODIsIGVuc3A6IDgxOTQsIGVtc3A6IDgxOTUsIHRoaW5zcDogODIwMSwgenduajogODIwNCwgendqOiA4MjA1LCBscm06IDgyMDYsIHJsbTogODIwNywgbmRhc2g6IDgyMTEsIG1kYXNoOiA4MjEyLCBsc3F1bzogODIxNiwgcnNxdW86IDgyMTcsIHNicXVvOiA4MjE4LCBsZHF1bzogODIyMCwgcmRxdW86IDgyMjEsIGJkcXVvOiA4MjIyLCBkYWdnZXI6IDgyMjQsIERhZ2dlcjogODIyNSwgYnVsbDogODIyNiwgaGVsbGlwOiA4MjMwLCBwZXJtaWw6IDgyNDAsIHByaW1lOiA4MjQyLCBQcmltZTogODI0MywgbHNhcXVvOiA4MjQ5LCByc2FxdW86IDgyNTAsIG9saW5lOiA4MjU0LCBmcmFzbDogODI2MCwgZXVybzogODM2NCwgaW1hZ2U6IDg0NjUsIHdlaWVycDogODQ3MiwgcmVhbDogODQ3NiwgdHJhZGU6IDg0ODIsIGFsZWZzeW06IDg1MDEsIGxhcnI6IDg1OTIsIHVhcnI6IDg1OTMsIHJhcnI6IDg1OTQsIGRhcnI6IDg1OTUsIGhhcnI6IDg1OTYsIGNyYXJyOiA4NjI5LCBsQXJyOiA4NjU2LCB1QXJyOiA4NjU3LCByQXJyOiA4NjU4LCBkQXJyOiA4NjU5LCBoQXJyOiA4NjYwLCBmb3JhbGw6IDg3MDQsIHBhcnQ6IDg3MDYsIGV4aXN0OiA4NzA3LCBlbXB0eTogODcwOSwgbmFibGE6IDg3MTEsIGlzaW46IDg3MTIsIG5vdGluOiA4NzEzLCBuaTogODcxNSwgcHJvZDogODcxOSwgc3VtOiA4NzIxLCBtaW51czogODcyMiwgbG93YXN0OiA4NzI3LCByYWRpYzogODczMCwgcHJvcDogODczMywgaW5maW46IDg3MzQsIGFuZzogODczNiwgYW5kOiA4NzQzLCBvcjogODc0NCwgY2FwOiA4NzQ1LCBjdXA6IDg3NDYsIGludDogODc0NywgdGhlcmU0OiA4NzU2LCBzaW06IDg3NjQsIGNvbmc6IDg3NzMsIGFzeW1wOiA4Nzc2LCBuZTogODgwMCwgZXF1aXY6IDg4MDEsIGxlOiA4ODA0LCBnZTogODgwNSwgc3ViOiA4ODM0LCBzdXA6IDg4MzUsIG5zdWI6IDg4MzYsIHN1YmU6IDg4MzgsIHN1cGU6IDg4MzksIG9wbHVzOiA4ODUzLCBvdGltZXM6IDg4NTUsIHBlcnA6IDg4NjksIHNkb3Q6IDg5MDEsIGxjZWlsOiA4OTY4LCByY2VpbDogODk2OSwgbGZsb29yOiA4OTcwLCByZmxvb3I6IDg5NzEsIGxhbmc6IDkwMDEsIHJhbmc6IDkwMDIsIGxvejogOTY3NCwgc3BhZGVzOiA5ODI0LCBjbHViczogOTgyNywgaGVhcnRzOiA5ODI5LCBkaWFtczogOTgzMCB9O1xuICBjb250cm9sQ2hhcmFjdGVycyA9IFs4MzY0LCAxMjksIDgyMTgsIDQwMiwgODIyMiwgODIzMCwgODIyNCwgODIyNSwgNzEwLCA4MjQwLCAzNTIsIDgyNDksIDMzOCwgMTQxLCAzODEsIDE0MywgMTQ0LCA4MjE2LCA4MjE3LCA4MjIwLCA4MjIxLCA4MjI2LCA4MjExLCA4MjEyLCA3MzIsIDg0ODIsIDM1MywgODI1MCwgMzM5LCAxNTcsIDM4MiwgMzc2XTtcbiAgZW50aXR5UGF0dGVybiA9IG5ldyBSZWdFeHAoXCImKCM/KD86eFtcXFxcd1xcXFxkXSt8XFxcXGQrfFwiICsgT2JqZWN0LmtleXMoaHRtbEVudGl0aWVzKS5qb2luKFwifFwiKSArIFwiKSk7P1wiLCBcImdcIik7XG5cbiAgZnVuY3Rpb24gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyhodG1sKSB7XG4gIFx0cmV0dXJuIGh0bWwucmVwbGFjZShlbnRpdHlQYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gsIGVudGl0eSkge1xuICBcdFx0dmFyIGNvZGU7XG5cbiAgXHRcdC8vIEhhbmRsZSBuYW1lZCBlbnRpdGllc1xuICBcdFx0aWYgKGVudGl0eVswXSAhPT0gXCIjXCIpIHtcbiAgXHRcdFx0Y29kZSA9IGh0bWxFbnRpdGllc1tlbnRpdHldO1xuICBcdFx0fSBlbHNlIGlmIChlbnRpdHlbMV0gPT09IFwieFwiKSB7XG4gIFx0XHRcdGNvZGUgPSBwYXJzZUludChlbnRpdHkuc3Vic3RyaW5nKDIpLCAxNik7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjb2RlID0gcGFyc2VJbnQoZW50aXR5LnN1YnN0cmluZygxKSwgMTApO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWNvZGUpIHtcbiAgXHRcdFx0cmV0dXJuIG1hdGNoO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWxpZGF0ZUNvZGUoY29kZSkpO1xuICBcdH0pO1xuICB9XG5cbiAgLy8gc29tZSBjb2RlIHBvaW50cyBhcmUgdmVyYm90ZW4uIElmIHdlIHdlcmUgaW5zZXJ0aW5nIEhUTUwsIHRoZSBicm93c2VyIHdvdWxkIHJlcGxhY2UgdGhlIGlsbGVnYWxcbiAgLy8gY29kZSBwb2ludHMgd2l0aCBhbHRlcm5hdGl2ZXMgaW4gc29tZSBjYXNlcyAtIHNpbmNlIHdlJ3JlIGJ5cGFzc2luZyB0aGF0IG1lY2hhbmlzbSwgd2UgbmVlZFxuICAvLyB0byByZXBsYWNlIHRoZW0gb3Vyc2VsdmVzXG4gIC8vXG4gIC8vIFNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DaGFyYWN0ZXJfZW5jb2RpbmdzX2luX0hUTUwjSWxsZWdhbF9jaGFyYWN0ZXJzXG4gIGZ1bmN0aW9uIHZhbGlkYXRlQ29kZShjb2RlKSB7XG4gIFx0aWYgKCFjb2RlKSB7XG4gIFx0XHRyZXR1cm4gNjU1MzM7XG4gIFx0fVxuXG4gIFx0Ly8gbGluZSBmZWVkIGJlY29tZXMgZ2VuZXJpYyB3aGl0ZXNwYWNlXG4gIFx0aWYgKGNvZGUgPT09IDEwKSB7XG4gIFx0XHRyZXR1cm4gMzI7XG4gIFx0fVxuXG4gIFx0Ly8gQVNDSUkgcmFuZ2UuIChXaHkgc29tZW9uZSB3b3VsZCB1c2UgSFRNTCBlbnRpdGllcyBmb3IgQVNDSUkgY2hhcmFjdGVycyBJIGRvbid0IGtub3csIGJ1dC4uLilcbiAgXHRpZiAoY29kZSA8IDEyOCkge1xuICBcdFx0cmV0dXJuIGNvZGU7XG4gIFx0fVxuXG4gIFx0Ly8gY29kZSBwb2ludHMgMTI4LTE1OSBhcmUgZGVhbHQgd2l0aCBsZW5pZW50bHkgYnkgYnJvd3NlcnMsIGJ1dCB0aGV5J3JlIGluY29ycmVjdC4gV2UgbmVlZFxuICBcdC8vIHRvIGNvcnJlY3QgdGhlIG1pc3Rha2Ugb3Igd2UnbGwgZW5kIHVwIHdpdGggbWlzc2luZyDigqwgc2lnbnMgYW5kIHNvIG9uXG4gIFx0aWYgKGNvZGUgPD0gMTU5KSB7XG4gIFx0XHRyZXR1cm4gY29udHJvbENoYXJhY3RlcnNbY29kZSAtIDEyOF07XG4gIFx0fVxuXG4gIFx0Ly8gYmFzaWMgbXVsdGlsaW5ndWFsIHBsYW5lXG4gIFx0aWYgKGNvZGUgPCA1NTI5Nikge1xuICBcdFx0cmV0dXJuIGNvZGU7XG4gIFx0fVxuXG4gIFx0Ly8gVVRGLTE2IHN1cnJvZ2F0ZSBoYWx2ZXNcbiAgXHRpZiAoY29kZSA8PSA1NzM0Mykge1xuICBcdFx0cmV0dXJuIDY1NTMzO1xuICBcdH1cblxuICBcdC8vIHJlc3Qgb2YgdGhlIGJhc2ljIG11bHRpbGluZ3VhbCBwbGFuZVxuICBcdGlmIChjb2RlIDw9IDY1NTM1KSB7XG4gIFx0XHRyZXR1cm4gY29kZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gNjU1MzM7XG4gIH1cblxuICBsZXNzVGhhbiA9IC88L2c7XG4gIGdyZWF0ZXJUaGFuID0gLz4vZztcbiAgYW1wID0gLyYvZztcblxuICBmdW5jdGlvbiBlc2NhcGVIdG1sKHN0cikge1xuICBcdHJldHVybiBzdHIucmVwbGFjZShhbXAsIFwiJmFtcDtcIikucmVwbGFjZShsZXNzVGhhbiwgXCImbHQ7XCIpLnJlcGxhY2UoZ3JlYXRlclRoYW4sIFwiJmd0O1wiKTtcbiAgfVxuXG4gIHZhciBsZWFkaW5nTGluZWJyZWFrID0gL15cXHMqXFxyP1xcbi8sXG4gICAgICB0cmFpbGluZ0xpbmVicmVhayA9IC9cXHI/XFxuXFxzKiQvO1xuXG4gIHZhciBzdHJpcFN0YW5kYWxvbmVzID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gIFx0dmFyIGksIGN1cnJlbnQsIGJhY2tPbmUsIGJhY2tUd28sIGxhc3RTZWN0aW9uSXRlbTtcblxuICBcdGZvciAoaSA9IDE7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0Y3VycmVudCA9IGl0ZW1zW2ldO1xuICBcdFx0YmFja09uZSA9IGl0ZW1zW2kgLSAxXTtcbiAgXHRcdGJhY2tUd28gPSBpdGVtc1tpIC0gMl07XG5cbiAgXHRcdC8vIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgYSBbdGV4dF1bY29tbWVudF1bdGV4dF0gc2VxdWVuY2UuLi5cbiAgXHRcdGlmIChpc1N0cmluZyhjdXJyZW50KSAmJiBpc0NvbW1lbnQoYmFja09uZSkgJiYgaXNTdHJpbmcoYmFja1R3bykpIHtcblxuICBcdFx0XHQvLyAuLi4gYW5kIHRoZSBjb21tZW50IGlzIGEgc3RhbmRhbG9uZSAoaS5lLiBsaW5lIGJyZWFrcyBlaXRoZXIgc2lkZSkuLi5cbiAgXHRcdFx0aWYgKHRyYWlsaW5nTGluZWJyZWFrLnRlc3QoYmFja1R3bykgJiYgbGVhZGluZ0xpbmVicmVhay50ZXN0KGN1cnJlbnQpKSB7XG5cbiAgXHRcdFx0XHQvLyAuLi4gdGhlbiB3ZSB3YW50IHRvIHJlbW92ZSB0aGUgd2hpdGVzcGFjZSBhZnRlciB0aGUgZmlyc3QgbGluZSBicmVha1xuICBcdFx0XHRcdGl0ZW1zW2kgLSAyXSA9IGJhY2tUd28ucmVwbGFjZSh0cmFpbGluZ0xpbmVicmVhaywgXCJcXG5cIik7XG5cbiAgXHRcdFx0XHQvLyBhbmQgdGhlIGxlYWRpbmcgbGluZSBicmVhayBvZiB0aGUgc2Vjb25kIHRleHQgdG9rZW5cbiAgXHRcdFx0XHRpdGVtc1tpXSA9IGN1cnJlbnQucmVwbGFjZShsZWFkaW5nTGluZWJyZWFrLCBcIlwiKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBpZiB0aGUgY3VycmVudCBpdGVtIGlzIGEgc2VjdGlvbiwgYW5kIGl0IGlzIHByZWNlZGVkIGJ5IGEgbGluZWJyZWFrLCBhbmRcbiAgXHRcdC8vIGl0cyBmaXJzdCBpdGVtIGlzIGEgbGluZWJyZWFrLi4uXG4gIFx0XHRpZiAoaXNTZWN0aW9uKGN1cnJlbnQpICYmIGlzU3RyaW5nKGJhY2tPbmUpKSB7XG4gIFx0XHRcdGlmICh0cmFpbGluZ0xpbmVicmVhay50ZXN0KGJhY2tPbmUpICYmIGlzU3RyaW5nKGN1cnJlbnQuZlswXSkgJiYgbGVhZGluZ0xpbmVicmVhay50ZXN0KGN1cnJlbnQuZlswXSkpIHtcbiAgXHRcdFx0XHRpdGVtc1tpIC0gMV0gPSBiYWNrT25lLnJlcGxhY2UodHJhaWxpbmdMaW5lYnJlYWssIFwiXFxuXCIpO1xuICBcdFx0XHRcdGN1cnJlbnQuZlswXSA9IGN1cnJlbnQuZlswXS5yZXBsYWNlKGxlYWRpbmdMaW5lYnJlYWssIFwiXCIpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlmIHRoZSBsYXN0IGl0ZW0gd2FzIGEgc2VjdGlvbiwgYW5kIGl0IGlzIGZvbGxvd2VkIGJ5IGEgbGluZWJyZWFrLCBhbmRcbiAgXHRcdC8vIGl0cyBsYXN0IGl0ZW0gaXMgYSBsaW5lYnJlYWsuLi5cbiAgXHRcdGlmIChpc1N0cmluZyhjdXJyZW50KSAmJiBpc1NlY3Rpb24oYmFja09uZSkpIHtcbiAgXHRcdFx0bGFzdFNlY3Rpb25JdGVtID0gbGFzdEl0ZW0oYmFja09uZS5mKTtcblxuICBcdFx0XHRpZiAoaXNTdHJpbmcobGFzdFNlY3Rpb25JdGVtKSAmJiB0cmFpbGluZ0xpbmVicmVhay50ZXN0KGxhc3RTZWN0aW9uSXRlbSkgJiYgbGVhZGluZ0xpbmVicmVhay50ZXN0KGN1cnJlbnQpKSB7XG4gIFx0XHRcdFx0YmFja09uZS5mW2JhY2tPbmUuZi5sZW5ndGggLSAxXSA9IGxhc3RTZWN0aW9uSXRlbS5yZXBsYWNlKHRyYWlsaW5nTGluZWJyZWFrLCBcIlxcblwiKTtcbiAgXHRcdFx0XHRpdGVtc1tpXSA9IGN1cnJlbnQucmVwbGFjZShsZWFkaW5nTGluZWJyZWFrLCBcIlwiKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBpdGVtcztcbiAgfTtcblxuICBmdW5jdGlvbiBpc1N0cmluZyhpdGVtKSB7XG4gIFx0cmV0dXJuIHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDb21tZW50KGl0ZW0pIHtcbiAgXHRyZXR1cm4gaXRlbS50ID09PSBDT01NRU5UIHx8IGl0ZW0udCA9PT0gREVMSU1DSEFOR0U7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NlY3Rpb24oaXRlbSkge1xuICBcdHJldHVybiAoaXRlbS50ID09PSBTRUNUSU9OIHx8IGl0ZW0udCA9PT0gSU5WRVJURUQpICYmIGl0ZW0uZjtcbiAgfVxuXG4gIHZhciB0cmltV2hpdGVzcGFjZV9fbGVhZGluZ1doaXRlc3BhY2UgPSAvXlsgXFx0XFxmXFxyXFxuXSsvLFxuICAgICAgdHJpbVdoaXRlc3BhY2VfX3RyYWlsaW5nV2hpdGVzcGFjZSA9IC9bIFxcdFxcZlxcclxcbl0rJC87XG5cbiAgdmFyIHRyaW1XaGl0ZXNwYWNlID0gZnVuY3Rpb24gKGl0ZW1zLCBsZWFkaW5nLCB0cmFpbGluZykge1xuICBcdHZhciBpdGVtO1xuXG4gIFx0aWYgKGxlYWRpbmcpIHtcbiAgXHRcdGl0ZW0gPSBpdGVtc1swXTtcbiAgXHRcdGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRpdGVtID0gaXRlbS5yZXBsYWNlKHRyaW1XaGl0ZXNwYWNlX19sZWFkaW5nV2hpdGVzcGFjZSwgXCJcIik7XG5cbiAgXHRcdFx0aWYgKCFpdGVtKSB7XG4gIFx0XHRcdFx0aXRlbXMuc2hpZnQoKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRpdGVtc1swXSA9IGl0ZW07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAodHJhaWxpbmcpIHtcbiAgXHRcdGl0ZW0gPSBsYXN0SXRlbShpdGVtcyk7XG4gIFx0XHRpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0aXRlbSA9IGl0ZW0ucmVwbGFjZSh0cmltV2hpdGVzcGFjZV9fdHJhaWxpbmdXaGl0ZXNwYWNlLCBcIlwiKTtcblxuICBcdFx0XHRpZiAoIWl0ZW0pIHtcbiAgXHRcdFx0XHRpdGVtcy5wb3AoKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSA9IGl0ZW07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIHV0aWxzX2NsZWFudXAgPSBjbGVhbnVwO1xuICB2YXIgY29udGlndW91c1doaXRlc3BhY2UgPSAvWyBcXHRcXGZcXHJcXG5dKy9nO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudHMgPSAvXig/OnByZXxzY3JpcHR8c3R5bGV8dGV4dGFyZWEpJC9pO1xuICB2YXIgdXRpbHNfY2xlYW51cF9fbGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccysvO1xuICB2YXIgdXRpbHNfY2xlYW51cF9fdHJhaWxpbmdXaGl0ZXNwYWNlID0gL1xccyskLztcbiAgZnVuY3Rpb24gY2xlYW51cChpdGVtcywgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZSwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlKSB7XG4gIFx0dmFyIGksIGl0ZW0sIHByZXZpb3VzSXRlbSwgbmV4dEl0ZW0sIHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwga2V5O1xuXG4gIFx0Ly8gRmlyc3QgcGFzcyAtIHJlbW92ZSBzdGFuZGFsb25lcyBhbmQgY29tbWVudHMgZXRjXG4gIFx0c3RyaXBTdGFuZGFsb25lcyhpdGVtcyk7XG5cbiAgXHRpID0gaXRlbXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGl0ZW0gPSBpdGVtc1tpXTtcblxuICBcdFx0Ly8gUmVtb3ZlIGRlbGltaXRlciBjaGFuZ2VzLCB1bnNhZmUgZWxlbWVudHMgZXRjXG4gIFx0XHRpZiAoaXRlbS5leGNsdWRlKSB7XG4gIFx0XHRcdGl0ZW1zLnNwbGljZShpLCAxKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gUmVtb3ZlIGNvbW1lbnRzLCB1bmxlc3Mgd2Ugd2FudCB0byBrZWVwIHRoZW1cbiAgXHRcdGVsc2UgaWYgKHN0cmlwQ29tbWVudHMgJiYgaXRlbS50ID09PSBDT01NRU5UKSB7XG4gIFx0XHRcdGl0ZW1zLnNwbGljZShpLCAxKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBJZiBuZWNlc3NhcnksIHJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gIFx0dHJpbVdoaXRlc3BhY2UoaXRlbXMsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlLCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2UpO1xuXG4gIFx0aSA9IGl0ZW1zLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpdGVtID0gaXRlbXNbaV07XG5cbiAgXHRcdC8vIFJlY3Vyc2VcbiAgXHRcdGlmIChpdGVtLmYpIHtcbiAgXHRcdFx0cHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgfHwgaXRlbS50ID09PSBFTEVNRU5UICYmIHByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnRzLnRlc3QoaXRlbS5lKTtcblxuICBcdFx0XHRpZiAoIXByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KSB7XG4gIFx0XHRcdFx0cHJldmlvdXNJdGVtID0gaXRlbXNbaSAtIDFdO1xuICBcdFx0XHRcdG5leHRJdGVtID0gaXRlbXNbaSArIDFdO1xuXG4gIFx0XHRcdFx0Ly8gaWYgdGhlIHByZXZpb3VzIGl0ZW0gd2FzIGEgdGV4dCBpdGVtIHdpdGggdHJhaWxpbmcgd2hpdGVzcGFjZSxcbiAgXHRcdFx0XHQvLyByZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlIGluc2lkZSB0aGUgZnJhZ21lbnRcbiAgXHRcdFx0XHRpZiAoIXByZXZpb3VzSXRlbSB8fCB0eXBlb2YgcHJldmlvdXNJdGVtID09PSBcInN0cmluZ1wiICYmIHV0aWxzX2NsZWFudXBfX3RyYWlsaW5nV2hpdGVzcGFjZS50ZXN0KHByZXZpb3VzSXRlbSkpIHtcbiAgXHRcdFx0XHRcdHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSB0cnVlO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIGFuZCB2aWNlIHZlcnNhXG4gIFx0XHRcdFx0aWYgKCFuZXh0SXRlbSB8fCB0eXBlb2YgbmV4dEl0ZW0gPT09IFwic3RyaW5nXCIgJiYgdXRpbHNfY2xlYW51cF9fbGVhZGluZ1doaXRlc3BhY2UudGVzdChuZXh0SXRlbSkpIHtcbiAgXHRcdFx0XHRcdHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjbGVhbnVwKGl0ZW0uZiwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gU3BsaXQgaWYtZWxzZSBibG9ja3MgaW50byB0d28gKGFuIGlmLCBhbmQgYW4gdW5sZXNzKVxuICBcdFx0aWYgKGl0ZW0ubCkge1xuICBcdFx0XHRjbGVhbnVwKGl0ZW0ubC5mLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcblxuICBcdFx0XHRpdGVtcy5zcGxpY2UoaSArIDEsIDAsIGl0ZW0ubCk7XG4gIFx0XHRcdGRlbGV0ZSBpdGVtLmw7IC8vIFRPRE8gd291bGQgYmUgbmljZSBpZiB0aGVyZSB3YXMgYSB3YXkgYXJvdW5kIHRoaXNcbiAgXHRcdH1cblxuICBcdFx0Ly8gQ2xlYW4gdXAgZWxlbWVudCBhdHRyaWJ1dGVzXG4gIFx0XHRpZiAoaXRlbS5hKSB7XG4gIFx0XHRcdGZvciAoa2V5IGluIGl0ZW0uYSkge1xuICBcdFx0XHRcdGlmIChpdGVtLmEuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0eXBlb2YgaXRlbS5hW2tleV0gIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHRcdGNsZWFudXAoaXRlbS5hW2tleV0sIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBDbGVhbiB1cCBjb25kaXRpb25hbCBhdHRyaWJ1dGVzXG4gIFx0XHRpZiAoaXRlbS5tKSB7XG4gIFx0XHRcdGNsZWFudXAoaXRlbS5tLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gQ2xlYW4gdXAgZXZlbnQgaGFuZGxlcnNcbiAgXHRcdGlmIChpdGVtLnYpIHtcbiAgXHRcdFx0Zm9yIChrZXkgaW4gaXRlbS52KSB7XG4gIFx0XHRcdFx0aWYgKGl0ZW0udi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdFx0XHQvLyBjbGVhbiB1cCBuYW1lc1xuICBcdFx0XHRcdFx0aWYgKGlzQXJyYXkoaXRlbS52W2tleV0ubikpIHtcbiAgXHRcdFx0XHRcdFx0Y2xlYW51cChpdGVtLnZba2V5XS5uLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0Ly8gY2xlYW4gdXAgcGFyYW1zXG4gIFx0XHRcdFx0XHRpZiAoaXNBcnJheShpdGVtLnZba2V5XS5kKSkge1xuICBcdFx0XHRcdFx0XHRjbGVhbnVwKGl0ZW0udltrZXldLmQsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIGZpbmFsIHBhc3MgLSBmdXNlIHRleHQgbm9kZXMgdG9nZXRoZXJcbiAgXHRpID0gaXRlbXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmICh0eXBlb2YgaXRlbXNbaV0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0aWYgKHR5cGVvZiBpdGVtc1tpICsgMV0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHRpdGVtc1tpXSA9IGl0ZW1zW2ldICsgaXRlbXNbaSArIDFdO1xuICBcdFx0XHRcdGl0ZW1zLnNwbGljZShpICsgMSwgMSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXByZXNlcnZlV2hpdGVzcGFjZSkge1xuICBcdFx0XHRcdGl0ZW1zW2ldID0gaXRlbXNbaV0ucmVwbGFjZShjb250aWd1b3VzV2hpdGVzcGFjZSwgXCIgXCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGl0ZW1zW2ldID09PSBcIlwiKSB7XG4gIFx0XHRcdFx0aXRlbXMuc3BsaWNlKGksIDEpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIGVsZW1lbnRfcmVhZENsb3NpbmdUYWcgPSByZWFkQ2xvc2luZ1RhZztcbiAgdmFyIGNsb3NpbmdUYWdQYXR0ZXJuID0gL14oW2EtekEtWl17MSx9Oj9bYS16QS1aMC05XFwtXSopXFxzKlxcPi87XG4gIGZ1bmN0aW9uIHJlYWRDbG9zaW5nVGFnKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgdGFnO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gYXJlIHdlIGxvb2tpbmcgYXQgYSBjbG9zaW5nIHRhZz9cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIjwvXCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAodGFnID0gcGFyc2VyLm1hdGNoUGF0dGVybihjbG9zaW5nVGFnUGF0dGVybikpIHtcbiAgXHRcdGlmIChwYXJzZXIuaW5zaWRlICYmIHRhZyAhPT0gcGFyc2VyLmluc2lkZSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBDTE9TSU5HX1RBRyxcbiAgXHRcdFx0ZTogdGFnXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdC8vIFdlIGhhdmUgYW4gaWxsZWdhbCBjbG9zaW5nIHRhZywgcmVwb3J0IGl0XG4gIFx0cGFyc2VyLnBvcyAtPSAyO1xuICBcdHBhcnNlci5lcnJvcihcIklsbGVnYWwgY2xvc2luZyB0YWdcIik7XG4gIH1cblxuICB2YXIgZ2V0TG93ZXN0SW5kZXggPSBmdW5jdGlvbiAoaGF5c3RhY2ssIG5lZWRsZXMpIHtcbiAgXHR2YXIgaSwgaW5kZXgsIGxvd2VzdDtcblxuICBcdGkgPSBuZWVkbGVzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpbmRleCA9IGhheXN0YWNrLmluZGV4T2YobmVlZGxlc1tpXSk7XG5cbiAgXHRcdC8vIHNob3J0IGNpcmN1aXRcbiAgXHRcdGlmICghaW5kZXgpIHtcbiAgXHRcdFx0cmV0dXJuIDA7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghbG93ZXN0IHx8IGluZGV4IDwgbG93ZXN0KSB7XG4gIFx0XHRcdGxvd2VzdCA9IGluZGV4O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBsb3dlc3QgfHwgLTE7XG4gIH07XG5cbiAgdmFyIGVsZW1lbnRfcmVhZEF0dHJpYnV0ZSA9IHJlYWRBdHRyaWJ1dGU7XG5cbiAgdmFyIGF0dHJpYnV0ZU5hbWVQYXR0ZXJuID0gL15bXlxcc1wiJz5cXC89XSsvLFxuICAgICAgdW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRleHRQYXR0ZXJuID0gL15bXlxcc1wiJz08PmBdKy87XG4gIGZ1bmN0aW9uIHJlYWRBdHRyaWJ1dGUocGFyc2VyKSB7XG4gIFx0dmFyIGF0dHIsIG5hbWUsIHZhbHVlO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0bmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oYXR0cmlidXRlTmFtZVBhdHRlcm4pO1xuICBcdGlmICghbmFtZSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0YXR0ciA9IHsgbmFtZTogbmFtZSB9O1xuXG4gIFx0dmFsdWUgPSByZWFkQXR0cmlidXRlVmFsdWUocGFyc2VyKTtcbiAgXHRpZiAodmFsdWUgIT0gbnVsbCkge1xuICBcdFx0Ly8gbm90IG51bGwvdW5kZWZpbmVkXG4gIFx0XHRhdHRyLnZhbHVlID0gdmFsdWU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGF0dHI7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXR0cmlidXRlVmFsdWUocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCB2YWx1ZVN0YXJ0LCBzdGFydERlcHRoLCB2YWx1ZTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIG5leHQgY2hhcmFjdGVyIG11c3QgYmUgYD1gLCBgL2AsIGA+YCBvciB3aGl0ZXNwYWNlXG4gIFx0aWYgKCEvWz1cXC8+XFxzXS8udGVzdChwYXJzZXIubmV4dENoYXIoKSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGA9YCwgYC9gLCBgPmAgb3Igd2hpdGVzcGFjZVwiKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj1cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdHZhbHVlU3RhcnQgPSBwYXJzZXIucG9zO1xuICBcdHN0YXJ0RGVwdGggPSBwYXJzZXIuc2VjdGlvbkRlcHRoO1xuXG4gIFx0dmFsdWUgPSByZWFkUXVvdGVkQXR0cmlidXRlVmFsdWUocGFyc2VyLCBcIidcIikgfHwgcmVhZFF1b3RlZEF0dHJpYnV0ZVZhbHVlKHBhcnNlciwgXCJcXFwiXCIpIHx8IHJlYWRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKHBhcnNlcik7XG5cbiAgXHRpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIHZhbGlkIGF0dHJpYnV0ZSB2YWx1ZVwiKTtcbiAgXHR9XG5cbiAgXHRpZiAocGFyc2VyLnNlY3Rpb25EZXB0aCAhPT0gc3RhcnREZXB0aCkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHZhbHVlU3RhcnQ7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJBbiBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBjb250YWluIGFzIG1hbnkgb3BlbmluZyBzZWN0aW9uIHRhZ3MgYXMgY2xvc2luZyBzZWN0aW9uIHRhZ3NcIik7XG4gIFx0fVxuXG4gIFx0aWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgXHRcdHJldHVybiBcIlwiO1xuICBcdH1cblxuICBcdGlmICh2YWx1ZS5sZW5ndGggPT09IDEgJiYgdHlwZW9mIHZhbHVlWzBdID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRyZXR1cm4gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyh2YWx1ZVswXSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbihwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIHRleHQsIGhheXN0YWNrLCBuZWVkbGVzLCBpbmRleDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdHRleHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHVucXVvdGVkQXR0cmlidXRlVmFsdWVUZXh0UGF0dGVybik7XG5cbiAgXHRpZiAoIXRleHQpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGhheXN0YWNrID0gdGV4dDtcbiAgXHRuZWVkbGVzID0gcGFyc2VyLnRhZ3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRyZXR1cm4gdC5vcGVuO1xuICBcdH0pOyAvLyBUT0RPIHJlZmFjdG9yLi4uIHdlIGRvIHRoaXMgaW4gcmVhZFRleHQuanMgYXMgd2VsbFxuXG4gIFx0aWYgKChpbmRleCA9IGdldExvd2VzdEluZGV4KGhheXN0YWNrLCBuZWVkbGVzKSkgIT09IC0xKSB7XG4gIFx0XHR0ZXh0ID0gdGV4dC5zdWJzdHIoMCwgaW5kZXgpO1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0ICsgdGV4dC5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIpIHtcbiAgXHR2YXIgdG9rZW5zLCB0b2tlbjtcblxuICBcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IHRydWU7XG5cbiAgXHR0b2tlbnMgPSBbXTtcblxuICBcdHRva2VuID0gY29udmVydGVyc19yZWFkTXVzdGFjaGUocGFyc2VyKSB8fCByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKHBhcnNlcik7XG4gIFx0d2hpbGUgKHRva2VuICE9PSBudWxsKSB7XG4gIFx0XHR0b2tlbnMucHVzaCh0b2tlbik7XG4gIFx0XHR0b2tlbiA9IGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlKHBhcnNlcikgfHwgcmVhZFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbihwYXJzZXIpO1xuICBcdH1cblxuICBcdGlmICghdG9rZW5zLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmluQXR0cmlidXRlID0gZmFsc2U7XG4gIFx0cmV0dXJuIHRva2VucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRRdW90ZWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIsIHF1b3RlTWFyaykge1xuICBcdHZhciBzdGFydCwgdG9rZW5zLCB0b2tlbjtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHF1b3RlTWFyaykpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IHF1b3RlTWFyaztcblxuICBcdHRva2VucyA9IFtdO1xuXG4gIFx0dG9rZW4gPSBjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZShwYXJzZXIpIHx8IHJlYWRRdW90ZWRTdHJpbmdUb2tlbihwYXJzZXIsIHF1b3RlTWFyayk7XG4gIFx0d2hpbGUgKHRva2VuICE9PSBudWxsKSB7XG4gIFx0XHR0b2tlbnMucHVzaCh0b2tlbik7XG4gIFx0XHR0b2tlbiA9IGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlKHBhcnNlcikgfHwgcmVhZFF1b3RlZFN0cmluZ1Rva2VuKHBhcnNlciwgcXVvdGVNYXJrKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhxdW90ZU1hcmspKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSBmYWxzZTtcblxuICBcdHJldHVybiB0b2tlbnM7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkUXVvdGVkU3RyaW5nVG9rZW4ocGFyc2VyLCBxdW90ZU1hcmspIHtcbiAgXHR2YXIgc3RhcnQsIGluZGV4LCBoYXlzdGFjaywgbmVlZGxlcztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRoYXlzdGFjayA9IHBhcnNlci5yZW1haW5pbmcoKTtcblxuICBcdG5lZWRsZXMgPSBwYXJzZXIudGFncy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgXHRcdHJldHVybiB0Lm9wZW47XG4gIFx0fSk7IC8vIFRPRE8gcmVmYWN0b3IuLi4gd2UgZG8gdGhpcyBpbiByZWFkVGV4dC5qcyBhcyB3ZWxsXG4gIFx0bmVlZGxlcy5wdXNoKHF1b3RlTWFyayk7XG5cbiAgXHRpbmRleCA9IGdldExvd2VzdEluZGV4KGhheXN0YWNrLCBuZWVkbGVzKTtcblxuICBcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIlF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBoYXZlIGEgY2xvc2luZyBxdW90ZVwiKTtcbiAgXHR9XG5cbiAgXHRpZiAoIWluZGV4KSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIucG9zICs9IGluZGV4O1xuICBcdHJldHVybiBoYXlzdGFjay5zdWJzdHIoMCwgaW5kZXgpO1xuICB9XG5cbiAgdmFyIEpzb25QYXJzZXIsIHNwZWNpYWxzLCBzcGVjaWFsc1BhdHRlcm4sIHBhcnNlSlNPTl9fbnVtYmVyUGF0dGVybiwgcGxhY2Vob2xkZXJQYXR0ZXJuLCBwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuLCBvbmx5V2hpdGVzcGFjZTtcblxuICBzcGVjaWFscyA9IHtcbiAgXHRcInRydWVcIjogdHJ1ZSxcbiAgXHRcImZhbHNlXCI6IGZhbHNlLFxuICBcdHVuZGVmaW5lZDogdW5kZWZpbmVkLFxuICBcdFwibnVsbFwiOiBudWxsXG4gIH07XG5cbiAgc3BlY2lhbHNQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIE9iamVjdC5rZXlzKHNwZWNpYWxzKS5qb2luKFwifFwiKSArIFwiKVwiKTtcbiAgcGFyc2VKU09OX19udW1iZXJQYXR0ZXJuID0gL14oPzpbKy1dPykoPzooPzooPzowfFsxLTldXFxkKik/XFwuXFxkKyl8KD86KD86MHxbMS05XVxcZCopXFwuKXwoPzowfFsxLTldXFxkKikpKD86W2VFXVsrLV0/XFxkKyk/LztcbiAgcGxhY2Vob2xkZXJQYXR0ZXJuID0gL1xcJFxceyhbXlxcfV0rKVxcfS9nO1xuICBwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuID0gL15cXCRcXHsoW15cXH1dKylcXH0vO1xuICBvbmx5V2hpdGVzcGFjZSA9IC9eXFxzKiQvO1xuXG4gIEpzb25QYXJzZXIgPSBwYXJzZV9QYXJzZXIuZXh0ZW5kKHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gIFx0XHR0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICBcdFx0dGhpcy5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHR9LFxuXG4gIFx0cG9zdFByb2Nlc3M6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgXHRcdGlmIChyZXN1bHQubGVuZ3RoICE9PSAxIHx8ICFvbmx5V2hpdGVzcGFjZS50ZXN0KHRoaXMubGVmdG92ZXIpKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4geyB2YWx1ZTogcmVzdWx0WzBdLnYgfTtcbiAgXHR9LFxuXG4gIFx0Y29udmVydGVyczogW2Z1bmN0aW9uIGdldFBsYWNlaG9sZGVyKHBhcnNlcikge1xuICBcdFx0dmFyIHBsYWNlaG9sZGVyO1xuXG4gIFx0XHRpZiAoIXBhcnNlci52YWx1ZXMpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHBsYWNlaG9sZGVyID0gcGFyc2VyLm1hdGNoUGF0dGVybihwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuKTtcblxuICBcdFx0aWYgKHBsYWNlaG9sZGVyICYmIHBhcnNlci52YWx1ZXMuaGFzT3duUHJvcGVydHkocGxhY2Vob2xkZXIpKSB7XG4gIFx0XHRcdHJldHVybiB7IHY6IHBhcnNlci52YWx1ZXNbcGxhY2Vob2xkZXJdIH07XG4gIFx0XHR9XG4gIFx0fSwgZnVuY3Rpb24gZ2V0U3BlY2lhbChwYXJzZXIpIHtcbiAgXHRcdHZhciBzcGVjaWFsO1xuXG4gIFx0XHRpZiAoc3BlY2lhbCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oc3BlY2lhbHNQYXR0ZXJuKSkge1xuICBcdFx0XHRyZXR1cm4geyB2OiBzcGVjaWFsc1tzcGVjaWFsXSB9O1xuICBcdFx0fVxuICBcdH0sIGZ1bmN0aW9uIGdldE51bWJlcihwYXJzZXIpIHtcbiAgXHRcdHZhciBudW1iZXI7XG5cbiAgXHRcdGlmIChudW1iZXIgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHBhcnNlSlNPTl9fbnVtYmVyUGF0dGVybikpIHtcbiAgXHRcdFx0cmV0dXJuIHsgdjogK251bWJlciB9O1xuICBcdFx0fVxuICBcdH0sIGZ1bmN0aW9uIGdldFN0cmluZyhwYXJzZXIpIHtcbiAgXHRcdHZhciBzdHJpbmdMaXRlcmFsID0gcmVhZFN0cmluZ0xpdGVyYWwocGFyc2VyKSxcbiAgXHRcdCAgICB2YWx1ZXM7XG5cbiAgXHRcdGlmIChzdHJpbmdMaXRlcmFsICYmICh2YWx1ZXMgPSBwYXJzZXIudmFsdWVzKSkge1xuICBcdFx0XHRyZXR1cm4ge1xuICBcdFx0XHRcdHY6IHN0cmluZ0xpdGVyYWwudi5yZXBsYWNlKHBsYWNlaG9sZGVyUGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoLCAkMSkge1xuICBcdFx0XHRcdFx0cmV0dXJuICQxIGluIHZhbHVlcyA/IHZhbHVlc1skMV0gOiAkMTtcbiAgXHRcdFx0XHR9KVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gc3RyaW5nTGl0ZXJhbDtcbiAgXHR9LCBmdW5jdGlvbiBnZXRPYmplY3QocGFyc2VyKSB7XG4gIFx0XHR2YXIgcmVzdWx0LCBwYWlyO1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIntcIikpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJlc3VsdCA9IHt9O1xuXG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJ9XCIpKSB7XG4gIFx0XHRcdHJldHVybiB7IHY6IHJlc3VsdCB9O1xuICBcdFx0fVxuXG4gIFx0XHR3aGlsZSAocGFpciA9IGdldEtleVZhbHVlUGFpcihwYXJzZXIpKSB7XG4gIFx0XHRcdHJlc3VsdFtwYWlyLmtleV0gPSBwYWlyLnZhbHVlO1xuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwifVwiKSkge1xuICBcdFx0XHRcdHJldHVybiB7IHY6IHJlc3VsdCB9O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIsXCIpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fSwgZnVuY3Rpb24gZ2V0QXJyYXkocGFyc2VyKSB7XG4gIFx0XHR2YXIgcmVzdWx0LCB2YWx1ZVRva2VuO1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIltcIikpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJlc3VsdCA9IFtdO1xuXG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJdXCIpKSB7XG4gIFx0XHRcdHJldHVybiB7IHY6IHJlc3VsdCB9O1xuICBcdFx0fVxuXG4gIFx0XHR3aGlsZSAodmFsdWVUb2tlbiA9IHBhcnNlci5yZWFkKCkpIHtcbiAgXHRcdFx0cmVzdWx0LnB1c2godmFsdWVUb2tlbi52KTtcblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIl1cIikpIHtcbiAgXHRcdFx0XHRyZXR1cm4geyB2OiByZXN1bHQgfTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiLFwiKSkge1xuICBcdFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XVxuICB9KTtcblxuICBmdW5jdGlvbiBnZXRLZXlWYWx1ZVBhaXIocGFyc2VyKSB7XG4gIFx0dmFyIGtleSwgdmFsdWVUb2tlbiwgcGFpcjtcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGtleSA9IHNoYXJlZF9yZWFkS2V5KHBhcnNlcik7XG5cbiAgXHRpZiAoIWtleSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFpciA9IHsga2V5OiBrZXkgfTtcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIjpcIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHR2YWx1ZVRva2VuID0gcGFyc2VyLnJlYWQoKTtcbiAgXHRpZiAoIXZhbHVlVG9rZW4pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhaXIudmFsdWUgPSB2YWx1ZVRva2VuLnY7XG5cbiAgXHRyZXR1cm4gcGFpcjtcbiAgfVxuXG4gIHZhciBwYXJzZUpTT04gPSBmdW5jdGlvbiAoc3RyLCB2YWx1ZXMpIHtcbiAgXHR2YXIgcGFyc2VyID0gbmV3IEpzb25QYXJzZXIoc3RyLCB7XG4gIFx0XHR2YWx1ZXM6IHZhbHVlc1xuICBcdH0pO1xuXG4gIFx0cmV0dXJuIHBhcnNlci5yZXN1bHQ7XG4gIH07XG5cbiAgLy8gVE9ETyBjbGVhbiB0aGlzIHVwLCBpdCdzIHNob2NraW5nXG4gIHZhciBlbGVtZW50X3Byb2Nlc3NEaXJlY3RpdmUgPSBwcm9jZXNzRGlyZWN0aXZlO1xuICB2YXIgbWV0aG9kQ2FsbFBhdHRlcm4gPSAvXihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopXFwoLyxcbiAgICAgIG1ldGhvZENhbGxFeGNlc3NQYXR0ZXJuID0gL1xcKVxccyokLyxcbiAgICAgIEV4cHJlc3Npb25QYXJzZXI7XG5cbiAgRXhwcmVzc2lvblBhcnNlciA9IHBhcnNlX1BhcnNlci5leHRlbmQoe1xuICBcdGNvbnZlcnRlcnM6IFtjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uXVxuICB9KTtcbiAgZnVuY3Rpb24gcHJvY2Vzc0RpcmVjdGl2ZSh0b2tlbnMsIHBhcmVudFBhcnNlcikge1xuICBcdHZhciByZXN1bHQsIG1hdGNoLCBwYXJzZXIsIGFyZ3MsIHRva2VuLCBjb2xvbkluZGV4LCBkaXJlY3RpdmVOYW1lLCBkaXJlY3RpdmVBcmdzLCBwYXJzZWQ7XG5cbiAgXHRpZiAodHlwZW9mIHRva2VucyA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0aWYgKG1hdGNoID0gbWV0aG9kQ2FsbFBhdHRlcm4uZXhlYyh0b2tlbnMpKSB7XG4gIFx0XHRcdHZhciBlbmQgPSB0b2tlbnMubGFzdEluZGV4T2YoXCIpXCIpO1xuXG4gIFx0XHRcdC8vIGNoZWNrIGZvciBpbnZhbGlkIG1ldGhvZCBjYWxsc1xuICBcdFx0XHRpZiAoIW1ldGhvZENhbGxFeGNlc3NQYXR0ZXJuLnRlc3QodG9rZW5zKSkge1xuICBcdFx0XHRcdHBhcmVudFBhcnNlci5lcnJvcihcIkludmFsaWQgaW5wdXQgYWZ0ZXIgbWV0aG9kIGNhbGwgZXhwcmVzc2lvbiAnXCIgKyB0b2tlbnMuc2xpY2UoZW5kICsgMSkgKyBcIidcIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXN1bHQgPSB7IG06IG1hdGNoWzFdIH07XG4gIFx0XHRcdGFyZ3MgPSBcIltcIiArIHRva2Vucy5zbGljZShyZXN1bHQubS5sZW5ndGggKyAxLCBlbmQpICsgXCJdXCI7XG5cbiAgXHRcdFx0cGFyc2VyID0gbmV3IEV4cHJlc3Npb25QYXJzZXIoYXJncyk7XG4gIFx0XHRcdHJlc3VsdC5hID0gdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24ocGFyc2VyLnJlc3VsdFswXSk7XG5cbiAgXHRcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRva2Vucy5pbmRleE9mKFwiOlwiKSA9PT0gLTEpIHtcbiAgXHRcdFx0cmV0dXJuIHRva2Vucy50cmltKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRva2VucyA9IFt0b2tlbnNdO1xuICBcdH1cblxuICBcdHJlc3VsdCA9IHt9O1xuXG4gIFx0ZGlyZWN0aXZlTmFtZSA9IFtdO1xuICBcdGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblxuICBcdGlmICh0b2tlbnMpIHtcbiAgXHRcdHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gIFx0XHRcdHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRcdGNvbG9uSW5kZXggPSB0b2tlbi5pbmRleE9mKFwiOlwiKTtcblxuICBcdFx0XHRcdGlmIChjb2xvbkluZGV4ID09PSAtMSkge1xuICBcdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKHRva2VuKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gIFx0XHRcdFx0XHQvLyBpcyB0aGUgY29sb24gdGhlIGZpcnN0IGNoYXJhY3Rlcj9cbiAgXHRcdFx0XHRcdGlmIChjb2xvbkluZGV4KSB7XG4gIFx0XHRcdFx0XHRcdC8vIG5vXG4gIFx0XHRcdFx0XHRcdGRpcmVjdGl2ZU5hbWUucHVzaCh0b2tlbi5zdWJzdHIoMCwgY29sb25JbmRleCkpO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBhbnl0aGluZyBhZnRlciB0aGUgY29sb24gaW4gdGhpcyB0b2tlbiwgdHJlYXRcbiAgXHRcdFx0XHRcdC8vIGl0IGFzIHRoZSBmaXJzdCB0b2tlbiBvZiB0aGUgZGlyZWN0aXZlQXJncyBmcmFnbWVudFxuICBcdFx0XHRcdFx0aWYgKHRva2VuLmxlbmd0aCA+IGNvbG9uSW5kZXggKyAxKSB7XG4gIFx0XHRcdFx0XHRcdGRpcmVjdGl2ZUFyZ3NbMF0gPSB0b2tlbi5zdWJzdHJpbmcoY29sb25JbmRleCArIDEpO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRicmVhaztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKHRva2VuKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRkaXJlY3RpdmVBcmdzID0gZGlyZWN0aXZlQXJncy5jb25jYXQodG9rZW5zKTtcbiAgXHR9XG5cbiAgXHRpZiAoIWRpcmVjdGl2ZU5hbWUubGVuZ3RoKSB7XG4gIFx0XHRyZXN1bHQgPSBcIlwiO1xuICBcdH0gZWxzZSBpZiAoZGlyZWN0aXZlQXJncy5sZW5ndGggfHwgdHlwZW9mIGRpcmVjdGl2ZU5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHJlc3VsdCA9IHtcbiAgXHRcdFx0Ly8gVE9ETyBpcyB0aGlzIHJlYWxseSBuZWNlc3Nhcnk/IGp1c3QgdXNlIHRoZSBhcnJheVxuICBcdFx0XHRuOiBkaXJlY3RpdmVOYW1lLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGlyZWN0aXZlTmFtZVswXSA9PT0gXCJzdHJpbmdcIiA/IGRpcmVjdGl2ZU5hbWVbMF0gOiBkaXJlY3RpdmVOYW1lXG4gIFx0XHR9O1xuXG4gIFx0XHRpZiAoZGlyZWN0aXZlQXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRpcmVjdGl2ZUFyZ3NbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKFwiW1wiICsgZGlyZWN0aXZlQXJnc1swXSArIFwiXVwiKTtcbiAgXHRcdFx0cmVzdWx0LmEgPSBwYXJzZWQgPyBwYXJzZWQudmFsdWUgOiBkaXJlY3RpdmVBcmdzWzBdLnRyaW0oKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJlc3VsdC5kID0gZGlyZWN0aXZlQXJncztcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0cmVzdWx0ID0gZGlyZWN0aXZlTmFtZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIHRhZ05hbWVQYXR0ZXJuID0gL15bYS16QS1aXXsxLH06P1thLXpBLVowLTlcXC1dKi8sXG4gICAgICB2YWxpZFRhZ05hbWVGb2xsb3dlciA9IC9eW1xcc1xcblxcLz5dLyxcbiAgICAgIG9uUGF0dGVybiA9IC9eb24vLFxuICAgICAgcHJveHlFdmVudFBhdHRlcm4gPSAvXm9uLShbYS16QS1aXFxcXCpcXFxcLiRfXVthLXpBLVpcXFxcKlxcXFwuJF8wLTlcXC1dKykkLyxcbiAgICAgIHJlc2VydmVkRXZlbnROYW1lcyA9IC9eKD86Y2hhbmdlfHJlc2V0fHRlYXJkb3dufHVwZGF0ZXxjb25zdHJ1Y3R8Y29uZmlnfGluaXR8cmVuZGVyfHVucmVuZGVyfGRldGFjaHxpbnNlcnQpJC8sXG4gICAgICBkaXJlY3RpdmVzID0geyBcImludHJvLW91dHJvXCI6IFwidDBcIiwgaW50cm86IFwidDFcIiwgb3V0cm86IFwidDJcIiwgZGVjb3JhdG9yOiBcIm9cIiB9LFxuICAgICAgZXhjbHVkZSA9IHsgZXhjbHVkZTogdHJ1ZSB9LFxuICAgICAgZGlzYWxsb3dlZENvbnRlbnRzO1xuXG4gIC8vIGJhc2VkIG9uIGh0dHA6Ly9kZXZlbG9wZXJzLndoYXR3Zy5vcmcvc3ludGF4Lmh0bWwjc3ludGF4LXRhZy1vbWlzc2lvblxuICBkaXNhbGxvd2VkQ29udGVudHMgPSB7XG4gIFx0bGk6IFtcImxpXCJdLFxuICBcdGR0OiBbXCJkdFwiLCBcImRkXCJdLFxuICBcdGRkOiBbXCJkdFwiLCBcImRkXCJdLFxuICBcdHA6IFwiYWRkcmVzcyBhcnRpY2xlIGFzaWRlIGJsb2NrcXVvdGUgZGl2IGRsIGZpZWxkc2V0IGZvb3RlciBmb3JtIGgxIGgyIGgzIGg0IGg1IGg2IGhlYWRlciBoZ3JvdXAgaHIgbWFpbiBtZW51IG5hdiBvbCBwIHByZSBzZWN0aW9uIHRhYmxlIHVsXCIuc3BsaXQoXCIgXCIpLFxuICBcdHJ0OiBbXCJydFwiLCBcInJwXCJdLFxuICBcdHJwOiBbXCJydFwiLCBcInJwXCJdLFxuICBcdG9wdGdyb3VwOiBbXCJvcHRncm91cFwiXSxcbiAgXHRvcHRpb246IFtcIm9wdGlvblwiLCBcIm9wdGdyb3VwXCJdLFxuICBcdHRoZWFkOiBbXCJ0Ym9keVwiLCBcInRmb290XCJdLFxuICBcdHRib2R5OiBbXCJ0Ym9keVwiLCBcInRmb290XCJdLFxuICBcdHRmb290OiBbXCJ0Ym9keVwiXSxcbiAgXHR0cjogW1widHJcIiwgXCJ0Ym9keVwiXSxcbiAgXHR0ZDogW1widGRcIiwgXCJ0aFwiLCBcInRyXCJdLFxuICBcdHRoOiBbXCJ0ZFwiLCBcInRoXCIsIFwidHJcIl1cbiAgfTtcblxuICB2YXIgY29udmVydGVyc19yZWFkRWxlbWVudCA9IHJlYWRFbGVtZW50O1xuXG4gIGZ1bmN0aW9uIHJlYWRFbGVtZW50KHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgZWxlbWVudCwgZGlyZWN0aXZlTmFtZSwgbWF0Y2gsIGFkZFByb3h5RXZlbnQsIGF0dHJpYnV0ZSwgZGlyZWN0aXZlLCBzZWxmQ2xvc2luZywgY2hpbGRyZW4sIHBhcnRpYWxzLCBoYXNQYXJ0aWFscywgY2hpbGQsIGNsb3NlZCwgcG9zLCByZW1haW5pbmcsIGNsb3NpbmdUYWc7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAocGFyc2VyLmluc2lkZSB8fCBwYXJzZXIuaW5BdHRyaWJ1dGUpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPFwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgdGhpcyBpcyBhIGNsb3NpbmcgdGFnLCBhYm9ydCBzdHJhaWdodCBhd2F5XG4gIFx0aWYgKHBhcnNlci5uZXh0Q2hhcigpID09PSBcIi9cIikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0ZWxlbWVudCA9IHt9O1xuICBcdGlmIChwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMpIHtcbiAgXHRcdGVsZW1lbnQucCA9IHBhcnNlci5nZXRMaW5lUG9zKHN0YXJ0KTtcbiAgXHR9XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiIVwiKSkge1xuICBcdFx0ZWxlbWVudC50ID0gRE9DVFlQRTtcbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoUGF0dGVybigvXmRvY3R5cGUvaSkpIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgRE9DVFlQRSBkZWNsYXJhdGlvblwiKTtcbiAgXHRcdH1cblxuICBcdFx0ZWxlbWVudC5hID0gcGFyc2VyLm1hdGNoUGF0dGVybigvXiguKz8pPi8pO1xuICBcdFx0cmV0dXJuIGVsZW1lbnQ7XG4gIFx0fVxuXG4gIFx0ZWxlbWVudC50ID0gRUxFTUVOVDtcblxuICBcdC8vIGVsZW1lbnQgbmFtZVxuICBcdGVsZW1lbnQuZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4odGFnTmFtZVBhdHRlcm4pO1xuICBcdGlmICghZWxlbWVudC5lKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBuZXh0IGNoYXJhY3RlciBtdXN0IGJlIHdoaXRlc3BhY2UsIGNsb3Npbmcgc29saWR1cyBvciAnPidcbiAgXHRpZiAoIXZhbGlkVGFnTmFtZUZvbGxvd2VyLnRlc3QocGFyc2VyLm5leHRDaGFyKCkpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJJbGxlZ2FsIHRhZyBuYW1lXCIpO1xuICBcdH1cblxuICBcdGFkZFByb3h5RXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZGlyZWN0aXZlKSB7XG4gIFx0XHR2YXIgZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZS5uIHx8IGRpcmVjdGl2ZTtcblxuICBcdFx0aWYgKHJlc2VydmVkRXZlbnROYW1lcy50ZXN0KGRpcmVjdGl2ZU5hbWUpKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgLT0gZGlyZWN0aXZlTmFtZS5sZW5ndGg7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkNhbm5vdCB1c2UgcmVzZXJ2ZWQgZXZlbnQgbmFtZXMgKGNoYW5nZSwgcmVzZXQsIHRlYXJkb3duLCB1cGRhdGUsIGNvbnN0cnVjdCwgY29uZmlnLCBpbml0LCByZW5kZXIsIHVucmVuZGVyLCBkZXRhY2gsIGluc2VydClcIik7XG4gIFx0XHR9XG5cbiAgXHRcdGVsZW1lbnQudltuYW1lXSA9IGRpcmVjdGl2ZTtcbiAgXHR9O1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gZGlyZWN0aXZlcyBhbmQgYXR0cmlidXRlc1xuICBcdHdoaWxlIChhdHRyaWJ1dGUgPSBjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZShwYXJzZXIpIHx8IGVsZW1lbnRfcmVhZEF0dHJpYnV0ZShwYXJzZXIpKSB7XG4gIFx0XHQvLyByZWd1bGFyIGF0dHJpYnV0ZXNcbiAgXHRcdGlmIChhdHRyaWJ1dGUubmFtZSkge1xuICBcdFx0XHQvLyBpbnRybywgb3V0cm8sIGRlY29yYXRvclxuICBcdFx0XHRpZiAoZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZXNbYXR0cmlidXRlLm5hbWVdKSB7XG4gIFx0XHRcdFx0ZWxlbWVudFtkaXJlY3RpdmVOYW1lXSA9IGVsZW1lbnRfcHJvY2Vzc0RpcmVjdGl2ZShhdHRyaWJ1dGUudmFsdWUsIHBhcnNlcik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBvbi1jbGljayBldGNcbiAgXHRcdFx0ZWxzZSBpZiAobWF0Y2ggPSBwcm94eUV2ZW50UGF0dGVybi5leGVjKGF0dHJpYnV0ZS5uYW1lKSkge1xuICBcdFx0XHRcdGlmICghZWxlbWVudC52KSBlbGVtZW50LnYgPSB7fTtcbiAgXHRcdFx0XHRkaXJlY3RpdmUgPSBlbGVtZW50X3Byb2Nlc3NEaXJlY3RpdmUoYXR0cmlidXRlLnZhbHVlLCBwYXJzZXIpO1xuICBcdFx0XHRcdGFkZFByb3h5RXZlbnQobWF0Y2hbMV0sIGRpcmVjdGl2ZSk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0aWYgKCFwYXJzZXIuc2FuaXRpemVFdmVudEF0dHJpYnV0ZXMgfHwgIW9uUGF0dGVybi50ZXN0KGF0dHJpYnV0ZS5uYW1lKSkge1xuICBcdFx0XHRcdFx0aWYgKCFlbGVtZW50LmEpIGVsZW1lbnQuYSA9IHt9O1xuICBcdFx0XHRcdFx0ZWxlbWVudC5hW2F0dHJpYnV0ZS5uYW1lXSA9IGF0dHJpYnV0ZS52YWx1ZSB8fCAoYXR0cmlidXRlLnZhbHVlID09PSBcIlwiID8gXCJcIiA6IDApO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyB7eyNpZiBmb299fWNsYXNzPSdmb28ne3svaWZ9fVxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdGlmICghZWxlbWVudC5tKSBlbGVtZW50Lm0gPSBbXTtcbiAgXHRcdFx0ZWxlbWVudC5tLnB1c2goYXR0cmlidXRlKTtcbiAgXHRcdH1cblxuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdH1cblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3Npbmcgc29saWR1c1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIHNlbGYtY2xvc2luZyBzb2xpZHVzP1xuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIvXCIpKSB7XG4gIFx0XHRzZWxmQ2xvc2luZyA9IHRydWU7XG4gIFx0fVxuXG4gIFx0Ly8gY2xvc2luZyBhbmdsZSBicmFja2V0XG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI+XCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHR2YXIgbG93ZXJDYXNlTmFtZSA9IGVsZW1lbnQuZS50b0xvd2VyQ2FzZSgpO1xuICBcdHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBwYXJzZXIucHJlc2VydmVXaGl0ZXNwYWNlO1xuXG4gIFx0aWYgKCFzZWxmQ2xvc2luZyAmJiAhdm9pZEVsZW1lbnROYW1lcy50ZXN0KGVsZW1lbnQuZSkpIHtcbiAgXHRcdHBhcnNlci5lbGVtZW50U3RhY2sucHVzaChsb3dlckNhc2VOYW1lKTtcblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gaWYgd2Ugb3BlbiBhIHNjcmlwdCBlbGVtZW50LCBmdXJ0aGVyIHRhZ3Mgc2hvdWxkXG4gIFx0XHQvLyBiZSBpZ25vcmVkIHVubGVzcyB0aGV5J3JlIGEgY2xvc2luZyBzY3JpcHQgZWxlbWVudFxuICBcdFx0aWYgKGxvd2VyQ2FzZU5hbWUgPT09IFwic2NyaXB0XCIgfHwgbG93ZXJDYXNlTmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gIFx0XHRcdHBhcnNlci5pbnNpZGUgPSBsb3dlckNhc2VOYW1lO1xuICBcdFx0fVxuXG4gIFx0XHRjaGlsZHJlbiA9IFtdO1xuICBcdFx0cGFydGlhbHMgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHRcdGRvIHtcbiAgXHRcdFx0cG9zID0gcGFyc2VyLnBvcztcbiAgXHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXG4gIFx0XHRcdC8vIGlmIGZvciBleGFtcGxlIHdlJ3JlIGluIGFuIDxsaT4gZWxlbWVudCwgYW5kIHdlIHNlZSBhbm90aGVyXG4gIFx0XHRcdC8vIDxsaT4gdGFnLCBjbG9zZSB0aGUgZmlyc3Qgc28gdGhleSBiZWNvbWUgc2libGluZ3NcbiAgXHRcdFx0aWYgKCFjYW5Db250YWluKGxvd2VyQ2FzZU5hbWUsIHJlbWFpbmluZykpIHtcbiAgXHRcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gY2xvc2luZyB0YWdcbiAgXHRcdFx0ZWxzZSBpZiAoY2xvc2luZ1RhZyA9IGVsZW1lbnRfcmVhZENsb3NpbmdUYWcocGFyc2VyKSkge1xuICBcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG5cbiAgXHRcdFx0XHR2YXIgY2xvc2luZ1RhZ05hbWUgPSBjbG9zaW5nVGFnLmUudG9Mb3dlckNhc2UoKTtcblxuICBcdFx0XHRcdC8vIGlmIHRoaXMgKmlzbid0KiB0aGUgY2xvc2luZyB0YWcgZm9yIHRoZSBjdXJyZW50IGVsZW1lbnQuLi5cbiAgXHRcdFx0XHRpZiAoY2xvc2luZ1RhZ05hbWUgIT09IGxvd2VyQ2FzZU5hbWUpIHtcbiAgXHRcdFx0XHRcdC8vIHJld2luZCBwYXJzZXJcbiAgXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBwb3M7XG5cbiAgXHRcdFx0XHRcdC8vIGlmIGl0IGRvZXNuJ3QgY2xvc2UgYSBwYXJlbnQgdGFnLCBlcnJvclxuICBcdFx0XHRcdFx0aWYgKCEgfnBhcnNlci5lbGVtZW50U3RhY2suaW5kZXhPZihjbG9zaW5nVGFnTmFtZSkpIHtcbiAgXHRcdFx0XHRcdFx0dmFyIGVycm9yTWVzc2FnZSA9IFwiVW5leHBlY3RlZCBjbG9zaW5nIHRhZ1wiO1xuXG4gIFx0XHRcdFx0XHRcdC8vIGFkZCBhZGRpdGlvbmFsIGhlbHAgZm9yIHZvaWQgZWxlbWVudHMsIHNpbmNlIGNvbXBvbmVudCBuYW1lc1xuICBcdFx0XHRcdFx0XHQvLyBtaWdodCBjbGFzaCB3aXRoIHRoZW1cbiAgXHRcdFx0XHRcdFx0aWYgKHZvaWRFbGVtZW50TmFtZXMudGVzdChjbG9zaW5nVGFnTmFtZSkpIHtcbiAgXHRcdFx0XHRcdFx0XHRlcnJvck1lc3NhZ2UgKz0gXCIgKDxcIiArIGNsb3NpbmdUYWdOYW1lICsgXCI+IGlzIGEgdm9pZCBlbGVtZW50IC0gaXQgY2Fubm90IGNvbnRhaW4gY2hpbGRyZW4pXCI7XG4gIFx0XHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBpbXBsaWNpdCBjbG9zZSBieSBjbG9zaW5nIHNlY3Rpb24gdGFnLiBUT0RPIGNsZWFuIHRoaXMgdXBcbiAgXHRcdFx0ZWxzZSBpZiAoY2hpbGQgPSBzZWN0aW9uX3JlYWRDbG9zaW5nKHBhcnNlciwgeyBvcGVuOiBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzBdLCBjbG9zZTogcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSB9KSkge1xuICBcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRpZiAoY2hpbGQgPSBwYXJzZXIucmVhZChQQVJUSUFMX1JFQURFUlMpKSB7XG4gIFx0XHRcdFx0XHRpZiAocGFydGlhbHNbY2hpbGQubl0pIHtcbiAgXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcbiAgXHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRHVwbGljYXRlIHBhcnRpYWwgZGVmaW5pdGlvblwiKTtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0dXRpbHNfY2xlYW51cChjaGlsZC5mLCBwYXJzZXIuc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCAhcHJlc2VydmVXaGl0ZXNwYWNlLCAhcHJlc2VydmVXaGl0ZXNwYWNlKTtcblxuICBcdFx0XHRcdFx0cGFydGlhbHNbY2hpbGQubl0gPSBjaGlsZC5mO1xuICBcdFx0XHRcdFx0aGFzUGFydGlhbHMgPSB0cnVlO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRpZiAoY2hpbGQgPSBwYXJzZXIucmVhZChSRUFERVJTKSkge1xuICBcdFx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgXHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IHdoaWxlICghY2xvc2VkKTtcblxuICBcdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICBcdFx0XHRlbGVtZW50LmYgPSBjaGlsZHJlbjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGhhc1BhcnRpYWxzKSB7XG4gIFx0XHRcdGVsZW1lbnQucCA9IHBhcnRpYWxzO1xuICBcdFx0fVxuXG4gIFx0XHRwYXJzZXIuZWxlbWVudFN0YWNrLnBvcCgpO1xuICBcdH1cblxuICBcdHBhcnNlci5pbnNpZGUgPSBudWxsO1xuXG4gIFx0aWYgKHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzICYmIHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzLmluZGV4T2YobG93ZXJDYXNlTmFtZSkgIT09IC0xKSB7XG4gIFx0XHRyZXR1cm4gZXhjbHVkZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkNvbnRhaW4obmFtZSwgcmVtYWluaW5nKSB7XG4gIFx0dmFyIG1hdGNoLCBkaXNhbGxvd2VkO1xuXG4gIFx0bWF0Y2ggPSAvXjwoW2EtekEtWl1bYS16QS1aMC05XSopLy5leGVjKHJlbWFpbmluZyk7XG4gIFx0ZGlzYWxsb3dlZCA9IGRpc2FsbG93ZWRDb250ZW50c1tuYW1lXTtcblxuICBcdGlmICghbWF0Y2ggfHwgIWRpc2FsbG93ZWQpIHtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cblxuICBcdHJldHVybiAhIH5kaXNhbGxvd2VkLmluZGV4T2YobWF0Y2hbMV0udG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkVGV4dCA9IHJlYWRUZXh0O1xuICBmdW5jdGlvbiByZWFkVGV4dChwYXJzZXIpIHtcbiAgXHR2YXIgaW5kZXgsIHJlbWFpbmluZywgZGlzYWxsb3dlZCwgYmFycmllcjtcblxuICBcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblxuICBcdGJhcnJpZXIgPSBwYXJzZXIuaW5zaWRlID8gXCI8L1wiICsgcGFyc2VyLmluc2lkZSA6IFwiPFwiO1xuXG4gIFx0aWYgKHBhcnNlci5pbnNpZGUgJiYgIXBhcnNlci5pbnRlcnBvbGF0ZVtwYXJzZXIuaW5zaWRlXSkge1xuICBcdFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZihiYXJyaWVyKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0ZGlzYWxsb3dlZCA9IHBhcnNlci50YWdzLm1hcChmdW5jdGlvbiAodCkge1xuICBcdFx0XHRyZXR1cm4gdC5vcGVuO1xuICBcdFx0fSk7XG4gIFx0XHRkaXNhbGxvd2VkID0gZGlzYWxsb3dlZC5jb25jYXQocGFyc2VyLnRhZ3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdHJldHVybiBcIlxcXFxcIiArIHQub3BlbjtcbiAgXHRcdH0pKTtcblxuICBcdFx0Ly8gaHR0cDovL2RldmVsb3BlcnMud2hhdHdnLm9yZy9zeW50YXguaHRtbCNzeW50YXgtYXR0cmlidXRlc1xuICBcdFx0aWYgKHBhcnNlci5pbkF0dHJpYnV0ZSA9PT0gdHJ1ZSkge1xuICBcdFx0XHQvLyB3ZSdyZSBpbnNpZGUgYW4gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlXG4gIFx0XHRcdGRpc2FsbG93ZWQucHVzaChcIlxcXCJcIiwgXCInXCIsIFwiPVwiLCBcIjxcIiwgXCI+XCIsIFwiYFwiKTtcbiAgXHRcdH0gZWxzZSBpZiAocGFyc2VyLmluQXR0cmlidXRlKSB7XG4gIFx0XHRcdC8vIHF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVcbiAgXHRcdFx0ZGlzYWxsb3dlZC5wdXNoKHBhcnNlci5pbkF0dHJpYnV0ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRkaXNhbGxvd2VkLnB1c2goYmFycmllcik7XG4gIFx0XHR9XG5cbiAgXHRcdGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgocmVtYWluaW5nLCBkaXNhbGxvd2VkKTtcbiAgXHR9XG5cbiAgXHRpZiAoIWluZGV4KSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRpbmRleCA9IHJlbWFpbmluZy5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblxuICBcdHJldHVybiBwYXJzZXIuaW5zaWRlID8gcmVtYWluaW5nLnN1YnN0cigwLCBpbmRleCkgOiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKHJlbWFpbmluZy5zdWJzdHIoMCwgaW5kZXgpKTtcbiAgfVxuXG4gIHZhciB1dGlsc19lc2NhcGVSZWdFeHAgPSBlc2NhcGVSZWdFeHA7XG4gIHZhciB1dGlsc19lc2NhcGVSZWdFeHBfX3BhdHRlcm4gPSAvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZztcbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICBcdHJldHVybiBzdHIucmVwbGFjZSh1dGlsc19lc2NhcGVSZWdFeHBfX3BhdHRlcm4sIFwiXFxcXCQmXCIpO1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZFBhcnRpYWxEZWZpbml0aW9uQ29tbWVudCA9IHJlYWRQYXJ0aWFsRGVmaW5pdGlvbkNvbW1lbnQ7XG5cbiAgdmFyIHN0YXJ0UGF0dGVybiA9IC9ePCEtLVxccyovLFxuICAgICAgbmFtZVBhdHRlcm4gPSAvcyo+XFxzKihbYS16QS1aXyRdWy1hLXpBLVpfJDAtOV0qKVxccyovLFxuICAgICAgZmluaXNoUGF0dGVybiA9IC9cXHMqLS0+LyxcbiAgICAgIGNoaWxkO1xuXG4gIGZ1bmN0aW9uIHJlYWRQYXJ0aWFsRGVmaW5pdGlvbkNvbW1lbnQocGFyc2VyKSB7XG4gIFx0dmFyIGZpcnN0UG9zID0gcGFyc2VyLnBvcyxcbiAgXHQgICAgb3BlbiA9IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMF0sXG4gIFx0ICAgIGNsb3NlID0gcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSxcbiAgXHQgICAgY29udGVudCA9IHVuZGVmaW5lZCxcbiAgXHQgICAgY2xvc2VkID0gdW5kZWZpbmVkO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHN0YXJ0UGF0dGVybikgfHwgIXBhcnNlci5tYXRjaFN0cmluZyhvcGVuKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IGZpcnN0UG9zO1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0dmFyIG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKG5hbWVQYXR0ZXJuKTtcblxuICBcdHdhcm5PbmNlSWZEZWJ1ZyhcIklubGluZSBwYXJ0aWFsIGNvbW1lbnRzIGFyZSBkZXByZWNhdGVkLlxcblVzZSB0aGlzLi4uXFxuICB7eyNwYXJ0aWFsIFwiICsgbmFtZSArIFwifX0gLi4uIHt7L3BhcnRpYWx9fVxcblxcbi4uLmluc3RlYWQgb2YgdGhpczpcXG4gIDwhLS0ge3s+XCIgKyBuYW1lICsgXCJ9fSAtLT4gLi4uIDwhLS0ge3svXCIgKyBuYW1lICsgXCJ9fSAtLT4nXCIpO1xuXG4gIFx0Ly8gbWFrZSBzdXJlIHRoZSByZXN0IG9mIHRoZSBjb21tZW50IGlzIGluIHRoZSBjb3JyZWN0IHBsYWNlXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoY2xvc2UpIHx8ICFwYXJzZXIubWF0Y2hQYXR0ZXJuKGZpbmlzaFBhdHRlcm4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gZmlyc3RQb3M7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRjb250ZW50ID0gW107XG5cbiAgXHR2YXIgZW5kUGF0dGVybiA9IG5ldyBSZWdFeHAoXCJePCEtLVxcXFxzKlwiICsgdXRpbHNfZXNjYXBlUmVnRXhwKG9wZW4pICsgXCJcXFxccypcXFxcL1xcXFxzKlwiICsgbmFtZSArIFwiXFxcXHMqXCIgKyB1dGlsc19lc2NhcGVSZWdFeHAoY2xvc2UpICsgXCJcXFxccyotLT5cIik7XG5cbiAgXHRkbyB7XG4gIFx0XHRpZiAocGFyc2VyLm1hdGNoUGF0dGVybihlbmRQYXR0ZXJuKSkge1xuICBcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y2hpbGQgPSBwYXJzZXIucmVhZChSRUFERVJTKTtcbiAgXHRcdFx0aWYgKCFjaGlsZCkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcImV4cGVjdGVkIGNsb3NpbmcgY29tbWVudCAoJzwhLS0gXCIgKyBvcGVuICsgXCIvXCIgKyBuYW1lICsgXCJcIiArIGNsb3NlICsgXCIgLS0+JylcIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb250ZW50LnB1c2goY2hpbGQpO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKCFjbG9zZWQpO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IElOTElORV9QQVJUSUFMLFxuICBcdFx0ZjogY29udGVudCxcbiAgXHRcdG46IG5hbWVcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZFBhcnRpYWxEZWZpbml0aW9uU2VjdGlvbiA9IHJlYWRQYXJ0aWFsRGVmaW5pdGlvblNlY3Rpb247XG4gIHZhciBwYXJ0aWFsRGVmaW5pdGlvblNlY3Rpb25QYXR0ZXJuID0gL14jXFxzKnBhcnRpYWxcXHMrLztcbiAgZnVuY3Rpb24gcmVhZFBhcnRpYWxEZWZpbml0aW9uU2VjdGlvbihwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIG5hbWUsIGNvbnRlbnQsIGNoaWxkLCBjbG9zZWQ7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHR2YXIgZGVsaW1pdGVycyA9IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnM7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhkZWxpbWl0ZXJzWzBdKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHBhcnRpYWxEZWZpbml0aW9uU2VjdGlvblBhdHRlcm4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybigvXlthLXpBLVpfJF1bYS16QS1aXyQwLTlcXC1dKi8pO1xuXG4gIFx0aWYgKCFuYW1lKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJleHBlY3RlZCBsZWdhbCBwYXJ0aWFsIG5hbWVcIik7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoZGVsaW1pdGVyc1sxXSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIGRlbGltaXRlcnNbMV0gKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0Y29udGVudCA9IFtdO1xuXG4gIFx0ZG8ge1xuICBcdFx0Ly8gVE9ETyBjbGVhbiB0aGlzIHVwXG4gIFx0XHRpZiAoY2hpbGQgPSBzZWN0aW9uX3JlYWRDbG9zaW5nKHBhcnNlciwgeyBvcGVuOiBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzBdLCBjbG9zZTogcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSB9KSkge1xuICBcdFx0XHRpZiAoIWNoaWxkLnIgPT09IFwicGFydGlhbFwiKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgXCIgKyBkZWxpbWl0ZXJzWzBdICsgXCIvcGFydGlhbFwiICsgZGVsaW1pdGVyc1sxXSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y2hpbGQgPSBwYXJzZXIucmVhZChSRUFERVJTKTtcblxuICBcdFx0XHRpZiAoIWNoaWxkKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgXCIgKyBkZWxpbWl0ZXJzWzBdICsgXCIvcGFydGlhbFwiICsgZGVsaW1pdGVyc1sxXSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb250ZW50LnB1c2goY2hpbGQpO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKCFjbG9zZWQpO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IElOTElORV9QQVJUSUFMLFxuICBcdFx0bjogbmFtZSxcbiAgXHRcdGY6IGNvbnRlbnRcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZFRlbXBsYXRlID0gcmVhZFRlbXBsYXRlO1xuICBmdW5jdGlvbiByZWFkVGVtcGxhdGUocGFyc2VyKSB7XG4gIFx0dmFyIGZyYWdtZW50ID0gW107XG4gIFx0dmFyIHBhcnRpYWxzID0gY3JlYXRlKG51bGwpO1xuICBcdHZhciBoYXNQYXJ0aWFscyA9IGZhbHNlO1xuXG4gIFx0dmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IHBhcnNlci5wcmVzZXJ2ZVdoaXRlc3BhY2U7XG5cbiAgXHR3aGlsZSAocGFyc2VyLnBvcyA8IHBhcnNlci5zdHIubGVuZ3RoKSB7XG4gIFx0XHR2YXIgcG9zID0gcGFyc2VyLnBvcyxcbiAgXHRcdCAgICBpdGVtID0gdW5kZWZpbmVkLFxuICBcdFx0ICAgIHBhcnRpYWwgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdGlmIChwYXJ0aWFsID0gcGFyc2VyLnJlYWQoUEFSVElBTF9SRUFERVJTKSkge1xuICBcdFx0XHRpZiAocGFydGlhbHNbcGFydGlhbC5uXSkge1xuICBcdFx0XHRcdHBhcnNlci5wb3MgPSBwb3M7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiRHVwbGljYXRlZCBwYXJ0aWFsIGRlZmluaXRpb25cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR1dGlsc19jbGVhbnVwKHBhcnRpYWwuZiwgcGFyc2VyLnN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgIXByZXNlcnZlV2hpdGVzcGFjZSwgIXByZXNlcnZlV2hpdGVzcGFjZSk7XG5cbiAgXHRcdFx0cGFydGlhbHNbcGFydGlhbC5uXSA9IHBhcnRpYWwuZjtcbiAgXHRcdFx0aGFzUGFydGlhbHMgPSB0cnVlO1xuICBcdFx0fSBlbHNlIGlmIChpdGVtID0gcGFyc2VyLnJlYWQoUkVBREVSUykpIHtcbiAgXHRcdFx0ZnJhZ21lbnQucHVzaChpdGVtKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIlVuZXhwZWN0ZWQgdGVtcGxhdGUgY29udGVudFwiKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR2YXIgcmVzdWx0ID0ge1xuICBcdFx0djogVEVNUExBVEVfVkVSU0lPTixcbiAgXHRcdHQ6IGZyYWdtZW50XG4gIFx0fTtcblxuICBcdGlmIChoYXNQYXJ0aWFscykge1xuICBcdFx0cmVzdWx0LnAgPSBwYXJ0aWFscztcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIF9wYXJzZSA9IHBhcnNlO1xuXG4gIHZhciBTVEFOREFSRF9SRUFERVJTID0gW211c3RhY2hlX3JlYWRQYXJ0aWFsLCBtdXN0YWNoZV9yZWFkVW5lc2NhcGVkLCBtdXN0YWNoZV9yZWFkU2VjdGlvbiwgbXVzdGFjaGVfcmVhZFlpZWxkZXIsIG11c3RhY2hlX3JlYWRJbnRlcnBvbGF0b3IsIHJlYWRNdXN0YWNoZUNvbW1lbnRdO1xuICB2YXIgVFJJUExFX1JFQURFUlMgPSBbbXVzdGFjaGVfcmVhZFRyaXBsZV07XG4gIHZhciBTVEFUSUNfUkVBREVSUyA9IFttdXN0YWNoZV9yZWFkVW5lc2NhcGVkLCBtdXN0YWNoZV9yZWFkU2VjdGlvbiwgbXVzdGFjaGVfcmVhZEludGVycG9sYXRvcl07IC8vIFRPRE8gZG9lcyBpdCBtYWtlIHNlbnNlIHRvIGhhdmUgYSBzdGF0aWMgc2VjdGlvbj9cblxuICB2YXIgU3RhbmRhcmRQYXJzZXIgPSB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIHBhcnNlKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gIFx0cmV0dXJuIG5ldyBTdGFuZGFyZFBhcnNlcih0ZW1wbGF0ZSwgb3B0aW9ucyB8fCB7fSkucmVzdWx0O1xuICB9XG5cbiAgdmFyIFJFQURFUlMgPSBbY29udmVydGVyc19yZWFkTXVzdGFjaGUsIGNvbnZlcnRlcnNfcmVhZEh0bWxDb21tZW50LCBjb252ZXJ0ZXJzX3JlYWRFbGVtZW50LCBjb252ZXJ0ZXJzX3JlYWRUZXh0XTtcbiAgdmFyIFBBUlRJQUxfUkVBREVSUyA9IFtjb252ZXJ0ZXJzX3JlYWRQYXJ0aWFsRGVmaW5pdGlvbkNvbW1lbnQsIGNvbnZlcnRlcnNfcmVhZFBhcnRpYWxEZWZpbml0aW9uU2VjdGlvbl07XG5cbiAgU3RhbmRhcmRQYXJzZXIgPSBwYXJzZV9QYXJzZXIuZXh0ZW5kKHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgdHJpcGxlRGVsaW1pdGVycyA9IG9wdGlvbnMudHJpcGxlRGVsaW1pdGVycyB8fCBbXCJ7e3tcIiwgXCJ9fX1cIl0sXG4gIFx0XHQgICAgc3RhdGljRGVsaW1pdGVycyA9IG9wdGlvbnMuc3RhdGljRGVsaW1pdGVycyB8fCBbXCJbW1wiLCBcIl1dXCJdLFxuICBcdFx0ICAgIHN0YXRpY1RyaXBsZURlbGltaXRlcnMgPSBvcHRpb25zLnN0YXRpY1RyaXBsZURlbGltaXRlcnMgfHwgW1wiW1tbXCIsIFwiXV1dXCJdO1xuXG4gIFx0XHR0aGlzLnN0YW5kYXJkRGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycyB8fCBbXCJ7e1wiLCBcIn19XCJdO1xuXG4gIFx0XHR0aGlzLnRhZ3MgPSBbeyBpc1N0YXRpYzogZmFsc2UsIGlzVHJpcGxlOiBmYWxzZSwgb3BlbjogdGhpcy5zdGFuZGFyZERlbGltaXRlcnNbMF0sIGNsb3NlOiB0aGlzLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSwgcmVhZGVyczogU1RBTkRBUkRfUkVBREVSUyB9LCB7IGlzU3RhdGljOiBmYWxzZSwgaXNUcmlwbGU6IHRydWUsIG9wZW46IHRyaXBsZURlbGltaXRlcnNbMF0sIGNsb3NlOiB0cmlwbGVEZWxpbWl0ZXJzWzFdLCByZWFkZXJzOiBUUklQTEVfUkVBREVSUyB9LCB7IGlzU3RhdGljOiB0cnVlLCBpc1RyaXBsZTogZmFsc2UsIG9wZW46IHN0YXRpY0RlbGltaXRlcnNbMF0sIGNsb3NlOiBzdGF0aWNEZWxpbWl0ZXJzWzFdLCByZWFkZXJzOiBTVEFUSUNfUkVBREVSUyB9LCB7IGlzU3RhdGljOiB0cnVlLCBpc1RyaXBsZTogdHJ1ZSwgb3Blbjogc3RhdGljVHJpcGxlRGVsaW1pdGVyc1swXSwgY2xvc2U6IHN0YXRpY1RyaXBsZURlbGltaXRlcnNbMV0sIHJlYWRlcnM6IFRSSVBMRV9SRUFERVJTIH1dO1xuXG4gIFx0XHR0aGlzLnNvcnRNdXN0YWNoZVRhZ3MoKTtcblxuICBcdFx0dGhpcy5zZWN0aW9uRGVwdGggPSAwO1xuICBcdFx0dGhpcy5lbGVtZW50U3RhY2sgPSBbXTtcblxuICBcdFx0dGhpcy5pbnRlcnBvbGF0ZSA9IHtcbiAgXHRcdFx0c2NyaXB0OiAhb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCBvcHRpb25zLmludGVycG9sYXRlLnNjcmlwdCAhPT0gZmFsc2UsXG4gIFx0XHRcdHN0eWxlOiAhb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCBvcHRpb25zLmludGVycG9sYXRlLnN0eWxlICE9PSBmYWxzZVxuICBcdFx0fTtcblxuICBcdFx0aWYgKG9wdGlvbnMuc2FuaXRpemUgPT09IHRydWUpIHtcbiAgXHRcdFx0b3B0aW9ucy5zYW5pdGl6ZSA9IHtcbiAgXHRcdFx0XHQvLyBibGFja2xpc3QgZnJvbSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1jYWphL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvY2FqYS9sYW5nL2h0bWwvaHRtbDQtZWxlbWVudHMtd2hpdGVsaXN0Lmpzb25cbiAgXHRcdFx0XHRlbGVtZW50czogXCJhcHBsZXQgYmFzZSBiYXNlZm9udCBib2R5IGZyYW1lIGZyYW1lc2V0IGhlYWQgaHRtbCBpc2luZGV4IGxpbmsgbWV0YSBub2ZyYW1lcyBub3NjcmlwdCBvYmplY3QgcGFyYW0gc2NyaXB0IHN0eWxlIHRpdGxlXCIuc3BsaXQoXCIgXCIpLFxuICBcdFx0XHRcdGV2ZW50QXR0cmlidXRlczogdHJ1ZVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnN0cmlwQ29tbWVudHMgPSBvcHRpb25zLnN0cmlwQ29tbWVudHMgIT09IGZhbHNlO1xuICBcdFx0dGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZTtcbiAgXHRcdHRoaXMuc2FuaXRpemVFbGVtZW50cyA9IG9wdGlvbnMuc2FuaXRpemUgJiYgb3B0aW9ucy5zYW5pdGl6ZS5lbGVtZW50cztcbiAgXHRcdHRoaXMuc2FuaXRpemVFdmVudEF0dHJpYnV0ZXMgPSBvcHRpb25zLnNhbml0aXplICYmIG9wdGlvbnMuc2FuaXRpemUuZXZlbnRBdHRyaWJ1dGVzO1xuICBcdFx0dGhpcy5pbmNsdWRlTGluZVBvc2l0aW9ucyA9IG9wdGlvbnMuaW5jbHVkZUxpbmVQb3NpdGlvbnM7XG4gIFx0fSxcblxuICBcdHBvc3RQcm9jZXNzOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBlbXB0eSBzdHJpbmdcbiAgXHRcdGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICBcdFx0XHRyZXR1cm4geyB0OiBbXSwgdjogVEVNUExBVEVfVkVSU0lPTiB9O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5zZWN0aW9uRGVwdGggPiAwKSB7XG4gIFx0XHRcdHRoaXMuZXJyb3IoXCJBIHNlY3Rpb24gd2FzIGxlZnQgb3BlblwiKTtcbiAgXHRcdH1cblxuICBcdFx0dXRpbHNfY2xlYW51cChyZXN1bHRbMF0udCwgdGhpcy5zdHJpcENvbW1lbnRzLCB0aGlzLnByZXNlcnZlV2hpdGVzcGFjZSwgIXRoaXMucHJlc2VydmVXaGl0ZXNwYWNlLCAhdGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2UpO1xuXG4gIFx0XHRyZXR1cm4gcmVzdWx0WzBdO1xuICBcdH0sXG5cbiAgXHRjb252ZXJ0ZXJzOiBbY29udmVydGVyc19yZWFkVGVtcGxhdGVdLFxuXG4gIFx0c29ydE11c3RhY2hlVGFnczogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gU29ydCBpbiBvcmRlciBvZiBkZXNjZW5kaW5nIG9wZW5pbmcgZGVsaW1pdGVyIGxlbmd0aCAobG9uZ2VyIGZpcnN0KSxcbiAgXHRcdC8vIHRvIHByb3RlY3QgYWdhaW5zdCBvcGVuaW5nIGRlbGltaXRlcnMgYmVpbmcgc3Vic3RyaW5ncyBvZiBlYWNoIG90aGVyXG4gIFx0XHR0aGlzLnRhZ3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICBcdFx0XHRyZXR1cm4gYi5vcGVuLmxlbmd0aCAtIGEub3Blbi5sZW5ndGg7XG4gIFx0XHR9KTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBwYXJzZU9wdGlvbnMgPSBbXCJwcmVzZXJ2ZVdoaXRlc3BhY2VcIiwgXCJzYW5pdGl6ZVwiLCBcInN0cmlwQ29tbWVudHNcIiwgXCJkZWxpbWl0ZXJzXCIsIFwidHJpcGxlRGVsaW1pdGVyc1wiLCBcImludGVycG9sYXRlXCJdO1xuXG4gIHZhciBwYXJzZXIgPSB7XG4gIFx0cGFyc2U6IGRvUGFyc2UsXG4gIFx0ZnJvbUlkOiBmcm9tSWQsXG4gIFx0aXNIYXNoZWRJZDogaXNIYXNoZWRJZCxcbiAgXHRpc1BhcnNlZDogaXNQYXJzZWQsXG4gIFx0Z2V0UGFyc2VPcHRpb25zOiBnZXRQYXJzZU9wdGlvbnMsXG4gIFx0Y3JlYXRlSGVscGVyOiB0ZW1wbGF0ZV9wYXJzZXJfX2NyZWF0ZUhlbHBlclxuICB9O1xuXG4gIGZ1bmN0aW9uIHRlbXBsYXRlX3BhcnNlcl9fY3JlYXRlSGVscGVyKHBhcnNlT3B0aW9ucykge1xuICBcdHZhciBoZWxwZXIgPSBjcmVhdGUocGFyc2VyKTtcbiAgXHRoZWxwZXIucGFyc2UgPSBmdW5jdGlvbiAodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgXHRcdHJldHVybiBkb1BhcnNlKHRlbXBsYXRlLCBvcHRpb25zIHx8IHBhcnNlT3B0aW9ucyk7XG4gIFx0fTtcbiAgXHRyZXR1cm4gaGVscGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9QYXJzZSh0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zKSB7XG4gIFx0aWYgKCFfcGFyc2UpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgUmFjdGl2ZS5wYXJzZSAtIGNhbm5vdCBwYXJzZSB0ZW1wbGF0ZS4gRWl0aGVyIHByZXBhcnNlIG9yIHVzZSB0aGUgdmVyc2lvbiB0aGF0IGluY2x1ZGVzIHRoZSBwYXJzZXJcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIF9wYXJzZSh0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zIHx8IHRoaXMub3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tSWQoaWQsIG9wdGlvbnMpIHtcbiAgXHR2YXIgdGVtcGxhdGU7XG5cbiAgXHRpZiAoIWlzQ2xpZW50KSB7XG4gIFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJldHJpZXZlIHRlbXBsYXRlICNcIiArIGlkICsgXCIgYXMgUmFjdGl2ZSBpcyBub3QgcnVubmluZyBpbiBhIGJyb3dzZXIuXCIpO1xuICBcdH1cblxuICBcdGlmIChpc0hhc2hlZElkKGlkKSkge1xuICBcdFx0aWQgPSBpZC5zdWJzdHJpbmcoMSk7XG4gIFx0fVxuXG4gIFx0aWYgKCEodGVtcGxhdGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpKSB7XG4gIFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZWxlbWVudCB3aXRoIGlkICNcIiArIGlkKTtcbiAgXHR9XG5cbiAgXHRpZiAodGVtcGxhdGUudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSBcIlNDUklQVFwiKSB7XG4gIFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGVtcGxhdGUgZWxlbWVudCB3aXRoIGlkICNcIiArIGlkICsgXCIsIG11c3QgYmUgYSA8c2NyaXB0PiBlbGVtZW50XCIpO1xuICBcdH1cblxuICBcdHJldHVybiB0ZW1wbGF0ZS50ZXh0Q29udGVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSGFzaGVkSWQoaWQpIHtcbiAgXHRyZXR1cm4gaWQgJiYgaWQuY2hhckF0KDApID09PSBcIiNcIjsgLy8gVE9ETyB3aGF0IGFib3V0IGBpZFswXWAsIGRvZXMgdGhhdCB3b3JrIGV2ZXJ5d2hlcmU/XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhcnNlZCh0ZW1wbGF0ZSkge1xuICBcdHJldHVybiAhKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXJzZU9wdGlvbnMocmFjdGl2ZSkge1xuICBcdC8vIENvdWxkIGJlIFJhY3RpdmUgb3IgYSBDb21wb25lbnRcbiAgXHRpZiAocmFjdGl2ZS5kZWZhdWx0cykge1xuICBcdFx0cmFjdGl2ZSA9IHJhY3RpdmUuZGVmYXVsdHM7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHBhcnNlT3B0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gIFx0XHR2YWxba2V5XSA9IHJhY3RpdmVba2V5XTtcbiAgXHRcdHJldHVybiB2YWw7XG4gIFx0fSwge30pO1xuICB9XG5cbiAgdmFyIHRlbXBsYXRlX3BhcnNlciA9IHBhcnNlcjtcblxuICB2YXIgdGVtcGxhdGVDb25maWd1cmF0b3IgPSB7XG4gIFx0bmFtZTogXCJ0ZW1wbGF0ZVwiLFxuXG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoUGFyZW50LCBwcm90bywgb3B0aW9ucykge1xuICBcdFx0dmFyIHRlbXBsYXRlO1xuXG4gIFx0XHQvLyBvbmx5IGFzc2lnbiBpZiBleGlzdHNcbiAgXHRcdGlmIChcInRlbXBsYXRlXCIgaW4gb3B0aW9ucykge1xuICBcdFx0XHR0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdFx0cHJvdG8udGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRwcm90by50ZW1wbGF0ZSA9IHBhcnNlSWZTdHJpbmcodGVtcGxhdGUsIHByb3RvKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiBpbml0KFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucykge1xuICBcdFx0dmFyIHRlbXBsYXRlLCBmbjtcblxuICBcdFx0Ly8gVE9ETyBiZWNhdXNlIG9mIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHdlIG1pZ2h0IGp1c3QgYmUgYWJsZSB0byB1c2VcbiAgXHRcdC8vIHJhY3RpdmUudGVtcGxhdGUsIGFuZCBub3QgYm90aGVyIHBhc3NpbmcgdGhyb3VnaCB0aGUgUGFyZW50IG9iamVjdC5cbiAgXHRcdC8vIEF0IHByZXNlbnQgdGhhdCBicmVha3MgdGhlIHRlc3QgbW9ja3MnIGV4cGVjdGF0aW9uc1xuICBcdFx0dGVtcGxhdGUgPSBcInRlbXBsYXRlXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMudGVtcGxhdGUgOiBQYXJlbnQucHJvdG90eXBlLnRlbXBsYXRlO1xuXG4gIFx0XHRpZiAodHlwZW9mIHRlbXBsYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0Zm4gPSB0ZW1wbGF0ZTtcbiAgXHRcdFx0dGVtcGxhdGUgPSBnZXREeW5hbWljVGVtcGxhdGUocmFjdGl2ZSwgZm4pO1xuXG4gIFx0XHRcdHJhY3RpdmUuX2NvbmZpZy50ZW1wbGF0ZSA9IHtcbiAgXHRcdFx0XHRmbjogZm4sXG4gIFx0XHRcdFx0cmVzdWx0OiB0ZW1wbGF0ZVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHR0ZW1wbGF0ZSA9IHBhcnNlSWZTdHJpbmcodGVtcGxhdGUsIHJhY3RpdmUpO1xuXG4gIFx0XHQvLyBUT0RPIHRoZSBuYW1pbmcgb2YgdGhpcyBpcyBjb25mdXNpbmcgLSByYWN0aXZlLnRlbXBsYXRlIHJlZmVycyB0byBbLi4uXSxcbiAgXHRcdC8vIGJ1dCBDb21wb25lbnQucHJvdG90eXBlLnRlbXBsYXRlIHJlZmVycyB0byB7djoxLHQ6W10scDpbXX0uLi5cbiAgXHRcdC8vIGl0J3MgdW5uZWNlc3NhcnksIGJlY2F1c2UgdGhlIGRldmVsb3BlciBuZXZlciBuZWVkcyB0byBhY2Nlc3NcbiAgXHRcdC8vIHJhY3RpdmUudGVtcGxhdGVcbiAgXHRcdHJhY3RpdmUudGVtcGxhdGUgPSB0ZW1wbGF0ZS50O1xuXG4gIFx0XHRpZiAodGVtcGxhdGUucCkge1xuICBcdFx0XHRleHRlbmRQYXJ0aWFscyhyYWN0aXZlLnBhcnRpYWxzLCB0ZW1wbGF0ZS5wKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVzZXQ6IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG4gIFx0XHR2YXIgcmVzdWx0ID0gcmVzZXRWYWx1ZShyYWN0aXZlKSxcbiAgXHRcdCAgICBwYXJzZWQ7XG5cbiAgXHRcdGlmIChyZXN1bHQpIHtcbiAgXHRcdFx0cGFyc2VkID0gcGFyc2VJZlN0cmluZyhyZXN1bHQsIHJhY3RpdmUpO1xuXG4gIFx0XHRcdHJhY3RpdmUudGVtcGxhdGUgPSBwYXJzZWQudDtcbiAgXHRcdFx0ZXh0ZW5kUGFydGlhbHMocmFjdGl2ZS5wYXJ0aWFscywgcGFyc2VkLnAsIHRydWUpO1xuXG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiByZXNldFZhbHVlKHJhY3RpdmUpIHtcbiAgXHR2YXIgaW5pdGlhbCA9IHJhY3RpdmUuX2NvbmZpZy50ZW1wbGF0ZSxcbiAgXHQgICAgcmVzdWx0O1xuXG4gIFx0Ly8gSWYgdGhpcyBpc24ndCBhIGR5bmFtaWMgdGVtcGxhdGUsIHRoZXJlJ3Mgbm90aGluZyB0byBkb1xuICBcdGlmICghaW5pdGlhbCB8fCAhaW5pdGlhbC5mbikge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHJlc3VsdCA9IGdldER5bmFtaWNUZW1wbGF0ZShyYWN0aXZlLCBpbml0aWFsLmZuKTtcblxuICBcdC8vIFRPRE8gZGVlcCBlcXVhbGl0eSBjaGVjayB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlLXJlbmRlcmluZ1xuICBcdC8vIGluIHRoZSBjYXNlIG9mIGFscmVhZHktcGFyc2VkIHRlbXBsYXRlc1xuICBcdGlmIChyZXN1bHQgIT09IGluaXRpYWwucmVzdWx0KSB7XG4gIFx0XHRpbml0aWFsLnJlc3VsdCA9IHJlc3VsdDtcbiAgXHRcdHJlc3VsdCA9IHBhcnNlSWZTdHJpbmcocmVzdWx0LCByYWN0aXZlKTtcbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RHluYW1pY1RlbXBsYXRlKHJhY3RpdmUsIGZuKSB7XG4gIFx0dmFyIGhlbHBlciA9IHRlbXBsYXRlX3RlbXBsYXRlX19jcmVhdGVIZWxwZXIodGVtcGxhdGVfcGFyc2VyLmdldFBhcnNlT3B0aW9ucyhyYWN0aXZlKSk7XG4gIFx0cmV0dXJuIGZuLmNhbGwocmFjdGl2ZSwgaGVscGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlbXBsYXRlX3RlbXBsYXRlX19jcmVhdGVIZWxwZXIocGFyc2VPcHRpb25zKSB7XG4gIFx0dmFyIGhlbHBlciA9IGNyZWF0ZSh0ZW1wbGF0ZV9wYXJzZXIpO1xuICBcdGhlbHBlci5wYXJzZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgb3B0aW9ucykge1xuICBcdFx0cmV0dXJuIHRlbXBsYXRlX3BhcnNlci5wYXJzZSh0ZW1wbGF0ZSwgb3B0aW9ucyB8fCBwYXJzZU9wdGlvbnMpO1xuICBcdH07XG4gIFx0cmV0dXJuIGhlbHBlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSWZTdHJpbmcodGVtcGxhdGUsIHJhY3RpdmUpIHtcbiAgXHRpZiAodHlwZW9mIHRlbXBsYXRlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHQvLyBJRCBvZiBhbiBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHRlbXBsYXRlP1xuICBcdFx0aWYgKHRlbXBsYXRlWzBdID09PSBcIiNcIikge1xuICBcdFx0XHR0ZW1wbGF0ZSA9IHRlbXBsYXRlX3BhcnNlci5mcm9tSWQodGVtcGxhdGUpO1xuICBcdFx0fVxuXG4gIFx0XHR0ZW1wbGF0ZSA9IF9wYXJzZSh0ZW1wbGF0ZSwgdGVtcGxhdGVfcGFyc2VyLmdldFBhcnNlT3B0aW9ucyhyYWN0aXZlKSk7XG4gIFx0fVxuXG4gIFx0Ly8gQ2hlY2sgdGhlIHBhcnNlZCB0ZW1wbGF0ZSBoYXMgYSB2ZXJzaW9uIGF0IGFsbFxuICBcdGVsc2UgaWYgKHR5cGVvZiB0ZW1wbGF0ZS52ICE9PSBcIm51bWJlclwiKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdGVtcGxhdGUgcGFyc2VyIHdhcyBwYXNzZWQgYSBub24tc3RyaW5nIHRlbXBsYXRlLCBidXQgdGhlIHRlbXBsYXRlIGRvZXNuJ3QgaGF2ZSBhIHZlcnNpb24uICBNYWtlIHN1cmUgeW91J3JlIHBhc3NpbmcgaW4gdGhlIHRlbXBsYXRlIHlvdSB0aGluayB5b3UgYXJlLlwiKTtcbiAgXHR9XG5cbiAgXHQvLyBDaGVjayB3ZSdyZSB1c2luZyB0aGUgY29ycmVjdCB2ZXJzaW9uXG4gIFx0ZWxzZSBpZiAodGVtcGxhdGUudiAhPT0gVEVNUExBVEVfVkVSU0lPTikge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCB0ZW1wbGF0ZSB2ZXJzaW9uIChleHBlY3RlZCBcIiArIFRFTVBMQVRFX1ZFUlNJT04gKyBcIiwgZ290IFwiICsgdGVtcGxhdGUudiArIFwiKSBQbGVhc2UgZW5zdXJlIHlvdSBhcmUgdXNpbmcgdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIFJhY3RpdmUuanMgaW4geW91ciBidWlsZCBwcm9jZXNzIGFzIHdlbGwgYXMgaW4geW91ciBhcHBcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRlbXBsYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kUGFydGlhbHMoZXhpc3RpbmdQYXJ0aWFscywgbmV3UGFydGlhbHMsIG92ZXJ3cml0ZSkge1xuICBcdGlmICghbmV3UGFydGlhbHMpIHJldHVybjtcblxuICBcdC8vIFRPRE8gdGhlcmUncyBhbiBhbWJpZ3VpdHkgaGVyZSAtIHdlIG5lZWQgdG8gb3ZlcndyaXRlIGluIHRoZSBgcmVzZXQoKWBcbiAgXHQvLyBjYXNlLCBidXQgbm90IGluaXRpYWxseS4uLlxuXG4gIFx0Zm9yICh2YXIga2V5IGluIG5ld1BhcnRpYWxzKSB7XG4gIFx0XHRpZiAob3ZlcndyaXRlIHx8ICFleGlzdGluZ1BhcnRpYWxzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0ZXhpc3RpbmdQYXJ0aWFsc1trZXldID0gbmV3UGFydGlhbHNba2V5XTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgdGVtcGxhdGVfdGVtcGxhdGUgPSB0ZW1wbGF0ZUNvbmZpZ3VyYXRvcjtcblxuICB2YXIgY29uZmlnX3JlZ2lzdHJpZXNfX3JlZ2lzdHJ5TmFtZXMsIFJlZ2lzdHJ5LCByZWdpc3RyaWVzO1xuXG4gIGNvbmZpZ19yZWdpc3RyaWVzX19yZWdpc3RyeU5hbWVzID0gW1wiYWRhcHRvcnNcIiwgXCJjb21wb25lbnRzXCIsIFwiY29tcHV0ZWRcIiwgXCJkZWNvcmF0b3JzXCIsIFwiZWFzaW5nXCIsIFwiZXZlbnRzXCIsIFwiaW50ZXJwb2xhdG9yc1wiLCBcInBhcnRpYWxzXCIsIFwidHJhbnNpdGlvbnNcIl07XG5cbiAgUmVnaXN0cnkgPSBmdW5jdGlvbiAobmFtZSwgdXNlRGVmYXVsdHMpIHtcbiAgXHR0aGlzLm5hbWUgPSBuYW1lO1xuICBcdHRoaXMudXNlRGVmYXVsdHMgPSB1c2VEZWZhdWx0cztcbiAgfTtcblxuICBSZWdpc3RyeS5wcm90b3R5cGUgPSB7XG4gIFx0Y29uc3RydWN0b3I6IFJlZ2lzdHJ5LFxuXG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAoUGFyZW50LCBwcm90bywgb3B0aW9ucykge1xuICBcdFx0dGhpcy5jb25maWd1cmUodGhpcy51c2VEZWZhdWx0cyA/IFBhcmVudC5kZWZhdWx0cyA6IFBhcmVudCwgdGhpcy51c2VEZWZhdWx0cyA/IHByb3RvIDogcHJvdG8uY29uc3RydWN0b3IsIG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7fSxcblxuICBcdGNvbmZpZ3VyZTogZnVuY3Rpb24gKFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgbmFtZSA9IHRoaXMubmFtZSxcbiAgXHRcdCAgICBvcHRpb24gPSBvcHRpb25zW25hbWVdLFxuICBcdFx0ICAgIHJlZ2lzdHJ5O1xuXG4gIFx0XHRyZWdpc3RyeSA9IGNyZWF0ZShQYXJlbnRbbmFtZV0pO1xuXG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gb3B0aW9uKSB7XG4gIFx0XHRcdHJlZ2lzdHJ5W2tleV0gPSBvcHRpb25ba2V5XTtcbiAgXHRcdH1cblxuICBcdFx0dGFyZ2V0W25hbWVdID0gcmVnaXN0cnk7XG4gIFx0fSxcblxuICBcdHJlc2V0OiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0dmFyIHJlZ2lzdHJ5ID0gcmFjdGl2ZVt0aGlzLm5hbWVdO1xuICBcdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgXHRcdE9iamVjdC5rZXlzKHJlZ2lzdHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdFx0dmFyIGl0ZW0gPSByZWdpc3RyeVtrZXldO1xuICBcdFx0XHRpZiAoaXRlbS5fZm4pIHtcbiAgXHRcdFx0XHRpZiAoaXRlbS5fZm4uaXNPd25lcikge1xuICBcdFx0XHRcdFx0cmVnaXN0cnlba2V5XSA9IGl0ZW0uX2ZuO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRkZWxldGUgcmVnaXN0cnlba2V5XTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdFx0cmV0dXJuIGNoYW5nZWQ7XG4gIFx0fVxuICB9O1xuXG4gIHJlZ2lzdHJpZXMgPSBjb25maWdfcmVnaXN0cmllc19fcmVnaXN0cnlOYW1lcy5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRyZXR1cm4gbmV3IFJlZ2lzdHJ5KG5hbWUsIG5hbWUgPT09IFwiY29tcHV0ZWRcIik7XG4gIH0pO1xuXG4gIHZhciBjb25maWdfcmVnaXN0cmllcyA9IHJlZ2lzdHJpZXM7XG5cbiAgLyp0aGlzLmNvbmZpZ3VyZShcbiAgXHR0aGlzLnVzZURlZmF1bHRzID8gUGFyZW50LmRlZmF1bHRzIDogUGFyZW50LFxuICBcdHJhY3RpdmUsXG4gIFx0b3B0aW9ucyApOyovXG5cbiAgdmFyIHdyYXBQcm90b3R5cGUgPSB3cmFwO1xuXG4gIGZ1bmN0aW9uIHdyYXAocGFyZW50LCBuYW1lLCBtZXRob2QpIHtcbiAgXHRpZiAoIS9fc3VwZXIvLnRlc3QobWV0aG9kKSkge1xuICBcdFx0cmV0dXJuIG1ldGhvZDtcbiAgXHR9XG5cbiAgXHR2YXIgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBTdXBlcigpIHtcbiAgXHRcdHZhciBzdXBlck1ldGhvZCA9IGdldFN1cGVyTWV0aG9kKHdyYXBwZXIuX3BhcmVudCwgbmFtZSksXG4gIFx0XHQgICAgaGFzU3VwZXIgPSAoXCJfc3VwZXJcIiBpbiB0aGlzKSxcbiAgXHRcdCAgICBvbGRTdXBlciA9IHRoaXMuX3N1cGVyLFxuICBcdFx0ICAgIHJlc3VsdDtcblxuICBcdFx0dGhpcy5fc3VwZXIgPSBzdXBlck1ldGhvZDtcblxuICBcdFx0cmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgXHRcdGlmIChoYXNTdXBlcikge1xuICBcdFx0XHR0aGlzLl9zdXBlciA9IG9sZFN1cGVyO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX3N1cGVyO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdH07XG5cbiAgXHR3cmFwcGVyLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIFx0d3JhcHBlci5fbWV0aG9kID0gbWV0aG9kO1xuXG4gIFx0cmV0dXJuIHdyYXBwZXI7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdXBlck1ldGhvZChwYXJlbnQsIG5hbWUpIHtcbiAgXHR2YXIgdmFsdWUsIG1ldGhvZDtcblxuICBcdGlmIChuYW1lIGluIHBhcmVudCkge1xuICBcdFx0dmFsdWUgPSBwYXJlbnRbbmFtZV07XG5cbiAgXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRtZXRob2QgPSB2YWx1ZTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG1ldGhvZCA9IGZ1bmN0aW9uIHJldHVyblZhbHVlKCkge1xuICBcdFx0XHRcdHJldHVybiB2YWx1ZTtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0bWV0aG9kID0gbm9vcDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbWV0aG9kO1xuICB9XG5cbiAgdmFyIGNvbmZpZ19kZXByZWNhdGUgPSBkZXByZWNhdGU7XG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoZGVwcmVjYXRlZCwgY29ycmVjdCwgaXNFcnJvcikge1xuICBcdHJldHVybiBcIm9wdGlvbnMuXCIgKyBkZXByZWNhdGVkICsgXCIgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Ygb3B0aW9ucy5cIiArIGNvcnJlY3QgKyBcIi5cIiArIChpc0Vycm9yID8gXCIgWW91IGNhbm5vdCBzcGVjaWZ5IGJvdGggb3B0aW9ucywgcGxlYXNlIHVzZSBvcHRpb25zLlwiICsgY29ycmVjdCArIFwiLlwiIDogXCJcIik7XG4gIH1cblxuICBmdW5jdGlvbiBkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgZGVwcmVjYXRlZE9wdGlvbiwgY29ycmVjdCkge1xuICBcdGlmIChkZXByZWNhdGVkT3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgXHRcdGlmICghKGNvcnJlY3QgaW4gb3B0aW9ucykpIHtcbiAgXHRcdFx0d2FybklmRGVidWcoZ2V0TWVzc2FnZShkZXByZWNhdGVkT3B0aW9uLCBjb3JyZWN0KSk7XG4gIFx0XHRcdG9wdGlvbnNbY29ycmVjdF0gPSBvcHRpb25zW2RlcHJlY2F0ZWRPcHRpb25dO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKGdldE1lc3NhZ2UoZGVwcmVjYXRlZE9wdGlvbiwgY29ycmVjdCwgdHJ1ZSkpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuICBmdW5jdGlvbiBkZXByZWNhdGUob3B0aW9ucykge1xuICBcdGRlcHJlY2F0ZU9wdGlvbihvcHRpb25zLCBcImJlZm9yZUluaXRcIiwgXCJvbmNvbnN0cnVjdFwiKTtcbiAgXHRkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgXCJpbml0XCIsIFwib25yZW5kZXJcIik7XG4gIFx0ZGVwcmVjYXRlT3B0aW9uKG9wdGlvbnMsIFwiY29tcGxldGVcIiwgXCJvbmNvbXBsZXRlXCIpO1xuICBcdGRlcHJlY2F0ZU9wdGlvbihvcHRpb25zLCBcImV2ZW50RGVmaW5pdGlvbnNcIiwgXCJldmVudHNcIik7XG5cbiAgXHQvLyBVc2luZyBleHRlbmQgd2l0aCBDb21wb25lbnQgaW5zdGVhZCBvZiBvcHRpb25zLFxuICBcdC8vIGxpa2UgSHVtYW4uZXh0ZW5kKCBTcGlkZXIgKSBtZWFucyBhZGFwdG9ycyBhcyBhIHJlZ2lzdHJ5XG4gIFx0Ly8gZ2V0cyBjb3BpZWQgdG8gb3B0aW9ucy4gU28gd2UgaGF2ZSB0byBjaGVjayBpZiBhY3R1YWxseSBhbiBhcnJheVxuICBcdGlmIChpc0FycmF5KG9wdGlvbnMuYWRhcHRvcnMpKSB7XG4gIFx0XHRkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgXCJhZGFwdG9yc1wiLCBcImFkYXB0XCIpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBjb25maWcsIG9yZGVyLCBkZWZhdWx0S2V5cywgY3VzdG9tLCBpc0JsYWNrbGlzdGVkLCBpc1N0YW5kYXJkS2V5O1xuXG4gIGN1c3RvbSA9IHtcbiAgXHRhZGFwdDogY3VzdG9tX2FkYXB0LFxuICBcdGNzczogY3NzX2NzcyxcbiAgXHRkYXRhOiBjdXN0b21fZGF0YSxcbiAgXHR0ZW1wbGF0ZTogdGVtcGxhdGVfdGVtcGxhdGVcbiAgfTtcblxuICBkZWZhdWx0S2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZ19kZWZhdWx0cyk7XG5cbiAgaXNTdGFuZGFyZEtleSA9IG1ha2VPYmooZGVmYXVsdEtleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRyZXR1cm4gIWN1c3RvbVtrZXldO1xuICB9KSk7XG5cbiAgLy8gYmxhY2tsaXN0ZWQga2V5cyB0aGF0IHdlIGRvbid0IGRvdWJsZSBleHRlbmRcbiAgaXNCbGFja2xpc3RlZCA9IG1ha2VPYmooZGVmYXVsdEtleXMuY29uY2F0KGNvbmZpZ19yZWdpc3RyaWVzLm1hcChmdW5jdGlvbiAocikge1xuICBcdHJldHVybiByLm5hbWU7XG4gIH0pKSk7XG5cbiAgb3JkZXIgPSBbXS5jb25jYXQoZGVmYXVsdEtleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRyZXR1cm4gIWNvbmZpZ19yZWdpc3RyaWVzW2tleV0gJiYgIWN1c3RvbVtrZXldO1xuICB9KSwgY29uZmlnX3JlZ2lzdHJpZXMsIGN1c3RvbS5kYXRhLCBjdXN0b20udGVtcGxhdGUsIGN1c3RvbS5jc3MpO1xuXG4gIGNvbmZpZyA9IHtcbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIChQYXJlbnQsIHByb3RvLCBvcHRpb25zKSB7XG4gIFx0XHRyZXR1cm4gY29uZmlndXJlKFwiZXh0ZW5kXCIsIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoUGFyZW50LCByYWN0aXZlLCBvcHRpb25zKSB7XG4gIFx0XHRyZXR1cm4gY29uZmlndXJlKFwiaW5pdFwiLCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRyZXNldDogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdHJldHVybiBvcmRlci5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgXHRcdFx0cmV0dXJuIGMucmVzZXQgJiYgYy5yZXNldChyYWN0aXZlKTtcbiAgXHRcdH0pLm1hcChmdW5jdGlvbiAoYykge1xuICBcdFx0XHRyZXR1cm4gYy5uYW1lO1xuICBcdFx0fSk7XG4gIFx0fSxcblxuICBcdC8vIHRoaXMgZGVmaW5lcyB0aGUgb3JkZXIuIFRPRE8gdGhpcyBpc24ndCB1c2VkIGFueXdoZXJlIGluIHRoZSBjb2RlYmFzZSxcbiAgXHQvLyBvbmx5IGluIHRoZSB0ZXN0IHN1aXRlIC0gc2hvdWxkIGdldCByaWQgb2YgaXRcbiAgXHRvcmRlcjogb3JkZXIgfTtcblxuICBmdW5jdGlvbiBjb25maWd1cmUobWV0aG9kLCBQYXJlbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICBcdGNvbmZpZ19kZXByZWNhdGUob3B0aW9ucyk7XG5cbiAgXHRmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICBcdFx0aWYgKGlzU3RhbmRhcmRLZXkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBcdFx0XHR2YXIgdmFsdWUgPSBvcHRpb25zW2tleV07XG5cbiAgXHRcdFx0Ly8gd2FybiB0aGUgZGV2ZWxvcGVyIGlmIHRoZXkgcGFzc2VkIGEgZnVuY3Rpb24gYW5kIGlnbm9yZSBpdHMgdmFsdWVcblxuICBcdFx0XHQvLyBOT1RFOiB3ZSBhbGxvdyBzb21lIGZ1bmN0aW9ucyBvbiBcImVsXCIgYmVjYXVzZSB3ZSBkdWNrIHR5cGUgZWxlbWVudCBsaXN0c1xuICBcdFx0XHQvLyBhbmQgc29tZSBsaWJyYXJpZXMgb3IgZWYnZWQtdXAgdmlydHVhbCBicm93c2VycyAocGhhbnRvbUpTKSByZXR1cm4gYVxuICBcdFx0XHQvLyBmdW5jdGlvbiBvYmplY3QgYXMgdGhlIHJlc3VsdCBvZiBxdWVyeVNlbGVjdG9yIG1ldGhvZHNcbiAgXHRcdFx0aWYgKGtleSAhPT0gXCJlbFwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdFx0d2FybklmRGVidWcoXCJcIiArIGtleSArIFwiIGlzIGEgUmFjdGl2ZSBvcHRpb24gdGhhdCBkb2VzIG5vdCBleHBlY3QgYSBmdW5jdGlvbiBhbmQgd2lsbCBiZSBpZ25vcmVkXCIsIG1ldGhvZCA9PT0gXCJpbml0XCIgPyB0YXJnZXQgOiBudWxsKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR0YXJnZXRba2V5XSA9IHZhbHVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Y29uZmlnX3JlZ2lzdHJpZXMuZm9yRWFjaChmdW5jdGlvbiAocmVnaXN0cnkpIHtcbiAgXHRcdHJlZ2lzdHJ5W21ldGhvZF0oUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpO1xuICBcdH0pO1xuXG4gIFx0Y3VzdG9tX2FkYXB0W21ldGhvZF0oUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpO1xuICBcdHRlbXBsYXRlX3RlbXBsYXRlW21ldGhvZF0oUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpO1xuICBcdGNzc19jc3NbbWV0aG9kXShQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyk7XG5cbiAgXHRleHRlbmRPdGhlck1ldGhvZHMoUGFyZW50LnByb3RvdHlwZSwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZE90aGVyTWV0aG9kcyhwYXJlbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICBcdGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gIFx0XHRpZiAoIWlzQmxhY2tsaXN0ZWRba2V5XSAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0dmFyIG1lbWJlciA9IG9wdGlvbnNba2V5XTtcblxuICBcdFx0XHQvLyBpZiB0aGlzIGlzIGEgbWV0aG9kIHRoYXQgb3ZlcndyaXRlcyBhIG1ldGhvZCwgd3JhcCBpdDpcbiAgXHRcdFx0aWYgKHR5cGVvZiBtZW1iZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRcdG1lbWJlciA9IHdyYXBQcm90b3R5cGUocGFyZW50LCBrZXksIG1lbWJlcik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0YXJnZXRba2V5XSA9IG1lbWJlcjtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlT2JqKGFycmF5KSB7XG4gIFx0dmFyIG9iaiA9IHt9O1xuICBcdGFycmF5LmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgXHRcdHJldHVybiBvYmpbeF0gPSB0cnVlO1xuICBcdH0pO1xuICBcdHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgY29uZmlnX2NvbmZpZyA9IGNvbmZpZztcblxuICB2YXIgcHJvdG90eXBlX2J1YmJsZSA9IEZyYWdtZW50JGJ1YmJsZTtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRidWJibGUoKSB7XG4gIFx0dGhpcy5kaXJ0eVZhbHVlID0gdGhpcy5kaXJ0eUFyZ3MgPSB0cnVlO1xuXG4gIFx0aWYgKHRoaXMuYm91bmQgJiYgdHlwZW9mIHRoaXMub3duZXIuYnViYmxlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdHRoaXMub3duZXIuYnViYmxlKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9kZXRhY2ggPSBGcmFnbWVudCRkZXRhY2g7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZGV0YWNoKCkge1xuICBcdHZhciBkb2NGcmFnO1xuXG4gIFx0aWYgKHRoaXMuaXRlbXMubGVuZ3RoID09PSAxKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5pdGVtc1swXS5kZXRhY2goKTtcbiAgXHR9XG5cbiAgXHRkb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIFx0dGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHR2YXIgbm9kZSA9IGl0ZW0uZGV0YWNoKCk7XG5cbiAgXHRcdC8vIFRPRE8gVGhlIGlmIHsuLi59IHdhc24ndCBwcmV2aW91c2x5IHJlcXVpcmVkIC0gaXQgaXMgbm93LCBiZWNhdXNlIHdlJ3JlXG4gIFx0XHQvLyBmb3JjaWJseSBkZXRhY2hpbmcgZXZlcnl0aGluZyB0byByZW9yZGVyIHNlY3Rpb25zIGFmdGVyIGFuIHVwZGF0ZS4gVGhhdCdzXG4gIFx0XHQvLyBhIG5vbi1pZGVhbCBicnV0ZSBmb3JjZSBhcHByb2FjaCwgaW1wbGVtZW50ZWQgdG8gZ2V0IGFsbCB0aGUgdGVzdHMgdG8gcGFzc1xuICBcdFx0Ly8gLSBhcyBzb29uIGFzIGl0J3MgcmVwbGFjZWQgd2l0aCBzb21ldGhpbmcgbW9yZSBlbGVnYW50LCB0aGlzIHNob3VsZFxuICBcdFx0Ly8gcmV2ZXJ0IHRvIGBkb2NGcmFnLmFwcGVuZENoaWxkKCBpdGVtLmRldGFjaCgpIClgXG4gIFx0XHRpZiAobm9kZSkge1xuICBcdFx0XHRkb2NGcmFnLmFwcGVuZENoaWxkKG5vZGUpO1xuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0cmV0dXJuIGRvY0ZyYWc7XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmQgPSBGcmFnbWVudCRmaW5kO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGZpbmQoc2VsZWN0b3IpIHtcbiAgXHR2YXIgaSwgbGVuLCBpdGVtLCBxdWVyeVJlc3VsdDtcblxuICBcdGlmICh0aGlzLml0ZW1zKSB7XG4gIFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1tpXTtcblxuICBcdFx0XHRpZiAoaXRlbS5maW5kICYmIChxdWVyeVJlc3VsdCA9IGl0ZW0uZmluZChzZWxlY3RvcikpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfZmluZEFsbCA9IEZyYWdtZW50JGZpbmRBbGw7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZmluZEFsbChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHR2YXIgaSwgbGVuLCBpdGVtO1xuXG4gIFx0aWYgKHRoaXMuaXRlbXMpIHtcbiAgXHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuXG4gIFx0XHRcdGlmIChpdGVtLmZpbmRBbGwpIHtcbiAgXHRcdFx0XHRpdGVtLmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMgPSBGcmFnbWVudCRmaW5kQWxsQ29tcG9uZW50cztcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHR2YXIgaSwgbGVuLCBpdGVtO1xuXG4gIFx0aWYgKHRoaXMuaXRlbXMpIHtcbiAgXHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuXG4gIFx0XHRcdGlmIChpdGVtLmZpbmRBbGxDb21wb25lbnRzKSB7XG4gIFx0XHRcdFx0aXRlbS5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9maW5kQ29tcG9uZW50ID0gRnJhZ21lbnQkZmluZENvbXBvbmVudDtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaW5kQ29tcG9uZW50KHNlbGVjdG9yKSB7XG4gIFx0dmFyIGxlbiwgaSwgaXRlbSwgcXVlcnlSZXN1bHQ7XG5cbiAgXHRpZiAodGhpcy5pdGVtcykge1xuICBcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbaV07XG5cbiAgXHRcdFx0aWYgKGl0ZW0uZmluZENvbXBvbmVudCAmJiAocXVlcnlSZXN1bHQgPSBpdGVtLmZpbmRDb21wb25lbnQoc2VsZWN0b3IpKSkge1xuICBcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSA9IEZyYWdtZW50JGZpbmROZXh0Tm9kZTtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaW5kTmV4dE5vZGUoaXRlbSkge1xuICBcdHZhciBpbmRleCA9IGl0ZW0uaW5kZXgsXG4gIFx0ICAgIG5vZGU7XG5cbiAgXHRpZiAodGhpcy5pdGVtc1tpbmRleCArIDFdKSB7XG4gIFx0XHRub2RlID0gdGhpcy5pdGVtc1tpbmRleCArIDFdLmZpcnN0Tm9kZSgpO1xuICBcdH1cblxuICBcdC8vIGlmIHRoaXMgaXMgdGhlIHJvb3QgZnJhZ21lbnQsIGFuZCB0aGVyZSBhcmUgbm8gbW9yZSBpdGVtcyxcbiAgXHQvLyBpdCBtZWFucyB3ZSdyZSBhdCB0aGUgZW5kLi4uXG4gIFx0ZWxzZSBpZiAodGhpcy5vd25lciA9PT0gdGhpcy5yb290KSB7XG4gIFx0XHRpZiAoIXRoaXMub3duZXIuY29tcG9uZW50KSB7XG4gIFx0XHRcdC8vIFRPRE8gYnV0IHNvbWV0aGluZyBlbHNlIGNvdWxkIGhhdmUgYmVlbiBhcHBlbmRlZCB0b1xuICBcdFx0XHQvLyB0aGlzLnJvb3QuZWwsIG5vP1xuICBcdFx0XHRub2RlID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gLi4udW5sZXNzIHRoaXMgaXMgYSBjb21wb25lbnRcbiAgXHRcdGVsc2Uge1xuICBcdFx0XHRub2RlID0gdGhpcy5vd25lci5jb21wb25lbnQuZmluZE5leHROb2RlKCk7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG5vZGUgPSB0aGlzLm93bmVyLmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmlyc3ROb2RlID0gRnJhZ21lbnQkZmlyc3ROb2RlO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGZpcnN0Tm9kZSgpIHtcbiAgXHRpZiAodGhpcy5pdGVtcyAmJiB0aGlzLml0ZW1zWzBdKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5pdGVtc1swXS5maXJzdE5vZGUoKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzaGFyZWRfcHJvY2Vzc0l0ZW1zID0gcHJvY2Vzc0l0ZW1zO1xuXG4gIGZ1bmN0aW9uIHByb2Nlc3NJdGVtcyhpdGVtcywgdmFsdWVzLCBndWlkLCBjb3VudGVyKSB7XG4gIFx0Y291bnRlciA9IGNvdW50ZXIgfHwgMDtcblxuICBcdHJldHVybiBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdHZhciBwbGFjZWhvbGRlcklkLCB3cmFwcGVkLCB2YWx1ZTtcblxuICBcdFx0aWYgKGl0ZW0udGV4dCkge1xuICBcdFx0XHRyZXR1cm4gaXRlbS50ZXh0O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoaXRlbS5mcmFnbWVudHMpIHtcbiAgXHRcdFx0cmV0dXJuIGl0ZW0uZnJhZ21lbnRzLm1hcChmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgXHRcdFx0XHRyZXR1cm4gcHJvY2Vzc0l0ZW1zKGZyYWdtZW50Lml0ZW1zLCB2YWx1ZXMsIGd1aWQsIGNvdW50ZXIpO1xuICBcdFx0XHR9KS5qb2luKFwiXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRwbGFjZWhvbGRlcklkID0gZ3VpZCArIFwiLVwiICsgY291bnRlcisrO1xuXG4gIFx0XHRpZiAoaXRlbS5rZXlwYXRoICYmICh3cmFwcGVkID0gaXRlbS5yb290LnZpZXdtb2RlbC53cmFwcGVkW2l0ZW0ua2V5cGF0aC5zdHJdKSkge1xuICBcdFx0XHR2YWx1ZSA9IHdyYXBwZWQudmFsdWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR2YWx1ZSA9IGl0ZW0uZ2V0VmFsdWUoKTtcbiAgXHRcdH1cblxuICBcdFx0dmFsdWVzW3BsYWNlaG9sZGVySWRdID0gdmFsdWU7XG5cbiAgXHRcdHJldHVybiBcIiR7XCIgKyBwbGFjZWhvbGRlcklkICsgXCJ9XCI7XG4gIFx0fSkuam9pbihcIlwiKTtcbiAgfVxuXG4gIHZhciBnZXRBcmdzTGlzdCA9IEZyYWdtZW50JGdldEFyZ3NMaXN0O1xuICBmdW5jdGlvbiBGcmFnbWVudCRnZXRBcmdzTGlzdCgpIHtcbiAgXHR2YXIgdmFsdWVzLCBzb3VyY2UsIHBhcnNlZCwgcmVzdWx0O1xuXG4gIFx0aWYgKHRoaXMuZGlydHlBcmdzKSB7XG4gIFx0XHRzb3VyY2UgPSBzaGFyZWRfcHJvY2Vzc0l0ZW1zKHRoaXMuaXRlbXMsIHZhbHVlcyA9IHt9LCB0aGlzLnJvb3QuX2d1aWQpO1xuICBcdFx0cGFyc2VkID0gcGFyc2VKU09OKFwiW1wiICsgc291cmNlICsgXCJdXCIsIHZhbHVlcyk7XG5cbiAgXHRcdGlmICghcGFyc2VkKSB7XG4gIFx0XHRcdHJlc3VsdCA9IFt0aGlzLnRvU3RyaW5nKCldO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmVzdWx0ID0gcGFyc2VkLnZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmFyZ3NMaXN0ID0gcmVzdWx0O1xuICBcdFx0dGhpcy5kaXJ0eUFyZ3MgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5hcmdzTGlzdDtcbiAgfVxuXG4gIHZhciBnZXROb2RlID0gRnJhZ21lbnQkZ2V0Tm9kZTtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRnZXROb2RlKCkge1xuICBcdHZhciBmcmFnbWVudCA9IHRoaXM7XG5cbiAgXHRkbyB7XG4gIFx0XHRpZiAoZnJhZ21lbnQucEVsZW1lbnQpIHtcbiAgXHRcdFx0cmV0dXJuIGZyYWdtZW50LnBFbGVtZW50Lm5vZGU7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQpO1xuXG4gIFx0cmV0dXJuIHRoaXMucm9vdC5kZXRhY2hlZCB8fCB0aGlzLnJvb3QuZWw7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2dldFZhbHVlID0gRnJhZ21lbnQkZ2V0VmFsdWU7XG4gIGZ1bmN0aW9uIEZyYWdtZW50JGdldFZhbHVlKCkge1xuICBcdHZhciB2YWx1ZXMsIHNvdXJjZSwgcGFyc2VkLCByZXN1bHQ7XG5cbiAgXHRpZiAodGhpcy5kaXJ0eVZhbHVlKSB7XG4gIFx0XHRzb3VyY2UgPSBzaGFyZWRfcHJvY2Vzc0l0ZW1zKHRoaXMuaXRlbXMsIHZhbHVlcyA9IHt9LCB0aGlzLnJvb3QuX2d1aWQpO1xuICBcdFx0cGFyc2VkID0gcGFyc2VKU09OKHNvdXJjZSwgdmFsdWVzKTtcblxuICBcdFx0aWYgKCFwYXJzZWQpIHtcbiAgXHRcdFx0cmVzdWx0ID0gdGhpcy50b1N0cmluZygpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmVzdWx0ID0gcGFyc2VkLnZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnZhbHVlID0gcmVzdWx0O1xuICBcdFx0dGhpcy5kaXJ0eVZhbHVlID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICB2YXIgc2hhcmVkX2RldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRyZXR1cm4gZGV0YWNoTm9kZSh0aGlzLm5vZGUpO1xuICB9O1xuXG4gIHZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBURVhUO1xuICBcdHRoaXMudGV4dCA9IG9wdGlvbnMudGVtcGxhdGU7XG4gIH07XG5cbiAgVGV4dC5wcm90b3R5cGUgPSB7XG4gIFx0ZGV0YWNoOiBzaGFyZWRfZGV0YWNoLFxuXG4gIFx0Zmlyc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5ub2RlKSB7XG4gIFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGV4dCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoZXNjYXBlKSB7XG4gIFx0XHRyZXR1cm4gZXNjYXBlID8gZXNjYXBlSHRtbCh0aGlzLnRleHQpIDogdGhpcy50ZXh0O1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdGlmIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmRldGFjaCgpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfVGV4dCA9IFRleHQ7XG5cbiAgdmFyIHNoYXJlZF91bmJpbmQgPSBzaGFyZWRfdW5iaW5kX191bmJpbmQ7XG5cbiAgZnVuY3Rpb24gc2hhcmVkX3VuYmluZF9fdW5iaW5kKCkge1xuICBcdGlmICh0aGlzLnJlZ2lzdGVyZWQpIHtcbiAgXHRcdC8vIHRoaXMgd2FzIHJlZ2lzdGVyZWQgYXMgYSBkZXBlbmRhbnRcbiAgXHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLnJlc29sdmVyKSB7XG4gIFx0XHR0aGlzLnJlc29sdmVyLnVuYmluZCgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBNdXN0YWNoZV9nZXRWYWx1ZSA9IE11c3RhY2hlJGdldFZhbHVlO1xuXG4gIGZ1bmN0aW9uIE11c3RhY2hlJGdldFZhbHVlKCkge1xuICBcdHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG5cbiAgdmFyIFJlZmVyZW5jZVJlc29sdmVyID0gZnVuY3Rpb24gKG93bmVyLCByZWYsIGNhbGxiYWNrKSB7XG4gIFx0dmFyIGtleXBhdGg7XG5cbiAgXHR0aGlzLnJlZiA9IHJlZjtcbiAgXHR0aGlzLnJlc29sdmVkID0gZmFsc2U7XG5cbiAgXHR0aGlzLnJvb3QgPSBvd25lci5yb290O1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvd25lci5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHRrZXlwYXRoID0gc2hhcmVkX3Jlc29sdmVSZWYob3duZXIucm9vdCwgcmVmLCBvd25lci5wYXJlbnRGcmFnbWVudCk7XG4gIFx0aWYgKGtleXBhdGggIT0gdW5kZWZpbmVkKSB7XG4gIFx0XHR0aGlzLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLmFkZFVucmVzb2x2ZWQodGhpcyk7XG4gIFx0fVxuICB9O1xuXG4gIFJlZmVyZW5jZVJlc29sdmVyLnByb3RvdHlwZSA9IHtcbiAgXHRyZXNvbHZlOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMua2V5cGF0aCAmJiAha2V5cGF0aCkge1xuICBcdFx0XHQvLyBpdCB3YXMgcmVzb2x2ZWQsIGFuZCBub3cgaXQncyBub3QuIENhbiBoYXBwZW4gaWYgZS5nLiBgYmFyYCBpblxuICBcdFx0XHQvLyBge3tmb29bYmFyXX19YCBiZWNvbWVzIHVuZGVmaW5lZFxuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRVbnJlc29sdmVkKHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnJlc29sdmVkID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHRcdHRoaXMuY2FsbGJhY2soa2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5yZXNvbHZlKGdldEtleXBhdGgodGhpcy5yZWYpKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dmFyIGtleXBhdGg7XG5cbiAgXHRcdGlmICh0aGlzLmtleXBhdGggIT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdGtleXBhdGggPSB0aGlzLmtleXBhdGgucmVwbGFjZShvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdFx0Ly8gd2FzIGEgbmV3IGtleXBhdGggY3JlYXRlZD9cbiAgXHRcdFx0aWYgKGtleXBhdGggIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdC8vIHJlc29sdmUgaXRcbiAgXHRcdFx0XHR0aGlzLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AucmVtb3ZlVW5yZXNvbHZlZCh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIFJlc29sdmVyc19SZWZlcmVuY2VSZXNvbHZlciA9IFJlZmVyZW5jZVJlc29sdmVyO1xuXG4gIHZhciBTcGVjaWFsUmVzb2x2ZXIgPSBmdW5jdGlvbiAob3duZXIsIHJlZiwgY2FsbGJhY2spIHtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gb3duZXIucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5yZWYgPSByZWY7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIFx0dGhpcy5yZWJpbmQoKTtcbiAgfTtcblxuICB2YXIgcHJvcHMgPSB7XG4gIFx0XCJAa2V5cGF0aFwiOiB7IHByZWZpeDogXCJjXCIsIHByb3A6IFtcImNvbnRleHRcIl0gfSxcbiAgXHRcIkBpbmRleFwiOiB7IHByZWZpeDogXCJpXCIsIHByb3A6IFtcImluZGV4XCJdIH0sXG4gIFx0XCJAa2V5XCI6IHsgcHJlZml4OiBcImtcIiwgcHJvcDogW1wia2V5XCIsIFwiaW5kZXhcIl0gfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFByb3AodGFyZ2V0LCBwcm9wKSB7XG4gIFx0dmFyIHZhbHVlO1xuICBcdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcC5wcm9wLmxlbmd0aDsgaSsrKSB7XG4gIFx0XHRpZiAoKHZhbHVlID0gdGFyZ2V0W3Byb3AucHJvcFtpXV0pICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuIHZhbHVlO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIFNwZWNpYWxSZXNvbHZlci5wcm90b3R5cGUgPSB7XG4gIFx0cmViaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgcmVmID0gdGhpcy5yZWYsXG4gIFx0XHQgICAgZnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50LFxuICBcdFx0ICAgIHByb3AgPSBwcm9wc1tyZWZdLFxuICBcdFx0ICAgIHZhbHVlO1xuXG4gIFx0XHRpZiAoIXByb3ApIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzcGVjaWFsIHJlZmVyZW5jZSBcXFwiXCIgKyByZWYgKyBcIlxcXCIgLSB2YWxpZCByZWZlcmVuY2VzIGFyZSBAaW5kZXgsIEBrZXkgYW5kIEBrZXlwYXRoXCIpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBoYXZlIHdlIGFscmVhZHkgZm91bmQgdGhlIG5lYXJlc3QgcGFyZW50P1xuICBcdFx0aWYgKHRoaXMuY2FjaGVkKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmNhbGxiYWNrKGdldEtleXBhdGgoXCJAXCIgKyBwcm9wLnByZWZpeCArIGdldFByb3AodGhpcy5jYWNoZWQsIHByb3ApKSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSBmb3IgaW5kaWNlcywgd2hpY2ggbWF5IGNyb3NzIGNvbXBvbmVudCBib3VuZGFyaWVzXG4gIFx0XHRpZiAocHJvcC5wcm9wLmluZGV4T2YoXCJpbmRleFwiKSAhPT0gLTEgfHwgcHJvcC5wcm9wLmluZGV4T2YoXCJrZXlcIikgIT09IC0xKSB7XG4gIFx0XHRcdHdoaWxlIChmcmFnbWVudCkge1xuICBcdFx0XHRcdGlmIChmcmFnbWVudC5vd25lci5jdXJyZW50U3VidHlwZSA9PT0gU0VDVElPTl9FQUNIICYmICh2YWx1ZSA9IGdldFByb3AoZnJhZ21lbnQsIHByb3ApKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0XHR0aGlzLmNhY2hlZCA9IGZyYWdtZW50O1xuXG4gIFx0XHRcdFx0XHRmcmFnbWVudC5yZWdpc3RlckluZGV4UmVmKHRoaXMpO1xuXG4gIFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jYWxsYmFjayhnZXRLZXlwYXRoKFwiQFwiICsgcHJvcC5wcmVmaXggKyB2YWx1ZSkpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIHdhdGNoIGZvciBjb21wb25lbnQgYm91bmRhcmllc1xuICBcdFx0XHRcdGlmICghZnJhZ21lbnQucGFyZW50ICYmIGZyYWdtZW50Lm93bmVyICYmIGZyYWdtZW50Lm93bmVyLmNvbXBvbmVudCAmJiBmcmFnbWVudC5vd25lci5jb21wb25lbnQucGFyZW50RnJhZ21lbnQgJiYgIWZyYWdtZW50Lm93bmVyLmNvbXBvbmVudC5pbnN0YW5jZS5pc29sYXRlZCkge1xuICBcdFx0XHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5vd25lci5jb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0d2hpbGUgKGZyYWdtZW50KSB7XG4gIFx0XHRcdFx0aWYgKCh2YWx1ZSA9IGdldFByb3AoZnJhZ21lbnQsIHByb3ApKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jYWxsYmFjayhnZXRLZXlwYXRoKFwiQFwiICsgcHJvcC5wcmVmaXggKyB2YWx1ZS5zdHIpKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmNhY2hlZCkge1xuICBcdFx0XHR0aGlzLmNhY2hlZC51bnJlZ2lzdGVySW5kZXhSZWYodGhpcyk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBSZXNvbHZlcnNfU3BlY2lhbFJlc29sdmVyID0gU3BlY2lhbFJlc29sdmVyO1xuXG4gIHZhciBJbmRleFJlc29sdmVyID0gZnVuY3Rpb24gKG93bmVyLCByZWYsIGNhbGxiYWNrKSB7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IG93bmVyLnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMucmVmID0gcmVmO1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBcdHJlZi5yZWYuZnJhZ21lbnQucmVnaXN0ZXJJbmRleFJlZih0aGlzKTtcblxuICBcdHRoaXMucmViaW5kKCk7XG4gIH07XG5cbiAgSW5kZXhSZXNvbHZlci5wcm90b3R5cGUgPSB7XG4gIFx0cmViaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgaW5kZXgsXG4gIFx0XHQgICAgcmVmID0gdGhpcy5yZWYucmVmO1xuXG4gIFx0XHRpZiAocmVmLnJlZi50ID09PSBcImtcIikge1xuICBcdFx0XHRpbmRleCA9IFwia1wiICsgcmVmLmZyYWdtZW50LmtleTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGluZGV4ID0gXCJpXCIgKyByZWYuZnJhZ21lbnQuaW5kZXg7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMuY2FsbGJhY2soZ2V0S2V5cGF0aChcIkBcIiArIGluZGV4KSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5yZWYucmVmLmZyYWdtZW50LnVucmVnaXN0ZXJJbmRleFJlZih0aGlzKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIFJlc29sdmVyc19JbmRleFJlc29sdmVyID0gSW5kZXhSZXNvbHZlcjtcblxuICB2YXIgUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMgPSBmaW5kSW5kZXhSZWZzO1xuXG4gIGZ1bmN0aW9uIGZpbmRJbmRleFJlZnMoZnJhZ21lbnQsIHJlZk5hbWUpIHtcbiAgXHR2YXIgcmVzdWx0ID0ge30sXG4gIFx0ICAgIHJlZnMsXG4gIFx0ICAgIGZyYWdSZWZzLFxuICBcdCAgICByZWYsXG4gIFx0ICAgIGksXG4gIFx0ICAgIG93bmVyLFxuICBcdCAgICBoaXQgPSBmYWxzZTtcblxuICBcdGlmICghcmVmTmFtZSkge1xuICBcdFx0cmVzdWx0LnJlZnMgPSByZWZzID0ge307XG4gIFx0fVxuXG4gIFx0d2hpbGUgKGZyYWdtZW50KSB7XG4gIFx0XHRpZiAoKG93bmVyID0gZnJhZ21lbnQub3duZXIpICYmIChmcmFnUmVmcyA9IG93bmVyLmluZGV4UmVmcykpIHtcblxuICBcdFx0XHQvLyB3ZSdyZSBsb29raW5nIGZvciBhIHBhcnRpY3VsYXIgcmVmLCBhbmQgaXQncyBoZXJlXG4gIFx0XHRcdGlmIChyZWZOYW1lICYmIChyZWYgPSBvd25lci5nZXRJbmRleFJlZihyZWZOYW1lKSkpIHtcbiAgXHRcdFx0XHRyZXN1bHQucmVmID0ge1xuICBcdFx0XHRcdFx0ZnJhZ21lbnQ6IGZyYWdtZW50LFxuICBcdFx0XHRcdFx0cmVmOiByZWZcbiAgXHRcdFx0XHR9O1xuICBcdFx0XHRcdHJldHVybiByZXN1bHQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyB3ZSdyZSBjb2xsZWN0aW5nIHJlZnMgdXAtdHJlZVxuICBcdFx0XHRlbHNlIGlmICghcmVmTmFtZSkge1xuICBcdFx0XHRcdGZvciAoaSBpbiBmcmFnUmVmcykge1xuICBcdFx0XHRcdFx0cmVmID0gZnJhZ1JlZnNbaV07XG5cbiAgXHRcdFx0XHRcdC8vIGRvbid0IG92ZXJ3cml0ZSBleGlzdGluZyByZWZzIC0gdGhleSBzaG91bGQgc2hhZG93IHBhcmVudHNcbiAgXHRcdFx0XHRcdGlmICghcmVmc1tyZWYubl0pIHtcbiAgXHRcdFx0XHRcdFx0aGl0ID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdFx0cmVmc1tyZWYubl0gPSB7XG4gIFx0XHRcdFx0XHRcdFx0ZnJhZ21lbnQ6IGZyYWdtZW50LFxuICBcdFx0XHRcdFx0XHRcdHJlZjogcmVmXG4gIFx0XHRcdFx0XHRcdH07XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHdhdGNoIGZvciBjb21wb25lbnQgYm91bmRhcmllc1xuICBcdFx0aWYgKCFmcmFnbWVudC5wYXJlbnQgJiYgZnJhZ21lbnQub3duZXIgJiYgZnJhZ21lbnQub3duZXIuY29tcG9uZW50ICYmIGZyYWdtZW50Lm93bmVyLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCAmJiAhZnJhZ21lbnQub3duZXIuY29tcG9uZW50Lmluc3RhbmNlLmlzb2xhdGVkKSB7XG4gIFx0XHRcdHJlc3VsdC5jb21wb25lbnRCb3VuZGFyeSA9IHRydWU7XG4gIFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQub3duZXIuY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCFoaXQpIHtcbiAgXHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fVxuICB9XG5cbiAgZmluZEluZGV4UmVmcy5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShpbmRpY2VzKSB7XG4gIFx0dmFyIHJlZnMgPSB7fSxcbiAgXHQgICAgayxcbiAgXHQgICAgcmVmO1xuXG4gIFx0Zm9yIChrIGluIGluZGljZXMucmVmcykge1xuICBcdFx0cmVmID0gaW5kaWNlcy5yZWZzW2tdO1xuICBcdFx0cmVmc1tyZWYucmVmLm5dID0gcmVmLnJlZi50ID09PSBcImtcIiA/IHJlZi5mcmFnbWVudC5rZXkgOiByZWYuZnJhZ21lbnQuaW5kZXg7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlZnM7XG4gIH07XG5cbiAgdmFyIFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlciA9IGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyO1xuICBmdW5jdGlvbiBjcmVhdGVSZWZlcmVuY2VSZXNvbHZlcihvd25lciwgcmVmLCBjYWxsYmFjaykge1xuICBcdHZhciBpbmRleFJlZjtcblxuICBcdGlmIChyZWYuY2hhckF0KDApID09PSBcIkBcIikge1xuICBcdFx0cmV0dXJuIG5ldyBSZXNvbHZlcnNfU3BlY2lhbFJlc29sdmVyKG93bmVyLCByZWYsIGNhbGxiYWNrKTtcbiAgXHR9XG5cbiAgXHRpZiAoaW5kZXhSZWYgPSBSZXNvbHZlcnNfZmluZEluZGV4UmVmcyhvd25lci5wYXJlbnRGcmFnbWVudCwgcmVmKSkge1xuICBcdFx0cmV0dXJuIG5ldyBSZXNvbHZlcnNfSW5kZXhSZXNvbHZlcihvd25lciwgaW5kZXhSZWYsIGNhbGxiYWNrKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbmV3IFJlc29sdmVyc19SZWZlcmVuY2VSZXNvbHZlcihvd25lciwgcmVmLCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgc2hhcmVkX2dldEZ1bmN0aW9uRnJvbVN0cmluZyA9IGdldEZ1bmN0aW9uRnJvbVN0cmluZztcbiAgdmFyIGNhY2hlID0ge307XG4gIGZ1bmN0aW9uIGdldEZ1bmN0aW9uRnJvbVN0cmluZyhzdHIsIGkpIHtcbiAgXHR2YXIgZm4sIGFyZ3M7XG5cbiAgXHRpZiAoY2FjaGVbc3RyXSkge1xuICBcdFx0cmV0dXJuIGNhY2hlW3N0cl07XG4gIFx0fVxuXG4gIFx0YXJncyA9IFtdO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGFyZ3NbaV0gPSBcIl9cIiArIGk7XG4gIFx0fVxuXG4gIFx0Zm4gPSBuZXcgRnVuY3Rpb24oYXJncy5qb2luKFwiLFwiKSwgXCJyZXR1cm4oXCIgKyBzdHIgKyBcIilcIik7XG5cbiAgXHRjYWNoZVtzdHJdID0gZm47XG4gIFx0cmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIEV4cHJlc3Npb25SZXNvbHZlcixcbiAgICAgIFJlc29sdmVyc19FeHByZXNzaW9uUmVzb2x2ZXJfX2JpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcblxuICBFeHByZXNzaW9uUmVzb2x2ZXIgPSBmdW5jdGlvbiAob3duZXIsIHBhcmVudEZyYWdtZW50LCBleHByZXNzaW9uLCBjYWxsYmFjaykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgcmFjdGl2ZTtcblxuICBcdHJhY3RpdmUgPSBvd25lci5yb290O1xuXG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICBcdHRoaXMub3duZXIgPSBvd25lcjtcbiAgXHR0aGlzLnN0ciA9IGV4cHJlc3Npb24ucztcbiAgXHR0aGlzLmtleXBhdGhzID0gW107XG5cbiAgXHQvLyBDcmVhdGUgcmVzb2x2ZXJzIGZvciBlYWNoIHJlZmVyZW5jZVxuICBcdHRoaXMucGVuZGluZyA9IGV4cHJlc3Npb24uci5sZW5ndGg7XG4gIFx0dGhpcy5yZWZSZXNvbHZlcnMgPSBleHByZXNzaW9uLnIubWFwKGZ1bmN0aW9uIChyZWYsIGkpIHtcbiAgXHRcdHJldHVybiBSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoX3RoaXMsIHJlZiwgZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0X3RoaXMucmVzb2x2ZShpLCBrZXlwYXRoKTtcbiAgXHRcdH0pO1xuICBcdH0pO1xuXG4gIFx0dGhpcy5yZWFkeSA9IHRydWU7XG4gIFx0dGhpcy5idWJibGUoKTtcbiAgfTtcblxuICBFeHByZXNzaW9uUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLnJlYWR5KSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy51bmlxdWVTdHJpbmcgPSBnZXRVbmlxdWVTdHJpbmcodGhpcy5zdHIsIHRoaXMua2V5cGF0aHMpO1xuICBcdFx0dGhpcy5rZXlwYXRoID0gY3JlYXRlRXhwcmVzc2lvbktleXBhdGgodGhpcy51bmlxdWVTdHJpbmcpO1xuXG4gIFx0XHR0aGlzLmNyZWF0ZUV2YWx1YXRvcigpO1xuICBcdFx0dGhpcy5jYWxsYmFjayh0aGlzLmtleXBhdGgpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciByZXNvbHZlcjtcblxuICBcdFx0d2hpbGUgKHJlc29sdmVyID0gdGhpcy5yZWZSZXNvbHZlcnMucG9wKCkpIHtcbiAgXHRcdFx0cmVzb2x2ZXIudW5iaW5kKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlc29sdmU6IGZ1bmN0aW9uIChpbmRleCwga2V5cGF0aCkge1xuICBcdFx0dGhpcy5rZXlwYXRoc1tpbmRleF0gPSBrZXlwYXRoO1xuICBcdFx0dGhpcy5idWJibGUoKTtcbiAgXHR9LFxuXG4gIFx0Y3JlYXRlRXZhbHVhdG9yOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgY29tcHV0YXRpb24sIHZhbHVlR2V0dGVycywgc2lnbmF0dXJlLCBrZXlwYXRoLCBmbjtcblxuICBcdFx0a2V5cGF0aCA9IHRoaXMua2V5cGF0aDtcbiAgXHRcdGNvbXB1dGF0aW9uID0gdGhpcy5yb290LnZpZXdtb2RlbC5jb21wdXRhdGlvbnNba2V5cGF0aC5zdHJdO1xuXG4gIFx0XHQvLyBvbmx5IGlmIGl0IGRvZXNuJ3QgZXhpc3QgeWV0IVxuICBcdFx0aWYgKCFjb21wdXRhdGlvbikge1xuICBcdFx0XHRmbiA9IHNoYXJlZF9nZXRGdW5jdGlvbkZyb21TdHJpbmcodGhpcy5zdHIsIHRoaXMucmVmUmVzb2x2ZXJzLmxlbmd0aCk7XG5cbiAgXHRcdFx0dmFsdWVHZXR0ZXJzID0gdGhpcy5rZXlwYXRocy5tYXAoZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0XHR2YXIgdmFsdWU7XG5cbiAgXHRcdFx0XHRpZiAoa2V5cGF0aCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcbiAgXHRcdFx0XHRcdH07XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gJ3NwZWNpYWwnIGtleXBhdGhzIGVuY29kZSBhIHZhbHVlXG4gIFx0XHRcdFx0aWYgKGtleXBhdGguaXNTcGVjaWFsKSB7XG4gIFx0XHRcdFx0XHR2YWx1ZSA9IGtleXBhdGgudmFsdWU7XG4gIFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0XHRcdFx0XHR9O1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBfdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCwgeyBub1Vud3JhcDogdHJ1ZSwgZnVsbFJvb3RHZXQ6IHRydWUgfSk7XG4gIFx0XHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHRcdFx0dmFsdWUgPSB3cmFwRnVuY3Rpb24odmFsdWUsIF90aGlzLnJvb3QpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuICBcdFx0XHRcdH07XG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHNpZ25hdHVyZSA9IHtcbiAgXHRcdFx0XHRkZXBzOiB0aGlzLmtleXBhdGhzLmZpbHRlcihpc1ZhbGlkRGVwZW5kZW5jeSksXG4gIFx0XHRcdFx0Z2V0dGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHR2YXIgYXJncyA9IHZhbHVlR2V0dGVycy5tYXAoY2FsbCk7XG4gIFx0XHRcdFx0XHRyZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9O1xuXG4gIFx0XHRcdGNvbXB1dGF0aW9uID0gdGhpcy5yb290LnZpZXdtb2RlbC5jb21wdXRlKGtleXBhdGgsIHNpZ25hdHVyZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLm1hcmsoa2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdC8vIFRPRE8gb25seSBidWJibGUgb25jZSwgbm8gbWF0dGVyIGhvdyBtYW55IHJlZmVyZW5jZXMgYXJlIGFmZmVjdGVkIGJ5IHRoZSByZWJpbmRcbiAgXHRcdHRoaXMucmVmUmVzb2x2ZXJzLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgXHRcdFx0cmV0dXJuIHIucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fSk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyID0gRXhwcmVzc2lvblJlc29sdmVyO1xuXG4gIGZ1bmN0aW9uIGNhbGwodmFsdWUpIHtcbiAgXHRyZXR1cm4gdmFsdWUuY2FsbCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VW5pcXVlU3RyaW5nKHN0ciwga2V5cGF0aHMpIHtcbiAgXHQvLyBnZXQgc3RyaW5nIHRoYXQgaXMgdW5pcXVlIHRvIHRoaXMgZXhwcmVzc2lvblxuICBcdHJldHVybiBzdHIucmVwbGFjZSgvXyhbMC05XSspL2csIGZ1bmN0aW9uIChtYXRjaCwgJDEpIHtcbiAgXHRcdHZhciBrZXlwYXRoLCB2YWx1ZTtcblxuICBcdFx0Ly8gbWFrZSBzdXJlIHdlJ3JlIG5vdCByZXBsYWNpbmcgYSBub24ta2V5cGF0aCBfWzAtOV1cbiAgXHRcdGlmICgrJDEgPj0ga2V5cGF0aHMubGVuZ3RoKSB7XG4gIFx0XHRcdHJldHVybiBcIl9cIiArICQxO1xuICBcdFx0fVxuXG4gIFx0XHRrZXlwYXRoID0ga2V5cGF0aHNbJDFdO1xuXG4gIFx0XHRpZiAoa2V5cGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybiBcInVuZGVmaW5lZFwiO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoa2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdFx0dmFsdWUgPSBrZXlwYXRoLnZhbHVlO1xuICBcdFx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gdmFsdWUgOiBcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCI7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBrZXlwYXRoLnN0cjtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUV4cHJlc3Npb25LZXlwYXRoKHVuaXF1ZVN0cmluZykge1xuICBcdC8vIFNhbml0aXplIGJ5IHJlbW92aW5nIGFueSBwZXJpb2RzIG9yIHNxdWFyZSBicmFja2V0cy4gT3RoZXJ3aXNlXG4gIFx0Ly8gd2UgY2FuJ3Qgc3BsaXQgdGhlIGtleXBhdGggaW50byBrZXlzIVxuICBcdC8vIFJlbW92ZSBhc3Rlcmlza3MgdG9vLCBzaW5jZSB0aGV5IG1lc3Mgd2l0aCBwYXR0ZXJuIG9ic2VydmVyc1xuICBcdHJldHVybiBnZXRLZXlwYXRoKFwiJHtcIiArIHVuaXF1ZVN0cmluZy5yZXBsYWNlKC9bXFwuXFxbXFxdXS9nLCBcIi1cIikucmVwbGFjZSgvXFwqLywgXCIjTVVMI1wiKSArIFwifVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWREZXBlbmRlbmN5KGtleXBhdGgpIHtcbiAgXHRyZXR1cm4ga2V5cGF0aCAhPT0gdW5kZWZpbmVkICYmIGtleXBhdGhbMF0gIT09IFwiQFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcEZ1bmN0aW9uKGZuLCByYWN0aXZlKSB7XG4gIFx0dmFyIHdyYXBwZWQsIHByb3AsIGtleTtcblxuICBcdGlmIChmbi5fX3JhY3RpdmVfbm93cmFwKSB7XG4gIFx0XHRyZXR1cm4gZm47XG4gIFx0fVxuXG4gIFx0cHJvcCA9IFwiX19yYWN0aXZlX1wiICsgcmFjdGl2ZS5fZ3VpZDtcbiAgXHR3cmFwcGVkID0gZm5bcHJvcF07XG5cbiAgXHRpZiAod3JhcHBlZCkge1xuICBcdFx0cmV0dXJuIHdyYXBwZWQ7XG4gIFx0fSBlbHNlIGlmICgvdGhpcy8udGVzdChmbi50b1N0cmluZygpKSkge1xuICBcdFx0ZGVmaW5lUHJvcGVydHkoZm4sIHByb3AsIHtcbiAgXHRcdFx0dmFsdWU6IFJlc29sdmVyc19FeHByZXNzaW9uUmVzb2x2ZXJfX2JpbmQuY2FsbChmbiwgcmFjdGl2ZSksXG4gIFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICBcdFx0fSk7XG5cbiAgXHRcdC8vIEFkZCBwcm9wZXJ0aWVzL21ldGhvZHMgdG8gd3JhcHBlZCBmdW5jdGlvblxuICBcdFx0Zm9yIChrZXkgaW4gZm4pIHtcbiAgXHRcdFx0aWYgKGZuLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0XHRmbltwcm9wXVtrZXldID0gZm5ba2V5XTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyYWN0aXZlLl9ib3VuZEZ1bmN0aW9ucy5wdXNoKHtcbiAgXHRcdFx0Zm46IGZuLFxuICBcdFx0XHRwcm9wOiBwcm9wXG4gIFx0XHR9KTtcblxuICBcdFx0cmV0dXJuIGZuW3Byb3BdO1xuICBcdH1cblxuICBcdGRlZmluZVByb3BlcnR5KGZuLCBcIl9fcmFjdGl2ZV9ub3dyYXBcIiwge1xuICBcdFx0dmFsdWU6IGZuXG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gZm4uX19yYWN0aXZlX25vd3JhcDtcbiAgfVxuXG4gIHZhciBNZW1iZXJSZXNvbHZlciA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgcmVzb2x2ZXIsIHBhcmVudEZyYWdtZW50KSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHRoaXMucmVzb2x2ZXIgPSByZXNvbHZlcjtcbiAgXHR0aGlzLnJvb3QgPSByZXNvbHZlci5yb290O1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLnZpZXdtb2RlbCA9IHJlc29sdmVyLnJvb3Qudmlld21vZGVsO1xuXG4gIFx0aWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0dGhpcy52YWx1ZSA9IHRlbXBsYXRlO1xuICBcdH1cblxuICBcdC8vIFNpbXBsZSByZWZlcmVuY2U/XG4gIFx0ZWxzZSBpZiAodGVtcGxhdGUudCA9PT0gUkVGRVJFTkNFKSB7XG4gIFx0XHR0aGlzLnJlZlJlc29sdmVyID0gUmVzb2x2ZXJzX2NyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKHRoaXMsIHRlbXBsYXRlLm4sIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdF90aGlzLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHQvLyBPdGhlcndpc2Ugd2UgaGF2ZSBhbiBleHByZXNzaW9uIGluIGl0cyBvd24gcmlnaHRcbiAgXHRlbHNlIHtcbiAgXHRcdG5ldyBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyKHJlc29sdmVyLCBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGUsIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdF90aGlzLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9XG4gIH07XG5cbiAgTWVtYmVyUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdHJlc29sdmU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoKSB7XG4gIFx0XHRcdHRoaXMudmlld21vZGVsLnVucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHRcdHRoaXMudmFsdWUgPSB0aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdHRoaXMuYmluZCgpO1xuXG4gIFx0XHR0aGlzLnJlc29sdmVyLmJ1YmJsZSgpO1xuICBcdH0sXG5cbiAgXHRiaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHRpZiAodGhpcy5yZWZSZXNvbHZlcikge1xuICBcdFx0XHR0aGlzLnJlZlJlc29sdmVyLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICBcdFx0dGhpcy5yZXNvbHZlci5idWJibGUoKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoKSB7XG4gIFx0XHRcdHRoaXMudmlld21vZGVsLnVucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMucmVmUmVzb2x2ZXIpIHtcbiAgXHRcdFx0dGhpcy5yZWZSZXNvbHZlci51bmJpbmQoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5yZWZSZXNvbHZlcikge1xuICBcdFx0XHR0aGlzLnJlZlJlc29sdmVyLmZvcmNlUmVzb2x1dGlvbigpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX01lbWJlclJlc29sdmVyID0gTWVtYmVyUmVzb2x2ZXI7XG5cbiAgdmFyIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciA9IGZ1bmN0aW9uIChtdXN0YWNoZSwgdGVtcGxhdGUsIGNhbGxiYWNrKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciByYWN0aXZlLCByZWYsIGtleXBhdGgsIHBhcmVudEZyYWdtZW50O1xuXG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50ID0gbXVzdGFjaGUucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZSA9IG11c3RhY2hlLnJvb3Q7XG4gIFx0dGhpcy5tdXN0YWNoZSA9IG11c3RhY2hlO1xuXG4gIFx0dGhpcy5yZWYgPSByZWYgPSB0ZW1wbGF0ZS5yO1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBcdHRoaXMudW5yZXNvbHZlZCA9IFtdO1xuXG4gIFx0Ly8gRmluZCBiYXNlIGtleXBhdGhcbiAgXHRpZiAoa2V5cGF0aCA9IHNoYXJlZF9yZXNvbHZlUmVmKHJhY3RpdmUsIHJlZiwgcGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHR0aGlzLmJhc2UgPSBrZXlwYXRoO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR0aGlzLmJhc2VSZXNvbHZlciA9IG5ldyBSZXNvbHZlcnNfUmVmZXJlbmNlUmVzb2x2ZXIodGhpcywgcmVmLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRfdGhpcy5iYXNlID0ga2V5cGF0aDtcbiAgXHRcdFx0X3RoaXMuYmFzZVJlc29sdmVyID0gbnVsbDtcbiAgXHRcdFx0X3RoaXMuYnViYmxlKCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHQvLyBGaW5kIHZhbHVlcyBmb3IgbWVtYmVycywgb3IgbWFyayB0aGVtIGFzIHVucmVzb2x2ZWRcbiAgXHR0aGlzLm1lbWJlcnMgPSB0ZW1wbGF0ZS5tLm1hcChmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgXHRcdHJldHVybiBuZXcgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX01lbWJlclJlc29sdmVyKHRlbXBsYXRlLCBfdGhpcywgcGFyZW50RnJhZ21lbnQpO1xuICBcdH0pO1xuXG4gIFx0dGhpcy5yZWFkeSA9IHRydWU7XG4gIFx0dGhpcy5idWJibGUoKTsgLy8gdHJpZ2dlciBpbml0aWFsIHJlc29sdXRpb24gaWYgcG9zc2libGVcbiAgfTtcblxuICBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdGdldEtleXBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB2YWx1ZXMgPSB0aGlzLm1lbWJlcnMubWFwKFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfX2dldFZhbHVlKTtcblxuICBcdFx0aWYgKCF2YWx1ZXMuZXZlcnkoaXNEZWZpbmVkKSB8fCB0aGlzLmJhc2VSZXNvbHZlcikge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMuYmFzZS5qb2luKHZhbHVlcy5qb2luKFwiLlwiKSk7XG4gIFx0fSxcblxuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLnJlYWR5IHx8IHRoaXMuYmFzZVJlc29sdmVyKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5jYWxsYmFjayh0aGlzLmdldEtleXBhdGgoKSk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5tZW1iZXJzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dmFyIGNoYW5nZWQ7XG5cbiAgXHRcdGlmICh0aGlzLmJhc2UpIHtcbiAgXHRcdFx0dmFyIG5ld0Jhc2UgPSB0aGlzLmJhc2UucmVwbGFjZShvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdFx0aWYgKG5ld0Jhc2UgJiYgbmV3QmFzZSAhPT0gdGhpcy5iYXNlKSB7XG4gIFx0XHRcdFx0dGhpcy5iYXNlID0gbmV3QmFzZTtcbiAgXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaChmdW5jdGlvbiAobWVtYmVycykge1xuICBcdFx0XHRpZiAobWVtYmVycy5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkpIHtcbiAgXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG5cbiAgXHRcdGlmIChjaGFuZ2VkKSB7XG4gIFx0XHRcdHRoaXMuYnViYmxlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGZvcmNlUmVzb2x1dGlvbjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuYmFzZVJlc29sdmVyKSB7XG4gIFx0XHRcdHRoaXMuYmFzZSA9IGdldEtleXBhdGgodGhpcy5yZWYpO1xuXG4gIFx0XHRcdHRoaXMuYmFzZVJlc29sdmVyLnVuYmluZCgpO1xuICBcdFx0XHR0aGlzLmJhc2VSZXNvbHZlciA9IG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMubWVtYmVycy5mb3JFYWNoKGZvcmNlUmVzb2x1dGlvbik7XG4gIFx0XHR0aGlzLmJ1YmJsZSgpO1xuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX19nZXRWYWx1ZShtZW1iZXIpIHtcbiAgXHRyZXR1cm4gbWVtYmVyLnZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIFx0cmV0dXJuIHZhbHVlICE9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcmNlUmVzb2x1dGlvbihtZW1iZXIpIHtcbiAgXHRtZW1iZXIuZm9yY2VSZXNvbHV0aW9uKCk7XG4gIH1cblxuICB2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciA9IFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcjtcblxuICB2YXIgTXVzdGFjaGVfaW5pdGlhbGlzZSA9IE11c3RhY2hlJGluaXQ7XG4gIGZ1bmN0aW9uIE11c3RhY2hlJGluaXQobXVzdGFjaGUsIG9wdGlvbnMpIHtcblxuICBcdHZhciByZWYsIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZTtcblxuICBcdHBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcbiAgXHR0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cbiAgXHRtdXN0YWNoZS5yb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcbiAgXHRtdXN0YWNoZS5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50O1xuICBcdG11c3RhY2hlLnBFbGVtZW50ID0gcGFyZW50RnJhZ21lbnQucEVsZW1lbnQ7XG5cbiAgXHRtdXN0YWNoZS50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gIFx0bXVzdGFjaGUuaW5kZXggPSBvcHRpb25zLmluZGV4IHx8IDA7XG4gIFx0bXVzdGFjaGUuaXNTdGF0aWMgPSBvcHRpb25zLnRlbXBsYXRlLnM7XG5cbiAgXHRtdXN0YWNoZS50eXBlID0gb3B0aW9ucy50ZW1wbGF0ZS50O1xuXG4gIFx0bXVzdGFjaGUucmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG4gIFx0Ly8gaWYgdGhpcyBpcyBhIHNpbXBsZSBtdXN0YWNoZSwgd2l0aCBhIHJlZmVyZW5jZSwgd2UganVzdCBuZWVkIHRvIHJlc29sdmVcbiAgXHQvLyB0aGUgcmVmZXJlbmNlIHRvIGEga2V5cGF0aFxuICBcdGlmIChyZWYgPSB0ZW1wbGF0ZS5yKSB7XG4gIFx0XHRtdXN0YWNoZS5yZXNvbHZlciA9IFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlcihtdXN0YWNoZSwgcmVmLCByZXNvbHZlKTtcbiAgXHR9XG5cbiAgXHQvLyBpZiBpdCdzIGFuIGV4cHJlc3Npb24sIHdlIGhhdmUgYSBiaXQgbW9yZSB3b3JrIHRvIGRvXG4gIFx0aWYgKG9wdGlvbnMudGVtcGxhdGUueCkge1xuICBcdFx0bXVzdGFjaGUucmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXJzX0V4cHJlc3Npb25SZXNvbHZlcihtdXN0YWNoZSwgcGFyZW50RnJhZ21lbnQsIG9wdGlvbnMudGVtcGxhdGUueCwgcmVzb2x2ZUFuZFJlYmluZENoaWxkcmVuKTtcbiAgXHR9XG5cbiAgXHRpZiAob3B0aW9ucy50ZW1wbGF0ZS5yeCkge1xuICBcdFx0bXVzdGFjaGUucmVzb2x2ZXIgPSBuZXcgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcihtdXN0YWNoZSwgb3B0aW9ucy50ZW1wbGF0ZS5yeCwgcmVzb2x2ZUFuZFJlYmluZENoaWxkcmVuKTtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSBpbnZlcnRlZCBzZWN0aW9uc1xuICBcdGlmIChtdXN0YWNoZS50ZW1wbGF0ZS5uID09PSBTRUNUSU9OX1VOTEVTUyAmJiAhbXVzdGFjaGUuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSkge1xuICBcdFx0bXVzdGFjaGUuc2V0VmFsdWUodW5kZWZpbmVkKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiByZXNvbHZlKGtleXBhdGgpIHtcbiAgXHRcdG11c3RhY2hlLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gcmVzb2x2ZUFuZFJlYmluZENoaWxkcmVuKG5ld0tleXBhdGgpIHtcbiAgXHRcdHZhciBvbGRLZXlwYXRoID0gbXVzdGFjaGUua2V5cGF0aDtcblxuICBcdFx0aWYgKG5ld0tleXBhdGggIT0gb2xkS2V5cGF0aCkge1xuICBcdFx0XHRtdXN0YWNoZS5yZXNvbHZlKG5ld0tleXBhdGgpO1xuXG4gIFx0XHRcdGlmIChvbGRLZXlwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS5mcmFnbWVudHMgJiYgbXVzdGFjaGUuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgXHRcdFx0XHRcdGYucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIE11c3RhY2hlX3Jlc29sdmUgPSBNdXN0YWNoZSRyZXNvbHZlO1xuXG4gIGZ1bmN0aW9uIE11c3RhY2hlJHJlc29sdmUoa2V5cGF0aCkge1xuICBcdHZhciB3YXNSZXNvbHZlZCwgdmFsdWUsIHR3b3dheUJpbmRpbmc7XG5cbiAgXHQvLyAnU3BlY2lhbCcga2V5cGF0aHMsIGUuZy4gQGZvbyBvciBANywgZW5jb2RlIGEgdmFsdWVcbiAgXHRpZiAoa2V5cGF0aCAmJiBrZXlwYXRoLmlzU3BlY2lhbCkge1xuICBcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHRcdHRoaXMuc2V0VmFsdWUoa2V5cGF0aC52YWx1ZSk7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gSWYgd2UgcmVzb2x2ZWQgcHJldmlvdXNseSwgd2UgbmVlZCB0byB1bnJlZ2lzdGVyXG4gIFx0aWYgKHRoaXMucmVnaXN0ZXJlZCkge1xuICBcdFx0Ly8gdW5kZWZpbmVkIG9yIG51bGxcbiAgXHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMpO1xuICBcdFx0dGhpcy5yZWdpc3RlcmVkID0gZmFsc2U7XG5cbiAgXHRcdHdhc1Jlc29sdmVkID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXG4gIFx0Ly8gSWYgdGhlIG5ldyBrZXlwYXRoIGV4aXN0cywgd2UgbmVlZCB0byByZWdpc3RlclxuICBcdC8vIHdpdGggdGhlIHZpZXdtb2RlbFxuICBcdGlmIChrZXlwYXRoICE9IHVuZGVmaW5lZCkge1xuICBcdFx0Ly8gdW5kZWZpbmVkIG9yIG51bGxcbiAgXHRcdHZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnJlZ2lzdGVyKGtleXBhdGgsIHRoaXMpO1xuXG4gIFx0XHR0aGlzLnJlZ2lzdGVyZWQgPSB0cnVlO1xuICBcdH1cblxuICBcdC8vIEVpdGhlciB3YXkgd2UgbmVlZCB0byBxdWV1ZSB1cCBhIHJlbmRlciAoYHZhbHVlYFxuICBcdC8vIHdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgdGhlcmUncyBubyBrZXlwYXRoKVxuICBcdHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuXG4gIFx0Ly8gVHdvLXdheSBiaW5kaW5ncyBuZWVkIHRvIHBvaW50IHRvIHRoZWlyIG5ldyB0YXJnZXQga2V5cGF0aFxuICBcdGlmICh3YXNSZXNvbHZlZCAmJiAodHdvd2F5QmluZGluZyA9IHRoaXMudHdvd2F5QmluZGluZykpIHtcbiAgXHRcdHR3b3dheUJpbmRpbmcucmVib3VuZCgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBNdXN0YWNoZV9yZWJpbmQgPSBNdXN0YWNoZSRyZWJpbmQ7XG5cbiAgZnVuY3Rpb24gTXVzdGFjaGUkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHQvLyBDaGlsZHJlbiBmaXJzdFxuICBcdGlmICh0aGlzLmZyYWdtZW50cykge1xuICBcdFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICBcdFx0XHRyZXR1cm4gZi5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHQvLyBFeHByZXNzaW9uIG11c3RhY2hlP1xuICBcdGlmICh0aGlzLnJlc29sdmVyKSB7XG4gIFx0XHR0aGlzLnJlc29sdmVyLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgTXVzdGFjaGUgPSB7XG4gIFx0Z2V0VmFsdWU6IE11c3RhY2hlX2dldFZhbHVlLFxuICBcdGluaXQ6IE11c3RhY2hlX2luaXRpYWxpc2UsXG4gIFx0cmVzb2x2ZTogTXVzdGFjaGVfcmVzb2x2ZSxcbiAgXHRyZWJpbmQ6IE11c3RhY2hlX3JlYmluZFxuICB9O1xuXG4gIHZhciBJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMudHlwZSA9IElOVEVSUE9MQVRPUjtcbiAgXHRNdXN0YWNoZS5pbml0KHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEludGVycG9sYXRvci5wcm90b3R5cGUgPSB7XG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLm5vZGUuZGF0YSA9IHRoaXMudmFsdWUgPT0gdW5kZWZpbmVkID8gXCJcIiA6IHRoaXMudmFsdWU7XG4gIFx0fSxcbiAgXHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuICBcdHJlYmluZDogTXVzdGFjaGUucmViaW5kLFxuICBcdGRldGFjaDogc2hhcmVkX2RldGFjaCxcblxuICBcdHVuYmluZDogc2hhcmVkX3VuYmluZCxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLm5vZGUpIHtcbiAgXHRcdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc2FmZVRvU3RyaW5nVmFsdWUodGhpcy52YWx1ZSkpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdGlmIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRcdGRldGFjaE5vZGUodGhpcy5ub2RlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IE11c3RhY2hlLmdldFZhbHVlLFxuXG4gIFx0Ly8gVEVNUFxuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdHZhciB3cmFwcGVyO1xuXG4gIFx0XHQvLyBUT0RPIGlzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBhcHByb2FjaCB0aGlzP1xuICBcdFx0aWYgKHRoaXMua2V5cGF0aCAmJiAod3JhcHBlciA9IHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFt0aGlzLmtleXBhdGguc3RyXSkpIHtcbiAgXHRcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWlzRXF1YWwodmFsdWUsIHRoaXMudmFsdWUpKSB7XG4gIFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblxuICBcdFx0XHRpZiAodGhpcy5ub2RlKSB7XG4gIFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRmaXJzdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoZXNjYXBlKSB7XG4gIFx0XHR2YXIgc3RyaW5nID0gXCJcIiArIHNhZmVUb1N0cmluZ1ZhbHVlKHRoaXMudmFsdWUpO1xuICBcdFx0cmV0dXJuIGVzY2FwZSA/IGVzY2FwZUh0bWwoc3RyaW5nKSA6IHN0cmluZztcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGl0ZW1zX0ludGVycG9sYXRvciA9IEludGVycG9sYXRvcjtcblxuICB2YXIgU2VjdGlvbl9wcm90b3R5cGVfYnViYmxlID0gU2VjdGlvbiRidWJibGU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRidWJibGUoKSB7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcbiAgfVxuXG4gIHZhciBTZWN0aW9uX3Byb3RvdHlwZV9kZXRhY2ggPSBTZWN0aW9uJGRldGFjaDtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGRldGFjaCgpIHtcbiAgXHR2YXIgZG9jRnJhZztcblxuICBcdGlmICh0aGlzLmZyYWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50c1swXS5kZXRhY2goKTtcbiAgXHR9XG5cbiAgXHRkb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0ZG9jRnJhZy5hcHBlbmRDaGlsZChpdGVtLmRldGFjaCgpKTtcbiAgXHR9KTtcblxuICBcdHJldHVybiBkb2NGcmFnO1xuICB9XG5cbiAgdmFyIGZpbmQgPSBTZWN0aW9uJGZpbmQ7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRmaW5kKHNlbGVjdG9yKSB7XG4gIFx0dmFyIGksIGxlbiwgcXVlcnlSZXN1bHQ7XG5cbiAgXHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRpZiAocXVlcnlSZXN1bHQgPSB0aGlzLmZyYWdtZW50c1tpXS5maW5kKHNlbGVjdG9yKSkge1xuICBcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZmluZEFsbCA9IFNlY3Rpb24kZmluZEFsbDtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0dmFyIGksIGxlbjtcblxuICBcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnRzW2ldLmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9XG4gIH1cblxuICB2YXIgZmluZEFsbENvbXBvbmVudHMgPSBTZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0dmFyIGksIGxlbjtcblxuICBcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnRzW2ldLmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGZpbmRDb21wb25lbnQgPSBTZWN0aW9uJGZpbmRDb21wb25lbnQ7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRmaW5kQ29tcG9uZW50KHNlbGVjdG9yKSB7XG4gIFx0dmFyIGksIGxlbiwgcXVlcnlSZXN1bHQ7XG5cbiAgXHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRpZiAocXVlcnlSZXN1bHQgPSB0aGlzLmZyYWdtZW50c1tpXS5maW5kQ29tcG9uZW50KHNlbGVjdG9yKSkge1xuICBcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZmluZE5leHROb2RlID0gU2VjdGlvbiRmaW5kTmV4dE5vZGU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRmaW5kTmV4dE5vZGUoZnJhZ21lbnQpIHtcbiAgXHRpZiAodGhpcy5mcmFnbWVudHNbZnJhZ21lbnQuaW5kZXggKyAxXSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnRzW2ZyYWdtZW50LmluZGV4ICsgMV0uZmlyc3ROb2RlKCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICB9XG5cbiAgdmFyIGZpcnN0Tm9kZSA9IFNlY3Rpb24kZmlyc3ROb2RlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmlyc3ROb2RlKCkge1xuICBcdHZhciBsZW4sIGksIG5vZGU7XG5cbiAgXHRpZiAobGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0aWYgKG5vZGUgPSB0aGlzLmZyYWdtZW50c1tpXS5maXJzdE5vZGUoKSkge1xuICBcdFx0XHRcdHJldHVybiBub2RlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICB9XG5cbiAgdmFyIHNodWZmbGUgPSBTZWN0aW9uJHNodWZmbGU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRzaHVmZmxlKG5ld0luZGljZXMpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHBhcmVudEZyYWdtZW50LCBmaXJzdENoYW5nZSwgaSwgbmV3TGVuZ3RoLCByZWJvdW5kRnJhZ21lbnRzLCBmcmFnbWVudE9wdGlvbnMsIGZyYWdtZW50O1xuXG4gIFx0Ly8gc2hvcnQgY2lyY3VpdCBhbnkgZG91YmxlLXVwZGF0ZXMsIGFuZCBlbnN1cmUgdGhhdCB0aGlzIGlzbid0IGFwcGxpZWQgdG9cbiAgXHQvLyBub24tbGlzdCBzZWN0aW9uc1xuICBcdGlmICh0aGlzLnNodWZmbGluZyB8fCB0aGlzLnVuYm91bmQgfHwgdGhpcy5jdXJyZW50U3VidHlwZSAhPT0gU0VDVElPTl9FQUNIKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dGhpcy5zaHVmZmxpbmcgPSB0cnVlO1xuICBcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gX3RoaXMuc2h1ZmZsaW5nID0gZmFsc2U7XG4gIFx0fSk7XG5cbiAgXHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHRyZWJvdW5kRnJhZ21lbnRzID0gW107XG5cbiAgXHQvLyBUT0RPOiBuZWVkIHRvIHVwZGF0ZSB0aGlzXG4gIFx0Ly8gZmlyc3QsIHJlYmluZCBleGlzdGluZyBmcmFnbWVudHNcbiAgXHRuZXdJbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKG5ld0luZGV4LCBvbGRJbmRleCkge1xuICBcdFx0dmFyIGZyYWdtZW50LCBieSwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCwgZGVwcztcblxuICBcdFx0aWYgKG5ld0luZGV4ID09PSBvbGRJbmRleCkge1xuICBcdFx0XHRyZWJvdW5kRnJhZ21lbnRzW25ld0luZGV4XSA9IF90aGlzLmZyYWdtZW50c1tvbGRJbmRleF07XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0ZnJhZ21lbnQgPSBfdGhpcy5mcmFnbWVudHNbb2xkSW5kZXhdO1xuXG4gIFx0XHRpZiAoZmlyc3RDaGFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRmaXJzdENoYW5nZSA9IG9sZEluZGV4O1xuICBcdFx0fVxuXG4gIFx0XHQvLyBkb2VzIHRoaXMgZnJhZ21lbnQgbmVlZCB0byBiZSB0b3JuIGRvd24/XG4gIFx0XHRpZiAobmV3SW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdF90aGlzLmZyYWdtZW50c1RvVW5yZW5kZXIucHVzaChmcmFnbWVudCk7XG4gIFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdC8vIE90aGVyd2lzZSwgaXQgbmVlZHMgdG8gYmUgcmVib3VuZCB0byBhIG5ldyBpbmRleFxuICBcdFx0YnkgPSBuZXdJbmRleCAtIG9sZEluZGV4O1xuICBcdFx0b2xkS2V5cGF0aCA9IF90aGlzLmtleXBhdGguam9pbihvbGRJbmRleCk7XG4gIFx0XHRuZXdLZXlwYXRoID0gX3RoaXMua2V5cGF0aC5qb2luKG5ld0luZGV4KTtcblxuICBcdFx0ZnJhZ21lbnQuaW5kZXggPSBuZXdJbmRleDtcblxuICBcdFx0Ly8gbm90aWZ5IGFueSByZWdpc3RlcmVkIGluZGV4IHJlZnMgZGlyZWN0bHlcbiAgXHRcdGlmIChkZXBzID0gZnJhZ21lbnQucmVnaXN0ZXJlZEluZGV4UmVmcykge1xuICBcdFx0XHRkZXBzLmZvckVhY2goc2h1ZmZsZV9fYmxpbmRSZWJpbmQpO1xuICBcdFx0fVxuXG4gIFx0XHRmcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHRyZWJvdW5kRnJhZ21lbnRzW25ld0luZGV4XSA9IGZyYWdtZW50O1xuICBcdH0pO1xuXG4gIFx0bmV3TGVuZ3RoID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQodGhpcy5rZXlwYXRoKS5sZW5ndGg7XG5cbiAgXHQvLyBJZiBub3RoaW5nIGNoYW5nZWQgd2l0aCB0aGUgZXhpc3RpbmcgZnJhZ21lbnRzLCB0aGVuIHdlIHN0YXJ0IGFkZGluZ1xuICBcdC8vIG5ldyBmcmFnbWVudHMgYXQgdGhlIGVuZC4uLlxuICBcdGlmIChmaXJzdENoYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHQvLyAuLi51bmxlc3MgdGhlcmUgYXJlIG5vIG5ldyBmcmFnbWVudHMgdG8gYWRkXG4gIFx0XHRpZiAodGhpcy5sZW5ndGggPT09IG5ld0xlbmd0aCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGZpcnN0Q2hhbmdlID0gdGhpcy5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0dGhpcy5sZW5ndGggPSB0aGlzLmZyYWdtZW50cy5sZW5ndGggPSBuZXdMZW5ndGg7XG5cbiAgXHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHR9XG5cbiAgXHQvLyBQcmVwYXJlIG5ldyBmcmFnbWVudCBvcHRpb25zXG4gIFx0ZnJhZ21lbnRPcHRpb25zID0ge1xuICBcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUuZixcbiAgXHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdG93bmVyOiB0aGlzXG4gIFx0fTtcblxuICBcdC8vIEFkZCBhcyBtYW55IG5ldyBmcmFnbWVudHMgYXMgd2UgbmVlZCB0bywgb3IgYWRkIGJhY2sgZXhpc3RpbmdcbiAgXHQvLyAoZGV0YWNoZWQpIGZyYWdtZW50c1xuICBcdGZvciAoaSA9IGZpcnN0Q2hhbmdlOyBpIDwgbmV3TGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdGZyYWdtZW50ID0gcmVib3VuZEZyYWdtZW50c1tpXTtcblxuICBcdFx0aWYgKCFmcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLnB1c2goaSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnRzW2ldID0gZnJhZ21lbnQ7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gc2h1ZmZsZV9fYmxpbmRSZWJpbmQoZGVwKSB7XG4gIFx0Ly8gdGhlIGtleXBhdGggZG9lc24ndCBhY3R1YWxseSBtYXR0ZXIgaGVyZSBhcyBpdCB3b24ndCBoYXZlIGNoYW5nZWRcbiAgXHRkZXAucmViaW5kKFwiXCIsIFwiXCIpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9yZWJpbmQgPSBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdE11c3RhY2hlLnJlYmluZC5jYWxsKHRoaXMsIG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICB9O1xuXG4gIHZhciBTZWN0aW9uX3Byb3RvdHlwZV9yZW5kZXIgPSBTZWN0aW9uJHJlbmRlcjtcblxuICBmdW5jdGlvbiBTZWN0aW9uJHJlbmRlcigpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICBcdFx0cmV0dXJuIF90aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQoZi5yZW5kZXIoKSk7XG4gIFx0fSk7XG5cbiAgXHR0aGlzLnJlbmRlcmVkRnJhZ21lbnRzID0gdGhpcy5mcmFnbWVudHMuc2xpY2UoKTtcbiAgXHR0aGlzLmZyYWdtZW50c1RvUmVuZGVyID0gW107XG5cbiAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuICB9XG5cbiAgdmFyIHNldFZhbHVlID0gU2VjdGlvbiRzZXRWYWx1ZTtcblxuICBmdW5jdGlvbiBTZWN0aW9uJHNldFZhbHVlKHZhbHVlKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciB3cmFwcGVyLCBmcmFnbWVudE9wdGlvbnM7XG5cbiAgXHRpZiAodGhpcy51cGRhdGluZykge1xuICBcdFx0Ly8gSWYgYSBjaGlsZCBvZiB0aGlzIHNlY3Rpb24gY2F1c2VzIGEgcmUtZXZhbHVhdGlvbiAtIGZvciBleGFtcGxlLCBhblxuICBcdFx0Ly8gZXhwcmVzc2lvbiByZWZlcnMgdG8gYSBmdW5jdGlvbiB0aGF0IG11dGF0ZXMgdGhlIGFycmF5IHRoYXQgdGhpc1xuICBcdFx0Ly8gc2VjdGlvbiBkZXBlbmRzIG9uIC0gd2UnbGwgZW5kIHVwIHdpdGggYSBkb3VibGUgcmVuZGVyaW5nIGJ1ZyAoc2VlXG4gIFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzLzc0OCkuIFRoaXMgcHJldmVudHMgaXQuXG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cbiAgXHQvLyB3aXRoIHNlY3Rpb25zLCB3ZSBuZWVkIHRvIGdldCB0aGUgZmFrZSB2YWx1ZSBpZiB3ZSBoYXZlIGEgd3JhcHBlZCBvYmplY3RcbiAgXHRpZiAodGhpcy5rZXlwYXRoICYmICh3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkW3RoaXMua2V5cGF0aC5zdHJdKSkge1xuICBcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuICBcdH1cblxuICBcdC8vIElmIGFueSBmcmFnbWVudHMgYXJlIGF3YWl0aW5nIGNyZWF0aW9uIGFmdGVyIGEgc3BsaWNlLFxuICBcdC8vIHRoaXMgaXMgdGhlIHBsYWNlIHRvIGRvIGl0XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUubGVuZ3RoKSB7XG4gIFx0XHRmcmFnbWVudE9wdGlvbnMgPSB7XG4gIFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLmYgfHwgW10sXG4gIFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdFx0cEVsZW1lbnQ6IHRoaXMucEVsZW1lbnQsXG4gIFx0XHRcdG93bmVyOiB0aGlzXG4gIFx0XHR9O1xuXG4gIFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gIFx0XHRcdHZhciBmcmFnbWVudDtcblxuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IF90aGlzLmtleXBhdGguam9pbihpbmRleCk7XG4gIFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IGluZGV4O1xuXG4gIFx0XHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoZnJhZ21lbnRPcHRpb25zKTtcbiAgXHRcdFx0X3RoaXMuZnJhZ21lbnRzVG9SZW5kZXIucHVzaChfdGhpcy5mcmFnbWVudHNbaW5kZXhdID0gZnJhZ21lbnQpO1xuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUubGVuZ3RoID0gMDtcbiAgXHR9IGVsc2UgaWYgKHJlZXZhbHVhdGVTZWN0aW9uKHRoaXMsIHZhbHVlKSkge1xuICBcdFx0dGhpcy5idWJibGUoKTtcblxuICBcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR0aGlzLnZhbHVlID0gdmFsdWU7XG4gIFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgdmFsdWUsIG9iaikge1xuICBcdGlmICh2YWx1ZSA9PT0gU0VDVElPTl9FQUNIKSB7XG4gIFx0XHQvLyBtYWtlIHN1cmUgcmVmIHR5cGUgaXMgdXAgdG8gZGF0ZSBmb3Iga2V5IG9yIHZhbHVlIGluZGljZXNcbiAgXHRcdGlmIChzZWN0aW9uLmluZGV4UmVmcyAmJiBzZWN0aW9uLmluZGV4UmVmc1swXSkge1xuICBcdFx0XHR2YXIgcmVmID0gc2VjdGlvbi5pbmRleFJlZnNbMF07XG5cbiAgXHRcdFx0Ly8gd2hlbiBzd2l0Y2hpbmcgZmxhdm9ycywgbWFrZSBzdXJlIHRoZSBzZWN0aW9uIGdldHMgdXBkYXRlZFxuICBcdFx0XHRpZiAob2JqICYmIHJlZi50ID09PSBcImlcIiB8fCAhb2JqICYmIHJlZi50ID09PSBcImtcIikge1xuICBcdFx0XHRcdC8vIGlmIHN3aXRjaGluZyBmcm9tIG9iamVjdCB0byBsaXN0LCB1bmJpbmQgYWxsIG9mIHRoZSBvbGQgZnJhZ21lbnRzXG4gIFx0XHRcdFx0aWYgKCFvYmopIHtcbiAgXHRcdFx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gMDtcbiAgXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNsaWNlKDApO1xuICBcdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgXHRcdFx0XHRcdFx0cmV0dXJuIGYudW5iaW5kKCk7XG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZWYudCA9IG9iaiA/IFwia1wiIDogXCJpXCI7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0c2VjdGlvbi5jdXJyZW50U3VidHlwZSA9IHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZVNlY3Rpb24oc2VjdGlvbiwgdmFsdWUpIHtcbiAgXHR2YXIgZnJhZ21lbnRPcHRpb25zID0ge1xuICBcdFx0dGVtcGxhdGU6IHNlY3Rpb24udGVtcGxhdGUuZiB8fCBbXSxcbiAgXHRcdHJvb3Q6IHNlY3Rpb24ucm9vdCxcbiAgXHRcdHBFbGVtZW50OiBzZWN0aW9uLnBhcmVudEZyYWdtZW50LnBFbGVtZW50LFxuICBcdFx0b3duZXI6IHNlY3Rpb25cbiAgXHR9O1xuXG4gIFx0c2VjdGlvbi5oYXNDb250ZXh0ID0gdHJ1ZTtcblxuICBcdC8vIElmIHdlIGFscmVhZHkga25vdyB0aGUgc2VjdGlvbiB0eXBlLCBncmVhdFxuICBcdC8vIFRPRE8gY2FuIHRoaXMgYmUgb3B0aW1pc2VkPyBpLmUuIHBpY2sgYW4gcmVldmFsdWF0ZVNlY3Rpb24gZnVuY3Rpb24gZHVyaW5nIGluaXRcbiAgXHQvLyBhbmQgYXZvaWQgZG9pbmcgdGhpcyBlYWNoIHRpbWU/XG4gIFx0aWYgKHNlY3Rpb24uc3VidHlwZSkge1xuICBcdFx0c3dpdGNoIChzZWN0aW9uLnN1YnR5cGUpIHtcbiAgXHRcdFx0Y2FzZSBTRUNUSU9OX0lGOlxuICBcdFx0XHRcdHNlY3Rpb24uaGFzQ29udGV4dCA9IGZhbHNlO1xuICBcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmYWxzZSwgZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0XHRjYXNlIFNFQ1RJT05fVU5MRVNTOlxuICBcdFx0XHRcdHNlY3Rpb24uaGFzQ29udGV4dCA9IGZhbHNlO1xuICBcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCB0cnVlLCBmcmFnbWVudE9wdGlvbnMpO1xuXG4gIFx0XHRcdGNhc2UgU0VDVElPTl9XSVRIOlxuICBcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0XHRjYXNlIFNFQ1RJT05fSUZfV0lUSDpcbiAgXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsQ29udGV4dFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyk7XG5cbiAgXHRcdFx0Y2FzZSBTRUNUSU9OX0VBQ0g6XG4gIFx0XHRcdFx0aWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICBcdFx0XHRcdFx0Y2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgc2VjdGlvbi5zdWJ0eXBlLCB0cnVlKTtcbiAgXHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gRmFsbHRocm91Z2ggLSBpZiBpdCdzIGEgY29uZGl0aW9uYWwgb3IgYW4gYXJyYXkgd2UgbmVlZCB0byBjb250aW51ZVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIHRvIHdvcmsgb3V0IHdoYXQgc29ydCBvZiBzZWN0aW9uIHdlJ3JlIGRlYWxpbmcgd2l0aFxuICBcdHNlY3Rpb24ub3JkZXJlZCA9ICEhaXNBcnJheUxpa2UodmFsdWUpO1xuXG4gIFx0Ly8gT3JkZXJlZCBsaXN0IHNlY3Rpb25cbiAgXHRpZiAoc2VjdGlvbi5vcmRlcmVkKSB7XG4gIFx0XHRjaGFuZ2VDdXJyZW50U3VidHlwZShzZWN0aW9uLCBTRUNUSU9OX0VBQ0gsIGZhbHNlKTtcbiAgXHRcdHJldHVybiByZWV2YWx1YXRlTGlzdFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0Ly8gVW5vcmRlcmVkIGxpc3QsIG9yIGNvbnRleHRcbiAgXHRpZiAoaXNPYmplY3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHQvLyBJbmRleCByZWZlcmVuY2UgaW5kaWNhdGVzIHNlY3Rpb24gc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBsaXN0XG4gIFx0XHRpZiAoc2VjdGlvbi50ZW1wbGF0ZS5pKSB7XG4gIFx0XHRcdGNoYW5nZUN1cnJlbnRTdWJ0eXBlKHNlY3Rpb24sIFNFQ1RJT05fRUFDSCwgdHJ1ZSk7XG4gIFx0XHRcdHJldHVybiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIE90aGVyd2lzZSwgb2JqZWN0IHByb3ZpZGVzIGNvbnRleHQgZm9yIGNvbnRlbnRzXG4gIFx0XHRjaGFuZ2VDdXJyZW50U3VidHlwZShzZWN0aW9uLCBTRUNUSU9OX1dJVEgsIGZhbHNlKTtcbiAgXHRcdHJldHVybiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zKTtcbiAgXHR9XG5cbiAgXHQvLyBDb25kaXRpb25hbCBzZWN0aW9uXG4gIFx0Y2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgU0VDVElPTl9JRiwgZmFsc2UpO1xuICBcdHNlY3Rpb24uaGFzQ29udGV4dCA9IGZhbHNlO1xuICBcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmYWxzZSwgZnJhZ21lbnRPcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVMaXN0U2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zKSB7XG4gIFx0dmFyIGksIGxlbmd0aCwgZnJhZ21lbnQ7XG5cbiAgXHRsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgXHRpZiAobGVuZ3RoID09PSBzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0Ly8gTm90aGluZyB0byBkb1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdC8vIGlmIHRoZSBhcnJheSBpcyBzaG9ydGVyIHRoYW4gaXQgd2FzIHByZXZpb3VzbHksIHJlbW92ZSBpdGVtc1xuICBcdGlmIChsZW5ndGggPCBzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyID0gc2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKGxlbmd0aCwgc2VjdGlvbi5sZW5ndGggLSBsZW5ndGgpO1xuICBcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHR9XG5cbiAgXHQvLyBvdGhlcndpc2UuLi5cbiAgXHRlbHNlIHtcbiAgXHRcdGlmIChsZW5ndGggPiBzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0XHQvLyBhZGQgYW55IG5ldyBvbmVzXG4gIFx0XHRcdGZvciAoaSA9IHNlY3Rpb24ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0XHQvLyBhcHBlbmQgbGlzdCBpdGVtIHRvIGNvbnRleHQgc3RhY2tcbiAgXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aC5qb2luKGkpO1xuICBcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IGk7XG5cbiAgXHRcdFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKHNlY3Rpb24uZnJhZ21lbnRzW2ldID0gZnJhZ21lbnQpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0c2VjdGlvbi5sZW5ndGggPSBsZW5ndGg7XG4gIFx0cmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucykge1xuICBcdHZhciBpZCwgaSwgaGFzS2V5LCBmcmFnbWVudCwgY2hhbmdlZCwgZGVwcztcblxuICBcdGhhc0tleSA9IHNlY3Rpb24uaGFzS2V5IHx8IChzZWN0aW9uLmhhc0tleSA9IHt9KTtcblxuICBcdC8vIHJlbW92ZSBhbnkgZnJhZ21lbnRzIHRoYXQgc2hvdWxkIG5vIGxvbmdlciBleGlzdFxuICBcdGkgPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0ZnJhZ21lbnQgPSBzZWN0aW9uLmZyYWdtZW50c1tpXTtcblxuICBcdFx0aWYgKCEoZnJhZ21lbnQua2V5IGluIHZhbHVlKSkge1xuICBcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblxuICBcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLnB1c2goZnJhZ21lbnQpO1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoaSwgMSk7XG5cbiAgXHRcdFx0aGFzS2V5W2ZyYWdtZW50LmtleV0gPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBub3RpZnkgYW55IGRlcGVuZGVudHMgYWJvdXQgY2hhbmdlZCBpbmRpY2VzXG4gIFx0aSA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRmcmFnbWVudCA9IHNlY3Rpb24uZnJhZ21lbnRzW2ldO1xuXG4gIFx0XHRpZiAoZnJhZ21lbnQuaW5kZXggIT09IGkpIHtcbiAgXHRcdFx0ZnJhZ21lbnQuaW5kZXggPSBpO1xuICBcdFx0XHRpZiAoZGVwcyA9IGZyYWdtZW50LnJlZ2lzdGVyZWRJbmRleFJlZnMpIHtcbiAgXHRcdFx0XHRkZXBzLmZvckVhY2goc2V0VmFsdWVfX2JsaW5kUmViaW5kKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIGFkZCBhbnkgdGhhdCBoYXZlbid0IGJlZW4gY3JlYXRlZCB5ZXRcbiAgXHRpID0gc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoO1xuICBcdGZvciAoaWQgaW4gdmFsdWUpIHtcbiAgXHRcdGlmICghaGFzS2V5W2lkXSkge1xuICBcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblxuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aC5qb2luKGlkKTtcbiAgXHRcdFx0ZnJhZ21lbnRPcHRpb25zLmtleSA9IGlkO1xuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpKys7XG5cbiAgXHRcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudChmcmFnbWVudE9wdGlvbnMpO1xuXG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaChmcmFnbWVudCk7XG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzLnB1c2goZnJhZ21lbnQpO1xuICBcdFx0XHRoYXNLZXlbaWRdID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRzZWN0aW9uLmxlbmd0aCA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRyZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVDb25kaXRpb25hbENvbnRleHRTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpIHtcbiAgXHRpZiAodmFsdWUpIHtcbiAgXHRcdHJldHVybiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIHJlbW92ZVNlY3Rpb25GcmFnbWVudHMoc2VjdGlvbik7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucykge1xuICBcdHZhciBmcmFnbWVudDtcblxuICBcdC8vIC4uLnRoZW4gaWYgaXQgaXNuJ3QgcmVuZGVyZWQsIHJlbmRlciBpdCwgYWRkaW5nIHNlY3Rpb24ua2V5cGF0aCB0byB0aGUgY29udGV4dCBzdGFja1xuICBcdC8vIChpZiBpdCBpcyBhbHJlYWR5IHJlbmRlcmVkLCB0aGVuIGFueSBjaGlsZHJlbiBkZXBlbmRlbnQgb24gdGhlIGNvbnRleHQgc3RhY2tcbiAgXHQvLyB3aWxsIHVwZGF0ZSB0aGVtc2VsdmVzIHdpdGhvdXQgYW55IHByb21wdGluZylcbiAgXHRpZiAoIXNlY3Rpb24ubGVuZ3RoKSB7XG4gIFx0XHQvLyBhcHBlbmQgdGhpcyBzZWN0aW9uIHRvIHRoZSBjb250ZXh0IHN0YWNrXG4gIFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aDtcbiAgXHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IDA7XG5cbiAgXHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKHNlY3Rpb24uZnJhZ21lbnRzWzBdID0gZnJhZ21lbnQpO1xuICBcdFx0c2VjdGlvbi5sZW5ndGggPSAxO1xuXG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBpbnZlcnRlZCwgZnJhZ21lbnRPcHRpb25zKSB7XG4gIFx0dmFyIGRvUmVuZGVyLCBlbXB0eUFycmF5LCBlbXB0eU9iamVjdCwgZnJhZ21lbnQsIG5hbWU7XG5cbiAgXHRlbXB0eUFycmF5ID0gaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgXHRlbXB0eU9iamVjdCA9IGZhbHNlO1xuICBcdGlmICghaXNBcnJheUxpa2UodmFsdWUpICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICBcdFx0ZW1wdHlPYmplY3QgPSB0cnVlO1xuICBcdFx0Zm9yIChuYW1lIGluIHZhbHVlKSB7XG4gIFx0XHRcdGVtcHR5T2JqZWN0ID0gZmFsc2U7XG4gIFx0XHRcdGJyZWFrO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChpbnZlcnRlZCkge1xuICBcdFx0ZG9SZW5kZXIgPSBlbXB0eUFycmF5IHx8IGVtcHR5T2JqZWN0IHx8ICF2YWx1ZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0ZG9SZW5kZXIgPSB2YWx1ZSAmJiAhZW1wdHlBcnJheSAmJiAhZW1wdHlPYmplY3Q7XG4gIFx0fVxuXG4gIFx0aWYgKGRvUmVuZGVyKSB7XG4gIFx0XHRpZiAoIXNlY3Rpb24ubGVuZ3RoKSB7XG4gIFx0XHRcdC8vIG5vIGNoYW5nZSB0byBjb250ZXh0IHN0YWNrXG4gIFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IDA7XG5cbiAgXHRcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudChmcmFnbWVudE9wdGlvbnMpO1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goc2VjdGlvbi5mcmFnbWVudHNbMF0gPSBmcmFnbWVudCk7XG4gIFx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gMTtcblxuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHNlY3Rpb24ubGVuZ3RoID4gMSkge1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoMSk7XG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG5cbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiByZW1vdmVTZWN0aW9uRnJhZ21lbnRzKHNlY3Rpb24pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVNlY3Rpb25GcmFnbWVudHMoc2VjdGlvbikge1xuICBcdGlmIChzZWN0aW9uLmxlbmd0aCkge1xuICBcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyID0gc2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKDAsIHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aCkuZmlsdGVyKGlzUmVuZGVyZWQpO1xuICBcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHRcdHNlY3Rpb24ubGVuZ3RoID0gc2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5sZW5ndGggPSAwO1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gaXNSZW5kZXJlZChmcmFnbWVudCkge1xuICBcdHJldHVybiBmcmFnbWVudC5yZW5kZXJlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFZhbHVlX19ibGluZFJlYmluZChkZXApIHtcbiAgXHQvLyB0aGUga2V5cGF0aCBkb2Vzbid0IGFjdHVhbGx5IG1hdHRlciBoZXJlIGFzIGl0IHdvbid0IGhhdmUgY2hhbmdlZFxuICBcdGRlcC5yZWJpbmQoXCJcIiwgXCJcIik7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3RvU3RyaW5nID0gU2VjdGlvbiR0b1N0cmluZztcblxuICBmdW5jdGlvbiBTZWN0aW9uJHRvU3RyaW5nKGVzY2FwZSkge1xuICBcdHZhciBzdHIsIGksIGxlbjtcblxuICBcdHN0ciA9IFwiXCI7XG5cbiAgXHRpID0gMDtcbiAgXHRsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0c3RyICs9IHRoaXMuZnJhZ21lbnRzW2ldLnRvU3RyaW5nKGVzY2FwZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdW5iaW5kID0gU2VjdGlvbiR1bmJpbmQ7XG4gIGZ1bmN0aW9uIFNlY3Rpb24kdW5iaW5kKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0dGhpcy5mcmFnbWVudHNUb1JlbmRlci5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gIFx0XHRyZXR1cm4gcmVtb3ZlRnJvbUFycmF5KF90aGlzLmZyYWdtZW50cywgZik7XG4gIFx0fSk7XG4gIFx0dGhpcy5mcmFnbWVudHNUb1JlbmRlciA9IFtdO1xuICBcdHNoYXJlZF91bmJpbmQuY2FsbCh0aGlzKTtcblxuICBcdHRoaXMubGVuZ3RoID0gMDtcbiAgXHR0aGlzLnVuYm91bmQgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV91bnJlbmRlciA9IFNlY3Rpb24kdW5yZW5kZXI7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiR1bnJlbmRlcihzaG91bGREZXN0cm95KSB7XG4gIFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaChzaG91bGREZXN0cm95ID8gdW5yZW5kZXJBbmREZXN0cm95IDogcHJvdG90eXBlX3VucmVuZGVyX191bnJlbmRlcik7XG4gIFx0dGhpcy5yZW5kZXJlZEZyYWdtZW50cyA9IFtdO1xuICBcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucmVuZGVyQW5kRGVzdHJveShmcmFnbWVudCkge1xuICBcdGZyYWdtZW50LnVucmVuZGVyKHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvdG90eXBlX3VucmVuZGVyX191bnJlbmRlcihmcmFnbWVudCkge1xuICBcdGZyYWdtZW50LnVucmVuZGVyKGZhbHNlKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdXBkYXRlID0gU2VjdGlvbiR1cGRhdGU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiR1cGRhdGUoKSB7XG4gIFx0dmFyIGZyYWdtZW50LCByZW5kZXJJbmRleCwgcmVuZGVyZWRGcmFnbWVudHMsIGFuY2hvciwgdGFyZ2V0LCBpLCBsZW47XG5cbiAgXHQvLyBgdGhpcy5yZW5kZXJlZEZyYWdtZW50c2AgaXMgaW4gdGhlIG9yZGVyIG9mIHRoZSBwcmV2aW91cyByZW5kZXIuXG4gIFx0Ly8gSWYgZnJhZ21lbnRzIGhhdmUgc2h1ZmZsZWQgYWJvdXQsIHRoaXMgYWxsb3dzIHVzIHRvIHF1aWNrbHlcbiAgXHQvLyByZWluc2VydCB0aGVtIGluIHRoZSBjb3JyZWN0IHBsYWNlXG4gIFx0cmVuZGVyZWRGcmFnbWVudHMgPSB0aGlzLnJlbmRlcmVkRnJhZ21lbnRzO1xuXG4gIFx0Ly8gUmVtb3ZlIGZyYWdtZW50cyB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgZm9yIGRlc3RydWN0aW9uXG4gIFx0d2hpbGUgKGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudHNUb1VucmVuZGVyLnBvcCgpKSB7XG4gIFx0XHRmcmFnbWVudC51bnJlbmRlcih0cnVlKTtcbiAgXHRcdHJlbmRlcmVkRnJhZ21lbnRzLnNwbGljZShyZW5kZXJlZEZyYWdtZW50cy5pbmRleE9mKGZyYWdtZW50KSwgMSk7XG4gIFx0fVxuXG4gIFx0Ly8gUmVuZGVyIG5ldyBmcmFnbWVudHMgKGJ1dCBkb24ndCBpbnNlcnQgdGhlbSB5ZXQpXG4gIFx0d2hpbGUgKGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudHNUb1JlbmRlci5zaGlmdCgpKSB7XG4gIFx0XHRmcmFnbWVudC5yZW5kZXIoKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0dGFyZ2V0ID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG4gIFx0fVxuXG4gIFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0ZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50c1tpXTtcbiAgXHRcdHJlbmRlckluZGV4ID0gcmVuZGVyZWRGcmFnbWVudHMuaW5kZXhPZihmcmFnbWVudCwgaSk7IC8vIHNlYXJjaCBmcm9tIGN1cnJlbnQgaW5kZXggLSBpdCdzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHNhbWUgb3IgaGlnaGVyXG5cbiAgXHRcdGlmIChyZW5kZXJJbmRleCA9PT0gaSkge1xuICBcdFx0XHQvLyBhbHJlYWR5IGluIHRoZSByaWdodCBwbGFjZS4gaW5zZXJ0IGFjY3VtdWxhdGVkIG5vZGVzIChpZiBhbnkpIGFuZCBjYXJyeSBvblxuICBcdFx0XHRpZiAodGhpcy5kb2NGcmFnLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0YW5jaG9yID0gZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG4gIFx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLmRvY0ZyYWcsIGFuY2hvcik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKGZyYWdtZW50LmRldGFjaCgpKTtcblxuICBcdFx0Ly8gdXBkYXRlIHJlbmRlcmVkRnJhZ21lbnRzXG4gIFx0XHRpZiAocmVuZGVySW5kZXggIT09IC0xKSB7XG4gIFx0XHRcdHJlbmRlcmVkRnJhZ21lbnRzLnNwbGljZShyZW5kZXJJbmRleCwgMSk7XG4gIFx0XHR9XG4gIFx0XHRyZW5kZXJlZEZyYWdtZW50cy5zcGxpY2UoaSwgMCwgZnJhZ21lbnQpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLnJlbmRlcmVkICYmIHRoaXMuZG9jRnJhZy5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICBcdFx0YW5jaG9yID0gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuZG9jRnJhZywgYW5jaG9yKTtcbiAgXHR9XG5cbiAgXHQvLyBTYXZlIHRoZSByZW5kZXJpbmcgb3JkZXIgZm9yIG5leHQgdGltZVxuICBcdHRoaXMucmVuZGVyZWRGcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cy5zbGljZSgpO1xuICB9XG5cbiAgdmFyIFNlY3Rpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMudHlwZSA9IFNFQ1RJT047XG4gIFx0dGhpcy5zdWJ0eXBlID0gdGhpcy5jdXJyZW50U3VidHlwZSA9IG9wdGlvbnMudGVtcGxhdGUubjtcbiAgXHR0aGlzLmludmVydGVkID0gdGhpcy5zdWJ0eXBlID09PSBTRUNUSU9OX1VOTEVTUztcblxuICBcdHRoaXMucEVsZW1lbnQgPSBvcHRpb25zLnBFbGVtZW50O1xuXG4gIFx0dGhpcy5mcmFnbWVudHMgPSBbXTtcbiAgXHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlID0gW107XG4gIFx0dGhpcy5mcmFnbWVudHNUb1JlbmRlciA9IFtdO1xuICBcdHRoaXMuZnJhZ21lbnRzVG9VbnJlbmRlciA9IFtdO1xuXG4gIFx0aWYgKG9wdGlvbnMudGVtcGxhdGUuaSkge1xuICBcdFx0dGhpcy5pbmRleFJlZnMgPSBvcHRpb25zLnRlbXBsYXRlLmkuc3BsaXQoXCIsXCIpLm1hcChmdW5jdGlvbiAoaywgaSkge1xuICBcdFx0XHRyZXR1cm4geyBuOiBrLCB0OiBpID09PSAwID8gXCJrXCIgOiBcImlcIiB9O1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5yZW5kZXJlZEZyYWdtZW50cyA9IFtdO1xuXG4gIFx0dGhpcy5sZW5ndGggPSAwOyAvLyBudW1iZXIgb2YgdGltZXMgdGhpcyBzZWN0aW9uIGlzIHJlbmRlcmVkXG5cbiAgXHRNdXN0YWNoZS5pbml0KHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIFNlY3Rpb24ucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogU2VjdGlvbl9wcm90b3R5cGVfYnViYmxlLFxuICBcdGRldGFjaDogU2VjdGlvbl9wcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IGZpbmQsXG4gIFx0ZmluZEFsbDogZmluZEFsbCxcbiAgXHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcbiAgXHRmaW5kTmV4dE5vZGU6IGZpbmROZXh0Tm9kZSxcbiAgXHRmaXJzdE5vZGU6IGZpcnN0Tm9kZSxcbiAgXHRnZXRJbmRleFJlZjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgXHRcdGlmICh0aGlzLmluZGV4UmVmcykge1xuICBcdFx0XHR2YXIgaSA9IHRoaXMuaW5kZXhSZWZzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdHZhciByZWYgPSB0aGlzLmluZGV4UmVmc1tpXTtcbiAgXHRcdFx0XHRpZiAocmVmLm4gPT09IG5hbWUpIHtcbiAgXHRcdFx0XHRcdHJldHVybiByZWY7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcbiAgXHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG4gIFx0c2h1ZmZsZTogc2h1ZmZsZSxcbiAgXHRyZWJpbmQ6IHByb3RvdHlwZV9yZWJpbmQsXG4gIFx0cmVuZGVyOiBTZWN0aW9uX3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcbiAgXHRzZXRWYWx1ZTogc2V0VmFsdWUsXG4gIFx0dG9TdHJpbmc6IHByb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IHByb3RvdHlwZV91bmJpbmQsXG4gIFx0dW5yZW5kZXI6IHByb3RvdHlwZV91bnJlbmRlcixcbiAgXHR1cGRhdGU6IHByb3RvdHlwZV91cGRhdGVcbiAgfTtcblxuICB2YXIgX1NlY3Rpb24gPSBTZWN0aW9uO1xuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX2RldGFjaCA9IFRyaXBsZSRkZXRhY2g7XG5cbiAgZnVuY3Rpb24gVHJpcGxlJGRldGFjaCgpIHtcbiAgXHR2YXIgbGVuLCBpO1xuXG4gIFx0aWYgKHRoaXMuZG9jRnJhZykge1xuICBcdFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0dGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKHRoaXMubm9kZXNbaV0pO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuICBcdH1cbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX2ZpbmQgPSBUcmlwbGUkZmluZDtcbiAgZnVuY3Rpb24gVHJpcGxlJGZpbmQoc2VsZWN0b3IpIHtcbiAgXHR2YXIgaSwgbGVuLCBub2RlLCBxdWVyeVJlc3VsdDtcblxuICBcdGxlbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0bm9kZSA9IHRoaXMubm9kZXNbaV07XG5cbiAgXHRcdGlmIChub2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gIFx0XHRcdGNvbnRpbnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobWF0Y2hlcyhub2RlLCBzZWxlY3RvcikpIHtcbiAgXHRcdFx0cmV0dXJuIG5vZGU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChxdWVyeVJlc3VsdCA9IG5vZGUucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpIHtcbiAgXHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfZmluZEFsbCA9IFRyaXBsZSRmaW5kQWxsO1xuICBmdW5jdGlvbiBUcmlwbGUkZmluZEFsbChzZWxlY3RvciwgcXVlcnlSZXN1bHQpIHtcbiAgXHR2YXIgaSwgbGVuLCBub2RlLCBxdWVyeUFsbFJlc3VsdCwgbnVtTm9kZXMsIGo7XG5cbiAgXHRsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG5vZGUgPSB0aGlzLm5vZGVzW2ldO1xuXG4gIFx0XHRpZiAobm9kZS5ub2RlVHlwZSAhPT0gMSkge1xuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG1hdGNoZXMobm9kZSwgc2VsZWN0b3IpKSB7XG4gIFx0XHRcdHF1ZXJ5UmVzdWx0LnB1c2gobm9kZSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChxdWVyeUFsbFJlc3VsdCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpIHtcbiAgXHRcdFx0bnVtTm9kZXMgPSBxdWVyeUFsbFJlc3VsdC5sZW5ndGg7XG4gIFx0XHRcdGZvciAoaiA9IDA7IGogPCBudW1Ob2RlczsgaiArPSAxKSB7XG4gIFx0XHRcdFx0cXVlcnlSZXN1bHQucHVzaChxdWVyeUFsbFJlc3VsdFtqXSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV9maXJzdE5vZGUgPSBUcmlwbGUkZmlyc3ROb2RlO1xuXG4gIGZ1bmN0aW9uIFRyaXBsZSRmaXJzdE5vZGUoKSB7XG4gIFx0aWYgKHRoaXMucmVuZGVyZWQgJiYgdGhpcy5ub2Rlc1swXSkge1xuICBcdFx0cmV0dXJuIHRoaXMubm9kZXNbMF07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICB9XG5cbiAgdmFyIGVsZW1lbnRDYWNoZSA9IHt9LFxuICAgICAgaWVCdWcsXG4gICAgICBpZUJsYWNrbGlzdDtcblxuICB0cnkge1xuICBcdGNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiKS5pbm5lckhUTUwgPSBcImZvb1wiO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgXHRpZUJ1ZyA9IHRydWU7XG5cbiAgXHRpZUJsYWNrbGlzdCA9IHtcbiAgXHRcdFRBQkxFOiBbXCI8dGFibGUgY2xhc3M9XFxcInhcXFwiPlwiLCBcIjwvdGFibGU+XCJdLFxuICBcdFx0VEhFQUQ6IFtcIjx0YWJsZT48dGhlYWQgY2xhc3M9XFxcInhcXFwiPlwiLCBcIjwvdGhlYWQ+PC90YWJsZT5cIl0sXG4gIFx0XHRUQk9EWTogW1wiPHRhYmxlPjx0Ym9keSBjbGFzcz1cXFwieFxcXCI+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiXSxcbiAgXHRcdFRSOiBbXCI8dGFibGU+PHRyIGNsYXNzPVxcXCJ4XFxcIj5cIiwgXCI8L3RyPjwvdGFibGU+XCJdLFxuICBcdFx0U0VMRUNUOiBbXCI8c2VsZWN0IGNsYXNzPVxcXCJ4XFxcIj5cIiwgXCI8L3NlbGVjdD5cIl1cbiAgXHR9O1xuICB9XG5cbiAgdmFyIGluc2VydEh0bWwgPSBmdW5jdGlvbiAoaHRtbCwgbm9kZSwgZG9jRnJhZykge1xuICBcdHZhciBjb250YWluZXIsXG4gIFx0ICAgIG5vZGVzID0gW10sXG4gIFx0ICAgIHdyYXBwZXIsXG4gIFx0ICAgIHNlbGVjdGVkT3B0aW9uLFxuICBcdCAgICBjaGlsZCxcbiAgXHQgICAgaTtcblxuICBcdC8vIHJlbmRlciAwIGFuZCBmYWxzZVxuICBcdGlmIChodG1sICE9IG51bGwgJiYgaHRtbCAhPT0gXCJcIikge1xuICBcdFx0aWYgKGllQnVnICYmICh3cmFwcGVyID0gaWVCbGFja2xpc3Rbbm9kZS50YWdOYW1lXSkpIHtcbiAgXHRcdFx0Y29udGFpbmVyID0gZWxlbWVudChcIkRJVlwiKTtcbiAgXHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IHdyYXBwZXJbMF0gKyBodG1sICsgd3JhcHBlclsxXTtcbiAgXHRcdFx0Y29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIueFwiKTtcblxuICBcdFx0XHRpZiAoY29udGFpbmVyLnRhZ05hbWUgPT09IFwiU0VMRUNUXCIpIHtcbiAgXHRcdFx0XHRzZWxlY3RlZE9wdGlvbiA9IGNvbnRhaW5lci5vcHRpb25zW2NvbnRhaW5lci5zZWxlY3RlZEluZGV4XTtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5zdmcpIHtcbiAgXHRcdFx0Y29udGFpbmVyID0gZWxlbWVudChcIkRJVlwiKTtcbiAgXHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IFwiPHN2ZyBjbGFzcz1cXFwieFxcXCI+XCIgKyBodG1sICsgXCI8L3N2Zz5cIjtcbiAgXHRcdFx0Y29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIueFwiKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQobm9kZS50YWdOYW1lKTtcbiAgXHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgXHRcdFx0aWYgKGNvbnRhaW5lci50YWdOYW1lID09PSBcIlNFTEVDVFwiKSB7XG4gIFx0XHRcdFx0c2VsZWN0ZWRPcHRpb24gPSBjb250YWluZXIub3B0aW9uc1tjb250YWluZXIuc2VsZWN0ZWRJbmRleF07XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0d2hpbGUgKGNoaWxkID0gY29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgXHRcdFx0bm9kZXMucHVzaChjaGlsZCk7XG4gIFx0XHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBUaGlzIGlzIHJlYWxseSBhbm5veWluZy4gRXh0cmFjdGluZyA8b3B0aW9uPiBub2RlcyBmcm9tIHRoZVxuICBcdFx0Ly8gdGVtcG9yYXJ5IGNvbnRhaW5lciA8c2VsZWN0PiBjYXVzZXMgdGhlIHJlbWFpbmluZyBvbmVzIHRvXG4gIFx0XHQvLyBiZWNvbWUgc2VsZWN0ZWQuIFNvIG5vdyB3ZSBoYXZlIHRvIGRlc2VsZWN0IHRoZW0uIElFOCwgeW91XG4gIFx0XHQvLyBhbWF6ZSBtZS4gWW91IHJlYWxseSBkb1xuICBcdFx0Ly8gLi4uYW5kIG5vdyBDaHJvbWUgdG9vXG4gIFx0XHRpZiAobm9kZS50YWdOYW1lID09PSBcIlNFTEVDVFwiKSB7XG4gIFx0XHRcdGkgPSBub2Rlcy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRpZiAobm9kZXNbaV0gIT09IHNlbGVjdGVkT3B0aW9uKSB7XG4gIFx0XHRcdFx0XHRub2Rlc1tpXS5zZWxlY3RlZCA9IGZhbHNlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBub2RlcztcbiAgfTtcblxuICBmdW5jdGlvbiBlbGVtZW50KHRhZ05hbWUpIHtcbiAgXHRyZXR1cm4gZWxlbWVudENhY2hlW3RhZ05hbWVdIHx8IChlbGVtZW50Q2FjaGVbdGFnTmFtZV0gPSBjcmVhdGVFbGVtZW50KHRhZ05hbWUpKTtcbiAgfVxuXG4gIHZhciBoZWxwZXJzX3VwZGF0ZVNlbGVjdCA9IHVwZGF0ZVNlbGVjdDtcblxuICBmdW5jdGlvbiB1cGRhdGVTZWxlY3QocGFyZW50RWxlbWVudCkge1xuICBcdHZhciBzZWxlY3RlZE9wdGlvbnMsIG9wdGlvbiwgdmFsdWU7XG5cbiAgXHRpZiAoIXBhcmVudEVsZW1lbnQgfHwgcGFyZW50RWxlbWVudC5uYW1lICE9PSBcInNlbGVjdFwiIHx8ICFwYXJlbnRFbGVtZW50LmJpbmRpbmcpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRzZWxlY3RlZE9wdGlvbnMgPSB0b0FycmF5KHBhcmVudEVsZW1lbnQubm9kZS5vcHRpb25zKS5maWx0ZXIoaXNTZWxlY3RlZCk7XG5cbiAgXHQvLyBJZiBvbmUgb2YgdGhlbSBoYWQgYSBgc2VsZWN0ZWRgIGF0dHJpYnV0ZSwgd2UgbmVlZCB0byBzeW5jXG4gIFx0Ly8gdGhlIG1vZGVsIHRvIHRoZSB2aWV3XG4gIFx0aWYgKHBhcmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikpIHtcbiAgXHRcdHZhbHVlID0gc2VsZWN0ZWRPcHRpb25zLm1hcChmdW5jdGlvbiAobykge1xuICBcdFx0XHRyZXR1cm4gby52YWx1ZTtcbiAgXHRcdH0pO1xuICBcdH0gZWxzZSBpZiAob3B0aW9uID0gc2VsZWN0ZWRPcHRpb25zWzBdKSB7XG4gIFx0XHR2YWx1ZSA9IG9wdGlvbi52YWx1ZTtcbiAgXHR9XG5cbiAgXHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0cGFyZW50RWxlbWVudC5iaW5kaW5nLnNldFZhbHVlKHZhbHVlKTtcbiAgXHR9XG5cbiAgXHRwYXJlbnRFbGVtZW50LmJ1YmJsZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTZWxlY3RlZChvcHRpb24pIHtcbiAgXHRyZXR1cm4gb3B0aW9uLnNlbGVjdGVkO1xuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfcmVuZGVyID0gVHJpcGxlJHJlbmRlcjtcbiAgZnVuY3Rpb24gVHJpcGxlJHJlbmRlcigpIHtcbiAgXHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHJlbmRlciBhbiBpdGVtIHRoYXQgd2FzIGFscmVhZHkgcmVuZGVyZWRcIik7XG4gIFx0fVxuXG4gIFx0dGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBcdHRoaXMubm9kZXMgPSBpbnNlcnRIdG1sKHRoaXMudmFsdWUsIHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpLCB0aGlzLmRvY0ZyYWcpO1xuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gd2UncmUgaW5zZXJ0aW5nIHRoZSBjb250ZW50cyBvZiBhIDxzZWxlY3Q+XG4gIFx0aGVscGVyc191cGRhdGVTZWxlY3QodGhpcy5wRWxlbWVudCk7XG5cbiAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9zZXRWYWx1ZSA9IFRyaXBsZSRzZXRWYWx1ZTtcbiAgZnVuY3Rpb24gVHJpcGxlJHNldFZhbHVlKHZhbHVlKSB7XG4gIFx0dmFyIHdyYXBwZXI7XG5cbiAgXHQvLyBUT0RPIGlzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBhcHByb2FjaCB0aGlzP1xuICBcdGlmICh3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkW3RoaXMua2V5cGF0aC5zdHJdKSB7XG4gIFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG4gIFx0fVxuXG4gIFx0aWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gIFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG4gIFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXG4gIFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX3RvU3RyaW5nID0gVHJpcGxlJHRvU3RyaW5nO1xuICBmdW5jdGlvbiBUcmlwbGUkdG9TdHJpbmcoKSB7XG4gIFx0cmV0dXJuIHRoaXMudmFsdWUgIT0gdW5kZWZpbmVkID8gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyhcIlwiICsgdGhpcy52YWx1ZSkgOiBcIlwiO1xuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfdW5yZW5kZXIgPSBUcmlwbGUkdW5yZW5kZXI7XG4gIGZ1bmN0aW9uIFRyaXBsZSR1bnJlbmRlcihzaG91bGREZXN0cm95KSB7XG4gIFx0aWYgKHRoaXMucmVuZGVyZWQgJiYgc2hvdWxkRGVzdHJveSkge1xuICBcdFx0dGhpcy5ub2Rlcy5mb3JFYWNoKGRldGFjaE5vZGUpO1xuICBcdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICBcdH1cblxuICBcdC8vIFRPRE8gdXBkYXRlIGxpdmUgcXVlcmllc1xuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfdXBkYXRlID0gVHJpcGxlJHVwZGF0ZTtcbiAgZnVuY3Rpb24gVHJpcGxlJHVwZGF0ZSgpIHtcbiAgXHR2YXIgbm9kZSwgcGFyZW50Tm9kZTtcblxuICBcdGlmICghdGhpcy5yZW5kZXJlZCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIFJlbW92ZSBleGlzdGluZyBub2Rlc1xuICBcdHdoaWxlICh0aGlzLm5vZGVzICYmIHRoaXMubm9kZXMubGVuZ3RoKSB7XG4gIFx0XHRub2RlID0gdGhpcy5ub2Rlcy5wb3AoKTtcbiAgXHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgXHR9XG5cbiAgXHQvLyBJbnNlcnQgbmV3IG5vZGVzXG4gIFx0cGFyZW50Tm9kZSA9IHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpO1xuXG4gIFx0dGhpcy5ub2RlcyA9IGluc2VydEh0bWwodGhpcy52YWx1ZSwgcGFyZW50Tm9kZSwgdGhpcy5kb2NGcmFnKTtcbiAgXHRwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmRvY0ZyYWcsIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpKTtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHdlJ3JlIGluc2VydGluZyB0aGUgY29udGVudHMgb2YgYSA8c2VsZWN0PlxuICBcdGhlbHBlcnNfdXBkYXRlU2VsZWN0KHRoaXMucEVsZW1lbnQpO1xuICB9XG5cbiAgdmFyIFRyaXBsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy50eXBlID0gVFJJUExFO1xuICBcdE11c3RhY2hlLmluaXQodGhpcywgb3B0aW9ucyk7XG4gIH07XG5cbiAgVHJpcGxlLnByb3RvdHlwZSA9IHtcbiAgXHRkZXRhY2g6IFRyaXBsZV9wcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IFRyaXBsZV9wcm90b3R5cGVfZmluZCxcbiAgXHRmaW5kQWxsOiBUcmlwbGVfcHJvdG90eXBlX2ZpbmRBbGwsXG4gIFx0Zmlyc3ROb2RlOiBUcmlwbGVfcHJvdG90eXBlX2ZpcnN0Tm9kZSxcbiAgXHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG4gIFx0cmViaW5kOiBNdXN0YWNoZS5yZWJpbmQsXG4gIFx0cmVuZGVyOiBUcmlwbGVfcHJvdG90eXBlX3JlbmRlcixcbiAgXHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuICBcdHNldFZhbHVlOiBwcm90b3R5cGVfc2V0VmFsdWUsXG4gIFx0dG9TdHJpbmc6IFRyaXBsZV9wcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBzaGFyZWRfdW5iaW5kLFxuICBcdHVucmVuZGVyOiBUcmlwbGVfcHJvdG90eXBlX3VucmVuZGVyLFxuICBcdHVwZGF0ZTogVHJpcGxlX3Byb3RvdHlwZV91cGRhdGVcbiAgfTtcblxuICB2YXIgX1RyaXBsZSA9IFRyaXBsZTtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfYnViYmxlID0gZnVuY3Rpb24gKCkge1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG4gIH07XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2RldGFjaCA9IEVsZW1lbnQkZGV0YWNoO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnQkZGV0YWNoKCkge1xuICBcdHZhciBub2RlID0gdGhpcy5ub2RlLFxuICBcdCAgICBwYXJlbnROb2RlO1xuXG4gIFx0aWYgKG5vZGUpIHtcbiAgXHRcdC8vIG5lZWQgdG8gY2hlY2sgZm9yIHBhcmVudCBub2RlIC0gRE9NIG1heSBoYXZlIGJlZW4gYWx0ZXJlZFxuICBcdFx0Ly8gYnkgc29tZXRoaW5nIG90aGVyIHRoYW4gUmFjdGl2ZSEgZS5nLiBqUXVlcnkgVUkuLi5cbiAgXHRcdGlmIChwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gIFx0XHRcdHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBub2RlO1xuICBcdH1cbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maW5kID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0aWYgKCF0aGlzLm5vZGUpIHtcbiAgXHRcdC8vIHRoaXMgZWxlbWVudCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXRcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmIChtYXRjaGVzKHRoaXMubm9kZSwgc2VsZWN0b3IpKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmZyYWdtZW50ICYmIHRoaXMuZnJhZ21lbnQuZmluZCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZChzZWxlY3Rvcik7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maW5kQWxsID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdC8vIEFkZCB0aGlzIG5vZGUgdG8gdGhlIHF1ZXJ5LCBpZiBhcHBsaWNhYmxlLCBhbmQgcmVnaXN0ZXIgdGhlXG4gIFx0Ly8gcXVlcnkgb24gdGhpcyBlbGVtZW50XG4gIFx0aWYgKHF1ZXJ5Ll90ZXN0KHRoaXMsIHRydWUpICYmIHF1ZXJ5LmxpdmUpIHtcbiAgXHRcdCh0aGlzLmxpdmVRdWVyaWVzIHx8ICh0aGlzLmxpdmVRdWVyaWVzID0gW10pKS5wdXNoKHF1ZXJ5KTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KHNlbGVjdG9yKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSA9IEVsZW1lbnQkZmluZE5leHROb2RlO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnQkZmluZE5leHROb2RlKCkge1xuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2ZpcnN0Tm9kZSA9IEVsZW1lbnQkZmlyc3ROb2RlO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnQkZmlyc3ROb2RlKCkge1xuICBcdHJldHVybiB0aGlzLm5vZGU7XG4gIH1cblxuICB2YXIgZ2V0QXR0cmlidXRlID0gRWxlbWVudCRnZXRBdHRyaWJ1dGU7XG5cbiAgZnVuY3Rpb24gRWxlbWVudCRnZXRBdHRyaWJ1dGUobmFtZSkge1xuICBcdGlmICghdGhpcy5hdHRyaWJ1dGVzIHx8ICF0aGlzLmF0dHJpYnV0ZXNbbmFtZV0pIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW25hbWVdLnZhbHVlO1xuICB9XG5cbiAgdmFyIHRydXRoeSA9IC9edHJ1ZXxvbnx5ZXN8MSQvaTtcbiAgdmFyIHByb2Nlc3NCaW5kaW5nQXR0cmlidXRlc19faXNOdW1lcmljID0gL15bMC05XSskLztcblxuICB2YXIgcHJvY2Vzc0JpbmRpbmdBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRlbXBsYXRlKSB7XG4gIFx0dmFyIHZhbCwgYXR0cnMsIGF0dHJpYnV0ZXM7XG5cbiAgXHRhdHRyaWJ1dGVzID0gdGVtcGxhdGUuYSB8fCB7fTtcbiAgXHRhdHRycyA9IHt9O1xuXG4gIFx0Ly8gYXR0cmlidXRlcyB0aGF0IGFyZSBwcmVzZW50IGJ1dCBkb24ndCBoYXZlIGEgdmFsdWUgKD0pXG4gIFx0Ly8gd2lsbCBiZSBzZXQgdG8gdGhlIG51bWJlciAwLCB3aGljaCB3ZSBjb25kaWRlciB0byBiZSB0cnVlXG4gIFx0Ly8gdGhlIHN0cmluZyAnMCcsIGhvd2V2ZXIgaXMgZmFsc2VcblxuICBcdHZhbCA9IGF0dHJpYnV0ZXMudHdvd2F5O1xuICBcdGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0YXR0cnMudHdvd2F5ID0gdmFsID09PSAwIHx8IHRydXRoeS50ZXN0KHZhbCk7XG4gIFx0fVxuXG4gIFx0dmFsID0gYXR0cmlidXRlcy5sYXp5O1xuICBcdGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0Ly8gY2hlY2sgZm9yIHRpbWVvdXQgdmFsdWVcbiAgXHRcdGlmICh2YWwgIT09IDAgJiYgcHJvY2Vzc0JpbmRpbmdBdHRyaWJ1dGVzX19pc051bWVyaWMudGVzdCh2YWwpKSB7XG4gIFx0XHRcdGF0dHJzLmxhenkgPSBwYXJzZUludCh2YWwpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0YXR0cnMubGF6eSA9IHZhbCA9PT0gMCB8fCB0cnV0aHkudGVzdCh2YWwpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBhdHRycztcbiAgfTtcblxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV9idWJibGUgPSBBdHRyaWJ1dGUkYnViYmxlO1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkYnViYmxlKCkge1xuICBcdHZhciB2YWx1ZSA9IHRoaXMudXNlUHJvcGVydHkgfHwgIXRoaXMucmVuZGVyZWQgPyB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCkgOiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCk7XG5cbiAgXHQvLyBUT0RPIHRoaXMgY2FuIHJlZ2lzdGVyIHRoZSBhdHRyaWJ1dGUgbXVsdGlwbGUgdGltZXMgKHNlZSByZW5kZXIgdGVzdFxuICBcdC8vICdBdHRyaWJ1dGUgd2l0aCBuZXN0ZWQgbXVzdGFjaGVzJylcbiAgXHRpZiAoIWlzRXF1YWwodmFsdWUsIHRoaXMudmFsdWUpKSB7XG5cbiAgXHRcdC8vIE5lZWQgdG8gY2xlYXIgb2xkIGlkIGZyb20gcmFjdGl2ZS5ub2Rlc1xuICBcdFx0aWYgKHRoaXMubmFtZSA9PT0gXCJpZFwiICYmIHRoaXMudmFsdWUpIHtcbiAgXHRcdFx0ZGVsZXRlIHRoaXMucm9vdC5ub2Rlc1t0aGlzLnZhbHVlXTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0XHRpZiAodGhpcy5uYW1lID09PSBcInZhbHVlXCIgJiYgdGhpcy5ub2RlKSB7XG4gIFx0XHRcdC8vIFdlIG5lZWQgdG8gc3RvcmUgdGhlIHZhbHVlIG9uIHRoZSBET00gbGlrZSB0aGlzIHNvIHdlXG4gIFx0XHRcdC8vIGNhbiByZXRyaWV2ZSBpdCBsYXRlciB3aXRob3V0IGl0IGJlaW5nIGNvZXJjZWQgdG8gYSBzdHJpbmdcbiAgXHRcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIHN2Z0NhbWVsQ2FzZUVsZW1lbnRzLCBzdmdDYW1lbENhc2VBdHRyaWJ1dGVzLCBjcmVhdGVNYXAsIG1hcDtcbiAgc3ZnQ2FtZWxDYXNlRWxlbWVudHMgPSBcImFsdEdseXBoIGFsdEdseXBoRGVmIGFsdEdseXBoSXRlbSBhbmltYXRlQ29sb3IgYW5pbWF0ZU1vdGlvbiBhbmltYXRlVHJhbnNmb3JtIGNsaXBQYXRoIGZlQmxlbmQgZmVDb2xvck1hdHJpeCBmZUNvbXBvbmVudFRyYW5zZmVyIGZlQ29tcG9zaXRlIGZlQ29udm9sdmVNYXRyaXggZmVEaWZmdXNlTGlnaHRpbmcgZmVEaXNwbGFjZW1lbnRNYXAgZmVEaXN0YW50TGlnaHQgZmVGbG9vZCBmZUZ1bmNBIGZlRnVuY0IgZmVGdW5jRyBmZUZ1bmNSIGZlR2F1c3NpYW5CbHVyIGZlSW1hZ2UgZmVNZXJnZSBmZU1lcmdlTm9kZSBmZU1vcnBob2xvZ3kgZmVPZmZzZXQgZmVQb2ludExpZ2h0IGZlU3BlY3VsYXJMaWdodGluZyBmZVNwb3RMaWdodCBmZVRpbGUgZmVUdXJidWxlbmNlIGZvcmVpZ25PYmplY3QgZ2x5cGhSZWYgbGluZWFyR3JhZGllbnQgcmFkaWFsR3JhZGllbnQgdGV4dFBhdGggdmtlcm5cIi5zcGxpdChcIiBcIik7XG4gIHN2Z0NhbWVsQ2FzZUF0dHJpYnV0ZXMgPSBcImF0dHJpYnV0ZU5hbWUgYXR0cmlidXRlVHlwZSBiYXNlRnJlcXVlbmN5IGJhc2VQcm9maWxlIGNhbGNNb2RlIGNsaXBQYXRoVW5pdHMgY29udGVudFNjcmlwdFR5cGUgY29udGVudFN0eWxlVHlwZSBkaWZmdXNlQ29uc3RhbnQgZWRnZU1vZGUgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCBmaWx0ZXJSZXMgZmlsdGVyVW5pdHMgZ2x5cGhSZWYgZ3JhZGllbnRUcmFuc2Zvcm0gZ3JhZGllbnRVbml0cyBrZXJuZWxNYXRyaXgga2VybmVsVW5pdExlbmd0aCBrZXlQb2ludHMga2V5U3BsaW5lcyBrZXlUaW1lcyBsZW5ndGhBZGp1c3QgbGltaXRpbmdDb25lQW5nbGUgbWFya2VySGVpZ2h0IG1hcmtlclVuaXRzIG1hcmtlcldpZHRoIG1hc2tDb250ZW50VW5pdHMgbWFza1VuaXRzIG51bU9jdGF2ZXMgcGF0aExlbmd0aCBwYXR0ZXJuQ29udGVudFVuaXRzIHBhdHRlcm5UcmFuc2Zvcm0gcGF0dGVyblVuaXRzIHBvaW50c0F0WCBwb2ludHNBdFkgcG9pbnRzQXRaIHByZXNlcnZlQWxwaGEgcHJlc2VydmVBc3BlY3RSYXRpbyBwcmltaXRpdmVVbml0cyByZWZYIHJlZlkgcmVwZWF0Q291bnQgcmVwZWF0RHVyIHJlcXVpcmVkRXh0ZW5zaW9ucyByZXF1aXJlZEZlYXR1cmVzIHNwZWN1bGFyQ29uc3RhbnQgc3BlY3VsYXJFeHBvbmVudCBzcHJlYWRNZXRob2Qgc3RhcnRPZmZzZXQgc3RkRGV2aWF0aW9uIHN0aXRjaFRpbGVzIHN1cmZhY2VTY2FsZSBzeXN0ZW1MYW5ndWFnZSB0YWJsZVZhbHVlcyB0YXJnZXRYIHRhcmdldFkgdGV4dExlbmd0aCB2aWV3Qm94IHZpZXdUYXJnZXQgeENoYW5uZWxTZWxlY3RvciB5Q2hhbm5lbFNlbGVjdG9yIHpvb21BbmRQYW5cIi5zcGxpdChcIiBcIik7XG5cbiAgY3JlYXRlTWFwID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gIFx0dmFyIG1hcCA9IHt9LFxuICBcdCAgICBpID0gaXRlbXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdG1hcFtpdGVtc1tpXS50b0xvd2VyQ2FzZSgpXSA9IGl0ZW1zW2ldO1xuICBcdH1cbiAgXHRyZXR1cm4gbWFwO1xuICB9O1xuXG4gIG1hcCA9IGNyZWF0ZU1hcChzdmdDYW1lbENhc2VFbGVtZW50cy5jb25jYXQoc3ZnQ2FtZWxDYXNlQXR0cmlidXRlcykpO1xuXG4gIHZhciBlbmZvcmNlQ2FzZSA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSkge1xuICBcdHZhciBsb3dlckNhc2VFbGVtZW50TmFtZSA9IGVsZW1lbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIFx0cmV0dXJuIG1hcFtsb3dlckNhc2VFbGVtZW50TmFtZV0gfHwgbG93ZXJDYXNlRWxlbWVudE5hbWU7XG4gIH07XG5cbiAgdmFyIGRldGVybWluZU5hbWVBbmROYW1lc3BhY2UgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBuYW1lKSB7XG4gIFx0dmFyIGNvbG9uSW5kZXgsIG5hbWVzcGFjZVByZWZpeDtcblxuICBcdC8vIGFyZSB3ZSBkZWFsaW5nIHdpdGggYSBuYW1lc3BhY2VkIGF0dHJpYnV0ZSwgZS5nLiB4bGluazpocmVmP1xuICBcdGNvbG9uSW5kZXggPSBuYW1lLmluZGV4T2YoXCI6XCIpO1xuICBcdGlmIChjb2xvbkluZGV4ICE9PSAtMSkge1xuXG4gIFx0XHQvLyBsb29rcyBsaWtlIHdlIGFyZSwgeWVzLi4uXG4gIFx0XHRuYW1lc3BhY2VQcmVmaXggPSBuYW1lLnN1YnN0cigwLCBjb2xvbkluZGV4KTtcblxuICBcdFx0Ly8gLi4udW5sZXNzIGl0J3MgYSBuYW1lc3BhY2UgKmRlY2xhcmF0aW9uKiwgd2hpY2ggd2UgaWdub3JlIChvbiB0aGUgYXNzdW1wdGlvblxuICBcdFx0Ly8gdGhhdCBvbmx5IHZhbGlkIG5hbWVzcGFjZXMgd2lsbCBiZSB1c2VkKVxuICBcdFx0aWYgKG5hbWVzcGFjZVByZWZpeCAhPT0gXCJ4bWxuc1wiKSB7XG4gIFx0XHRcdG5hbWUgPSBuYW1lLnN1YnN0cmluZyhjb2xvbkluZGV4ICsgMSk7XG5cbiAgXHRcdFx0YXR0cmlidXRlLm5hbWUgPSBlbmZvcmNlQ2FzZShuYW1lKTtcbiAgXHRcdFx0YXR0cmlidXRlLm5hbWVzcGFjZSA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlUHJlZml4LnRvTG93ZXJDYXNlKCldO1xuICBcdFx0XHRhdHRyaWJ1dGUubmFtZXNwYWNlUHJlZml4ID0gbmFtZXNwYWNlUHJlZml4O1xuXG4gIFx0XHRcdGlmICghYXR0cmlidXRlLm5hbWVzcGFjZSkge1xuICBcdFx0XHRcdHRocm93IFwiVW5rbm93biBuYW1lc3BhY2UgKFxcXCJcIiArIG5hbWVzcGFjZVByZWZpeCArIFwiXFxcIilcIjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBTVkcgYXR0cmlidXRlIG5hbWVzIGFyZSBjYXNlIHNlbnNpdGl2ZVxuICBcdGF0dHJpYnV0ZS5uYW1lID0gYXR0cmlidXRlLmVsZW1lbnQubmFtZXNwYWNlICE9PSBuYW1lc3BhY2VzLmh0bWwgPyBlbmZvcmNlQ2FzZShuYW1lKSA6IG5hbWU7XG4gIH07XG5cbiAgdmFyIGhlbHBlcnNfZ2V0SW50ZXJwb2xhdG9yID0gZ2V0SW50ZXJwb2xhdG9yO1xuICBmdW5jdGlvbiBnZXRJbnRlcnBvbGF0b3IoYXR0cmlidXRlKSB7XG4gIFx0dmFyIGl0ZW1zID0gYXR0cmlidXRlLmZyYWdtZW50Lml0ZW1zO1xuXG4gIFx0aWYgKGl0ZW1zLmxlbmd0aCAhPT0gMSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmIChpdGVtc1swXS50eXBlID09PSBJTlRFUlBPTEFUT1IpIHtcbiAgXHRcdHJldHVybiBpdGVtc1swXTtcbiAgXHR9XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2luaXQgPSBBdHRyaWJ1dGUkaW5pdDtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJGluaXQob3B0aW9ucykge1xuICBcdHRoaXMudHlwZSA9IEFUVFJJQlVURTtcbiAgXHR0aGlzLmVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gb3B0aW9ucy5yb290O1xuXG4gIFx0ZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSh0aGlzLCBvcHRpb25zLm5hbWUpO1xuICBcdHRoaXMuaXNCb29sZWFuID0gYm9vbGVhbkF0dHJpYnV0ZXMudGVzdCh0aGlzLm5hbWUpO1xuXG4gIFx0Ly8gaWYgaXQncyBhbiBlbXB0eSBhdHRyaWJ1dGUsIG9yIGp1c3QgYSBzdHJhaWdodCBrZXktdmFsdWUgcGFpciwgd2l0aCBub1xuICBcdC8vIG11c3RhY2hlIHNoZW5hbmlnYW5zLCBzZXQgdGhlIGF0dHJpYnV0ZSBhY2NvcmRpbmdseSBhbmQgZ28gaG9tZVxuICBcdGlmICghb3B0aW9ucy52YWx1ZSB8fCB0eXBlb2Ygb3B0aW9ucy52YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0dGhpcy52YWx1ZSA9IHRoaXMuaXNCb29sZWFuID8gdHJ1ZSA6IG9wdGlvbnMudmFsdWUgfHwgXCJcIjtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBvdGhlcndpc2Ugd2UgbmVlZCB0byBkbyBzb21lIHdvcmtcblxuICBcdC8vIHNoYXJlIHBhcmVudEZyYWdtZW50IHdpdGggcGFyZW50IGVsZW1lbnRcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudEZyYWdtZW50O1xuXG4gIFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdHRlbXBsYXRlOiBvcHRpb25zLnZhbHVlLFxuICBcdFx0cm9vdDogdGhpcy5yb290LFxuICBcdFx0b3duZXI6IHRoaXNcbiAgXHR9KTtcblxuICBcdC8vIFRPRE8gY2FuIHdlIHVzZSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCkgaW4gc29tZSBjYXNlcz8gSXQncyBxdWlja2VyXG4gIFx0dGhpcy52YWx1ZSA9IHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKTtcblxuICBcdC8vIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoaXMgYXR0cmlidXRlJ3MgaW50ZXJwb2xhdG9yLCBpZiBpdHMgZnJhZ21lbnRcbiAgXHQvLyB0YWtlcyB0aGUgZm9ybSBge3tmb299fWAuIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciB0d28td2F5IGJpbmRpbmcgYW5kXG4gIFx0Ly8gZm9yIGNvcnJlY3RseSByZW5kZXJpbmcgSFRNTCBsYXRlclxuICBcdHRoaXMuaW50ZXJwb2xhdG9yID0gaGVscGVyc19nZXRJbnRlcnBvbGF0b3IodGhpcyk7XG4gIFx0dGhpcy5pc0JpbmRhYmxlID0gISF0aGlzLmludGVycG9sYXRvciAmJiAhdGhpcy5pbnRlcnBvbGF0b3IuaXNTdGF0aWM7XG5cbiAgXHQvLyBtYXJrIGFzIHJlYWR5XG4gIFx0dGhpcy5yZWFkeSA9IHRydWU7XG4gIH1cblxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV9yZWJpbmQgPSBBdHRyaWJ1dGUkcmViaW5kO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSRyZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV9yZW5kZXIgPSBBdHRyaWJ1dGUkcmVuZGVyO1xuICB2YXIgcHJvcGVydHlOYW1lcyA9IHtcbiAgXHRcImFjY2VwdC1jaGFyc2V0XCI6IFwiYWNjZXB0Q2hhcnNldFwiLFxuICBcdGFjY2Vzc2tleTogXCJhY2Nlc3NLZXlcIixcbiAgXHRiZ2NvbG9yOiBcImJnQ29sb3JcIixcbiAgXHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCIsXG4gIFx0Y29kZWJhc2U6IFwiY29kZUJhc2VcIixcbiAgXHRjb2xzcGFuOiBcImNvbFNwYW5cIixcbiAgXHRjb250ZW50ZWRpdGFibGU6IFwiY29udGVudEVkaXRhYmxlXCIsXG4gIFx0ZGF0ZXRpbWU6IFwiZGF0ZVRpbWVcIixcbiAgXHRkaXJuYW1lOiBcImRpck5hbWVcIixcbiAgXHRcImZvclwiOiBcImh0bWxGb3JcIixcbiAgXHRcImh0dHAtZXF1aXZcIjogXCJodHRwRXF1aXZcIixcbiAgXHRpc21hcDogXCJpc01hcFwiLFxuICBcdG1heGxlbmd0aDogXCJtYXhMZW5ndGhcIixcbiAgXHRub3ZhbGlkYXRlOiBcIm5vVmFsaWRhdGVcIixcbiAgXHRwdWJkYXRlOiBcInB1YkRhdGVcIixcbiAgXHRyZWFkb25seTogXCJyZWFkT25seVwiLFxuICBcdHJvd3NwYW46IFwicm93U3BhblwiLFxuICBcdHRhYmluZGV4OiBcInRhYkluZGV4XCIsXG4gIFx0dXNlbWFwOiBcInVzZU1hcFwiXG4gIH07XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSRyZW5kZXIobm9kZSkge1xuICBcdHZhciBwcm9wZXJ0eU5hbWU7XG5cbiAgXHR0aGlzLm5vZGUgPSBub2RlO1xuXG4gIFx0Ly8gc2hvdWxkIHdlIHVzZSBkaXJlY3QgcHJvcGVydHkgYWNjZXNzLCBvciBzZXRBdHRyaWJ1dGU/XG4gIFx0aWYgKCFub2RlLm5hbWVzcGFjZVVSSSB8fCBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5odG1sKSB7XG4gIFx0XHRwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVzW3RoaXMubmFtZV0gfHwgdGhpcy5uYW1lO1xuXG4gIFx0XHRpZiAobm9kZVtwcm9wZXJ0eU5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlzIGF0dHJpYnV0ZSBhIGJvb2xlYW4gYXR0cmlidXRlIG9yICd2YWx1ZSc/IElmIHNvIHdlJ3JlIGJldHRlciBvZmYgZG9pbmcgZS5nLlxuICBcdFx0Ly8gbm9kZS5zZWxlY3RlZCA9IHRydWUgcmF0aGVyIHRoYW4gbm9kZS5zZXRBdHRyaWJ1dGUoICdzZWxlY3RlZCcsICcnIClcbiAgXHRcdGlmICh0aGlzLmlzQm9vbGVhbiB8fCB0aGlzLmlzVHdvd2F5KSB7XG4gIFx0XHRcdHRoaXMudXNlUHJvcGVydHkgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAocHJvcGVydHlOYW1lID09PSBcInZhbHVlXCIpIHtcbiAgXHRcdFx0bm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHRoaXMudmFsdWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0dGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHZhciBBdHRyaWJ1dGVfcHJvdG90eXBlX3RvU3RyaW5nID0gQXR0cmlidXRlJHRvU3RyaW5nO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR0b1N0cmluZygpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgXHR2YXIgbmFtZXNwYWNlUHJlZml4ID0gX3JlZi5uYW1lc3BhY2VQcmVmaXg7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgXHR2YXIgaW50ZXJwb2xhdG9yID0gX3JlZi5pbnRlcnBvbGF0b3I7XG4gIFx0dmFyIGZyYWdtZW50ID0gX3JlZi5mcmFnbWVudDtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHNlbGVjdCBhbmQgdGV4dGFyZWEgdmFsdWVzIChzaG91bGQgbm90IGJlIHN0cmluZ2lmaWVkKVxuICBcdGlmIChuYW1lID09PSBcInZhbHVlXCIgJiYgKHRoaXMuZWxlbWVudC5uYW1lID09PSBcInNlbGVjdFwiIHx8IHRoaXMuZWxlbWVudC5uYW1lID09PSBcInRleHRhcmVhXCIpKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gY29udGVudCBlZGl0YWJsZVxuICBcdGlmIChuYW1lID09PSBcInZhbHVlXCIgJiYgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gcmFkaW8gbmFtZXNcbiAgXHRpZiAobmFtZSA9PT0gXCJuYW1lXCIgJiYgdGhpcy5lbGVtZW50Lm5hbWUgPT09IFwiaW5wdXRcIiAmJiBpbnRlcnBvbGF0b3IpIHtcbiAgXHRcdHJldHVybiBcIm5hbWU9e3tcIiArIChpbnRlcnBvbGF0b3Iua2V5cGF0aC5zdHIgfHwgaW50ZXJwb2xhdG9yLnJlZikgKyBcIn19XCI7XG4gIFx0fVxuXG4gIFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzXG4gIFx0aWYgKHRoaXMuaXNCb29sZWFuKSB7XG4gIFx0XHRyZXR1cm4gdmFsdWUgPyBuYW1lIDogXCJcIjtcbiAgXHR9XG5cbiAgXHRpZiAoZnJhZ21lbnQpIHtcbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIHRoaXMgY2F0Y2hlcyB1bmRlZmluZWQvbnVsbCB2YWx1ZXMgKCMxMjExKVxuICBcdFx0aWYgKGZyYWdtZW50Lml0ZW1zLmxlbmd0aCA9PT0gMSAmJiBmcmFnbWVudC5pdGVtc1swXS52YWx1ZSA9PSBudWxsKSB7XG4gIFx0XHRcdHJldHVybiBcIlwiO1xuICBcdFx0fVxuXG4gIFx0XHR2YWx1ZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIFx0fVxuXG4gIFx0aWYgKG5hbWVzcGFjZVByZWZpeCkge1xuICBcdFx0bmFtZSA9IG5hbWVzcGFjZVByZWZpeCArIFwiOlwiICsgbmFtZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWUgPyBuYW1lICsgXCI9XFxcIlwiICsgQXR0cmlidXRlX3Byb3RvdHlwZV90b1N0cmluZ19fZXNjYXBlKHZhbHVlKSArIFwiXFxcIlwiIDogbmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZV9wcm90b3R5cGVfdG9TdHJpbmdfX2VzY2FwZSh2YWx1ZSkge1xuICBcdHJldHVybiB2YWx1ZS5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIikucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIikucmVwbGFjZSgvJy9nLCBcIiYjMzk7XCIpO1xuICB9XG5cbiAgdmFyIEF0dHJpYnV0ZV9wcm90b3R5cGVfdW5iaW5kID0gQXR0cmlidXRlJHVuYmluZDtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdW5iaW5kKCkge1xuICBcdC8vIGlnbm9yZSBub24tZHluYW1pYyBhdHRyaWJ1dGVzXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJpZFwiKSB7XG4gIFx0XHRkZWxldGUgdGhpcy5yb290Lm5vZGVzW3RoaXMudmFsdWVdO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVTZWxlY3RWYWx1ZSA9IEF0dHJpYnV0ZSR1cGRhdGVTZWxlY3Q7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVNlbGVjdCgpIHtcbiAgXHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLFxuICBcdCAgICBvcHRpb25zLFxuICBcdCAgICBvcHRpb24sXG4gIFx0ICAgIG9wdGlvblZhbHVlLFxuICBcdCAgICBpO1xuXG4gIFx0aWYgKCF0aGlzLmxvY2tlZCkge1xuICBcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdG9wdGlvbnMgPSB0aGlzLm5vZGUub3B0aW9ucztcbiAgXHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRvcHRpb24gPSBvcHRpb25zW2ldO1xuICBcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTsgLy8gb3B0aW9ucyBpbnNlcnRlZCB2aWEgYSB0cmlwbGUgZG9uJ3QgaGF2ZSBfcmFjdGl2ZVxuXG4gIFx0XHRcdGlmIChvcHRpb25WYWx1ZSA9PSB2YWx1ZSkge1xuICBcdFx0XHRcdC8vIGRvdWJsZSBlcXVhbHMgYXMgd2UgbWF5IGJlIGNvbXBhcmluZyBudW1iZXJzIHdpdGggc3RyaW5nc1xuICBcdFx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBpZiB3ZSdyZSBzdGlsbCBoZXJlLCBpdCBtZWFucyB0aGUgbmV3IHZhbHVlIGRpZG4ndCBtYXRjaCBhbnkgb2YgdGhlIG9wdGlvbnMuLi5cbiAgXHQvLyBUT0RPIGZpZ3VyZSBvdXQgd2hhdCB0byBkbyBpbiB0aGlzIHNpdHVhdGlvblxuICB9XG5cbiAgdmFyIHVwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUgPSBBdHRyaWJ1dGUkdXBkYXRlTXVsdGlwbGVTZWxlY3Q7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVNdWx0aXBsZVNlbGVjdCgpIHtcbiAgXHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLFxuICBcdCAgICBvcHRpb25zLFxuICBcdCAgICBpLFxuICBcdCAgICBvcHRpb24sXG4gIFx0ICAgIG9wdGlvblZhbHVlO1xuXG4gIFx0aWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICBcdFx0dmFsdWUgPSBbdmFsdWVdO1xuICBcdH1cblxuICBcdG9wdGlvbnMgPSB0aGlzLm5vZGUub3B0aW9ucztcbiAgXHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRvcHRpb24gPSBvcHRpb25zW2ldO1xuICBcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7IC8vIG9wdGlvbnMgaW5zZXJ0ZWQgdmlhIGEgdHJpcGxlIGRvbid0IGhhdmUgX3JhY3RpdmVcbiAgXHRcdG9wdGlvbi5zZWxlY3RlZCA9IGFycmF5Q29udGFpbnModmFsdWUsIG9wdGlvblZhbHVlKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlUmFkaW9OYW1lID0gQXR0cmlidXRlJHVwZGF0ZVJhZGlvTmFtZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlUmFkaW9OYW1lKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBub2RlID0gX3JlZi5ub2RlO1xuICBcdHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG5cbiAgXHRub2RlLmNoZWNrZWQgPSB2YWx1ZSA9PSBub2RlLl9yYWN0aXZlLnZhbHVlO1xuICB9XG5cbiAgdmFyIHVwZGF0ZVJhZGlvVmFsdWUgPSBBdHRyaWJ1dGUkdXBkYXRlUmFkaW9WYWx1ZTtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVJhZGlvVmFsdWUoKSB7XG4gIFx0dmFyIHdhc0NoZWNrZWQsXG4gIFx0ICAgIG5vZGUgPSB0aGlzLm5vZGUsXG4gIFx0ICAgIGJpbmRpbmcsXG4gIFx0ICAgIGJpbmRpbmdzLFxuICBcdCAgICBpO1xuXG4gIFx0d2FzQ2hlY2tlZCA9IG5vZGUuY2hlY2tlZDtcblxuICBcdG5vZGUudmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0bm9kZS5jaGVja2VkID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcblxuICBcdC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgLSBpZiB0aGUgaW5wdXQgd2FzIGNoZWNrZWQsIGFuZCB0aGUgdmFsdWVcbiAgXHQvLyBjaGFuZ2VkIHNvIHRoYXQgaXQncyBubyBsb25nZXIgY2hlY2tlZCwgdGhlIHR3b3dheSBiaW5kaW5nIGlzXG4gIFx0Ly8gbW9zdCBsaWtlbHkgb3V0IG9mIGRhdGUuIFRvIGZpeCBpdCB3ZSBoYXZlIHRvIGp1bXAgdGhyb3VnaCBzb21lXG4gIFx0Ly8gaG9vcHMuLi4gdGhpcyBpcyBhIGxpdHRsZSBrbHVkZ3kgYnV0IGl0IHdvcmtzXG4gIFx0aWYgKHdhc0NoZWNrZWQgJiYgIW5vZGUuY2hlY2tlZCAmJiB0aGlzLmVsZW1lbnQuYmluZGluZykge1xuICBcdFx0YmluZGluZ3MgPSB0aGlzLmVsZW1lbnQuYmluZGluZy5zaWJsaW5ncztcblxuICBcdFx0aWYgKGkgPSBiaW5kaW5ncy5sZW5ndGgpIHtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcblxuICBcdFx0XHRcdGlmICghYmluZGluZy5lbGVtZW50Lm5vZGUpIHtcbiAgXHRcdFx0XHRcdC8vIHRoaXMgaXMgdGhlIGluaXRpYWwgcmVuZGVyLCBzaWJsaW5ncyBhcmUgc3RpbGwgcmVuZGVyaW5nIVxuICBcdFx0XHRcdFx0Ly8gd2UnbGwgY29tZSBiYWNrIGxhdGVyLi4uXG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKGJpbmRpbmcuZWxlbWVudC5ub2RlLmNoZWNrZWQpIHtcbiAgXHRcdFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFJhY3RpdmUoYmluZGluZy5yb290KTtcbiAgXHRcdFx0XHRcdHJldHVybiBiaW5kaW5nLmhhbmRsZUNoYW5nZSgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KGJpbmRpbmcua2V5cGF0aCwgdW5kZWZpbmVkKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlQ2hlY2tib3hOYW1lID0gQXR0cmlidXRlJHVwZGF0ZUNoZWNrYm94TmFtZTtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUNoZWNrYm94TmFtZSgpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgZWxlbWVudCA9IF9yZWYuZWxlbWVudDtcbiAgXHR2YXIgbm9kZSA9IF9yZWYubm9kZTtcbiAgXHR2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO3ZhciBiaW5kaW5nID0gZWxlbWVudC5iaW5kaW5nO3ZhciB2YWx1ZUF0dHJpYnV0ZTt2YXIgaTtcblxuICBcdHZhbHVlQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblxuICBcdGlmICghaXNBcnJheSh2YWx1ZSkpIHtcbiAgXHRcdGJpbmRpbmcuaXNDaGVja2VkID0gbm9kZS5jaGVja2VkID0gdmFsdWUgPT0gdmFsdWVBdHRyaWJ1dGU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGkgPSB2YWx1ZS5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGlmICh2YWx1ZUF0dHJpYnV0ZSA9PSB2YWx1ZVtpXSkge1xuICBcdFx0XHRcdGJpbmRpbmcuaXNDaGVja2VkID0gbm9kZS5jaGVja2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdGJpbmRpbmcuaXNDaGVja2VkID0gbm9kZS5jaGVja2VkID0gZmFsc2U7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZUNsYXNzTmFtZSA9IEF0dHJpYnV0ZSR1cGRhdGVDbGFzc05hbWU7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVDbGFzc05hbWUoKSB7XG4gIFx0dGhpcy5ub2RlLmNsYXNzTmFtZSA9IHNhZmVUb1N0cmluZ1ZhbHVlKHRoaXMudmFsdWUpO1xuICB9XG5cbiAgdmFyIHVwZGF0ZUlkQXR0cmlidXRlID0gQXR0cmlidXRlJHVwZGF0ZUlkQXR0cmlidXRlO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVJZEF0dHJpYnV0ZSgpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgbm9kZSA9IF9yZWYubm9kZTtcbiAgXHR2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuXG4gIFx0dGhpcy5yb290Lm5vZGVzW3ZhbHVlXSA9IG5vZGU7XG4gIFx0bm9kZS5pZCA9IHZhbHVlO1xuICB9XG5cbiAgdmFyIHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUgPSBBdHRyaWJ1dGUkdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZSgpIHtcbiAgXHR2YXIgbm9kZSwgdmFsdWU7XG5cbiAgXHRub2RlID0gdGhpcy5ub2RlO1xuICBcdHZhbHVlID0gdGhpcy52YWx1ZTtcblxuICBcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHR2YWx1ZSA9IFwiXCI7XG4gIFx0fVxuXG4gIFx0bm9kZS5zdHlsZS5zZXRBdHRyaWJ1dGUoXCJjc3NUZXh0XCIsIHZhbHVlKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZSA9IEF0dHJpYnV0ZSR1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUoKSB7XG4gIFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcblxuICBcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHR2YWx1ZSA9IFwiXCI7XG4gIFx0fVxuXG4gIFx0aWYgKCF0aGlzLmxvY2tlZCkge1xuICBcdFx0dGhpcy5ub2RlLmlubmVySFRNTCA9IHZhbHVlO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVWYWx1ZSA9IEF0dHJpYnV0ZSR1cGRhdGVWYWx1ZTtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlVmFsdWUoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcblxuICBcdC8vIHN0b3JlIGFjdHVhbCB2YWx1ZSwgc28gaXQgZG9lc24ndCBnZXQgY29lcmNlZCB0byBhIHN0cmluZ1xuICBcdG5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcblxuICBcdC8vIHdpdGggdHdvLXdheSBiaW5kaW5nLCBvbmx5IHVwZGF0ZSBpZiB0aGUgY2hhbmdlIHdhc24ndCBpbml0aWF0ZWQgYnkgdGhlIHVzZXJcbiAgXHQvLyBvdGhlcndpc2UgdGhlIGN1cnNvciB3aWxsIG9mdGVuIGJlIHNlbnQgdG8gdGhlIHdyb25nIHBsYWNlXG4gIFx0aWYgKCF0aGlzLmxvY2tlZCkge1xuICBcdFx0bm9kZS52YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/IFwiXCIgOiB2YWx1ZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlQm9vbGVhbiA9IEF0dHJpYnV0ZSR1cGRhdGVCb29sZWFuQXR0cmlidXRlO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVCb29sZWFuQXR0cmlidXRlKCkge1xuICBcdC8vIHdpdGggdHdvLXdheSBiaW5kaW5nLCBvbmx5IHVwZGF0ZSBpZiB0aGUgY2hhbmdlIHdhc24ndCBpbml0aWF0ZWQgYnkgdGhlIHVzZXJcbiAgXHQvLyBvdGhlcndpc2UgdGhlIGN1cnNvciB3aWxsIG9mdGVuIGJlIHNlbnQgdG8gdGhlIHdyb25nIHBsYWNlXG4gIFx0aWYgKCF0aGlzLmxvY2tlZCkge1xuICBcdFx0dGhpcy5ub2RlW3RoaXMucHJvcGVydHlOYW1lXSA9IHRoaXMudmFsdWU7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlID0gQXR0cmlidXRlJHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVFdmVyeXRoaW5nRWxzZSgpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgbm9kZSA9IF9yZWYubm9kZTtcbiAgXHR2YXIgbmFtZXNwYWNlID0gX3JlZi5uYW1lc3BhY2U7XG4gIFx0dmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgXHR2YXIgZnJhZ21lbnQgPSBfcmVmLmZyYWdtZW50O1xuXG4gIFx0aWYgKG5hbWVzcGFjZSkge1xuICBcdFx0bm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUsIChmcmFnbWVudCB8fCB2YWx1ZSkudG9TdHJpbmcoKSk7XG4gIFx0fSBlbHNlIGlmICghdGhpcy5pc0Jvb2xlYW4pIHtcbiAgXHRcdGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gIFx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgKGZyYWdtZW50IHx8IHZhbHVlKS50b1N0cmluZygpKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgLSB0cnV0aHkgYmVjb21lcyAnJywgZmFsc3kgbWVhbnMgJ3JlbW92ZSBhdHRyaWJ1dGUnXG4gIFx0ZWxzZSB7XG4gIFx0XHRpZiAodmFsdWUpIHtcbiAgXHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgXCJcIik7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICAvLyBUaGVyZSBhcmUgYSBmZXcgc3BlY2lhbCBjYXNlcyB3aGVuIGl0IGNvbWVzIHRvIHVwZGF0aW5nIGF0dHJpYnV0ZXMuIEZvciB0aGlzIHJlYXNvbixcbiAgLy8gdGhlIHByb3RvdHlwZSAudXBkYXRlKCkgbWV0aG9kIHBvaW50cyB0byB0aGlzIG1ldGhvZCwgd2hpY2ggd2FpdHMgdW50aWwgdGhlXG4gIC8vIGF0dHJpYnV0ZSBoYXMgZmluaXNoZWQgaW5pdGlhbGlzaW5nLCB0aGVuIHJlcGxhY2VzIHRoZSBwcm90b3R5cGUgbWV0aG9kIHdpdGggYSBtb3JlXG4gIC8vIHN1aXRhYmxlIG9uZS4gVGhhdCB3YXksIHdlIHNhdmUgb3Vyc2VsdmVzIGRvaW5nIGEgYnVuY2ggb2YgdGVzdHMgb24gZWFjaCBjYWxsXG4gIHZhciBBdHRyaWJ1dGVfcHJvdG90eXBlX3VwZGF0ZSA9IEF0dHJpYnV0ZSR1cGRhdGU7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGUoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gIFx0dmFyIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQ7XG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7dmFyIHR5cGU7dmFyIHVwZGF0ZU1ldGhvZDtcblxuICBcdGlmIChuYW1lID09PSBcImlkXCIpIHtcbiAgXHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUlkQXR0cmlidXRlO1xuICBcdH0gZWxzZSBpZiAobmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBzZWxlY3RzXG4gIFx0XHRpZiAoZWxlbWVudC5uYW1lID09PSBcInNlbGVjdFwiICYmIG5hbWUgPT09IFwidmFsdWVcIikge1xuICBcdFx0XHR1cGRhdGVNZXRob2QgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpID8gdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSA6IHVwZGF0ZVNlbGVjdFZhbHVlO1xuICBcdFx0fSBlbHNlIGlmIChlbGVtZW50Lm5hbWUgPT09IFwidGV4dGFyZWFcIikge1xuICBcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVWYWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gY29udGVudGVkaXRhYmxlXG4gIFx0XHRlbHNlIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSAhPSBudWxsKSB7XG4gIFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSA8aW5wdXQ+XG4gIFx0XHRlbHNlIGlmIChlbGVtZW50Lm5hbWUgPT09IFwiaW5wdXRcIikge1xuICBcdFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuXG4gIFx0XHRcdC8vIHR5cGU9J2ZpbGUnIHZhbHVlPSd7e2ZpbGVMaXN0fX0nPlxuICBcdFx0XHRpZiAodHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgXHRcdFx0XHR1cGRhdGVNZXRob2QgPSBub29wOyAvLyByZWFkLW9ubHlcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIHR5cGU9J3JhZGlvJyBuYW1lPSd7e3R3b3dheX19J1xuICBcdFx0XHRlbHNlIGlmICh0eXBlID09PSBcInJhZGlvXCIgJiYgZWxlbWVudC5iaW5kaW5nICYmIGVsZW1lbnQuYmluZGluZy5uYW1lID09PSBcIm5hbWVcIikge1xuICBcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVJhZGlvVmFsdWU7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlVmFsdWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBzcGVjaWFsIGNhc2UgLSA8aW5wdXQgdHlwZT0ncmFkaW8nIG5hbWU9J3t7dHdvd2F5fX0nIHZhbHVlPSdmb28nPlxuICBcdGVsc2UgaWYgKHRoaXMuaXNUd293YXkgJiYgbmFtZSA9PT0gXCJuYW1lXCIpIHtcbiAgXHRcdGlmIChub2RlLnR5cGUgPT09IFwicmFkaW9cIikge1xuICBcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVSYWRpb05hbWU7XG4gIFx0XHR9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gIFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNoZWNrYm94TmFtZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBzcGVjaWFsIGNhc2UgLSBzdHlsZSBhdHRyaWJ1dGVzIGluIEludGVybmV0IEV4cGxvZGVyXG4gIFx0ZWxzZSBpZiAobmFtZSA9PT0gXCJzdHlsZVwiICYmIG5vZGUuc3R5bGUuc2V0QXR0cmlidXRlKSB7XG4gIFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVJRVN0eWxlQXR0cmlidXRlO1xuICBcdH1cblxuICBcdC8vIHNwZWNpYWwgY2FzZSAtIGNsYXNzIG5hbWVzLiBJRSBmdWNrcyB0aGluZ3MgdXAsIGFnYWluXG4gIFx0ZWxzZSBpZiAobmFtZSA9PT0gXCJjbGFzc1wiICYmICghbm9kZS5uYW1lc3BhY2VVUkkgfHwgbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuaHRtbCkpIHtcbiAgXHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNsYXNzTmFtZTtcbiAgXHR9IGVsc2UgaWYgKHRoaXMudXNlUHJvcGVydHkpIHtcbiAgXHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUJvb2xlYW47XG4gIFx0fVxuXG4gIFx0aWYgKCF1cGRhdGVNZXRob2QpIHtcbiAgXHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlO1xuICBcdH1cblxuICBcdHRoaXMudXBkYXRlID0gdXBkYXRlTWV0aG9kO1xuICBcdHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICB2YXIgQXR0cmlidXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLmluaXQob3B0aW9ucyk7XG4gIH07XG5cbiAgQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IEF0dHJpYnV0ZV9wcm90b3R5cGVfYnViYmxlLFxuICBcdGluaXQ6IHByb3RvdHlwZV9pbml0LFxuICBcdHJlYmluZDogQXR0cmlidXRlX3Byb3RvdHlwZV9yZWJpbmQsXG4gIFx0cmVuZGVyOiBBdHRyaWJ1dGVfcHJvdG90eXBlX3JlbmRlcixcbiAgXHR0b1N0cmluZzogQXR0cmlidXRlX3Byb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IEF0dHJpYnV0ZV9wcm90b3R5cGVfdW5iaW5kLFxuICBcdHVwZGF0ZTogQXR0cmlidXRlX3Byb3RvdHlwZV91cGRhdGVcbiAgfTtcblxuICB2YXIgX0F0dHJpYnV0ZSA9IEF0dHJpYnV0ZTtcblxuICB2YXIgY3JlYXRlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIFx0dmFyIG5hbWUsXG4gIFx0ICAgIGF0dHJpYnV0ZSxcbiAgXHQgICAgcmVzdWx0ID0gW107XG5cbiAgXHRmb3IgKG5hbWUgaW4gYXR0cmlidXRlcykge1xuICBcdFx0Ly8gc2tpcCBiaW5kaW5nIGF0dHJpYnV0ZXNcbiAgXHRcdGlmIChuYW1lID09PSBcInR3b3dheVwiIHx8IG5hbWUgPT09IFwibGF6eVwiKSB7XG4gIFx0XHRcdGNvbnRpbnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICBcdFx0XHRhdHRyaWJ1dGUgPSBuZXcgX0F0dHJpYnV0ZSh7XG4gIFx0XHRcdFx0ZWxlbWVudDogZWxlbWVudCxcbiAgXHRcdFx0XHRuYW1lOiBuYW1lLFxuICBcdFx0XHRcdHZhbHVlOiBhdHRyaWJ1dGVzW25hbWVdLFxuICBcdFx0XHRcdHJvb3Q6IGVsZW1lbnQucm9vdFxuICBcdFx0XHR9KTtcblxuICBcdFx0XHRyZXN1bHRbbmFtZV0gPSBhdHRyaWJ1dGU7XG5cbiAgXHRcdFx0aWYgKG5hbWUgIT09IFwidmFsdWVcIikge1xuICBcdFx0XHRcdHJlc3VsdC5wdXNoKGF0dHJpYnV0ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyB2YWx1ZSBhdHRyaWJ1dGUgZ29lcyBsYXN0LiBUaGlzIGlzIGJlY2F1c2UgaXRcbiAgXHQvLyBtYXkgZ2V0IGNsYW1wZWQgb24gcmVuZGVyIG90aGVyd2lzZSwgZS5nLiBpblxuICBcdC8vIGA8aW5wdXQgdHlwZT0ncmFuZ2UnIHZhbHVlPSc5OTknIG1pbj0nMCcgbWF4PScxMDAwJz5gXG4gIFx0Ly8gc2luY2UgZGVmYXVsdCBtYXggaXMgMTAwXG4gIFx0aWYgKGF0dHJpYnV0ZSA9IHJlc3VsdC52YWx1ZSkge1xuICBcdFx0cmVzdWx0LnB1c2goYXR0cmlidXRlKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBfQ29uZGl0aW9uYWxBdHRyaWJ1dGVfX2RpdjtcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIFx0X0NvbmRpdGlvbmFsQXR0cmlidXRlX19kaXYgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB9XG5cbiAgdmFyIENvbmRpdGlvbmFsQXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRlbXBsYXRlKSB7XG4gIFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgXHR0aGlzLnJvb3QgPSBlbGVtZW50LnJvb3Q7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHR0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcblxuICBcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRyb290OiBlbGVtZW50LnJvb3QsXG4gIFx0XHRvd25lcjogdGhpcyxcbiAgXHRcdHRlbXBsYXRlOiBbdGVtcGxhdGVdXG4gIFx0fSk7XG4gIH07XG5cbiAgQ29uZGl0aW9uYWxBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMubm9kZSkge1xuICBcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmVsZW1lbnQuYnViYmxlKCk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gIFx0XHR0aGlzLm5vZGUgPSBub2RlO1xuICBcdFx0dGhpcy5pc1N2ZyA9IG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLnN2ZztcblxuICBcdFx0dGhpcy51cGRhdGUoKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdH0sXG5cbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciBzdHIsIGF0dHJzO1xuXG4gIFx0XHRzdHIgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIFx0XHRhdHRycyA9IHBhcnNlQXR0cmlidXRlcyhzdHIsIHRoaXMuaXNTdmcpO1xuXG4gIFx0XHQvLyBhbnkgYXR0cmlidXRlcyB0aGF0IHByZXZpb3VzbHkgZXhpc3RlZCBidXQgbm8gbG9uZ2VyIGRvXG4gIFx0XHQvLyBtdXN0IGJlIHJlbW92ZWRcbiAgXHRcdHRoaXMuYXR0cmlidXRlcy5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgXHRcdFx0cmV0dXJuIG5vdEluKGF0dHJzLCBhKTtcbiAgXHRcdH0pLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgXHRcdFx0X3RoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoYS5uYW1lKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gIFx0XHRcdF90aGlzLm5vZGUuc2V0QXR0cmlidXRlKGEubmFtZSwgYS52YWx1ZSk7XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5hdHRyaWJ1dGVzID0gYXR0cnM7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgX0NvbmRpdGlvbmFsQXR0cmlidXRlID0gQ29uZGl0aW9uYWxBdHRyaWJ1dGU7XG5cbiAgZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVzKHN0ciwgaXNTdmcpIHtcbiAgXHR2YXIgdGFnID0gaXNTdmcgPyBcInN2Z1wiIDogXCJkaXZcIjtcbiAgXHRfQ29uZGl0aW9uYWxBdHRyaWJ1dGVfX2Rpdi5pbm5lckhUTUwgPSBcIjxcIiArIHRhZyArIFwiIFwiICsgc3RyICsgXCI+PC9cIiArIHRhZyArIFwiPlwiO1xuXG4gIFx0cmV0dXJuIHRvQXJyYXkoX0NvbmRpdGlvbmFsQXR0cmlidXRlX19kaXYuY2hpbGROb2Rlc1swXS5hdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdEluKGhheXN0YWNrLCBuZWVkbGUpIHtcbiAgXHR2YXIgaSA9IGhheXN0YWNrLmxlbmd0aDtcblxuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmIChoYXlzdGFja1tpXS5uYW1lID09PSBuZWVkbGUubmFtZSkge1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgY3JlYXRlQ29uZGl0aW9uYWxBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgXHRpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgXHRcdHJldHVybiBbXTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYXR0cmlidXRlcy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgXHRcdHJldHVybiBuZXcgX0NvbmRpdGlvbmFsQXR0cmlidXRlKGVsZW1lbnQsIGEpO1xuICBcdH0pO1xuICB9O1xuXG4gIHZhciBCaW5kaW5nID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgXHR2YXIgaW50ZXJwb2xhdG9yLCBrZXlwYXRoLCB2YWx1ZSwgcGFyZW50Rm9ybTtcblxuICBcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gZWxlbWVudC5yb290O1xuICBcdHRoaXMuYXR0cmlidXRlID0gZWxlbWVudC5hdHRyaWJ1dGVzW3RoaXMubmFtZSB8fCBcInZhbHVlXCJdO1xuXG4gIFx0aW50ZXJwb2xhdG9yID0gdGhpcy5hdHRyaWJ1dGUuaW50ZXJwb2xhdG9yO1xuICBcdGludGVycG9sYXRvci50d293YXlCaW5kaW5nID0gdGhpcztcblxuICBcdGlmIChrZXlwYXRoID0gaW50ZXJwb2xhdG9yLmtleXBhdGgpIHtcbiAgXHRcdGlmIChrZXlwYXRoLnN0ci5zbGljZSgtMSkgPT09IFwifVwiKSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhcIlR3by13YXkgYmluZGluZyBkb2VzIG5vdCB3b3JrIHdpdGggZXhwcmVzc2lvbnMgKGAlc2Agb24gPCVzPilcIiwgaW50ZXJwb2xhdG9yLnJlc29sdmVyLnVuaXF1ZVN0cmluZywgZWxlbWVudC5uYW1lLCB7IHJhY3RpdmU6IHRoaXMucm9vdCB9KTtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoa2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdFx0d2Fybk9uY2VJZkRlYnVnKFwiVHdvLXdheSBiaW5kaW5nIGRvZXMgbm90IHdvcmsgd2l0aCAlc1wiLCBpbnRlcnBvbGF0b3IucmVzb2x2ZXIucmVmLCB7IHJhY3RpdmU6IHRoaXMucm9vdCB9KTtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBBIG11c3RhY2hlIG1heSBiZSAqYW1iaWd1b3VzKi4gTGV0J3Mgc2F5IHdlIHdlcmUgZ2l2ZW5cbiAgXHRcdC8vIGB2YWx1ZT1cInt7YmFyfX1cImAuIElmIHRoZSBjb250ZXh0IHdhcyBgZm9vYCwgYW5kIGBmb28uYmFyYFxuICBcdFx0Ly8gKndhc24ndCogYHVuZGVmaW5lZGAsIHRoZSBrZXlwYXRoIHdvdWxkIGJlIGBmb28uYmFyYC5cbiAgXHRcdC8vIFRoZW4sIGFueSB1c2VyIGlucHV0IHdvdWxkIHJlc3VsdCBpbiBgZm9vLmJhcmAgYmVpbmcgdXBkYXRlZC5cbiAgXHRcdC8vXG4gIFx0XHQvLyBJZiwgaG93ZXZlciwgYGZvby5iYXJgICp3YXMqIHVuZGVmaW5lZCwgYW5kIHNvIHdhcyBgYmFyYCwgd2Ugd291bGQgYmVcbiAgXHRcdC8vIGxlZnQgd2l0aCBhbiB1bnJlc29sdmVkIHBhcnRpYWwga2V5cGF0aCAtIHNvIHdlIGFyZSBmb3JjZWQgdG8gbWFrZSBhblxuICBcdFx0Ly8gYXNzdW1wdGlvbi4gVGhhdCBhc3N1bXB0aW9uIGlzIHRoYXQgdGhlIGlucHV0IGluIHF1ZXN0aW9uIHNob3VsZFxuICBcdFx0Ly8gYmUgZm9yY2VkIHRvIHJlc29sdmUgdG8gYGJhcmAsIGFuZCBhbnkgdXNlciBpbnB1dCB3b3VsZCBhZmZlY3QgYGJhcmBcbiAgXHRcdC8vIGFuZCBub3QgYGZvby5iYXJgLlxuICBcdFx0Ly9cbiAgXHRcdC8vIERpZCB0aGF0IG1ha2UgYW55IHNlbnNlPyBObz8gT2guIFNvcnJ5LiBXZWxsIHRoZSBtb3JhbCBvZiB0aGUgc3RvcnkgaXNcbiAgXHRcdC8vIGJlIGV4cGxpY2l0IHdoZW4gdXNpbmcgdHdvLXdheSBkYXRhLWJpbmRpbmcgYWJvdXQgd2hhdCBrZXlwYXRoIHlvdSdyZVxuICBcdFx0Ly8gdXBkYXRpbmcuIFVzaW5nIGl0IGluIGxpc3RzIGlzIHByb2JhYmx5IGEgcmVjaXBlIGZvciBjb25mdXNpb24uLi5cbiAgXHRcdHZhciByZWYgPSBpbnRlcnBvbGF0b3IudGVtcGxhdGUuciA/IFwiJ1wiICsgaW50ZXJwb2xhdG9yLnRlbXBsYXRlLnIgKyBcIicgcmVmZXJlbmNlXCIgOiBcImV4cHJlc3Npb25cIjtcbiAgXHRcdHdhcm5JZkRlYnVnKFwiVGhlICVzIGJlaW5nIHVzZWQgZm9yIHR3by13YXkgYmluZGluZyBpcyBhbWJpZ3VvdXMsIGFuZCBtYXkgY2F1c2UgdW5leHBlY3RlZCByZXN1bHRzLiBDb25zaWRlciBpbml0aWFsaXNpbmcgeW91ciBkYXRhIHRvIGVsaW1pbmF0ZSB0aGUgYW1iaWd1aXR5XCIsIHJlZiwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0XHRpbnRlcnBvbGF0b3IucmVzb2x2ZXIuZm9yY2VSZXNvbHV0aW9uKCk7XG4gIFx0XHRrZXlwYXRoID0gaW50ZXJwb2xhdG9yLmtleXBhdGg7XG4gIFx0fVxuXG4gIFx0dGhpcy5hdHRyaWJ1dGUuaXNUd293YXkgPSB0cnVlO1xuICBcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cbiAgXHQvLyBpbml0aWFsaXNlIHZhbHVlLCBpZiBpdCdzIHVuZGVmaW5lZFxuICBcdHZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmdldEluaXRpYWxWYWx1ZSkge1xuICBcdFx0dmFsdWUgPSB0aGlzLmdldEluaXRpYWxWYWx1ZSgpO1xuXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldChrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHBhcmVudEZvcm0gPSBmaW5kUGFyZW50Rm9ybShlbGVtZW50KSkge1xuICBcdFx0dGhpcy5yZXNldFZhbHVlID0gdmFsdWU7XG4gIFx0XHRwYXJlbnRGb3JtLmZvcm1CaW5kaW5ncy5wdXNoKHRoaXMpO1xuICBcdH1cbiAgfTtcblxuICBCaW5kaW5nLnByb3RvdHlwZSA9IHtcbiAgXHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMucm9vdCk7XG4gIFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuICBcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQodGhpcy5rZXlwYXRoLCB0aGlzLmdldFZhbHVlKCkpO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIF90aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcbiAgXHRcdH0pO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0fSxcblxuICBcdHJlYm91bmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBiaW5kaW5ncywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aDtcblxuICBcdFx0b2xkS2V5cGF0aCA9IHRoaXMua2V5cGF0aDtcbiAgXHRcdG5ld0tleXBhdGggPSB0aGlzLmF0dHJpYnV0ZS5pbnRlcnBvbGF0b3Iua2V5cGF0aDtcblxuICBcdFx0Ly8gVGhlIGF0dHJpYnV0ZSB0aGlzIGJpbmRpbmcgaXMgbGlua2VkIHRvIGhhcyBhbHJlYWR5IGRvbmUgdGhlIHdvcmtcbiAgXHRcdGlmIChvbGRLZXlwYXRoID09PSBuZXdLZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3Nbb2xkS2V5cGF0aC5zdHJdLCB0aGlzKTtcblxuICBcdFx0dGhpcy5rZXlwYXRoID0gbmV3S2V5cGF0aDtcblxuICBcdFx0YmluZGluZ3MgPSB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzW25ld0tleXBhdGguc3RyXSB8fCAodGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tuZXdLZXlwYXRoLnN0cl0gPSBbXSk7XG4gIFx0XHRiaW5kaW5ncy5wdXNoKHRoaXMpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHt9XG4gIH07XG5cbiAgQmluZGluZy5leHRlbmQgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICBcdHZhciBQYXJlbnQgPSB0aGlzLFxuICBcdCAgICBTcGVjaWFsaXNlZEJpbmRpbmc7XG5cbiAgXHRTcGVjaWFsaXNlZEJpbmRpbmcgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBcdFx0QmluZGluZy5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuXG4gIFx0XHRpZiAodGhpcy5pbml0KSB7XG4gIFx0XHRcdHRoaXMuaW5pdCgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRTcGVjaWFsaXNlZEJpbmRpbmcucHJvdG90eXBlID0gY3JlYXRlKFBhcmVudC5wcm90b3R5cGUpO1xuICBcdHV0aWxzX29iamVjdF9fZXh0ZW5kKFNwZWNpYWxpc2VkQmluZGluZy5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuXG4gIFx0U3BlY2lhbGlzZWRCaW5kaW5nLmV4dGVuZCA9IEJpbmRpbmcuZXh0ZW5kO1xuXG4gIFx0cmV0dXJuIFNwZWNpYWxpc2VkQmluZGluZztcbiAgfTtcblxuICB2YXIgQmluZGluZ19CaW5kaW5nID0gQmluZGluZztcblxuICBmdW5jdGlvbiBmaW5kUGFyZW50Rm9ybShlbGVtZW50KSB7XG4gIFx0d2hpbGUgKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudCkge1xuICBcdFx0aWYgKGVsZW1lbnQubmFtZSA9PT0gXCJmb3JtXCIpIHtcbiAgXHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgLy8gdGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgZWxlbWVudCBpcyB1bmJvdW5kLlxuICAvLyBTcGVjaWFsaXNlZCBiaW5kaW5ncyBjYW4gb3ZlcnJpZGUgaXRcblxuICAvLyBUaGlzIGlzIHRoZSBoYW5kbGVyIGZvciBET00gZXZlbnRzIHRoYXQgd291bGQgbGVhZCB0byBhIGNoYW5nZSBpbiB0aGUgbW9kZWxcbiAgLy8gKGkuZS4gY2hhbmdlLCBzb21ldGltZXMsIGlucHV0LCBhbmQgb2NjYXNpb25hbGx5IGNsaWNrIGFuZCBrZXl1cClcbiAgdmFyIGhhbmRsZURvbUV2ZW50ID0gaGFuZGxlQ2hhbmdlO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSgpIHtcbiAgXHR0aGlzLl9yYWN0aXZlLmJpbmRpbmcuaGFuZGxlQ2hhbmdlKCk7XG4gIH1cblxuICB2YXIgQ29udGVudEVkaXRhYmxlQmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5mcmFnbWVudCA/IHRoaXMuZWxlbWVudC5mcmFnbWVudC50b1N0cmluZygpIDogXCJcIjtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0aWYgKCF0aGlzLnJvb3QubGF6eSkge1xuICBcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuXG4gIFx0XHRcdGlmIChub2RlLmF0dGFjaEV2ZW50KSB7XG4gIFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5pbm5lckhUTUw7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19Db250ZW50RWRpdGFibGVCaW5kaW5nID0gQ29udGVudEVkaXRhYmxlQmluZGluZztcblxuICB2YXIgc2hhcmVkX2dldFNpYmxpbmdzID0gZ2V0U2libGluZ3M7XG4gIHZhciBzZXRzID0ge307XG4gIGZ1bmN0aW9uIGdldFNpYmxpbmdzKGlkLCBncm91cCwga2V5cGF0aCkge1xuICBcdHZhciBoYXNoID0gaWQgKyBncm91cCArIGtleXBhdGg7XG4gIFx0cmV0dXJuIHNldHNbaGFzaF0gfHwgKHNldHNbaGFzaF0gPSBbXSk7XG4gIH1cblxuICB2YXIgUmFkaW9CaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0bmFtZTogXCJjaGVja2VkXCIsXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnNpYmxpbmdzID0gc2hhcmVkX2dldFNpYmxpbmdzKHRoaXMucm9vdC5fZ3VpZCwgXCJyYWRpb1wiLCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSk7XG4gIFx0XHR0aGlzLnNpYmxpbmdzLnB1c2godGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdGlmIChub2RlLmF0dGFjaEV2ZW50KSB7XG4gIFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcy5yb290KTtcblxuICBcdFx0dGhpcy5zaWJsaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gIFx0XHRcdGJpbmRpbmcucm9vdC52aWV3bW9kZWwuc2V0KGJpbmRpbmcua2V5cGF0aCwgYmluZGluZy5nZXRWYWx1ZSgpKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLnNpYmxpbmdzLCB0aGlzKTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX1JhZGlvQmluZGluZyA9IFJhZGlvQmluZGluZztcblxuICB2YXIgUmFkaW9OYW1lQmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdG5hbWU6IFwibmFtZVwiLFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5zaWJsaW5ncyA9IHNoYXJlZF9nZXRTaWJsaW5ncyh0aGlzLnJvb3QuX2d1aWQsIFwicmFkaW9uYW1lXCIsIHRoaXMua2V5cGF0aC5zdHIpO1xuICBcdFx0dGhpcy5zaWJsaW5ncy5wdXNoKHRoaXMpO1xuXG4gIFx0XHR0aGlzLnJhZGlvTmFtZSA9IHRydWU7IC8vIHNvIHRoYXQgcmFjdGl2ZS51cGRhdGVNb2RlbCgpIGtub3dzIHdoYXQgdG8gZG8gd2l0aCB0aGlzXG4gIFx0fSxcblxuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIpKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5uYW1lID0gXCJ7e1wiICsgdGhpcy5rZXlwYXRoLnN0ciArIFwifX1cIjtcbiAgXHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KHRoaXMua2V5cGF0aCkgPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG4gIFx0XHRyZXR1cm4gbm9kZS5fcmFjdGl2ZSA/IG5vZGUuX3JhY3RpdmUudmFsdWUgOiBub2RlLnZhbHVlO1xuICBcdH0sXG5cbiAgXHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIElmIHRoaXMgPGlucHV0PiBpcyB0aGUgb25lIHRoYXQncyBjaGVja2VkLCB0aGVuIHRoZSB2YWx1ZSBvZiBpdHNcbiAgXHRcdC8vIGBuYW1lYCBrZXlwYXRoIGdldHMgc2V0IHRvIGl0cyB2YWx1ZVxuICBcdFx0aWYgKHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQpIHtcbiAgXHRcdFx0QmluZGluZ19CaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UuY2FsbCh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVib3VuZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHZhciBub2RlO1xuXG4gIFx0XHRCaW5kaW5nX0JpbmRpbmcucHJvdG90eXBlLnJlYm91bmQuY2FsbCh0aGlzLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcblxuICBcdFx0aWYgKG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZSkge1xuICBcdFx0XHRub2RlLm5hbWUgPSBcInt7XCIgKyB0aGlzLmtleXBhdGguc3RyICsgXCJ9fVwiO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLnNpYmxpbmdzLCB0aGlzKTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX1JhZGlvTmFtZUJpbmRpbmcgPSBSYWRpb05hbWVCaW5kaW5nO1xuXG4gIHZhciBDaGVja2JveE5hbWVCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0bmFtZTogXCJuYW1lXCIsXG5cbiAgXHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFRoaXMgb25seSBnZXRzIGNhbGxlZCBvbmNlIHBlciBncm91cCAob2YgaW5wdXRzIHRoYXRcbiAgXHRcdC8vIHNoYXJlIGEgbmFtZSksIGJlY2F1c2UgaXQgb25seSBnZXRzIGNhbGxlZCBpZiB0aGVyZVxuICBcdFx0Ly8gaXNuJ3QgYW4gaW5pdGlhbCB2YWx1ZS4gQnkgdGhlIHNhbWUgdG9rZW4sIHdlIGNhbiBtYWtlXG4gIFx0XHQvLyBhIG5vdGUgb2YgdGhhdCBmYWN0IHRoYXQgdGhlcmUgd2FzIG5vIGluaXRpYWwgdmFsdWUsXG4gIFx0XHQvLyBhbmQgcG9wdWxhdGUgaXQgdXNpbmcgYW55IGBjaGVja2VkYCBhdHRyaWJ1dGVzIHRoYXRcbiAgXHRcdC8vIGV4aXN0ICh3aGljaCB1c2VycyBzaG91bGQgYXZvaWQsIGJ1dCB3aGljaCB3ZSBzaG91bGRcbiAgXHRcdC8vIHN1cHBvcnQgYW55d2F5IHRvIGF2b2lkIGJyZWFraW5nIGV4cGVjdGF0aW9ucylcbiAgXHRcdHRoaXMubm9Jbml0aWFsVmFsdWUgPSB0cnVlO1xuICBcdFx0cmV0dXJuIFtdO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlO1xuXG4gIFx0XHR0aGlzLmNoZWNrYm94TmFtZSA9IHRydWU7IC8vIHNvIHRoYXQgcmFjdGl2ZS51cGRhdGVNb2RlbCgpIGtub3dzIHdoYXQgdG8gZG8gd2l0aCB0aGlzXG5cbiAgXHRcdC8vIEVhY2ggaW5wdXQgaGFzIGEgcmVmZXJlbmNlIHRvIGFuIGFycmF5IGNvbnRhaW5pbmcgaXQgYW5kIGl0c1xuICBcdFx0Ly8gc2libGluZ3MsIGFzIHR3by13YXkgYmluZGluZyBkZXBlbmRzIG9uIGJlaW5nIGFibGUgdG8gYXNjZXJ0YWluXG4gIFx0XHQvLyB0aGUgc3RhdHVzIG9mIGFsbCBpbnB1dHMgd2l0aGluIHRoZSBncm91cFxuICBcdFx0dGhpcy5zaWJsaW5ncyA9IHNoYXJlZF9nZXRTaWJsaW5ncyh0aGlzLnJvb3QuX2d1aWQsIFwiY2hlY2tib3hlc1wiLCB0aGlzLmtleXBhdGguc3RyKTtcbiAgXHRcdHRoaXMuc2libGluZ3MucHVzaCh0aGlzKTtcblxuICBcdFx0aWYgKHRoaXMubm9Jbml0aWFsVmFsdWUpIHtcbiAgXHRcdFx0dGhpcy5zaWJsaW5ncy5ub0luaXRpYWxWYWx1ZSA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIElmIG5vIGluaXRpYWwgdmFsdWUgd2FzIHNldCwgYW5kIHRoaXMgaW5wdXQgaXMgY2hlY2tlZCwgd2VcbiAgXHRcdC8vIHVwZGF0ZSB0aGUgbW9kZWxcbiAgXHRcdGlmICh0aGlzLnNpYmxpbmdzLm5vSW5pdGlhbFZhbHVlICYmIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIpKSB7XG4gIFx0XHRcdGV4aXN0aW5nVmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLmtleXBhdGgpO1xuICBcdFx0XHRiaW5kaW5nVmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRcdFx0ZXhpc3RpbmdWYWx1ZS5wdXNoKGJpbmRpbmdWYWx1ZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuc2libGluZ3MsIHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGUsXG4gIFx0XHQgICAgZXhpc3RpbmdWYWx1ZSxcbiAgXHRcdCAgICBiaW5kaW5nVmFsdWU7XG5cbiAgXHRcdGV4aXN0aW5nVmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLmtleXBhdGgpO1xuICBcdFx0YmluZGluZ1ZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0XHRpZiAoaXNBcnJheShleGlzdGluZ1ZhbHVlKSkge1xuICBcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IGFycmF5Q29udGFpbnMoZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuaXNDaGVja2VkID0gZXhpc3RpbmdWYWx1ZSA9PSBiaW5kaW5nVmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdG5vZGUubmFtZSA9IFwie3tcIiArIHRoaXMua2V5cGF0aC5zdHIgKyBcIn19XCI7XG4gIFx0XHRub2RlLmNoZWNrZWQgPSB0aGlzLmlzQ2hlY2tlZDtcblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdC8vIGluIGNhc2Ugb2YgSUUgZW1lcmdlbmN5LCBiaW5kIHRvIGNsaWNrIGV2ZW50IGFzIHdlbGxcbiAgXHRcdGlmIChub2RlLmF0dGFjaEV2ZW50KSB7XG4gIFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdGNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB3YXNDaGVja2VkID0gISF0aGlzLmlzQ2hlY2tlZDtcbiAgXHRcdHRoaXMuaXNDaGVja2VkID0gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcbiAgXHRcdHJldHVybiB0aGlzLmlzQ2hlY2tlZCA9PT0gd2FzQ2hlY2tlZDtcbiAgXHR9LFxuXG4gIFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmlzQ2hlY2tlZCA9IHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG4gIFx0XHRCaW5kaW5nX0JpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZS5jYWxsKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuc2libGluZ3MuZmlsdGVyKGlzQ2hlY2tlZCkubWFwKEJpbmRpbmdfQ2hlY2tib3hOYW1lQmluZGluZ19fZ2V0VmFsdWUpO1xuICBcdH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gaXNDaGVja2VkKGJpbmRpbmcpIHtcbiAgXHRyZXR1cm4gYmluZGluZy5pc0NoZWNrZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBCaW5kaW5nX0NoZWNrYm94TmFtZUJpbmRpbmdfX2dldFZhbHVlKGJpbmRpbmcpIHtcbiAgXHRyZXR1cm4gYmluZGluZy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICB9XG5cbiAgdmFyIEJpbmRpbmdfQ2hlY2tib3hOYW1lQmluZGluZyA9IENoZWNrYm94TmFtZUJpbmRpbmc7XG5cbiAgdmFyIENoZWNrYm94QmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdG5hbWU6IFwiY2hlY2tlZFwiLFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfQ2hlY2tib3hCaW5kaW5nID0gQ2hlY2tib3hCaW5kaW5nO1xuXG4gIHZhciBTZWxlY3RCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuZWxlbWVudC5vcHRpb25zLFxuICBcdFx0ICAgIGxlbixcbiAgXHRcdCAgICBpLFxuICBcdFx0ICAgIHZhbHVlLFxuICBcdFx0ICAgIG9wdGlvbldhc1NlbGVjdGVkO1xuXG4gIFx0XHRpZiAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpID0gbGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHRcdGlmICghbGVuKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gdGFrZSB0aGUgZmluYWwgc2VsZWN0ZWQgb3B0aW9uLi4uXG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGlmIChvcHRpb25zW2ldLmdldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIpKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zW2ldLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdFx0XHRcdG9wdGlvbldhc1NlbGVjdGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBvciB0aGUgZmlyc3Qgbm9uLWRpc2FibGVkIG9wdGlvbiwgaWYgbm9uZSBhcmUgc2VsZWN0ZWRcbiAgXHRcdGlmICghb3B0aW9uV2FzU2VsZWN0ZWQpIHtcbiAgXHRcdFx0d2hpbGUgKCsraSA8IGxlbikge1xuICBcdFx0XHRcdGlmICghb3B0aW9uc1tpXS5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSkge1xuICBcdFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zW2ldLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFRoaXMgaXMgYW4gb3B0aW1pc2F0aW9uIChha2EgaGFjaykgdGhhdCBhbGxvd3MgdXMgdG8gZm9yZ28gc29tZVxuICBcdFx0Ly8gb3RoZXIgbW9yZSBleHBlbnNpdmUgd29ya1xuICBcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5lbGVtZW50LmF0dHJpYnV0ZXMudmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHZhbHVlO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Ly8gVE9ETyB0aGlzIG1ldGhvZCBpcyBhbiBhbm9tYWx5Li4uIGlzIGl0IG5lY2Vzc2FyeT9cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCh0aGlzLmtleXBhdGgsIHZhbHVlKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBvcHRpb25zLCBpLCBsZW4sIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cbiAgXHRcdG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQubm9kZS5vcHRpb25zO1xuICBcdFx0bGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRvcHRpb24gPSBvcHRpb25zW2ldO1xuXG4gIFx0XHRcdGlmIChvcHRpb25zW2ldLnNlbGVjdGVkKSB7XG4gIFx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG4gIFx0XHRcdFx0cmV0dXJuIG9wdGlvblZhbHVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIF90aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcbiAgXHRcdFx0fSk7XG4gIFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KHRoaXMua2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfU2VsZWN0QmluZGluZyA9IFNlbGVjdEJpbmRpbmc7XG5cbiAgdmFyIE11bHRpcGxlU2VsZWN0QmluZGluZyA9IEJpbmRpbmdfU2VsZWN0QmluZGluZy5leHRlbmQoe1xuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5vcHRpb25zLmZpbHRlcihmdW5jdGlvbiAob3B0aW9uKSB7XG4gIFx0XHRcdHJldHVybiBvcHRpb24uZ2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIik7XG4gIFx0XHR9KS5tYXAoZnVuY3Rpb24gKG9wdGlvbikge1xuICBcdFx0XHRyZXR1cm4gb3B0aW9uLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdFx0fSk7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHZhbHVlRnJvbU1vZGVsO1xuXG4gIFx0XHR0aGlzLmVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdHZhbHVlRnJvbU1vZGVsID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQodGhpcy5rZXlwYXRoKTtcblxuICBcdFx0aWYgKHZhbHVlRnJvbU1vZGVsID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0Ly8gZ2V0IHZhbHVlIGZyb20gRE9NLCBpZiBwb3NzaWJsZVxuICBcdFx0XHR0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVE9ETyBub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHNlbGVjdGVkVmFsdWVzLCBvcHRpb25zLCBpLCBsZW4sIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cbiAgXHRcdHNlbGVjdGVkVmFsdWVzID0gW107XG4gIFx0XHRvcHRpb25zID0gdGhpcy5lbGVtZW50Lm5vZGUub3B0aW9ucztcbiAgXHRcdGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0b3B0aW9uID0gb3B0aW9uc1tpXTtcblxuICBcdFx0XHRpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gIFx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG4gIFx0XHRcdFx0c2VsZWN0ZWRWYWx1ZXMucHVzaChvcHRpb25WYWx1ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHNlbGVjdGVkVmFsdWVzO1xuICBcdH0sXG5cbiAgXHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBhdHRyaWJ1dGUsIHByZXZpb3VzVmFsdWUsIHZhbHVlO1xuXG4gIFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZTtcbiAgXHRcdHByZXZpb3VzVmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG5cbiAgXHRcdHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG4gIFx0XHRpZiAocHJldmlvdXNWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFhcnJheUNvbnRlbnRzTWF0Y2godmFsdWUsIHByZXZpb3VzVmFsdWUpKSB7XG4gIFx0XHRcdEJpbmRpbmdfU2VsZWN0QmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwodGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH0sXG5cbiAgXHRmb3JjZVVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHJldHVybiBfdGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG4gIFx0XHRcdH0pO1xuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCh0aGlzLmtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dXBkYXRlTW9kZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmF0dHJpYnV0ZS52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICF0aGlzLmF0dHJpYnV0ZS52YWx1ZS5sZW5ndGgpIHtcbiAgXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQodGhpcy5rZXlwYXRoLCB0aGlzLmluaXRpYWxWYWx1ZSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19NdWx0aXBsZVNlbGVjdEJpbmRpbmcgPSBNdWx0aXBsZVNlbGVjdEJpbmRpbmc7XG5cbiAgdmFyIEZpbGVMaXN0QmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmZpbGVzO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfRmlsZUxpc3RCaW5kaW5nID0gRmlsZUxpc3RCaW5kaW5nO1xuXG4gIHZhciBHZW5lcmljQmluZGluZztcblxuICBHZW5lcmljQmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIFwiXCI7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUudmFsdWU7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZSxcbiAgXHRcdCAgICBsYXp5LFxuICBcdFx0ICAgIHRpbWVvdXQgPSBmYWxzZTtcbiAgXHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXG4gIFx0XHQvLyBhbnkgbGF6eSBzZXR0aW5nIGZvciB0aGlzIGVsZW1lbnQgb3ZlcnJpZGVzIHRoZSByb290XG4gIFx0XHQvLyBpZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0J3MgYSB0aW1lb3V0XG4gIFx0XHRsYXp5ID0gdGhpcy5yb290Lmxhenk7XG4gIFx0XHRpZiAodGhpcy5lbGVtZW50LmxhenkgPT09IHRydWUpIHtcbiAgXHRcdFx0bGF6eSA9IHRydWU7XG4gIFx0XHR9IGVsc2UgaWYgKHRoaXMuZWxlbWVudC5sYXp5ID09PSBmYWxzZSkge1xuICBcdFx0XHRsYXp5ID0gZmFsc2U7XG4gIFx0XHR9IGVsc2UgaWYgKGlzX19pc051bWVyaWModGhpcy5lbGVtZW50LmxhenkpKSB7XG4gIFx0XHRcdGxhenkgPSBmYWxzZTtcbiAgXHRcdFx0dGltZW91dCA9ICt0aGlzLmVsZW1lbnQubGF6eTtcbiAgXHRcdH0gZWxzZSBpZiAoaXNfX2lzTnVtZXJpYyhsYXp5IHx8IFwiXCIpKSB7XG4gIFx0XHRcdHRpbWVvdXQgPSArbGF6eTtcbiAgXHRcdFx0bGF6eSA9IGZhbHNlO1xuXG4gIFx0XHRcdC8vIG1ha2Ugc3VyZSB0aGUgdGltZW91dCBpcyBhdmFpbGFibGUgdG8gdGhlIGhhbmRsZXJcbiAgXHRcdFx0dGhpcy5lbGVtZW50LmxhenkgPSB0aW1lb3V0O1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmhhbmRsZXIgPSB0aW1lb3V0ID8gaGFuZGxlRGVsYXkgOiBoYW5kbGVEb21FdmVudDtcblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdGlmICghbGF6eSkge1xuICBcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLmhhbmRsZXIsIGZhbHNlKTtcblxuICBcdFx0XHRpZiAobm9kZS5hdHRhY2hFdmVudCkge1xuICBcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMuaGFuZGxlciwgZmFsc2UpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgaGFuZGxlQmx1ciwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcbiAgXHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcblxuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLmhhbmRsZXIsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMuaGFuZGxlciwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBoYW5kbGVCbHVyLCBmYWxzZSk7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19HZW5lcmljQmluZGluZyA9IEdlbmVyaWNCaW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUJsdXIoKSB7XG4gIFx0dmFyIHZhbHVlO1xuXG4gIFx0aGFuZGxlRG9tRXZlbnQuY2FsbCh0aGlzKTtcblxuICBcdHZhbHVlID0gdGhpcy5fcmFjdGl2ZS5yb290LnZpZXdtb2RlbC5nZXQodGhpcy5fcmFjdGl2ZS5iaW5kaW5nLmtleXBhdGgpO1xuICBcdHRoaXMudmFsdWUgPSB2YWx1ZSA9PSB1bmRlZmluZWQgPyBcIlwiIDogdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVEZWxheSgpIHtcbiAgXHR2YXIgYmluZGluZyA9IHRoaXMuX3JhY3RpdmUuYmluZGluZyxcbiAgXHQgICAgZWwgPSB0aGlzO1xuXG4gIFx0aWYgKCEhYmluZGluZy5fdGltZW91dCkgY2xlYXJUaW1lb3V0KGJpbmRpbmcuX3RpbWVvdXQpO1xuXG4gIFx0YmluZGluZy5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKGJpbmRpbmcucmVuZGVyZWQpIGhhbmRsZURvbUV2ZW50LmNhbGwoZWwpO1xuICBcdFx0YmluZGluZy5fdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgXHR9LCBiaW5kaW5nLmVsZW1lbnQubGF6eSk7XG4gIH1cblxuICB2YXIgTnVtZXJpY0JpbmRpbmcgPSBCaW5kaW5nX0dlbmVyaWNCaW5kaW5nLmV4dGVuZCh7XG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLmVsZW1lbnQubm9kZS52YWx1ZSk7XG4gIFx0XHRyZXR1cm4gaXNOYU4odmFsdWUpID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgaW5pdF9jcmVhdGVUd293YXlCaW5kaW5nID0gY3JlYXRlVHdvd2F5QmluZGluZztcblxuICBmdW5jdGlvbiBjcmVhdGVUd293YXlCaW5kaW5nKGVsZW1lbnQpIHtcbiAgXHR2YXIgYXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcyxcbiAgXHQgICAgdHlwZSxcbiAgXHQgICAgQmluZGluZyxcbiAgXHQgICAgYmluZE5hbWUsXG4gIFx0ICAgIGJpbmRDaGVja2VkLFxuICBcdCAgICBiaW5kaW5nO1xuXG4gIFx0Ly8gaWYgdGhpcyBpcyBhIGxhdGUgYmluZGluZywgYW5kIHRoZXJlJ3MgYWxyZWFkeSBvbmUsIGl0XG4gIFx0Ly8gbmVlZHMgdG8gYmUgdG9ybiBkb3duXG4gIFx0aWYgKGVsZW1lbnQuYmluZGluZykge1xuICBcdFx0ZWxlbWVudC5iaW5kaW5nLnRlYXJkb3duKCk7XG4gIFx0XHRlbGVtZW50LmJpbmRpbmcgPSBudWxsO1xuICBcdH1cblxuICBcdC8vIGNvbnRlbnRlZGl0YWJsZVxuICBcdGlmIChcbiAgXHQvLyBpZiB0aGUgY29udGVudGVkaXRhYmxlIGF0dHJpYnV0ZSBpcyB0cnVlIG9yIGlzIGJpbmRhYmxlIGFuZCBtYXkgdGh1cyBiZWNvbWUgdHJ1ZVxuICBcdChlbGVtZW50LmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSB8fCAhIWF0dHJpYnV0ZXMuY29udGVudGVkaXRhYmxlICYmIGlzQmluZGFibGUoYXR0cmlidXRlcy5jb250ZW50ZWRpdGFibGUpKSAmJiBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMudmFsdWUpKSB7XG4gIFx0XHRCaW5kaW5nID0gQmluZGluZ19Db250ZW50RWRpdGFibGVCaW5kaW5nO1xuICBcdH1cblxuICBcdC8vIDxpbnB1dD5cbiAgXHRlbHNlIGlmIChlbGVtZW50Lm5hbWUgPT09IFwiaW5wdXRcIikge1xuICBcdFx0dHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcblxuICBcdFx0aWYgKHR5cGUgPT09IFwicmFkaW9cIiB8fCB0eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgXHRcdFx0YmluZE5hbWUgPSBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMubmFtZSk7XG4gIFx0XHRcdGJpbmRDaGVja2VkID0gaXNCaW5kYWJsZShhdHRyaWJ1dGVzLmNoZWNrZWQpO1xuXG4gIFx0XHRcdC8vIHdlIGNhbiBlaXRoZXIgYmluZCB0aGUgbmFtZSBhdHRyaWJ1dGUsIG9yIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSAtIG5vdCBib3RoXG4gIFx0XHRcdGlmIChiaW5kTmFtZSAmJiBiaW5kQ2hlY2tlZCkge1xuICBcdFx0XHRcdHdhcm5JZkRlYnVnKFwiQSByYWRpbyBpbnB1dCBjYW4gaGF2ZSB0d28td2F5IGJpbmRpbmcgb24gaXRzIG5hbWUgYXR0cmlidXRlLCBvciBpdHMgY2hlY2tlZCBhdHRyaWJ1dGUgLSBub3QgYm90aFwiLCB7IHJhY3RpdmU6IGVsZW1lbnQucm9vdCB9KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChiaW5kTmFtZSkge1xuICBcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSBcInJhZGlvXCIgPyBCaW5kaW5nX1JhZGlvTmFtZUJpbmRpbmcgOiBCaW5kaW5nX0NoZWNrYm94TmFtZUJpbmRpbmc7XG4gIFx0XHRcdH0gZWxzZSBpZiAoYmluZENoZWNrZWQpIHtcbiAgXHRcdFx0XHRCaW5kaW5nID0gdHlwZSA9PT0gXCJyYWRpb1wiID8gQmluZGluZ19SYWRpb0JpbmRpbmcgOiBCaW5kaW5nX0NoZWNrYm94QmluZGluZztcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIGlmICh0eXBlID09PSBcImZpbGVcIiAmJiBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMudmFsdWUpKSB7XG4gIFx0XHRcdEJpbmRpbmcgPSBCaW5kaW5nX0ZpbGVMaXN0QmluZGluZztcbiAgXHRcdH0gZWxzZSBpZiAoaXNCaW5kYWJsZShhdHRyaWJ1dGVzLnZhbHVlKSkge1xuICBcdFx0XHRCaW5kaW5nID0gdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInJhbmdlXCIgPyBOdW1lcmljQmluZGluZyA6IEJpbmRpbmdfR2VuZXJpY0JpbmRpbmc7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gPHNlbGVjdD5cbiAgXHRlbHNlIGlmIChlbGVtZW50Lm5hbWUgPT09IFwic2VsZWN0XCIgJiYgaXNCaW5kYWJsZShhdHRyaWJ1dGVzLnZhbHVlKSkge1xuICBcdFx0QmluZGluZyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikgPyBCaW5kaW5nX011bHRpcGxlU2VsZWN0QmluZGluZyA6IEJpbmRpbmdfU2VsZWN0QmluZGluZztcbiAgXHR9XG5cbiAgXHQvLyA8dGV4dGFyZWE+XG4gIFx0ZWxzZSBpZiAoZWxlbWVudC5uYW1lID09PSBcInRleHRhcmVhXCIgJiYgaXNCaW5kYWJsZShhdHRyaWJ1dGVzLnZhbHVlKSkge1xuICBcdFx0QmluZGluZyA9IEJpbmRpbmdfR2VuZXJpY0JpbmRpbmc7XG4gIFx0fVxuXG4gIFx0aWYgKEJpbmRpbmcgJiYgKGJpbmRpbmcgPSBuZXcgQmluZGluZyhlbGVtZW50KSkgJiYgYmluZGluZy5rZXlwYXRoKSB7XG4gIFx0XHRyZXR1cm4gYmluZGluZztcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBpc0JpbmRhYmxlKGF0dHJpYnV0ZSkge1xuICBcdHJldHVybiBhdHRyaWJ1dGUgJiYgYXR0cmlidXRlLmlzQmluZGFibGU7XG4gIH1cblxuICAvLyBhbmQgdGhpcyBlbGVtZW50IGFsc28gaGFzIGEgdmFsdWUgYXR0cmlidXRlIHRvIGJpbmRcblxuICB2YXIgRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9idWJibGUgPSBFdmVudEhhbmRsZXIkYnViYmxlO1xuXG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRidWJibGUoKSB7XG4gIFx0dmFyIGhhc0FjdGlvbiA9IHRoaXMuZ2V0QWN0aW9uKCk7XG5cbiAgXHRpZiAoaGFzQWN0aW9uICYmICF0aGlzLmhhc0xpc3RlbmVyKSB7XG4gIFx0XHR0aGlzLmxpc3RlbigpO1xuICBcdH0gZWxzZSBpZiAoIWhhc0FjdGlvbiAmJiB0aGlzLmhhc0xpc3RlbmVyKSB7XG4gIFx0XHR0aGlzLnVucmVuZGVyKCk7XG4gIFx0fVxuICB9XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBtYXkgYmUgb3ZlcndyaXR0ZW4sIGlmIHRoZSBldmVudCBkaXJlY3RpdmVcbiAgLy8gaW5jbHVkZXMgcGFyYW1ldGVyc1xuICB2YXIgRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9maXJlID0gRXZlbnRIYW5kbGVyJGZpcmU7XG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRmaXJlKGV2ZW50KSB7XG4gIFx0c2hhcmVkX2ZpcmVFdmVudCh0aGlzLnJvb3QsIHRoaXMuZ2V0QWN0aW9uKCksIHsgZXZlbnQ6IGV2ZW50IH0pO1xuICB9XG5cbiAgdmFyIGdldEFjdGlvbiA9IEV2ZW50SGFuZGxlciRnZXRBY3Rpb247XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGdldEFjdGlvbigpIHtcbiAgXHRyZXR1cm4gdGhpcy5hY3Rpb24udG9TdHJpbmcoKS50cmltKCk7XG4gIH1cblxuICB2YXIgRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9pbml0ID0gRXZlbnRIYW5kbGVyJGluaXQ7XG5cbiAgdmFyIGV2ZW50UGF0dGVybiA9IC9eZXZlbnQoPzpcXC4oLispKT8vO1xuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkaW5pdChlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgYWN0aW9uLCByZWZzLCByYWN0aXZlO1xuXG4gIFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgXHR0aGlzLnJvb3QgPSBlbGVtZW50LnJvb3Q7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5uYW1lID0gbmFtZTtcblxuICBcdGlmIChuYW1lLmluZGV4T2YoXCIqXCIpICE9PSAtMSkge1xuICBcdFx0ZmF0YWwoXCJPbmx5IGNvbXBvbmVudCBwcm94eS1ldmVudHMgbWF5IGNvbnRhaW4gXFxcIipcXFwiIHdpbGRjYXJkcywgPCVzIG9uLSVzPVxcXCIuLi5cXFwiLz4gaXMgbm90IHZhbGlkXCIsIGVsZW1lbnQubmFtZSwgbmFtZSk7XG4gIFx0XHR0aGlzLmludmFsaWQgPSB0cnVlO1xuICBcdH1cblxuICBcdGlmICh0ZW1wbGF0ZS5tKSB7XG4gIFx0XHRyZWZzID0gdGVtcGxhdGUuYS5yO1xuXG4gIFx0XHQvLyBUaGlzIGlzIGEgbWV0aG9kIGNhbGxcbiAgXHRcdHRoaXMubWV0aG9kID0gdGVtcGxhdGUubTtcbiAgXHRcdHRoaXMua2V5cGF0aHMgPSBbXTtcbiAgXHRcdHRoaXMuZm4gPSBzaGFyZWRfZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nKHRlbXBsYXRlLmEucywgcmVmcy5sZW5ndGgpO1xuXG4gIFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHRcdHJhY3RpdmUgPSB0aGlzLnJvb3Q7XG5cbiAgXHRcdC8vIENyZWF0ZSByZXNvbHZlcnMgZm9yIGVhY2ggcmVmZXJlbmNlXG4gIFx0XHR0aGlzLnJlZlJlc29sdmVycyA9IFtdO1xuICBcdFx0cmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYsIGkpIHtcbiAgXHRcdFx0dmFyIG1hdGNoID0gdW5kZWZpbmVkO1xuXG4gIFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIHRoZSBgZXZlbnRgIG9iamVjdFxuICBcdFx0XHRpZiAobWF0Y2ggPSBldmVudFBhdHRlcm4uZXhlYyhyZWYpKSB7XG4gIFx0XHRcdFx0X3RoaXMua2V5cGF0aHNbaV0gPSB7XG4gIFx0XHRcdFx0XHRldmVudE9iamVjdDogdHJ1ZSxcbiAgXHRcdFx0XHRcdHJlZmluZW1lbnRzOiBtYXRjaFsxXSA/IG1hdGNoWzFdLnNwbGl0KFwiLlwiKSA6IFtdXG4gIFx0XHRcdFx0fTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRfdGhpcy5yZWZSZXNvbHZlcnMucHVzaChSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoX3RoaXMsIHJlZiwgZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0XHRcdHJldHVybiBfdGhpcy5yZXNvbHZlKGksIGtleXBhdGgpO1xuICBcdFx0XHRcdH0pKTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMuZmlyZSA9IGZpcmVNZXRob2RDYWxsO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBHZXQgYWN0aW9uICgnZm9vJyBpbiAnb24tY2xpY2s9J2ZvbycpXG4gIFx0XHRhY3Rpb24gPSB0ZW1wbGF0ZS5uIHx8IHRlbXBsYXRlO1xuICBcdFx0aWYgKHR5cGVvZiBhY3Rpb24gIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0YWN0aW9uID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHRcdHRlbXBsYXRlOiBhY3Rpb24sXG4gIFx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuICBcdFx0XHRcdG93bmVyOiB0aGlzXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmFjdGlvbiA9IGFjdGlvbjtcblxuICBcdFx0Ly8gR2V0IHBhcmFtZXRlcnNcbiAgXHRcdGlmICh0ZW1wbGF0ZS5kKSB7XG4gIFx0XHRcdHRoaXMuZHluYW1pY1BhcmFtcyA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZCxcbiAgXHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG4gIFx0XHRcdFx0b3duZXI6IHRoaXMuZWxlbWVudFxuICBcdFx0XHR9KTtcblxuICBcdFx0XHR0aGlzLmZpcmUgPSBmaXJlRXZlbnRXaXRoRHluYW1pY1BhcmFtcztcbiAgXHRcdH0gZWxzZSBpZiAodGVtcGxhdGUuYSkge1xuICBcdFx0XHR0aGlzLnBhcmFtcyA9IHRlbXBsYXRlLmE7XG4gIFx0XHRcdHRoaXMuZmlyZSA9IGZpcmVFdmVudFdpdGhQYXJhbXM7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZmlyZU1ldGhvZENhbGwoZXZlbnQpIHtcbiAgXHR2YXIgcmFjdGl2ZSwgdmFsdWVzLCBhcmdzO1xuXG4gIFx0cmFjdGl2ZSA9IHRoaXMucm9vdDtcblxuICBcdGlmICh0eXBlb2YgcmFjdGl2ZVt0aGlzLm1ldGhvZF0gIT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGNhbGwgYSBub24tZXhpc3RlbnQgbWV0aG9kIChcXFwiXCIgKyB0aGlzLm1ldGhvZCArIFwiXFxcIilcIik7XG4gIFx0fVxuXG4gIFx0dmFsdWVzID0gdGhpcy5rZXlwYXRocy5tYXAoZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHZhciB2YWx1ZSwgbGVuLCBpO1xuXG4gIFx0XHRpZiAoa2V5cGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdC8vIG5vdCB5ZXQgcmVzb2x2ZWRcbiAgXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gVE9ETyB0aGUgcmVmaW5lbWVudHMgc3R1ZmYgd291bGQgYmUgYmV0dGVyIGhhbmRsZWQgYXQgcGFyc2UgdGltZVxuICBcdFx0aWYgKGtleXBhdGguZXZlbnRPYmplY3QpIHtcbiAgXHRcdFx0dmFsdWUgPSBldmVudDtcblxuICBcdFx0XHRpZiAobGVuID0ga2V5cGF0aC5yZWZpbmVtZW50cy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVba2V5cGF0aC5yZWZpbmVtZW50c1tpXV07XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR2YWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLmdldChrZXlwYXRoKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHZhbHVlO1xuICBcdH0pO1xuXG4gIFx0c2hhcmVkX2V2ZW50U3RhY2suZW5xdWV1ZShyYWN0aXZlLCBldmVudCk7XG5cbiAgXHRhcmdzID0gdGhpcy5mbi5hcHBseShudWxsLCB2YWx1ZXMpO1xuICBcdHJhY3RpdmVbdGhpcy5tZXRob2RdLmFwcGx5KHJhY3RpdmUsIGFyZ3MpO1xuXG4gIFx0c2hhcmVkX2V2ZW50U3RhY2suZGVxdWV1ZShyYWN0aXZlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVFdmVudFdpdGhQYXJhbXMoZXZlbnQpIHtcbiAgXHRzaGFyZWRfZmlyZUV2ZW50KHRoaXMucm9vdCwgdGhpcy5nZXRBY3Rpb24oKSwgeyBldmVudDogZXZlbnQsIGFyZ3M6IHRoaXMucGFyYW1zIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUV2ZW50V2l0aER5bmFtaWNQYXJhbXMoZXZlbnQpIHtcbiAgXHR2YXIgYXJncyA9IHRoaXMuZHluYW1pY1BhcmFtcy5nZXRBcmdzTGlzdCgpO1xuXG4gIFx0Ly8gbmVlZCB0byBzdHJpcCBbXSBmcm9tIGVuZHMgaWYgYSBzdHJpbmchXG4gIFx0aWYgKHR5cGVvZiBhcmdzID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRhcmdzID0gYXJncy5zdWJzdHIoMSwgYXJncy5sZW5ndGggLSAyKTtcbiAgXHR9XG5cbiAgXHRzaGFyZWRfZmlyZUV2ZW50KHRoaXMucm9vdCwgdGhpcy5nZXRBY3Rpb24oKSwgeyBldmVudDogZXZlbnQsIGFyZ3M6IGFyZ3MgfSk7XG4gIH1cblxuICB2YXIgc2hhcmVkX2dlbmVyaWNIYW5kbGVyID0gZ2VuZXJpY0hhbmRsZXI7XG4gIGZ1bmN0aW9uIGdlbmVyaWNIYW5kbGVyKGV2ZW50KSB7XG4gIFx0dmFyIHN0b3JhZ2UsXG4gIFx0ICAgIGhhbmRsZXIsXG4gIFx0ICAgIGluZGljZXMsXG4gIFx0ICAgIGluZGV4ID0ge307XG5cbiAgXHRzdG9yYWdlID0gdGhpcy5fcmFjdGl2ZTtcbiAgXHRoYW5kbGVyID0gc3RvcmFnZS5ldmVudHNbZXZlbnQudHlwZV07XG5cbiAgXHRpZiAoaW5kaWNlcyA9IFJlc29sdmVyc19maW5kSW5kZXhSZWZzKGhhbmRsZXIuZWxlbWVudC5wYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdGluZGV4ID0gUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMucmVzb2x2ZShpbmRpY2VzKTtcbiAgXHR9XG5cbiAgXHRoYW5kbGVyLmZpcmUoe1xuICBcdFx0bm9kZTogdGhpcyxcbiAgXHRcdG9yaWdpbmFsOiBldmVudCxcbiAgXHRcdGluZGV4OiBpbmRleCxcbiAgXHRcdGtleXBhdGg6IHN0b3JhZ2Uua2V5cGF0aC5zdHIsXG4gIFx0XHRjb250ZXh0OiBzdG9yYWdlLnJvb3Qudmlld21vZGVsLmdldChzdG9yYWdlLmtleXBhdGgpXG4gIFx0fSk7XG4gIH1cblxuICB2YXIgbGlzdGVuID0gRXZlbnRIYW5kbGVyJGxpc3RlbjtcblxuICB2YXIgY3VzdG9tSGFuZGxlcnMgPSB7fSxcbiAgICAgIHRvdWNoRXZlbnRzID0ge1xuICBcdHRvdWNoc3RhcnQ6IHRydWUsXG4gIFx0dG91Y2htb3ZlOiB0cnVlLFxuICBcdHRvdWNoZW5kOiB0cnVlLFxuICBcdHRvdWNoY2FuY2VsOiB0cnVlLFxuICBcdC8vbm90IHczYywgYnV0IHN1cHBvcnRlZCBpbiBzb21lIGJyb3dzZXJzXG4gIFx0dG91Y2hsZWF2ZTogdHJ1ZVxuICB9O1xuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkbGlzdGVuKCkge1xuICBcdHZhciBkZWZpbml0aW9uLFxuICBcdCAgICBuYW1lID0gdGhpcy5uYW1lO1xuXG4gIFx0aWYgKHRoaXMuaW52YWxpZCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmIChkZWZpbml0aW9uID0gZmluZEluVmlld0hpZXJhcmNoeShcImV2ZW50c1wiLCB0aGlzLnJvb3QsIG5hbWUpKSB7XG4gIFx0XHR0aGlzLmN1c3RvbSA9IGRlZmluaXRpb24odGhpcy5ub2RlLCBnZXRDdXN0b21IYW5kbGVyKG5hbWUpKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gTG9va3MgbGlrZSB3ZSdyZSBkZWFsaW5nIHdpdGggYSBzdGFuZGFyZCBET00gZXZlbnQuLi4gYnV0IGxldCdzIGNoZWNrXG4gIFx0XHRpZiAoIShcIm9uXCIgKyBuYW1lIGluIHRoaXMubm9kZSkgJiYgISh3aW5kb3cgJiYgXCJvblwiICsgbmFtZSBpbiB3aW5kb3cpICYmICFpc0pzZG9tKSB7XG5cbiAgXHRcdFx0Ly8gb2theSB0byB1c2UgdG91Y2ggZXZlbnRzIGlmIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlbVxuICBcdFx0XHRpZiAoIXRvdWNoRXZlbnRzW25hbWVdKSB7XG4gIFx0XHRcdFx0d2Fybk9uY2VJZkRlYnVnKG1pc3NpbmdQbHVnaW4obmFtZSwgXCJldmVudFwiKSwgeyBub2RlOiB0aGlzLm5vZGUgfSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIHNoYXJlZF9nZW5lcmljSGFuZGxlciwgZmFsc2UpO1xuICBcdH1cblxuICBcdHRoaXMuaGFzTGlzdGVuZXIgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VzdG9tSGFuZGxlcihuYW1lKSB7XG4gIFx0aWYgKCFjdXN0b21IYW5kbGVyc1tuYW1lXSkge1xuICBcdFx0Y3VzdG9tSGFuZGxlcnNbbmFtZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgXHRcdFx0dmFyIHN0b3JhZ2UgPSBldmVudC5ub2RlLl9yYWN0aXZlO1xuXG4gIFx0XHRcdGV2ZW50LmluZGV4ID0gc3RvcmFnZS5pbmRleDtcbiAgXHRcdFx0ZXZlbnQua2V5cGF0aCA9IHN0b3JhZ2Uua2V5cGF0aC5zdHI7XG4gIFx0XHRcdGV2ZW50LmNvbnRleHQgPSBzdG9yYWdlLnJvb3Qudmlld21vZGVsLmdldChzdG9yYWdlLmtleXBhdGgpO1xuXG4gIFx0XHRcdHN0b3JhZ2UuZXZlbnRzW25hbWVdLmZpcmUoZXZlbnQpO1xuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gY3VzdG9tSGFuZGxlcnNbbmFtZV07XG4gIH1cblxuICB2YXIgRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9yZWJpbmQgPSBFdmVudEhhbmRsZXIkcmViaW5kO1xuXG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRyZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdHZhciBmcmFnbWVudDtcbiAgXHRpZiAodGhpcy5tZXRob2QpIHtcbiAgXHRcdGZyYWdtZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudEZyYWdtZW50O1xuICBcdFx0dGhpcy5yZWZSZXNvbHZlcnMuZm9yRWFjaChyZWJpbmQpO1xuXG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiB0aGlzLmFjdGlvbiAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0cmViaW5kKHRoaXMuYWN0aW9uKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5keW5hbWljUGFyYW1zKSB7XG4gIFx0XHRyZWJpbmQodGhpcy5keW5hbWljUGFyYW1zKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiByZWJpbmQodGhpbmcpIHtcbiAgXHRcdHRoaW5nICYmIHRoaW5nLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9yZW5kZXIgPSBFdmVudEhhbmRsZXIkcmVuZGVyO1xuXG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRyZW5kZXIoKSB7XG4gIFx0dGhpcy5ub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG4gIFx0Ly8gc3RvcmUgdGhpcyBvbiB0aGUgbm9kZSBpdHNlbGYsIHNvIGl0IGNhbiBiZSByZXRyaWV2ZWQgYnkgYVxuICBcdC8vIHVuaXZlcnNhbCBoYW5kbGVyXG4gIFx0dGhpcy5ub2RlLl9yYWN0aXZlLmV2ZW50c1t0aGlzLm5hbWVdID0gdGhpcztcblxuICBcdGlmICh0aGlzLm1ldGhvZCB8fCB0aGlzLmdldEFjdGlvbigpKSB7XG4gIFx0XHR0aGlzLmxpc3RlbigpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfcmVzb2x2ZSA9IEV2ZW50SGFuZGxlciRyZXNvbHZlO1xuXG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRyZXNvbHZlKGluZGV4LCBrZXlwYXRoKSB7XG4gIFx0dGhpcy5rZXlwYXRoc1tpbmRleF0gPSBrZXlwYXRoO1xuICB9XG5cbiAgdmFyIEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfdW5iaW5kID0gRXZlbnRIYW5kbGVyJHVuYmluZDtcbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHVuYmluZCgpIHtcbiAgXHRpZiAodGhpcy5tZXRob2QpIHtcbiAgXHRcdHRoaXMucmVmUmVzb2x2ZXJzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBUZWFyIGRvd24gZHluYW1pYyBuYW1lXG4gIFx0aWYgKHR5cGVvZiB0aGlzLmFjdGlvbiAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0dGhpcy5hY3Rpb24udW5iaW5kKCk7XG4gIFx0fVxuXG4gIFx0Ly8gVGVhciBkb3duIGR5bmFtaWMgcGFyYW1ldGVyc1xuICBcdGlmICh0aGlzLmR5bmFtaWNQYXJhbXMpIHtcbiAgXHRcdHRoaXMuZHluYW1pY1BhcmFtcy51bmJpbmQoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV91bnJlbmRlciA9IEV2ZW50SGFuZGxlciR1bnJlbmRlcjtcbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHVucmVuZGVyKCkge1xuXG4gIFx0aWYgKHRoaXMuY3VzdG9tKSB7XG4gIFx0XHR0aGlzLmN1c3RvbS50ZWFyZG93bigpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLm5hbWUsIHNoYXJlZF9nZW5lcmljSGFuZGxlciwgZmFsc2UpO1xuICBcdH1cblxuICBcdHRoaXMuaGFzTGlzdGVuZXIgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSwgdGVtcGxhdGUpIHtcbiAgXHR0aGlzLmluaXQoZWxlbWVudCwgbmFtZSwgdGVtcGxhdGUpO1xuICB9O1xuXG4gIEV2ZW50SGFuZGxlci5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2J1YmJsZSxcbiAgXHRmaXJlOiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2ZpcmUsXG4gIFx0Z2V0QWN0aW9uOiBnZXRBY3Rpb24sXG4gIFx0aW5pdDogRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9pbml0LFxuICBcdGxpc3RlbjogbGlzdGVuLFxuICBcdHJlYmluZDogRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9yZWJpbmQsXG4gIFx0cmVuZGVyOiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3JlbmRlcixcbiAgXHRyZXNvbHZlOiBwcm90b3R5cGVfcmVzb2x2ZSxcbiAgXHR1bmJpbmQ6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfdW5iaW5kLFxuICBcdHVucmVuZGVyOiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3VucmVuZGVyXG4gIH07XG5cbiAgdmFyIF9FdmVudEhhbmRsZXIgPSBFdmVudEhhbmRsZXI7XG5cbiAgdmFyIGNyZWF0ZUV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiAoZWxlbWVudCwgdGVtcGxhdGUpIHtcbiAgXHR2YXIgaSxcbiAgXHQgICAgbmFtZSxcbiAgXHQgICAgbmFtZXMsXG4gIFx0ICAgIGhhbmRsZXIsXG4gIFx0ICAgIHJlc3VsdCA9IFtdO1xuXG4gIFx0Zm9yIChuYW1lIGluIHRlbXBsYXRlKSB7XG4gIFx0XHRpZiAodGVtcGxhdGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgXHRcdFx0bmFtZXMgPSBuYW1lLnNwbGl0KFwiLVwiKTtcbiAgXHRcdFx0aSA9IG5hbWVzLmxlbmd0aDtcblxuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0aGFuZGxlciA9IG5ldyBfRXZlbnRIYW5kbGVyKGVsZW1lbnQsIG5hbWVzW2ldLCB0ZW1wbGF0ZVtuYW1lXSk7XG4gIFx0XHRcdFx0cmVzdWx0LnB1c2goaGFuZGxlcik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBEZWNvcmF0b3IgPSBmdW5jdGlvbiAoZWxlbWVudCwgdGVtcGxhdGUpIHtcbiAgXHR2YXIgc2VsZiA9IHRoaXMsXG4gIFx0ICAgIHJhY3RpdmUsXG4gIFx0ICAgIG5hbWUsXG4gIFx0ICAgIGZyYWdtZW50O1xuXG4gIFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlID0gZWxlbWVudC5yb290O1xuXG4gIFx0bmFtZSA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG5cbiAgXHRpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogbmFtZSxcbiAgXHRcdFx0cm9vdDogcmFjdGl2ZSxcbiAgXHRcdFx0b3duZXI6IGVsZW1lbnRcbiAgXHRcdH0pO1xuXG4gIFx0XHRuYW1lID0gZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgXHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXG4gIFx0XHRpZiAobmFtZSA9PT0gXCJcIikge1xuICBcdFx0XHQvLyBlbXB0eSBzdHJpbmcgb2theSwganVzdCBubyBkZWNvcmF0b3JcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICh0ZW1wbGF0ZS5hKSB7XG4gIFx0XHR0aGlzLnBhcmFtcyA9IHRlbXBsYXRlLmE7XG4gIFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS5kKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZCxcbiAgXHRcdFx0cm9vdDogcmFjdGl2ZSxcbiAgXHRcdFx0b3duZXI6IGVsZW1lbnRcbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLnBhcmFtcyA9IHRoaXMuZnJhZ21lbnQuZ2V0QXJnc0xpc3QoKTtcblxuICBcdFx0dGhpcy5mcmFnbWVudC5idWJibGUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHRoaXMuZGlydHlBcmdzID0gdGhpcy5kaXJ0eVZhbHVlID0gdHJ1ZTtcbiAgXHRcdFx0c2VsZi5wYXJhbXMgPSB0aGlzLmdldEFyZ3NMaXN0KCk7XG5cbiAgXHRcdFx0aWYgKHNlbGYucmVhZHkpIHtcbiAgXHRcdFx0XHRzZWxmLnVwZGF0ZSgpO1xuICBcdFx0XHR9XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHRoaXMuZm4gPSBmaW5kSW5WaWV3SGllcmFyY2h5KFwiZGVjb3JhdG9yc1wiLCByYWN0aXZlLCBuYW1lKTtcblxuICBcdGlmICghdGhpcy5mbikge1xuICBcdFx0ZmF0YWwobWlzc2luZ1BsdWdpbihuYW1lLCBcImRlY29yYXRvclwiKSk7XG4gIFx0fVxuICB9O1xuXG4gIERlY29yYXRvci5wcm90b3R5cGUgPSB7XG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUsIHJlc3VsdCwgYXJncztcblxuICBcdFx0bm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRpZiAodGhpcy5wYXJhbXMpIHtcbiAgXHRcdFx0YXJncyA9IFtub2RlXS5jb25jYXQodGhpcy5wYXJhbXMpO1xuICBcdFx0XHRyZXN1bHQgPSB0aGlzLmZuLmFwcGx5KHRoaXMucm9vdCwgYXJncyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXN1bHQgPSB0aGlzLmZuLmNhbGwodGhpcy5yb290LCBub2RlKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFyZXN1bHQgfHwgIXJlc3VsdC50ZWFyZG93bikge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJEZWNvcmF0b3IgZGVmaW5pdGlvbiBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2l0aCBhIHRlYXJkb3duIG1ldGhvZFwiKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gVE9ETyBkb2VzIHRoaXMgbWFrZSBzZW5zZT9cbiAgXHRcdHRoaXMuYWN0dWFsID0gcmVzdWx0O1xuICBcdFx0dGhpcy5yZWFkeSA9IHRydWU7XG4gIFx0fSxcblxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuYWN0dWFsLnVwZGF0ZSkge1xuICBcdFx0XHR0aGlzLmFjdHVhbC51cGRhdGUuYXBwbHkodGhpcy5yb290LCB0aGlzLnBhcmFtcyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLmFjdHVhbC50ZWFyZG93bih0cnVlKTtcbiAgXHRcdFx0dGhpcy5pbml0KCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR0ZWFyZG93bjogZnVuY3Rpb24gKHVwZGF0aW5nKSB7XG4gIFx0XHR0aGlzLnRvcm5kb3duID0gdHJ1ZTtcbiAgXHRcdGlmICh0aGlzLnJlYWR5KSB7XG4gIFx0XHRcdHRoaXMuYWN0dWFsLnRlYXJkb3duKCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdXBkYXRpbmcgJiYgdGhpcy5mcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgX0RlY29yYXRvciA9IERlY29yYXRvcjtcblxuICBmdW5jdGlvbiBzZWxlY3RfX2J1YmJsZSgpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0aWYgKCF0aGlzLmRpcnR5KSB7XG4gIFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0c3luYyhfdGhpcyk7XG4gIFx0XHRcdF90aGlzLmRpcnR5ID0gZmFsc2U7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpOyAvLyBkZWZhdWx0IGJlaGF2aW91clxuICB9XG5cbiAgZnVuY3Rpb24gc3luYyhzZWxlY3RFbGVtZW50KSB7XG4gIFx0dmFyIHNlbGVjdE5vZGUsIHNlbGVjdFZhbHVlLCBpc011bHRpcGxlLCBvcHRpb25zLCBvcHRpb25XYXNTZWxlY3RlZDtcblxuICBcdHNlbGVjdE5vZGUgPSBzZWxlY3RFbGVtZW50Lm5vZGU7XG5cbiAgXHRpZiAoIXNlbGVjdE5vZGUpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRvcHRpb25zID0gdG9BcnJheShzZWxlY3ROb2RlLm9wdGlvbnMpO1xuXG4gIFx0c2VsZWN0VmFsdWUgPSBzZWxlY3RFbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdGlzTXVsdGlwbGUgPSBzZWxlY3RFbGVtZW50LmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpO1xuXG4gIFx0Ly8gSWYgdGhlIDxzZWxlY3Q+IGhhcyBhIHNwZWNpZmllZCB2YWx1ZSwgdGhhdCBzaG91bGQgb3ZlcnJpZGVcbiAgXHQvLyB0aGVzZSBvcHRpb25zXG4gIFx0aWYgKHNlbGVjdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdG9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobykge1xuICBcdFx0XHR2YXIgb3B0aW9uVmFsdWUsIHNob3VsZFNlbGVjdDtcblxuICBcdFx0XHRvcHRpb25WYWx1ZSA9IG8uX3JhY3RpdmUgPyBvLl9yYWN0aXZlLnZhbHVlIDogby52YWx1ZTtcbiAgXHRcdFx0c2hvdWxkU2VsZWN0ID0gaXNNdWx0aXBsZSA/IHZhbHVlQ29udGFpbnMoc2VsZWN0VmFsdWUsIG9wdGlvblZhbHVlKSA6IHNlbGVjdFZhbHVlID09IG9wdGlvblZhbHVlO1xuXG4gIFx0XHRcdGlmIChzaG91bGRTZWxlY3QpIHtcbiAgXHRcdFx0XHRvcHRpb25XYXNTZWxlY3RlZCA9IHRydWU7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRvLnNlbGVjdGVkID0gc2hvdWxkU2VsZWN0O1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmICghb3B0aW9uV2FzU2VsZWN0ZWQpIHtcbiAgXHRcdFx0aWYgKG9wdGlvbnNbMF0pIHtcbiAgXHRcdFx0XHRvcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChzZWxlY3RFbGVtZW50LmJpbmRpbmcpIHtcbiAgXHRcdFx0XHRzZWxlY3RFbGVtZW50LmJpbmRpbmcuZm9yY2VVcGRhdGUoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIE90aGVyd2lzZSB0aGUgdmFsdWUgc2hvdWxkIGJlIGluaXRpYWxpc2VkIGFjY29yZGluZyB0byB3aGljaFxuICBcdC8vIDxvcHRpb24+IGVsZW1lbnQgaXMgc2VsZWN0ZWQsIGlmIHR3b3dheSBiaW5kaW5nIGlzIGluIGVmZmVjdFxuICBcdGVsc2UgaWYgKHNlbGVjdEVsZW1lbnQuYmluZGluZykge1xuICBcdFx0c2VsZWN0RWxlbWVudC5iaW5kaW5nLmZvcmNlVXBkYXRlKCk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsdWVDb250YWlucyhzZWxlY3RWYWx1ZSwgb3B0aW9uVmFsdWUpIHtcbiAgXHR2YXIgaSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoc2VsZWN0VmFsdWVbaV0gPT0gb3B0aW9uVmFsdWUpIHtcbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gc3BlY2lhbF9vcHRpb25fX2luaXQob3B0aW9uLCB0ZW1wbGF0ZSkge1xuICBcdG9wdGlvbi5zZWxlY3QgPSBmaW5kUGFyZW50U2VsZWN0KG9wdGlvbi5wYXJlbnQpO1xuXG4gIFx0Ly8gd2UgbWlnaHQgYmUgaW5zaWRlIGEgPGRhdGFsaXN0PiBlbGVtZW50XG4gIFx0aWYgKCFvcHRpb24uc2VsZWN0KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0b3B0aW9uLnNlbGVjdC5vcHRpb25zLnB1c2gob3B0aW9uKTtcblxuICBcdC8vIElmIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgaXMgbWlzc2luZywgdXNlIHRoZSBlbGVtZW50J3MgY29udGVudFxuICBcdGlmICghdGVtcGxhdGUuYSkge1xuICBcdFx0dGVtcGxhdGUuYSA9IHt9O1xuICBcdH1cblxuICBcdC8vIC4uLmFzIGxvbmcgYXMgaXQgaXNuJ3QgZGlzYWJsZWRcbiAgXHRpZiAodGVtcGxhdGUuYS52YWx1ZSA9PT0gdW5kZWZpbmVkICYmICF0ZW1wbGF0ZS5hLmhhc093blByb3BlcnR5KFwiZGlzYWJsZWRcIikpIHtcbiAgXHRcdHRlbXBsYXRlLmEudmFsdWUgPSB0ZW1wbGF0ZS5mO1xuICBcdH1cblxuICBcdC8vIElmIHRoZXJlIGlzIGEgYHNlbGVjdGVkYCBhdHRyaWJ1dGUsIGJ1dCB0aGUgPHNlbGVjdD5cbiAgXHQvLyBhbHJlYWR5IGhhcyBhIHZhbHVlLCBkZWxldGUgaXRcbiAgXHRpZiAoXCJzZWxlY3RlZFwiIGluIHRlbXBsYXRlLmEgJiYgb3B0aW9uLnNlbGVjdC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRkZWxldGUgdGVtcGxhdGUuYS5zZWxlY3RlZDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBzcGVjaWFsX29wdGlvbl9fdW5iaW5kKG9wdGlvbikge1xuICBcdGlmIChvcHRpb24uc2VsZWN0KSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkob3B0aW9uLnNlbGVjdC5vcHRpb25zLCBvcHRpb24pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRQYXJlbnRTZWxlY3QoZWxlbWVudCkge1xuICBcdGlmICghZWxlbWVudCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGRvIHtcbiAgXHRcdGlmIChlbGVtZW50Lm5hbWUgPT09IFwic2VsZWN0XCIpIHtcbiAgXHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50KTtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9pbml0ID0gRWxlbWVudCRpbml0O1xuICBmdW5jdGlvbiBFbGVtZW50JGluaXQob3B0aW9ucykge1xuICBcdHZhciBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGUsIHJhY3RpdmUsIGJpbmRpbmcsIGJpbmRpbmdzLCB0d293YXksIGJpbmRpbmdBdHRycztcblxuICBcdHRoaXMudHlwZSA9IEVMRU1FTlQ7XG5cbiAgXHQvLyBzdHVmZiB3ZSdsbCBuZWVkIGxhdGVyXG4gIFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcbiAgXHR0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXG4gIFx0dGhpcy5wYXJlbnQgPSBvcHRpb25zLnBFbGVtZW50IHx8IHBhcmVudEZyYWdtZW50LnBFbGVtZW50O1xuXG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZSA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG4gIFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG4gIFx0dGhpcy5rZXkgPSBvcHRpb25zLmtleTtcblxuICBcdHRoaXMubmFtZSA9IGVuZm9yY2VDYXNlKHRlbXBsYXRlLmUpO1xuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gPG9wdGlvbj4gZWxlbWVudHNcbiAgXHRpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiKSB7XG4gIFx0XHRzcGVjaWFsX29wdGlvbl9faW5pdCh0aGlzLCB0ZW1wbGF0ZSk7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gPHNlbGVjdD4gZWxlbWVudHNcbiAgXHRpZiAodGhpcy5uYW1lID09PSBcInNlbGVjdFwiKSB7XG4gIFx0XHR0aGlzLm9wdGlvbnMgPSBbXTtcbiAgXHRcdHRoaXMuYnViYmxlID0gc2VsZWN0X19idWJibGU7IC8vIFRPRE8gdGhpcyBpcyBhIGtsdWRnZVxuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIDxmb3JtPiBlbGVtZW50c1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwiZm9ybVwiKSB7XG4gIFx0XHR0aGlzLmZvcm1CaW5kaW5ncyA9IFtdO1xuICBcdH1cblxuICBcdC8vIGhhbmRsZSBiaW5kaW5nIGF0dHJpYnV0ZXMgZmlyc3QgKHR3b3dheSwgbGF6eSlcbiAgXHRiaW5kaW5nQXR0cnMgPSBwcm9jZXNzQmluZGluZ0F0dHJpYnV0ZXModGhpcywgdGVtcGxhdGUpO1xuXG4gIFx0Ly8gY3JlYXRlIGF0dHJpYnV0ZXNcbiAgXHR0aGlzLmF0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVzKHRoaXMsIHRlbXBsYXRlLmEpO1xuICBcdHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzID0gY3JlYXRlQ29uZGl0aW9uYWxBdHRyaWJ1dGVzKHRoaXMsIHRlbXBsYXRlLm0pO1xuXG4gIFx0Ly8gYXBwZW5kIGNoaWxkcmVuLCBpZiB0aGVyZSBhcmUgYW55XG4gIFx0aWYgKHRlbXBsYXRlLmYpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5mLFxuICBcdFx0XHRyb290OiByYWN0aXZlLFxuICBcdFx0XHRvd25lcjogdGhpcyxcbiAgXHRcdFx0cEVsZW1lbnQ6IHRoaXMsXG4gIFx0XHRcdGNzc0lkczogbnVsbFxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Ly8gdGhlIGVsZW1lbnQgc2V0dGluZyBzaG91bGQgb3ZlcnJpZGUgdGhlIHJhY3RpdmUgc2V0dGluZ1xuICBcdHR3b3dheSA9IHJhY3RpdmUudHdvd2F5O1xuICBcdGlmIChiaW5kaW5nQXR0cnMudHdvd2F5ID09PSBmYWxzZSkgdHdvd2F5ID0gZmFsc2U7ZWxzZSBpZiAoYmluZGluZ0F0dHJzLnR3b3dheSA9PT0gdHJ1ZSkgdHdvd2F5ID0gdHJ1ZTtcblxuICBcdHRoaXMudHdvd2F5ID0gdHdvd2F5O1xuICBcdHRoaXMubGF6eSA9IGJpbmRpbmdBdHRycy5sYXp5O1xuXG4gIFx0Ly8gY3JlYXRlIHR3b3dheSBiaW5kaW5nXG4gIFx0aWYgKHR3b3dheSAmJiAoYmluZGluZyA9IGluaXRfY3JlYXRlVHdvd2F5QmluZGluZyh0aGlzLCB0ZW1wbGF0ZS5hKSkpIHtcbiAgXHRcdHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XG5cbiAgXHRcdC8vIHJlZ2lzdGVyIHRoaXMgd2l0aCB0aGUgcm9vdCwgc28gdGhhdCB3ZSBjYW4gZG8gcmFjdGl2ZS51cGRhdGVNb2RlbCgpXG4gIFx0XHRiaW5kaW5ncyA9IHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbYmluZGluZy5rZXlwYXRoLnN0cl0gfHwgKHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbYmluZGluZy5rZXlwYXRoLnN0cl0gPSBbXSk7XG4gIFx0XHRiaW5kaW5ncy5wdXNoKGJpbmRpbmcpO1xuICBcdH1cblxuICBcdC8vIGNyZWF0ZSBldmVudCBwcm94aWVzXG4gIFx0aWYgKHRlbXBsYXRlLnYpIHtcbiAgXHRcdHRoaXMuZXZlbnRIYW5kbGVycyA9IGNyZWF0ZUV2ZW50SGFuZGxlcnModGhpcywgdGVtcGxhdGUudik7XG4gIFx0fVxuXG4gIFx0Ly8gY3JlYXRlIGRlY29yYXRvclxuICBcdGlmICh0ZW1wbGF0ZS5vKSB7XG4gIFx0XHR0aGlzLmRlY29yYXRvciA9IG5ldyBfRGVjb3JhdG9yKHRoaXMsIHRlbXBsYXRlLm8pO1xuICBcdH1cblxuICBcdC8vIGNyZWF0ZSB0cmFuc2l0aW9uc1xuICBcdHRoaXMuaW50cm8gPSB0ZW1wbGF0ZS50MCB8fCB0ZW1wbGF0ZS50MTtcbiAgXHR0aGlzLm91dHJvID0gdGVtcGxhdGUudDAgfHwgdGVtcGxhdGUudDI7XG4gIH1cblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfcmViaW5kID0gRWxlbWVudCRyZWJpbmQ7XG4gIGZ1bmN0aW9uIEVsZW1lbnQkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHR2YXIgaSwgc3RvcmFnZSwgbGl2ZVF1ZXJpZXMsIHJhY3RpdmU7XG5cbiAgXHRpZiAodGhpcy5hdHRyaWJ1dGVzKSB7XG4gIFx0XHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaChyZWJpbmQpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcykge1xuICBcdFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMuZm9yRWFjaChyZWJpbmQpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmV2ZW50SGFuZGxlcnMpIHtcbiAgXHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKHJlYmluZCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZGVjb3JhdG9yKSB7XG4gIFx0XHRyZWJpbmQodGhpcy5kZWNvcmF0b3IpO1xuICBcdH1cblxuICBcdC8vIHJlYmluZCBjaGlsZHJlblxuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRyZWJpbmQodGhpcy5mcmFnbWVudCk7XG4gIFx0fVxuXG4gIFx0Ly8gVXBkYXRlIGxpdmUgcXVlcmllcywgaWYgbmVjZXNzYXJ5XG4gIFx0aWYgKGxpdmVRdWVyaWVzID0gdGhpcy5saXZlUXVlcmllcykge1xuICBcdFx0cmFjdGl2ZSA9IHRoaXMucm9vdDtcblxuICBcdFx0aSA9IGxpdmVRdWVyaWVzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0bGl2ZVF1ZXJpZXNbaV0uX21ha2VEaXJ0eSgpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICh0aGlzLm5vZGUgJiYgKHN0b3JhZ2UgPSB0aGlzLm5vZGUuX3JhY3RpdmUpKSB7XG5cbiAgXHRcdC8vIGFkanVzdCBrZXlwYXRoIGlmIG5lZWRlZFxuICBcdFx0YXNzaWduTmV3S2V5cGF0aChzdG9yYWdlLCBcImtleXBhdGhcIiwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gcmViaW5kKHRoaW5nKSB7XG4gIFx0XHR0aGluZy5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gc3BlY2lhbF9pbWdfX3JlbmRlcihpbWcpIHtcbiAgXHR2YXIgbG9hZEhhbmRsZXI7XG5cbiAgXHQvLyBpZiB0aGlzIGlzIGFuIDxpbWc+LCBhbmQgd2UncmUgaW4gYSBjcmFwIGJyb3dzZXIsIHdlIG1heSBuZWVkIHRvIHByZXZlbnQgaXRcbiAgXHQvLyBmcm9tIG92ZXJyaWRpbmcgd2lkdGggYW5kIGhlaWdodCB3aGVuIGl0IGxvYWRzIHRoZSBzcmNcbiAgXHRpZiAoaW1nLmF0dHJpYnV0ZXMud2lkdGggfHwgaW1nLmF0dHJpYnV0ZXMuaGVpZ2h0KSB7XG4gIFx0XHRpbWcubm9kZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsb2FkSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dmFyIHdpZHRoID0gaW1nLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpLFxuICBcdFx0XHQgICAgaGVpZ2h0ID0gaW1nLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKTtcblxuICBcdFx0XHRpZiAod2lkdGggIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdGltZy5ub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChoZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdGltZy5ub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aW1nLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgbG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgXHRcdH0sIGZhbHNlKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtX19yZW5kZXIoZWxlbWVudCkge1xuICBcdGVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRcIiwgaGFuZGxlUmVzZXQsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1fX3VucmVuZGVyKGVsZW1lbnQpIHtcbiAgXHRlbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2V0XCIsIGhhbmRsZVJlc2V0LCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVSZXNldCgpIHtcbiAgXHR2YXIgZWxlbWVudCA9IHRoaXMuX3JhY3RpdmUucHJveHk7XG5cbiAgXHRnbG9iYWxfcnVubG9vcC5zdGFydCgpO1xuICBcdGVsZW1lbnQuZm9ybUJpbmRpbmdzLmZvckVhY2godXBkYXRlTW9kZWwpO1xuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTW9kZWwoYmluZGluZykge1xuICBcdGJpbmRpbmcucm9vdC52aWV3bW9kZWwuc2V0KGJpbmRpbmcua2V5cGF0aCwgYmluZGluZy5yZXNldFZhbHVlKTtcbiAgfVxuXG4gIHZhciBUcmFuc2l0aW9uX3Byb3RvdHlwZV9pbml0ID0gVHJhbnNpdGlvbiRpbml0O1xuICBmdW5jdGlvbiBUcmFuc2l0aW9uJGluaXQoZWxlbWVudCwgdGVtcGxhdGUsIGlzSW50cm8pIHtcbiAgXHR2YXIgcmFjdGl2ZSwgbmFtZSwgZnJhZ21lbnQ7XG5cbiAgXHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmUgPSBlbGVtZW50LnJvb3Q7XG4gIFx0dGhpcy5pc0ludHJvID0gaXNJbnRybztcblxuICBcdG5hbWUgPSB0ZW1wbGF0ZS5uIHx8IHRlbXBsYXRlO1xuXG4gIFx0aWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IG5hbWUsXG4gIFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiBlbGVtZW50XG4gIFx0XHR9KTtcblxuICBcdFx0bmFtZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblxuICBcdFx0aWYgKG5hbWUgPT09IFwiXCIpIHtcbiAgXHRcdFx0Ly8gZW1wdHkgc3RyaW5nIG9rYXksIGp1c3Qgbm8gdHJhbnNpdGlvblxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0dGhpcy5uYW1lID0gbmFtZTtcblxuICBcdGlmICh0ZW1wbGF0ZS5hKSB7XG4gIFx0XHR0aGlzLnBhcmFtcyA9IHRlbXBsYXRlLmE7XG4gIFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS5kKSB7XG4gIFx0XHQvLyBUT0RPIGlzIHRoZXJlIGEgd2F5IHRvIGludGVycHJldCBkeW5hbWljIGFyZ3VtZW50cyB3aXRob3V0IGFsbCB0aGVcbiAgXHRcdC8vICdkZXBlbmRlbmN5IHRocmFzaGluZyc/XG4gIFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmQsXG4gIFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiBlbGVtZW50XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5wYXJhbXMgPSBmcmFnbWVudC5nZXRBcmdzTGlzdCgpO1xuICBcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fVxuXG4gIFx0dGhpcy5fZm4gPSBmaW5kSW5WaWV3SGllcmFyY2h5KFwidHJhbnNpdGlvbnNcIiwgcmFjdGl2ZSwgbmFtZSk7XG5cbiAgXHRpZiAoIXRoaXMuX2ZuKSB7XG4gIFx0XHR3YXJuT25jZUlmRGVidWcobWlzc2luZ1BsdWdpbihuYW1lLCBcInRyYW5zaXRpb25cIiksIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdH1cbiAgfVxuXG4gIHZhciBjYW1lbENhc2UgPSBmdW5jdGlvbiAoaHlwaGVuYXRlZFN0cikge1xuICBcdHJldHVybiBoeXBoZW5hdGVkU3RyLnJlcGxhY2UoLy0oW2EtekEtWl0pL2csIGZ1bmN0aW9uIChtYXRjaCwgJDEpIHtcbiAgXHRcdHJldHVybiAkMS50b1VwcGVyQ2FzZSgpO1xuICBcdH0pO1xuICB9O1xuXG4gIHZhciBoZWxwZXJzX3ByZWZpeF9fcHJlZml4LCBwcmVmaXhDYWNoZSwgaGVscGVyc19wcmVmaXhfX3Rlc3RTdHlsZTtcblxuICBpZiAoIWlzQ2xpZW50KSB7XG4gIFx0aGVscGVyc19wcmVmaXhfX3ByZWZpeCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gIFx0cHJlZml4Q2FjaGUgPSB7fTtcbiAgXHRoZWxwZXJzX3ByZWZpeF9fdGVzdFN0eWxlID0gY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZTtcblxuICBcdGhlbHBlcnNfcHJlZml4X19wcmVmaXggPSBmdW5jdGlvbiAocHJvcCkge1xuICBcdFx0dmFyIGksIHZlbmRvciwgY2FwcGVkO1xuXG4gIFx0XHRwcm9wID0gY2FtZWxDYXNlKHByb3ApO1xuXG4gIFx0XHRpZiAoIXByZWZpeENhY2hlW3Byb3BdKSB7XG4gIFx0XHRcdGlmIChoZWxwZXJzX3ByZWZpeF9fdGVzdFN0eWxlW3Byb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRwcmVmaXhDYWNoZVtwcm9wXSA9IHByb3A7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0Ly8gdGVzdCB2ZW5kb3JzLi4uXG4gIFx0XHRcdFx0Y2FwcGVkID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc3Vic3RyaW5nKDEpO1xuXG4gIFx0XHRcdFx0aSA9IHZlbmRvcnMubGVuZ3RoO1xuICBcdFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRcdHZlbmRvciA9IHZlbmRvcnNbaV07XG4gIFx0XHRcdFx0XHRpZiAoaGVscGVyc19wcmVmaXhfX3Rlc3RTdHlsZVt2ZW5kb3IgKyBjYXBwZWRdICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRcdFx0cHJlZml4Q2FjaGVbcHJvcF0gPSB2ZW5kb3IgKyBjYXBwZWQ7XG4gIFx0XHRcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gcHJlZml4Q2FjaGVbcHJvcF07XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBoZWxwZXJzX3ByZWZpeCA9IGhlbHBlcnNfcHJlZml4X19wcmVmaXg7XG5cbiAgdmFyIGdldFN0eWxlLCBwcm90b3R5cGVfZ2V0U3R5bGVfX2dldENvbXB1dGVkU3R5bGU7XG5cbiAgaWYgKCFpc0NsaWVudCkge1xuICBcdGdldFN0eWxlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHRwcm90b3R5cGVfZ2V0U3R5bGVfX2dldENvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSB8fCBsZWdhY3kuZ2V0Q29tcHV0ZWRTdHlsZTtcblxuICBcdGdldFN0eWxlID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gIFx0XHR2YXIgY29tcHV0ZWRTdHlsZSwgc3R5bGVzLCBpLCBwcm9wLCB2YWx1ZTtcblxuICBcdFx0Y29tcHV0ZWRTdHlsZSA9IHByb3RvdHlwZV9nZXRTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLm5vZGUpO1xuXG4gIFx0XHRpZiAodHlwZW9mIHByb3BzID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdHZhbHVlID0gY29tcHV0ZWRTdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wcyldO1xuICBcdFx0XHRpZiAodmFsdWUgPT09IFwiMHB4XCIpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IDA7XG4gIFx0XHRcdH1cbiAgXHRcdFx0cmV0dXJuIHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWlzQXJyYXkocHJvcHMpKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRyYW5zaXRpb24kZ2V0U3R5bGUgbXVzdCBiZSBwYXNzZWQgYSBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIENTUyBwcm9wZXJ0aWVzXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRzdHlsZXMgPSB7fTtcblxuICBcdFx0aSA9IHByb3BzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0cHJvcCA9IHByb3BzW2ldO1xuICBcdFx0XHR2YWx1ZSA9IGNvbXB1dGVkU3R5bGVbaGVscGVyc19wcmVmaXgocHJvcCldO1xuICBcdFx0XHRpZiAodmFsdWUgPT09IFwiMHB4XCIpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IDA7XG4gIFx0XHRcdH1cbiAgXHRcdFx0c3R5bGVzW3Byb3BdID0gdmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBzdHlsZXM7XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZ2V0U3R5bGUgPSBnZXRTdHlsZTtcblxuICB2YXIgc2V0U3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUsIHZhbHVlKSB7XG4gIFx0dmFyIHByb3A7XG5cbiAgXHRpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHR0aGlzLm5vZGUuc3R5bGVbaGVscGVyc19wcmVmaXgoc3R5bGUpXSA9IHZhbHVlO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRmb3IgKHByb3AgaW4gc3R5bGUpIHtcbiAgXHRcdFx0aWYgKHN0eWxlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gIFx0XHRcdFx0dGhpcy5ub2RlLnN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXSA9IHN0eWxlW3Byb3BdO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIFRpY2tlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dmFyIGVhc2luZztcblxuICBcdHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuICBcdHRoaXMuc3RlcCA9IG9wdGlvbnMuc3RlcDtcbiAgXHR0aGlzLmNvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcblxuICBcdC8vIGVhc2luZ1xuICBcdGlmICh0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGVhc2luZyA9IG9wdGlvbnMucm9vdC5lYXNpbmdbb3B0aW9ucy5lYXNpbmddO1xuXG4gIFx0XHRpZiAoIWVhc2luZykge1xuICBcdFx0XHR3YXJuT25jZUlmRGVidWcobWlzc2luZ1BsdWdpbihvcHRpb25zLmVhc2luZywgXCJlYXNpbmdcIikpO1xuICBcdFx0XHRlYXNpbmcgPSBsaW5lYXI7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGVhc2luZyA9IGxpbmVhcjtcbiAgXHR9XG5cbiAgXHR0aGlzLmVhc2luZyA9IGVhc2luZztcblxuICBcdHRoaXMuc3RhcnQgPSB1dGlsc19nZXRUaW1lKCk7XG4gIFx0dGhpcy5lbmQgPSB0aGlzLnN0YXJ0ICsgdGhpcy5kdXJhdGlvbjtcblxuICBcdHRoaXMucnVubmluZyA9IHRydWU7XG4gIFx0c2hhcmVkX2FuaW1hdGlvbnMuYWRkKHRoaXMpO1xuICB9O1xuXG4gIFRpY2tlci5wcm90b3R5cGUgPSB7XG4gIFx0dGljazogZnVuY3Rpb24gKG5vdykge1xuICBcdFx0dmFyIGVsYXBzZWQsIGVhc2VkO1xuXG4gIFx0XHRpZiAoIXRoaXMucnVubmluZykge1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChub3cgPiB0aGlzLmVuZCkge1xuICBcdFx0XHRpZiAodGhpcy5zdGVwKSB7XG4gIFx0XHRcdFx0dGhpcy5zdGVwKDEpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHRoaXMuY29tcGxldGUpIHtcbiAgXHRcdFx0XHR0aGlzLmNvbXBsZXRlKDEpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHRlbGFwc2VkID0gbm93IC0gdGhpcy5zdGFydDtcbiAgXHRcdGVhc2VkID0gdGhpcy5lYXNpbmcoZWxhcHNlZCAvIHRoaXMuZHVyYXRpb24pO1xuXG4gIFx0XHRpZiAodGhpcy5zdGVwKSB7XG4gIFx0XHRcdHRoaXMuc3RlcChlYXNlZCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH0sXG5cbiAgXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5hYm9ydCkge1xuICBcdFx0XHR0aGlzLmFib3J0KCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuICBcdH1cbiAgfTtcblxuICB2YXIgc2hhcmVkX1RpY2tlciA9IFRpY2tlcjtcbiAgZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgXHRyZXR1cm4gdDtcbiAgfVxuXG4gIHZhciB1bnByZWZpeFBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXi0oPzpcIiArIHZlbmRvcnMuam9pbihcInxcIikgKyBcIiktXCIpO1xuXG4gIHZhciB1bnByZWZpeCA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gIFx0cmV0dXJuIHByb3AucmVwbGFjZSh1bnByZWZpeFBhdHRlcm4sIFwiXCIpO1xuICB9O1xuXG4gIHZhciB2ZW5kb3JQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHZlbmRvcnMuam9pbihcInxcIikgKyBcIikoW0EtWl0pXCIpO1xuXG4gIHZhciBoeXBoZW5hdGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIFx0dmFyIGh5cGhlbmF0ZWQ7XG5cbiAgXHRpZiAoIXN0cikge1xuICBcdFx0cmV0dXJuIFwiXCI7IC8vIGVkZ2UgY2FzZVxuICBcdH1cblxuICBcdGlmICh2ZW5kb3JQYXR0ZXJuLnRlc3Qoc3RyKSkge1xuICBcdFx0c3RyID0gXCItXCIgKyBzdHI7XG4gIFx0fVxuXG4gIFx0aHlwaGVuYXRlZCA9IHN0ci5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgXHRcdHJldHVybiBcIi1cIiArIG1hdGNoLnRvTG93ZXJDYXNlKCk7XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gaHlwaGVuYXRlZDtcbiAgfTtcblxuICB2YXIgY3JlYXRlVHJhbnNpdGlvbnMsXG4gICAgICBhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnNfX3Rlc3RTdHlsZSxcbiAgICAgIFRSQU5TSVRJT04sXG4gICAgICBUUkFOU0lUSU9ORU5ELFxuICAgICAgQ1NTX1RSQU5TSVRJT05TX0VOQUJMRUQsXG4gICAgICBUUkFOU0lUSU9OX0RVUkFUSU9OLFxuICAgICAgVFJBTlNJVElPTl9QUk9QRVJUWSxcbiAgICAgIFRSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OLFxuICAgICAgY2FuVXNlQ3NzVHJhbnNpdGlvbnMgPSB7fSxcbiAgICAgIGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zID0ge307XG5cbiAgaWYgKCFpc0NsaWVudCkge1xuICBcdGNyZWF0ZVRyYW5zaXRpb25zID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHRhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnNfX3Rlc3RTdHlsZSA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGU7XG5cbiAgXHQvLyBkZXRlcm1pbmUgc29tZSBmYWN0cyBhYm91dCBvdXIgZW52aXJvbm1lbnRcbiAgXHQoZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9uc19fdGVzdFN0eWxlLnRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRUUkFOU0lUSU9OID0gXCJ0cmFuc2l0aW9uXCI7XG4gIFx0XHRcdFRSQU5TSVRJT05FTkQgPSBcInRyYW5zaXRpb25lbmRcIjtcbiAgXHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSB0cnVlO1xuICBcdFx0fSBlbHNlIGlmIChhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnNfX3Rlc3RTdHlsZS53ZWJraXRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0VFJBTlNJVElPTiA9IFwid2Via2l0VHJhbnNpdGlvblwiO1xuICBcdFx0XHRUUkFOU0lUSU9ORU5EID0gXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCI7XG4gIFx0XHRcdENTU19UUkFOU0lUSU9OU19FTkFCTEVEID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdENTU19UUkFOU0lUSU9OU19FTkFCTEVEID0gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fSkoKTtcblxuICBcdGlmIChUUkFOU0lUSU9OKSB7XG4gIFx0XHRUUkFOU0lUSU9OX0RVUkFUSU9OID0gVFJBTlNJVElPTiArIFwiRHVyYXRpb25cIjtcbiAgXHRcdFRSQU5TSVRJT05fUFJPUEVSVFkgPSBUUkFOU0lUSU9OICsgXCJQcm9wZXJ0eVwiO1xuICBcdFx0VFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT04gPSBUUkFOU0lUSU9OICsgXCJUaW1pbmdGdW5jdGlvblwiO1xuICBcdH1cblxuICBcdGNyZWF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24gKHQsIHRvLCBvcHRpb25zLCBjaGFuZ2VkUHJvcGVydGllcywgcmVzb2x2ZSkge1xuXG4gIFx0XHQvLyBXYWl0IGEgYmVhdCAob3RoZXJ3aXNlIHRoZSB0YXJnZXQgc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBpbW1lZGlhdGVseSlcbiAgXHRcdC8vIFRPRE8gdXNlIGEgZmFzdGRvbS1zdHlsZSBtZWNoYW5pc20/XG4gIFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblxuICBcdFx0XHR2YXIgaGFzaFByZWZpeCwganNUcmFuc2l0aW9uc0NvbXBsZXRlLCBjc3NUcmFuc2l0aW9uc0NvbXBsZXRlLCBjaGVja0NvbXBsZXRlLCB0cmFuc2l0aW9uRW5kSGFuZGxlcjtcblxuICBcdFx0XHRjaGVja0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdGlmIChqc1RyYW5zaXRpb25zQ29tcGxldGUgJiYgY3NzVHJhbnNpdGlvbnNDb21wbGV0ZSkge1xuICBcdFx0XHRcdFx0Ly8gd2lsbCBjaGFuZ2VzIHRvIGV2ZW50cyBhbmQgZmlyZSBoYXZlIGFuIHVuZXhwZWN0ZWQgY29uc2VxdWVuY2UgaGVyZT9cbiAgXHRcdFx0XHRcdHQucm9vdC5maXJlKHQubmFtZSArIFwiOmVuZFwiLCB0Lm5vZGUsIHQuaXNJbnRybyk7XG4gIFx0XHRcdFx0XHRyZXNvbHZlKCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9O1xuXG4gIFx0XHRcdC8vIHRoaXMgaXMgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIGVsZW1lbnRzIGNhbiB1c2UgQ1NTIHRvIGFuaW1hdGVcbiAgXHRcdFx0Ly8gd2hpY2ggcHJvcGVydGllc1xuICBcdFx0XHRoYXNoUHJlZml4ID0gKHQubm9kZS5uYW1lc3BhY2VVUkkgfHwgXCJcIikgKyB0Lm5vZGUudGFnTmFtZTtcblxuICBcdFx0XHR0Lm5vZGUuc3R5bGVbVFJBTlNJVElPTl9QUk9QRVJUWV0gPSBjaGFuZ2VkUHJvcGVydGllcy5tYXAoaGVscGVyc19wcmVmaXgpLm1hcChoeXBoZW5hdGUpLmpvaW4oXCIsXCIpO1xuICBcdFx0XHR0Lm5vZGUuc3R5bGVbVFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT05dID0gaHlwaGVuYXRlKG9wdGlvbnMuZWFzaW5nIHx8IFwibGluZWFyXCIpO1xuICBcdFx0XHR0Lm5vZGUuc3R5bGVbVFJBTlNJVElPTl9EVVJBVElPTl0gPSBvcHRpb25zLmR1cmF0aW9uIC8gMTAwMCArIFwic1wiO1xuXG4gIFx0XHRcdHRyYW5zaXRpb25FbmRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIFx0XHRcdFx0dmFyIGluZGV4O1xuXG4gIFx0XHRcdFx0aW5kZXggPSBjaGFuZ2VkUHJvcGVydGllcy5pbmRleE9mKGNhbWVsQ2FzZSh1bnByZWZpeChldmVudC5wcm9wZXJ0eU5hbWUpKSk7XG4gIFx0XHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0XHQvLyBzdGlsbCB0cmFuc2l0aW9uaW5nLi4uXG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0dC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlKTtcblxuICBcdFx0XHRcdGNzc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuICBcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcbiAgXHRcdFx0fTtcblxuICBcdFx0XHR0Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UpO1xuXG4gIFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHZhciBpID0gY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoLFxuICBcdFx0XHRcdCAgICBoYXNoLFxuICBcdFx0XHRcdCAgICBvcmlnaW5hbFZhbHVlLFxuICBcdFx0XHRcdCAgICBpbmRleCxcbiAgXHRcdFx0XHQgICAgcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMgPSBbXSxcbiAgXHRcdFx0XHQgICAgcHJvcCxcbiAgXHRcdFx0XHQgICAgc3VmZml4O1xuXG4gIFx0XHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdFx0cHJvcCA9IGNoYW5nZWRQcm9wZXJ0aWVzW2ldO1xuICBcdFx0XHRcdFx0aGFzaCA9IGhhc2hQcmVmaXggKyBwcm9wO1xuXG4gIFx0XHRcdFx0XHRpZiAoQ1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgJiYgIWNhbm5vdFVzZUNzc1RyYW5zaXRpb25zW2hhc2hdKSB7XG4gIFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wKV0gPSB0b1twcm9wXTtcblxuICBcdFx0XHRcdFx0XHQvLyBJZiB3ZSdyZSBub3Qgc3VyZSBpZiBDU1MgdHJhbnNpdGlvbnMgYXJlIHN1cHBvcnRlZCBmb3JcbiAgXHRcdFx0XHRcdFx0Ly8gdGhpcyB0YWcvcHJvcGVydHkgY29tYm8sIGZpbmQgb3V0IG5vd1xuICBcdFx0XHRcdFx0XHRpZiAoIWNhblVzZUNzc1RyYW5zaXRpb25zW2hhc2hdKSB7XG4gIFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxWYWx1ZSA9IHQuZ2V0U3R5bGUocHJvcCk7XG5cbiAgXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGlzIHByb3BlcnR5IGlzIHRyYW5zaXRpb25hYmxlIGluIHRoaXMgYnJvd3NlcixcbiAgXHRcdFx0XHRcdFx0XHQvLyB0aGUgY3VycmVudCBzdHlsZSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIHRoZSB0YXJnZXQgc3R5bGVcbiAgXHRcdFx0XHRcdFx0XHRjYW5Vc2VDc3NUcmFuc2l0aW9uc1toYXNoXSA9IHQuZ2V0U3R5bGUocHJvcCkgIT0gdG9bcHJvcF07XG4gIFx0XHRcdFx0XHRcdFx0Y2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0gPSAhY2FuVXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF07XG5cbiAgXHRcdFx0XHRcdFx0XHQvLyBSZXNldCwgaWYgd2UncmUgZ29pbmcgdG8gdXNlIHRpbWVycyBhZnRlciBhbGxcbiAgXHRcdFx0XHRcdFx0XHRpZiAoY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0pIHtcbiAgXHRcdFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wKV0gPSBvcmlnaW5hbFZhbHVlO1xuICBcdFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRpZiAoIUNTU19UUkFOU0lUSU9OU19FTkFCTEVEIHx8IGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zW2hhc2hdKSB7XG4gIFx0XHRcdFx0XHRcdC8vIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIHRpbWVyLWJhc2VkIHN0dWZmXG4gIFx0XHRcdFx0XHRcdGlmIChvcmlnaW5hbFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRcdFx0XHRvcmlnaW5hbFZhbHVlID0gdC5nZXRTdHlsZShwcm9wKTtcbiAgXHRcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRcdC8vIG5lZWQgdG8gcmVtb3ZlIHRoaXMgZnJvbSBjaGFuZ2VkUHJvcGVydGllcywgb3RoZXJ3aXNlIHRyYW5zaXRpb25FbmRIYW5kbGVyXG4gIFx0XHRcdFx0XHRcdC8vIHdpbGwgZ2V0IGNvbmZ1c2VkXG4gIFx0XHRcdFx0XHRcdGluZGV4ID0gY2hhbmdlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKTtcbiAgXHRcdFx0XHRcdFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0XHRcdFx0XHRcdHdhcm5JZkRlYnVnKFwiU29tZXRoaW5nIHZlcnkgc3RyYW5nZSBoYXBwZW5lZCB3aXRoIHRyYW5zaXRpb25zLiBQbGVhc2UgcmFpc2UgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3VlcyAtIHRoYW5rcyFcIiwgeyBub2RlOiB0Lm5vZGUgfSk7XG4gIFx0XHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRcdC8vIFRPRE8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBwcm9wZXJ0eSBpcyBhbmltYXRhYmxlIGF0IGFsbFxuXG4gIFx0XHRcdFx0XHRcdHN1ZmZpeCA9IC9bXlxcZF0qJC8uZXhlYyh0b1twcm9wXSlbMF07XG5cbiAgXHRcdFx0XHRcdFx0Ly8gLi4udGhlbiBraWNrIG9mZiBhIHRpbWVyLWJhc2VkIHRyYW5zaXRpb25cbiAgXHRcdFx0XHRcdFx0cHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMucHVzaCh7XG4gIFx0XHRcdFx0XHRcdFx0bmFtZTogaGVscGVyc19wcmVmaXgocHJvcCksXG4gIFx0XHRcdFx0XHRcdFx0aW50ZXJwb2xhdG9yOiBzaGFyZWRfaW50ZXJwb2xhdGUocGFyc2VGbG9hdChvcmlnaW5hbFZhbHVlKSwgcGFyc2VGbG9hdCh0b1twcm9wXSkpLFxuICBcdFx0XHRcdFx0XHRcdHN1ZmZpeDogc3VmZml4XG4gIFx0XHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIGphdmFzY3JpcHQgdHJhbnNpdGlvbnNcbiAgXHRcdFx0XHRpZiAocHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0XHRuZXcgc2hhcmVkX1RpY2tlcih7XG4gIFx0XHRcdFx0XHRcdHJvb3Q6IHQucm9vdCxcbiAgXHRcdFx0XHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gIFx0XHRcdFx0XHRcdGVhc2luZzogY2FtZWxDYXNlKG9wdGlvbnMuZWFzaW5nIHx8IFwiXCIpLFxuICBcdFx0XHRcdFx0XHRzdGVwOiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHRcdFx0XHRcdFx0dmFyIHByb3AsIGk7XG5cbiAgXHRcdFx0XHRcdFx0XHRpID0gcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMubGVuZ3RoO1xuICBcdFx0XHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRcdFx0XHRcdHByb3AgPSBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kc1tpXTtcbiAgXHRcdFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVtwcm9wLm5hbWVdID0gcHJvcC5pbnRlcnBvbGF0b3IocG9zKSArIHByb3Auc3VmZml4O1xuICBcdFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFx0fSxcbiAgXHRcdFx0XHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdFx0XHRqc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuICBcdFx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGpzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKCFjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uRW5kSGFuZGxlciwgYW5kIGRlYWwgd2l0aFxuICBcdFx0XHRcdFx0Ly8gdGhlIGZhY3QgdGhhdCBpdCB3aWxsIG5ldmVyIGZpcmVcbiAgXHRcdFx0XHRcdHQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBmYWxzZSk7XG4gIFx0XHRcdFx0XHRjc3NUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0sIDApO1xuICBcdFx0fSwgb3B0aW9ucy5kZWxheSB8fCAwKTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9ucyA9IGNyZWF0ZVRyYW5zaXRpb25zO1xuXG4gIHZhciBoaWRkZW4sIHZlbmRvciwgYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX3ByZWZpeCwgYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX2ksIHZpc2liaWxpdHk7XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBcdGhpZGRlbiA9IFwiaGlkZGVuXCI7XG5cbiAgXHR2aXNpYmlsaXR5ID0ge307XG5cbiAgXHRpZiAoaGlkZGVuIGluIGRvY3VtZW50KSB7XG4gIFx0XHRhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9fcHJlZml4ID0gXCJcIjtcbiAgXHR9IGVsc2Uge1xuICBcdFx0YW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX2kgPSB2ZW5kb3JzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9faS0tKSB7XG4gIFx0XHRcdHZlbmRvciA9IHZlbmRvcnNbYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX2ldO1xuICBcdFx0XHRoaWRkZW4gPSB2ZW5kb3IgKyBcIkhpZGRlblwiO1xuXG4gIFx0XHRcdGlmIChoaWRkZW4gaW4gZG9jdW1lbnQpIHtcbiAgXHRcdFx0XHRhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9fcHJlZml4ID0gdmVuZG9yO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19wcmVmaXggIT09IHVuZGVmaW5lZCkge1xuICBcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9fcHJlZml4ICsgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uQ2hhbmdlKTtcblxuICBcdFx0Ly8gaW5pdGlhbGlzZVxuICBcdFx0b25DaGFuZ2UoKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gZ2FoLCB3ZSdyZSBpbiBhbiBvbGQgYnJvd3NlclxuICBcdFx0aWYgKFwib25mb2N1c291dFwiIGluIGRvY3VtZW50KSB7XG4gIFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBvbkhpZGUpO1xuICBcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBvblNob3cpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBvbkhpZGUpO1xuICBcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgb25IaWRlKTtcblxuICBcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VzaG93XCIsIG9uU2hvdyk7XG4gIFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgb25TaG93KTtcbiAgXHRcdH1cblxuICBcdFx0dmlzaWJpbGl0eS5oaWRkZW4gPSBmYWxzZTsgLy8gdW50aWwgcHJvdmVuIG90aGVyd2lzZS4gTm90IGlkZWFsIGJ1dCBoZXlcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgXHR2aXNpYmlsaXR5LmhpZGRlbiA9IGRvY3VtZW50W2hpZGRlbl07XG4gIH1cblxuICBmdW5jdGlvbiBvbkhpZGUoKSB7XG4gIFx0dmlzaWJpbGl0eS5oaWRkZW4gPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TaG93KCkge1xuICBcdHZpc2liaWxpdHkuaGlkZGVuID0gZmFsc2U7XG4gIH1cblxuICB2YXIgYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHkgPSB2aXNpYmlsaXR5O1xuXG4gIHZhciBhbmltYXRlU3R5bGUsIF9hbmltYXRlU3R5bGVfX2dldENvbXB1dGVkU3R5bGUsIHJlc29sdmVkO1xuXG4gIGlmICghaXNDbGllbnQpIHtcbiAgXHRhbmltYXRlU3R5bGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdF9hbmltYXRlU3R5bGVfX2dldENvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSB8fCBsZWdhY3kuZ2V0Q29tcHV0ZWRTdHlsZTtcblxuICBcdGFuaW1hdGVTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciB0bztcblxuICBcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidC5hbmltYXRlU3R5bGUoKSByZXR1cm5zIGEgcHJvbWlzZSAtIHVzZSAudGhlbigpIGluc3RlYWQgb2YgcGFzc2luZyBhIGNhbGxiYWNrXCIpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBwYWdlIGlzbid0IHZpc2libGUuIERvbid0IGFuaW1hdGUgYW55dGhpbmcsIGJlY2F1c2VcbiAgXHRcdC8vIHRoYXQgd2F5IHlvdSdsbCBuZXZlciBnZXQgQ1NTIHRyYW5zaXRpb25lbmQgZXZlbnRzXG4gIFx0XHRpZiAoYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHkuaGlkZGVuKSB7XG4gIFx0XHRcdHRoaXMuc2V0U3R5bGUoc3R5bGUsIHZhbHVlKTtcbiAgXHRcdFx0cmV0dXJuIHJlc29sdmVkIHx8IChyZXNvbHZlZCA9IHV0aWxzX1Byb21pc2UucmVzb2x2ZSgpKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHR0byA9IHt9O1xuICBcdFx0XHR0b1tzdHlsZV0gPSB2YWx1ZTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRvID0gc3R5bGU7XG5cbiAgXHRcdFx0Ly8gc2h1ZmZsZSBhcmd1bWVudHNcbiAgXHRcdFx0b3B0aW9ucyA9IHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBBcyBvZiAwLjMuOSwgdHJhbnNpdGlvbiBhdXRob3JzIHNob3VsZCBzdXBwbHkgYW4gYG9wdGlvbmAgb2JqZWN0IHdpdGhcbiAgXHRcdC8vIGBkdXJhdGlvbmAgYW5kIGBlYXNpbmdgIHByb3BlcnRpZXMgKGFuZCBvcHRpb25hbCBgZGVsYXlgKSwgcGx1cyBhXG4gIFx0XHQvLyBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGFmdGVyIHRoZSBhbmltYXRpb24gY29tcGxldGVzXG5cbiAgXHRcdC8vIFRPRE8gcmVtb3ZlIHRoaXMgY2hlY2sgaW4gYSBmdXR1cmUgdmVyc2lvblxuICBcdFx0aWYgKCFvcHRpb25zKSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhcIlRoZSBcXFwiJXNcXFwiIHRyYW5zaXRpb24gZG9lcyBub3Qgc3VwcGx5IGFuIG9wdGlvbnMgb2JqZWN0IHRvIGB0LmFuaW1hdGVTdHlsZSgpYC4gVGhpcyB3aWxsIGJyZWFrIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgUmFjdGl2ZS4gRm9yIG1vcmUgaW5mbyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3Vlcy8zNDBcIiwgdGhpcy5uYW1lKTtcbiAgXHRcdFx0b3B0aW9ucyA9IHRoaXM7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBwcm9taXNlID0gbmV3IHV0aWxzX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgXHRcdFx0dmFyIHByb3BlcnR5TmFtZXMsIGNoYW5nZWRQcm9wZXJ0aWVzLCBjb21wdXRlZFN0eWxlLCBjdXJyZW50LCBmcm9tLCBpLCBwcm9wO1xuXG4gIFx0XHRcdC8vIEVkZ2UgY2FzZSAtIGlmIGR1cmF0aW9uIGlzIHplcm8sIHNldCBzdHlsZSBzeW5jaHJvbm91c2x5IGFuZCBjb21wbGV0ZVxuICBcdFx0XHRpZiAoIW9wdGlvbnMuZHVyYXRpb24pIHtcbiAgXHRcdFx0XHRfdGhpcy5zZXRTdHlsZSh0byk7XG4gIFx0XHRcdFx0cmVzb2x2ZSgpO1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIEdldCBhIGxpc3Qgb2YgdGhlIHByb3BlcnRpZXMgd2UncmUgYW5pbWF0aW5nXG4gIFx0XHRcdHByb3BlcnR5TmFtZXMgPSBPYmplY3Qua2V5cyh0byk7XG4gIFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzID0gW107XG5cbiAgXHRcdFx0Ly8gU3RvcmUgdGhlIGN1cnJlbnQgc3R5bGVzXG4gIFx0XHRcdGNvbXB1dGVkU3R5bGUgPSBfYW5pbWF0ZVN0eWxlX19nZXRDb21wdXRlZFN0eWxlKF90aGlzLm5vZGUpO1xuXG4gIFx0XHRcdGZyb20gPSB7fTtcbiAgXHRcdFx0aSA9IHByb3BlcnR5TmFtZXMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0cHJvcCA9IHByb3BlcnR5TmFtZXNbaV07XG4gIFx0XHRcdFx0Y3VycmVudCA9IGNvbXB1dGVkU3R5bGVbaGVscGVyc19wcmVmaXgocHJvcCldO1xuXG4gIFx0XHRcdFx0aWYgKGN1cnJlbnQgPT09IFwiMHB4XCIpIHtcbiAgXHRcdFx0XHRcdGN1cnJlbnQgPSAwO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIHdlIG5lZWQgdG8ga25vdyBpZiB3ZSdyZSBhY3R1YWxseSBjaGFuZ2luZyBhbnl0aGluZ1xuICBcdFx0XHRcdGlmIChjdXJyZW50ICE9IHRvW3Byb3BdKSB7XG4gIFx0XHRcdFx0XHQvLyB1c2UgIT0gaW5zdGVhZCBvZiAhPT0sIHNvIHdlIGNhbiBjb21wYXJlIHN0cmluZ3Mgd2l0aCBudW1iZXJzXG4gIFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5wdXNoKHByb3ApO1xuXG4gIFx0XHRcdFx0XHQvLyBtYWtlIHRoZSBjb21wdXRlZCBzdHlsZSBleHBsaWNpdCwgc28gd2UgY2FuIGFuaW1hdGUgd2hlcmVcbiAgXHRcdFx0XHRcdC8vIGUuZy4gaGVpZ2h0PSdhdXRvJ1xuICBcdFx0XHRcdFx0X3RoaXMubm9kZS5zdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wKV0gPSBjdXJyZW50O1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIElmIHdlJ3JlIG5vdCBhY3R1YWxseSBjaGFuZ2luZyBhbnl0aGluZywgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnRcbiAgXHRcdFx0Ly8gd2lsbCBuZXZlciBmaXJlISBTbyB3ZSBjb21wbGV0ZSBlYXJseVxuICBcdFx0XHRpZiAoIWNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICBcdFx0XHRcdHJlc29sdmUoKTtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHRhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnMoX3RoaXMsIHRvLCBvcHRpb25zLCBjaGFuZ2VkUHJvcGVydGllcywgcmVzb2x2ZSk7XG4gIFx0XHR9KTtcblxuICBcdFx0cmV0dXJuIHByb21pc2U7XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBfYW5pbWF0ZVN0eWxlID0gYW5pbWF0ZVN0eWxlO1xuXG4gIHZhciBwcm9jZXNzUGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcywgZGVmYXVsdHMpIHtcbiAgXHRpZiAodHlwZW9mIHBhcmFtcyA9PT0gXCJudW1iZXJcIikge1xuICBcdFx0cGFyYW1zID0geyBkdXJhdGlvbjogcGFyYW1zIH07XG4gIFx0fSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRpZiAocGFyYW1zID09PSBcInNsb3dcIikge1xuICBcdFx0XHRwYXJhbXMgPSB7IGR1cmF0aW9uOiA2MDAgfTtcbiAgXHRcdH0gZWxzZSBpZiAocGFyYW1zID09PSBcImZhc3RcIikge1xuICBcdFx0XHRwYXJhbXMgPSB7IGR1cmF0aW9uOiAyMDAgfTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhcmFtcyA9IHsgZHVyYXRpb246IDQwMCB9O1xuICBcdFx0fVxuICBcdH0gZWxzZSBpZiAoIXBhcmFtcykge1xuICBcdFx0cGFyYW1zID0ge307XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGZpbGxHYXBzKHt9LCBwYXJhbXMsIGRlZmF1bHRzKTtcbiAgfTtcblxuICB2YXIgcHJvdG90eXBlX3N0YXJ0ID0gVHJhbnNpdGlvbiRzdGFydDtcblxuICBmdW5jdGlvbiBUcmFuc2l0aW9uJHN0YXJ0KCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgbm9kZSwgb3JpZ2luYWxTdHlsZSwgY29tcGxldGVkO1xuXG4gIFx0bm9kZSA9IHRoaXMubm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuICBcdG9yaWdpbmFsU3R5bGUgPSBub2RlLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuXG4gIFx0Ly8gY3JlYXRlIHQuY29tcGxldGUoKSAtIHdlIGRvbid0IHdhbnQgdGhpcyBvbiB0aGUgcHJvdG90eXBlLFxuICBcdC8vIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBgdGhpc2Agc2lsbGluZXNzIHdoZW4gcGFzc2luZyBpdCBhc1xuICBcdC8vIGFuIGFyZ3VtZW50XG4gIFx0dGhpcy5jb21wbGV0ZSA9IGZ1bmN0aW9uIChub1Jlc2V0KSB7XG4gIFx0XHRpZiAoY29tcGxldGVkKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFub1Jlc2V0ICYmIF90aGlzLmlzSW50cm8pIHtcbiAgXHRcdFx0cmVzZXRTdHlsZShub2RlLCBvcmlnaW5hbFN0eWxlKTtcbiAgXHRcdH1cblxuICBcdFx0bm9kZS5fcmFjdGl2ZS50cmFuc2l0aW9uID0gbnVsbDtcbiAgXHRcdF90aGlzLl9tYW5hZ2VyLnJlbW92ZShfdGhpcyk7XG5cbiAgXHRcdGNvbXBsZXRlZCA9IHRydWU7XG4gIFx0fTtcblxuICBcdC8vIElmIHRoZSB0cmFuc2l0aW9uIGZ1bmN0aW9uIGRvZXNuJ3QgZXhpc3QsIGFib3J0XG4gIFx0aWYgKCF0aGlzLl9mbikge1xuICBcdFx0dGhpcy5jb21wbGV0ZSgpO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHRoaXMuX2ZuLmFwcGx5KHRoaXMucm9vdCwgW3RoaXNdLmNvbmNhdCh0aGlzLnBhcmFtcykpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRTdHlsZShub2RlLCBzdHlsZSkge1xuICBcdGlmIChzdHlsZSkge1xuICBcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBzdHlsZSk7XG4gIFx0fSBlbHNlIHtcblxuICBcdFx0Ly8gTmV4dCBsaW5lIGlzIG5lY2Vzc2FyeSwgdG8gcmVtb3ZlIGVtcHR5IHN0eWxlIGF0dHJpYnV0ZSFcbiAgXHRcdC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTY3NTUzXG4gIFx0XHRub2RlLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICBcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChvd25lciwgdGVtcGxhdGUsIGlzSW50cm8pIHtcbiAgXHR0aGlzLmluaXQob3duZXIsIHRlbXBsYXRlLCBpc0ludHJvKTtcbiAgfTtcblxuICBUcmFuc2l0aW9uLnByb3RvdHlwZSA9IHtcbiAgXHRpbml0OiBUcmFuc2l0aW9uX3Byb3RvdHlwZV9pbml0LFxuICBcdHN0YXJ0OiBwcm90b3R5cGVfc3RhcnQsXG4gIFx0Z2V0U3R5bGU6IHByb3RvdHlwZV9nZXRTdHlsZSxcbiAgXHRzZXRTdHlsZTogc2V0U3R5bGUsXG4gIFx0YW5pbWF0ZVN0eWxlOiBfYW5pbWF0ZVN0eWxlLFxuICBcdHByb2Nlc3NQYXJhbXM6IHByb2Nlc3NQYXJhbXNcbiAgfTtcblxuICB2YXIgX1RyYW5zaXRpb24gPSBUcmFuc2l0aW9uO1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9yZW5kZXIgPSBFbGVtZW50JHJlbmRlcjtcblxuICB2YXIgdXBkYXRlQ3NzLCB1cGRhdGVTY3JpcHQ7XG5cbiAgdXBkYXRlQ3NzID0gZnVuY3Rpb24gKCkge1xuICBcdHZhciBub2RlID0gdGhpcy5ub2RlLFxuICBcdCAgICBjb250ZW50ID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyhmYWxzZSk7XG5cbiAgXHQvLyBJRTggaGFzIG5vIHN0eWxlU2hlZXQgdW5sZXNzIHRoZXJlJ3MgYSB0eXBlIHRleHQvY3NzXG4gIFx0aWYgKHdpbmRvdyAmJiB3aW5kb3cuYXBwZWFyc1RvQmVJRUxlc3NFcXVhbDgpIHtcbiAgXHRcdG5vZGUudHlwZSA9IFwidGV4dC9jc3NcIjtcbiAgXHR9XG5cbiAgXHRpZiAobm9kZS5zdHlsZVNoZWV0KSB7XG4gIFx0XHRub2RlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNvbnRlbnQ7XG4gIFx0fSBlbHNlIHtcblxuICBcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gIFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgXHRcdH1cblxuICBcdFx0bm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb250ZW50KSk7XG4gIFx0fVxuICB9O1xuXG4gIHVwZGF0ZVNjcmlwdCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRpZiAoIXRoaXMubm9kZS50eXBlIHx8IHRoaXMubm9kZS50eXBlID09PSBcInRleHQvamF2YXNjcmlwdFwiKSB7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcIlNjcmlwdCB0YWcgd2FzIHVwZGF0ZWQuIFRoaXMgZG9lcyBub3QgY2F1c2UgdGhlIGNvZGUgdG8gYmUgcmUtZXZhbHVhdGVkIVwiLCB7IHJhY3RpdmU6IHRoaXMucm9vdCB9KTtcbiAgXHRcdC8vIEFzIGl0IGhhcHBlbnMsIHdlIEFSRSBpbiBhIHBvc2l0aW9uIHRvIHJlLWV2YWx1YXRlIHRoZSBjb2RlIGlmIHdlIHdhbnRlZFxuICBcdFx0Ly8gdG8gLSB3ZSBjb3VsZCBldmFsKCkgaXQsIG9yIGluc2VydCBpdCBpbnRvIGEgZnJlc2ggKHRlbXBvcmFyeSkgc2NyaXB0IHRhZy5cbiAgXHRcdC8vIEJ1dCB0aGlzIHdvdWxkIGJlIGEgdGVycmlibGUgaWRlYSB3aXRoIHVucHJlZGljdGFibGUgcmVzdWx0cywgc28gbGV0J3Mgbm90LlxuICBcdH1cblxuICBcdHRoaXMubm9kZS50ZXh0ID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyhmYWxzZSk7XG4gIH07XG4gIGZ1bmN0aW9uIEVsZW1lbnQkcmVuZGVyKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgcm9vdCA9IHRoaXMucm9vdCxcbiAgXHQgICAgbmFtZXNwYWNlLFxuICBcdCAgICBub2RlLFxuICBcdCAgICB0cmFuc2l0aW9uO1xuXG4gIFx0bmFtZXNwYWNlID0gZ2V0TmFtZXNwYWNlKHRoaXMpO1xuICBcdG5vZGUgPSB0aGlzLm5vZGUgPSBjcmVhdGVFbGVtZW50KHRoaXMubmFtZSwgbmFtZXNwYWNlKTtcblxuICBcdC8vIElzIHRoaXMgYSB0b3AtbGV2ZWwgbm9kZSBvZiBhIGNvbXBvbmVudD8gSWYgc28sIHdlIG1heSBuZWVkIHRvIGFkZFxuICBcdC8vIGEgZGF0YS1yYWN0aXZlLWNzcyBhdHRyaWJ1dGUsIGZvciBDU1MgZW5jYXBzdWxhdGlvblxuICBcdGlmICh0aGlzLnBhcmVudEZyYWdtZW50LmNzc0lkcykge1xuICBcdFx0dGhpcy5ub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtcmFjdGl2ZS1jc3NcIiwgdGhpcy5wYXJlbnRGcmFnbWVudC5jc3NJZHMubWFwKGZ1bmN0aW9uICh4KSB7XG4gIFx0XHRcdHJldHVybiBcIntcIiArIHggKyBcIn1cIjtcbiAgXHRcdH0pLmpvaW4oXCIgXCIpKTtcbiAgXHR9XG5cbiAgXHQvLyBBZGQgX3JhY3RpdmUgcHJvcGVydHkgdG8gdGhlIG5vZGUgLSB3ZSB1c2UgdGhpcyBvYmplY3QgdG8gc3RvcmUgc3R1ZmZcbiAgXHQvLyByZWxhdGVkIHRvIHByb3h5IGV2ZW50cywgdHdvLXdheSBiaW5kaW5ncyBldGNcbiAgXHRkZWZpbmVQcm9wZXJ0eSh0aGlzLm5vZGUsIFwiX3JhY3RpdmVcIiwge1xuICBcdFx0dmFsdWU6IHtcbiAgXHRcdFx0cHJveHk6IHRoaXMsXG4gIFx0XHRcdGtleXBhdGg6IGdldElubmVyQ29udGV4dCh0aGlzLnBhcmVudEZyYWdtZW50KSxcbiAgXHRcdFx0ZXZlbnRzOiBjcmVhdGUobnVsbCksXG4gIFx0XHRcdHJvb3Q6IHJvb3RcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdC8vIFJlbmRlciBhdHRyaWJ1dGVzXG4gIFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgXHRcdHJldHVybiBhLnJlbmRlcihub2RlKTtcbiAgXHR9KTtcbiAgXHR0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gIFx0XHRyZXR1cm4gYS5yZW5kZXIobm9kZSk7XG4gIFx0fSk7XG5cbiAgXHQvLyBSZW5kZXIgY2hpbGRyZW5cbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gPHNjcmlwdD4gZWxlbWVudFxuICBcdFx0aWYgKHRoaXMubmFtZSA9PT0gXCJzY3JpcHRcIikge1xuICBcdFx0XHR0aGlzLmJ1YmJsZSA9IHVwZGF0ZVNjcmlwdDtcbiAgXHRcdFx0dGhpcy5ub2RlLnRleHQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKGZhbHNlKTsgLy8gYnlwYXNzIHdhcm5pbmcgaW5pdGlhbGx5XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIgPSBub29wOyAvLyBUT0RPIHRoaXMgaXMgYSBrbHVkZ2VcbiAgXHRcdH1cblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gPHN0eWxlPiBlbGVtZW50XG4gIFx0XHRlbHNlIGlmICh0aGlzLm5hbWUgPT09IFwic3R5bGVcIikge1xuICBcdFx0XHR0aGlzLmJ1YmJsZSA9IHVwZGF0ZUNzcztcbiAgXHRcdFx0dGhpcy5idWJibGUoKTtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciA9IG5vb3A7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSAtIGNvbnRlbnRlZGl0YWJsZVxuICBcdFx0ZWxzZSBpZiAodGhpcy5iaW5kaW5nICYmIHRoaXMuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpKSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIgPSBub29wO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuZnJhZ21lbnQucmVuZGVyKCkpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIGRlYWwgd2l0aCB0d28td2F5IGJpbmRpbmdzXG4gIFx0aWYgKHRoaXMuYmluZGluZykge1xuICBcdFx0dGhpcy5iaW5kaW5nLnJlbmRlcigpO1xuICBcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLmJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XG4gIFx0fVxuXG4gIFx0Ly8gQWRkIHByb3h5IGV2ZW50IGhhbmRsZXJzXG4gIFx0aWYgKHRoaXMuZXZlbnRIYW5kbGVycykge1xuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGgpIHtcbiAgXHRcdFx0cmV0dXJuIGgucmVuZGVyKCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiKSB7XG4gIFx0XHRwcm9jZXNzT3B0aW9uKHRoaXMpO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZXNcbiAgXHRpZiAodGhpcy5uYW1lID09PSBcImltZ1wiKSB7XG4gIFx0XHQvLyBpZiB0aGlzIGlzIGFuIDxpbWc+LCBhbmQgd2UncmUgaW4gYSBjcmFwIGJyb3dzZXIsIHdlIG1heVxuICBcdFx0Ly8gbmVlZCB0byBwcmV2ZW50IGl0IGZyb20gb3ZlcnJpZGluZyB3aWR0aCBhbmQgaGVpZ2h0IHdoZW5cbiAgXHRcdC8vIGl0IGxvYWRzIHRoZSBzcmNcbiAgXHRcdHNwZWNpYWxfaW1nX19yZW5kZXIodGhpcyk7XG4gIFx0fSBlbHNlIGlmICh0aGlzLm5hbWUgPT09IFwiZm9ybVwiKSB7XG4gIFx0XHQvLyBmb3JtcyBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgdGhlaXIgYmluZGluZ3MsIGluIGNhc2Ugb2YgcmVzZXRcbiAgXHRcdGZvcm1fX3JlbmRlcih0aGlzKTtcbiAgXHR9IGVsc2UgaWYgKHRoaXMubmFtZSA9PT0gXCJpbnB1dFwiIHx8IHRoaXMubmFtZSA9PT0gXCJ0ZXh0YXJlYVwiKSB7XG4gIFx0XHQvLyBpbnB1dHMgYW5kIHRleHRhcmVhcyBzaG91bGQgc3RvcmUgdGhlaXIgaW5pdGlhbCB2YWx1ZSBhc1xuICBcdFx0Ly8gYGRlZmF1bHRWYWx1ZWAgaW4gY2FzZSBvZiByZXNldFxuICBcdFx0dGhpcy5ub2RlLmRlZmF1bHRWYWx1ZSA9IHRoaXMubm9kZS52YWx1ZTtcbiAgXHR9IGVsc2UgaWYgKHRoaXMubmFtZSA9PT0gXCJvcHRpb25cIikge1xuICBcdFx0Ly8gc2ltaWxhcmx5IGZvciBvcHRpb24gbm9kZXNcbiAgXHRcdHRoaXMubm9kZS5kZWZhdWx0U2VsZWN0ZWQgPSB0aGlzLm5vZGUuc2VsZWN0ZWQ7XG4gIFx0fVxuXG4gIFx0Ly8gYXBwbHkgZGVjb3JhdG9yKHMpXG4gIFx0aWYgKHRoaXMuZGVjb3JhdG9yICYmIHRoaXMuZGVjb3JhdG9yLmZuKSB7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRpZiAoIV90aGlzLmRlY29yYXRvci50b3JuZG93bikge1xuICBcdFx0XHRcdF90aGlzLmRlY29yYXRvci5pbml0KCk7XG4gIFx0XHRcdH1cbiAgXHRcdH0sIHRydWUpO1xuICBcdH1cblxuICBcdC8vIHRyaWdnZXIgaW50cm8gdHJhbnNpdGlvblxuICBcdGlmIChyb290LnRyYW5zaXRpb25zRW5hYmxlZCAmJiB0aGlzLmludHJvKSB7XG4gIFx0XHR0cmFuc2l0aW9uID0gbmV3IF9UcmFuc2l0aW9uKHRoaXMsIHRoaXMuaW50cm8sIHRydWUpO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AucmVnaXN0ZXJUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIHRyYW5zaXRpb24uc3RhcnQoKTtcbiAgXHRcdH0sIHRydWUpO1xuXG4gIFx0XHR0aGlzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICBcdH1cblxuICBcdGlmICh0aGlzLm5vZGUuYXV0b2ZvY3VzKSB7XG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UuIFNvbWUgYnJvd3NlcnMgKCpjb3VnaCogRmlyZWZpeCAqY291Z2gqKSBoYXZlIGEgcHJvYmxlbVxuICBcdFx0Ly8gd2l0aCBkeW5hbWljYWxseS1nZW5lcmF0ZWQgZWxlbWVudHMgaGF2aW5nIGF1dG9mb2N1cywgYW5kIHRoZXkgd29uJ3RcbiAgXHRcdC8vIGFsbG93IHlvdSB0byBwcm9ncmFtbWF0aWNhbGx5IGZvY3VzIHRoZSBlbGVtZW50IHVudGlsIGl0J3MgaW4gdGhlIERPTVxuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIF90aGlzLm5vZGUuZm9jdXMoKTtcbiAgXHRcdH0sIHRydWUpO1xuICBcdH1cblxuICBcdHVwZGF0ZUxpdmVRdWVyaWVzKHRoaXMpO1xuICBcdHJldHVybiB0aGlzLm5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROYW1lc3BhY2UoZWxlbWVudCkge1xuICBcdHZhciBuYW1lc3BhY2UsIHhtbG5zLCBwYXJlbnQ7XG5cbiAgXHQvLyBVc2Ugc3BlY2lmaWVkIG5hbWVzcGFjZS4uLlxuICBcdGlmICh4bWxucyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikpIHtcbiAgXHRcdG5hbWVzcGFjZSA9IHhtbG5zO1xuICBcdH1cblxuICBcdC8vIC4uLm9yIFNWRyBuYW1lc3BhY2UsIGlmIHRoaXMgaXMgYW4gPHN2Zz4gZWxlbWVudFxuICBcdGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gXCJzdmdcIikge1xuICBcdFx0bmFtZXNwYWNlID0gbmFtZXNwYWNlcy5zdmc7XG4gIFx0fSBlbHNlIGlmIChwYXJlbnQgPSBlbGVtZW50LnBhcmVudCkge1xuICBcdFx0Ly8gLi4ub3IgSFRNTCwgaWYgdGhlIHBhcmVudCBpcyBhIDxmb3JlaWduT2JqZWN0PlxuICBcdFx0aWYgKHBhcmVudC5uYW1lID09PSBcImZvcmVpZ25PYmplY3RcIikge1xuICBcdFx0XHRuYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmh0bWw7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIC4uLm9yIGluaGVyaXQgZnJvbSB0aGUgcGFyZW50IG5vZGVcbiAgXHRcdGVsc2Uge1xuICBcdFx0XHRuYW1lc3BhY2UgPSBwYXJlbnQubm9kZS5uYW1lc3BhY2VVUkk7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG5hbWVzcGFjZSA9IGVsZW1lbnQucm9vdC5lbC5uYW1lc3BhY2VVUkk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG5hbWVzcGFjZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NPcHRpb24ob3B0aW9uKSB7XG4gIFx0dmFyIG9wdGlvblZhbHVlLCBzZWxlY3RWYWx1ZSwgaTtcblxuICBcdGlmICghb3B0aW9uLnNlbGVjdCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHNlbGVjdFZhbHVlID0gb3B0aW9uLnNlbGVjdC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgXHRpZiAoc2VsZWN0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdG9wdGlvblZhbHVlID0gb3B0aW9uLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0aWYgKG9wdGlvbi5zZWxlY3Qubm9kZS5tdWx0aXBsZSAmJiBpc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICBcdFx0aSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0aWYgKG9wdGlvblZhbHVlID09IHNlbGVjdFZhbHVlW2ldKSB7XG4gIFx0XHRcdFx0b3B0aW9uLm5vZGUuc2VsZWN0ZWQgPSB0cnVlO1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG9wdGlvbi5ub2RlLnNlbGVjdGVkID0gb3B0aW9uVmFsdWUgPT0gc2VsZWN0VmFsdWU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGl2ZVF1ZXJpZXMoZWxlbWVudCkge1xuICBcdHZhciBpbnN0YW5jZSwgbGl2ZVF1ZXJpZXMsIGksIHNlbGVjdG9yLCBxdWVyeTtcblxuICBcdC8vIERvZXMgdGhpcyBuZWVkIHRvIGJlIGFkZGVkIHRvIGFueSBsaXZlIHF1ZXJpZXM/XG4gIFx0aW5zdGFuY2UgPSBlbGVtZW50LnJvb3Q7XG5cbiAgXHRkbyB7XG4gIFx0XHRsaXZlUXVlcmllcyA9IGluc3RhbmNlLl9saXZlUXVlcmllcztcblxuICBcdFx0aSA9IGxpdmVRdWVyaWVzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0c2VsZWN0b3IgPSBsaXZlUXVlcmllc1tpXTtcbiAgXHRcdFx0cXVlcnkgPSBsaXZlUXVlcmllc1tcIl9cIiArIHNlbGVjdG9yXTtcblxuICBcdFx0XHRpZiAocXVlcnkuX3Rlc3QoZWxlbWVudCkpIHtcbiAgXHRcdFx0XHQvLyBrZWVwIHJlZ2lzdGVyIG9mIGFwcGxpY2FibGUgc2VsZWN0b3JzLCBmb3Igd2hlbiB3ZSB0ZWFyZG93blxuICBcdFx0XHRcdChlbGVtZW50LmxpdmVRdWVyaWVzIHx8IChlbGVtZW50LmxpdmVRdWVyaWVzID0gW10pKS5wdXNoKHF1ZXJ5KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0gd2hpbGUgKGluc3RhbmNlID0gaW5zdGFuY2UucGFyZW50KTtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV90b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgc3RyLCBlc2NhcGU7XG5cbiAgXHRpZiAodGhpcy50ZW1wbGF0ZS55KSB7XG4gIFx0XHQvLyBET0NUWVBFIGRlY2xhcmF0aW9uXG4gIFx0XHRyZXR1cm4gXCI8IURPQ1RZUEVcIiArIHRoaXMudGVtcGxhdGUuZGQgKyBcIj5cIjtcbiAgXHR9XG5cbiAgXHRzdHIgPSBcIjxcIiArIHRoaXMudGVtcGxhdGUuZTtcblxuICBcdHN0ciArPSB0aGlzLmF0dHJpYnV0ZXMubWFwKHN0cmluZ2lmeUF0dHJpYnV0ZSkuam9pbihcIlwiKSArIHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzLm1hcChzdHJpbmdpZnlBdHRyaWJ1dGUpLmpvaW4oXCJcIik7XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSBzZWxlY3RlZCBvcHRpb25zXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJvcHRpb25cIiAmJiBvcHRpb25Jc1NlbGVjdGVkKHRoaXMpKSB7XG4gIFx0XHRzdHIgKz0gXCIgc2VsZWN0ZWRcIjtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSB0d28td2F5IHJhZGlvIG5hbWUgYmluZGluZ3NcbiAgXHRpZiAodGhpcy5uYW1lID09PSBcImlucHV0XCIgJiYgaW5wdXRJc0NoZWNrZWRSYWRpbyh0aGlzKSkge1xuICBcdFx0c3RyICs9IFwiIGNoZWNrZWRcIjtcbiAgXHR9XG5cbiAgXHRzdHIgKz0gXCI+XCI7XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSB0ZXh0YXJlYVxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwidGV4dGFyZWFcIiAmJiB0aGlzLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdHN0ciArPSBlc2NhcGVIdG1sKHRoaXMuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikpO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIGNvbnRlbnRlZGl0YWJsZVxuICBcdGVsc2UgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdHN0ciArPSB0aGlzLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIHx8IFwiXCI7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdGVzY2FwZSA9IHRoaXMubmFtZSAhPT0gXCJzY3JpcHRcIiAmJiB0aGlzLm5hbWUgIT09IFwic3R5bGVcIjtcbiAgXHRcdHN0ciArPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKGVzY2FwZSk7XG4gIFx0fVxuXG4gIFx0Ly8gYWRkIGEgY2xvc2luZyB0YWcgaWYgdGhpcyBpc24ndCBhIHZvaWQgZWxlbWVudFxuICBcdGlmICghdm9pZEVsZW1lbnROYW1lcy50ZXN0KHRoaXMudGVtcGxhdGUuZSkpIHtcbiAgXHRcdHN0ciArPSBcIjwvXCIgKyB0aGlzLnRlbXBsYXRlLmUgKyBcIj5cIjtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3RyO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG9wdGlvbklzU2VsZWN0ZWQoZWxlbWVudCkge1xuICBcdHZhciBvcHRpb25WYWx1ZSwgc2VsZWN0VmFsdWUsIGk7XG5cbiAgXHRvcHRpb25WYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRpZiAob3B0aW9uVmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhZWxlbWVudC5zZWxlY3QpIHtcbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG5cbiAgXHRzZWxlY3RWYWx1ZSA9IGVsZW1lbnQuc2VsZWN0LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0aWYgKHNlbGVjdFZhbHVlID09IG9wdGlvblZhbHVlKSB7XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG5cbiAgXHRpZiAoZWxlbWVudC5zZWxlY3QuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikgJiYgaXNBcnJheShzZWxlY3RWYWx1ZSkpIHtcbiAgXHRcdGkgPSBzZWxlY3RWYWx1ZS5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGlmIChzZWxlY3RWYWx1ZVtpXSA9PSBvcHRpb25WYWx1ZSkge1xuICBcdFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gaW5wdXRJc0NoZWNrZWRSYWRpbyhlbGVtZW50KSB7XG4gIFx0dmFyIGF0dHJpYnV0ZXMsIHR5cGVBdHRyaWJ1dGUsIHZhbHVlQXR0cmlidXRlLCBuYW1lQXR0cmlidXRlO1xuXG4gIFx0YXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcztcblxuICBcdHR5cGVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnR5cGU7XG4gIFx0dmFsdWVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnZhbHVlO1xuICBcdG5hbWVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLm5hbWU7XG5cbiAgXHRpZiAoIXR5cGVBdHRyaWJ1dGUgfHwgdHlwZUF0dHJpYnV0ZS52YWx1ZSAhPT0gXCJyYWRpb1wiIHx8ICF2YWx1ZUF0dHJpYnV0ZSB8fCAhbmFtZUF0dHJpYnV0ZS5pbnRlcnBvbGF0b3IpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAodmFsdWVBdHRyaWJ1dGUudmFsdWUgPT09IG5hbWVBdHRyaWJ1dGUuaW50ZXJwb2xhdG9yLnZhbHVlKSB7XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gIFx0dmFyIHN0ciA9IGF0dHJpYnV0ZS50b1N0cmluZygpO1xuICBcdHJldHVybiBzdHIgPyBcIiBcIiArIHN0ciA6IFwiXCI7XG4gIH1cblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfdW5iaW5kID0gRWxlbWVudCR1bmJpbmQ7XG4gIGZ1bmN0aW9uIEVsZW1lbnQkdW5iaW5kKCkge1xuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmJpbmRpbmcpIHtcbiAgXHRcdHRoaXMuYmluZGluZy51bmJpbmQoKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5ldmVudEhhbmRsZXJzKSB7XG4gIFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIDxvcHRpb24+XG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJvcHRpb25cIikge1xuICBcdFx0c3BlY2lhbF9vcHRpb25fX3VuYmluZCh0aGlzKTtcbiAgXHR9XG5cbiAgXHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV91bnJlbmRlciA9IEVsZW1lbnQkdW5yZW5kZXI7XG5cbiAgZnVuY3Rpb24gRWxlbWVudCR1bnJlbmRlcihzaG91bGREZXN0cm95KSB7XG4gIFx0dmFyIGJpbmRpbmcsIGJpbmRpbmdzLCB0cmFuc2l0aW9uO1xuXG4gIFx0aWYgKHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb24pIHtcbiAgXHRcdHRyYW5zaXRpb24uY29tcGxldGUoKTtcbiAgXHR9XG5cbiAgXHQvLyBEZXRhY2ggYXMgc29vbiBhcyB3ZSBjYW5cbiAgXHRpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiKSB7XG4gIFx0XHQvLyA8b3B0aW9uPiBlbGVtZW50cyBkZXRhY2ggaW1tZWRpYXRlbHksIHNvIHRoYXRcbiAgXHRcdC8vIHRoZWlyIHBhcmVudCA8c2VsZWN0PiBlbGVtZW50IHN5bmNzIGNvcnJlY3RseSwgYW5kXG4gIFx0XHQvLyBzaW5jZSBvcHRpb24gZWxlbWVudHMgY2FuJ3QgaGF2ZSB0cmFuc2l0aW9ucyBhbnl3YXlcbiAgXHRcdHRoaXMuZGV0YWNoKCk7XG4gIFx0fSBlbHNlIGlmIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5kZXRhY2hXaGVuUmVhZHkodGhpcyk7XG4gIFx0fVxuXG4gIFx0Ly8gQ2hpbGRyZW4gZmlyc3QuIHRoYXQgd2F5LCBhbnkgdHJhbnNpdGlvbnMgb24gY2hpbGQgZWxlbWVudHMgd2lsbCBiZVxuICBcdC8vIGhhbmRsZWQgYnkgdGhlIGN1cnJlbnQgdHJhbnNpdGlvbk1hbmFnZXJcbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlcihmYWxzZSk7XG4gIFx0fVxuXG4gIFx0aWYgKGJpbmRpbmcgPSB0aGlzLmJpbmRpbmcpIHtcbiAgXHRcdHRoaXMuYmluZGluZy51bnJlbmRlcigpO1xuXG4gIFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuYmluZGluZyA9IG51bGw7XG4gIFx0XHRiaW5kaW5ncyA9IHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbYmluZGluZy5rZXlwYXRoLnN0cl07XG4gIFx0XHRiaW5kaW5ncy5zcGxpY2UoYmluZGluZ3MuaW5kZXhPZihiaW5kaW5nKSwgMSk7XG4gIFx0fVxuXG4gIFx0Ly8gUmVtb3ZlIGV2ZW50IGhhbmRsZXJzXG4gIFx0aWYgKHRoaXMuZXZlbnRIYW5kbGVycykge1xuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5yZW5kZXIpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmRlY29yYXRvcikge1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AucmVnaXN0ZXJEZWNvcmF0b3IodGhpcy5kZWNvcmF0b3IpO1xuICBcdH1cblxuICBcdC8vIHRyaWdnZXIgb3V0cm8gdHJhbnNpdGlvbiBpZiBuZWNlc3NhcnlcbiAgXHRpZiAodGhpcy5yb290LnRyYW5zaXRpb25zRW5hYmxlZCAmJiB0aGlzLm91dHJvKSB7XG4gIFx0XHR0cmFuc2l0aW9uID0gbmV3IF9UcmFuc2l0aW9uKHRoaXMsIHRoaXMub3V0cm8sIGZhbHNlKTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnJlZ2lzdGVyVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiB0cmFuc2l0aW9uLnN0YXJ0KCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHQvLyBSZW1vdmUgdGhpcyBub2RlIGZyb20gYW55IGxpdmUgcXVlcmllc1xuICBcdGlmICh0aGlzLmxpdmVRdWVyaWVzKSB7XG4gIFx0XHRyZW1vdmVGcm9tTGl2ZVF1ZXJpZXModGhpcyk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJmb3JtXCIpIHtcbiAgXHRcdGZvcm1fX3VucmVuZGVyKHRoaXMpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUZyb21MaXZlUXVlcmllcyhlbGVtZW50KSB7XG4gIFx0dmFyIHF1ZXJ5LCBzZWxlY3RvciwgaTtcblxuICBcdGkgPSBlbGVtZW50LmxpdmVRdWVyaWVzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRxdWVyeSA9IGVsZW1lbnQubGl2ZVF1ZXJpZXNbaV07XG4gIFx0XHRzZWxlY3RvciA9IHF1ZXJ5LnNlbGVjdG9yO1xuXG4gIFx0XHRxdWVyeS5fcmVtb3ZlKGVsZW1lbnQubm9kZSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEVsZW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfTtcblxuICBFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IEVsZW1lbnRfcHJvdG90eXBlX2J1YmJsZSxcbiAgXHRkZXRhY2g6IEVsZW1lbnRfcHJvdG90eXBlX2RldGFjaCxcbiAgXHRmaW5kOiBFbGVtZW50X3Byb3RvdHlwZV9maW5kLFxuICBcdGZpbmRBbGw6IEVsZW1lbnRfcHJvdG90eXBlX2ZpbmRBbGwsXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IEVsZW1lbnRfcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzLFxuICBcdGZpbmRDb21wb25lbnQ6IEVsZW1lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQsXG4gIFx0ZmluZE5leHROb2RlOiBFbGVtZW50X3Byb3RvdHlwZV9maW5kTmV4dE5vZGUsXG4gIFx0Zmlyc3ROb2RlOiBFbGVtZW50X3Byb3RvdHlwZV9maXJzdE5vZGUsXG4gIFx0Z2V0QXR0cmlidXRlOiBnZXRBdHRyaWJ1dGUsXG4gIFx0aW5pdDogRWxlbWVudF9wcm90b3R5cGVfaW5pdCxcbiAgXHRyZWJpbmQ6IEVsZW1lbnRfcHJvdG90eXBlX3JlYmluZCxcbiAgXHRyZW5kZXI6IEVsZW1lbnRfcHJvdG90eXBlX3JlbmRlcixcbiAgXHR0b1N0cmluZzogRWxlbWVudF9wcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBFbGVtZW50X3Byb3RvdHlwZV91bmJpbmQsXG4gIFx0dW5yZW5kZXI6IEVsZW1lbnRfcHJvdG90eXBlX3VucmVuZGVyXG4gIH07XG5cbiAgdmFyIF9FbGVtZW50ID0gRWxlbWVudDtcblxuICB2YXIgZGVJbmRlbnRfX2VtcHR5ID0gL15cXHMqJC8sXG4gICAgICBkZUluZGVudF9fbGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccyovO1xuXG4gIHZhciBkZUluZGVudCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgXHR2YXIgbGluZXMsIGZpcnN0TGluZSwgbGFzdExpbmUsIG1pbkluZGVudDtcblxuICBcdGxpbmVzID0gc3RyLnNwbGl0KFwiXFxuXCIpO1xuXG4gIFx0Ly8gcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IGxpbmUsIGlmIHRoZXkgb25seSBjb250YWluIHdoaXRlc3BhY2VcbiAgXHRmaXJzdExpbmUgPSBsaW5lc1swXTtcbiAgXHRpZiAoZmlyc3RMaW5lICE9PSB1bmRlZmluZWQgJiYgZGVJbmRlbnRfX2VtcHR5LnRlc3QoZmlyc3RMaW5lKSkge1xuICBcdFx0bGluZXMuc2hpZnQoKTtcbiAgXHR9XG5cbiAgXHRsYXN0TGluZSA9IGxhc3RJdGVtKGxpbmVzKTtcbiAgXHRpZiAobGFzdExpbmUgIT09IHVuZGVmaW5lZCAmJiBkZUluZGVudF9fZW1wdHkudGVzdChsYXN0TGluZSkpIHtcbiAgXHRcdGxpbmVzLnBvcCgpO1xuICBcdH1cblxuICBcdG1pbkluZGVudCA9IGxpbmVzLnJlZHVjZShyZWR1Y2VyLCBudWxsKTtcblxuICBcdGlmIChtaW5JbmRlbnQpIHtcbiAgXHRcdHN0ciA9IGxpbmVzLm1hcChmdW5jdGlvbiAobGluZSkge1xuICBcdFx0XHRyZXR1cm4gbGluZS5yZXBsYWNlKG1pbkluZGVudCwgXCJcIik7XG4gIFx0XHR9KS5qb2luKFwiXFxuXCIpO1xuICBcdH1cblxuICBcdHJldHVybiBzdHI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVkdWNlcihwcmV2aW91cywgbGluZSkge1xuICBcdHZhciBsaW5lSW5kZW50ID0gZGVJbmRlbnRfX2xlYWRpbmdXaGl0ZXNwYWNlLmV4ZWMobGluZSlbMF07XG5cbiAgXHRpZiAocHJldmlvdXMgPT09IG51bGwgfHwgbGluZUluZGVudC5sZW5ndGggPCBwcmV2aW91cy5sZW5ndGgpIHtcbiAgXHRcdHJldHVybiBsaW5lSW5kZW50O1xuICBcdH1cblxuICBcdHJldHVybiBwcmV2aW91cztcbiAgfVxuXG4gIHZhciBQYXJ0aWFsX2dldFBhcnRpYWxUZW1wbGF0ZSA9IGdldFBhcnRpYWxUZW1wbGF0ZTtcblxuICBmdW5jdGlvbiBnZXRQYXJ0aWFsVGVtcGxhdGUocmFjdGl2ZSwgbmFtZSwgcGFyZW50RnJhZ21lbnQpIHtcbiAgXHR2YXIgcGFydGlhbDtcblxuICBcdC8vIElmIHRoZSBwYXJ0aWFsIGluIGluc3RhbmNlIG9yIHZpZXcgaGVpcmFyY2h5IGluc3RhbmNlcywgZ3JlYXRcbiAgXHRpZiAocGFydGlhbCA9IGdldFBhcnRpYWxGcm9tUmVnaXN0cnkocmFjdGl2ZSwgbmFtZSwgcGFyZW50RnJhZ21lbnQgfHwge30pKSB7XG4gIFx0XHRyZXR1cm4gcGFydGlhbDtcbiAgXHR9XG5cbiAgXHQvLyBEb2VzIGl0IGV4aXN0IG9uIHRoZSBwYWdlIGFzIGEgc2NyaXB0IHRhZz9cbiAgXHRwYXJ0aWFsID0gdGVtcGxhdGVfcGFyc2VyLmZyb21JZChuYW1lLCB7IG5vVGhyb3c6IHRydWUgfSk7XG5cbiAgXHRpZiAocGFydGlhbCkge1xuICBcdFx0Ly8gaXMgdGhpcyBuZWNlc3Nhcnk/XG4gIFx0XHRwYXJ0aWFsID0gZGVJbmRlbnQocGFydGlhbCk7XG5cbiAgXHRcdC8vIHBhcnNlIGFuZCByZWdpc3RlciB0byB0aGlzIHJhY3RpdmUgaW5zdGFuY2VcbiAgXHRcdHZhciBwYXJzZWQgPSB0ZW1wbGF0ZV9wYXJzZXIucGFyc2UocGFydGlhbCwgdGVtcGxhdGVfcGFyc2VyLmdldFBhcnNlT3B0aW9ucyhyYWN0aXZlKSk7XG5cbiAgXHRcdC8vIHJlZ2lzdGVyIChhbmQgcmV0dXJuIG1haW4gcGFydGlhbCBpZiB0aGVyZSBhcmUgb3RoZXJzIGluIHRoZSB0ZW1wbGF0ZSlcbiAgXHRcdHJldHVybiByYWN0aXZlLnBhcnRpYWxzW25hbWVdID0gcGFyc2VkLnQ7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFydGlhbEZyb21SZWdpc3RyeShyYWN0aXZlLCBuYW1lLCBwYXJlbnRGcmFnbWVudCkge1xuICBcdHZhciBmbiA9IHVuZGVmaW5lZCxcbiAgXHQgICAgcGFydGlhbCA9IGZpbmRQYXJlbnRQYXJ0aWFsKG5hbWUsIHBhcmVudEZyYWdtZW50Lm93bmVyKTtcblxuICBcdC8vIGlmIHRoZXJlIHdhcyBhbiBpbnN0YW5jZSB1cC1oaWVyYXJjaHksIGNvb2xcbiAgXHRpZiAocGFydGlhbCkgcmV0dXJuIHBhcnRpYWw7XG5cbiAgXHQvLyBmaW5kIGZpcnN0IGluc3RhbmNlIGluIHRoZSByYWN0aXZlIG9yIHZpZXcgaGllcmFyY2h5IHRoYXQgaGFzIHRoaXMgcGFydGlhbFxuICBcdHZhciBpbnN0YW5jZSA9IGZpbmRJbnN0YW5jZShcInBhcnRpYWxzXCIsIHJhY3RpdmUsIG5hbWUpO1xuXG4gIFx0aWYgKCFpbnN0YW5jZSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHBhcnRpYWwgPSBpbnN0YW5jZS5wYXJ0aWFsc1tuYW1lXTtcblxuICBcdC8vIHBhcnRpYWwgaXMgYSBmdW5jdGlvbj9cbiAgXHRpZiAodHlwZW9mIHBhcnRpYWwgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0Zm4gPSBwYXJ0aWFsLmJpbmQoaW5zdGFuY2UpO1xuICBcdFx0Zm4uaXNPd25lciA9IGluc3RhbmNlLnBhcnRpYWxzLmhhc093blByb3BlcnR5KG5hbWUpO1xuICBcdFx0cGFydGlhbCA9IGZuLmNhbGwocmFjdGl2ZSwgdGVtcGxhdGVfcGFyc2VyKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnRpYWwgJiYgcGFydGlhbCAhPT0gXCJcIikge1xuICBcdFx0d2FybklmRGVidWcobm9SZWdpc3RyeUZ1bmN0aW9uUmV0dXJuLCBuYW1lLCBcInBhcnRpYWxcIiwgXCJwYXJ0aWFsXCIsIHsgcmFjdGl2ZTogcmFjdGl2ZSB9KTtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGlzIHdhcyBhZGRlZCBtYW51YWxseSB0byB0aGUgcmVnaXN0cnksXG4gIFx0Ly8gYnV0IGhhc24ndCBiZWVuIHBhcnNlZCwgcGFyc2UgaXQgbm93XG4gIFx0aWYgKCF0ZW1wbGF0ZV9wYXJzZXIuaXNQYXJzZWQocGFydGlhbCkpIHtcblxuICBcdFx0Ly8gdXNlIHRoZSBwYXJzZU9wdGlvbnMgb2YgdGhlIHJhY3RpdmUgaW5zdGFuY2Ugb24gd2hpY2ggaXQgd2FzIGZvdW5kXG4gIFx0XHR2YXIgcGFyc2VkID0gdGVtcGxhdGVfcGFyc2VyLnBhcnNlKHBhcnRpYWwsIHRlbXBsYXRlX3BhcnNlci5nZXRQYXJzZU9wdGlvbnMoaW5zdGFuY2UpKTtcblxuICBcdFx0Ly8gUGFydGlhbHMgY2Fubm90IGNvbnRhaW4gbmVzdGVkIHBhcnRpYWxzIVxuICBcdFx0Ly8gVE9ETyBhZGQgYSB0ZXN0IGZvciB0aGlzXG4gIFx0XHRpZiAocGFyc2VkLnApIHtcbiAgXHRcdFx0d2FybklmRGVidWcoXCJQYXJ0aWFscyAoe3s+JXN9fSkgY2Fubm90IGNvbnRhaW4gbmVzdGVkIGlubGluZSBwYXJ0aWFsc1wiLCBuYW1lLCB7IHJhY3RpdmU6IHJhY3RpdmUgfSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlmIGZuLCB1c2UgaW5zdGFuY2UgdG8gc3RvcmUgcmVzdWx0LCBvdGhlcndpc2UgbmVlZHMgdG8gZ29cbiAgXHRcdC8vIGluIHRoZSBjb3JyZWN0IHBvaW50IGluIHByb3RvdHlwZSBjaGFpbiBvbiBpbnN0YW5jZSBvciBjb25zdHJ1Y3RvclxuICBcdFx0dmFyIHRhcmdldCA9IGZuID8gaW5zdGFuY2UgOiBmaW5kT3duZXIoaW5zdGFuY2UsIG5hbWUpO1xuXG4gIFx0XHQvLyBtYXkgYmUgYSB0ZW1wbGF0ZSB3aXRoIHBhcnRpYWxzLCB3aGljaCBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgYW5kIG1haW4gdGVtcGxhdGUgZXh0cmFjdGVkXG4gIFx0XHR0YXJnZXQucGFydGlhbHNbbmFtZV0gPSBwYXJ0aWFsID0gcGFyc2VkLnQ7XG4gIFx0fVxuXG4gIFx0Ly8gc3RvcmUgZm9yIHJlc2V0XG4gIFx0aWYgKGZuKSB7XG4gIFx0XHRwYXJ0aWFsLl9mbiA9IGZuO1xuICBcdH1cblxuICBcdHJldHVybiBwYXJ0aWFsLnYgPyBwYXJ0aWFsLnQgOiBwYXJ0aWFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZE93bmVyKHJhY3RpdmUsIGtleSkge1xuICBcdHJldHVybiByYWN0aXZlLnBhcnRpYWxzLmhhc093blByb3BlcnR5KGtleSkgPyByYWN0aXZlIDogZmluZENvbnN0cnVjdG9yKHJhY3RpdmUuY29uc3RydWN0b3IsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQ29uc3RydWN0b3IoY29uc3RydWN0b3IsIGtleSkge1xuICBcdGlmICghY29uc3RydWN0b3IpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG4gIFx0cmV0dXJuIGNvbnN0cnVjdG9yLnBhcnRpYWxzLmhhc093blByb3BlcnR5KGtleSkgPyBjb25zdHJ1Y3RvciA6IGZpbmRDb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvci5fUGFyZW50LCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFBhcmVudFBhcnRpYWwobmFtZSwgcGFyZW50KSB7XG4gIFx0aWYgKHBhcmVudCkge1xuICBcdFx0aWYgKHBhcmVudC50ZW1wbGF0ZSAmJiBwYXJlbnQudGVtcGxhdGUucCAmJiBwYXJlbnQudGVtcGxhdGUucFtuYW1lXSkge1xuICBcdFx0XHRyZXR1cm4gcGFyZW50LnRlbXBsYXRlLnBbbmFtZV07XG4gIFx0XHR9IGVsc2UgaWYgKHBhcmVudC5wYXJlbnRGcmFnbWVudCAmJiBwYXJlbnQucGFyZW50RnJhZ21lbnQub3duZXIpIHtcbiAgXHRcdFx0cmV0dXJuIGZpbmRQYXJlbnRQYXJ0aWFsKG5hbWUsIHBhcmVudC5wYXJlbnRGcmFnbWVudC5vd25lcik7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIGFwcGx5SW5kZW50ID0gZnVuY3Rpb24gKHN0cmluZywgaW5kZW50KSB7XG4gIFx0dmFyIGluZGVudGVkO1xuXG4gIFx0aWYgKCFpbmRlbnQpIHtcbiAgXHRcdHJldHVybiBzdHJpbmc7XG4gIFx0fVxuXG4gIFx0aW5kZW50ZWQgPSBzdHJpbmcuc3BsaXQoXCJcXG5cIikubWFwKGZ1bmN0aW9uIChsaW5lLCBub3RGaXJzdExpbmUpIHtcbiAgXHRcdHJldHVybiBub3RGaXJzdExpbmUgPyBpbmRlbnQgKyBsaW5lIDogbGluZTtcbiAgXHR9KS5qb2luKFwiXFxuXCIpO1xuXG4gIFx0cmV0dXJuIGluZGVudGVkO1xuICB9O1xuXG4gIHZhciBtaXNzaW5nUGFydGlhbE1lc3NhZ2UgPSBcIkNvdWxkIG5vdCBmaW5kIHRlbXBsYXRlIGZvciBwYXJ0aWFsIFxcXCIlc1xcXCJcIjtcblxuICB2YXIgUGFydGlhbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dmFyIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZTtcblxuICBcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHR0aGlzLnJvb3QgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuICBcdHRoaXMudHlwZSA9IFBBUlRJQUw7XG4gIFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG4gIFx0dGhpcy5uYW1lID0gb3B0aW9ucy50ZW1wbGF0ZS5yO1xuICBcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcblxuICBcdHRoaXMuZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50VG9SZW5kZXIgPSB0aGlzLmZyYWdtZW50VG9VbnJlbmRlciA9IG51bGw7XG5cbiAgXHRNdXN0YWNoZS5pbml0KHRoaXMsIG9wdGlvbnMpO1xuXG4gIFx0Ly8gSWYgdGhpcyBkaWRuJ3QgcmVzb2x2ZSwgaXQgbW9zdCBsaWtlbHkgbWVhbnMgd2UgaGF2ZSBhIG5hbWVkIHBhcnRpYWxcbiAgXHQvLyAoaS5lLiBge3s+Zm9vfX1gIG1lYW5zICd1c2UgdGhlIGZvbyBwYXJ0aWFsJywgbm90ICd1c2UgdGhlIHBhcnRpYWxcbiAgXHQvLyB3aG9zZSBuYW1lIGlzIHRoZSB2YWx1ZSBvZiBgZm9vYCcpXG4gIFx0aWYgKCF0aGlzLmtleXBhdGgpIHtcbiAgXHRcdGlmICh0ZW1wbGF0ZSA9IFBhcnRpYWxfZ2V0UGFydGlhbFRlbXBsYXRlKHRoaXMucm9vdCwgdGhpcy5uYW1lLCBwYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdFx0c2hhcmVkX3VuYmluZC5jYWxsKHRoaXMpOyAvLyBwcmV2ZW50IGFueSBmdXJ0aGVyIGNoYW5nZXNcbiAgXHRcdFx0dGhpcy5pc05hbWVkID0gdHJ1ZTtcbiAgXHRcdFx0dGhpcy5zZXRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3YXJuT25jZUlmRGVidWcobWlzc2luZ1BhcnRpYWxNZXNzYWdlLCB0aGlzLm5hbWUpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICBQYXJ0aWFsLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG4gIFx0fSxcblxuICBcdGRldGFjaDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIFx0fSxcblxuICBcdGZpbmQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZChzZWxlY3Rvcik7XG4gIFx0fSxcblxuICBcdGZpbmRBbGw6IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9LFxuXG4gIFx0ZmluZENvbXBvbmVudDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KHNlbGVjdG9yKTtcbiAgXHR9LFxuXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fSxcblxuICBcdGZpcnN0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG4gIFx0fSxcblxuICBcdGZpbmROZXh0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRnZXRQYXJ0aWFsTmFtZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuaXNOYW1lZCAmJiB0aGlzLm5hbWUpIHJldHVybiB0aGlzLm5hbWU7ZWxzZSBpZiAodGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5uYW1lO2Vsc2UgcmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHQvLyBuYW1lZCBwYXJ0aWFscyBhcmVuJ3QgYm91bmQsIHNvIGRvbid0IHJlYmluZFxuICBcdFx0aWYgKCF0aGlzLmlzTmFtZWQpIHtcbiAgXHRcdFx0TXVzdGFjaGVfcmViaW5kLmNhbGwodGhpcywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgXHRcdHRoaXMudXBkYXRlKCk7XG5cbiAgXHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcbiAgXHR9LFxuXG4gIFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcblxuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdHZhciB0ZW1wbGF0ZTtcblxuICBcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPT09IHRoaXMudmFsdWUpIHtcbiAgXHRcdFx0Ly8gbm90aGluZyBoYXMgY2hhbmdlZCwgc28gbm8gd29yayB0byBiZSBkb25lXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGVtcGxhdGUgPSBQYXJ0aWFsX2dldFBhcnRpYWxUZW1wbGF0ZSh0aGlzLnJvb3QsIFwiXCIgKyB2YWx1ZSwgdGhpcy5wYXJlbnRGcmFnbWVudCk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHdlIG1heSBiZSBoZXJlIGlmIHdlIGhhdmUgYSBwYXJ0aWFsIGxpa2UgYHt7PmZvb319YCBhbmQgYGZvb2AgaXMgdGhlXG4gIFx0XHQvLyBuYW1lIG9mIGJvdGggYSBkYXRhIHByb3BlcnR5ICh3aG9zZSB2YWx1ZSBJU04nVCB0aGUgbmFtZSBvZiBhIHBhcnRpYWwpXG4gIFx0XHQvLyBhbmQgYSBwYXJ0aWFsLiBJbiB0aG9zZSBjYXNlcywgdGhpcyBiZWNvbWVzIGEgbmFtZWQgcGFydGlhbFxuICBcdFx0aWYgKCF0ZW1wbGF0ZSAmJiB0aGlzLm5hbWUgJiYgKHRlbXBsYXRlID0gUGFydGlhbF9nZXRQYXJ0aWFsVGVtcGxhdGUodGhpcy5yb290LCB0aGlzLm5hbWUsIHRoaXMucGFyZW50RnJhZ21lbnQpKSkge1xuICBcdFx0XHRzaGFyZWRfdW5iaW5kLmNhbGwodGhpcyk7XG4gIFx0XHRcdHRoaXMuaXNOYW1lZCA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGVtcGxhdGUpIHtcbiAgXHRcdFx0d2Fybk9uY2VJZkRlYnVnKG1pc3NpbmdQYXJ0aWFsTWVzc2FnZSwgdGhpcy5uYW1lLCB7IHJhY3RpdmU6IHRoaXMucm9vdCB9KTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0XHR0aGlzLnNldFRlbXBsYXRlKHRlbXBsYXRlIHx8IFtdKTtcblxuICBcdFx0dGhpcy5idWJibGUoKTtcblxuICBcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0c2V0VGVtcGxhdGU6IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHRcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0XHR0aGlzLmZyYWdtZW50VG9VbnJlbmRlciA9IHRoaXMuZnJhZ21lbnQ7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuICBcdFx0XHRyb290OiB0aGlzLnJvb3QsXG4gIFx0XHRcdG93bmVyOiB0aGlzLFxuICBcdFx0XHRwRWxlbWVudDogdGhpcy5wYXJlbnRGcmFnbWVudC5wRWxlbWVudFxuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnRUb1JlbmRlciA9IHRoaXMuZnJhZ21lbnQ7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAodG9TdHJpbmcpIHtcbiAgXHRcdHZhciBzdHJpbmcsIHByZXZpb3VzSXRlbSwgbGFzdExpbmUsIG1hdGNoO1xuXG4gIFx0XHRzdHJpbmcgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKHRvU3RyaW5nKTtcblxuICBcdFx0cHJldmlvdXNJdGVtID0gdGhpcy5wYXJlbnRGcmFnbWVudC5pdGVtc1t0aGlzLmluZGV4IC0gMV07XG5cbiAgXHRcdGlmICghcHJldmlvdXNJdGVtIHx8IHByZXZpb3VzSXRlbS50eXBlICE9PSBURVhUKSB7XG4gIFx0XHRcdHJldHVybiBzdHJpbmc7XG4gIFx0XHR9XG5cbiAgXHRcdGxhc3RMaW5lID0gcHJldmlvdXNJdGVtLnRleHQuc3BsaXQoXCJcXG5cIikucG9wKCk7XG5cbiAgXHRcdGlmIChtYXRjaCA9IC9eXFxzKyQvLmV4ZWMobGFzdExpbmUpKSB7XG4gIFx0XHRcdHJldHVybiBhcHBseUluZGVudChzdHJpbmcsIG1hdGNoWzBdKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHN0cmluZztcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuaXNOYW1lZCkge1xuICBcdFx0XHQvLyBkeW5hbWljIHBhcnRpYWwgLSBuZWVkIHRvIHVuYmluZCBzZWxmXG4gIFx0XHRcdHNoYXJlZF91bmJpbmQuY2FsbCh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoc2hvdWxkRGVzdHJveSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB0YXJnZXQsIGFuY2hvcjtcblxuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyKSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyLnVucmVuZGVyKHRydWUpO1xuICBcdFx0XHR0aGlzLmZyYWdtZW50VG9VbnJlbmRlciA9IG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLmZyYWdtZW50VG9SZW5kZXIpIHtcbiAgXHRcdFx0dGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKHRoaXMuZnJhZ21lbnRUb1JlbmRlci5yZW5kZXIoKSk7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnRUb1JlbmRlciA9IG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdHRhcmdldCA9IHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpO1xuICBcdFx0XHRhbmNob3IgPSB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLmRvY0ZyYWcsIGFuY2hvcik7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBfUGFydGlhbCA9IFBhcnRpYWw7XG5cbiAgLy8gZmluZHMgdGhlIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBpbiB0aGUgcmVnaXN0cnkgb3IgdmlldyBoaWVyYXJjaHkgcmVnaXN0cmllc1xuXG4gIHZhciBDb21wb25lbnRfZ2V0Q29tcG9uZW50ID0gZ2V0Q29tcG9uZW50O1xuICBmdW5jdGlvbiBnZXRDb21wb25lbnQocmFjdGl2ZSwgbmFtZSkge1xuXG4gIFx0dmFyIENvbXBvbmVudCxcbiAgXHQgICAgaW5zdGFuY2UgPSBmaW5kSW5zdGFuY2UoXCJjb21wb25lbnRzXCIsIHJhY3RpdmUsIG5hbWUpO1xuXG4gIFx0aWYgKGluc3RhbmNlKSB7XG4gIFx0XHRDb21wb25lbnQgPSBpbnN0YW5jZS5jb21wb25lbnRzW25hbWVdO1xuXG4gIFx0XHQvLyBiZXN0IHRlc3Qgd2UgaGF2ZSBmb3Igbm90IFJhY3RpdmUuZXh0ZW5kXG4gIFx0XHRpZiAoIUNvbXBvbmVudC5fUGFyZW50KSB7XG4gIFx0XHRcdC8vIGZ1bmN0aW9uIG9wdGlvbiwgZXhlY3V0ZSBhbmQgc3RvcmUgZm9yIHJlc2V0XG4gIFx0XHRcdHZhciBmbiA9IENvbXBvbmVudC5iaW5kKGluc3RhbmNlKTtcbiAgXHRcdFx0Zm4uaXNPd25lciA9IGluc3RhbmNlLmNvbXBvbmVudHMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIFx0XHRcdENvbXBvbmVudCA9IGZuKCk7XG5cbiAgXHRcdFx0aWYgKCFDb21wb25lbnQpIHtcbiAgXHRcdFx0XHR3YXJuSWZEZWJ1Zyhub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm4sIG5hbWUsIFwiY29tcG9uZW50XCIsIFwiY29tcG9uZW50XCIsIHsgcmFjdGl2ZTogcmFjdGl2ZSB9KTtcblxuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICh0eXBlb2YgQ29tcG9uZW50ID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdFx0Ly8gYWxsb3cgc3RyaW5nIGxvb2t1cFxuICBcdFx0XHRcdENvbXBvbmVudCA9IGdldENvbXBvbmVudChyYWN0aXZlLCBDb21wb25lbnQpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Q29tcG9uZW50Ll9mbiA9IGZuO1xuICBcdFx0XHRpbnN0YW5jZS5jb21wb25lbnRzW25hbWVdID0gQ29tcG9uZW50O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBDb21wb25lbnQ7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9kZXRhY2ggPSBDb21wb25lbnQkZGV0YWNoO1xuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9kZXRhY2hfX2RldGFjaEhvb2sgPSBuZXcgaG9va3NfSG9vayhcImRldGFjaFwiKTtcbiAgZnVuY3Rpb24gQ29tcG9uZW50JGRldGFjaCgpIHtcbiAgXHR2YXIgZGV0YWNoZWQgPSB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmRldGFjaCgpO1xuICBcdENvbXBvbmVudF9wcm90b3R5cGVfZGV0YWNoX19kZXRhY2hIb29rLmZpcmUodGhpcy5pbnN0YW5jZSk7XG4gIFx0cmV0dXJuIGRldGFjaGVkO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZmluZCA9IENvbXBvbmVudCRmaW5kO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kKHNlbGVjdG9yKSB7XG4gIFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZChzZWxlY3Rvcik7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kQWxsID0gQ29tcG9uZW50JGZpbmRBbGw7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JGZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMgPSBDb21wb25lbnQkZmluZEFsbENvbXBvbmVudHM7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JGZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdHF1ZXJ5Ll90ZXN0KHRoaXMsIHRydWUpO1xuXG4gIFx0aWYgKHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kQ29tcG9uZW50ID0gQ29tcG9uZW50JGZpbmRDb21wb25lbnQ7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JGZpbmRDb21wb25lbnQoc2VsZWN0b3IpIHtcbiAgXHRpZiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSB0aGlzLm5hbWUpIHtcbiAgXHRcdHJldHVybiB0aGlzLmluc3RhbmNlO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmluc3RhbmNlLmZyYWdtZW50KSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQ29tcG9uZW50KHNlbGVjdG9yKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSA9IENvbXBvbmVudCRmaW5kTmV4dE5vZGU7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JGZpbmROZXh0Tm9kZSgpIHtcbiAgXHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9maXJzdE5vZGUgPSBDb21wb25lbnQkZmlyc3ROb2RlO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRmaXJzdE5vZGUoKSB7XG4gIFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHByb2Nlc3NXcmFwcGVyID0gZnVuY3Rpb24gKHdyYXBwZXIsIGFycmF5LCBtZXRob2ROYW1lLCBuZXdJbmRpY2VzKSB7XG4gIFx0dmFyIHJvb3QgPSB3cmFwcGVyLnJvb3Q7XG4gIFx0dmFyIGtleXBhdGggPSB3cmFwcGVyLmtleXBhdGg7XG5cbiAgXHRpZiAoISFuZXdJbmRpY2VzKSB7XG4gIFx0XHRyb290LnZpZXdtb2RlbC5zbWFydFVwZGF0ZShrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcyk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIElmIHRoaXMgaXMgYSBzb3J0IG9yIHJldmVyc2UsIHdlIGp1c3QgZG8gcm9vdC5zZXQoKS4uLlxuICBcdFx0Ly8gVE9ETyB1c2UgbWVyZ2UgbG9naWM/XG4gIFx0XHRyb290LnZpZXdtb2RlbC5tYXJrKGtleXBhdGgpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgcGF0Y2hlZEFycmF5UHJvdG8gPSBbXSxcbiAgICAgIG11dGF0b3JNZXRob2RzID0gW1wicG9wXCIsIFwicHVzaFwiLCBcInJldmVyc2VcIiwgXCJzaGlmdFwiLCBcInNvcnRcIiwgXCJzcGxpY2VcIiwgXCJ1bnNoaWZ0XCJdLFxuICAgICAgdGVzdE9iaixcbiAgICAgIHBhdGNoQXJyYXlNZXRob2RzLFxuICAgICAgdW5wYXRjaEFycmF5TWV0aG9kcztcblxuICBtdXRhdG9yTWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gIFx0dmFyIG1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRcdGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBuZXdJbmRpY2VzLCByZXN1bHQsIHdyYXBwZXIsIGk7XG5cbiAgXHRcdG5ld0luZGljZXMgPSBzaGFyZWRfZ2V0TmV3SW5kaWNlcyh0aGlzLCBtZXRob2ROYW1lLCBhcmdzKTtcblxuICBcdFx0Ly8gYXBwbHkgdGhlIHVuZGVybHlpbmcgbWV0aG9kXG4gIFx0XHRyZXN1bHQgPSBBcnJheS5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBcdFx0Ly8gdHJpZ2dlciBjaGFuZ2VzXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCgpO1xuXG4gIFx0XHR0aGlzLl9yYWN0aXZlLnNldHRpbmcgPSB0cnVlO1xuICBcdFx0aSA9IHRoaXMuX3JhY3RpdmUud3JhcHBlcnMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHR3cmFwcGVyID0gdGhpcy5fcmFjdGl2ZS53cmFwcGVyc1tpXTtcblxuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRSYWN0aXZlKHdyYXBwZXIucm9vdCk7XG4gIFx0XHRcdHByb2Nlc3NXcmFwcGVyKHdyYXBwZXIsIHRoaXMsIG1ldGhvZE5hbWUsIG5ld0luZGljZXMpO1xuICBcdFx0fVxuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdFx0dGhpcy5fcmFjdGl2ZS5zZXR0aW5nID0gZmFsc2U7XG4gIFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdH07XG5cbiAgXHRkZWZpbmVQcm9wZXJ0eShwYXRjaGVkQXJyYXlQcm90bywgbWV0aG9kTmFtZSwge1xuICBcdFx0dmFsdWU6IG1ldGhvZFxuICBcdH0pO1xuICB9KTtcblxuICAvLyBjYW4gd2UgdXNlIHByb3RvdHlwZSBjaGFpbiBpbmplY3Rpb24/XG4gIC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2hvdy1lY21hc2NyaXB0LTUtc3RpbGwtZG9lcy1ub3QtYWxsb3ctdG8tc3ViY2xhc3MtYW4tYXJyYXkvI3dyYXBwZXJzX3Byb3RvdHlwZV9jaGFpbl9pbmplY3Rpb25cbiAgdGVzdE9iaiA9IHt9O1xuXG4gIGlmICh0ZXN0T2JqLl9fcHJvdG9fXykge1xuICBcdC8vIHllcywgd2UgY2FuXG4gIFx0cGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgXHRcdGFycmF5Ll9fcHJvdG9fXyA9IHBhdGNoZWRBcnJheVByb3RvO1xuICBcdH07XG5cbiAgXHR1bnBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIFx0XHRhcnJheS5fX3Byb3RvX18gPSBBcnJheS5wcm90b3R5cGU7XG4gIFx0fTtcbiAgfSBlbHNlIHtcbiAgXHQvLyBubywgd2UgY2FuJ3RcbiAgXHRwYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uIChhcnJheSkge1xuICBcdFx0dmFyIGksIG1ldGhvZE5hbWU7XG5cbiAgXHRcdGkgPSBtdXRhdG9yTWV0aG9kcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdG1ldGhvZE5hbWUgPSBtdXRhdG9yTWV0aG9kc1tpXTtcbiAgXHRcdFx0ZGVmaW5lUHJvcGVydHkoYXJyYXksIG1ldGhvZE5hbWUsIHtcbiAgXHRcdFx0XHR2YWx1ZTogcGF0Y2hlZEFycmF5UHJvdG9bbWV0aG9kTmFtZV0sXG4gIFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHR1bnBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIFx0XHR2YXIgaTtcblxuICBcdFx0aSA9IG11dGF0b3JNZXRob2RzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0ZGVsZXRlIGFycmF5W211dGF0b3JNZXRob2RzW2ldXTtcbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgcGF0Y2hBcnJheU1ldGhvZHMudW5wYXRjaCA9IHVucGF0Y2hBcnJheU1ldGhvZHM7XG4gIHZhciBwYXRjaCA9IHBhdGNoQXJyYXlNZXRob2RzO1xuXG4gIHZhciBhcnJheUFkYXB0b3IsXG5cbiAgLy8gaGVscGVyc1xuICBBcnJheVdyYXBwZXIsIGFycmF5X2luZGV4X19lcnJvck1lc3NhZ2U7XG5cbiAgYXJyYXlBZGFwdG9yID0ge1xuICBcdGZpbHRlcjogZnVuY3Rpb24gKG9iamVjdCkge1xuICBcdFx0Ly8gd3JhcCB0aGUgYXJyYXkgaWYgYSkgYikgaXQncyBhbiBhcnJheSwgYW5kIGIpIGVpdGhlciBpdCBoYXNuJ3QgYmVlbiB3cmFwcGVkIGFscmVhZHksXG4gIFx0XHQvLyBvciB0aGUgYXJyYXkgZGlkbid0IHRyaWdnZXIgdGhlIGdldCgpIGl0c2VsZlxuICBcdFx0cmV0dXJuIGlzQXJyYXkob2JqZWN0KSAmJiAoIW9iamVjdC5fcmFjdGl2ZSB8fCAhb2JqZWN0Ll9yYWN0aXZlLnNldHRpbmcpO1xuICBcdH0sXG4gIFx0d3JhcDogZnVuY3Rpb24gKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKSB7XG4gIFx0XHRyZXR1cm4gbmV3IEFycmF5V3JhcHBlcihyYWN0aXZlLCBhcnJheSwga2V5cGF0aCk7XG4gIFx0fVxuICB9O1xuXG4gIEFycmF5V3JhcHBlciA9IGZ1bmN0aW9uIChyYWN0aXZlLCBhcnJheSwga2V5cGF0aCkge1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG4gIFx0dGhpcy52YWx1ZSA9IGFycmF5O1xuICBcdHRoaXMua2V5cGF0aCA9IGdldEtleXBhdGgoa2V5cGF0aCk7XG5cbiAgXHQvLyBpZiB0aGlzIGFycmF5IGhhc24ndCBhbHJlYWR5IGJlZW4gcmFjdGlmaWVkLCByYWN0aWZ5IGl0XG4gIFx0aWYgKCFhcnJheS5fcmFjdGl2ZSkge1xuXG4gIFx0XHQvLyBkZWZpbmUgYSBub24tZW51bWVyYWJsZSBfcmFjdGl2ZSBwcm9wZXJ0eSB0byBzdG9yZSB0aGUgd3JhcHBlcnNcbiAgXHRcdGRlZmluZVByb3BlcnR5KGFycmF5LCBcIl9yYWN0aXZlXCIsIHtcbiAgXHRcdFx0dmFsdWU6IHtcbiAgXHRcdFx0XHR3cmFwcGVyczogW10sXG4gIFx0XHRcdFx0aW5zdGFuY2VzOiBbXSxcbiAgXHRcdFx0XHRzZXR0aW5nOiBmYWxzZVxuICBcdFx0XHR9LFxuICBcdFx0XHRjb25maWd1cmFibGU6IHRydWVcbiAgXHRcdH0pO1xuXG4gIFx0XHRwYXRjaChhcnJheSk7XG4gIFx0fVxuXG4gIFx0Ly8gc3RvcmUgdGhlIHJhY3RpdmUgaW5zdGFuY2UsIHNvIHdlIGNhbiBoYW5kbGUgdHJhbnNpdGlvbnMgbGF0ZXJcbiAgXHRpZiAoIWFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1tyYWN0aXZlLl9ndWlkXSkge1xuICBcdFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzW3JhY3RpdmUuX2d1aWRdID0gMDtcbiAgXHRcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlcy5wdXNoKHJhY3RpdmUpO1xuICBcdH1cblxuICBcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1tyYWN0aXZlLl9ndWlkXSArPSAxO1xuICBcdGFycmF5Ll9yYWN0aXZlLndyYXBwZXJzLnB1c2godGhpcyk7XG4gIH07XG5cbiAgQXJyYXlXcmFwcGVyLnByb3RvdHlwZSA9IHtcbiAgXHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLnZhbHVlO1xuICBcdH0sXG4gIFx0dGVhcmRvd246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBhcnJheSwgc3RvcmFnZSwgd3JhcHBlcnMsIGluc3RhbmNlcywgaW5kZXg7XG5cbiAgXHRcdGFycmF5ID0gdGhpcy52YWx1ZTtcbiAgXHRcdHN0b3JhZ2UgPSBhcnJheS5fcmFjdGl2ZTtcbiAgXHRcdHdyYXBwZXJzID0gc3RvcmFnZS53cmFwcGVycztcbiAgXHRcdGluc3RhbmNlcyA9IHN0b3JhZ2UuaW5zdGFuY2VzO1xuXG4gIFx0XHQvLyBpZiB0ZWFyZG93bigpIHdhcyBpbnZva2VkIGJlY2F1c2Ugd2UncmUgY2xlYXJpbmcgdGhlIGNhY2hlIGFzIGEgcmVzdWx0IG9mXG4gIFx0XHQvLyBhIGNoYW5nZSB0aGF0IHRoZSBhcnJheSBpdHNlbGYgdHJpZ2dlcmVkLCB3ZSBjYW4gc2F2ZSBvdXJzZWx2ZXMgdGhlIHRlYXJkb3duXG4gIFx0XHQvLyBhbmQgaW1tZWRpYXRlIHNldHVwXG4gIFx0XHRpZiAoc3RvcmFnZS5zZXR0aW5nKSB7XG4gIFx0XHRcdHJldHVybiBmYWxzZTsgLy8gc28gdGhhdCB3ZSBkb24ndCByZW1vdmUgaXQgZnJvbSB0aGlzLnJvb3Qudmlld21vZGVsLndyYXBwZWRcbiAgXHRcdH1cblxuICBcdFx0aW5kZXggPSB3cmFwcGVycy5pbmRleE9mKHRoaXMpO1xuICBcdFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYXJyYXlfaW5kZXhfX2Vycm9yTWVzc2FnZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHdyYXBwZXJzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgXHRcdC8vIGlmIG5vdGhpbmcgZWxzZSBkZXBlbmRzIG9uIHRoaXMgYXJyYXksIHdlIGNhbiByZXZlcnQgaXQgdG8gaXRzXG4gIFx0XHQvLyBuYXR1cmFsIHN0YXRlXG4gIFx0XHRpZiAoIXdyYXBwZXJzLmxlbmd0aCkge1xuICBcdFx0XHRkZWxldGUgYXJyYXkuX3JhY3RpdmU7XG4gIFx0XHRcdHBhdGNoLnVucGF0Y2godGhpcy52YWx1ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHQvLyByZW1vdmUgcmFjdGl2ZSBpbnN0YW5jZSBpZiBwb3NzaWJsZVxuICBcdFx0XHRpbnN0YW5jZXNbdGhpcy5yb290Ll9ndWlkXSAtPSAxO1xuICBcdFx0XHRpZiAoIWluc3RhbmNlc1t0aGlzLnJvb3QuX2d1aWRdKSB7XG4gIFx0XHRcdFx0aW5kZXggPSBpbnN0YW5jZXMuaW5kZXhPZih0aGlzLnJvb3QpO1xuXG4gIFx0XHRcdFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGFycmF5X2luZGV4X19lcnJvck1lc3NhZ2UpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIGFycmF5X2luZGV4X19lcnJvck1lc3NhZ2UgPSBcIlNvbWV0aGluZyB3ZW50IHdyb25nIGluIGEgcmF0aGVyIGludGVyZXN0aW5nIHdheVwiO1xuICB2YXIgYXJyYXlfaW5kZXggPSBhcnJheUFkYXB0b3I7XG5cbiAgdmFyIG51bWVyaWMgPSAvXlxccypbMC05XStcXHMqJC87XG5cbiAgdmFyIGNyZWF0ZUJyYW5jaCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRyZXR1cm4gbnVtZXJpYy50ZXN0KGtleSkgPyBbXSA6IHt9O1xuICB9O1xuXG4gIHZhciBtYWdpY0FkYXB0b3IsIE1hZ2ljV3JhcHBlcjtcblxuICB0cnkge1xuICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJ0ZXN0XCIsIHsgdmFsdWU6IDAgfSk7XG5cbiAgXHRtYWdpY0FkYXB0b3IgPSB7XG4gIFx0XHRmaWx0ZXI6IGZ1bmN0aW9uIChvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUpIHtcbiAgXHRcdFx0dmFyIHBhcmVudFdyYXBwZXIsIHBhcmVudFZhbHVlO1xuXG4gIFx0XHRcdGlmICgha2V5cGF0aCkge1xuICBcdFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGtleXBhdGggPSBnZXRLZXlwYXRoKGtleXBhdGgpO1xuXG4gIFx0XHRcdC8vIElmIHRoZSBwYXJlbnQgdmFsdWUgaXMgYSB3cmFwcGVyLCBvdGhlciB0aGFuIGEgbWFnaWMgd3JhcHBlcixcbiAgXHRcdFx0Ly8gd2Ugc2hvdWxkbid0IHdyYXAgdGhpcyBwcm9wZXJ0eVxuICBcdFx0XHRpZiAoKHBhcmVudFdyYXBwZXIgPSByYWN0aXZlLnZpZXdtb2RlbC53cmFwcGVkW2tleXBhdGgucGFyZW50LnN0cl0pICYmICFwYXJlbnRXcmFwcGVyLm1hZ2ljKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cGFyZW50VmFsdWUgPSByYWN0aXZlLnZpZXdtb2RlbC5nZXQoa2V5cGF0aC5wYXJlbnQpO1xuXG4gIFx0XHRcdC8vIGlmIHBhcmVudFZhbHVlIGlzIGFuIGFycmF5IHRoYXQgZG9lc24ndCBpbmNsdWRlIHRoaXMgbWVtYmVyLFxuICBcdFx0XHQvLyB3ZSBzaG91bGQgcmV0dXJuIGZhbHNlIG90aGVyd2lzZSBsZW5ndGhzIHdpbGwgZ2V0IG1lc3NlZCB1cFxuICBcdFx0XHRpZiAoaXNBcnJheShwYXJlbnRWYWx1ZSkgJiYgL15bMC05XSskLy50ZXN0KGtleXBhdGgubGFzdEtleSkpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gcGFyZW50VmFsdWUgJiYgKHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcGFyZW50VmFsdWUgPT09IFwiZnVuY3Rpb25cIik7XG4gIFx0XHR9LFxuICBcdFx0d3JhcDogZnVuY3Rpb24gKHJhY3RpdmUsIHByb3BlcnR5LCBrZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBuZXcgTWFnaWNXcmFwcGVyKHJhY3RpdmUsIHByb3BlcnR5LCBrZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0TWFnaWNXcmFwcGVyID0gZnVuY3Rpb24gKHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoKSB7XG4gIFx0XHR2YXIgb2JqS2V5cGF0aCwgdGVtcGxhdGUsIHNpYmxpbmdzO1xuXG4gIFx0XHRrZXlwYXRoID0gZ2V0S2V5cGF0aChrZXlwYXRoKTtcblxuICBcdFx0dGhpcy5tYWdpYyA9IHRydWU7XG5cbiAgXHRcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG4gIFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0XHR0aGlzLnByb3AgPSBrZXlwYXRoLmxhc3RLZXk7XG5cbiAgXHRcdG9iaktleXBhdGggPSBrZXlwYXRoLnBhcmVudDtcbiAgXHRcdHRoaXMub2JqID0gb2JqS2V5cGF0aC5pc1Jvb3QgPyByYWN0aXZlLnZpZXdtb2RlbC5kYXRhIDogcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KG9iaktleXBhdGgpO1xuXG4gIFx0XHR0ZW1wbGF0ZSA9IHRoaXMub3JpZ2luYWxEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLm9iaiwgdGhpcy5wcm9wKTtcblxuICBcdFx0Ly8gSGFzIHRoaXMgcHJvcGVydHkgYWxyZWFkeSBiZWVuIHdyYXBwZWQ/XG4gIFx0XHRpZiAodGVtcGxhdGUgJiYgdGVtcGxhdGUuc2V0ICYmIChzaWJsaW5ncyA9IHRlbXBsYXRlLnNldC5fcmFjdGl2ZVdyYXBwZXJzKSkge1xuXG4gIFx0XHRcdC8vIFllcy4gUmVnaXN0ZXIgdGhpcyB3cmFwcGVyIHRvIHRoaXMgcHJvcGVydHksIGlmIGl0IGhhc24ndCBiZWVuIGFscmVhZHlcbiAgXHRcdFx0aWYgKHNpYmxpbmdzLmluZGV4T2YodGhpcykgPT09IC0xKSB7XG4gIFx0XHRcdFx0c2libGluZ3MucHVzaCh0aGlzKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybjsgLy8gYWxyZWFkeSB3cmFwcGVkXG4gIFx0XHR9XG5cbiAgXHRcdC8vIE5vLCBpdCBoYXNuJ3QgYmVlbiB3cmFwcGVkXG4gIFx0XHRjcmVhdGVBY2Nlc3NvcnModGhpcywgdmFsdWUsIHRlbXBsYXRlKTtcbiAgXHR9O1xuXG4gIFx0TWFnaWNXcmFwcGVyLnByb3RvdHlwZSA9IHtcbiAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHRcdH0sXG4gIFx0XHRyZXNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRcdGlmICh0aGlzLnVwZGF0aW5nKSB7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG4gIFx0XHRcdHRoaXMub2JqW3RoaXMucHJvcF0gPSB2YWx1ZTsgLy8gdHJpZ2dlciBzZXQoKSBhY2Nlc3NvclxuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRSYWN0aXZlKHRoaXMucmFjdGl2ZSk7XG4gIFx0XHRcdHRoaXMucmFjdGl2ZS52aWV3bW9kZWwubWFyayh0aGlzLmtleXBhdGgsIHsga2VlcEV4aXN0aW5nV3JhcHBlcjogdHJ1ZSB9KTtcbiAgXHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH0sXG4gIFx0XHRzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIFx0XHRcdGlmICh0aGlzLnVwZGF0aW5nKSB7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCF0aGlzLm9ialt0aGlzLnByb3BdKSB7XG4gIFx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG4gIFx0XHRcdFx0dGhpcy5vYmpbdGhpcy5wcm9wXSA9IGNyZWF0ZUJyYW5jaChrZXkpO1xuICBcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMub2JqW3RoaXMucHJvcF1ba2V5XSA9IHZhbHVlO1xuICBcdFx0fSxcbiAgXHRcdHRlYXJkb3duOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHZhciB0ZW1wbGF0ZSwgc2V0LCB2YWx1ZSwgd3JhcHBlcnMsIGluZGV4O1xuXG4gIFx0XHRcdC8vIElmIHRoaXMgbWV0aG9kIHdhcyBjYWxsZWQgYmVjYXVzZSB0aGUgY2FjaGUgd2FzIGJlaW5nIGNsZWFyZWQgYXMgYVxuICBcdFx0XHQvLyByZXN1bHQgb2YgYSBzZXQoKS91cGRhdGUoKSBjYWxsIG1hZGUgYnkgdGhpcyB3cmFwcGVyLCB3ZSByZXR1cm4gZmFsc2VcbiAgXHRcdFx0Ly8gc28gdGhhdCBpdCBkb2Vzbid0IGdldCB0b3JuIGRvd25cbiAgXHRcdFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0ZW1wbGF0ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcy5vYmosIHRoaXMucHJvcCk7XG4gIFx0XHRcdHNldCA9IHRlbXBsYXRlICYmIHRlbXBsYXRlLnNldDtcblxuICBcdFx0XHRpZiAoIXNldCkge1xuICBcdFx0XHRcdC8vIG1vc3QgbGlrZWx5LCB0aGlzIHdhcyBhbiBhcnJheSBtZW1iZXIgdGhhdCB3YXMgc3BsaWNlZCBvdXRcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHR3cmFwcGVycyA9IHNldC5fcmFjdGl2ZVdyYXBwZXJzO1xuXG4gIFx0XHRcdGluZGV4ID0gd3JhcHBlcnMuaW5kZXhPZih0aGlzKTtcbiAgXHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0XHRcdHdyYXBwZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBMYXN0IG9uZSBvdXQsIHR1cm4gb2ZmIHRoZSBsaWdodHNcbiAgXHRcdFx0aWYgKCF3cmFwcGVycy5sZW5ndGgpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IHRoaXMub2JqW3RoaXMucHJvcF07XG5cbiAgXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5vYmosIHRoaXMucHJvcCwgdGhpcy5vcmlnaW5hbERlc2NyaXB0b3IgfHwge1xuICBcdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG4gIFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuICBcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG4gIFx0XHRcdFx0fSk7XG5cbiAgXHRcdFx0XHR0aGlzLm9ialt0aGlzLnByb3BdID0gdmFsdWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgXHRtYWdpY0FkYXB0b3IgPSBmYWxzZTsgLy8gbm8gbWFnaWMgaW4gdGhpcyBicm93c2VyXG4gIH1cblxuICB2YXIgYWRhcHRvcnNfbWFnaWMgPSBtYWdpY0FkYXB0b3I7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQWNjZXNzb3JzKG9yaWdpbmFsV3JhcHBlciwgdmFsdWUsIHRlbXBsYXRlKSB7XG5cbiAgXHR2YXIgb2JqZWN0LCBwcm9wZXJ0eSwgb2xkR2V0LCBvbGRTZXQsIGdldCwgc2V0O1xuXG4gIFx0b2JqZWN0ID0gb3JpZ2luYWxXcmFwcGVyLm9iajtcbiAgXHRwcm9wZXJ0eSA9IG9yaWdpbmFsV3JhcHBlci5wcm9wO1xuXG4gIFx0Ly8gSXMgdGhpcyB0ZW1wbGF0ZSBjb25maWd1cmFibGU/XG4gIFx0aWYgKHRlbXBsYXRlICYmICF0ZW1wbGF0ZS5jb25maWd1cmFibGUpIHtcbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSAtIGFycmF5IGxlbmd0aFxuICBcdFx0aWYgKHByb3BlcnR5ID09PSBcImxlbmd0aFwiKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBtYWdpYyBtb2RlIHdpdGggcHJvcGVydHkgXFxcIlwiICsgcHJvcGVydHkgKyBcIlxcXCIgLSBvYmplY3QgaXMgbm90IGNvbmZpZ3VyYWJsZVwiKTtcbiAgXHR9XG5cbiAgXHQvLyBUaW1lIHRvIHdyYXAgdGhpcyBwcm9wZXJ0eVxuICBcdGlmICh0ZW1wbGF0ZSkge1xuICBcdFx0b2xkR2V0ID0gdGVtcGxhdGUuZ2V0O1xuICBcdFx0b2xkU2V0ID0gdGVtcGxhdGUuc2V0O1xuICBcdH1cblxuICBcdGdldCA9IG9sZEdldCB8fCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0fTtcblxuICBcdHNldCA9IGZ1bmN0aW9uICh2KSB7XG4gIFx0XHRpZiAob2xkU2V0KSB7XG4gIFx0XHRcdG9sZFNldCh2KTtcbiAgXHRcdH1cblxuICBcdFx0dmFsdWUgPSBvbGRHZXQgPyBvbGRHZXQoKSA6IHY7XG4gIFx0XHRzZXQuX3JhY3RpdmVXcmFwcGVycy5mb3JFYWNoKHVwZGF0ZVdyYXBwZXIpO1xuICBcdH07XG5cbiAgXHRmdW5jdGlvbiB1cGRhdGVXcmFwcGVyKHdyYXBwZXIpIHtcbiAgXHRcdHZhciBrZXlwYXRoLCByYWN0aXZlO1xuXG4gIFx0XHR3cmFwcGVyLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdGlmICh3cmFwcGVyLnVwZGF0aW5nKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0cmFjdGl2ZSA9IHdyYXBwZXIucmFjdGl2ZTtcbiAgXHRcdGtleXBhdGggPSB3cmFwcGVyLmtleXBhdGg7XG5cbiAgXHRcdHdyYXBwZXIudXBkYXRpbmcgPSB0cnVlO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQocmFjdGl2ZSk7XG5cbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLm1hcmsoa2V5cGF0aCk7XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdFx0d3JhcHBlci51cGRhdGluZyA9IGZhbHNlO1xuICBcdH1cblxuICBcdC8vIENyZWF0ZSBhbiBhcnJheSBvZiB3cmFwcGVycywgaW4gY2FzZSBvdGhlciBrZXlwYXRocy9yYWN0aXZlcyBkZXBlbmQgb24gdGhpcyBwcm9wZXJ0eS5cbiAgXHQvLyBIYW5kaWx5LCB3ZSBjYW4gc3RvcmUgdGhlbSBhcyBhIHByb3BlcnR5IG9mIHRoZSBzZXQgZnVuY3Rpb24uIFlheSBKYXZhU2NyaXB0LlxuICBcdHNldC5fcmFjdGl2ZVdyYXBwZXJzID0gW29yaWdpbmFsV3JhcHBlcl07XG4gIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHsgZ2V0OiBnZXQsIHNldDogc2V0LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH1cblxuICB2YXIgbWFnaWNBcnJheUFkYXB0b3IsIE1hZ2ljQXJyYXlXcmFwcGVyO1xuXG4gIGlmIChhZGFwdG9yc19tYWdpYykge1xuICBcdG1hZ2ljQXJyYXlBZGFwdG9yID0ge1xuICBcdFx0ZmlsdGVyOiBmdW5jdGlvbiAob2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlKSB7XG4gIFx0XHRcdHJldHVybiBhZGFwdG9yc19tYWdpYy5maWx0ZXIob2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlKSAmJiBhcnJheV9pbmRleC5maWx0ZXIob2JqZWN0KTtcbiAgXHRcdH0sXG5cbiAgXHRcdHdyYXA6IGZ1bmN0aW9uIChyYWN0aXZlLCBhcnJheSwga2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gbmV3IE1hZ2ljQXJyYXlXcmFwcGVyKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0TWFnaWNBcnJheVdyYXBwZXIgPSBmdW5jdGlvbiAocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpIHtcbiAgXHRcdHRoaXMudmFsdWUgPSBhcnJheTtcblxuICBcdFx0dGhpcy5tYWdpYyA9IHRydWU7XG5cbiAgXHRcdHRoaXMubWFnaWNXcmFwcGVyID0gYWRhcHRvcnNfbWFnaWMud3JhcChyYWN0aXZlLCBhcnJheSwga2V5cGF0aCk7XG4gIFx0XHR0aGlzLmFycmF5V3JhcHBlciA9IGFycmF5X2luZGV4LndyYXAocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpO1xuICBcdH07XG5cbiAgXHRNYWdpY0FycmF5V3JhcHBlci5wcm90b3R5cGUgPSB7XG4gIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0XHR9LFxuICBcdFx0dGVhcmRvd246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dGhpcy5hcnJheVdyYXBwZXIudGVhcmRvd24oKTtcbiAgXHRcdFx0dGhpcy5tYWdpY1dyYXBwZXIudGVhcmRvd24oKTtcbiAgXHRcdH0sXG4gIFx0XHRyZXNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLm1hZ2ljV3JhcHBlci5yZXNldCh2YWx1ZSk7XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBtYWdpY0FycmF5ID0gbWFnaWNBcnJheUFkYXB0b3I7XG5cbiAgdmFyIHByb3RvdHlwZV9hZGFwdCA9IFZpZXdtb2RlbCRhZGFwdDtcblxuICB2YXIgcHJlZml4ZXJzID0ge307XG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRhZGFwdChrZXlwYXRoLCB2YWx1ZSkge1xuICBcdHZhciBsZW4sIGksIGFkYXB0b3IsIHdyYXBwZWQ7XG5cbiAgXHRpZiAoIXRoaXMuYWRhcHRvcnMpIHJldHVybjtcblxuICBcdC8vIERvIHdlIGhhdmUgYW4gYWRhcHRvciBmb3IgdGhpcyB2YWx1ZT9cbiAgXHRsZW4gPSB0aGlzLmFkYXB0b3JzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdGFkYXB0b3IgPSB0aGlzLmFkYXB0b3JzW2ldO1xuXG4gIFx0XHRpZiAoYWRhcHRvci5maWx0ZXIodmFsdWUsIGtleXBhdGgsIHRoaXMucmFjdGl2ZSkpIHtcbiAgXHRcdFx0d3JhcHBlZCA9IHRoaXMud3JhcHBlZFtrZXlwYXRoXSA9IGFkYXB0b3Iud3JhcCh0aGlzLnJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoLCBnZXRQcmVmaXhlcihrZXlwYXRoKSk7XG4gIFx0XHRcdHdyYXBwZWQudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWZpeEtleXBhdGgob2JqLCBwcmVmaXgpIHtcbiAgXHR2YXIgcHJlZml4ZWQgPSB7fSxcbiAgXHQgICAga2V5O1xuXG4gIFx0aWYgKCFwcmVmaXgpIHtcbiAgXHRcdHJldHVybiBvYmo7XG4gIFx0fVxuXG4gIFx0cHJlZml4ICs9IFwiLlwiO1xuXG4gIFx0Zm9yIChrZXkgaW4gb2JqKSB7XG4gIFx0XHRpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0cHJlZml4ZWRbcHJlZml4ICsga2V5XSA9IG9ialtrZXldO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBwcmVmaXhlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByZWZpeGVyKHJvb3RLZXlwYXRoKSB7XG4gIFx0dmFyIHJvb3REb3Q7XG5cbiAgXHRpZiAoIXByZWZpeGVyc1tyb290S2V5cGF0aF0pIHtcbiAgXHRcdHJvb3REb3QgPSByb290S2V5cGF0aCA/IHJvb3RLZXlwYXRoICsgXCIuXCIgOiBcIlwiO1xuXG4gIFx0XHRwcmVmaXhlcnNbcm9vdEtleXBhdGhdID0gZnVuY3Rpb24gKHJlbGF0aXZlS2V5cGF0aCwgdmFsdWUpIHtcbiAgXHRcdFx0dmFyIG9iajtcblxuICBcdFx0XHRpZiAodHlwZW9mIHJlbGF0aXZlS2V5cGF0aCA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRcdG9iaiA9IHt9O1xuICBcdFx0XHRcdG9ialtyb290RG90ICsgcmVsYXRpdmVLZXlwYXRoXSA9IHZhbHVlO1xuICBcdFx0XHRcdHJldHVybiBvYmo7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAodHlwZW9mIHJlbGF0aXZlS2V5cGF0aCA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0XHRcdC8vICdyZWxhdGl2ZUtleXBhdGgnIGlzIGluIGZhY3QgYSBoYXNoLCBub3QgYSBrZXlwYXRoXG4gIFx0XHRcdFx0cmV0dXJuIHJvb3REb3QgPyBwcmVmaXhLZXlwYXRoKHJlbGF0aXZlS2V5cGF0aCwgcm9vdEtleXBhdGgpIDogcmVsYXRpdmVLZXlwYXRoO1xuICBcdFx0XHR9XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBwcmVmaXhlcnNbcm9vdEtleXBhdGhdO1xuICB9XG5cbiAgLy8gVEVNUFxuXG4gIHZhciBoZWxwZXJzX2dldFVwc3RyZWFtQ2hhbmdlcyA9IGdldFVwc3RyZWFtQ2hhbmdlcztcbiAgZnVuY3Rpb24gZ2V0VXBzdHJlYW1DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgXHR2YXIgdXBzdHJlYW1DaGFuZ2VzID0gW3Jvb3RLZXlwYXRoXSxcbiAgXHQgICAgaSxcbiAgXHQgICAga2V5cGF0aDtcblxuICBcdGkgPSBjaGFuZ2VzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRrZXlwYXRoID0gY2hhbmdlc1tpXS5wYXJlbnQ7XG5cbiAgXHRcdHdoaWxlIChrZXlwYXRoICYmICFrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0XHRpZiAoY2hhbmdlcy5pbmRleE9mKGtleXBhdGgpID09PSAtMSkge1xuICBcdFx0XHRcdGFkZFRvQXJyYXkodXBzdHJlYW1DaGFuZ2VzLCBrZXlwYXRoKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRrZXlwYXRoID0ga2V5cGF0aC5wYXJlbnQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHVwc3RyZWFtQ2hhbmdlcztcbiAgfVxuXG4gIHZhciBhcHBseUNoYW5nZXNfbm90aWZ5UGF0dGVybk9ic2VydmVycyA9IG5vdGlmeVBhdHRlcm5PYnNlcnZlcnM7XG5cbiAgZnVuY3Rpb24gbm90aWZ5UGF0dGVybk9ic2VydmVycyh2aWV3bW9kZWwsIGtleXBhdGgsIG9ubHlEaXJlY3QpIHtcbiAgXHR2YXIgcG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzO1xuXG4gIFx0dXBkYXRlTWF0Y2hpbmdQYXR0ZXJuT2JzZXJ2ZXJzKHZpZXdtb2RlbCwga2V5cGF0aCk7XG5cbiAgXHRpZiAob25seURpcmVjdCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyA9IGtleXBhdGgud2lsZGNhcmRNYXRjaGVzKCk7XG4gIFx0cG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKHVwc3RyZWFtUGF0dGVybikge1xuICBcdFx0Y2FzY2FkZSh2aWV3bW9kZWwsIHVwc3RyZWFtUGF0dGVybiwga2V5cGF0aCk7XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBjYXNjYWRlKHZpZXdtb2RlbCwgdXBzdHJlYW1QYXR0ZXJuLCBrZXlwYXRoKSB7XG4gIFx0dmFyIGdyb3VwLCBtYXAsIGFjdHVhbENoaWxkS2V5cGF0aDtcblxuICBcdC8vIFRPRE8gc2hvdWxkIGJlIG9uZSBvciB0aGUgb3RoZXJcbiAgXHR1cHN0cmVhbVBhdHRlcm4gPSB1cHN0cmVhbVBhdHRlcm4uc3RyIHx8IHVwc3RyZWFtUGF0dGVybjtcblxuICBcdGdyb3VwID0gdmlld21vZGVsLmRlcHNNYXAucGF0dGVybk9ic2VydmVycztcbiAgXHRtYXAgPSBncm91cCAmJiBncm91cFt1cHN0cmVhbVBhdHRlcm5dO1xuXG4gIFx0aWYgKCFtYXApIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRtYXAuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRLZXlwYXRoKSB7XG4gIFx0XHRhY3R1YWxDaGlsZEtleXBhdGggPSBrZXlwYXRoLmpvaW4oY2hpbGRLZXlwYXRoLmxhc3RLZXkpOyAvLyAnZm9vLmJhci5iYXonXG5cbiAgXHRcdHVwZGF0ZU1hdGNoaW5nUGF0dGVybk9ic2VydmVycyh2aWV3bW9kZWwsIGFjdHVhbENoaWxkS2V5cGF0aCk7XG4gIFx0XHRjYXNjYWRlKHZpZXdtb2RlbCwgY2hpbGRLZXlwYXRoLCBhY3R1YWxDaGlsZEtleXBhdGgpO1xuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTWF0Y2hpbmdQYXR0ZXJuT2JzZXJ2ZXJzKHZpZXdtb2RlbCwga2V5cGF0aCkge1xuICBcdHZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gIFx0XHRpZiAob2JzZXJ2ZXIucmVnZXgudGVzdChrZXlwYXRoLnN0cikpIHtcbiAgXHRcdFx0b2JzZXJ2ZXIudXBkYXRlKGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH0pO1xuICB9XG5cbiAgdmFyIGFwcGx5Q2hhbmdlcyA9IFZpZXdtb2RlbCRhcHBseUNoYW5nZXM7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJGFwcGx5Q2hhbmdlcygpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHNlbGYgPSB0aGlzLFxuICBcdCAgICBjaGFuZ2VzLFxuICBcdCAgICB1cHN0cmVhbUNoYW5nZXMsXG4gIFx0ICAgIGhhc2ggPSB7fSxcbiAgXHQgICAgYmluZGluZ3M7XG5cbiAgXHRjaGFuZ2VzID0gdGhpcy5jaGFuZ2VzO1xuXG4gIFx0aWYgKCFjaGFuZ2VzLmxlbmd0aCkge1xuICBcdFx0Ly8gVE9ETyB3ZSBlbmQgdXAgaGVyZSBvbiBpbml0aWFsIHJlbmRlci4gUGVyaGFwcyB3ZSBzaG91bGRuJ3Q/XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gaW52YWxpZGF0ZUNvbXB1dGF0aW9uKGNvbXB1dGF0aW9uKSB7XG4gIFx0XHR2YXIga2V5ID0gY29tcHV0YXRpb24ua2V5O1xuXG4gIFx0XHRpZiAoY29tcHV0YXRpb24udmlld21vZGVsID09PSBzZWxmKSB7XG4gIFx0XHRcdHNlbGYuY2xlYXJDYWNoZShrZXkuc3RyKTtcbiAgXHRcdFx0Y29tcHV0YXRpb24uaW52YWxpZGF0ZSgpO1xuXG4gIFx0XHRcdGNoYW5nZXMucHVzaChrZXkpO1xuICBcdFx0XHRjYXNjYWRlKGtleSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjb21wdXRhdGlvbi52aWV3bW9kZWwubWFyayhrZXkpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGZ1bmN0aW9uIGNhc2NhZGUoa2V5cGF0aCkge1xuICBcdFx0dmFyIG1hcCwgY29tcHV0YXRpb25zO1xuXG4gIFx0XHRpZiAoc2VsZi5ub0Nhc2NhZGUuaGFzT3duUHJvcGVydHkoa2V5cGF0aC5zdHIpKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGNvbXB1dGF0aW9ucyA9IHNlbGYuZGVwcy5jb21wdXRlZFtrZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0Y29tcHV0YXRpb25zLmZvckVhY2goaW52YWxpZGF0ZUNvbXB1dGF0aW9uKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG1hcCA9IHNlbGYuZGVwc01hcC5jb21wdXRlZFtrZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0bWFwLmZvckVhY2goY2FzY2FkZSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Y2hhbmdlcy5zbGljZSgpLmZvckVhY2goY2FzY2FkZSk7XG5cbiAgXHR1cHN0cmVhbUNoYW5nZXMgPSBoZWxwZXJzX2dldFVwc3RyZWFtQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgXHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFyIGNvbXB1dGF0aW9ucztcblxuICBcdFx0Ly8gbWFrZSBzdXJlIHdlIGhhdmVuJ3QgYWxyZWFkeSBiZWVuIGRvd24gdGhpcyBwYXJ0aWN1bGFyIGtleXBhdGggaW4gdGhpcyB0dXJuXG4gIFx0XHRpZiAoY2hhbmdlcy5pbmRleE9mKGtleXBhdGgpID09PSAtMSAmJiAoY29tcHV0YXRpb25zID0gc2VsZi5kZXBzLmNvbXB1dGVkW2tleXBhdGguc3RyXSkpIHtcbiAgXHRcdFx0Y29tcHV0YXRpb25zLmZvckVhY2goaW52YWxpZGF0ZUNvbXB1dGF0aW9uKTtcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdHRoaXMuY2hhbmdlcyA9IFtdO1xuXG4gIFx0Ly8gUGF0dGVybiBvYnNlcnZlcnMgYXJlIGEgd2VpcmQgc3BlY2lhbCBjYXNlXG4gIFx0aWYgKHRoaXMucGF0dGVybk9ic2VydmVycy5sZW5ndGgpIHtcbiAgXHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBhcHBseUNoYW5nZXNfbm90aWZ5UGF0dGVybk9ic2VydmVycyhfdGhpcywga2V5cGF0aCwgdHJ1ZSk7XG4gIFx0XHR9KTtcbiAgXHRcdGNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gYXBwbHlDaGFuZ2VzX25vdGlmeVBhdHRlcm5PYnNlcnZlcnMoX3RoaXMsIGtleXBhdGgpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZGVwcy5vYnNlcnZlcnMpIHtcbiAgXHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBub3RpZnlVcHN0cmVhbURlcGVuZGFudHMoX3RoaXMsIG51bGwsIGtleXBhdGgsIFwib2JzZXJ2ZXJzXCIpO1xuICBcdFx0fSk7XG4gIFx0XHRub3RpZnlBbGxEZXBlbmRhbnRzKHRoaXMsIGNoYW5nZXMsIFwib2JzZXJ2ZXJzXCIpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmRlcHNbXCJkZWZhdWx0XCJdKSB7XG4gIFx0XHRiaW5kaW5ncyA9IFtdO1xuICBcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIG5vdGlmeVVwc3RyZWFtRGVwZW5kYW50cyhfdGhpcywgYmluZGluZ3MsIGtleXBhdGgsIFwiZGVmYXVsdFwiKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRpZiAoYmluZGluZ3MubGVuZ3RoKSB7XG4gIFx0XHRcdG5vdGlmeUJpbmRpbmdzKHRoaXMsIGJpbmRpbmdzLCBjaGFuZ2VzKTtcbiAgXHRcdH1cblxuICBcdFx0bm90aWZ5QWxsRGVwZW5kYW50cyh0aGlzLCBjaGFuZ2VzLCBcImRlZmF1bHRcIik7XG4gIFx0fVxuXG4gIFx0Ly8gUmV0dXJuIGEgaGFzaCBvZiBrZXlwYXRocyB0byB1cGRhdGVkIHZhbHVlc1xuICBcdGNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0aGFzaFtrZXlwYXRoLnN0cl0gPSBfdGhpcy5nZXQoa2V5cGF0aCk7XG4gIFx0fSk7XG5cbiAgXHR0aGlzLmltcGxpY2l0Q2hhbmdlcyA9IHt9O1xuICBcdHRoaXMubm9DYXNjYWRlID0ge307XG5cbiAgXHRyZXR1cm4gaGFzaDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeVVwc3RyZWFtRGVwZW5kYW50cyh2aWV3bW9kZWwsIGJpbmRpbmdzLCBrZXlwYXRoLCBncm91cE5hbWUpIHtcbiAgXHR2YXIgZGVwZW5kYW50cywgdmFsdWU7XG5cbiAgXHRpZiAoZGVwZW5kYW50cyA9IGZpbmREZXBlbmRhbnRzKHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXBOYW1lKSkge1xuICBcdFx0dmFsdWUgPSB2aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0XHRkZXBlbmRhbnRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgXHRcdFx0Ly8gZG9uJ3QgXCJzZXRcIiB0aGUgcGFyZW50IHZhbHVlLCByZWZpbmUgaXRcbiAgXHRcdFx0Ly8gaS5lLiBub3QgZGF0YSA9IHZhbHVlLCBidXQgZGF0YVtmb29dID0gZm9vVmFsdWVcbiAgXHRcdFx0aWYgKGJpbmRpbmdzICYmIGQucmVmaW5lVmFsdWUpIHtcbiAgXHRcdFx0XHRiaW5kaW5ncy5wdXNoKGQpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGQuc2V0VmFsdWUodmFsdWUpO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlCaW5kaW5ncyh2aWV3bW9kZWwsIGJpbmRpbmdzLCBjaGFuZ2VzKSB7XG5cbiAgXHRiaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gIFx0XHR2YXIgdXNlU2V0ID0gZmFsc2UsXG4gIFx0XHQgICAgaSA9IDAsXG4gIFx0XHQgICAgbGVuZ3RoID0gY2hhbmdlcy5sZW5ndGgsXG4gIFx0XHQgICAgcmVmaW5lbWVudHMgPSBbXTtcblxuICBcdFx0d2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgXHRcdFx0dmFyIGtleXBhdGggPSBjaGFuZ2VzW2ldO1xuXG4gIFx0XHRcdGlmIChrZXlwYXRoID09PSBiaW5kaW5nLmtleXBhdGgpIHtcbiAgXHRcdFx0XHR1c2VTZXQgPSB0cnVlO1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGtleXBhdGguc2xpY2UoMCwgYmluZGluZy5rZXlwYXRoLmxlbmd0aCkgPT09IGJpbmRpbmcua2V5cGF0aCkge1xuICBcdFx0XHRcdHJlZmluZW1lbnRzLnB1c2goa2V5cGF0aCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpKys7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh1c2VTZXQpIHtcbiAgXHRcdFx0YmluZGluZy5zZXRWYWx1ZSh2aWV3bW9kZWwuZ2V0KGJpbmRpbmcua2V5cGF0aCkpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAocmVmaW5lbWVudHMubGVuZ3RoKSB7XG4gIFx0XHRcdGJpbmRpbmcucmVmaW5lVmFsdWUocmVmaW5lbWVudHMpO1xuICBcdFx0fVxuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5QWxsRGVwZW5kYW50cyh2aWV3bW9kZWwsIGtleXBhdGhzLCBncm91cE5hbWUpIHtcbiAgXHR2YXIgcXVldWUgPSBbXTtcblxuICBcdGFkZEtleXBhdGhzKGtleXBhdGhzKTtcbiAgXHRxdWV1ZS5mb3JFYWNoKGRpc3BhdGNoKTtcblxuICBcdGZ1bmN0aW9uIGFkZEtleXBhdGhzKGtleXBhdGhzKSB7XG4gIFx0XHRrZXlwYXRocy5mb3JFYWNoKGFkZEtleXBhdGgpO1xuICBcdFx0a2V5cGF0aHMuZm9yRWFjaChjYXNjYWRlKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBhZGRLZXlwYXRoKGtleXBhdGgpIHtcbiAgXHRcdHZhciBkZXBzID0gZmluZERlcGVuZGFudHModmlld21vZGVsLCBrZXlwYXRoLCBncm91cE5hbWUpO1xuXG4gIFx0XHRpZiAoZGVwcykge1xuICBcdFx0XHRxdWV1ZS5wdXNoKHtcbiAgXHRcdFx0XHRrZXlwYXRoOiBrZXlwYXRoLFxuICBcdFx0XHRcdGRlcHM6IGRlcHNcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gY2FzY2FkZShrZXlwYXRoKSB7XG4gIFx0XHR2YXIgY2hpbGREZXBzO1xuXG4gIFx0XHRpZiAoY2hpbGREZXBzID0gdmlld21vZGVsLmRlcHNNYXBbZ3JvdXBOYW1lXVtrZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0YWRkS2V5cGF0aHMoY2hpbGREZXBzKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBkaXNwYXRjaChzZXQpIHtcbiAgXHRcdHZhciB2YWx1ZSA9IHZpZXdtb2RlbC5nZXQoc2V0LmtleXBhdGgpO1xuICBcdFx0c2V0LmRlcHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHRyZXR1cm4gZC5zZXRWYWx1ZSh2YWx1ZSk7XG4gIFx0XHR9KTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kRGVwZW5kYW50cyh2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSkge1xuICBcdHZhciBncm91cCA9IHZpZXdtb2RlbC5kZXBzW2dyb3VwTmFtZV07XG4gIFx0cmV0dXJuIGdyb3VwID8gZ3JvdXBba2V5cGF0aC5zdHJdIDogbnVsbDtcbiAgfVxuXG4gIHZhciBjYXB0dXJlID0gVmlld21vZGVsJGNhcHR1cmU7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJGNhcHR1cmUoKSB7XG4gIFx0dGhpcy5jYXB0dXJlR3JvdXBzLnB1c2goW10pO1xuICB9XG5cbiAgdmFyIGNsZWFyQ2FjaGUgPSBWaWV3bW9kZWwkY2xlYXJDYWNoZTtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkY2xlYXJDYWNoZShrZXlwYXRoLCBrZWVwRXhpc3RpbmdXcmFwcGVyKSB7XG4gIFx0dmFyIGNhY2hlTWFwLCB3cmFwcGVyO1xuXG4gIFx0aWYgKCFrZWVwRXhpc3RpbmdXcmFwcGVyKSB7XG4gIFx0XHQvLyBJcyB0aGVyZSBhIHdyYXBwZWQgcHJvcGVydHkgYXQgdGhpcyBrZXlwYXRoP1xuICBcdFx0aWYgKHdyYXBwZXIgPSB0aGlzLndyYXBwZWRba2V5cGF0aF0pIHtcbiAgXHRcdFx0Ly8gRGlkIHdlIHVud3JhcCBpdD9cbiAgXHRcdFx0aWYgKHdyYXBwZXIudGVhcmRvd24oKSAhPT0gZmFsc2UpIHtcbiAgXHRcdFx0XHQvLyBJcyB0aGlzIHJpZ2h0P1xuICBcdFx0XHRcdC8vIFdoYXQncyB0aGUgbWVhbmluZyBvZiByZXR1cm5pbmcgZmFsc2UgZnJvbSB0ZWFyZG93bj9cbiAgXHRcdFx0XHQvLyBDb3VsZCB0aGVyZSBiZSBhIEdDIHJhbWlmaWNhdGlvbiBpZiB0aGlzIGlzIGEgXCJyZWFsXCIgcmFjdGl2ZS50ZWFyZG93bigpP1xuICBcdFx0XHRcdHRoaXMud3JhcHBlZFtrZXlwYXRoXSA9IG51bGw7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR0aGlzLmNhY2hlW2tleXBhdGhdID0gdW5kZWZpbmVkO1xuXG4gIFx0aWYgKGNhY2hlTWFwID0gdGhpcy5jYWNoZU1hcFtrZXlwYXRoXSkge1xuICBcdFx0d2hpbGUgKGNhY2hlTWFwLmxlbmd0aCkge1xuICBcdFx0XHR0aGlzLmNsZWFyQ2FjaGUoY2FjaGVNYXAucG9wKCkpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBVbnJlc29sdmVkRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChjb21wdXRhdGlvbiwgcmVmKSB7XG4gIFx0dGhpcy5jb21wdXRhdGlvbiA9IGNvbXB1dGF0aW9uO1xuICBcdHRoaXMudmlld21vZGVsID0gY29tcHV0YXRpb24udmlld21vZGVsO1xuICBcdHRoaXMucmVmID0gcmVmO1xuXG4gIFx0Ly8gVE9ETyB0aGlzIHNlZW1zIGxpa2UgYSByZWQgZmxhZyFcbiAgXHR0aGlzLnJvb3QgPSB0aGlzLnZpZXdtb2RlbC5yYWN0aXZlO1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSB0aGlzLnJvb3QuY29tcG9uZW50ICYmIHRoaXMucm9vdC5jb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG4gIH07XG5cbiAgVW5yZXNvbHZlZERlcGVuZGVuY3kucHJvdG90eXBlID0ge1xuICBcdHJlc29sdmU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR0aGlzLmNvbXB1dGF0aW9uLnNvZnREZXBzLnB1c2goa2V5cGF0aCk7XG4gIFx0XHR0aGlzLmNvbXB1dGF0aW9uLnVucmVzb2x2ZWREZXBzW2tleXBhdGguc3RyXSA9IG51bGw7XG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5yZWdpc3RlcihrZXlwYXRoLCB0aGlzLmNvbXB1dGF0aW9uLCBcImNvbXB1dGVkXCIpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgQ29tcHV0YXRpb25fVW5yZXNvbHZlZERlcGVuZGVuY3kgPSBVbnJlc29sdmVkRGVwZW5kZW5jeTtcblxuICB2YXIgQ29tcHV0YXRpb24gPSBmdW5jdGlvbiAoa2V5LCBzaWduYXR1cmUpIHtcbiAgXHR0aGlzLmtleSA9IGtleTtcblxuICBcdHRoaXMuZ2V0dGVyID0gc2lnbmF0dXJlLmdldHRlcjtcbiAgXHR0aGlzLnNldHRlciA9IHNpZ25hdHVyZS5zZXR0ZXI7XG5cbiAgXHR0aGlzLmhhcmREZXBzID0gc2lnbmF0dXJlLmRlcHMgfHwgW107XG4gIFx0dGhpcy5zb2Z0RGVwcyA9IFtdO1xuICBcdHRoaXMudW5yZXNvbHZlZERlcHMgPSB7fTtcblxuICBcdHRoaXMuZGVwVmFsdWVzID0ge307XG5cbiAgXHR0aGlzLl9kaXJ0eSA9IHRoaXMuX2ZpcnN0UnVuID0gdHJ1ZTtcbiAgfTtcblxuICBDb21wdXRhdGlvbi5wcm90b3R5cGUgPSB7XG4gIFx0Y29uc3RydWN0b3I6IENvbXB1dGF0aW9uLFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKHZpZXdtb2RlbCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIGluaXRpYWw7XG5cbiAgXHRcdHRoaXMudmlld21vZGVsID0gdmlld21vZGVsO1xuICBcdFx0dGhpcy5ieXBhc3MgPSB0cnVlO1xuXG4gIFx0XHRpbml0aWFsID0gdmlld21vZGVsLmdldCh0aGlzLmtleSk7XG4gIFx0XHR2aWV3bW9kZWwuY2xlYXJDYWNoZSh0aGlzLmtleS5zdHIpO1xuXG4gIFx0XHR0aGlzLmJ5cGFzcyA9IGZhbHNlO1xuXG4gIFx0XHRpZiAodGhpcy5zZXR0ZXIgJiYgaW5pdGlhbCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMuc2V0KGluaXRpYWwpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5oYXJkRGVwcykge1xuICBcdFx0XHR0aGlzLmhhcmREZXBzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgXHRcdFx0XHRyZXR1cm4gdmlld21vZGVsLnJlZ2lzdGVyKGQsIF90aGlzLCBcImNvbXB1dGVkXCIpO1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0aW52YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fZGlydHkgPSB0cnVlO1xuICBcdH0sXG5cbiAgXHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciBuZXdEZXBzLFxuICBcdFx0ICAgIGRlcGVuZGVuY2llc0NoYW5nZWQsXG4gIFx0XHQgICAgZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgPSBmYWxzZTtcblxuICBcdFx0aWYgKHRoaXMuZ2V0dGluZykge1xuICBcdFx0XHQvLyBwcmV2ZW50IGRvdWJsZS1jb21wdXRhdGlvbiAoZS5nLiBjYXVzZWQgYnkgYXJyYXkgbXV0YXRpb24gaW5zaWRlIGNvbXB1dGF0aW9uKVxuICBcdFx0XHR2YXIgbXNnID0gXCJUaGUgXCIgKyB0aGlzLmtleS5zdHIgKyBcIiBjb21wdXRhdGlvbiBpbmRpcmVjdGx5IGNhbGxlZCBpdHNlbGYuIFRoaXMgcHJvYmFibHkgaW5kaWNhdGVzIGEgYnVnIGluIHRoZSBjb21wdXRhdGlvbi4gSXQgaXMgY29tbW9ubHkgY2F1c2VkIGJ5IGBhcnJheS5zb3J0KC4uLilgIC0gaWYgdGhhdCdzIHRoZSBjYXNlLCBjbG9uZSB0aGUgYXJyYXkgZmlyc3Qgd2l0aCBgYXJyYXkuc2xpY2UoKS5zb3J0KC4uLilgXCI7XG4gIFx0XHRcdHdhcm5PbmNlKG1zZyk7XG4gIFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmdldHRpbmcgPSB0cnVlO1xuXG4gIFx0XHRpZiAodGhpcy5fZGlydHkpIHtcbiAgXHRcdFx0Ly8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGlucHV0cyBoYXZlIGNoYW5nZWQsIGluIGNhc2UgdGhpcyBkZXBlbmRzIG9uXG4gIFx0XHRcdC8vIG90aGVyIGNvbXB1dGVkIHZhbHVlc1xuICBcdFx0XHRpZiAodGhpcy5fZmlyc3RSdW4gfHwgIXRoaXMuaGFyZERlcHMubGVuZ3RoICYmICF0aGlzLnNvZnREZXBzLmxlbmd0aCkge1xuICBcdFx0XHRcdGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRbdGhpcy5oYXJkRGVwcywgdGhpcy5zb2Z0RGVwc10uZm9yRWFjaChmdW5jdGlvbiAoZGVwcykge1xuICBcdFx0XHRcdFx0dmFyIGtleXBhdGgsIHZhbHVlLCBpO1xuXG4gIFx0XHRcdFx0XHRpZiAoZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQpIHtcbiAgXHRcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRpID0gZGVwcy5sZW5ndGg7XG4gIFx0XHRcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0XHRcdGtleXBhdGggPSBkZXBzW2ldO1xuICBcdFx0XHRcdFx0XHR2YWx1ZSA9IF90aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdFx0XHRcdFx0aWYgKCFpc0VxdWFsKHZhbHVlLCBfdGhpcy5kZXBWYWx1ZXNba2V5cGF0aC5zdHJdKSkge1xuICBcdFx0XHRcdFx0XHRcdF90aGlzLmRlcFZhbHVlc1trZXlwYXRoLnN0cl0gPSB2YWx1ZTtcbiAgXHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCA9IHRydWU7XG5cbiAgXHRcdFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCkge1xuICBcdFx0XHRcdHRoaXMudmlld21vZGVsLmNhcHR1cmUoKTtcblxuICBcdFx0XHRcdHRyeSB7XG4gIFx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5nZXR0ZXIoKTtcbiAgXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdFx0XHRcdHdhcm5JZkRlYnVnKFwiRmFpbGVkIHRvIGNvbXB1dGUgXFxcIiVzXFxcIlwiLCB0aGlzLmtleS5zdHIpO1xuICBcdFx0XHRcdFx0bG9nSWZEZWJ1ZyhlcnIuc3RhY2sgfHwgZXJyKTtcblxuICBcdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZvaWQgMDtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRuZXdEZXBzID0gdGhpcy52aWV3bW9kZWwucmVsZWFzZSgpO1xuICBcdFx0XHRcdGRlcGVuZGVuY2llc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZURlcGVuZGVuY2llcyhuZXdEZXBzKTtcblxuICBcdFx0XHRcdGlmIChkZXBlbmRlbmNpZXNDaGFuZ2VkKSB7XG4gIFx0XHRcdFx0XHRbdGhpcy5oYXJkRGVwcywgdGhpcy5zb2Z0RGVwc10uZm9yRWFjaChmdW5jdGlvbiAoZGVwcykge1xuICBcdFx0XHRcdFx0XHRkZXBzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0XHRcdFx0XHRfdGhpcy5kZXBWYWx1ZXNba2V5cGF0aC5zdHJdID0gX3RoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcbiAgXHRcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmdldHRpbmcgPSB0aGlzLl9maXJzdFJ1biA9IGZhbHNlO1xuICBcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0fSxcblxuICBcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRpZiAodGhpcy5zZXR0aW5nKSB7XG4gIFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXRoaXMuc2V0dGVyKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNvbXB1dGVkIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJzIGFyZSByZWFkLW9ubHkuIChUaGlzIG1heSBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSYWN0aXZlISlcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuc2V0dGVyKHZhbHVlKTtcbiAgXHR9LFxuXG4gIFx0dXBkYXRlRGVwZW5kZW5jaWVzOiBmdW5jdGlvbiAobmV3RGVwcykge1xuICBcdFx0dmFyIGksIG9sZERlcHMsIGtleXBhdGgsIGRlcGVuZGVuY2llc0NoYW5nZWQsIHVucmVzb2x2ZWQ7XG5cbiAgXHRcdG9sZERlcHMgPSB0aGlzLnNvZnREZXBzO1xuXG4gIFx0XHQvLyByZW1vdmUgZGVwZW5kZW5jaWVzIHRoYXQgYXJlIG5vIGxvbmdlciB1c2VkXG4gIFx0XHRpID0gb2xkRGVwcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGtleXBhdGggPSBvbGREZXBzW2ldO1xuXG4gIFx0XHRcdGlmIChuZXdEZXBzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xKSB7XG4gIFx0XHRcdFx0ZGVwZW5kZW5jaWVzQ2hhbmdlZCA9IHRydWU7XG4gIFx0XHRcdFx0dGhpcy52aWV3bW9kZWwudW5yZWdpc3RlcihrZXlwYXRoLCB0aGlzLCBcImNvbXB1dGVkXCIpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGNyZWF0ZSByZWZlcmVuY2VzIGZvciBhbnkgbmV3IGRlcGVuZGVuY2llc1xuICBcdFx0aSA9IG5ld0RlcHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRrZXlwYXRoID0gbmV3RGVwc1tpXTtcblxuICBcdFx0XHRpZiAob2xkRGVwcy5pbmRleE9mKGtleXBhdGgpID09PSAtMSAmJiAoIXRoaXMuaGFyZERlcHMgfHwgdGhpcy5oYXJkRGVwcy5pbmRleE9mKGtleXBhdGgpID09PSAtMSkpIHtcbiAgXHRcdFx0XHRkZXBlbmRlbmNpZXNDaGFuZ2VkID0gdHJ1ZTtcblxuICBcdFx0XHRcdC8vIGlmIHRoaXMga2V5cGF0aCBpcyBjdXJyZW50bHkgdW5yZXNvbHZlZCwgd2UgbmVlZCB0byBtYXJrXG4gIFx0XHRcdFx0Ly8gaXQgYXMgc3VjaC4gVE9ETyB0aGlzIGlzIGEgYml0IG11ZGR5Li4uXG4gIFx0XHRcdFx0aWYgKGlzVW5yZXNvbHZlZCh0aGlzLnZpZXdtb2RlbCwga2V5cGF0aCkgJiYgIXRoaXMudW5yZXNvbHZlZERlcHNba2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdFx0XHR1bnJlc29sdmVkID0gbmV3IENvbXB1dGF0aW9uX1VucmVzb2x2ZWREZXBlbmRlbmN5KHRoaXMsIGtleXBhdGguc3RyKTtcbiAgXHRcdFx0XHRcdG5ld0RlcHMuc3BsaWNlKGksIDEpO1xuXG4gIFx0XHRcdFx0XHR0aGlzLnVucmVzb2x2ZWREZXBzW2tleXBhdGguc3RyXSA9IHVucmVzb2x2ZWQ7XG4gIFx0XHRcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRVbnJlc29sdmVkKHVucmVzb2x2ZWQpO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5yZWdpc3RlcihrZXlwYXRoLCB0aGlzLCBcImNvbXB1dGVkXCIpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRpZiAoZGVwZW5kZW5jaWVzQ2hhbmdlZCkge1xuICBcdFx0XHR0aGlzLnNvZnREZXBzID0gbmV3RGVwcy5zbGljZSgpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZGVwZW5kZW5jaWVzQ2hhbmdlZDtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNVbnJlc29sdmVkKHZpZXdtb2RlbCwga2V5cGF0aCkge1xuICBcdHZhciBrZXkgPSBrZXlwYXRoLmZpcnN0S2V5O1xuXG4gIFx0cmV0dXJuICEoa2V5IGluIHZpZXdtb2RlbC5kYXRhKSAmJiAhKGtleSBpbiB2aWV3bW9kZWwuY29tcHV0YXRpb25zKSAmJiAhKGtleSBpbiB2aWV3bW9kZWwubWFwcGluZ3MpO1xuICB9XG5cbiAgdmFyIENvbXB1dGF0aW9uX0NvbXB1dGF0aW9uID0gQ29tcHV0YXRpb247XG5cbiAgdmFyIGNvbXB1dGUgPSBWaWV3bW9kZWwkY29tcHV0ZTtcbiAgZnVuY3Rpb24gVmlld21vZGVsJGNvbXB1dGUoa2V5LCBzaWduYXR1cmUpIHtcbiAgXHR2YXIgY29tcHV0YXRpb24gPSBuZXcgQ29tcHV0YXRpb25fQ29tcHV0YXRpb24oa2V5LCBzaWduYXR1cmUpO1xuXG4gIFx0aWYgKHRoaXMucmVhZHkpIHtcbiAgXHRcdGNvbXB1dGF0aW9uLmluaXQodGhpcyk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMuY29tcHV0YXRpb25zW2tleS5zdHJdID0gY29tcHV0YXRpb247XG4gIH1cblxuICB2YXIgRkFJTEVEX0xPT0tVUCA9IHsgRkFJTEVEX0xPT0tVUDogdHJ1ZSB9O1xuXG4gIHZhciB2aWV3bW9kZWxfcHJvdG90eXBlX2dldCA9IFZpZXdtb2RlbCRnZXQ7XG5cbiAgdmFyIHZpZXdtb2RlbF9wcm90b3R5cGVfZ2V0X19lbXB0eSA9IHt9O1xuICBmdW5jdGlvbiBWaWV3bW9kZWwkZ2V0KGtleXBhdGgsIG9wdGlvbnMpIHtcbiAgXHR2YXIgY2FjaGUgPSB0aGlzLmNhY2hlLFxuICBcdCAgICB2YWx1ZSxcbiAgXHQgICAgY29tcHV0YXRpb24sXG4gIFx0ICAgIHdyYXBwZWQsXG4gIFx0ICAgIGNhcHR1cmVHcm91cCxcbiAgXHQgICAga2V5cGF0aFN0ciA9IGtleXBhdGguc3RyLFxuICBcdCAgICBrZXk7XG5cbiAgXHRvcHRpb25zID0gb3B0aW9ucyB8fCB2aWV3bW9kZWxfcHJvdG90eXBlX2dldF9fZW1wdHk7XG5cbiAgXHQvLyBjYXB0dXJlIHRoZSBrZXlwYXRoLCBpZiB3ZSdyZSBpbnNpZGUgYSBjb21wdXRhdGlvblxuICBcdGlmIChvcHRpb25zLmNhcHR1cmUgJiYgKGNhcHR1cmVHcm91cCA9IGxhc3RJdGVtKHRoaXMuY2FwdHVyZUdyb3VwcykpKSB7XG4gIFx0XHRpZiAoISB+Y2FwdHVyZUdyb3VwLmluZGV4T2Yoa2V5cGF0aCkpIHtcbiAgXHRcdFx0Y2FwdHVyZUdyb3VwLnB1c2goa2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKGhhc093bi5jYWxsKHRoaXMubWFwcGluZ3MsIGtleXBhdGguZmlyc3RLZXkpKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5tYXBwaW5nc1trZXlwYXRoLmZpcnN0S2V5XS5nZXQoa2V5cGF0aCwgb3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0aWYgKGtleXBhdGguaXNTcGVjaWFsKSB7XG4gIFx0XHRyZXR1cm4ga2V5cGF0aC52YWx1ZTtcbiAgXHR9XG5cbiAgXHRpZiAoY2FjaGVba2V5cGF0aFN0cl0gPT09IHVuZGVmaW5lZCkge1xuXG4gIFx0XHQvLyBJcyB0aGlzIGEgY29tcHV0ZWQgcHJvcGVydHk/XG4gIFx0XHRpZiAoKGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRhdGlvbnNba2V5cGF0aFN0cl0pICYmICFjb21wdXRhdGlvbi5ieXBhc3MpIHtcbiAgXHRcdFx0dmFsdWUgPSBjb21wdXRhdGlvbi5nZXQoKTtcbiAgXHRcdFx0dGhpcy5hZGFwdChrZXlwYXRoU3RyLCB2YWx1ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIElzIHRoaXMgYSB3cmFwcGVkIHByb3BlcnR5P1xuICBcdFx0ZWxzZSBpZiAod3JhcHBlZCA9IHRoaXMud3JhcHBlZFtrZXlwYXRoU3RyXSkge1xuICBcdFx0XHR2YWx1ZSA9IHdyYXBwZWQudmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIElzIGl0IHRoZSByb290P1xuICBcdFx0ZWxzZSBpZiAoa2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdFx0dGhpcy5hZGFwdChcIlwiLCB0aGlzLmRhdGEpO1xuICBcdFx0XHR2YWx1ZSA9IHRoaXMuZGF0YTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gTm8/IFRoZW4gd2UgbmVlZCB0byByZXRyaWV2ZSB0aGUgdmFsdWUgb25lIGtleSBhdCBhIHRpbWVcbiAgXHRcdGVsc2Uge1xuICBcdFx0XHR2YWx1ZSA9IHJldHJpZXZlKHRoaXMsIGtleXBhdGgpO1xuICBcdFx0fVxuXG4gIFx0XHRjYWNoZVtrZXlwYXRoU3RyXSA9IHZhbHVlO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR2YWx1ZSA9IGNhY2hlW2tleXBhdGhTdHJdO1xuICBcdH1cblxuICBcdGlmICghb3B0aW9ucy5ub1Vud3JhcCAmJiAod3JhcHBlZCA9IHRoaXMud3JhcHBlZFtrZXlwYXRoU3RyXSkpIHtcbiAgXHRcdHZhbHVlID0gd3JhcHBlZC5nZXQoKTtcbiAgXHR9XG5cbiAgXHRpZiAoa2V5cGF0aC5pc1Jvb3QgJiYgb3B0aW9ucy5mdWxsUm9vdEdldCkge1xuICBcdFx0Zm9yIChrZXkgaW4gdGhpcy5tYXBwaW5ncykge1xuICBcdFx0XHR2YWx1ZVtrZXldID0gdGhpcy5tYXBwaW5nc1trZXldLmdldFZhbHVlKCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHZhbHVlID09PSBGQUlMRURfTE9PS1VQID8gdm9pZCAwIDogdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXRyaWV2ZSh2aWV3bW9kZWwsIGtleXBhdGgpIHtcblxuICBcdHZhciBwYXJlbnRWYWx1ZSwgY2FjaGVNYXAsIHZhbHVlLCB3cmFwcGVkO1xuXG4gIFx0cGFyZW50VmFsdWUgPSB2aWV3bW9kZWwuZ2V0KGtleXBhdGgucGFyZW50KTtcblxuICBcdGlmICh3cmFwcGVkID0gdmlld21vZGVsLndyYXBwZWRba2V5cGF0aC5wYXJlbnQuc3RyXSkge1xuICBcdFx0cGFyZW50VmFsdWUgPSB3cmFwcGVkLmdldCgpO1xuICBcdH1cblxuICBcdGlmIChwYXJlbnRWYWx1ZSA9PT0gbnVsbCB8fCBwYXJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gdXBkYXRlIGNhY2hlIG1hcFxuICBcdGlmICghKGNhY2hlTWFwID0gdmlld21vZGVsLmNhY2hlTWFwW2tleXBhdGgucGFyZW50LnN0cl0pKSB7XG4gIFx0XHR2aWV3bW9kZWwuY2FjaGVNYXBba2V5cGF0aC5wYXJlbnQuc3RyXSA9IFtrZXlwYXRoLnN0cl07XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGlmIChjYWNoZU1hcC5pbmRleE9mKGtleXBhdGguc3RyKSA9PT0gLTEpIHtcbiAgXHRcdFx0Y2FjaGVNYXAucHVzaChrZXlwYXRoLnN0cik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gSWYgdGhpcyBwcm9wZXJ0eSBkb2Vzbid0IGV4aXN0LCB3ZSByZXR1cm4gYSBzZW50aW5lbCB2YWx1ZVxuICBcdC8vIHNvIHRoYXQgd2Uga25vdyB0byBxdWVyeSBwYXJlbnQgc2NvcGUgKGlmIHN1Y2ggdGhlcmUgYmUpXG4gIFx0aWYgKHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhKGtleXBhdGgubGFzdEtleSBpbiBwYXJlbnRWYWx1ZSkpIHtcbiAgXHRcdHJldHVybiB2aWV3bW9kZWwuY2FjaGVba2V5cGF0aC5zdHJdID0gRkFJTEVEX0xPT0tVUDtcbiAgXHR9XG5cbiAgXHR2YWx1ZSA9IHBhcmVudFZhbHVlW2tleXBhdGgubGFzdEtleV07XG5cbiAgXHQvLyBEbyB3ZSBoYXZlIGFuIGFkYXB0b3IgZm9yIHRoaXMgdmFsdWU/XG4gIFx0dmlld21vZGVsLmFkYXB0KGtleXBhdGguc3RyLCB2YWx1ZSwgZmFsc2UpO1xuXG4gIFx0Ly8gVXBkYXRlIGNhY2hlXG4gIFx0dmlld21vZGVsLmNhY2hlW2tleXBhdGguc3RyXSA9IHZhbHVlO1xuICBcdHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHZhciB2aWV3bW9kZWxfcHJvdG90eXBlX2luaXQgPSBWaWV3bW9kZWwkaW5pdDtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkaW5pdCgpIHtcbiAgXHR2YXIga2V5O1xuXG4gIFx0Zm9yIChrZXkgaW4gdGhpcy5jb21wdXRhdGlvbnMpIHtcbiAgXHRcdHRoaXMuY29tcHV0YXRpb25zW2tleV0uaW5pdCh0aGlzKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX21hcCA9IFZpZXdtb2RlbCRtYXA7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJG1hcChrZXksIG9wdGlvbnMpIHtcbiAgXHR2YXIgbWFwcGluZyA9IHRoaXMubWFwcGluZ3Nba2V5LnN0cl0gPSBuZXcgTWFwcGluZyhrZXksIG9wdGlvbnMpO1xuICBcdG1hcHBpbmcuaW5pdFZpZXdtb2RlbCh0aGlzKTtcbiAgXHRyZXR1cm4gbWFwcGluZztcbiAgfVxuXG4gIHZhciBNYXBwaW5nID0gZnVuY3Rpb24gKGxvY2FsS2V5LCBvcHRpb25zKSB7XG4gIFx0dGhpcy5sb2NhbEtleSA9IGxvY2FsS2V5O1xuICBcdHRoaXMua2V5cGF0aCA9IG9wdGlvbnMua2V5cGF0aDtcbiAgXHR0aGlzLm9yaWdpbiA9IG9wdGlvbnMub3JpZ2luO1xuXG4gIFx0dGhpcy5kZXBzID0gW107XG4gIFx0dGhpcy51bnJlc29sdmVkID0gW107XG5cbiAgXHR0aGlzLnJlc29sdmVkID0gZmFsc2U7XG4gIH07XG5cbiAgTWFwcGluZy5wcm90b3R5cGUgPSB7XG4gIFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBUT0RPIHdhcm4sIGFzIHBlciAjMTY5Mj9cbiAgXHRcdHRoaXMua2V5cGF0aCA9IHRoaXMubG9jYWxLZXk7XG4gIFx0XHR0aGlzLnNldHVwKCk7XG4gIFx0fSxcblxuICBcdGdldDogZnVuY3Rpb24gKGtleXBhdGgsIG9wdGlvbnMpIHtcbiAgXHRcdGlmICghdGhpcy5yZXNvbHZlZCkge1xuICBcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXMub3JpZ2luLmdldCh0aGlzLm1hcChrZXlwYXRoKSwgb3B0aW9ucyk7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMua2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXMub3JpZ2luLmdldCh0aGlzLmtleXBhdGgpO1xuICBcdH0sXG5cbiAgXHRpbml0Vmlld21vZGVsOiBmdW5jdGlvbiAodmlld21vZGVsKSB7XG4gIFx0XHR0aGlzLmxvY2FsID0gdmlld21vZGVsO1xuICBcdFx0dGhpcy5zZXR1cCgpO1xuICBcdH0sXG5cbiAgXHRtYXA6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRpZiAodHlwZW9mIHRoaXMua2V5cGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmxvY2FsS2V5O1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIGtleXBhdGgucmVwbGFjZSh0aGlzLmxvY2FsS2V5LCB0aGlzLmtleXBhdGgpO1xuICBcdH0sXG5cbiAgXHRyZWdpc3RlcjogZnVuY3Rpb24gKGtleXBhdGgsIGRlcGVuZGFudCwgZ3JvdXApIHtcbiAgXHRcdHRoaXMuZGVwcy5wdXNoKHsga2V5cGF0aDoga2V5cGF0aCwgZGVwOiBkZXBlbmRhbnQsIGdyb3VwOiBncm91cCB9KTtcblxuICBcdFx0aWYgKHRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0dGhpcy5vcmlnaW4ucmVnaXN0ZXIodGhpcy5tYXAoa2V5cGF0aCksIGRlcGVuZGFudCwgZ3JvdXApO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZXNvbHZlOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMua2V5cGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMudW5iaW5kKHRydWUpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdFx0dGhpcy5zZXR1cCgpO1xuICBcdH0sXG5cbiAgXHRzZXQ6IGZ1bmN0aW9uIChrZXlwYXRoLCB2YWx1ZSkge1xuICBcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdHRoaXMuZm9yY2VSZXNvbHV0aW9uKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMub3JpZ2luLnNldCh0aGlzLm1hcChrZXlwYXRoKSwgdmFsdWUpO1xuICBcdH0sXG5cbiAgXHRzZXR1cDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0aWYgKHRoaXMua2V5cGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5yZXNvbHZlZCA9IHRydWU7XG5cbiAgXHRcdC8vIGFjY3VtdWxhdGVkIGRlcGVuZGFudHMgY2FuIG5vdyBiZSByZWdpc3RlcmVkXG4gIFx0XHRpZiAodGhpcy5kZXBzLmxlbmd0aCkge1xuICBcdFx0XHR0aGlzLmRlcHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHRcdHZhciBrZXlwYXRoID0gX3RoaXMubWFwKGQua2V5cGF0aCk7XG4gIFx0XHRcdFx0X3RoaXMub3JpZ2luLnJlZ2lzdGVyKGtleXBhdGgsIGQuZGVwLCBkLmdyb3VwKTtcblxuICBcdFx0XHRcdC8vIFRPRE8gdGhpcyBpcyBhIGJpdCBvZiBhIHJlZCBmbGFnLi4uIGFsbCBkZXBzIHNob3VsZCBiZSB0aGUgc2FtZT9cbiAgXHRcdFx0XHRpZiAoZC5kZXAuc2V0VmFsdWUpIHtcbiAgXHRcdFx0XHRcdGQuZGVwLnNldFZhbHVlKF90aGlzLm9yaWdpbi5nZXQoa2V5cGF0aCkpO1xuICBcdFx0XHRcdH0gZWxzZSBpZiAoZC5kZXAuaW52YWxpZGF0ZSkge1xuICBcdFx0XHRcdFx0ZC5kZXAuaW52YWxpZGF0ZSgpO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkLiBQbGVhc2UgcmFpc2UgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3VlcyAtIHRoYW5rcyFcIik7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9KTtcblxuICBcdFx0XHR0aGlzLm9yaWdpbi5tYXJrKHRoaXMua2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdGlmICghdGhpcy5rZXlwYXRoKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIk1hcHBpbmcgZG9lcyBub3QgaGF2ZSBrZXlwYXRoLCBjYW5ub3Qgc2V0IHZhbHVlLiBQbGVhc2UgcmFpc2UgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3VlcyAtIHRoYW5rcyFcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMub3JpZ2luLnNldCh0aGlzLmtleXBhdGgsIHZhbHVlKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoa2VlcExvY2FsKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHRpZiAoIWtlZXBMb2NhbCkge1xuICBcdFx0XHRkZWxldGUgdGhpcy5sb2NhbC5tYXBwaW5nc1t0aGlzLmxvY2FsS2V5XTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5kZXBzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgXHRcdFx0X3RoaXMub3JpZ2luLnVucmVnaXN0ZXIoX3RoaXMubWFwKGQua2V5cGF0aCksIGQuZGVwLCBkLmdyb3VwKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRpZiAodGhpcy50cmFja2VyKSB7XG4gIFx0XHRcdHRoaXMub3JpZ2luLnVucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzLnRyYWNrZXIpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlZ2lzdGVyOiBmdW5jdGlvbiAoa2V5cGF0aCwgZGVwZW5kYW50LCBncm91cCkge1xuICBcdFx0dmFyIGRlcHMsIGk7XG5cbiAgXHRcdGlmICghdGhpcy5yZXNvbHZlZCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGRlcHMgPSB0aGlzLmRlcHM7XG4gIFx0XHRpID0gZGVwcy5sZW5ndGg7XG5cbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0aWYgKGRlcHNbaV0uZGVwID09PSBkZXBlbmRhbnQpIHtcbiAgXHRcdFx0XHRkZXBzLnNwbGljZShpLCAxKTtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0dGhpcy5vcmlnaW4udW5yZWdpc3Rlcih0aGlzLm1hcChrZXlwYXRoKSwgZGVwZW5kYW50LCBncm91cCk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBtYXJrID0gVmlld21vZGVsJG1hcms7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJG1hcmsoa2V5cGF0aCwgb3B0aW9ucykge1xuICBcdHZhciBjb21wdXRhdGlvbixcbiAgXHQgICAga2V5cGF0aFN0ciA9IGtleXBhdGguc3RyO1xuXG4gIFx0Ly8gaW1wbGljaXQgY2hhbmdlcyAoaS5lLiBgZm9vLmxlbmd0aGAgb24gYHJhY3RpdmUucHVzaCgnZm9vJyw0MilgKVxuICBcdC8vIHNob3VsZCBub3QgYmUgcGlja2VkIHVwIGJ5IHBhdHRlcm4gb2JzZXJ2ZXJzXG4gIFx0aWYgKG9wdGlvbnMpIHtcbiAgXHRcdGlmIChvcHRpb25zLmltcGxpY2l0KSB7XG4gIFx0XHRcdHRoaXMuaW1wbGljaXRDaGFuZ2VzW2tleXBhdGhTdHJdID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHRcdGlmIChvcHRpb25zLm5vQ2FzY2FkZSkge1xuICBcdFx0XHR0aGlzLm5vQ2FzY2FkZVtrZXlwYXRoU3RyXSA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRhdGlvbnNba2V5cGF0aFN0cl0pIHtcbiAgXHRcdGNvbXB1dGF0aW9uLmludmFsaWRhdGUoKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5jaGFuZ2VzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xKSB7XG4gIFx0XHR0aGlzLmNoYW5nZXMucHVzaChrZXlwYXRoKTtcbiAgXHR9XG5cbiAgXHQvLyBwYXNzIG9uIGtlZXBFeGlzdGluZ1dyYXBwZXIsIGlmIHdlIGNhblxuICBcdHZhciBrZWVwRXhpc3RpbmdXcmFwcGVyID0gb3B0aW9ucyA/IG9wdGlvbnMua2VlcEV4aXN0aW5nV3JhcHBlciA6IGZhbHNlO1xuXG4gIFx0dGhpcy5jbGVhckNhY2hlKGtleXBhdGhTdHIsIGtlZXBFeGlzdGluZ1dyYXBwZXIpO1xuXG4gIFx0aWYgKHRoaXMucmVhZHkpIHtcbiAgXHRcdHRoaXMub25jaGFuZ2UoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgbWFwT2xkVG9OZXdJbmRleCA9IGZ1bmN0aW9uIChvbGRBcnJheSwgbmV3QXJyYXkpIHtcbiAgXHR2YXIgdXNlZEluZGljZXMsIGZpcnN0VW51c2VkSW5kZXgsIG5ld0luZGljZXMsIGNoYW5nZWQ7XG5cbiAgXHR1c2VkSW5kaWNlcyA9IHt9O1xuICBcdGZpcnN0VW51c2VkSW5kZXggPSAwO1xuXG4gIFx0bmV3SW5kaWNlcyA9IG9sZEFycmF5Lm1hcChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICBcdFx0dmFyIGluZGV4LCBzdGFydCwgbGVuO1xuXG4gIFx0XHRzdGFydCA9IGZpcnN0VW51c2VkSW5kZXg7XG4gIFx0XHRsZW4gPSBuZXdBcnJheS5sZW5ndGg7XG5cbiAgXHRcdGRvIHtcbiAgXHRcdFx0aW5kZXggPSBuZXdBcnJheS5pbmRleE9mKGl0ZW0sIHN0YXJ0KTtcblxuICBcdFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG4gIFx0XHRcdFx0cmV0dXJuIC0xO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0c3RhcnQgPSBpbmRleCArIDE7XG4gIFx0XHR9IHdoaWxlICh1c2VkSW5kaWNlc1tpbmRleF0gJiYgc3RhcnQgPCBsZW4pO1xuXG4gIFx0XHQvLyBrZWVwIHRyYWNrIG9mIHRoZSBmaXJzdCB1bnVzZWQgaW5kZXgsIHNvIHdlIGRvbid0IHNlYXJjaFxuICBcdFx0Ly8gdGhlIHdob2xlIG9mIG5ld0FycmF5IGZvciBlYWNoIGl0ZW0gaW4gb2xkQXJyYXkgdW5uZWNlc3NhcmlseVxuICBcdFx0aWYgKGluZGV4ID09PSBmaXJzdFVudXNlZEluZGV4KSB7XG4gIFx0XHRcdGZpcnN0VW51c2VkSW5kZXggKz0gMTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGluZGV4ICE9PSBpKSB7XG4gIFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHR1c2VkSW5kaWNlc1tpbmRleF0gPSB0cnVlO1xuICBcdFx0cmV0dXJuIGluZGV4O1xuICBcdH0pO1xuXG4gIFx0cmV0dXJuIG5ld0luZGljZXM7XG4gIH07XG5cbiAgdmFyIG1lcmdlID0gVmlld21vZGVsJG1lcmdlO1xuXG4gIHZhciBjb21wYXJhdG9ycyA9IHt9O1xuICBmdW5jdGlvbiBWaWV3bW9kZWwkbWVyZ2Uoa2V5cGF0aCwgY3VycmVudEFycmF5LCBhcnJheSwgb3B0aW9ucykge1xuICBcdHZhciBvbGRBcnJheSwgbmV3QXJyYXksIGNvbXBhcmF0b3IsIG5ld0luZGljZXM7XG5cbiAgXHR0aGlzLm1hcmsoa2V5cGF0aCk7XG5cbiAgXHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhcmUpIHtcblxuICBcdFx0Y29tcGFyYXRvciA9IGdldENvbXBhcmF0b3JGdW5jdGlvbihvcHRpb25zLmNvbXBhcmUpO1xuXG4gIFx0XHR0cnkge1xuICBcdFx0XHRvbGRBcnJheSA9IGN1cnJlbnRBcnJheS5tYXAoY29tcGFyYXRvcik7XG4gIFx0XHRcdG5ld0FycmF5ID0gYXJyYXkubWFwKGNvbXBhcmF0b3IpO1xuICBcdFx0fSBjYXRjaCAoZXJyKSB7XG4gIFx0XHRcdC8vIGZhbGxiYWNrIHRvIGFuIGlkZW50aXR5IGNoZWNrIC0gd29yc3QgY2FzZSBzY2VuYXJpbyB3ZSBoYXZlXG4gIFx0XHRcdC8vIHRvIGRvIG1vcmUgRE9NIG1hbmlwdWxhdGlvbiB0aGFuIHdlIHRob3VnaHQuLi5cbiAgXHRcdFx0d2FybklmRGVidWcoXCJtZXJnZSgpOiBcXFwiJXNcXFwiIGNvbXBhcmlzb24gZmFpbGVkLiBGYWxsaW5nIGJhY2sgdG8gaWRlbnRpdHkgY2hlY2tpbmdcIiwga2V5cGF0aCk7XG5cbiAgXHRcdFx0b2xkQXJyYXkgPSBjdXJyZW50QXJyYXk7XG4gIFx0XHRcdG5ld0FycmF5ID0gYXJyYXk7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5O1xuICBcdFx0bmV3QXJyYXkgPSBhcnJheTtcbiAgXHR9XG5cbiAgXHQvLyBmaW5kIG5ldyBpbmRpY2VzIGZvciBtZW1iZXJzIG9mIG9sZEFycmF5XG4gIFx0bmV3SW5kaWNlcyA9IG1hcE9sZFRvTmV3SW5kZXgob2xkQXJyYXksIG5ld0FycmF5KTtcblxuICBcdHRoaXMuc21hcnRVcGRhdGUoa2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMsIGN1cnJlbnRBcnJheS5sZW5ndGggIT09IGFycmF5Lmxlbmd0aCk7XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnkoaXRlbSkge1xuICBcdHJldHVybiBKU09OLnN0cmluZ2lmeShpdGVtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbXBhcmF0b3JGdW5jdGlvbihjb21wYXJhdG9yKSB7XG4gIFx0Ly8gSWYgYGNvbXBhcmVgIGlzIGB0cnVlYCwgd2UgdXNlIEpTT04uc3RyaW5naWZ5IHRvIGNvbXBhcmVcbiAgXHQvLyBvYmplY3RzIHRoYXQgYXJlIHRoZSBzYW1lIHNoYXBlLCBidXQgbm9uLWlkZW50aWNhbCAtIGkuZS5cbiAgXHQvLyB7IGZvbzogJ2JhcicgfSAhPT0geyBmb286ICdiYXInIH1cbiAgXHRpZiAoY29tcGFyYXRvciA9PT0gdHJ1ZSkge1xuICBcdFx0cmV0dXJuIHN0cmluZ2lmeTtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIGNvbXBhcmF0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGlmICghY29tcGFyYXRvcnNbY29tcGFyYXRvcl0pIHtcbiAgXHRcdFx0Y29tcGFyYXRvcnNbY29tcGFyYXRvcl0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0XHRcdHJldHVybiBpdGVtW2NvbXBhcmF0b3JdO1xuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gY29tcGFyYXRvcnNbY29tcGFyYXRvcl07XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiBjb21wYXJhdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdHJldHVybiBjb21wYXJhdG9yO1xuICBcdH1cblxuICBcdHRocm93IG5ldyBFcnJvcihcIlRoZSBgY29tcGFyZWAgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbiwgb3IgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGlkZW50aWZ5aW5nIGZpZWxkIChvciBgdHJ1ZWAgdG8gdXNlIEpTT04uc3RyaW5naWZ5KVwiKTtcbiAgfVxuXG4gIHZhciByZWdpc3RlciA9IFZpZXdtb2RlbCRyZWdpc3RlcjtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkcmVnaXN0ZXIoa2V5cGF0aCwgZGVwZW5kYW50KSB7XG4gIFx0dmFyIGdyb3VwID0gYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBcImRlZmF1bHRcIiA6IGFyZ3VtZW50c1syXTtcblxuICBcdHZhciBtYXBwaW5nLCBkZXBzQnlLZXlwYXRoLCBkZXBzO1xuXG4gIFx0aWYgKGRlcGVuZGFudC5pc1N0YXRpYykge1xuICBcdFx0cmV0dXJuOyAvLyBUT0RPIHdlIHNob3VsZCBuZXZlciBnZXQgaGVyZSBpZiBhIGRlcGVuZGFudCBpcyBzdGF0aWMuLi5cbiAgXHR9XG5cbiAgXHRpZiAobWFwcGluZyA9IHRoaXMubWFwcGluZ3Nba2V5cGF0aC5maXJzdEtleV0pIHtcbiAgXHRcdG1hcHBpbmcucmVnaXN0ZXIoa2V5cGF0aCwgZGVwZW5kYW50LCBncm91cCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGRlcHNCeUtleXBhdGggPSB0aGlzLmRlcHNbZ3JvdXBdIHx8ICh0aGlzLmRlcHNbZ3JvdXBdID0ge30pO1xuICBcdFx0ZGVwcyA9IGRlcHNCeUtleXBhdGhba2V5cGF0aC5zdHJdIHx8IChkZXBzQnlLZXlwYXRoW2tleXBhdGguc3RyXSA9IFtdKTtcblxuICBcdFx0ZGVwcy5wdXNoKGRlcGVuZGFudCk7XG5cbiAgXHRcdGlmICghdGhpcy5kZXBzTWFwW2dyb3VwXSkge1xuICBcdFx0XHR0aGlzLmRlcHNNYXBbZ3JvdXBdID0ge307XG4gIFx0XHR9XG5cbiAgXHRcdGlmICgha2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdFx0cmVnaXN0ZXJfX3VwZGF0ZURlcGVuZGFudHNNYXAodGhpcywga2V5cGF0aCwgZ3JvdXApO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyX191cGRhdGVEZXBlbmRhbnRzTWFwKHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXApIHtcbiAgXHR2YXIgbWFwLCBwYXJlbnQsIGtleXBhdGhTdHI7XG5cbiAgXHQvLyB1cGRhdGUgZGVwZW5kYW50cyBtYXBcbiAgXHR3aGlsZSAoIWtleXBhdGguaXNSb290KSB7XG4gIFx0XHRtYXAgPSB2aWV3bW9kZWwuZGVwc01hcFtncm91cF07XG4gIFx0XHRwYXJlbnQgPSBtYXBba2V5cGF0aC5wYXJlbnQuc3RyXSB8fCAobWFwW2tleXBhdGgucGFyZW50LnN0cl0gPSBbXSk7XG5cbiAgXHRcdGtleXBhdGhTdHIgPSBrZXlwYXRoLnN0cjtcblxuICBcdFx0Ly8gVE9ETyBmaW5kIGFuIGFsdGVybmF0aXZlIHRvIHRoaXMgbmFzdHkgYXBwcm9hY2hcbiAgXHRcdGlmIChwYXJlbnRbXCJfXCIgKyBrZXlwYXRoU3RyXSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHBhcmVudFtcIl9cIiArIGtleXBhdGhTdHJdID0gMDtcbiAgXHRcdFx0cGFyZW50LnB1c2goa2V5cGF0aCk7XG4gIFx0XHR9XG5cbiAgXHRcdHBhcmVudFtcIl9cIiArIGtleXBhdGhTdHJdICs9IDE7XG4gIFx0XHRrZXlwYXRoID0ga2V5cGF0aC5wYXJlbnQ7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHJlbGVhc2UgPSBWaWV3bW9kZWwkcmVsZWFzZTtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkcmVsZWFzZSgpIHtcbiAgXHRyZXR1cm4gdGhpcy5jYXB0dXJlR3JvdXBzLnBvcCgpO1xuICB9XG5cbiAgdmFyIHJlc2V0ID0gVmlld21vZGVsJHJlc2V0O1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRyZXNldChkYXRhKSB7XG4gIFx0dGhpcy5kYXRhID0gZGF0YTtcbiAgXHR0aGlzLmNsZWFyQ2FjaGUoXCJcIik7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3NldCA9IFZpZXdtb2RlbCRzZXQ7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJHNldChrZXlwYXRoLCB2YWx1ZSkge1xuICBcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1syXTtcblxuICBcdHZhciBtYXBwaW5nLCBjb21wdXRhdGlvbiwgd3JhcHBlciwga2VlcEV4aXN0aW5nV3JhcHBlcjtcblxuICBcdC8vIHVubGVzcyBkYXRhIGlzIGJlaW5nIHNldCBmb3IgZGF0YSB0cmFja2luZyBwdXJwb3Nlc1xuICBcdGlmICghb3B0aW9ucy5ub01hcHBpbmcpIHtcbiAgXHRcdC8vIElmIHRoaXMgZGF0YSBiZWxvbmdzIHRvIGEgZGlmZmVyZW50IHZpZXdtb2RlbCxcbiAgXHRcdC8vIHBhc3MgdGhlIGNoYW5nZSBhbG9uZ1xuICBcdFx0aWYgKG1hcHBpbmcgPSB0aGlzLm1hcHBpbmdzW2tleXBhdGguZmlyc3RLZXldKSB7XG4gIFx0XHRcdHJldHVybiBtYXBwaW5nLnNldChrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Y29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1trZXlwYXRoLnN0cl07XG4gIFx0aWYgKGNvbXB1dGF0aW9uKSB7XG4gIFx0XHRpZiAoY29tcHV0YXRpb24uc2V0dGluZykge1xuICBcdFx0XHQvLyBsZXQgdGhlIG90aGVyIGNvbXB1dGF0aW9uIHNldCgpIGhhbmRsZSB0aGluZ3MuLi5cbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdFx0Y29tcHV0YXRpb24uc2V0KHZhbHVlKTtcbiAgXHRcdHZhbHVlID0gY29tcHV0YXRpb24uZ2V0KCk7XG4gIFx0fVxuXG4gIFx0aWYgKGlzRXF1YWwodGhpcy5jYWNoZVtrZXlwYXRoLnN0cl0sIHZhbHVlKSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHdyYXBwZXIgPSB0aGlzLndyYXBwZWRba2V5cGF0aC5zdHJdO1xuXG4gIFx0Ly8gSWYgd2UgaGF2ZSBhIHdyYXBwZXIgd2l0aCBhIGByZXNldCgpYCBtZXRob2QsIHdlIHRyeSBhbmQgdXNlIGl0LiBJZiB0aGVcbiAgXHQvLyBgcmVzZXQoKWAgbWV0aG9kIHJldHVybnMgZmFsc2UsIHRoZSB3cmFwcGVyIHNob3VsZCBiZSB0b3JuIGRvd24sIGFuZFxuICBcdC8vIChtb3N0IGxpa2VseSkgYSBuZXcgb25lIHNob3VsZCBiZSBjcmVhdGVkIGxhdGVyXG4gIFx0aWYgKHdyYXBwZXIgJiYgd3JhcHBlci5yZXNldCkge1xuICBcdFx0a2VlcEV4aXN0aW5nV3JhcHBlciA9IHdyYXBwZXIucmVzZXQodmFsdWUpICE9PSBmYWxzZTtcblxuICBcdFx0aWYgKGtlZXBFeGlzdGluZ1dyYXBwZXIpIHtcbiAgXHRcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICghY29tcHV0YXRpb24gJiYgIWtlZXBFeGlzdGluZ1dyYXBwZXIpIHtcbiAgXHRcdHJlc29sdmVTZXQodGhpcywga2V5cGF0aCwgdmFsdWUpO1xuICBcdH1cblxuICBcdGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgXHRcdHRoaXMubWFyayhrZXlwYXRoKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gV2UncmUgc2V0dGluZyBhIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdGFyZ2V0IGtleXBhdGggKGkuZS5cbiAgXHRcdC8vIGNyZWF0aW5nIGEgZnJlc2ggYnJhbmNoKSAtIHdlIG5lZWQgdG8gY2xlYXIgdGhlIGNhY2hlLCBidXRcbiAgXHRcdC8vIG5vdCBtYXJrIGl0IGFzIGEgY2hhbmdlXG4gIFx0XHR0aGlzLmNsZWFyQ2FjaGUoa2V5cGF0aC5zdHIpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVTZXQodmlld21vZGVsLCBrZXlwYXRoLCB2YWx1ZSkge1xuICBcdHZhciB3cmFwcGVyLCBwYXJlbnRWYWx1ZSwgd3JhcHBlclNldCwgdmFsdWVTZXQ7XG5cbiAgXHR3cmFwcGVyU2V0ID0gZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHdyYXBwZXIuc2V0KSB7XG4gIFx0XHRcdHdyYXBwZXIuc2V0KGtleXBhdGgubGFzdEtleSwgdmFsdWUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyZW50VmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuICBcdFx0XHR2YWx1ZVNldCgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHR2YWx1ZVNldCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghcGFyZW50VmFsdWUpIHtcbiAgXHRcdFx0cGFyZW50VmFsdWUgPSBjcmVhdGVCcmFuY2goa2V5cGF0aC5sYXN0S2V5KTtcbiAgXHRcdFx0dmlld21vZGVsLnNldChrZXlwYXRoLnBhcmVudCwgcGFyZW50VmFsdWUsIHsgc2lsZW50OiB0cnVlIH0pO1xuICBcdFx0fVxuICBcdFx0cGFyZW50VmFsdWVba2V5cGF0aC5sYXN0S2V5XSA9IHZhbHVlO1xuICBcdH07XG5cbiAgXHR3cmFwcGVyID0gdmlld21vZGVsLndyYXBwZWRba2V5cGF0aC5wYXJlbnQuc3RyXTtcblxuICBcdGlmICh3cmFwcGVyKSB7XG4gIFx0XHR3cmFwcGVyU2V0KCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHBhcmVudFZhbHVlID0gdmlld21vZGVsLmdldChrZXlwYXRoLnBhcmVudCk7XG5cbiAgXHRcdC8vIG1heSBoYXZlIGJlZW4gd3JhcHBlZCB2aWEgdGhlIGFib3ZlIC5nZXQoKVxuICBcdFx0Ly8gY2FsbCBvbiB2aWV3bW9kZWwgaWYgdGhpcyBpcyBmaXJzdCBhY2Nlc3MgdmlhIC5zZXQoKSFcbiAgXHRcdGlmICh3cmFwcGVyID0gdmlld21vZGVsLndyYXBwZWRba2V5cGF0aC5wYXJlbnQuc3RyXSkge1xuICBcdFx0XHR3cmFwcGVyU2V0KCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR2YWx1ZVNldCgpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBzbWFydFVwZGF0ZSA9IFZpZXdtb2RlbCRzbWFydFVwZGF0ZTtcblxuICB2YXIgaW1wbGljaXRPcHRpb24gPSB7IGltcGxpY2l0OiB0cnVlIH0sXG4gICAgICBub0Nhc2NhZGVPcHRpb24gPSB7IG5vQ2FzY2FkZTogdHJ1ZSB9O1xuICBmdW5jdGlvbiBWaWV3bW9kZWwkc21hcnRVcGRhdGUoa2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIGRlcGVuZGFudHMsIG9sZExlbmd0aCwgaTtcblxuICBcdG9sZExlbmd0aCA9IG5ld0luZGljZXMubGVuZ3RoO1xuXG4gIFx0Ly8gSW5kaWNlcyB0aGF0IGFyZSBiZWluZyByZW1vdmVkIHNob3VsZCBiZSBtYXJrZWQgYXMgZGlydHlcbiAgXHRuZXdJbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKG5ld0luZGV4LCBvbGRJbmRleCkge1xuICBcdFx0aWYgKG5ld0luZGV4ID09PSAtMSkge1xuICBcdFx0XHRfdGhpcy5tYXJrKGtleXBhdGguam9pbihvbGRJbmRleCksIG5vQ2FzY2FkZU9wdGlvbik7XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHQvLyBVcGRhdGUgdGhlIG1vZGVsXG4gIFx0Ly8gVE9ETyBhbGxvdyBleGlzdGluZyBhcnJheSB0byBiZSB1cGRhdGVkIGluIHBsYWNlLCByYXRoZXIgdGhhbiByZXBsYWNlZD9cbiAgXHR0aGlzLnNldChrZXlwYXRoLCBhcnJheSwgeyBzaWxlbnQ6IHRydWUgfSk7XG5cbiAgXHRpZiAoZGVwZW5kYW50cyA9IHRoaXMuZGVwc1tcImRlZmF1bHRcIl1ba2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRkZXBlbmRhbnRzLmZpbHRlcihjYW5TaHVmZmxlKS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gIFx0XHRcdHJldHVybiBkLnNodWZmbGUobmV3SW5kaWNlcywgYXJyYXkpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0aWYgKG9sZExlbmd0aCAhPT0gYXJyYXkubGVuZ3RoKSB7XG4gIFx0XHR0aGlzLm1hcmsoa2V5cGF0aC5qb2luKFwibGVuZ3RoXCIpLCBpbXBsaWNpdE9wdGlvbik7XG5cbiAgXHRcdGZvciAoaSA9IG5ld0luZGljZXMudG91Y2hlZEZyb207IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0XHR0aGlzLm1hcmsoa2V5cGF0aC5qb2luKGkpKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gZG9uJ3QgYWxsb3cgcmVtb3ZlZCBpbmRleGVzIGJleW9uZCBlbmQgb2YgbmV3IGFycmF5IHRvIHRyaWdnZXIgcmVjb21wdXRhdGlvbnNcbiAgXHRcdC8vIFRPRE8gaXMgdGhpcyBzdGlsbCBuZWNlc3NhcnksIG5vdyB0aGF0IGNvbXB1dGF0aW9ucyBhcmUgbGF6eT9cbiAgXHRcdGZvciAoaSA9IGFycmF5Lmxlbmd0aDsgaSA8IG9sZExlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdHRoaXMubWFyayhrZXlwYXRoLmpvaW4oaSksIG5vQ2FzY2FkZU9wdGlvbik7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gY2FuU2h1ZmZsZShkZXBlbmRhbnQpIHtcbiAgXHRyZXR1cm4gdHlwZW9mIGRlcGVuZGFudC5zaHVmZmxlID09PSBcImZ1bmN0aW9uXCI7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3RlYXJkb3duID0gVmlld21vZGVsJHRlYXJkb3duO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCR0ZWFyZG93bigpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3k7XG5cbiAgXHQvLyBDbGVhciBlbnRpcmUgY2FjaGUgLSB0aGlzIGhhcyB0aGUgZGVzaXJlZCBzaWRlLWVmZmVjdFxuICBcdC8vIG9mIHVud3JhcHBpbmcgYWRhcHRlZCB2YWx1ZXMgKGUuZy4gYXJyYXlzKVxuICBcdE9iamVjdC5rZXlzKHRoaXMuY2FjaGUpLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHJldHVybiBfdGhpcy5jbGVhckNhY2hlKGtleXBhdGgpO1xuICBcdH0pO1xuXG4gIFx0Ly8gVGVhcmRvd24gYW55IGZhaWxlZCBsb29rdXBzIC0gd2UgZG9uJ3QgbmVlZCB0aGVtIHRvIHJlc29sdmUgYW55IG1vcmVcbiAgXHR3aGlsZSAodW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSA9IHRoaXMudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzLnBvcCgpKSB7XG4gIFx0XHR1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5LnRlYXJkb3duKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVucmVnaXN0ZXIgPSBWaWV3bW9kZWwkdW5yZWdpc3RlcjtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkdW5yZWdpc3RlcihrZXlwYXRoLCBkZXBlbmRhbnQpIHtcbiAgXHR2YXIgZ3JvdXAgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IFwiZGVmYXVsdFwiIDogYXJndW1lbnRzWzJdO1xuXG4gIFx0dmFyIG1hcHBpbmcsIGRlcHMsIGluZGV4O1xuXG4gIFx0aWYgKGRlcGVuZGFudC5pc1N0YXRpYykge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmIChtYXBwaW5nID0gdGhpcy5tYXBwaW5nc1trZXlwYXRoLmZpcnN0S2V5XSkge1xuICBcdFx0cmV0dXJuIG1hcHBpbmcudW5yZWdpc3RlcihrZXlwYXRoLCBkZXBlbmRhbnQsIGdyb3VwKTtcbiAgXHR9XG5cbiAgXHRkZXBzID0gdGhpcy5kZXBzW2dyb3VwXVtrZXlwYXRoLnN0cl07XG4gIFx0aW5kZXggPSBkZXBzLmluZGV4T2YoZGVwZW5kYW50KTtcblxuICBcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byByZW1vdmUgYSBkZXBlbmRhbnQgdGhhdCB3YXMgbm8gbG9uZ2VyIHJlZ2lzdGVyZWQhIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4uIElmIHlvdSBhcmUgc2VlaW5nIHRoaXMgYnVnIGluIGRldmVsb3BtZW50IHBsZWFzZSByYWlzZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vUmFjdGl2ZUpTL1JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzXCIpO1xuICBcdH1cblxuICBcdGRlcHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICBcdGlmIChrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHVucmVnaXN0ZXJfX3VwZGF0ZURlcGVuZGFudHNNYXAodGhpcywga2V5cGF0aCwgZ3JvdXApO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5yZWdpc3Rlcl9fdXBkYXRlRGVwZW5kYW50c01hcCh2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwKSB7XG4gIFx0dmFyIG1hcCwgcGFyZW50O1xuXG4gIFx0Ly8gdXBkYXRlIGRlcGVuZGFudHMgbWFwXG4gIFx0d2hpbGUgKCFrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0bWFwID0gdmlld21vZGVsLmRlcHNNYXBbZ3JvdXBdO1xuICBcdFx0cGFyZW50ID0gbWFwW2tleXBhdGgucGFyZW50LnN0cl07XG5cbiAgXHRcdHBhcmVudFtcIl9cIiArIGtleXBhdGguc3RyXSAtPSAxO1xuXG4gIFx0XHRpZiAoIXBhcmVudFtcIl9cIiArIGtleXBhdGguc3RyXSkge1xuICBcdFx0XHQvLyByZW1vdmUgZnJvbSBwYXJlbnQgZGVwcyBtYXBcbiAgXHRcdFx0cmVtb3ZlRnJvbUFycmF5KHBhcmVudCwga2V5cGF0aCk7XG4gIFx0XHRcdHBhcmVudFtcIl9cIiArIGtleXBhdGguc3RyXSA9IHVuZGVmaW5lZDtcbiAgXHRcdH1cblxuICBcdFx0a2V5cGF0aCA9IGtleXBhdGgucGFyZW50O1xuICBcdH1cbiAgfVxuXG4gIHZhciBWaWV3bW9kZWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHZhciBhZGFwdCA9IG9wdGlvbnMuYWRhcHQ7XG4gIFx0dmFyIGRhdGEgPSBvcHRpb25zLmRhdGE7XG4gIFx0dmFyIHJhY3RpdmUgPSBvcHRpb25zLnJhY3RpdmU7XG4gIFx0dmFyIGNvbXB1dGVkID0gb3B0aW9ucy5jb21wdXRlZDtcbiAgXHR2YXIgbWFwcGluZ3MgPSBvcHRpb25zLm1hcHBpbmdzO1xuICBcdHZhciBrZXk7XG4gIFx0dmFyIG1hcHBpbmc7XG5cbiAgXHQvLyBUT0RPIGlzIGl0IHBvc3NpYmxlIHRvIHJlbW92ZSB0aGlzIHJlZmVyZW5jZT9cbiAgXHR0aGlzLnJhY3RpdmUgPSByYWN0aXZlO1xuXG4gIFx0dGhpcy5hZGFwdG9ycyA9IGFkYXB0O1xuICBcdHRoaXMub25jaGFuZ2UgPSBvcHRpb25zLm9uY2hhbmdlO1xuXG4gIFx0dGhpcy5jYWNoZSA9IHt9OyAvLyB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gdXNlIGhhc093blByb3BlcnR5LCBzbyBjYW4ndCBpbmhlcml0IGZyb20gbnVsbFxuICBcdHRoaXMuY2FjaGVNYXAgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHR0aGlzLmRlcHMgPSB7XG4gIFx0XHRjb21wdXRlZDogY3JlYXRlKG51bGwpLFxuICBcdFx0XCJkZWZhdWx0XCI6IGNyZWF0ZShudWxsKVxuICBcdH07XG4gIFx0dGhpcy5kZXBzTWFwID0ge1xuICBcdFx0Y29tcHV0ZWQ6IGNyZWF0ZShudWxsKSxcbiAgXHRcdFwiZGVmYXVsdFwiOiBjcmVhdGUobnVsbClcbiAgXHR9O1xuXG4gIFx0dGhpcy5wYXR0ZXJuT2JzZXJ2ZXJzID0gW107XG5cbiAgXHR0aGlzLnNwZWNpYWxzID0gY3JlYXRlKG51bGwpO1xuXG4gIFx0dGhpcy53cmFwcGVkID0gY3JlYXRlKG51bGwpO1xuICBcdHRoaXMuY29tcHV0YXRpb25zID0gY3JlYXRlKG51bGwpO1xuXG4gIFx0dGhpcy5jYXB0dXJlR3JvdXBzID0gW107XG4gIFx0dGhpcy51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMgPSBbXTtcblxuICBcdHRoaXMuY2hhbmdlcyA9IFtdO1xuICBcdHRoaXMuaW1wbGljaXRDaGFuZ2VzID0ge307XG4gIFx0dGhpcy5ub0Nhc2NhZGUgPSB7fTtcblxuICBcdHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgXHQvLyBzZXQgdXAgZXhwbGljaXQgbWFwcGluZ3NcbiAgXHR0aGlzLm1hcHBpbmdzID0gY3JlYXRlKG51bGwpO1xuICBcdGZvciAoa2V5IGluIG1hcHBpbmdzKSB7XG4gIFx0XHR0aGlzLm1hcChnZXRLZXlwYXRoKGtleSksIG1hcHBpbmdzW2tleV0pO1xuICBcdH1cblxuICBcdGlmIChkYXRhKSB7XG4gIFx0XHQvLyBpZiBkYXRhIGV4aXN0cyBsb2NhbGx5LCBidXQgaXMgbWlzc2luZyBvbiB0aGUgcGFyZW50LFxuICBcdFx0Ly8gd2UgdHJhbnNmZXIgb3duZXJzaGlwIHRvIHRoZSBwYXJlbnRcbiAgXHRcdGZvciAoa2V5IGluIGRhdGEpIHtcbiAgXHRcdFx0aWYgKChtYXBwaW5nID0gdGhpcy5tYXBwaW5nc1trZXldKSAmJiBtYXBwaW5nLmdldFZhbHVlKCkgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdG1hcHBpbmcuc2V0VmFsdWUoZGF0YVtrZXldKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdGZvciAoa2V5IGluIGNvbXB1dGVkKSB7XG4gIFx0XHRpZiAobWFwcGluZ3MgJiYga2V5IGluIG1hcHBpbmdzKSB7XG4gIFx0XHRcdGZhdGFsKFwiQ2Fubm90IG1hcCB0byBhIGNvbXB1dGVkIHByb3BlcnR5ICgnJXMnKVwiLCBrZXkpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmNvbXB1dGUoZ2V0S2V5cGF0aChrZXkpLCBjb21wdXRlZFtrZXldKTtcbiAgXHR9XG5cbiAgXHR0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgfTtcblxuICBWaWV3bW9kZWwucHJvdG90eXBlID0ge1xuICBcdGFkYXB0OiBwcm90b3R5cGVfYWRhcHQsXG4gIFx0YXBwbHlDaGFuZ2VzOiBhcHBseUNoYW5nZXMsXG4gIFx0Y2FwdHVyZTogY2FwdHVyZSxcbiAgXHRjbGVhckNhY2hlOiBjbGVhckNhY2hlLFxuICBcdGNvbXB1dGU6IGNvbXB1dGUsXG4gIFx0Z2V0OiB2aWV3bW9kZWxfcHJvdG90eXBlX2dldCxcbiAgXHRpbml0OiB2aWV3bW9kZWxfcHJvdG90eXBlX2luaXQsXG4gIFx0bWFwOiBwcm90b3R5cGVfbWFwLFxuICBcdG1hcms6IG1hcmssXG4gIFx0bWVyZ2U6IG1lcmdlLFxuICBcdHJlZ2lzdGVyOiByZWdpc3RlcixcbiAgXHRyZWxlYXNlOiByZWxlYXNlLFxuICBcdHJlc2V0OiByZXNldCxcbiAgXHRzZXQ6IHByb3RvdHlwZV9zZXQsXG4gIFx0c21hcnRVcGRhdGU6IHNtYXJ0VXBkYXRlLFxuICBcdHRlYXJkb3duOiBwcm90b3R5cGVfdGVhcmRvd24sXG4gIFx0dW5yZWdpc3RlcjogdW5yZWdpc3RlclxuICB9O1xuXG4gIHZhciB2aWV3bW9kZWxfVmlld21vZGVsID0gVmlld21vZGVsO1xuXG4gIGZ1bmN0aW9uIEhvb2tRdWV1ZShldmVudCkge1xuICBcdHRoaXMuaG9vayA9IG5ldyBob29rc19Ib29rKGV2ZW50KTtcbiAgXHR0aGlzLmluUHJvY2VzcyA9IHt9O1xuICBcdHRoaXMucXVldWUgPSB7fTtcbiAgfVxuXG4gIEhvb2tRdWV1ZS5wcm90b3R5cGUgPSB7XG5cbiAgXHRjb25zdHJ1Y3RvcjogSG9va1F1ZXVlLFxuXG4gIFx0YmVnaW46IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG4gIFx0XHR0aGlzLmluUHJvY2Vzc1tyYWN0aXZlLl9ndWlkXSA9IHRydWU7XG4gIFx0fSxcblxuICBcdGVuZDogZnVuY3Rpb24gKHJhY3RpdmUpIHtcblxuICBcdFx0dmFyIHBhcmVudCA9IHJhY3RpdmUucGFyZW50O1xuXG4gIFx0XHQvLyBJZiB0aGlzIGlzICppc24ndCogYSBjaGlsZCBvZiBhIGNvbXBvbmVudCB0aGF0J3MgaW4gcHJvY2VzcyxcbiAgXHRcdC8vIGl0IHNob3VsZCBjYWxsIG1ldGhvZHMgb3IgZmlyZSBhdCB0aGlzIHBvaW50XG4gIFx0XHRpZiAoIXBhcmVudCB8fCAhdGhpcy5pblByb2Nlc3NbcGFyZW50Ll9ndWlkXSkge1xuICBcdFx0XHRmaXJlKHRoaXMsIHJhY3RpdmUpO1xuICBcdFx0fVxuICBcdFx0Ly8gZWxzZXdpc2UsIGhhbmRvZmYgdG8gcGFyZW50IHRvIGZpcmUgd2hlbiByZWFkeVxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdGdldENoaWxkUXVldWUodGhpcy5xdWV1ZSwgcGFyZW50KS5wdXNoKHJhY3RpdmUpO1xuICBcdFx0fVxuXG4gIFx0XHRkZWxldGUgdGhpcy5pblByb2Nlc3NbcmFjdGl2ZS5fZ3VpZF07XG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldENoaWxkUXVldWUocXVldWUsIHJhY3RpdmUpIHtcbiAgXHRyZXR1cm4gcXVldWVbcmFjdGl2ZS5fZ3VpZF0gfHwgKHF1ZXVlW3JhY3RpdmUuX2d1aWRdID0gW10pO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZShob29rUXVldWUsIHJhY3RpdmUpIHtcblxuICBcdHZhciBjaGlsZFF1ZXVlID0gZ2V0Q2hpbGRRdWV1ZShob29rUXVldWUucXVldWUsIHJhY3RpdmUpO1xuXG4gIFx0aG9va1F1ZXVlLmhvb2suZmlyZShyYWN0aXZlKTtcblxuICBcdC8vIHF1ZXVlIGlzIFwibGl2ZVwiIGJlY2F1c2UgY29tcG9uZW50cyBjYW4gZW5kIHVwIGJlaW5nXG4gIFx0Ly8gYWRkZWQgd2hpbGUgaG9va3MgZmlyZSBvbiBwYXJlbnRzIHRoYXQgbW9kaWZ5IGRhdGEgdmFsdWVzLlxuICBcdHdoaWxlIChjaGlsZFF1ZXVlLmxlbmd0aCkge1xuICBcdFx0ZmlyZShob29rUXVldWUsIGNoaWxkUXVldWUuc2hpZnQoKSk7XG4gIFx0fVxuXG4gIFx0ZGVsZXRlIGhvb2tRdWV1ZS5xdWV1ZVtyYWN0aXZlLl9ndWlkXTtcbiAgfVxuXG4gIHZhciBob29rc19Ib29rUXVldWUgPSBIb29rUXVldWU7XG5cbiAgdmFyIGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzID0gZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzO1xuXG4gIHZhciBoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlc19fcGF0dGVybiA9IC9cXCRcXHsoW15cXH1dKylcXH0vZztcbiAgZnVuY3Rpb24gZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzKHJhY3RpdmUsIGNvbXB1dGVkKSB7XG4gIFx0dmFyIHNpZ25hdHVyZXMgPSB7fSxcbiAgXHQgICAga2V5O1xuXG4gIFx0Zm9yIChrZXkgaW4gY29tcHV0ZWQpIHtcbiAgXHRcdHNpZ25hdHVyZXNba2V5XSA9IGdldENvbXB1dGF0aW9uU2lnbmF0dXJlKHJhY3RpdmUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHNpZ25hdHVyZXM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb21wdXRhdGlvblNpZ25hdHVyZShyYWN0aXZlLCBrZXksIHNpZ25hdHVyZSkge1xuICBcdHZhciBnZXR0ZXIsIHNldHRlcjtcblxuICBcdGlmICh0eXBlb2Ygc2lnbmF0dXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdGdldHRlciA9IGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzX19iaW5kKHNpZ25hdHVyZSwgcmFjdGl2ZSk7XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiBzaWduYXR1cmUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGdldHRlciA9IGNyZWF0ZUZ1bmN0aW9uRnJvbVN0cmluZyhyYWN0aXZlLCBzaWduYXR1cmUpO1xuICBcdH1cblxuICBcdGlmICh0eXBlb2Ygc2lnbmF0dXJlID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRpZiAodHlwZW9mIHNpZ25hdHVyZS5nZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0Z2V0dGVyID0gY3JlYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKHJhY3RpdmUsIHNpZ25hdHVyZS5nZXQpO1xuICBcdFx0fSBlbHNlIGlmICh0eXBlb2Ygc2lnbmF0dXJlLmdldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdGdldHRlciA9IGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzX19iaW5kKHNpZ25hdHVyZS5nZXQsIHJhY3RpdmUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZmF0YWwoXCJgJXNgIGNvbXB1dGF0aW9uIG11c3QgaGF2ZSBhIGBnZXQoKWAgbWV0aG9kXCIsIGtleSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0eXBlb2Ygc2lnbmF0dXJlLnNldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdHNldHRlciA9IGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzX19iaW5kKHNpZ25hdHVyZS5zZXQsIHJhY3RpdmUpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB7IGdldHRlcjogZ2V0dGVyLCBzZXR0ZXI6IHNldHRlciB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKHJhY3RpdmUsIHN0cikge1xuICBcdHZhciBmdW5jdGlvbkJvZHksIGhhc1RoaXMsIGZuO1xuXG4gIFx0ZnVuY3Rpb25Cb2R5ID0gXCJyZXR1cm4gKFwiICsgc3RyLnJlcGxhY2UoaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX3BhdHRlcm4sIGZ1bmN0aW9uIChtYXRjaCwga2V5cGF0aCkge1xuICBcdFx0aGFzVGhpcyA9IHRydWU7XG4gIFx0XHRyZXR1cm4gXCJfX3JhY3RpdmUuZ2V0KFxcXCJcIiArIGtleXBhdGggKyBcIlxcXCIpXCI7XG4gIFx0fSkgKyBcIik7XCI7XG5cbiAgXHRpZiAoaGFzVGhpcykge1xuICBcdFx0ZnVuY3Rpb25Cb2R5ID0gXCJ2YXIgX19yYWN0aXZlID0gdGhpczsgXCIgKyBmdW5jdGlvbkJvZHk7XG4gIFx0fVxuXG4gIFx0Zm4gPSBuZXcgRnVuY3Rpb24oZnVuY3Rpb25Cb2R5KTtcbiAgXHRyZXR1cm4gaGFzVGhpcyA/IGZuLmJpbmQocmFjdGl2ZSkgOiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzX19iaW5kKGZuLCBjb250ZXh0KSB7XG4gIFx0cmV0dXJuIC90aGlzLy50ZXN0KGZuLnRvU3RyaW5nKCkpID8gZm4uYmluZChjb250ZXh0KSA6IGZuO1xuICB9XG5cbiAgdmFyIGNvbnN0cnVjdEhvb2sgPSBuZXcgaG9va3NfSG9vayhcImNvbnN0cnVjdFwiKTtcbiAgdmFyIGNvbmZpZ0hvb2sgPSBuZXcgaG9va3NfSG9vayhcImNvbmZpZ1wiKTtcbiAgdmFyIGluaXRIb29rID0gbmV3IGhvb2tzX0hvb2tRdWV1ZShcImluaXRcIik7XG4gIHZhciBpbml0aWFsaXNlX191aWQgPSAwO1xuXG4gIHZhciBpbml0aWFsaXNlX19yZWdpc3RyeU5hbWVzID0gW1wiYWRhcHRvcnNcIiwgXCJjb21wb25lbnRzXCIsIFwiZGVjb3JhdG9yc1wiLCBcImVhc2luZ1wiLCBcImV2ZW50c1wiLCBcImludGVycG9sYXRvcnNcIiwgXCJwYXJ0aWFsc1wiLCBcInRyYW5zaXRpb25zXCJdO1xuXG4gIHZhciBpbml0aWFsaXNlID0gaW5pdGlhbGlzZVJhY3RpdmVJbnN0YW5jZTtcblxuICBmdW5jdGlvbiBpbml0aWFsaXNlUmFjdGl2ZUluc3RhbmNlKHJhY3RpdmUpIHtcbiAgXHR2YXIgdXNlck9wdGlvbnMgPSBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuICBcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1syXTtcblxuICBcdHZhciBlbCwgdmlld21vZGVsO1xuXG4gIFx0aWYgKF9SYWN0aXZlLkRFQlVHKSB7XG4gIFx0XHR3ZWxjb21lKCk7XG4gIFx0fVxuXG4gIFx0aW5pdGlhbGlzZVByb3BlcnRpZXMocmFjdGl2ZSwgb3B0aW9ucyk7XG5cbiAgXHQvLyBUT0RPIHJlbW92ZSB0aGlzLCBldmVudHVhbGx5XG4gIFx0ZGVmaW5lUHJvcGVydHkocmFjdGl2ZSwgXCJkYXRhXCIsIHsgZ2V0OiBkZXByZWNhdGVSYWN0aXZlRGF0YSB9KTtcblxuICBcdC8vIFRPRE8gZG9uJ3QgYWxsb3cgYG9uY29uc3RydWN0YCB3aXRoIGBuZXcgUmFjdGl2ZSgpYCwgdGhlcmUncyBubyBuZWVkIGZvciBpdFxuICBcdGNvbnN0cnVjdEhvb2suZmlyZShyYWN0aXZlLCB1c2VyT3B0aW9ucyk7XG5cbiAgXHQvLyBBZGQgcmVnaXN0cmllc1xuICBcdGluaXRpYWxpc2VfX3JlZ2lzdHJ5TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0cmFjdGl2ZVtuYW1lXSA9IHV0aWxzX29iamVjdF9fZXh0ZW5kKGNyZWF0ZShyYWN0aXZlLmNvbnN0cnVjdG9yW25hbWVdIHx8IG51bGwpLCB1c2VyT3B0aW9uc1tuYW1lXSk7XG4gIFx0fSk7XG5cbiAgXHQvLyBDcmVhdGUgYSB2aWV3bW9kZWxcbiAgXHR2aWV3bW9kZWwgPSBuZXcgdmlld21vZGVsX1ZpZXdtb2RlbCh7XG4gIFx0XHRhZGFwdDogZ2V0QWRhcHRvcnMocmFjdGl2ZSwgcmFjdGl2ZS5hZGFwdCwgdXNlck9wdGlvbnMpLFxuICBcdFx0ZGF0YTogY3VzdG9tX2RhdGEuaW5pdChyYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCB1c2VyT3B0aW9ucyksXG4gIFx0XHRjb21wdXRlZDogaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXMocmFjdGl2ZSwgdXRpbHNfb2JqZWN0X19leHRlbmQoY3JlYXRlKHJhY3RpdmUuY29uc3RydWN0b3IucHJvdG90eXBlLmNvbXB1dGVkKSwgdXNlck9wdGlvbnMuY29tcHV0ZWQpKSxcbiAgXHRcdG1hcHBpbmdzOiBvcHRpb25zLm1hcHBpbmdzLFxuICBcdFx0cmFjdGl2ZTogcmFjdGl2ZSxcbiAgXHRcdG9uY2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiBnbG9iYWxfcnVubG9vcC5hZGRSYWN0aXZlKHJhY3RpdmUpO1xuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0cmFjdGl2ZS52aWV3bW9kZWwgPSB2aWV3bW9kZWw7XG5cbiAgXHQvLyBUaGlzIGNhbid0IGhhcHBlbiBlYXJsaWVyLCBiZWNhdXNlIGNvbXB1dGVkIHByb3BlcnRpZXMgbWF5IGNhbGwgYHJhY3RpdmUuZ2V0KClgLCBldGNcbiAgXHR2aWV3bW9kZWwuaW5pdCgpO1xuXG4gIFx0Ly8gaW5pdCBjb25maWcgZnJvbSBQYXJlbnQgYW5kIG9wdGlvbnNcbiAgXHRjb25maWdfY29uZmlnLmluaXQocmFjdGl2ZS5jb25zdHJ1Y3RvciwgcmFjdGl2ZSwgdXNlck9wdGlvbnMpO1xuXG4gIFx0Y29uZmlnSG9vay5maXJlKHJhY3RpdmUpO1xuICBcdGluaXRIb29rLmJlZ2luKHJhY3RpdmUpO1xuXG4gIFx0Ly8gLy8gSWYgdGhpcyBpcyBhIGNvbXBvbmVudCB3aXRoIGEgZnVuY3Rpb24gYGRhdGFgIHByb3BlcnR5LCBjYWxsIHRoZSBmdW5jdGlvblxuICBcdC8vIC8vIHdpdGggYHJhY3RpdmVgIGFzIGNvbnRleHQgKHVubGVzcyB0aGUgY2hpbGQgd2FzIGFsc28gYSBmdW5jdGlvbilcbiAgXHQvLyBpZiAoIHR5cGVvZiByYWN0aXZlLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5kYXRhID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB1c2VyT3B0aW9ucy5kYXRhICE9PSAnZnVuY3Rpb24nICkge1xuICBcdC8vIFx0dmlld21vZGVsLnJlc2V0KCByYWN0aXZlLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5kYXRhLmNhbGwoIHJhY3RpdmUgKSB8fCBmYXRhbCggJ2BkYXRhYCBmdW5jdGlvbnMgbXVzdCByZXR1cm4gYSBkYXRhIG9iamVjdCcgKSApO1xuICBcdC8vIH1cblxuICBcdC8vIFJlbmRlciB2aXJ0dWFsIERPTVxuICBcdGlmIChyYWN0aXZlLnRlbXBsYXRlKSB7XG4gIFx0XHR2YXIgY3NzSWRzID0gdW5kZWZpbmVkO1xuXG4gIFx0XHRpZiAob3B0aW9ucy5jc3NJZHMgfHwgcmFjdGl2ZS5jc3NJZCkge1xuICBcdFx0XHRjc3NJZHMgPSBvcHRpb25zLmNzc0lkcyA/IG9wdGlvbnMuY3NzSWRzLnNsaWNlKCkgOiBbXTtcblxuICBcdFx0XHRpZiAocmFjdGl2ZS5jc3NJZCkge1xuICBcdFx0XHRcdGNzc0lkcy5wdXNoKHJhY3RpdmUuY3NzSWQpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJhY3RpdmUuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiByYWN0aXZlLnRlbXBsYXRlLFxuICBcdFx0XHRyb290OiByYWN0aXZlLFxuICBcdFx0XHRvd25lcjogcmFjdGl2ZSwgLy8gc2F2ZXMgZG9pbmcgYGlmICggdGhpcy5wYXJlbnQgKSB7IC8qLi4uKi8gfWAgbGF0ZXIgb25cbiAgXHRcdFx0Y3NzSWRzOiBjc3NJZHNcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdGluaXRIb29rLmVuZChyYWN0aXZlKTtcblxuICBcdC8vIHJlbmRlciBhdXRvbWF0aWNhbGx5ICggaWYgYGVsYCBpcyBzcGVjaWZpZWQgKVxuICBcdGlmIChlbCA9IGdldEVsZW1lbnQocmFjdGl2ZS5lbCkpIHtcbiAgXHRcdHZhciBwcm9taXNlID0gcmFjdGl2ZS5yZW5kZXIoZWwsIHJhY3RpdmUuYXBwZW5kKTtcblxuICBcdFx0aWYgKF9SYWN0aXZlLkRFQlVHX1BST01JU0VTKSB7XG4gIFx0XHRcdHByb21pc2VbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gIFx0XHRcdFx0d2Fybk9uY2VJZkRlYnVnKFwiUHJvbWlzZSBkZWJ1Z2dpbmcgaXMgZW5hYmxlZCwgdG8gaGVscCBzb2x2ZSBlcnJvcnMgdGhhdCBoYXBwZW4gYXN5bmNocm9ub3VzbHkuIFNvbWUgYnJvd3NlcnMgd2lsbCBsb2cgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9ucywgaW4gd2hpY2ggY2FzZSB5b3UgY2FuIHNhZmVseSBkaXNhYmxlIHByb21pc2UgZGVidWdnaW5nOlxcbiAgUmFjdGl2ZS5ERUJVR19QUk9NSVNFUyA9IGZhbHNlO1wiKTtcbiAgXHRcdFx0XHR3YXJuSWZEZWJ1ZyhcIkFuIGVycm9yIGhhcHBlbmVkIGR1cmluZyByZW5kZXJpbmdcIiwgeyByYWN0aXZlOiByYWN0aXZlIH0pO1xuICBcdFx0XHRcdGVyci5zdGFjayAmJiBsb2dJZkRlYnVnKGVyci5zdGFjayk7XG5cbiAgXHRcdFx0XHR0aHJvdyBlcnI7XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFkYXB0b3JzKHJhY3RpdmUsIHByb3RvQWRhcHQsIHVzZXJPcHRpb25zKSB7XG4gIFx0dmFyIGFkYXB0LCBtYWdpYywgbW9kaWZ5QXJyYXlzO1xuXG4gIFx0cHJvdG9BZGFwdCA9IHByb3RvQWRhcHQubWFwKGxvb2t1cCk7XG4gIFx0YWRhcHQgPSBlbnN1cmVBcnJheSh1c2VyT3B0aW9ucy5hZGFwdCkubWFwKGxvb2t1cCk7XG5cbiAgXHRhZGFwdCA9IGluaXRpYWxpc2VfX2NvbWJpbmUocHJvdG9BZGFwdCwgYWRhcHQpO1xuXG4gIFx0bWFnaWMgPSBcIm1hZ2ljXCIgaW4gdXNlck9wdGlvbnMgPyB1c2VyT3B0aW9ucy5tYWdpYyA6IHJhY3RpdmUubWFnaWM7XG4gIFx0bW9kaWZ5QXJyYXlzID0gXCJtb2RpZnlBcnJheXNcIiBpbiB1c2VyT3B0aW9ucyA/IHVzZXJPcHRpb25zLm1vZGlmeUFycmF5cyA6IHJhY3RpdmUubW9kaWZ5QXJyYXlzO1xuXG4gIFx0aWYgKG1hZ2ljKSB7XG4gIFx0XHRpZiAoIWVudmlyb25tZW50X19tYWdpYykge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJHZXR0ZXJzIGFuZCBzZXR0ZXJzIChtYWdpYyBtb2RlKSBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChtb2RpZnlBcnJheXMpIHtcbiAgXHRcdFx0YWRhcHQucHVzaChtYWdpY0FycmF5KTtcbiAgXHRcdH1cblxuICBcdFx0YWRhcHQucHVzaChhZGFwdG9yc19tYWdpYyk7XG4gIFx0fVxuXG4gIFx0aWYgKG1vZGlmeUFycmF5cykge1xuICBcdFx0YWRhcHQucHVzaChhcnJheV9pbmRleCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGFkYXB0O1xuXG4gIFx0ZnVuY3Rpb24gbG9va3VwKGFkYXB0b3IpIHtcbiAgXHRcdGlmICh0eXBlb2YgYWRhcHRvciA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRhZGFwdG9yID0gZmluZEluVmlld0hpZXJhcmNoeShcImFkYXB0b3JzXCIsIHJhY3RpdmUsIGFkYXB0b3IpO1xuXG4gIFx0XHRcdGlmICghYWRhcHRvcikge1xuICBcdFx0XHRcdGZhdGFsKG1pc3NpbmdQbHVnaW4oYWRhcHRvciwgXCJhZGFwdG9yXCIpKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gYWRhcHRvcjtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXNlX19jb21iaW5lKGEsIGIpIHtcbiAgXHR2YXIgYyA9IGEuc2xpY2UoKSxcbiAgXHQgICAgaSA9IGIubGVuZ3RoO1xuXG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKCEgfmMuaW5kZXhPZihiW2ldKSkge1xuICBcdFx0XHRjLnB1c2goYltpXSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGM7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXNlUHJvcGVydGllcyhyYWN0aXZlLCBvcHRpb25zKSB7XG4gIFx0Ly8gR2VuZXJhdGUgYSB1bmlxdWUgaWRlbnRpZmllciwgZm9yIHBsYWNlcyB3aGVyZSB5b3UnZCB1c2UgYSB3ZWFrIG1hcCBpZiBpdFxuICBcdC8vIGV4aXN0ZWRcbiAgXHRyYWN0aXZlLl9ndWlkID0gXCJyLVwiICsgaW5pdGlhbGlzZV9fdWlkKys7XG5cbiAgXHQvLyBldmVudHNcbiAgXHRyYWN0aXZlLl9zdWJzID0gY3JlYXRlKG51bGwpO1xuXG4gIFx0Ly8gc3RvcmFnZSBmb3IgaXRlbSBjb25maWd1cmF0aW9uIGZyb20gaW5zdGFudGlhdGlvbiB0byByZXNldCxcbiAgXHQvLyBsaWtlIGR5bmFtaWMgZnVuY3Rpb25zIG9yIG9yaWdpbmFsIHZhbHVlc1xuICBcdHJhY3RpdmUuX2NvbmZpZyA9IHt9O1xuXG4gIFx0Ly8gdHdvLXdheSBiaW5kaW5nc1xuICBcdHJhY3RpdmUuX3R3b3dheUJpbmRpbmdzID0gY3JlYXRlKG51bGwpO1xuXG4gIFx0Ly8gYW5pbWF0aW9ucyAoc28gd2UgY2FuIHN0b3AgYW55IGluIHByb2dyZXNzIGF0IHRlYXJkb3duKVxuICBcdHJhY3RpdmUuX2FuaW1hdGlvbnMgPSBbXTtcblxuICBcdC8vIG5vZGVzIHJlZ2lzdHJ5XG4gIFx0cmFjdGl2ZS5ub2RlcyA9IHt9O1xuXG4gIFx0Ly8gbGl2ZSBxdWVyaWVzXG4gIFx0cmFjdGl2ZS5fbGl2ZVF1ZXJpZXMgPSBbXTtcbiAgXHRyYWN0aXZlLl9saXZlQ29tcG9uZW50UXVlcmllcyA9IFtdO1xuXG4gIFx0Ly8gYm91bmQgZGF0YSBmdW5jdGlvbnNcbiAgXHRyYWN0aXZlLl9ib3VuZEZ1bmN0aW9ucyA9IFtdO1xuXG4gIFx0Ly8gb2JzZXJ2ZXJzXG4gIFx0cmFjdGl2ZS5fb2JzZXJ2ZXJzID0gW107XG5cbiAgXHQvLyBwcm9wZXJ0aWVzIHNwZWNpZmljIHRvIGlubGluZSBjb21wb25lbnRzXG4gIFx0aWYgKG9wdGlvbnMuY29tcG9uZW50KSB7XG4gIFx0XHRyYWN0aXZlLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBcdFx0cmFjdGl2ZS5jb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciB8fCBudWxsO1xuICBcdFx0cmFjdGl2ZS5yb290ID0gcmFjdGl2ZS5wYXJlbnQucm9vdDtcblxuICBcdFx0cmFjdGl2ZS5jb21wb25lbnQgPSBvcHRpb25zLmNvbXBvbmVudDtcbiAgXHRcdG9wdGlvbnMuY29tcG9uZW50Lmluc3RhbmNlID0gcmFjdGl2ZTtcblxuICBcdFx0Ly8gZm9yIGhhY2thYmlsaXR5LCB0aGlzIGNvdWxkIGJlIGFuIG9wZW4gb3B0aW9uXG4gIFx0XHQvLyBmb3IgYW55IHJhY3RpdmUgaW5zdGFuY2UsIGJ1dCBmb3Igbm93LCBqdXN0XG4gIFx0XHQvLyBmb3IgY29tcG9uZW50cyBhbmQganVzdCBmb3IgcmFjdGl2ZS4uLlxuICBcdFx0cmFjdGl2ZS5faW5saW5lUGFydGlhbHMgPSBvcHRpb25zLmlubGluZVBhcnRpYWxzO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyYWN0aXZlLnJvb3QgPSByYWN0aXZlO1xuICBcdFx0cmFjdGl2ZS5wYXJlbnQgPSByYWN0aXZlLmNvbnRhaW5lciA9IG51bGw7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZGVwcmVjYXRlUmFjdGl2ZURhdGEoKSB7XG4gIFx0dGhyb3cgbmV3IEVycm9yKFwiVXNpbmcgYHJhY3RpdmUuZGF0YWAgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCAtIHlvdSBtdXN0IHVzZSB0aGUgYHJhY3RpdmUuZ2V0KClgIEFQSSBpbnN0ZWFkXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29tcGxleFBhcmFtZXRlcihjb21wb25lbnQsIHRlbXBsYXRlLCBjYWxsYmFjaykge1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgXHRcdHJvb3Q6IGNvbXBvbmVudC5yb290LFxuICBcdFx0b3duZXI6IHRoaXNcbiAgXHR9KTtcblxuICBcdHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICB2YXIgaW5pdGlhbGlzZV9Db21wbGV4UGFyYW1ldGVyID0gQ29tcGxleFBhcmFtZXRlcjtcblxuICBDb21wbGV4UGFyYW1ldGVyLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5kaXJ0eSkge1xuICBcdFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmNhbGxiYWNrKHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKSk7XG4gIFx0XHR0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBjcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIENvbXBvbmVudCwgYXR0cmlidXRlcywgeWllbGRUZW1wbGF0ZSwgcGFydGlhbHMpIHtcbiAgXHR2YXIgaW5zdGFuY2UsXG4gIFx0ICAgIHBhcmVudEZyYWdtZW50LFxuICBcdCAgICByYWN0aXZlLFxuICBcdCAgICBmcmFnbWVudCxcbiAgXHQgICAgY29udGFpbmVyLFxuICBcdCAgICBpbmxpbmVQYXJ0aWFscyA9IHt9LFxuICBcdCAgICBkYXRhID0ge30sXG4gIFx0ICAgIG1hcHBpbmdzID0ge30sXG4gIFx0ICAgIHJlYWR5LFxuICBcdCAgICByZXNvbHZlcnMgPSBbXTtcblxuICBcdHBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuICBcdHJhY3RpdmUgPSBjb21wb25lbnQucm9vdDtcblxuICBcdHBhcnRpYWxzID0gcGFydGlhbHMgfHwge307XG4gIFx0dXRpbHNfb2JqZWN0X19leHRlbmQoaW5saW5lUGFydGlhbHMsIHBhcnRpYWxzKTtcblxuICBcdC8vIE1ha2UgY29udGVudHMgYXZhaWxhYmxlIGFzIGEge3s+Y29udGVudH19IHBhcnRpYWxcbiAgXHRwYXJ0aWFscy5jb250ZW50ID0geWllbGRUZW1wbGF0ZSB8fCBbXTtcblxuICBcdC8vIHNldCBhIGRlZmF1bHQgcGFydGlhbCBmb3IgeWllbGRzIHdpdGggbm8gbmFtZVxuICBcdGlubGluZVBhcnRpYWxzW1wiXCJdID0gcGFydGlhbHMuY29udGVudDtcblxuICBcdGlmIChDb21wb25lbnQuZGVmYXVsdHMuZWwpIHtcbiAgXHRcdHdhcm5JZkRlYnVnKFwiVGhlIDwlcy8+IGNvbXBvbmVudCBoYXMgYSBkZWZhdWx0IGBlbGAgcHJvcGVydHk7IGl0IGhhcyBiZWVuIGRpc3JlZ2FyZGVkXCIsIGNvbXBvbmVudC5uYW1lKTtcbiAgXHR9XG5cbiAgXHQvLyBmaW5kIGNvbnRhaW5lclxuICBcdGZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG4gIFx0d2hpbGUgKGZyYWdtZW50KSB7XG4gIFx0XHRpZiAoZnJhZ21lbnQub3duZXIudHlwZSA9PT0gWUlFTERFUikge1xuICBcdFx0XHRjb250YWluZXIgPSBmcmFnbWVudC5vd25lci5jb250YWluZXI7XG4gIFx0XHRcdGJyZWFrO1xuICBcdFx0fVxuXG4gIFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudDtcbiAgXHR9XG5cbiAgXHQvLyBlYWNoIGF0dHJpYnV0ZSByZXByZXNlbnRzIGVpdGhlciBhKSBkYXRhIG9yIGIpIGEgbWFwcGluZ1xuICBcdGlmIChhdHRyaWJ1dGVzKSB7XG4gIFx0XHRPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5XSxcbiAgXHRcdFx0ICAgIHBhcnNlZCxcbiAgXHRcdFx0ICAgIHJlc29sdmVyO1xuXG4gIFx0XHRcdGlmICh0eXBlb2YgYXR0cmlidXRlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdFx0Ly8gaXQncyBzdGF0aWMgZGF0YVxuICBcdFx0XHRcdHBhcnNlZCA9IHBhcnNlSlNPTihhdHRyaWJ1dGUpO1xuICBcdFx0XHRcdGRhdGFba2V5XSA9IHBhcnNlZCA/IHBhcnNlZC52YWx1ZSA6IGF0dHJpYnV0ZTtcbiAgXHRcdFx0fSBlbHNlIGlmIChhdHRyaWJ1dGUgPT09IDApIHtcbiAgXHRcdFx0XHQvLyBpdCBoYWQgbm8gJz0nLCBzbyB3ZSdsbCBjYWxsIGl0IHRydWVcbiAgXHRcdFx0XHRkYXRhW2tleV0gPSB0cnVlO1xuICBcdFx0XHR9IGVsc2UgaWYgKGlzQXJyYXkoYXR0cmlidXRlKSkge1xuICBcdFx0XHRcdC8vIHRoaXMgcmVwcmVzZW50cyBkeW5hbWljIGRhdGFcbiAgXHRcdFx0XHRpZiAoaXNTaW5nbGVJbnRlcnBvbGF0b3IoYXR0cmlidXRlKSkge1xuICBcdFx0XHRcdFx0bWFwcGluZ3Nba2V5XSA9IHtcbiAgXHRcdFx0XHRcdFx0b3JpZ2luOiBjb21wb25lbnQucm9vdC52aWV3bW9kZWwsXG4gIFx0XHRcdFx0XHRcdGtleXBhdGg6IHVuZGVmaW5lZFxuICBcdFx0XHRcdFx0fTtcblxuICBcdFx0XHRcdFx0cmVzb2x2ZXIgPSBjcmVhdGVSZXNvbHZlcihjb21wb25lbnQsIGF0dHJpYnV0ZVswXSwgZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0XHRcdFx0aWYgKGtleXBhdGguaXNTcGVjaWFsKSB7XG4gIFx0XHRcdFx0XHRcdFx0aWYgKHJlYWR5KSB7XG4gIFx0XHRcdFx0XHRcdFx0XHRpbnN0YW5jZS5zZXQoa2V5LCBrZXlwYXRoLnZhbHVlKTsgLy8gVE9ETyB1c2Ugdmlld21vZGVsP1xuICBcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdFx0XHRkYXRhW2tleV0gPSBrZXlwYXRoLnZhbHVlO1xuXG4gIFx0XHRcdFx0XHRcdFx0XHQvLyBUT0RPIGVycnIuLi4uIHdvdWxkIGJlIGJldHRlciBpZiB3ZSBkaWRuJ3QgaGF2ZSB0byBkbyB0aGlzXG4gIFx0XHRcdFx0XHRcdFx0XHRkZWxldGUgbWFwcGluZ3Nba2V5XTtcbiAgXHRcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdFx0aWYgKHJlYWR5KSB7XG4gIFx0XHRcdFx0XHRcdFx0XHRpbnN0YW5jZS52aWV3bW9kZWwubWFwcGluZ3Nba2V5XS5yZXNvbHZlKGtleXBhdGgpO1xuICBcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdFx0XHQvLyByZXNvbHZlZCBpbW1lZGlhdGVseVxuICBcdFx0XHRcdFx0XHRcdFx0bWFwcGluZ3Nba2V5XS5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHRcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRyZXNvbHZlciA9IG5ldyBpbml0aWFsaXNlX0NvbXBsZXhQYXJhbWV0ZXIoY29tcG9uZW50LCBhdHRyaWJ1dGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0XHRcdFx0XHRpZiAocmVhZHkpIHtcbiAgXHRcdFx0XHRcdFx0XHRpbnN0YW5jZS5zZXQoa2V5LCB2YWx1ZSk7IC8vIFRPRE8gdXNlIHZpZXdtb2RlbD9cbiAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRkYXRhW2tleV0gPSB2YWx1ZTtcbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0cmVzb2x2ZXJzLnB1c2gocmVzb2x2ZXIpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImVybSB3dXRcIik7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdGluc3RhbmNlID0gY3JlYXRlKENvbXBvbmVudC5wcm90b3R5cGUpO1xuXG4gIFx0aW5pdGlhbGlzZShpbnN0YW5jZSwge1xuICBcdFx0ZWw6IG51bGwsXG4gIFx0XHRhcHBlbmQ6IHRydWUsXG4gIFx0XHRkYXRhOiBkYXRhLFxuICBcdFx0cGFydGlhbHM6IHBhcnRpYWxzLFxuICBcdFx0bWFnaWM6IHJhY3RpdmUubWFnaWMgfHwgQ29tcG9uZW50LmRlZmF1bHRzLm1hZ2ljLFxuICBcdFx0bW9kaWZ5QXJyYXlzOiByYWN0aXZlLm1vZGlmeUFycmF5cyxcbiAgXHRcdC8vIG5lZWQgdG8gaW5oZXJpdCBydW50aW1lIHBhcmVudCBhZGFwdG9yc1xuICBcdFx0YWRhcHQ6IHJhY3RpdmUuYWRhcHRcbiAgXHR9LCB7XG4gIFx0XHRwYXJlbnQ6IHJhY3RpdmUsXG4gIFx0XHRjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgXHRcdGNvbnRhaW5lcjogY29udGFpbmVyLFxuICBcdFx0bWFwcGluZ3M6IG1hcHBpbmdzLFxuICBcdFx0aW5saW5lUGFydGlhbHM6IGlubGluZVBhcnRpYWxzLFxuICBcdFx0Y3NzSWRzOiBwYXJlbnRGcmFnbWVudC5jc3NJZHNcbiAgXHR9KTtcblxuICBcdHJlYWR5ID0gdHJ1ZTtcbiAgXHRjb21wb25lbnQucmVzb2x2ZXJzID0gcmVzb2x2ZXJzO1xuXG4gIFx0cmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlc29sdmVyKGNvbXBvbmVudCwgdGVtcGxhdGUsIGNhbGxiYWNrKSB7XG4gIFx0dmFyIHJlc29sdmVyO1xuXG4gIFx0aWYgKHRlbXBsYXRlLnIpIHtcbiAgXHRcdHJlc29sdmVyID0gUmVzb2x2ZXJzX2NyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKGNvbXBvbmVudCwgdGVtcGxhdGUuciwgY2FsbGJhY2spO1xuICBcdH0gZWxzZSBpZiAodGVtcGxhdGUueCkge1xuICBcdFx0cmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXJzX0V4cHJlc3Npb25SZXNvbHZlcihjb21wb25lbnQsIGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCwgdGVtcGxhdGUueCwgY2FsbGJhY2spO1xuICBcdH0gZWxzZSBpZiAodGVtcGxhdGUucngpIHtcbiAgXHRcdHJlc29sdmVyID0gbmV3IFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIoY29tcG9uZW50LCB0ZW1wbGF0ZS5yeCwgY2FsbGJhY2spO1xuICBcdH1cblxuICBcdHJldHVybiByZXNvbHZlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2luZ2xlSW50ZXJwb2xhdG9yKHRlbXBsYXRlKSB7XG4gIFx0cmV0dXJuIHRlbXBsYXRlLmxlbmd0aCA9PT0gMSAmJiB0ZW1wbGF0ZVswXS50ID09PSBJTlRFUlBPTEFUT1I7XG4gIH1cblxuICAvLyBUT0RPIGhvdyBzaG91bGQgZXZlbnQgYXJndW1lbnRzIGJlIGhhbmRsZWQ/IGUuZy5cbiAgLy8gPHdpZGdldCBvbi1mb289J2JhcjoxLDIsMycvPlxuICAvLyBUaGUgZXZlbnQgJ2Jhcicgd2lsbCBiZSBmaXJlZCBvbiB0aGUgcGFyZW50IGluc3RhbmNlXG4gIC8vIHdoZW4gJ2ZvbycgZmlyZXMgb24gdGhlIGNoaWxkLCBidXQgdGhlIDEsMiwzIGFyZ3VtZW50c1xuICAvLyB3aWxsIGJlIGxvc3RcblxuICB2YXIgaW5pdGlhbGlzZV9wcm9wYWdhdGVFdmVudHMgPSBwcm9wYWdhdGVFdmVudHM7XG5cbiAgZnVuY3Rpb24gcHJvcGFnYXRlRXZlbnRzKGNvbXBvbmVudCwgZXZlbnRzRGVzY3JpcHRvcikge1xuICBcdHZhciBldmVudE5hbWU7XG5cbiAgXHRmb3IgKGV2ZW50TmFtZSBpbiBldmVudHNEZXNjcmlwdG9yKSB7XG4gIFx0XHRpZiAoZXZlbnRzRGVzY3JpcHRvci5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gIFx0XHRcdHByb3BhZ2F0ZUV2ZW50KGNvbXBvbmVudC5pbnN0YW5jZSwgY29tcG9uZW50LnJvb3QsIGV2ZW50TmFtZSwgZXZlbnRzRGVzY3JpcHRvcltldmVudE5hbWVdKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9wYWdhdGVFdmVudChjaGlsZEluc3RhbmNlLCBwYXJlbnRJbnN0YW5jZSwgZXZlbnROYW1lLCBwcm94eUV2ZW50TmFtZSkge1xuICBcdGlmICh0eXBlb2YgcHJveHlFdmVudE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGZhdGFsKFwiQ29tcG9uZW50cyBjdXJyZW50bHkgb25seSBzdXBwb3J0IHNpbXBsZSBldmVudHMgLSB5b3UgY2Fubm90IGluY2x1ZGUgYXJndW1lbnRzLiBTb3JyeSFcIik7XG4gIFx0fVxuXG4gIFx0Y2hpbGRJbnN0YW5jZS5vbihldmVudE5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBldmVudCwgYXJncztcblxuICBcdFx0Ly8gc2VtaS13ZWFrIHRlc3QsIGJ1dCB3aGF0IGVsc2U/IHRhZyB0aGUgZXZlbnQgb2JqIC5faXNFdmVudCA/XG4gIFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMF0gJiYgYXJndW1lbnRzWzBdLm5vZGUpIHtcbiAgXHRcdFx0ZXZlbnQgPSBBcnJheS5wcm90b3R5cGUuc2hpZnQuY2FsbChhcmd1bWVudHMpO1xuICBcdFx0fVxuXG4gIFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBcdFx0c2hhcmVkX2ZpcmVFdmVudChwYXJlbnRJbnN0YW5jZSwgcHJveHlFdmVudE5hbWUsIHsgZXZlbnQ6IGV2ZW50LCBhcmdzOiBhcmdzIH0pO1xuXG4gIFx0XHQvLyBjYW5jZWwgYnViYmxpbmdcbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9KTtcbiAgfVxuXG4gIHZhciBpbml0aWFsaXNlX3VwZGF0ZUxpdmVRdWVyaWVzID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICBcdHZhciBhbmNlc3RvciwgcXVlcnk7XG5cbiAgXHQvLyBJZiB0aGVyZSdzIGEgbGl2ZSBxdWVyeSBmb3IgdGhpcyBjb21wb25lbnQgdHlwZSwgYWRkIGl0XG4gIFx0YW5jZXN0b3IgPSBjb21wb25lbnQucm9vdDtcbiAgXHR3aGlsZSAoYW5jZXN0b3IpIHtcbiAgXHRcdGlmIChxdWVyeSA9IGFuY2VzdG9yLl9saXZlQ29tcG9uZW50UXVlcmllc1tcIl9cIiArIGNvbXBvbmVudC5uYW1lXSkge1xuICBcdFx0XHRxdWVyeS5wdXNoKGNvbXBvbmVudC5pbnN0YW5jZSk7XG4gIFx0XHR9XG5cbiAgXHRcdGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICBcdH1cbiAgfTtcblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9pbml0ID0gQ29tcG9uZW50JGluaXQ7XG4gIGZ1bmN0aW9uIENvbXBvbmVudCRpbml0KG9wdGlvbnMsIENvbXBvbmVudCkge1xuICBcdHZhciBwYXJlbnRGcmFnbWVudCwgcm9vdDtcblxuICBcdGlmICghQ29tcG9uZW50KSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb21wb25lbnQgXFxcIlwiICsgdGhpcy5uYW1lICsgXCJcXFwiIG5vdCBmb3VuZFwiKTtcbiAgXHR9XG5cbiAgXHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuICBcdHJvb3QgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuXG4gIFx0dGhpcy5yb290ID0gcm9vdDtcbiAgXHR0aGlzLnR5cGUgPSBDT01QT05FTlQ7XG4gIFx0dGhpcy5uYW1lID0gb3B0aW9ucy50ZW1wbGF0ZS5lO1xuICBcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuICBcdHRoaXMuaW5kZXhSZWZCaW5kaW5ncyA9IHt9O1xuICBcdHRoaXMueWllbGRlcnMgPSB7fTtcbiAgXHR0aGlzLnJlc29sdmVycyA9IFtdO1xuXG4gIFx0Y3JlYXRlSW5zdGFuY2UodGhpcywgQ29tcG9uZW50LCBvcHRpb25zLnRlbXBsYXRlLmEsIG9wdGlvbnMudGVtcGxhdGUuZiwgb3B0aW9ucy50ZW1wbGF0ZS5wKTtcbiAgXHRpbml0aWFsaXNlX3Byb3BhZ2F0ZUV2ZW50cyh0aGlzLCBvcHRpb25zLnRlbXBsYXRlLnYpO1xuXG4gIFx0Ly8gaW50cm8sIG91dHJvIGFuZCBkZWNvcmF0b3IgZGlyZWN0aXZlcyBoYXZlIG5vIGVmZmVjdFxuICBcdGlmIChvcHRpb25zLnRlbXBsYXRlLnQwIHx8IG9wdGlvbnMudGVtcGxhdGUudDEgfHwgb3B0aW9ucy50ZW1wbGF0ZS50MiB8fCBvcHRpb25zLnRlbXBsYXRlLm8pIHtcbiAgXHRcdHdhcm5JZkRlYnVnKFwiVGhlIFxcXCJpbnRyb1xcXCIsIFxcXCJvdXRyb1xcXCIgYW5kIFxcXCJkZWNvcmF0b3JcXFwiIGRpcmVjdGl2ZXMgaGF2ZSBubyBlZmZlY3Qgb24gY29tcG9uZW50c1wiLCB7IHJhY3RpdmU6IHRoaXMuaW5zdGFuY2UgfSk7XG4gIFx0fVxuXG4gIFx0aW5pdGlhbGlzZV91cGRhdGVMaXZlUXVlcmllcyh0aGlzKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX3JlYmluZCA9IENvbXBvbmVudCRyZWJpbmQ7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JHJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0dmFyIHF1ZXJ5O1xuXG4gIFx0dGhpcy5yZXNvbHZlcnMuZm9yRWFjaChyZWJpbmQpO1xuXG4gIFx0Zm9yICh2YXIgayBpbiB0aGlzLnlpZWxkZXJzKSB7XG4gIFx0XHRpZiAodGhpcy55aWVsZGVyc1trXVswXSkge1xuICBcdFx0XHRyZWJpbmQodGhpcy55aWVsZGVyc1trXVswXSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHF1ZXJ5ID0gdGhpcy5yb290Ll9saXZlQ29tcG9uZW50UXVlcmllc1tcIl9cIiArIHRoaXMubmFtZV0pIHtcbiAgXHRcdHF1ZXJ5Ll9tYWtlRGlydHkoKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiByZWJpbmQoeCkge1xuICBcdFx0eC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfcmVuZGVyID0gQ29tcG9uZW50JHJlbmRlcjtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkcmVuZGVyKCkge1xuICBcdHZhciBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2U7XG5cbiAgXHRpbnN0YW5jZS5yZW5kZXIodGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCkpO1xuXG4gIFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0cmV0dXJuIGluc3RhbmNlLmZyYWdtZW50LmRldGFjaCgpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfdG9TdHJpbmcgPSBDb21wb25lbnQkdG9TdHJpbmc7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JHRvU3RyaW5nKCkge1xuICBcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV91bmJpbmQgPSBDb21wb25lbnQkdW5iaW5kO1xuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX3VuYmluZF9fdGVhcmRvd25Ib29rID0gbmV3IGhvb2tzX0hvb2soXCJ0ZWFyZG93blwiKTtcbiAgZnVuY3Rpb24gQ29tcG9uZW50JHVuYmluZCgpIHtcbiAgXHR2YXIgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlO1xuXG4gIFx0dGhpcy5yZXNvbHZlcnMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuXG4gIFx0cmVtb3ZlRnJvbUxpdmVDb21wb25lbnRRdWVyaWVzKHRoaXMpO1xuXG4gIFx0aW5zdGFuY2UuX29ic2VydmVycy5mb3JFYWNoKGNhbmNlbCk7XG5cbiAgXHQvLyB0ZWFyZG93biB0aGUgaW5zdGFuY2VcbiAgXHRpbnN0YW5jZS5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHRpbnN0YW5jZS52aWV3bW9kZWwudGVhcmRvd24oKTtcblxuICBcdGlmIChpbnN0YW5jZS5mcmFnbWVudC5yZW5kZXJlZCAmJiBpbnN0YW5jZS5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18pIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheShpbnN0YW5jZS5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIGluc3RhbmNlKTtcbiAgXHR9XG5cbiAgXHRDb21wb25lbnRfcHJvdG90eXBlX3VuYmluZF9fdGVhcmRvd25Ib29rLmZpcmUoaW5zdGFuY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRnJvbUxpdmVDb21wb25lbnRRdWVyaWVzKGNvbXBvbmVudCkge1xuICBcdHZhciBpbnN0YW5jZSwgcXVlcnk7XG5cbiAgXHRpbnN0YW5jZSA9IGNvbXBvbmVudC5yb290O1xuXG4gIFx0ZG8ge1xuICBcdFx0aWYgKHF1ZXJ5ID0gaW5zdGFuY2UuX2xpdmVDb21wb25lbnRRdWVyaWVzW1wiX1wiICsgY29tcG9uZW50Lm5hbWVdKSB7XG4gIFx0XHRcdHF1ZXJ5Ll9yZW1vdmUoY29tcG9uZW50KTtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlIChpbnN0YW5jZSA9IGluc3RhbmNlLnBhcmVudCk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV91bnJlbmRlciA9IENvbXBvbmVudCR1bnJlbmRlcjtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkdW5yZW5kZXIoc2hvdWxkRGVzdHJveSkge1xuICBcdHRoaXMuc2hvdWxkRGVzdHJveSA9IHNob3VsZERlc3Ryb3k7XG4gIFx0dGhpcy5pbnN0YW5jZS51bnJlbmRlcigpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uIChvcHRpb25zLCBDb25zdHJ1Y3Rvcikge1xuICBcdHRoaXMuaW5pdChvcHRpb25zLCBDb25zdHJ1Y3Rvcik7XG4gIH07XG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZSA9IHtcbiAgXHRkZXRhY2g6IENvbXBvbmVudF9wcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IENvbXBvbmVudF9wcm90b3R5cGVfZmluZCxcbiAgXHRmaW5kQWxsOiBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRBbGwsXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IENvbXBvbmVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kQ29tcG9uZW50LFxuICBcdGZpbmROZXh0Tm9kZTogQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kTmV4dE5vZGUsXG4gIFx0Zmlyc3ROb2RlOiBDb21wb25lbnRfcHJvdG90eXBlX2ZpcnN0Tm9kZSxcbiAgXHRpbml0OiBDb21wb25lbnRfcHJvdG90eXBlX2luaXQsXG4gIFx0cmViaW5kOiBDb21wb25lbnRfcHJvdG90eXBlX3JlYmluZCxcbiAgXHRyZW5kZXI6IENvbXBvbmVudF9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHRvU3RyaW5nOiBDb21wb25lbnRfcHJvdG90eXBlX3RvU3RyaW5nLFxuICBcdHVuYmluZDogQ29tcG9uZW50X3Byb3RvdHlwZV91bmJpbmQsXG4gIFx0dW5yZW5kZXI6IENvbXBvbmVudF9wcm90b3R5cGVfdW5yZW5kZXJcbiAgfTtcblxuICB2YXIgX0NvbXBvbmVudCA9IENvbXBvbmVudDtcblxuICB2YXIgQ29tbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy50eXBlID0gQ09NTUVOVDtcbiAgXHR0aGlzLnZhbHVlID0gb3B0aW9ucy50ZW1wbGF0ZS5jO1xuICB9O1xuXG4gIENvbW1lbnQucHJvdG90eXBlID0ge1xuICBcdGRldGFjaDogc2hhcmVkX2RldGFjaCxcblxuICBcdGZpcnN0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMubm9kZSkge1xuICBcdFx0XHR0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRoaXMudmFsdWUpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIFwiPCEtLVwiICsgdGhpcy52YWx1ZSArIFwiLS0+XCI7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0aWYgKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdFx0dGhpcy5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIGl0ZW1zX0NvbW1lbnQgPSBDb21tZW50O1xuXG4gIHZhciBZaWVsZGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR2YXIgY29udGFpbmVyLCBjb21wb25lbnQ7XG5cbiAgXHR0aGlzLnR5cGUgPSBZSUVMREVSO1xuXG4gIFx0dGhpcy5jb250YWluZXIgPSBjb250YWluZXIgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50LnJvb3Q7XG4gIFx0dGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQgPSBjb250YWluZXIuY29tcG9uZW50O1xuXG4gIFx0dGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gIFx0dGhpcy5jb250YWluZXJGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblxuICBcdHZhciBuYW1lID0gdGhpcy5uYW1lID0gb3B0aW9ucy50ZW1wbGF0ZS5uIHx8IFwiXCI7XG5cbiAgXHR2YXIgdGVtcGxhdGUgPSBjb250YWluZXIuX2lubGluZVBhcnRpYWxzW25hbWVdO1xuXG4gIFx0aWYgKCF0ZW1wbGF0ZSkge1xuICBcdFx0d2FybklmRGVidWcoXCJDb3VsZCBub3QgZmluZCB0ZW1wbGF0ZSBmb3IgcGFydGlhbCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIsIHsgcmFjdGl2ZTogb3B0aW9ucy5yb290IH0pO1xuICBcdFx0dGVtcGxhdGUgPSBbXTtcbiAgXHR9XG5cbiAgXHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0b3duZXI6IHRoaXMsXG4gIFx0XHRyb290OiBjb250YWluZXIucGFyZW50LFxuICBcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuICBcdFx0cEVsZW1lbnQ6IHRoaXMuY29udGFpbmVyRnJhZ21lbnQucEVsZW1lbnRcbiAgXHR9KTtcblxuICBcdC8vIGV2ZW4gdGhvdWdoIG9ubHkgb25lIHlpZWxkZXIgaXMgYWxsb3dlZCwgd2UgbmVlZCB0byBoYXZlIGFuIGFycmF5IG9mIHRoZW1cbiAgXHQvLyBhcyBpdCdzIHBvc3NpYmxlIHRvIGNhdXNlIGEgeWllbGRlciB0byBiZSBjcmVhdGVkIGJlZm9yZSB0aGUgbGFzdCBvbmVcbiAgXHQvLyB3YXMgZGVzdHJveWVkIGluIHRoZSBzYW1lIHR1cm4gb2YgdGhlIHJ1bmxvb3BcbiAgXHRpZiAoIWlzQXJyYXkoY29tcG9uZW50LnlpZWxkZXJzW25hbWVdKSkge1xuICBcdFx0Y29tcG9uZW50LnlpZWxkZXJzW25hbWVdID0gW3RoaXNdO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRjb21wb25lbnQueWllbGRlcnNbbmFtZV0ucHVzaCh0aGlzKTtcbiAgXHR9XG5cbiAgXHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKGNvbXBvbmVudC55aWVsZGVyc1tuYW1lXS5sZW5ndGggPiAxKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkEgY29tcG9uZW50IHRlbXBsYXRlIGNhbiBvbmx5IGhhdmUgb25lIHt7eWllbGRcIiArIChuYW1lID8gXCIgXCIgKyBuYW1lIDogXCJcIikgKyBcIn19IGRlY2xhcmF0aW9uIGF0IGEgdGltZVwiKTtcbiAgXHRcdH1cbiAgXHR9KTtcbiAgfTtcblxuICBZaWVsZGVyLnByb3RvdHlwZSA9IHtcbiAgXHRkZXRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmRldGFjaCgpO1xuICBcdH0sXG5cbiAgXHRmaW5kOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoc2VsZWN0b3IpO1xuICBcdH0sXG5cbiAgXHRmaW5kQWxsOiBmdW5jdGlvbiAoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fSxcblxuICBcdGZpbmRDb21wb25lbnQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudChzZWxlY3Rvcik7XG4gIFx0fSxcblxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBmdW5jdGlvbiAoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdH0sXG5cbiAgXHRmaW5kTmV4dE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lckZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0Zmlyc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maXJzdE5vZGUoKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZShvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5yZW5kZXIoKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoc2hvdWxkRGVzdHJveSk7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodGhpcy5jb21wb25lbnQueWllbGRlcnNbdGhpcy5uYW1lXSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGl0ZW1zX1lpZWxkZXIgPSBZaWVsZGVyO1xuXG4gIHZhciBEb2N0eXBlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLmRlY2xhcmF0aW9uID0gb3B0aW9ucy50ZW1wbGF0ZS5hO1xuICB9O1xuXG4gIERvY3R5cGUucHJvdG90eXBlID0ge1xuICBcdGluaXQ6IG5vb3AsXG4gIFx0cmVuZGVyOiBub29wLFxuICBcdHVucmVuZGVyOiBub29wLFxuICBcdHRlYXJkb3duOiBub29wLFxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gXCI8IURPQ1RZUEVcIiArIHRoaXMuZGVjbGFyYXRpb24gKyBcIj5cIjtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGl0ZW1zX0RvY3R5cGUgPSBEb2N0eXBlO1xuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfaW5pdCA9IEZyYWdtZW50JGluaXQ7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkaW5pdChvcHRpb25zKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHRoaXMub3duZXIgPSBvcHRpb25zLm93bmVyOyAvLyBUaGUgaXRlbSB0aGF0IG93bnMgdGhpcyBmcmFnbWVudCAtIGFuIGVsZW1lbnQsIHNlY3Rpb24sIHBhcnRpYWwsIG9yIGF0dHJpYnV0ZVxuICBcdHRoaXMucGFyZW50ID0gdGhpcy5vd25lci5wYXJlbnRGcmFnbWVudDtcblxuICBcdC8vIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gIFx0dGhpcy5yb290ID0gb3B0aW9ucy5yb290O1xuICBcdHRoaXMucEVsZW1lbnQgPSBvcHRpb25zLnBFbGVtZW50O1xuICBcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcbiAgXHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgXHR0aGlzLmtleSA9IG9wdGlvbnMua2V5O1xuICBcdHRoaXMucmVnaXN0ZXJlZEluZGV4UmVmcyA9IFtdO1xuXG4gIFx0Ly8gZW5jYXBzdWxhdGVkIHN0eWxlcyBzaG91bGQgYmUgaW5oZXJpdGVkIHVudGlsIHRoZXkgZ2V0IGFwcGxpZWQgYnkgYW4gZWxlbWVudFxuICBcdHRoaXMuY3NzSWRzID0gXCJjc3NJZHNcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5jc3NJZHMgOiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmNzc0lkcyA6IG51bGw7XG5cbiAgXHR0aGlzLml0ZW1zID0gb3B0aW9ucy50ZW1wbGF0ZS5tYXAoZnVuY3Rpb24gKHRlbXBsYXRlLCBpKSB7XG4gIFx0XHRyZXR1cm4gY3JlYXRlSXRlbSh7XG4gIFx0XHRcdHBhcmVudEZyYWdtZW50OiBfdGhpcyxcbiAgXHRcdFx0cEVsZW1lbnQ6IG9wdGlvbnMucEVsZW1lbnQsXG4gIFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgXHRcdFx0aW5kZXg6IGlcbiAgXHRcdH0pO1xuICBcdH0pO1xuXG4gIFx0dGhpcy52YWx1ZSA9IHRoaXMuYXJnc0xpc3QgPSBudWxsO1xuICBcdHRoaXMuZGlydHlBcmdzID0gdGhpcy5kaXJ0eVZhbHVlID0gdHJ1ZTtcblxuICBcdHRoaXMuYm91bmQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSXRlbShvcHRpb25zKSB7XG4gIFx0aWYgKHR5cGVvZiBvcHRpb25zLnRlbXBsYXRlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRyZXR1cm4gbmV3IGl0ZW1zX1RleHQob3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0c3dpdGNoIChvcHRpb25zLnRlbXBsYXRlLnQpIHtcbiAgXHRcdGNhc2UgWUlFTERFUjpcbiAgXHRcdFx0cmV0dXJuIG5ldyBpdGVtc19ZaWVsZGVyKG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBJTlRFUlBPTEFUT1I6XG4gIFx0XHRcdHJldHVybiBuZXcgaXRlbXNfSW50ZXJwb2xhdG9yKG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBTRUNUSU9OOlxuICBcdFx0XHRyZXR1cm4gbmV3IF9TZWN0aW9uKG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBUUklQTEU6XG4gIFx0XHRcdHJldHVybiBuZXcgX1RyaXBsZShvcHRpb25zKTtcbiAgXHRcdGNhc2UgRUxFTUVOVDpcbiAgXHRcdFx0dmFyIGNvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICBcdFx0XHRpZiAoY29uc3RydWN0b3IgPSBDb21wb25lbnRfZ2V0Q29tcG9uZW50KG9wdGlvbnMucGFyZW50RnJhZ21lbnQucm9vdCwgb3B0aW9ucy50ZW1wbGF0ZS5lKSkge1xuICBcdFx0XHRcdHJldHVybiBuZXcgX0NvbXBvbmVudChvcHRpb25zLCBjb25zdHJ1Y3Rvcik7XG4gIFx0XHRcdH1cbiAgXHRcdFx0cmV0dXJuIG5ldyBfRWxlbWVudChvcHRpb25zKTtcbiAgXHRcdGNhc2UgUEFSVElBTDpcbiAgXHRcdFx0cmV0dXJuIG5ldyBfUGFydGlhbChvcHRpb25zKTtcbiAgXHRcdGNhc2UgQ09NTUVOVDpcbiAgXHRcdFx0cmV0dXJuIG5ldyBpdGVtc19Db21tZW50KG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBET0NUWVBFOlxuICBcdFx0XHRyZXR1cm4gbmV3IGl0ZW1zX0RvY3R5cGUob3B0aW9ucyk7XG5cbiAgXHRcdGRlZmF1bHQ6XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlNvbWV0aGluZyB2ZXJ5IHN0cmFuZ2UgaGFwcGVuZWQuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMuIFRoYW5rcyFcIik7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9yZWJpbmQgPSBGcmFnbWVudCRyZWJpbmQ7XG4gIGZ1bmN0aW9uIEZyYWdtZW50JHJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG5cbiAgXHQvLyBhc3NpZ24gbmV3IGNvbnRleHQga2V5cGF0aCBpZiBuZWVkZWRcbiAgXHRpZiAoIXRoaXMub3duZXIgfHwgdGhpcy5vd25lci5oYXNDb250ZXh0KSB7XG4gIFx0XHRhc3NpZ25OZXdLZXlwYXRoKHRoaXMsIFwiY29udGV4dFwiLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG5cbiAgXHR0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdGlmIChpdGVtLnJlYmluZCkge1xuICBcdFx0XHRpdGVtLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9KTtcbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfcmVuZGVyID0gRnJhZ21lbnQkcmVuZGVyO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JHJlbmRlcigpIHtcbiAgXHR2YXIgcmVzdWx0O1xuXG4gIFx0aWYgKHRoaXMuaXRlbXMubGVuZ3RoID09PSAxKSB7XG4gIFx0XHRyZXN1bHQgPSB0aGlzLml0ZW1zWzBdLnJlbmRlcigpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgXHRcdHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0XHRyZXN1bHQuYXBwZW5kQ2hpbGQoaXRlbS5yZW5kZXIoKSk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV90b1N0cmluZyA9IEZyYWdtZW50JHRvU3RyaW5nO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JHRvU3RyaW5nKGVzY2FwZSkge1xuICBcdGlmICghdGhpcy5pdGVtcykge1xuICBcdFx0cmV0dXJuIFwiXCI7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMuaXRlbXMubWFwKGVzY2FwZSA/IHRvRXNjYXBlZFN0cmluZyA6IEZyYWdtZW50X3Byb3RvdHlwZV90b1N0cmluZ19fdG9TdHJpbmcpLmpvaW4oXCJcIik7XG4gIH1cblxuICBmdW5jdGlvbiBGcmFnbWVudF9wcm90b3R5cGVfdG9TdHJpbmdfX3RvU3RyaW5nKGl0ZW0pIHtcbiAgXHRyZXR1cm4gaXRlbS50b1N0cmluZygpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9Fc2NhcGVkU3RyaW5nKGl0ZW0pIHtcbiAgXHRyZXR1cm4gaXRlbS50b1N0cmluZyh0cnVlKTtcbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfdW5iaW5kID0gRnJhZ21lbnQkdW5iaW5kO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JHVuYmluZCgpIHtcbiAgXHRpZiAoIXRoaXMuYm91bmQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHR0aGlzLml0ZW1zLmZvckVhY2godW5iaW5kSXRlbSk7XG4gIFx0dGhpcy5ib3VuZCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5iaW5kSXRlbShpdGVtKSB7XG4gIFx0aWYgKGl0ZW0udW5iaW5kKSB7XG4gIFx0XHRpdGVtLnVuYmluZCgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfdW5yZW5kZXIgPSBGcmFnbWVudCR1bnJlbmRlcjtcblxuICBmdW5jdGlvbiBGcmFnbWVudCR1bnJlbmRlcihzaG91bGREZXN0cm95KSB7XG4gIFx0aWYgKCF0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gdW5yZW5kZXIgYSBmcmFnbWVudCB0aGF0IHdhcyBub3QgcmVuZGVyZWRcIik7XG4gIFx0fVxuXG4gIFx0dGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7XG4gIFx0XHRyZXR1cm4gaS51bnJlbmRlcihzaG91bGREZXN0cm95KTtcbiAgXHR9KTtcbiAgXHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgRnJhZ21lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfTtcblxuICBGcmFnbWVudC5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBwcm90b3R5cGVfYnViYmxlLFxuICBcdGRldGFjaDogRnJhZ21lbnRfcHJvdG90eXBlX2RldGFjaCxcbiAgXHRmaW5kOiBGcmFnbWVudF9wcm90b3R5cGVfZmluZCxcbiAgXHRmaW5kQWxsOiBGcmFnbWVudF9wcm90b3R5cGVfZmluZEFsbCxcbiAgXHRmaW5kQWxsQ29tcG9uZW50czogRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzLFxuICBcdGZpbmRDb21wb25lbnQ6IEZyYWdtZW50X3Byb3RvdHlwZV9maW5kQ29tcG9uZW50LFxuICBcdGZpbmROZXh0Tm9kZTogcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSxcbiAgXHRmaXJzdE5vZGU6IHByb3RvdHlwZV9maXJzdE5vZGUsXG4gIFx0Z2V0QXJnc0xpc3Q6IGdldEFyZ3NMaXN0LFxuICBcdGdldE5vZGU6IGdldE5vZGUsXG4gIFx0Z2V0VmFsdWU6IHByb3RvdHlwZV9nZXRWYWx1ZSxcbiAgXHRpbml0OiBGcmFnbWVudF9wcm90b3R5cGVfaW5pdCxcbiAgXHRyZWJpbmQ6IEZyYWdtZW50X3Byb3RvdHlwZV9yZWJpbmQsXG4gIFx0cmVnaXN0ZXJJbmRleFJlZjogZnVuY3Rpb24gKGlkeCkge1xuICBcdFx0dmFyIGlkeHMgPSB0aGlzLnJlZ2lzdGVyZWRJbmRleFJlZnM7XG4gIFx0XHRpZiAoaWR4cy5pbmRleE9mKGlkeCkgPT09IC0xKSB7XG4gIFx0XHRcdGlkeHMucHVzaChpZHgpO1xuICBcdFx0fVxuICBcdH0sXG4gIFx0cmVuZGVyOiBGcmFnbWVudF9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHRvU3RyaW5nOiBGcmFnbWVudF9wcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBGcmFnbWVudF9wcm90b3R5cGVfdW5iaW5kLFxuICBcdHVucmVnaXN0ZXJJbmRleFJlZjogZnVuY3Rpb24gKGlkeCkge1xuICBcdFx0dmFyIGlkeHMgPSB0aGlzLnJlZ2lzdGVyZWRJbmRleFJlZnM7XG4gIFx0XHRpZHhzLnNwbGljZShpZHhzLmluZGV4T2YoaWR4KSwgMSk7XG4gIFx0fSxcbiAgXHR1bnJlbmRlcjogRnJhZ21lbnRfcHJvdG90eXBlX3VucmVuZGVyXG4gIH07XG5cbiAgdmFyIHZpcnR1YWxkb21fRnJhZ21lbnQgPSBGcmFnbWVudDtcblxuICB2YXIgcHJvdG90eXBlX3Jlc2V0ID0gUmFjdGl2ZSRyZXNldDtcbiAgdmFyIHNob3VsZFJlcmVuZGVyID0gW1widGVtcGxhdGVcIiwgXCJwYXJ0aWFsc1wiLCBcImNvbXBvbmVudHNcIiwgXCJkZWNvcmF0b3JzXCIsIFwiZXZlbnRzXCJdLFxuICAgICAgcmVzZXRIb29rID0gbmV3IGhvb2tzX0hvb2soXCJyZXNldFwiKTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRyZXNldChkYXRhKSB7XG4gIFx0dmFyIHByb21pc2UsIHdyYXBwZXIsIGNoYW5nZXMsIGksIHJlcmVuZGVyO1xuXG4gIFx0ZGF0YSA9IGRhdGEgfHwge307XG5cbiAgXHRpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNldCBtZXRob2QgdGFrZXMgZWl0aGVyIG5vIGFyZ3VtZW50cywgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmV3IGRhdGFcIik7XG4gIFx0fVxuXG4gIFx0Ly8gSWYgdGhlIHJvb3Qgb2JqZWN0IGlzIHdyYXBwZWQsIHRyeSBhbmQgdXNlIHRoZSB3cmFwcGVyJ3MgcmVzZXQgdmFsdWVcbiAgXHRpZiAoKHdyYXBwZXIgPSB0aGlzLnZpZXdtb2RlbC53cmFwcGVkW1wiXCJdKSAmJiB3cmFwcGVyLnJlc2V0KSB7XG4gIFx0XHRpZiAod3JhcHBlci5yZXNldChkYXRhKSA9PT0gZmFsc2UpIHtcbiAgXHRcdFx0Ly8gcmVzZXQgd2FzIHJlamVjdGVkLCB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhlIG9iamVjdFxuICBcdFx0XHR0aGlzLnZpZXdtb2RlbC5yZXNldChkYXRhKTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0dGhpcy52aWV3bW9kZWwucmVzZXQoZGF0YSk7XG4gIFx0fVxuXG4gIFx0Ly8gcmVzZXQgY29uZmlnIGl0ZW1zIGFuZCB0cmFjayBpZiBuZWVkIHRvIHJlcmVuZGVyXG4gIFx0Y2hhbmdlcyA9IGNvbmZpZ19jb25maWcucmVzZXQodGhpcyk7XG5cbiAgXHRpID0gY2hhbmdlcy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKHNob3VsZFJlcmVuZGVyLmluZGV4T2YoY2hhbmdlc1tpXSkgPiAtMSkge1xuICBcdFx0XHRyZXJlbmRlciA9IHRydWU7XG4gIFx0XHRcdGJyZWFrO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChyZXJlbmRlcikge1xuICBcdFx0dmFyIGNvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxuICBcdFx0dGhpcy52aWV3bW9kZWwubWFyayhyb290S2V5cGF0aCk7XG5cbiAgXHRcdC8vIElzIHRoaXMgaXMgYSBjb21wb25lbnQsIHdlIG5lZWQgdG8gc2V0IHRoZSBgc2hvdWxkRGVzdHJveWBcbiAgXHRcdC8vIGZsYWcsIG90aGVyd2lzZSBpdCB3aWxsIGFzc3VtZSBieSBkZWZhdWx0IHRoYXQgYSBwYXJlbnQgbm9kZVxuICBcdFx0Ly8gd2lsbCBiZSBkZXRhY2hlZCwgYW5kIHRoZXJlZm9yZSBpdCBkb2Vzbid0IG5lZWQgdG8gYm90aGVyXG4gIFx0XHQvLyBkZXRhY2hpbmcgaXRzIG93biBub2Rlc1xuICBcdFx0aWYgKGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50KSB7XG4gIFx0XHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy51bnJlbmRlcigpO1xuXG4gIFx0XHRpZiAoY29tcG9uZW50KSB7XG4gIFx0XHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIElmIHRoZSB0ZW1wbGF0ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvIGRlc3Ryb3kgdGhlIHBhcmFsbGVsIERPTVxuICBcdFx0Ly8gVE9ETyBpZiB3ZSdyZSBoZXJlLCBwcmVzdW1hYmx5IGl0IGRpZD9cbiAgXHRcdGlmICh0aGlzLmZyYWdtZW50LnRlbXBsYXRlICE9PSB0aGlzLnRlbXBsYXRlKSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cbiAgXHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZSxcbiAgXHRcdFx0XHRyb290OiB0aGlzLFxuICBcdFx0XHRcdG93bmVyOiB0aGlzXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHRwcm9taXNlID0gdGhpcy5yZW5kZXIodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKHJvb3RLZXlwYXRoKTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdH1cblxuICBcdHJlc2V0SG9vay5maXJlKHRoaXMsIGRhdGEpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgcmVzZXRQYXJ0aWFsID0gZnVuY3Rpb24gKG5hbWUsIHBhcnRpYWwpIHtcbiAgXHR2YXIgcHJvbWlzZSxcbiAgXHQgICAgY29sbGVjdGlvbiA9IFtdO1xuXG4gIFx0ZnVuY3Rpb24gY29sbGVjdChzb3VyY2UsIGRlc3QsIHJhY3RpdmUpIHtcbiAgXHRcdC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgYW5kIGl0IGhhcyBpdHMgb3duIHBhcnRpYWwsIGJhaWxcbiAgXHRcdGlmIChyYWN0aXZlICYmIHJhY3RpdmUucGFydGlhbHNbbmFtZV0pIHJldHVybjtcblxuICBcdFx0c291cmNlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdFx0Ly8gcXVldWUgdG8gcmVyZW5kZXIgaWYgdGhlIGl0ZW0gaXMgYSBwYXJ0aWFsIGFuZCB0aGUgY3VycmVudCBuYW1lIG1hdGNoZXNcbiAgXHRcdFx0aWYgKGl0ZW0udHlwZSA9PT0gUEFSVElBTCAmJiBpdGVtLmdldFBhcnRpYWxOYW1lKCkgPT09IG5hbWUpIHtcbiAgXHRcdFx0XHRkZXN0LnB1c2goaXRlbSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBpZiBpdCBoYXMgYSBmcmFnbWVudCwgcHJvY2VzcyBpdHMgaXRlbXNcbiAgXHRcdFx0aWYgKGl0ZW0uZnJhZ21lbnQpIHtcbiAgXHRcdFx0XHRjb2xsZWN0KGl0ZW0uZnJhZ21lbnQuaXRlbXMsIGRlc3QsIHJhY3RpdmUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gb3IgaWYgaXQgaGFzIGZyYWdtZW50c1xuICBcdFx0XHRpZiAoaXNBcnJheShpdGVtLmZyYWdtZW50cykpIHtcbiAgXHRcdFx0XHRjb2xsZWN0KGl0ZW0uZnJhZ21lbnRzLCBkZXN0LCByYWN0aXZlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIG9yIGlmIGl0IGlzIGl0c2VsZiBhIGZyYWdtZW50LCBwcm9jZXNzIGl0cyBpdGVtc1xuICBcdFx0XHRlbHNlIGlmIChpc0FycmF5KGl0ZW0uaXRlbXMpKSB7XG4gIFx0XHRcdFx0Y29sbGVjdChpdGVtLml0ZW1zLCBkZXN0LCByYWN0aXZlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIG9yIGlmIGl0IGlzIGEgY29tcG9uZW50LCBzdGVwIGluIGFuZCBwcm9jZXNzIGl0cyBpdGVtc1xuICBcdFx0XHRlbHNlIGlmIChpdGVtLnR5cGUgPT09IENPTVBPTkVOVCAmJiBpdGVtLmluc3RhbmNlKSB7XG4gIFx0XHRcdFx0Y29sbGVjdChpdGVtLmluc3RhbmNlLmZyYWdtZW50Lml0ZW1zLCBkZXN0LCBpdGVtLmluc3RhbmNlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGlmIHRoZSBpdGVtIGlzIGFuIGVsZW1lbnQsIHByb2Nlc3MgaXRzIGF0dHJpYnV0ZXMgdG9vXG4gIFx0XHRcdGlmIChpdGVtLnR5cGUgPT09IEVMRU1FTlQpIHtcbiAgXHRcdFx0XHRpZiAoaXNBcnJheShpdGVtLmF0dHJpYnV0ZXMpKSB7XG4gIFx0XHRcdFx0XHRjb2xsZWN0KGl0ZW0uYXR0cmlidXRlcywgZGVzdCwgcmFjdGl2ZSk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKGlzQXJyYXkoaXRlbS5jb25kaXRpb25hbEF0dHJpYnV0ZXMpKSB7XG4gIFx0XHRcdFx0XHRjb2xsZWN0KGl0ZW0uY29uZGl0aW9uYWxBdHRyaWJ1dGVzLCBkZXN0LCByYWN0aXZlKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdGNvbGxlY3QodGhpcy5mcmFnbWVudC5pdGVtcywgY29sbGVjdGlvbik7XG4gIFx0dGhpcy5wYXJ0aWFsc1tuYW1lXSA9IHBhcnRpYWw7XG5cbiAgXHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG5cbiAgXHRjb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdGl0ZW0udmFsdWUgPSB1bmRlZmluZWQ7XG4gIFx0XHRpdGVtLnNldFZhbHVlKG5hbWUpO1xuICBcdH0pO1xuXG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICAvLyBUT0RPIHNob3VsZCByZXNldFRlbXBsYXRlIGJlIGFzeW5jaHJvbm91cz8gaS5lLiBzaG91bGQgaXQgYmUgYSBjYXNlXG4gIC8vIG9mIG91dHJvLCB1cGRhdGUgdGVtcGxhdGUsIGludHJvPyBJIHJlY2tvbiBwcm9iYWJseSBub3QsIHNpbmNlIHRoYXRcbiAgLy8gY291bGQgYmUgYWNoaWV2ZWQgd2l0aCB1bnJlbmRlci1yZXNldFRlbXBsYXRlLXJlbmRlci4gQWxzbywgaXQgc2hvdWxkXG4gIC8vIGNvbmNlcHR1YWxseSBiZSBzaW1pbGFyIHRvIHJlc2V0UGFydGlhbCwgd2hpY2ggY291bGRuJ3QgYmUgYXN5bmNcblxuICB2YXIgcmVzZXRUZW1wbGF0ZSA9IFJhY3RpdmUkcmVzZXRUZW1wbGF0ZTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRyZXNldFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gIFx0dmFyIHRyYW5zaXRpb25zRW5hYmxlZCwgY29tcG9uZW50O1xuXG4gIFx0dGVtcGxhdGVfdGVtcGxhdGUuaW5pdChudWxsLCB0aGlzLCB7IHRlbXBsYXRlOiB0ZW1wbGF0ZSB9KTtcblxuICBcdHRyYW5zaXRpb25zRW5hYmxlZCA9IHRoaXMudHJhbnNpdGlvbnNFbmFibGVkO1xuICBcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gZmFsc2U7XG5cbiAgXHQvLyBJcyB0aGlzIGlzIGEgY29tcG9uZW50LCB3ZSBuZWVkIHRvIHNldCB0aGUgYHNob3VsZERlc3Ryb3lgXG4gIFx0Ly8gZmxhZywgb3RoZXJ3aXNlIGl0IHdpbGwgYXNzdW1lIGJ5IGRlZmF1bHQgdGhhdCBhIHBhcmVudCBub2RlXG4gIFx0Ly8gd2lsbCBiZSBkZXRhY2hlZCwgYW5kIHRoZXJlZm9yZSBpdCBkb2Vzbid0IG5lZWQgdG8gYm90aGVyXG4gIFx0Ly8gZGV0YWNoaW5nIGl0cyBvd24gbm9kZXNcbiAgXHRpZiAoY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQpIHtcbiAgXHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHR0aGlzLnVucmVuZGVyKCk7XG5cbiAgXHRpZiAoY29tcG9uZW50KSB7XG4gIFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IGZhbHNlO1xuICBcdH1cblxuICBcdC8vIHJlbW92ZSBleGlzdGluZyBmcmFnbWVudCBhbmQgY3JlYXRlIG5ldyBvbmVcbiAgXHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZSxcbiAgXHRcdHJvb3Q6IHRoaXMsXG4gIFx0XHRvd25lcjogdGhpc1xuICBcdH0pO1xuXG4gIFx0dGhpcy5yZW5kZXIodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuXG4gIFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSB0cmFuc2l0aW9uc0VuYWJsZWQ7XG4gIH1cblxuICB2YXIgcmV2ZXJzZSA9IG1ha2VBcnJheU1ldGhvZChcInJldmVyc2VcIik7XG5cbiAgdmFyIFJhY3RpdmVfcHJvdG90eXBlX3NldCA9IFJhY3RpdmUkc2V0O1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkc2V0KGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0dmFyIG1hcCwgcHJvbWlzZTtcblxuICBcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcblxuICBcdC8vIFNldCBtdWx0aXBsZSBrZXlwYXRocyBpbiBvbmUgZ29cbiAgXHRpZiAoaXNPYmplY3Qoa2V5cGF0aCkpIHtcbiAgXHRcdG1hcCA9IGtleXBhdGg7XG5cbiAgXHRcdGZvciAoa2V5cGF0aCBpbiBtYXApIHtcbiAgXHRcdFx0aWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShrZXlwYXRoKSkge1xuICBcdFx0XHRcdHZhbHVlID0gbWFwW2tleXBhdGhdO1xuICBcdFx0XHRcdHNldCh0aGlzLCBrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBTZXQgYSBzaW5nbGUga2V5cGF0aFxuICBcdGVsc2Uge1xuICBcdFx0c2V0KHRoaXMsIGtleXBhdGgsIHZhbHVlKTtcbiAgXHR9XG5cbiAgXHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0KHJhY3RpdmUsIGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0a2V5cGF0aCA9IGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKTtcblxuICBcdGlmIChrZXlwYXRoLmlzUGF0dGVybikge1xuICBcdFx0Z2V0TWF0Y2hpbmdLZXlwYXRocyhyYWN0aXZlLCBrZXlwYXRoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnNldChrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0XHR9KTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmFjdGl2ZS52aWV3bW9kZWwuc2V0KGtleXBhdGgsIHZhbHVlKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgc2hpZnQgPSBtYWtlQXJyYXlNZXRob2QoXCJzaGlmdFwiKTtcblxuICB2YXIgcHJvdG90eXBlX3NvcnQgPSBtYWtlQXJyYXlNZXRob2QoXCJzb3J0XCIpO1xuXG4gIHZhciBzcGxpY2UgPSBtYWtlQXJyYXlNZXRob2QoXCJzcGxpY2VcIik7XG5cbiAgdmFyIHN1YnRyYWN0ID0gUmFjdGl2ZSRzdWJ0cmFjdDtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRzdWJ0cmFjdChrZXlwYXRoLCBkKSB7XG4gIFx0cmV0dXJuIHNoYXJlZF9hZGQodGhpcywga2V5cGF0aCwgZCA9PT0gdW5kZWZpbmVkID8gLTEgOiAtZCk7XG4gIH1cblxuICAvLyBUZWFyZG93bi4gVGhpcyBnb2VzIHRocm91Z2ggdGhlIHJvb3QgZnJhZ21lbnQgYW5kIGFsbCBpdHMgY2hpbGRyZW4sIHJlbW92aW5nIG9ic2VydmVyc1xuICAvLyBhbmQgZ2VuZXJhbGx5IGNsZWFuaW5nIHVwIGFmdGVyIGl0c2VsZlxuXG4gIHZhciBSYWN0aXZlX3Byb3RvdHlwZV90ZWFyZG93biA9IFJhY3RpdmUkdGVhcmRvd247XG5cbiAgdmFyIFJhY3RpdmVfcHJvdG90eXBlX3RlYXJkb3duX190ZWFyZG93bkhvb2sgPSBuZXcgaG9va3NfSG9vayhcInRlYXJkb3duXCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHRlYXJkb3duKCkge1xuICBcdHZhciBwcm9taXNlO1xuXG4gIFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR0aGlzLnZpZXdtb2RlbC50ZWFyZG93bigpO1xuXG4gIFx0dGhpcy5fb2JzZXJ2ZXJzLmZvckVhY2goY2FuY2VsKTtcblxuICBcdGlmICh0aGlzLmZyYWdtZW50LnJlbmRlcmVkICYmIHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIHRoaXMpO1xuICBcdH1cblxuICBcdHRoaXMuc2hvdWxkRGVzdHJveSA9IHRydWU7XG4gIFx0cHJvbWlzZSA9IHRoaXMuZnJhZ21lbnQucmVuZGVyZWQgPyB0aGlzLnVucmVuZGVyKCkgOiB1dGlsc19Qcm9taXNlLnJlc29sdmUoKTtcblxuICBcdFJhY3RpdmVfcHJvdG90eXBlX3RlYXJkb3duX190ZWFyZG93bkhvb2suZmlyZSh0aGlzKTtcblxuICBcdHRoaXMuX2JvdW5kRnVuY3Rpb25zLmZvckVhY2goZGVsZXRlRnVuY3Rpb25Db3B5KTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlRnVuY3Rpb25Db3B5KGJvdW5kKSB7XG4gIFx0ZGVsZXRlIGJvdW5kLmZuW2JvdW5kLnByb3BdO1xuICB9XG5cbiAgdmFyIHRvZ2dsZSA9IFJhY3RpdmUkdG9nZ2xlO1xuICBmdW5jdGlvbiBSYWN0aXZlJHRvZ2dsZShrZXlwYXRoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdGlmICh0eXBlb2Yga2V5cGF0aCAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihiYWRBcmd1bWVudHMpO1xuICBcdH1cblxuICBcdHZhciBjaGFuZ2VzID0gdW5kZWZpbmVkO1xuXG4gIFx0aWYgKC9cXCovLnRlc3Qoa2V5cGF0aCkpIHtcbiAgXHRcdGNoYW5nZXMgPSB7fTtcblxuICBcdFx0Z2V0TWF0Y2hpbmdLZXlwYXRocyh0aGlzLCBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSkpLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0Y2hhbmdlc1trZXlwYXRoLnN0cl0gPSAhX3RoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXQoY2hhbmdlcyk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMuc2V0KGtleXBhdGgsICF0aGlzLmdldChrZXlwYXRoKSk7XG4gIH1cblxuICB2YXIgdG9IVE1MID0gUmFjdGl2ZSR0b0hUTUw7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSR0b0hUTUwoKSB7XG4gIFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcodHJ1ZSk7XG4gIH1cblxuICB2YXIgUmFjdGl2ZV9wcm90b3R5cGVfdW5yZW5kZXIgPSBSYWN0aXZlJHVucmVuZGVyO1xuICB2YXIgdW5yZW5kZXJIb29rID0gbmV3IGhvb2tzX0hvb2soXCJ1bnJlbmRlclwiKTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSR1bnJlbmRlcigpIHtcbiAgXHR2YXIgcHJvbWlzZSwgc2hvdWxkRGVzdHJveTtcblxuICBcdGlmICghdGhpcy5mcmFnbWVudC5yZW5kZXJlZCkge1xuICBcdFx0d2FybklmRGVidWcoXCJyYWN0aXZlLnVucmVuZGVyKCkgd2FzIGNhbGxlZCBvbiBhIFJhY3RpdmUgaW5zdGFuY2UgdGhhdCB3YXMgbm90IHJlbmRlcmVkXCIpO1xuICBcdFx0cmV0dXJuIHV0aWxzX1Byb21pc2UucmVzb2x2ZSgpO1xuICBcdH1cblxuICBcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcblxuICBcdC8vIElmIHRoaXMgaXMgYSBjb21wb25lbnQsIGFuZCB0aGUgY29tcG9uZW50IGlzbid0IG1hcmtlZCBmb3IgZGVzdHJ1Y3Rpb24sXG4gIFx0Ly8gZG9uJ3QgZGV0YWNoIG5vZGVzIGZyb20gdGhlIERPTSB1bm5lY2Vzc2FyaWx5XG4gIFx0c2hvdWxkRGVzdHJveSA9ICF0aGlzLmNvbXBvbmVudCB8fCB0aGlzLmNvbXBvbmVudC5zaG91bGREZXN0cm95IHx8IHRoaXMuc2hvdWxkRGVzdHJveTtcblxuICBcdC8vIENhbmNlbCBhbnkgYW5pbWF0aW9ucyBpbiBwcm9ncmVzc1xuICBcdHdoaWxlICh0aGlzLl9hbmltYXRpb25zWzBdKSB7XG4gIFx0XHR0aGlzLl9hbmltYXRpb25zWzBdLnN0b3AoKTsgLy8gaXQgd2lsbCByZW1vdmUgaXRzZWxmIGZyb20gdGhlIGluZGV4XG4gIFx0fVxuXG4gIFx0dGhpcy5mcmFnbWVudC51bnJlbmRlcihzaG91bGREZXN0cm95KTtcblxuICBcdHJlbW92ZUZyb21BcnJheSh0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgdGhpcyk7XG5cbiAgXHR1bnJlbmRlckhvb2suZmlyZSh0aGlzKTtcblxuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgdmFyIHVuc2hpZnQgPSBtYWtlQXJyYXlNZXRob2QoXCJ1bnNoaWZ0XCIpO1xuXG4gIHZhciBSYWN0aXZlX3Byb3RvdHlwZV91cGRhdGUgPSBSYWN0aXZlJHVwZGF0ZTtcbiAgdmFyIHVwZGF0ZUhvb2sgPSBuZXcgaG9va3NfSG9vayhcInVwZGF0ZVwiKTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSR1cGRhdGUoa2V5cGF0aCkge1xuICBcdHZhciBwcm9taXNlO1xuXG4gIFx0a2V5cGF0aCA9IGdldEtleXBhdGgoa2V5cGF0aCkgfHwgcm9vdEtleXBhdGg7XG5cbiAgXHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG4gIFx0dGhpcy52aWV3bW9kZWwubWFyayhrZXlwYXRoKTtcbiAgXHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdHVwZGF0ZUhvb2suZmlyZSh0aGlzLCBrZXlwYXRoKTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV91cGRhdGVNb2RlbCA9IFJhY3RpdmUkdXBkYXRlTW9kZWw7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSR1cGRhdGVNb2RlbChrZXlwYXRoLCBjYXNjYWRlKSB7XG4gIFx0dmFyIHZhbHVlcywga2V5LCBiaW5kaW5ncztcblxuICBcdGlmICh0eXBlb2Yga2V5cGF0aCA9PT0gXCJzdHJpbmdcIiAmJiAhY2FzY2FkZSkge1xuICBcdFx0YmluZGluZ3MgPSB0aGlzLl90d293YXlCaW5kaW5nc1trZXlwYXRoXTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0YmluZGluZ3MgPSBbXTtcblxuICBcdFx0Zm9yIChrZXkgaW4gdGhpcy5fdHdvd2F5QmluZGluZ3MpIHtcbiAgXHRcdFx0aWYgKCFrZXlwYXRoIHx8IGdldEtleXBhdGgoa2V5KS5lcXVhbHNPclN0YXJ0c1dpdGgoa2V5cGF0aCkpIHtcbiAgXHRcdFx0XHQvLyBUT0RPIGlzIHRoaXMgcmlnaHQ/XG4gIFx0XHRcdFx0YmluZGluZ3MucHVzaC5hcHBseShiaW5kaW5ncywgdGhpcy5fdHdvd2F5QmluZGluZ3Nba2V5XSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR2YWx1ZXMgPSBjb25zb2xpZGF0ZSh0aGlzLCBiaW5kaW5ncyk7XG4gIFx0cmV0dXJuIHRoaXMuc2V0KHZhbHVlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zb2xpZGF0ZShyYWN0aXZlLCBiaW5kaW5ncykge1xuICBcdHZhciB2YWx1ZXMgPSB7fSxcbiAgXHQgICAgY2hlY2tib3hHcm91cHMgPSBbXTtcblxuICBcdGJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgXHRcdHZhciBvbGRWYWx1ZSwgbmV3VmFsdWU7XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIHJhZGlvIG5hbWUgYmluZGluZ3NcbiAgXHRcdGlmIChiLnJhZGlvTmFtZSAmJiAhYi5lbGVtZW50Lm5vZGUuY2hlY2tlZCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGNoZWNrYm94IG5hbWUgYmluZGluZ3MgY29tZSBpbiBncm91cHMsIHNvXG4gIFx0XHQvLyB3ZSB3YW50IHRvIGdldCB0aGUgdmFsdWUgb25jZSBhdCBtb3N0XG4gIFx0XHRpZiAoYi5jaGVja2JveE5hbWUpIHtcbiAgXHRcdFx0aWYgKCFjaGVja2JveEdyb3Vwc1tiLmtleXBhdGguc3RyXSAmJiAhYi5jaGFuZ2VkKCkpIHtcbiAgXHRcdFx0XHRjaGVja2JveEdyb3Vwcy5wdXNoKGIua2V5cGF0aCk7XG4gIFx0XHRcdFx0Y2hlY2tib3hHcm91cHNbYi5rZXlwYXRoLnN0cl0gPSBiO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRvbGRWYWx1ZSA9IGIuYXR0cmlidXRlLnZhbHVlO1xuICBcdFx0bmV3VmFsdWUgPSBiLmdldFZhbHVlKCk7XG5cbiAgXHRcdGlmIChhcnJheUNvbnRlbnRzTWF0Y2gob2xkVmFsdWUsIG5ld1ZhbHVlKSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghaXNFcXVhbChvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gIFx0XHRcdHZhbHVlc1tiLmtleXBhdGguc3RyXSA9IG5ld1ZhbHVlO1xuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0Ly8gSGFuZGxlIGdyb3VwcyBvZiBgPGlucHV0IHR5cGU9J2NoZWNrYm94JyBuYW1lPSd7e2Zvb319JyAuLi4+YFxuICBcdGlmIChjaGVja2JveEdyb3Vwcy5sZW5ndGgpIHtcbiAgXHRcdGNoZWNrYm94R3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0dmFyIGJpbmRpbmcsIG9sZFZhbHVlLCBuZXdWYWx1ZTtcblxuICBcdFx0XHRiaW5kaW5nID0gY2hlY2tib3hHcm91cHNba2V5cGF0aC5zdHJdOyAvLyBvbmUgdG8gcmVwcmVzZW50IHRoZSBlbnRpcmUgZ3JvdXBcbiAgXHRcdFx0b2xkVmFsdWUgPSBiaW5kaW5nLmF0dHJpYnV0ZS52YWx1ZTtcbiAgXHRcdFx0bmV3VmFsdWUgPSBiaW5kaW5nLmdldFZhbHVlKCk7XG5cbiAgXHRcdFx0aWYgKCFhcnJheUNvbnRlbnRzTWF0Y2gob2xkVmFsdWUsIG5ld1ZhbHVlKSkge1xuICBcdFx0XHRcdHZhbHVlc1trZXlwYXRoLnN0cl0gPSBuZXdWYWx1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSB7XG4gIFx0YWRkOiBwcm90b3R5cGVfYWRkLFxuICBcdGFuaW1hdGU6IHByb3RvdHlwZV9hbmltYXRlLFxuICBcdGRldGFjaDogcHJvdG90eXBlX2RldGFjaCxcbiAgXHRmaW5kOiBwcm90b3R5cGVfZmluZCxcbiAgXHRmaW5kQWxsOiBwcm90b3R5cGVfZmluZEFsbCxcbiAgXHRmaW5kQWxsQ29tcG9uZW50czogcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzLFxuICBcdGZpbmRDb21wb25lbnQ6IHByb3RvdHlwZV9maW5kQ29tcG9uZW50LFxuICBcdGZpbmRDb250YWluZXI6IGZpbmRDb250YWluZXIsXG4gIFx0ZmluZFBhcmVudDogZmluZFBhcmVudCxcbiAgXHRmaXJlOiBwcm90b3R5cGVfZmlyZSxcbiAgXHRnZXQ6IHByb3RvdHlwZV9nZXQsXG4gIFx0aW5zZXJ0OiBpbnNlcnQsXG4gIFx0bWVyZ2U6IHByb3RvdHlwZV9tZXJnZSxcbiAgXHRvYnNlcnZlOiBvYnNlcnZlLFxuICBcdG9ic2VydmVPbmNlOiBvYnNlcnZlT25jZSxcbiAgXHRvZmY6IG9mZixcbiAgXHRvbjogb24sXG4gIFx0b25jZTogb25jZSxcbiAgXHRwb3A6IHBvcCxcbiAgXHRwdXNoOiBwdXNoLFxuICBcdHJlbmRlcjogcHJvdG90eXBlX3JlbmRlcixcbiAgXHRyZXNldDogcHJvdG90eXBlX3Jlc2V0LFxuICBcdHJlc2V0UGFydGlhbDogcmVzZXRQYXJ0aWFsLFxuICBcdHJlc2V0VGVtcGxhdGU6IHJlc2V0VGVtcGxhdGUsXG4gIFx0cmV2ZXJzZTogcmV2ZXJzZSxcbiAgXHRzZXQ6IFJhY3RpdmVfcHJvdG90eXBlX3NldCxcbiAgXHRzaGlmdDogc2hpZnQsXG4gIFx0c29ydDogcHJvdG90eXBlX3NvcnQsXG4gIFx0c3BsaWNlOiBzcGxpY2UsXG4gIFx0c3VidHJhY3Q6IHN1YnRyYWN0LFxuICBcdHRlYXJkb3duOiBSYWN0aXZlX3Byb3RvdHlwZV90ZWFyZG93bixcbiAgXHR0b2dnbGU6IHRvZ2dsZSxcbiAgXHR0b0hUTUw6IHRvSFRNTCxcbiAgXHR0b0h0bWw6IHRvSFRNTCxcbiAgXHR1bnJlbmRlcjogUmFjdGl2ZV9wcm90b3R5cGVfdW5yZW5kZXIsXG4gIFx0dW5zaGlmdDogdW5zaGlmdCxcbiAgXHR1cGRhdGU6IFJhY3RpdmVfcHJvdG90eXBlX3VwZGF0ZSxcbiAgXHR1cGRhdGVNb2RlbDogcHJvdG90eXBlX3VwZGF0ZU1vZGVsXG4gIH07XG5cbiAgdmFyIHdyYXBNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kLCBzdXBlck1ldGhvZCwgZm9yY2UpIHtcblxuICBcdGlmIChmb3JjZSB8fCBuZWVkc1N1cGVyKG1ldGhvZCwgc3VwZXJNZXRob2QpKSB7XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgXHRcdFx0dmFyIGhhc1N1cGVyID0gKFwiX3N1cGVyXCIgaW4gdGhpcyksXG4gIFx0XHRcdCAgICBfc3VwZXIgPSB0aGlzLl9zdXBlcixcbiAgXHRcdFx0ICAgIHJlc3VsdDtcblxuICBcdFx0XHR0aGlzLl9zdXBlciA9IHN1cGVyTWV0aG9kO1xuXG4gIFx0XHRcdHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIFx0XHRcdGlmIChoYXNTdXBlcikge1xuICBcdFx0XHRcdHRoaXMuX3N1cGVyID0gX3N1cGVyO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHRcdH07XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiBtZXRob2Q7XG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIG5lZWRzU3VwZXIobWV0aG9kLCBzdXBlck1ldGhvZCkge1xuICBcdHJldHVybiB0eXBlb2Ygc3VwZXJNZXRob2QgPT09IFwiZnVuY3Rpb25cIiAmJiAvX3N1cGVyLy50ZXN0KG1ldGhvZCk7XG4gIH1cblxuICB2YXIgdW53cmFwRXh0ZW5kZWQgPSB1bndyYXA7XG5cbiAgZnVuY3Rpb24gdW53cmFwKENoaWxkKSB7XG4gIFx0dmFyIG9wdGlvbnMgPSB7fTtcblxuICBcdHdoaWxlIChDaGlsZCkge1xuICBcdFx0YWRkUmVnaXN0cmllcyhDaGlsZCwgb3B0aW9ucyk7XG4gIFx0XHRhZGRPdGhlck9wdGlvbnMoQ2hpbGQsIG9wdGlvbnMpO1xuXG4gIFx0XHRpZiAoQ2hpbGQuX1BhcmVudCAhPT0gX1JhY3RpdmUpIHtcbiAgXHRcdFx0Q2hpbGQgPSBDaGlsZC5fUGFyZW50O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Q2hpbGQgPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gb3B0aW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFJlZ2lzdHJpZXMoQ2hpbGQsIG9wdGlvbnMpIHtcbiAgXHRjb25maWdfcmVnaXN0cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gIFx0XHRhZGRSZWdpc3RyeShyLnVzZURlZmF1bHRzID8gQ2hpbGQucHJvdG90eXBlIDogQ2hpbGQsIG9wdGlvbnMsIHIubmFtZSk7XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRSZWdpc3RyeSh0YXJnZXQsIG9wdGlvbnMsIG5hbWUpIHtcbiAgXHR2YXIgcmVnaXN0cnksXG4gIFx0ICAgIGtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXRbbmFtZV0pO1xuXG4gIFx0aWYgKCFrZXlzLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmICghKHJlZ2lzdHJ5ID0gb3B0aW9uc1tuYW1lXSkpIHtcbiAgXHRcdHJlZ2lzdHJ5ID0gb3B0aW9uc1tuYW1lXSA9IHt9O1xuICBcdH1cblxuICBcdGtleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdHJldHVybiAhKGtleSBpbiByZWdpc3RyeSk7XG4gIFx0fSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHRyZXR1cm4gcmVnaXN0cnlba2V5XSA9IHRhcmdldFtuYW1lXVtrZXldO1xuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkT3RoZXJPcHRpb25zKENoaWxkLCBvcHRpb25zKSB7XG4gIFx0T2JqZWN0LmtleXMoQ2hpbGQucHJvdG90eXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdGlmIChrZXkgPT09IFwiY29tcHV0ZWRcIikge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHZhciB2YWx1ZSA9IENoaWxkLnByb3RvdHlwZVtrZXldO1xuXG4gIFx0XHRpZiAoIShrZXkgaW4gb3B0aW9ucykpIHtcbiAgXHRcdFx0b3B0aW9uc1trZXldID0gdmFsdWUuX21ldGhvZCA/IHZhbHVlLl9tZXRob2QgOiB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gaXMgaXQgYSB3cmFwcGVkIGZ1bmN0aW9uP1xuICBcdFx0ZWxzZSBpZiAodHlwZW9mIG9wdGlvbnNba2V5XSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmIG9wdGlvbnNba2V5XS5fbWV0aG9kKSB7XG5cbiAgXHRcdFx0dmFyIHJlc3VsdCA9IHVuZGVmaW5lZCxcbiAgXHRcdFx0ICAgIG5lZWRzU3VwZXIgPSB2YWx1ZS5fbWV0aG9kO1xuXG4gIFx0XHRcdGlmIChuZWVkc1N1cGVyKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5fbWV0aG9kO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gcmV3cmFwIGJvdW5kIGRpcmVjdGx5IHRvIHBhcmVudCBmblxuICBcdFx0XHRyZXN1bHQgPSB3cmFwTWV0aG9kKG9wdGlvbnNba2V5XS5fbWV0aG9kLCB2YWx1ZSk7XG5cbiAgXHRcdFx0aWYgKG5lZWRzU3VwZXIpIHtcbiAgXHRcdFx0XHRyZXN1bHQuX21ldGhvZCA9IHJlc3VsdDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdG9wdGlvbnNba2V5XSA9IHJlc3VsdDtcbiAgXHRcdH1cbiAgXHR9KTtcbiAgfVxuXG4gIHZhciBfZXh0ZW5kID0gX2V4dGVuZF9fZXh0ZW5kO1xuXG4gIGZ1bmN0aW9uIF9leHRlbmRfX2V4dGVuZCgpIHtcbiAgXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgb3B0aW9ucyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0b3B0aW9uc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHR9XG5cbiAgXHRpZiAoIW9wdGlvbnMubGVuZ3RoKSB7XG4gIFx0XHRyZXR1cm4gZXh0ZW5kT25lKHRoaXMpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gb3B0aW9ucy5yZWR1Y2UoZXh0ZW5kT25lLCB0aGlzKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmRPbmUoUGFyZW50KSB7XG4gIFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gIFx0dmFyIENoaWxkLCBwcm90bztcblxuICBcdC8vIGlmIHdlJ3JlIGV4dGVuZGluZyB3aXRoIGFub3RoZXIgUmFjdGl2ZSBpbnN0YW5jZS4uLlxuICBcdC8vXG4gIFx0Ly8gICB2YXIgSHVtYW4gPSBSYWN0aXZlLmV4dGVuZCguLi4pLCBTcGlkZXIgPSBSYWN0aXZlLmV4dGVuZCguLi4pO1xuICBcdC8vICAgdmFyIFNwaWRlcm1hbiA9IEh1bWFuLmV4dGVuZCggU3BpZGVyICk7XG4gIFx0Ly9cbiAgXHQvLyAuLi5pbmhlcml0IHByb3RvdHlwZSBtZXRob2RzIGFuZCBkZWZhdWx0IG9wdGlvbnMgYXMgd2VsbFxuICBcdGlmIChvcHRpb25zLnByb3RvdHlwZSBpbnN0YW5jZW9mIF9SYWN0aXZlKSB7XG4gIFx0XHRvcHRpb25zID0gdW53cmFwRXh0ZW5kZWQob3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0Q2hpbGQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIENoaWxkKSkgcmV0dXJuIG5ldyBDaGlsZChvcHRpb25zKTtcbiAgXHRcdGluaXRpYWxpc2UodGhpcywgb3B0aW9ucyk7XG4gIFx0fTtcblxuICBcdHByb3RvID0gY3JlYXRlKFBhcmVudC5wcm90b3R5cGUpO1xuICBcdHByb3RvLmNvbnN0cnVjdG9yID0gQ2hpbGQ7XG5cbiAgXHQvLyBTdGF0aWMgcHJvcGVydGllc1xuICBcdGRlZmluZVByb3BlcnRpZXMoQ2hpbGQsIHtcbiAgXHRcdC8vIGFsaWFzIHByb3RvdHlwZSBhcyBkZWZhdWx0c1xuICBcdFx0ZGVmYXVsdHM6IHsgdmFsdWU6IHByb3RvIH0sXG5cbiAgXHRcdC8vIGV4dGVuZGFibGVcbiAgXHRcdGV4dGVuZDogeyB2YWx1ZTogX2V4dGVuZF9fZXh0ZW5kLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0sXG5cbiAgXHRcdC8vIFBhcmVudCAtIGZvciBJRTgsIGNhbid0IHVzZSBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbiAgXHRcdF9QYXJlbnQ6IHsgdmFsdWU6IFBhcmVudCB9XG4gIFx0fSk7XG5cbiAgXHQvLyBleHRlbmQgY29uZmlndXJhdGlvblxuICBcdGNvbmZpZ19jb25maWcuZXh0ZW5kKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpO1xuXG4gIFx0Y3VzdG9tX2RhdGEuZXh0ZW5kKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpO1xuXG4gIFx0aWYgKG9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgXHRcdHByb3RvLmNvbXB1dGVkID0gdXRpbHNfb2JqZWN0X19leHRlbmQoY3JlYXRlKFBhcmVudC5wcm90b3R5cGUuY29tcHV0ZWQpLCBvcHRpb25zLmNvbXB1dGVkKTtcbiAgXHR9XG5cbiAgXHRDaGlsZC5wcm90b3R5cGUgPSBwcm90bztcblxuICBcdHJldHVybiBDaGlsZDtcbiAgfVxuXG4gIHZhciBnZXROb2RlSW5mbyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIFx0dmFyIGluZm8gPSB7fSxcbiAgXHQgICAgcHJpdixcbiAgXHQgICAgaW5kaWNlcztcblxuICBcdGlmICghbm9kZSB8fCAhKHByaXYgPSBub2RlLl9yYWN0aXZlKSkge1xuICBcdFx0cmV0dXJuIGluZm87XG4gIFx0fVxuXG4gIFx0aW5mby5yYWN0aXZlID0gcHJpdi5yb290O1xuICBcdGluZm8ua2V5cGF0aCA9IHByaXYua2V5cGF0aC5zdHI7XG4gIFx0aW5mby5pbmRleCA9IHt9O1xuXG4gIFx0Ly8gZmluZCBhbGwgaW5kZXggcmVmZXJlbmNlcyBhbmQgcmVzb2x2ZSB0aGVtXG4gIFx0aWYgKGluZGljZXMgPSBSZXNvbHZlcnNfZmluZEluZGV4UmVmcyhwcml2LnByb3h5LnBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0aW5mby5pbmRleCA9IFJlc29sdmVyc19maW5kSW5kZXhSZWZzLnJlc29sdmUoaW5kaWNlcyk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGluZm87XG4gIH07XG5cbiAgdmFyIFJhY3RpdmUsIHByb3BlcnRpZXM7XG5cbiAgLy8gTWFpbiBSYWN0aXZlIHJlcXVpcmVkIG9iamVjdFxuICBSYWN0aXZlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFjdGl2ZSkpIHJldHVybiBuZXcgUmFjdGl2ZShvcHRpb25zKTtcbiAgXHRpbml0aWFsaXNlKHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIC8vIFJhY3RpdmUgcHJvcGVydGllc1xuICBwcm9wZXJ0aWVzID0ge1xuXG4gIFx0Ly8gZGVidWcgZmxhZ1xuICBcdERFQlVHOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdHJ1ZSB9LFxuICBcdERFQlVHX1BST01JU0VTOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdHJ1ZSB9LFxuXG4gIFx0Ly8gc3RhdGljIG1ldGhvZHM6XG4gIFx0ZXh0ZW5kOiB7IHZhbHVlOiBfZXh0ZW5kIH0sXG4gIFx0Z2V0Tm9kZUluZm86IHsgdmFsdWU6IGdldE5vZGVJbmZvIH0sXG4gIFx0cGFyc2U6IHsgdmFsdWU6IF9wYXJzZSB9LFxuXG4gIFx0Ly8gTmFtZXNwYWNlZCBjb25zdHJ1Y3RvcnNcbiAgXHRQcm9taXNlOiB7IHZhbHVlOiB1dGlsc19Qcm9taXNlIH0sXG5cbiAgXHQvLyBzdXBwb3J0XG4gIFx0c3ZnOiB7IHZhbHVlOiBzdmcgfSxcbiAgXHRtYWdpYzogeyB2YWx1ZTogZW52aXJvbm1lbnRfX21hZ2ljIH0sXG5cbiAgXHQvLyB2ZXJzaW9uXG4gIFx0VkVSU0lPTjogeyB2YWx1ZTogXCIwLjcuMlwiIH0sXG5cbiAgXHQvLyBQbHVnaW5zXG4gIFx0YWRhcHRvcnM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuICBcdGNvbXBvbmVudHM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuICBcdGRlY29yYXRvcnM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuICBcdGVhc2luZzogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHN0YXRpY19lYXNpbmcgfSxcbiAgXHRldmVudHM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuICBcdGludGVycG9sYXRvcnM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBzdGF0aWNfaW50ZXJwb2xhdG9ycyB9LFxuICBcdHBhcnRpYWxzOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcbiAgXHR0cmFuc2l0aW9uczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH1cbiAgfTtcblxuICAvLyBSYWN0aXZlIHByb3BlcnRpZXNcbiAgZGVmaW5lUHJvcGVydGllcyhSYWN0aXZlLCBwcm9wZXJ0aWVzKTtcblxuICBSYWN0aXZlLnByb3RvdHlwZSA9IHV0aWxzX29iamVjdF9fZXh0ZW5kKHByb3RvdHlwZSwgY29uZmlnX2RlZmF1bHRzKTtcblxuICBSYWN0aXZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJhY3RpdmU7XG5cbiAgLy8gYWxpYXMgcHJvdG90eXBlIGFzIGRlZmF1bHRzXG4gIFJhY3RpdmUuZGVmYXVsdHMgPSBSYWN0aXZlLnByb3RvdHlwZTtcblxuICAvLyBSYWN0aXZlLmpzIG1ha2VzIGxpYmVyYWwgdXNlIG9mIHRoaW5ncyBsaWtlIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLiBJblxuICAvLyBvbGRlciBicm93c2VycywgdGhlc2UgYXJlIG1hZGUgYXZhaWxhYmxlIHZpYSBhIHNoaW0gLSBoZXJlLCB3ZSBkbyBhIHF1aWNrXG4gIC8vIHByZS1mbGlnaHQgY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXQgZWl0aGVyIGEpIHdlJ3JlIG5vdCBpbiBhIHNoaXQgYnJvd3NlcixcbiAgLy8gb3IgYikgd2UncmUgdXNpbmcgYSBSYWN0aXZlLWxlZ2FjeS5qcyBidWlsZFxuICB2YXIgRlVOQ1RJT04gPSBcImZ1bmN0aW9uXCI7XG5cbiAgaWYgKHR5cGVvZiBEYXRlLm5vdyAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIFN0cmluZy5wcm90b3R5cGUudHJpbSAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIE9iamVjdC5rZXlzICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5tYXAgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZmlsdGVyICE9PSBGVU5DVElPTiB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gRlVOQ1RJT04pIHtcbiAgXHR0aHJvdyBuZXcgRXJyb3IoXCJJdCBsb29rcyBsaWtlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVzZSBSYWN0aXZlLmpzIGluIGFuIG9sZGVyIGJyb3dzZXIuIFlvdSdsbCBuZWVkIHRvIHVzZSBvbmUgb2YgdGhlICdsZWdhY3kgYnVpbGRzJyBpbiBvcmRlciB0byBjb250aW51ZSAtIHNlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9sZWdhY3ktYnVpbGRzIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiKTtcbiAgfVxuXG4gIHZhciBfUmFjdGl2ZSA9IFJhY3RpdmU7XG5cbiAgcmV0dXJuIF9SYWN0aXZlO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYWN0aXZlLmpzLm1hcFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmFjdGl2ZS9yYWN0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=');

}});