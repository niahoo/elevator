!function(n){function c(e){if(t[e])return t[e].exports;var d=t[e]={exports:{},id:e,loaded:!1};return n[e].call(d.exports,d,d.exports,c),d.loaded=!0,d.exports}var t={};return c.m=n,c.c=t,c.p="",c(0)}([function(module,exports,__webpack_require__){eval("/*var graphics = require('graphics')\r\nvar elevator = require('elevator')\r\nvar Storey = require('model/Storey')\r\nvar CONF = require('conf')\r\n\r\nconsole.log('WontRepair initializing')\r\n\r\nwindow.WontRepair = function(node) {\r\n	// initialize\r\n	var storeys = [new Storey(0), new Storey(1), new Storey(2)]\r\n	var elv = elevator.createElevator()\r\n	var renderer = graphics.createRenderer({\r\n		domnode:node,\r\n		elevator:elv,\r\n		storeys: storeys\r\n	})\r\n	window.elv = elv // DEBUG\r\n	setTimeout(function(){ elv.addWaypointUp(1) }, 1000)\r\n}\r\n\r\nconsole.log('WontRepair installed')\r\n*/\r\n\r\nvar Proc = __webpack_require__(3)\r\nvar p = Proc.spawn(function(){\r\n	console.log('initializing')\r\n	console.log('calling next into initilize')\r\n	this.next(loop)\r\n})\r\n\r\nfunction loop() {\r\n	this.trace('entering loop')\r\n	console.log(' - this : ', this)\r\n	this.receive('wakeup', function(){\r\n		console.log('received wakeup')\r\n		this.next()\r\n	}).receive({type:'val'}, function(message){\r\n		console.log('received value : ', message.val)\r\n		this.next()\r\n	}).receive(150, handle_150)\r\n}\r\n\r\nfunction handle_150(val) {\r\n	console.log(val + ' === 150')\r\n	this.next()\r\n}\r\n\r\np.send('wakeup')\r\np.send({type:'val', val:'spa'})\r\np.send('wakeup')\r\np.send(150)\r\np.send('wakeup')\r\n\r\n\r\nconsole.log('proc p',p)\r\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvbWFpbi5qcz8xZTNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxXQUFXLFdBQVc7QUFDeEI7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTs7O0FBR0EiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qdmFyIGdyYXBoaWNzID0gcmVxdWlyZSgnZ3JhcGhpY3MnKVxyXG52YXIgZWxldmF0b3IgPSByZXF1aXJlKCdlbGV2YXRvcicpXHJcbnZhciBTdG9yZXkgPSByZXF1aXJlKCdtb2RlbC9TdG9yZXknKVxyXG52YXIgQ09ORiA9IHJlcXVpcmUoJ2NvbmYnKVxyXG5cclxuY29uc29sZS5sb2coJ1dvbnRSZXBhaXIgaW5pdGlhbGl6aW5nJylcclxuXHJcbndpbmRvdy5Xb250UmVwYWlyID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdC8vIGluaXRpYWxpemVcclxuXHR2YXIgc3RvcmV5cyA9IFtuZXcgU3RvcmV5KDApLCBuZXcgU3RvcmV5KDEpLCBuZXcgU3RvcmV5KDIpXVxyXG5cdHZhciBlbHYgPSBlbGV2YXRvci5jcmVhdGVFbGV2YXRvcigpXHJcblx0dmFyIHJlbmRlcmVyID0gZ3JhcGhpY3MuY3JlYXRlUmVuZGVyZXIoe1xyXG5cdFx0ZG9tbm9kZTpub2RlLFxyXG5cdFx0ZWxldmF0b3I6ZWx2LFxyXG5cdFx0c3RvcmV5czogc3RvcmV5c1xyXG5cdH0pXHJcblx0d2luZG93LmVsdiA9IGVsdiAvLyBERUJVR1xyXG5cdHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgZWx2LmFkZFdheXBvaW50VXAoMSkgfSwgMTAwMClcclxufVxyXG5cclxuY29uc29sZS5sb2coJ1dvbnRSZXBhaXIgaW5zdGFsbGVkJylcclxuKi9cclxuXHJcbnZhciBQcm9jID0gcmVxdWlyZSgncHJvYycpXHJcbnZhciBwID0gUHJvYy5zcGF3bihmdW5jdGlvbigpe1xyXG5cdGNvbnNvbGUubG9nKCdpbml0aWFsaXppbmcnKVxyXG5cdGNvbnNvbGUubG9nKCdjYWxsaW5nIG5leHQgaW50byBpbml0aWxpemUnKVxyXG5cdHRoaXMubmV4dChsb29wKVxyXG59KVxyXG5cclxuZnVuY3Rpb24gbG9vcCgpIHtcclxuXHR0aGlzLnRyYWNlKCdlbnRlcmluZyBsb29wJylcclxuXHRjb25zb2xlLmxvZygnIC0gdGhpcyA6ICcsIHRoaXMpXHJcblx0dGhpcy5yZWNlaXZlKCd3YWtldXAnLCBmdW5jdGlvbigpe1xyXG5cdFx0Y29uc29sZS5sb2coJ3JlY2VpdmVkIHdha2V1cCcpXHJcblx0XHR0aGlzLm5leHQoKVxyXG5cdH0pLnJlY2VpdmUoe3R5cGU6J3ZhbCd9LCBmdW5jdGlvbihtZXNzYWdlKXtcclxuXHRcdGNvbnNvbGUubG9nKCdyZWNlaXZlZCB2YWx1ZSA6ICcsIG1lc3NhZ2UudmFsKVxyXG5cdFx0dGhpcy5uZXh0KClcclxuXHR9KS5yZWNlaXZlKDE1MCwgaGFuZGxlXzE1MClcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlXzE1MCh2YWwpIHtcclxuXHRjb25zb2xlLmxvZyh2YWwgKyAnID09PSAxNTAnKVxyXG5cdHRoaXMubmV4dCgpXHJcbn1cclxuXHJcbnAuc2VuZCgnd2FrZXVwJylcclxucC5zZW5kKHt0eXBlOid2YWwnLCB2YWw6J3NwYSd9KVxyXG5wLnNlbmQoJ3dha2V1cCcpXHJcbnAuc2VuZCgxNTApXHJcbnAuc2VuZCgnd2FrZXVwJylcclxuXHJcblxyXG5jb25zb2xlLmxvZygncHJvYyBwJyxwKVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL2pzL21haW4uanNcbiAqKiBtb2R1bGUgaWQgPSAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(2).nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That\'s not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).setImmediate, __webpack_require__(1).clearImmediate))\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzPzY5YzEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpQkFBaUI7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval("// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanM/NmYwZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50UXVldWU7XG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtpXSgpO1xuICAgICAgICB9XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgcXVldWUucHVzaChmdW4pO1xuICAgIGlmICghZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {__webpack_require__(6)\r\nvar extend = __webpack_require__(4)\r\n\r\n	//@todo implement procLoop from strach pour avoir le moins de fonctions\r\n	//    anonymes possibles (utiliser un prototype) pour utiliser moins de ram\r\n\r\n	// au lieu de passer <next> on passe <proc> qui contient proc.next (==next)\r\n	// mais aussi proc.receive (la mailbox) proc.exit (qui rend tout appel à\r\n	// .next sans effet (set .next = noop))\r\n\r\n	// proc.state qui est un objet vide dans lequel on laisse l'utilisateur\r\n	// stocker ce qu'il veut\r\n\r\n	// proc.receive N'EST pas implémenté car on est synchrone : on peut just\r\n	// fetcher la mailbox et éventuellement faire un petit proc.next(300) s'il\r\n	// n'y a rien\r\n\r\n	// implémenter également proc.next(fun) et proc.next(fun, 300) qui remplace\r\n	// la callback utilisée\r\n\r\nvar promise = __webpack_require__(5).Promise\r\n\r\nvar spawn = setImmediate\r\n\r\nfunction noop() {\r\n	/* hi ! */\r\n}\r\n\r\n\r\nvar DEBUG_INCREMENT = 0\r\n\r\nvar ttrace = function() {\r\n	var args = ['#'+ DEBUG_INCREMENT++].concat(Array.prototype.slice.call(arguments))\r\n	console.log.apply(console, args)\r\n}\r\n\r\nfunction Proc(init) {\r\n	var opts = typeof init === 'function' ? {initialize:init} : init\r\n	extend(this, opts)\r\n	console.log('opts', opts)\r\n	this.__mailbox = new Mailbox(this)\r\n	// initialization is synchronous\r\n	this.initialize()\r\n}\r\n\r\nProc.prototype.initialize = function() {\r\n	throw new Error('Proc.spawn must me be called with a function as its first '\r\n		+ 'argument, or with an object defining an \"initialize\" method.')\r\n}\r\n\r\nProc.prototype.__loop = noop\r\n\r\nProc.prototype.next = function(/* loop */) {\r\n	if (typeof arguments[0] === 'function') {\r\n		this.__loop = arguments[0].bind(this)\r\n	}\r\n	this.trace('before spawn')\r\n	spawn(this.__loop)\r\n	this.trace('after spawn')\r\n}\r\n\r\nProc.prototype.trace = ttrace\r\n\r\n\r\nProc.prototype.poke = function() {\r\n	if (this.asleep) this.resume()\r\n}\r\n\r\nProc.prototype.receive = function(pattern, handle) {\r\n	// we boot a new chain and proxy the first tuple passed\r\n	var chain = (new ReceiveChain()).receive(pattern, handle)\r\n	// then we defer the execution to another timeframe, so the user can chain\r\n	// calls to receive without the need to call something like .run() at the\r\n	// chain end\r\n	var self = this\r\n	spawn(function(){\r\n		ttrace('executing chain')\r\n		console.error('@todo')\r\n	})\r\n	// then we return the chain\r\n	return chain\r\n}\r\n\r\n// -- ReceiveChain ------------------------------------------------------------\r\n\r\nfunction ReceiveChain () {\r\n	this.stack = []\r\n}\r\n\r\nReceiveChain.prototype.receive = function(pattern, handle) {\r\n	ttrace('registering chain ')\r\n	this.stack.push([pattern, handle])\r\n	return this\r\n}\r\n\r\n\r\n\r\n// -- Mailbox is the message passing link between client and proc -------------\r\n\r\nfunction Mailbox(proc) {\r\n	this.proc = proc\r\n	this.messages = []\r\n}\r\n\r\nMailbox.prototype.send = function(message) {\r\n	this.messages.push(message)\r\n	this.proc.poke()\r\n}\r\n\r\n// -- Client is an API for the proc clients -----------------------------------\r\n\r\nfunction Client (mailbox) {\r\n	this.__mailbox = mailbox\r\n}\r\n\r\nClient.prototype.send = function (message) {\r\n	return this.__mailbox.send(message)\r\n}\r\n\r\n// -- Proc static methods -----------------------------------------------------\r\n\r\nProc.spawn = function(opts) {\r\n	var p = new Proc(opts)\r\n	var api = new Client(p.__mailbox)\r\n	return api\r\n}\r\n\r\nmodule.exports = Proc\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).setImmediate))\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvcHJvYy5qcz85MDZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJvREFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJ3NldEltbWVkaWF0ZScpXHJcbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQnKVxyXG5cclxuXHQvL0B0b2RvIGltcGxlbWVudCBwcm9jTG9vcCBmcm9tIHN0cmFjaCBwb3VyIGF2b2lyIGxlIG1vaW5zIGRlIGZvbmN0aW9uc1xyXG5cdC8vICAgIGFub255bWVzIHBvc3NpYmxlcyAodXRpbGlzZXIgdW4gcHJvdG90eXBlKSBwb3VyIHV0aWxpc2VyIG1vaW5zIGRlIHJhbVxyXG5cclxuXHQvLyBhdSBsaWV1IGRlIHBhc3NlciA8bmV4dD4gb24gcGFzc2UgPHByb2M+IHF1aSBjb250aWVudCBwcm9jLm5leHQgKD09bmV4dClcclxuXHQvLyBtYWlzIGF1c3NpIHByb2MucmVjZWl2ZSAobGEgbWFpbGJveCkgcHJvYy5leGl0IChxdWkgcmVuZCB0b3V0IGFwcGVsIMOgXHJcblx0Ly8gLm5leHQgc2FucyBlZmZldCAoc2V0IC5uZXh0ID0gbm9vcCkpXHJcblxyXG5cdC8vIHByb2Muc3RhdGUgcXVpIGVzdCB1biBvYmpldCB2aWRlIGRhbnMgbGVxdWVsIG9uIGxhaXNzZSBsJ3V0aWxpc2F0ZXVyXHJcblx0Ly8gc3RvY2tlciBjZSBxdSdpbCB2ZXV0XHJcblxyXG5cdC8vIHByb2MucmVjZWl2ZSBOJ0VTVCBwYXMgaW1wbMOpbWVudMOpIGNhciBvbiBlc3Qgc3luY2hyb25lIDogb24gcGV1dCBqdXN0XHJcblx0Ly8gZmV0Y2hlciBsYSBtYWlsYm94IGV0IMOpdmVudHVlbGxlbWVudCBmYWlyZSB1biBwZXRpdCBwcm9jLm5leHQoMzAwKSBzJ2lsXHJcblx0Ly8gbid5IGEgcmllblxyXG5cclxuXHQvLyBpbXBsw6ltZW50ZXIgw6lnYWxlbWVudCBwcm9jLm5leHQoZnVuKSBldCBwcm9jLm5leHQoZnVuLCAzMDApIHF1aSByZW1wbGFjZVxyXG5cdC8vIGxhIGNhbGxiYWNrIHV0aWxpc8OpZVxyXG5cclxudmFyIHByb21pc2UgPSByZXF1aXJlKCdyYWN0aXZlJykuUHJvbWlzZVxyXG5cclxudmFyIHNwYXduID0gc2V0SW1tZWRpYXRlXHJcblxyXG5mdW5jdGlvbiBub29wKCkge1xyXG5cdC8qIGhpICEgKi9cclxufVxyXG5cclxuXHJcbnZhciBERUJVR19JTkNSRU1FTlQgPSAwXHJcblxyXG52YXIgdHRyYWNlID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGFyZ3MgPSBbJyMnKyBERUJVR19JTkNSRU1FTlQrK10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXHJcblx0Y29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncylcclxufVxyXG5cclxuZnVuY3Rpb24gUHJvYyhpbml0KSB7XHJcblx0dmFyIG9wdHMgPSB0eXBlb2YgaW5pdCA9PT0gJ2Z1bmN0aW9uJyA/IHtpbml0aWFsaXplOmluaXR9IDogaW5pdFxyXG5cdGV4dGVuZCh0aGlzLCBvcHRzKVxyXG5cdGNvbnNvbGUubG9nKCdvcHRzJywgb3B0cylcclxuXHR0aGlzLl9fbWFpbGJveCA9IG5ldyBNYWlsYm94KHRoaXMpXHJcblx0Ly8gaW5pdGlhbGl6YXRpb24gaXMgc3luY2hyb25vdXNcclxuXHR0aGlzLmluaXRpYWxpemUoKVxyXG59XHJcblxyXG5Qcm9jLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7XHJcblx0dGhyb3cgbmV3IEVycm9yKCdQcm9jLnNwYXduIG11c3QgbWUgYmUgY2FsbGVkIHdpdGggYSBmdW5jdGlvbiBhcyBpdHMgZmlyc3QgJ1xyXG5cdFx0KyAnYXJndW1lbnQsIG9yIHdpdGggYW4gb2JqZWN0IGRlZmluaW5nIGFuIFwiaW5pdGlhbGl6ZVwiIG1ldGhvZC4nKVxyXG59XHJcblxyXG5Qcm9jLnByb3RvdHlwZS5fX2xvb3AgPSBub29wXHJcblxyXG5Qcm9jLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oLyogbG9vcCAqLykge1xyXG5cdGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHR0aGlzLl9fbG9vcCA9IGFyZ3VtZW50c1swXS5iaW5kKHRoaXMpXHJcblx0fVxyXG5cdHRoaXMudHJhY2UoJ2JlZm9yZSBzcGF3bicpXHJcblx0c3Bhd24odGhpcy5fX2xvb3ApXHJcblx0dGhpcy50cmFjZSgnYWZ0ZXIgc3Bhd24nKVxyXG59XHJcblxyXG5Qcm9jLnByb3RvdHlwZS50cmFjZSA9IHR0cmFjZVxyXG5cclxuXHJcblByb2MucHJvdG90eXBlLnBva2UgPSBmdW5jdGlvbigpIHtcclxuXHRpZiAodGhpcy5hc2xlZXApIHRoaXMucmVzdW1lKClcclxufVxyXG5cclxuUHJvYy5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIGhhbmRsZSkge1xyXG5cdC8vIHdlIGJvb3QgYSBuZXcgY2hhaW4gYW5kIHByb3h5IHRoZSBmaXJzdCB0dXBsZSBwYXNzZWRcclxuXHR2YXIgY2hhaW4gPSAobmV3IFJlY2VpdmVDaGFpbigpKS5yZWNlaXZlKHBhdHRlcm4sIGhhbmRsZSlcclxuXHQvLyB0aGVuIHdlIGRlZmVyIHRoZSBleGVjdXRpb24gdG8gYW5vdGhlciB0aW1lZnJhbWUsIHNvIHRoZSB1c2VyIGNhbiBjaGFpblxyXG5cdC8vIGNhbGxzIHRvIHJlY2VpdmUgd2l0aG91dCB0aGUgbmVlZCB0byBjYWxsIHNvbWV0aGluZyBsaWtlIC5ydW4oKSBhdCB0aGVcclxuXHQvLyBjaGFpbiBlbmRcclxuXHR2YXIgc2VsZiA9IHRoaXNcclxuXHRzcGF3bihmdW5jdGlvbigpe1xyXG5cdFx0dHRyYWNlKCdleGVjdXRpbmcgY2hhaW4nKVxyXG5cdFx0Y29uc29sZS5lcnJvcignQHRvZG8nKVxyXG5cdH0pXHJcblx0Ly8gdGhlbiB3ZSByZXR1cm4gdGhlIGNoYWluXHJcblx0cmV0dXJuIGNoYWluXHJcbn1cclxuXHJcbi8vIC0tIFJlY2VpdmVDaGFpbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbmZ1bmN0aW9uIFJlY2VpdmVDaGFpbiAoKSB7XHJcblx0dGhpcy5zdGFjayA9IFtdXHJcbn1cclxuXHJcblJlY2VpdmVDaGFpbi5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uKHBhdHRlcm4sIGhhbmRsZSkge1xyXG5cdHR0cmFjZSgncmVnaXN0ZXJpbmcgY2hhaW4gJylcclxuXHR0aGlzLnN0YWNrLnB1c2goW3BhdHRlcm4sIGhhbmRsZV0pXHJcblx0cmV0dXJuIHRoaXNcclxufVxyXG5cclxuXHJcblxyXG4vLyAtLSBNYWlsYm94IGlzIHRoZSBtZXNzYWdlIHBhc3NpbmcgbGluayBiZXR3ZWVuIGNsaWVudCBhbmQgcHJvYyAtLS0tLS0tLS0tLS0tXHJcblxyXG5mdW5jdGlvbiBNYWlsYm94KHByb2MpIHtcclxuXHR0aGlzLnByb2MgPSBwcm9jXHJcblx0dGhpcy5tZXNzYWdlcyA9IFtdXHJcbn1cclxuXHJcbk1haWxib3gucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XHJcblx0dGhpcy5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpXHJcblx0dGhpcy5wcm9jLnBva2UoKVxyXG59XHJcblxyXG4vLyAtLSBDbGllbnQgaXMgYW4gQVBJIGZvciB0aGUgcHJvYyBjbGllbnRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5mdW5jdGlvbiBDbGllbnQgKG1haWxib3gpIHtcclxuXHR0aGlzLl9fbWFpbGJveCA9IG1haWxib3hcclxufVxyXG5cclxuQ2xpZW50LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuXHRyZXR1cm4gdGhpcy5fX21haWxib3guc2VuZChtZXNzYWdlKVxyXG59XHJcblxyXG4vLyAtLSBQcm9jIHN0YXRpYyBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5Qcm9jLnNwYXduID0gZnVuY3Rpb24ob3B0cykge1xyXG5cdHZhciBwID0gbmV3IFByb2Mob3B0cylcclxuXHR2YXIgYXBpID0gbmV3IENsaWVudChwLl9fbWFpbGJveClcclxuXHRyZXR1cm4gYXBpXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUHJvY1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL2pzL3Byb2MuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("var hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar undefined;\n\nvar isArray = function isArray(arr) {\n	if (typeof Array.isArray === 'function') {\n		return Array.isArray(arr);\n	}\n\n	return toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n	'use strict';\n	if (!obj || toStr.call(obj) !== '[object Object]') {\n		return false;\n	}\n\n	var has_own_constructor = hasOwn.call(obj, 'constructor');\n	var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n	// Not own constructor property must be Object\n	if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {\n		return false;\n	}\n\n	// Own properties are enumerated firstly, so to speed up,\n	// if last one is own, then all properties are own.\n	var key;\n	for (key in obj) {}\n\n	return key === undefined || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n	'use strict';\n	var options, name, src, copy, copyIsArray, clone,\n		target = arguments[0],\n		i = 1,\n		length = arguments.length,\n		deep = false;\n\n	// Handle a deep copy situation\n	if (typeof target === 'boolean') {\n		deep = target;\n		target = arguments[1] || {};\n		// skip the boolean and the target\n		i = 2;\n	} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {\n		target = {};\n	}\n\n	for (; i < length; ++i) {\n		options = arguments[i];\n		// Only deal with non-null/undefined values\n		if (options != null) {\n			// Extend the base object\n			for (name in options) {\n				src = target[name];\n				copy = options[name];\n\n				// Prevent never-ending loop\n				if (target === copy) {\n					continue;\n				}\n\n				// Recurse if we're merging plain objects or arrays\n				if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n					if (copyIsArray) {\n						copyIsArray = false;\n						clone = src && isArray(src) ? src : [];\n					} else {\n						clone = src && isPlainObject(src) ? src : {};\n					}\n\n					// Never move original objects, clone them\n					target[name] = extend(deep, clone, copy);\n\n				// Don't bring in undefined values\n				} else if (copy !== undefined) {\n					target[name] = copy;\n				}\n			}\n		}\n	}\n\n	// Return the modified object\n	return target;\n};\n\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2V4dGVuZC9pbmRleC5qcz8zNmM4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUEsT0FBTyxZQUFZO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgdW5kZWZpbmVkO1xuXG52YXIgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkoYXJyKSB7XG5cdGlmICh0eXBlb2YgQXJyYXkuaXNBcnJheSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBBcnJheS5pc0FycmF5KGFycik7XG5cdH1cblxuXHRyZXR1cm4gdG9TdHIuY2FsbChhcnIpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIGlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuXHQndXNlIHN0cmljdCc7XG5cdGlmICghb2JqIHx8IHRvU3RyLmNhbGwob2JqKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgaGFzX293bl9jb25zdHJ1Y3RvciA9IGhhc093bi5jYWxsKG9iaiwgJ2NvbnN0cnVjdG9yJyk7XG5cdHZhciBoYXNfaXNfcHJvcGVydHlfb2ZfbWV0aG9kID0gb2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgJiYgaGFzT3duLmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ2lzUHJvdG90eXBlT2YnKTtcblx0Ly8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuXHRpZiAob2JqLmNvbnN0cnVjdG9yICYmICFoYXNfb3duX2NvbnN0cnVjdG9yICYmICFoYXNfaXNfcHJvcGVydHlfb2ZfbWV0aG9kKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gT3duIHByb3BlcnRpZXMgYXJlIGVudW1lcmF0ZWQgZmlyc3RseSwgc28gdG8gc3BlZWQgdXAsXG5cdC8vIGlmIGxhc3Qgb25lIGlzIG93biwgdGhlbiBhbGwgcHJvcGVydGllcyBhcmUgb3duLlxuXHR2YXIga2V5O1xuXHRmb3IgKGtleSBpbiBvYmopIHt9XG5cblx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkIHx8IGhhc093bi5jYWxsKG9iaiwga2V5KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXh0ZW5kKCkge1xuXHQndXNlIHN0cmljdCc7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMF0sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMV0gfHwge307XG5cdFx0Ly8gc2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdGkgPSAyO1xuXHR9IGVsc2UgaWYgKCh0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKSB8fCB0YXJnZXQgPT0gbnVsbCkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Zm9yICg7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbaV07XG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmIChvcHRpb25zICE9IG51bGwpIHtcblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAobmFtZSBpbiBvcHRpb25zKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFtuYW1lXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbbmFtZV07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAodGFyZ2V0ID09PSBjb3B5KSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKGRlZXAgJiYgY29weSAmJiAoaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBpc0FycmF5KGNvcHkpKSkpIHtcblx0XHRcdFx0XHRpZiAoY29weUlzQXJyYXkpIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBpc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0W25hbWVdID0gZXh0ZW5kKGRlZXAsIGNsb25lLCBjb3B5KTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W25hbWVdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRlbmQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval('/*\n	Ractive.js v0.7.3\n	Sat Apr 25 2015 13:52:38 GMT-0400 (EDT) - commit da40f81c660ba2f09c45a09a9c20fdd34ee36d80\n\n	http://ractivejs.org\n	http://twitter.com/RactiveJS\n\n	Released under the MIT License.\n*/\n\n(function (global, factory) {\n  true ? module.exports = factory() :\n  typeof define === \'function\' && define.amd ? define(factory) :\n  global.Ractive = factory()\n}(this, function () { \'use strict\';\n\n  var TEMPLATE_VERSION = 3;\n\n  var defaultOptions = {\n\n  	// render placement:\n  	el: void 0,\n  	append: false,\n\n  	// template:\n  	template: { v: TEMPLATE_VERSION, t: [] },\n\n  	// parse:     // TODO static delimiters?\n  	preserveWhitespace: false,\n  	sanitize: false,\n  	stripComments: true,\n  	delimiters: ["{{", "}}"],\n  	tripleDelimiters: ["{{{", "}}}"],\n  	interpolate: false,\n\n  	// data & binding:\n  	data: {},\n  	computed: {},\n  	magic: false,\n  	modifyArrays: true,\n  	adapt: [],\n  	isolated: false,\n  	twoway: true,\n  	lazy: false,\n\n  	// transitions:\n  	noIntro: false,\n  	transitionsEnabled: true,\n  	complete: void 0,\n\n  	// css:\n  	css: null,\n  	noCssTransform: false\n  };\n\n  var config_defaults = defaultOptions;\n\n  // These are a subset of the easing equations found at\n  // https://raw.github.com/danro/easing-js - license info\n  // follows:\n\n  // --------------------------------------------------\n  // easing.js v0.5.4\n  // Generic set of easing functions with AMD support\n  // https://github.com/danro/easing-js\n  // This code may be freely distributed under the MIT license\n  // http://danro.mit-license.org/\n  // --------------------------------------------------\n  // All functions adapted from Thomas Fuchs & Jeremy Kahn\n  // Easing Equations (c) 2003 Robert Penner, BSD license\n  // https://raw.github.com/danro/easing-js/master/LICENSE\n  // --------------------------------------------------\n\n  // In that library, the functions named easeIn, easeOut, and\n  // easeInOut below are named easeInCubic, easeOutCubic, and\n  // (you guessed it) easeInOutCubic.\n  //\n  // You can add additional easing functions to this list, and they\n  // will be globally available.\n\n  var static_easing = {\n  	linear: function (pos) {\n  		return pos;\n  	},\n  	easeIn: function (pos) {\n  		return Math.pow(pos, 3);\n  	},\n  	easeOut: function (pos) {\n  		return Math.pow(pos - 1, 3) + 1;\n  	},\n  	easeInOut: function (pos) {\n  		if ((pos /= 0.5) < 1) {\n  			return 0.5 * Math.pow(pos, 3);\n  		}\n  		return 0.5 * (Math.pow(pos - 2, 3) + 2);\n  	}\n  };\n\n  /*global console, navigator */\n  var isClient, isJsdom, hasConsole, environment__magic, namespaces, svg, vendors;\n\n  isClient = typeof document === "object";\n\n  isJsdom = typeof navigator !== "undefined" && /jsDom/.test(navigator.appName);\n\n  hasConsole = typeof console !== "undefined" && typeof console.warn === "function" && typeof console.warn.apply === "function";\n\n  try {\n  	Object.defineProperty({}, "test", { value: 0 });\n  	environment__magic = true;\n  } catch (e) {\n  	environment__magic = false;\n  }\n\n  namespaces = {\n  	html: "http://www.w3.org/1999/xhtml",\n  	mathml: "http://www.w3.org/1998/Math/MathML",\n  	svg: "http://www.w3.org/2000/svg",\n  	xlink: "http://www.w3.org/1999/xlink",\n  	xml: "http://www.w3.org/XML/1998/namespace",\n  	xmlns: "http://www.w3.org/2000/xmlns/"\n  };\n\n  if (typeof document === "undefined") {\n  	svg = false;\n  } else {\n  	svg = document && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");\n  }\n\n  vendors = ["o", "ms", "moz", "webkit"];\n\n  var createElement, matches, dom__div, methodNames, unprefixed, prefixed, dom__i, j, makeFunction;\n\n  // Test for SVG support\n  if (!svg) {\n  	createElement = function (type, ns) {\n  		if (ns && ns !== namespaces.html) {\n  			throw "This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information";\n  		}\n\n  		return document.createElement(type);\n  	};\n  } else {\n  	createElement = function (type, ns) {\n  		if (!ns || ns === namespaces.html) {\n  			return document.createElement(type);\n  		}\n\n  		return document.createElementNS(ns, type);\n  	};\n  }\n\n  function getElement(input) {\n  	var output;\n\n  	if (!input || typeof input === "boolean") {\n  		return;\n  	}\n\n  	if (typeof window === "undefined" || !document || !input) {\n  		return null;\n  	}\n\n  	// We already have a DOM node - no work to do. (Duck typing alert!)\n  	if (input.nodeType) {\n  		return input;\n  	}\n\n  	// Get node from string\n  	if (typeof input === "string") {\n  		// try ID first\n  		output = document.getElementById(input);\n\n  		// then as selector, if possible\n  		if (!output && document.querySelector) {\n  			output = document.querySelector(input);\n  		}\n\n  		// did it work?\n  		if (output && output.nodeType) {\n  			return output;\n  		}\n  	}\n\n  	// If we\'ve been given a collection (jQuery, Zepto etc), extract the first item\n  	if (input[0] && input[0].nodeType) {\n  		return input[0];\n  	}\n\n  	return null;\n  }\n\n  if (!isClient) {\n  	matches = null;\n  } else {\n  	dom__div = createElement("div");\n  	methodNames = ["matches", "matchesSelector"];\n\n  	makeFunction = function (methodName) {\n  		return function (node, selector) {\n  			return node[methodName](selector);\n  		};\n  	};\n\n  	dom__i = methodNames.length;\n\n  	while (dom__i-- && !matches) {\n  		unprefixed = methodNames[dom__i];\n\n  		if (dom__div[unprefixed]) {\n  			matches = makeFunction(unprefixed);\n  		} else {\n  			j = vendors.length;\n  			while (j--) {\n  				prefixed = vendors[dom__i] + unprefixed.substr(0, 1).toUpperCase() + unprefixed.substring(1);\n\n  				if (dom__div[prefixed]) {\n  					matches = makeFunction(prefixed);\n  					break;\n  				}\n  			}\n  		}\n  	}\n\n  	// IE8...\n  	if (!matches) {\n  		matches = function (node, selector) {\n  			var nodes, parentNode, i;\n\n  			parentNode = node.parentNode;\n\n  			if (!parentNode) {\n  				// empty dummy <div>\n  				dom__div.innerHTML = "";\n\n  				parentNode = dom__div;\n  				node = node.cloneNode();\n\n  				dom__div.appendChild(node);\n  			}\n\n  			nodes = parentNode.querySelectorAll(selector);\n\n  			i = nodes.length;\n  			while (i--) {\n  				if (nodes[i] === node) {\n  					return true;\n  				}\n  			}\n\n  			return false;\n  		};\n  	}\n  }\n\n  function detachNode(node) {\n  	if (node && typeof node.parentNode !== "unknown" && node.parentNode) {\n  		node.parentNode.removeChild(node);\n  	}\n\n  	return node;\n  }\n\n  function safeToStringValue(value) {\n  	return value == null || !value.toString ? "" : value;\n  }\n\n  var legacy = null;\n\n  var create, defineProperty, defineProperties;\n\n  try {\n  	Object.defineProperty({}, "test", { value: 0 });\n\n  	if (isClient) {\n  		Object.defineProperty(document.createElement("div"), "test", { value: 0 });\n  	}\n\n  	defineProperty = Object.defineProperty;\n  } catch (err) {\n  	// Object.defineProperty doesn\'t exist, or we\'re in IE8 where you can\n  	// only use it with DOM objects (what were you smoking, MSFT?)\n  	defineProperty = function (obj, prop, desc) {\n  		obj[prop] = desc.value;\n  	};\n  }\n\n  try {\n  	try {\n  		Object.defineProperties({}, { test: { value: 0 } });\n  	} catch (err) {\n  		// TODO how do we account for this? noMagic = true;\n  		throw err;\n  	}\n\n  	if (isClient) {\n  		Object.defineProperties(createElement("div"), { test: { value: 0 } });\n  	}\n\n  	defineProperties = Object.defineProperties;\n  } catch (err) {\n  	defineProperties = function (obj, props) {\n  		var prop;\n\n  		for (prop in props) {\n  			if (props.hasOwnProperty(prop)) {\n  				defineProperty(obj, prop, props[prop]);\n  			}\n  		}\n  	};\n  }\n\n  try {\n  	Object.create(null);\n\n  	create = Object.create;\n  } catch (err) {\n  	// sigh\n  	create = (function () {\n  		var F = function () {};\n\n  		return function (proto, props) {\n  			var obj;\n\n  			if (proto === null) {\n  				return {};\n  			}\n\n  			F.prototype = proto;\n  			obj = new F();\n\n  			if (props) {\n  				Object.defineProperties(obj, props);\n  			}\n\n  			return obj;\n  		};\n  	})();\n  }\n\n  function utils_object__extend(target) {\n  	for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  		sources[_key - 1] = arguments[_key];\n  	}\n\n  	var prop, source;\n\n  	while (source = sources.shift()) {\n  		for (prop in source) {\n  			if (hasOwn.call(source, prop)) {\n  				target[prop] = source[prop];\n  			}\n  		}\n  	}\n\n  	return target;\n  }\n\n  function fillGaps(target) {\n  	for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  		sources[_key - 1] = arguments[_key];\n  	}\n\n  	sources.forEach(function (s) {\n  		for (var key in s) {\n  			if (s.hasOwnProperty(key) && !(key in target)) {\n  				target[key] = s[key];\n  			}\n  		}\n  	});\n\n  	return target;\n  }\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  // thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n  var is__toString = Object.prototype.toString,\n      arrayLikePattern = /^\\[object (?:Array|FileList)\\]$/;\n  function isArray(thing) {\n  	return is__toString.call(thing) === "[object Array]";\n  }\n\n  function isArrayLike(obj) {\n  	return arrayLikePattern.test(is__toString.call(obj));\n  }\n\n  function isEqual(a, b) {\n  	if (a === null && b === null) {\n  		return true;\n  	}\n\n  	if (typeof a === "object" || typeof b === "object") {\n  		return false;\n  	}\n\n  	return a === b;\n  }\n\n  function is__isNumeric(thing) {\n  	return !isNaN(parseFloat(thing)) && isFinite(thing);\n  }\n\n  function isObject(thing) {\n  	return thing && is__toString.call(thing) === "[object Object]";\n  }\n\n  var noop = function () {};\n\n  /* global console */\n  var alreadyWarned = {},\n      log,\n      printWarning,\n      welcome;\n\n  if (hasConsole) {\n  	(function () {\n  		var welcomeIntro = ["%cRactive.js %c0.7.3 %cin debug mode, %cmore...", "color: rgb(114, 157, 52); font-weight: normal;", "color: rgb(85, 85, 85); font-weight: normal;", "color: rgb(85, 85, 85); font-weight: normal;", "color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;"];\n  		var welcomeMessage = "You\'re running Ractive 0.7.3 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\\n\\nTo disable debug mode, add this line at the start of your app:\\n  Ractive.DEBUG = false;\\n\\nTo disable debug mode when your app is minified, add this snippet:\\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\\n\\nGet help and support:\\n  http://docs.ractivejs.org\\n  http://stackoverflow.com/questions/tagged/ractivejs\\n  http://groups.google.com/forum/#!forum/ractive-js\\n  http://twitter.com/ractivejs\\n\\nFound a bug? Raise an issue:\\n  https://github.com/ractivejs/ractive/issues\\n\\n";\n\n  		welcome = function () {\n  			var hasGroup = !!console.groupCollapsed;\n  			console[hasGroup ? "groupCollapsed" : "log"].apply(console, welcomeIntro);\n  			console.log(welcomeMessage);\n  			if (hasGroup) {\n  				console.groupEnd(welcomeIntro);\n  			}\n\n  			welcome = noop;\n  		};\n\n  		printWarning = function (message, args) {\n  			welcome();\n\n  			// extract information about the instance this message pertains to, if applicable\n  			if (typeof args[args.length - 1] === "object") {\n  				var options = args.pop();\n  				var ractive = options ? options.ractive : null;\n\n  				if (ractive) {\n  					// if this is an instance of a component that we know the name of, add\n  					// it to the message\n  					var _name = undefined;\n  					if (ractive.component && (_name = ractive.component.name)) {\n  						message = "<" + _name + "> " + message;\n  					}\n\n  					var node = undefined;\n  					if (node = options.node || ractive.fragment && ractive.fragment.rendered && ractive.find("*")) {\n  						args.push(node);\n  					}\n  				}\n  			}\n\n  			console.warn.apply(console, ["%cRactive.js: %c" + message, "color: rgb(114, 157, 52);", "color: rgb(85, 85, 85);"].concat(args));\n  		};\n\n  		log = function () {\n  			console.log.apply(console, arguments);\n  		};\n  	})();\n  } else {\n  	printWarning = log = welcome = noop;\n  }\n\n  function format(message, args) {\n  	return message.replace(/%s/g, function () {\n  		return args.shift();\n  	});\n  }\n\n  function fatal(message) {\n  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  		args[_key - 1] = arguments[_key];\n  	}\n\n  	message = format(message, args);\n  	throw new Error(message);\n  }\n\n  function logIfDebug() {\n  	if (_Ractive.DEBUG) {\n  		log.apply(null, arguments);\n  	}\n  }\n\n  function warn(message) {\n  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  		args[_key - 1] = arguments[_key];\n  	}\n\n  	message = format(message, args);\n  	printWarning(message, args);\n  }\n\n  function warnOnce(message) {\n  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  		args[_key - 1] = arguments[_key];\n  	}\n\n  	message = format(message, args);\n\n  	if (alreadyWarned[message]) {\n  		return;\n  	}\n\n  	alreadyWarned[message] = true;\n  	printWarning(message, args);\n  }\n\n  function warnIfDebug() {\n  	if (_Ractive.DEBUG) {\n  		warn.apply(null, arguments);\n  	}\n  }\n\n  function warnOnceIfDebug() {\n  	if (_Ractive.DEBUG) {\n  		warnOnce.apply(null, arguments);\n  	}\n  }\n\n  // Error messages that are used (or could be) in multiple places\n  var badArguments = "Bad arguments";\n  var noRegistryFunctionReturn = "A function was specified for \\"%s\\" %s, but no %s was returned";\n  var missingPlugin = function (name, type) {\n    return "Missing \\"" + name + "\\" " + type + " plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#" + type + "s";\n  };\n\n  function findInViewHierarchy(registryName, ractive, name) {\n  	var instance = findInstance(registryName, ractive, name);\n  	return instance ? instance[registryName][name] : null;\n  }\n\n  function findInstance(registryName, ractive, name) {\n  	while (ractive) {\n  		if (name in ractive[registryName]) {\n  			return ractive;\n  		}\n\n  		if (ractive.isolated) {\n  			return null;\n  		}\n\n  		ractive = ractive.parent;\n  	}\n  }\n\n  var interpolate = function (from, to, ractive, type) {\n  	if (from === to) {\n  		return snap(to);\n  	}\n\n  	if (type) {\n\n  		var interpol = findInViewHierarchy("interpolators", ractive, type);\n  		if (interpol) {\n  			return interpol(from, to) || snap(to);\n  		}\n\n  		fatal(missingPlugin(type, "interpolator"));\n  	}\n\n  	return static_interpolators.number(from, to) || static_interpolators.array(from, to) || static_interpolators.object(from, to) || snap(to);\n  };\n\n  var shared_interpolate = interpolate;\n\n  function snap(to) {\n  	return function () {\n  		return to;\n  	};\n  }\n\n  var interpolators = {\n  	number: function (from, to) {\n  		var delta;\n\n  		if (!is__isNumeric(from) || !is__isNumeric(to)) {\n  			return null;\n  		}\n\n  		from = +from;\n  		to = +to;\n\n  		delta = to - from;\n\n  		if (!delta) {\n  			return function () {\n  				return from;\n  			};\n  		}\n\n  		return function (t) {\n  			return from + t * delta;\n  		};\n  	},\n\n  	array: function (from, to) {\n  		var intermediate, interpolators, len, i;\n\n  		if (!isArray(from) || !isArray(to)) {\n  			return null;\n  		}\n\n  		intermediate = [];\n  		interpolators = [];\n\n  		i = len = Math.min(from.length, to.length);\n  		while (i--) {\n  			interpolators[i] = shared_interpolate(from[i], to[i]);\n  		}\n\n  		// surplus values - don\'t interpolate, but don\'t exclude them either\n  		for (i = len; i < from.length; i += 1) {\n  			intermediate[i] = from[i];\n  		}\n\n  		for (i = len; i < to.length; i += 1) {\n  			intermediate[i] = to[i];\n  		}\n\n  		return function (t) {\n  			var i = len;\n\n  			while (i--) {\n  				intermediate[i] = interpolators[i](t);\n  			}\n\n  			return intermediate;\n  		};\n  	},\n\n  	object: function (from, to) {\n  		var properties, len, interpolators, intermediate, prop;\n\n  		if (!isObject(from) || !isObject(to)) {\n  			return null;\n  		}\n\n  		properties = [];\n  		intermediate = {};\n  		interpolators = {};\n\n  		for (prop in from) {\n  			if (hasOwn.call(from, prop)) {\n  				if (hasOwn.call(to, prop)) {\n  					properties.push(prop);\n  					interpolators[prop] = shared_interpolate(from[prop], to[prop]);\n  				} else {\n  					intermediate[prop] = from[prop];\n  				}\n  			}\n  		}\n\n  		for (prop in to) {\n  			if (hasOwn.call(to, prop) && !hasOwn.call(from, prop)) {\n  				intermediate[prop] = to[prop];\n  			}\n  		}\n\n  		len = properties.length;\n\n  		return function (t) {\n  			var i = len,\n  			    prop;\n\n  			while (i--) {\n  				prop = properties[i];\n\n  				intermediate[prop] = interpolators[prop](t);\n  			}\n\n  			return intermediate;\n  		};\n  	}\n  };\n\n  var static_interpolators = interpolators;\n\n  // This function takes a keypath such as \'foo.bar.baz\', and returns\n  // all the variants of that keypath that include a wildcard in place\n  // of a key, such as \'foo.bar.*\', \'foo.*.baz\', \'foo.*.*\' and so on.\n  // These are then checked against the dependants map (ractive.viewmodel.depsMap)\n  // to see if any pattern observers are downstream of one or more of\n  // these wildcard keypaths (e.g. \'foo.bar.*.status\')\n  var utils_getPotentialWildcardMatches = getPotentialWildcardMatches;\n\n  var starMaps = {};\n  function getPotentialWildcardMatches(keypath) {\n  	var keys, starMap, mapper, i, result, wildcardKeypath;\n\n  	keys = keypath.split(".");\n  	if (!(starMap = starMaps[keys.length])) {\n  		starMap = getStarMap(keys.length);\n  	}\n\n  	result = [];\n\n  	mapper = function (star, i) {\n  		return star ? "*" : keys[i];\n  	};\n\n  	i = starMap.length;\n  	while (i--) {\n  		wildcardKeypath = starMap[i].map(mapper).join(".");\n\n  		if (!result.hasOwnProperty(wildcardKeypath)) {\n  			result.push(wildcardKeypath);\n  			result[wildcardKeypath] = true;\n  		}\n  	}\n\n  	return result;\n  }\n\n  // This function returns all the possible true/false combinations for\n  // a given number - e.g. for two, the possible combinations are\n  // [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n  // It does so by getting all the binary values between 0 and e.g. 11\n  function getStarMap(num) {\n  	var ones = "",\n  	    max,\n  	    binary,\n  	    starMap,\n  	    mapper,\n  	    i,\n  	    j,\n  	    l,\n  	    map;\n\n  	if (!starMaps[num]) {\n  		starMap = [];\n\n  		while (ones.length < num) {\n  			ones += 1;\n  		}\n\n  		max = parseInt(ones, 2);\n\n  		mapper = function (digit) {\n  			return digit === "1";\n  		};\n\n  		for (i = 0; i <= max; i += 1) {\n  			binary = i.toString(2);\n  			while (binary.length < num) {\n  				binary = "0" + binary;\n  			}\n\n  			map = [];\n  			l = binary.length;\n  			for (j = 0; j < l; j++) {\n  				map.push(mapper(binary[j]));\n  			}\n  			starMap[i] = map;\n  		}\n\n  		starMaps[num] = starMap;\n  	}\n\n  	return starMaps[num];\n  }\n\n  var refPattern = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\n  var patternPattern = /\\*/;\n  var keypathCache = {};\n\n  var Keypath = function (str) {\n  	var keys = str.split(".");\n\n  	this.str = str;\n\n  	if (str[0] === "@") {\n  		this.isSpecial = true;\n  		this.value = decodeKeypath(str);\n  	}\n\n  	this.firstKey = keys[0];\n  	this.lastKey = keys.pop();\n\n  	this.isPattern = patternPattern.test(str);\n\n  	this.parent = str === "" ? null : getKeypath(keys.join("."));\n  	this.isRoot = !str;\n  };\n\n  Keypath.prototype = {\n  	equalsOrStartsWith: function (keypath) {\n  		return keypath === this || this.startsWith(keypath);\n  	},\n\n  	join: function (str) {\n  		return getKeypath(this.isRoot ? String(str) : this.str + "." + str);\n  	},\n\n  	replace: function (oldKeypath, newKeypath) {\n  		if (this === oldKeypath) {\n  			return newKeypath;\n  		}\n\n  		if (this.startsWith(oldKeypath)) {\n  			return newKeypath === null ? newKeypath : getKeypath(this.str.replace(oldKeypath.str + ".", newKeypath.str + "."));\n  		}\n  	},\n\n  	startsWith: function (keypath) {\n  		if (!keypath) {\n  			// TODO under what circumstances does this happen?\n  			return false;\n  		}\n\n  		return keypath && this.str.substr(0, keypath.str.length + 1) === keypath.str + ".";\n  	},\n\n  	toString: function () {\n  		throw new Error("Bad coercion");\n  	},\n\n  	valueOf: function () {\n  		throw new Error("Bad coercion");\n  	},\n\n  	wildcardMatches: function () {\n  		return this._wildcardMatches || (this._wildcardMatches = utils_getPotentialWildcardMatches(this.str));\n  	}\n  };\n  function assignNewKeypath(target, property, oldKeypath, newKeypath) {\n  	var existingKeypath = target[property];\n\n  	if (existingKeypath && (existingKeypath.equalsOrStartsWith(newKeypath) || !existingKeypath.equalsOrStartsWith(oldKeypath))) {\n  		return;\n  	}\n\n  	target[property] = existingKeypath ? existingKeypath.replace(oldKeypath, newKeypath) : newKeypath;\n  	return true;\n  }\n\n  function decodeKeypath(keypath) {\n  	var value = keypath.slice(2);\n\n  	if (keypath[1] === "i") {\n  		return is__isNumeric(value) ? +value : value;\n  	} else {\n  		return value;\n  	}\n  }\n\n  function getKeypath(str) {\n  	if (str == null) {\n  		return str;\n  	}\n\n  	// TODO it *may* be worth having two versions of this function - one where\n  	// keypathCache inherits from null, and one for IE8. Depends on how\n  	// much of an overhead hasOwnProperty is - probably negligible\n  	if (!keypathCache.hasOwnProperty(str)) {\n  		keypathCache[str] = new Keypath(str);\n  	}\n\n  	return keypathCache[str];\n  }\n\n  function getMatchingKeypaths(ractive, keypath) {\n  	var keys, key, matchingKeypaths;\n\n  	keys = keypath.str.split(".");\n  	matchingKeypaths = [rootKeypath];\n\n  	while (key = keys.shift()) {\n  		if (key === "*") {\n  			// expand to find all valid child keypaths\n  			matchingKeypaths = matchingKeypaths.reduce(expand, []);\n  		} else {\n  			if (matchingKeypaths[0] === rootKeypath) {\n  				// first key\n  				matchingKeypaths[0] = getKeypath(key);\n  			} else {\n  				matchingKeypaths = matchingKeypaths.map(concatenate(key));\n  			}\n  		}\n  	}\n\n  	return matchingKeypaths;\n\n  	function expand(matchingKeypaths, keypath) {\n  		var wrapper, value, keys;\n\n  		if (keypath.isRoot) {\n  			keys = [].concat(Object.keys(ractive.viewmodel.data), Object.keys(ractive.viewmodel.mappings), Object.keys(ractive.viewmodel.computations));\n  		} else {\n  			wrapper = ractive.viewmodel.wrapped[keypath.str];\n  			value = wrapper ? wrapper.get() : ractive.viewmodel.get(keypath);\n\n  			keys = value ? Object.keys(value) : null;\n  		}\n\n  		if (keys) {\n  			keys.forEach(function (key) {\n  				if (key !== "_ractive" || !isArray(value)) {\n  					matchingKeypaths.push(keypath.join(key));\n  				}\n  			});\n  		}\n\n  		return matchingKeypaths;\n  	}\n  }\n\n  function concatenate(key) {\n  	return function (keypath) {\n  		return keypath.join(key);\n  	};\n  }\n  function normalise(ref) {\n  	return ref ? ref.replace(refPattern, ".$1") : "";\n  }\n\n  var rootKeypath = getKeypath("");\n\n  var shared_add = add;\n  var shared_add__errorMessage = "Cannot add to a non-numeric value";\n  function add(root, keypath, d) {\n  	if (typeof keypath !== "string" || !is__isNumeric(d)) {\n  		throw new Error("Bad arguments");\n  	}\n\n  	var value = undefined,\n  	    changes = undefined;\n\n  	if (/\\*/.test(keypath)) {\n  		changes = {};\n\n  		getMatchingKeypaths(root, getKeypath(normalise(keypath))).forEach(function (keypath) {\n  			var value = root.viewmodel.get(keypath);\n\n  			if (!is__isNumeric(value)) {\n  				throw new Error(shared_add__errorMessage);\n  			}\n\n  			changes[keypath.str] = value + d;\n  		});\n\n  		return root.set(changes);\n  	}\n\n  	value = root.get(keypath);\n\n  	if (!is__isNumeric(value)) {\n  		throw new Error(shared_add__errorMessage);\n  	}\n\n  	return root.set(keypath, +value + d);\n  }\n\n  var prototype_add = Ractive$add;\n  function Ractive$add(keypath, d) {\n  	return shared_add(this, keypath, d === undefined ? 1 : +d);\n  }\n\n  var requestAnimationFrame;\n\n  // If window doesn\'t exist, we don\'t need requestAnimationFrame\n  if (typeof window === "undefined") {\n  	requestAnimationFrame = null;\n  } else {\n  	// https://gist.github.com/paulirish/1579671\n  	(function (vendors, lastTime, window) {\n\n  		var x, setTimeout;\n\n  		if (window.requestAnimationFrame) {\n  			return;\n  		}\n\n  		for (x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n  			window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];\n  		}\n\n  		if (!window.requestAnimationFrame) {\n  			setTimeout = window.setTimeout;\n\n  			window.requestAnimationFrame = function (callback) {\n  				var currTime, timeToCall, id;\n\n  				currTime = Date.now();\n  				timeToCall = Math.max(0, 16 - (currTime - lastTime));\n  				id = setTimeout(function () {\n  					callback(currTime + timeToCall);\n  				}, timeToCall);\n\n  				lastTime = currTime + timeToCall;\n  				return id;\n  			};\n  		}\n  	})(vendors, 0, window);\n\n  	requestAnimationFrame = window.requestAnimationFrame;\n  }\n\n  var rAF = requestAnimationFrame;\n\n  var getTime;\n\n  if (typeof window !== "undefined" && window.performance && typeof window.performance.now === "function") {\n  	getTime = function () {\n  		return window.performance.now();\n  	};\n  } else {\n  	getTime = function () {\n  		return Date.now();\n  	};\n  }\n\n  var utils_getTime = getTime;\n\n  var deprecations = {\n  	construct: {\n  		deprecated: "beforeInit",\n  		replacement: "onconstruct"\n  	},\n  	render: {\n  		deprecated: "init",\n  		message: "The \\"init\\" method has been deprecated " + "and will likely be removed in a future release. " + "You can either use the \\"oninit\\" method which will fire " + "only once prior to, and regardless of, any eventual ractive " + "instance being rendered, or if you need to access the " + "rendered DOM, use \\"onrender\\" instead. " + "See http://docs.ractivejs.org/latest/migrating for more information."\n  	},\n  	complete: {\n  		deprecated: "complete",\n  		replacement: "oncomplete"\n  	}\n  };\n\n  function Hook(event) {\n  	this.event = event;\n  	this.method = "on" + event;\n  	this.deprecate = deprecations[event];\n  }\n\n  Hook.prototype.fire = function (ractive, arg) {\n  	function call(method) {\n  		if (ractive[method]) {\n  			arg ? ractive[method](arg) : ractive[method]();\n  			return true;\n  		}\n  	}\n\n  	call(this.method);\n\n  	if (!ractive[this.method] && this.deprecate && call(this.deprecate.deprecated)) {\n  		if (this.deprecate.message) {\n  			warnIfDebug(this.deprecate.message);\n  		} else {\n  			warnIfDebug("The method \\"%s\\" has been deprecated in favor of \\"%s\\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.", this.deprecate.deprecated, this.deprecate.replacement);\n  		}\n  	}\n\n  	arg ? ractive.fire(this.event, arg) : ractive.fire(this.event);\n  };\n\n  var hooks_Hook = Hook;\n\n  function addToArray(array, value) {\n  	var index = array.indexOf(value);\n\n  	if (index === -1) {\n  		array.push(value);\n  	}\n  }\n\n  function arrayContains(array, value) {\n  	for (var i = 0, c = array.length; i < c; i++) {\n  		if (array[i] == value) {\n  			return true;\n  		}\n  	}\n\n  	return false;\n  }\n\n  function arrayContentsMatch(a, b) {\n  	var i;\n\n  	if (!isArray(a) || !isArray(b)) {\n  		return false;\n  	}\n\n  	if (a.length !== b.length) {\n  		return false;\n  	}\n\n  	i = a.length;\n  	while (i--) {\n  		if (a[i] !== b[i]) {\n  			return false;\n  		}\n  	}\n\n  	return true;\n  }\n\n  function ensureArray(x) {\n  	if (typeof x === "string") {\n  		return [x];\n  	}\n\n  	if (x === undefined) {\n  		return [];\n  	}\n\n  	return x;\n  }\n\n  function lastItem(array) {\n  	return array[array.length - 1];\n  }\n\n  function removeFromArray(array, member) {\n  	var index = array.indexOf(member);\n\n  	if (index !== -1) {\n  		array.splice(index, 1);\n  	}\n  }\n\n  function toArray(arrayLike) {\n  	var array = [],\n  	    i = arrayLike.length;\n  	while (i--) {\n  		array[i] = arrayLike[i];\n  	}\n\n  	return array;\n  }\n\n  var _Promise,\n      PENDING = {},\n      FULFILLED = {},\n      REJECTED = {};\n\n  if (typeof Promise === "function") {\n  	// use native Promise\n  	_Promise = Promise;\n  } else {\n  	_Promise = function (callback) {\n  		var fulfilledHandlers = [],\n  		    rejectedHandlers = [],\n  		    state = PENDING,\n  		    result,\n  		    dispatchHandlers,\n  		    makeResolver,\n  		    fulfil,\n  		    reject,\n  		    promise;\n\n  		makeResolver = function (newState) {\n  			return function (value) {\n  				if (state !== PENDING) {\n  					return;\n  				}\n\n  				result = value;\n  				state = newState;\n\n  				dispatchHandlers = makeDispatcher(state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result);\n\n  				// dispatch onFulfilled and onRejected handlers asynchronously\n  				wait(dispatchHandlers);\n  			};\n  		};\n\n  		fulfil = makeResolver(FULFILLED);\n  		reject = makeResolver(REJECTED);\n\n  		try {\n  			callback(fulfil, reject);\n  		} catch (err) {\n  			reject(err);\n  		}\n\n  		promise = {\n  			// `then()` returns a Promise - 2.2.7\n  			then: function (onFulfilled, onRejected) {\n  				var promise2 = new _Promise(function (fulfil, reject) {\n\n  					var processResolutionHandler = function (handler, handlers, forward) {\n\n  						// 2.2.1.1\n  						if (typeof handler === "function") {\n  							handlers.push(function (p1result) {\n  								var x;\n\n  								try {\n  									x = handler(p1result);\n  									utils_Promise__resolve(promise2, x, fulfil, reject);\n  								} catch (err) {\n  									reject(err);\n  								}\n  							});\n  						} else {\n  							// Forward the result of promise1 to promise2, if resolution handlers\n  							// are not given\n  							handlers.push(forward);\n  						}\n  					};\n\n  					// 2.2\n  					processResolutionHandler(onFulfilled, fulfilledHandlers, fulfil);\n  					processResolutionHandler(onRejected, rejectedHandlers, reject);\n\n  					if (state !== PENDING) {\n  						// If the promise has resolved already, dispatch the appropriate handlers asynchronously\n  						wait(dispatchHandlers);\n  					}\n  				});\n\n  				return promise2;\n  			}\n  		};\n\n  		promise["catch"] = function (onRejected) {\n  			return this.then(null, onRejected);\n  		};\n\n  		return promise;\n  	};\n\n  	_Promise.all = function (promises) {\n  		return new _Promise(function (fulfil, reject) {\n  			var result = [],\n  			    pending,\n  			    i,\n  			    processPromise;\n\n  			if (!promises.length) {\n  				fulfil(result);\n  				return;\n  			}\n\n  			processPromise = function (promise, i) {\n  				if (promise && typeof promise.then === "function") {\n  					promise.then(function (value) {\n  						result[i] = value;\n  						--pending || fulfil(result);\n  					}, reject);\n  				} else {\n  					result[i] = promise;\n  					--pending || fulfil(result);\n  				}\n  			};\n\n  			pending = i = promises.length;\n  			while (i--) {\n  				processPromise(promises[i], i);\n  			}\n  		});\n  	};\n\n  	_Promise.resolve = function (value) {\n  		return new _Promise(function (fulfil) {\n  			fulfil(value);\n  		});\n  	};\n\n  	_Promise.reject = function (reason) {\n  		return new _Promise(function (fulfil, reject) {\n  			reject(reason);\n  		});\n  	};\n  }\n\n  var utils_Promise = _Promise;\n\n  // TODO use MutationObservers or something to simulate setImmediate\n  function wait(callback) {\n  	setTimeout(callback, 0);\n  }\n\n  function makeDispatcher(handlers, result) {\n  	return function () {\n  		var handler;\n\n  		while (handler = handlers.shift()) {\n  			handler(result);\n  		}\n  	};\n  }\n\n  function utils_Promise__resolve(promise, x, fulfil, reject) {\n  	// Promise Resolution Procedure\n  	var then;\n\n  	// 2.3.1\n  	if (x === promise) {\n  		throw new TypeError("A promise\'s fulfillment handler cannot return the same promise");\n  	}\n\n  	// 2.3.2\n  	if (x instanceof _Promise) {\n  		x.then(fulfil, reject);\n  	}\n\n  	// 2.3.3\n  	else if (x && (typeof x === "object" || typeof x === "function")) {\n  		try {\n  			then = x.then; // 2.3.3.1\n  		} catch (e) {\n  			reject(e); // 2.3.3.2\n  			return;\n  		}\n\n  		// 2.3.3.3\n  		if (typeof then === "function") {\n  			var called, resolvePromise, rejectPromise;\n\n  			resolvePromise = function (y) {\n  				if (called) {\n  					return;\n  				}\n  				called = true;\n  				utils_Promise__resolve(promise, y, fulfil, reject);\n  			};\n\n  			rejectPromise = function (r) {\n  				if (called) {\n  					return;\n  				}\n  				called = true;\n  				reject(r);\n  			};\n\n  			try {\n  				then.call(x, resolvePromise, rejectPromise);\n  			} catch (e) {\n  				if (!called) {\n  					// 2.3.3.3.4.1\n  					reject(e); // 2.3.3.3.4.2\n  					called = true;\n  					return;\n  				}\n  			}\n  		} else {\n  			fulfil(x);\n  		}\n  	} else {\n  		fulfil(x);\n  	}\n  }\n\n  var getInnerContext = function (fragment) {\n  	do {\n  		if (fragment.context !== undefined) {\n  			return fragment.context;\n  		}\n  	} while (fragment = fragment.parent);\n\n  	return rootKeypath;\n  };\n\n  var shared_resolveRef = resolveRef;\n\n  function resolveRef(ractive, ref, fragment) {\n  	var keypath;\n\n  	ref = normalise(ref);\n\n  	// If a reference begins \'~/\', it\'s a top-level reference\n  	if (ref.substr(0, 2) === "~/") {\n  		keypath = getKeypath(ref.substring(2));\n  		createMappingIfNecessary(ractive, keypath.firstKey, fragment);\n  	}\n\n  	// If a reference begins with \'.\', it\'s either a restricted reference or\n  	// an ancestor reference...\n  	else if (ref[0] === ".") {\n  		keypath = resolveAncestorRef(getInnerContext(fragment), ref);\n\n  		if (keypath) {\n  			createMappingIfNecessary(ractive, keypath.firstKey, fragment);\n  		}\n  	}\n\n  	// ...otherwise we need to figure out the keypath based on context\n  	else {\n  		keypath = resolveAmbiguousReference(ractive, getKeypath(ref), fragment);\n  	}\n\n  	return keypath;\n  }\n\n  function resolveAncestorRef(baseContext, ref) {\n  	var contextKeys;\n\n  	// TODO...\n  	if (baseContext != undefined && typeof baseContext !== "string") {\n  		baseContext = baseContext.str;\n  	}\n\n  	// {{.}} means \'current context\'\n  	if (ref === ".") return getKeypath(baseContext);\n\n  	contextKeys = baseContext ? baseContext.split(".") : [];\n\n  	// ancestor references (starting "../") go up the tree\n  	if (ref.substr(0, 3) === "../") {\n  		while (ref.substr(0, 3) === "../") {\n  			if (!contextKeys.length) {\n  				throw new Error("Could not resolve reference - too many \\"../\\" prefixes");\n  			}\n\n  			contextKeys.pop();\n  			ref = ref.substring(3);\n  		}\n\n  		contextKeys.push(ref);\n  		return getKeypath(contextKeys.join("."));\n  	}\n\n  	// not an ancestor reference - must be a restricted reference (prepended with "." or "./")\n  	if (!baseContext) {\n  		return getKeypath(ref.replace(/^\\.\\/?/, ""));\n  	}\n\n  	return getKeypath(baseContext + ref.replace(/^\\.\\//, "."));\n  }\n\n  function resolveAmbiguousReference(ractive, ref, fragment, isParentLookup) {\n  	var context, key, parentValue, hasContextChain, parentKeypath;\n\n  	if (ref.isRoot) {\n  		return ref;\n  	}\n\n  	key = ref.firstKey;\n\n  	while (fragment) {\n  		context = fragment.context;\n  		fragment = fragment.parent;\n\n  		if (!context) {\n  			continue;\n  		}\n\n  		hasContextChain = true;\n  		parentValue = ractive.viewmodel.get(context);\n\n  		if (parentValue && (typeof parentValue === "object" || typeof parentValue === "function") && key in parentValue) {\n  			return context.join(ref.str);\n  		}\n  	}\n\n  	// Root/computed/mapped property?\n  	if (isRootProperty(ractive.viewmodel, key)) {\n  		return ref;\n  	}\n\n  	// If this is an inline component, and it\'s not isolated, we\n  	// can try going up the scope chain\n  	if (ractive.parent && !ractive.isolated) {\n  		hasContextChain = true;\n  		fragment = ractive.component.parentFragment;\n\n  		key = getKeypath(key);\n\n  		if (parentKeypath = resolveAmbiguousReference(ractive.parent, key, fragment, true)) {\n  			// We need to create an inter-component binding\n  			ractive.viewmodel.map(key, {\n  				origin: ractive.parent.viewmodel,\n  				keypath: parentKeypath\n  			});\n\n  			return ref;\n  		}\n  	}\n\n  	// If there\'s no context chain, and the instance is either a) isolated or\n  	// b) an orphan, then we know that the keypath is identical to the reference\n  	if (!isParentLookup && !hasContextChain) {\n  		// the data object needs to have a property by this name,\n  		// to prevent future failed lookups\n  		ractive.viewmodel.set(ref, undefined);\n  		return ref;\n  	}\n  }\n\n  function createMappingIfNecessary(ractive, key) {\n  	var parentKeypath;\n\n  	if (!ractive.parent || ractive.isolated || isRootProperty(ractive.viewmodel, key)) {\n  		return;\n  	}\n\n  	key = getKeypath(key);\n\n  	if (parentKeypath = resolveAmbiguousReference(ractive.parent, key, ractive.component.parentFragment, true)) {\n  		ractive.viewmodel.map(key, {\n  			origin: ractive.parent.viewmodel,\n  			keypath: parentKeypath\n  		});\n  	}\n  }\n\n  function isRootProperty(viewmodel, key) {\n  	// special case for reference to root\n  	return key === "" || key in viewmodel.data || key in viewmodel.computations || key in viewmodel.mappings;\n  }\n\n  function teardown(x) {\n    x.teardown();\n  }\n\n  function methodCallers__unbind(x) {\n    x.unbind();\n  }\n\n  function methodCallers__unrender(x) {\n    x.unrender();\n  }\n\n  function cancel(x) {\n    x.cancel();\n  }\n\n  var TransitionManager = function (callback, parent) {\n  	this.callback = callback;\n  	this.parent = parent;\n\n  	this.intros = [];\n  	this.outros = [];\n\n  	this.children = [];\n  	this.totalChildren = this.outroChildren = 0;\n\n  	this.detachQueue = [];\n  	this.decoratorQueue = [];\n  	this.outrosComplete = false;\n\n  	if (parent) {\n  		parent.addChild(this);\n  	}\n  };\n\n  TransitionManager.prototype = {\n  	addChild: function (child) {\n  		this.children.push(child);\n\n  		this.totalChildren += 1;\n  		this.outroChildren += 1;\n  	},\n\n  	decrementOutros: function () {\n  		this.outroChildren -= 1;\n  		check(this);\n  	},\n\n  	decrementTotal: function () {\n  		this.totalChildren -= 1;\n  		check(this);\n  	},\n\n  	add: function (transition) {\n  		var list = transition.isIntro ? this.intros : this.outros;\n  		list.push(transition);\n  	},\n\n  	addDecorator: function (decorator) {\n  		this.decoratorQueue.push(decorator);\n  	},\n\n  	remove: function (transition) {\n  		var list = transition.isIntro ? this.intros : this.outros;\n  		removeFromArray(list, transition);\n  		check(this);\n  	},\n\n  	init: function () {\n  		this.ready = true;\n  		check(this);\n  	},\n\n  	detachNodes: function () {\n  		this.decoratorQueue.forEach(teardown);\n  		this.detachQueue.forEach(detach);\n  		this.children.forEach(detachNodes);\n  	}\n  };\n\n  function detach(element) {\n  	element.detach();\n  }\n\n  function detachNodes(tm) {\n  	tm.detachNodes();\n  }\n\n  function check(tm) {\n  	if (!tm.ready || tm.outros.length || tm.outroChildren) return;\n\n  	// If all outros are complete, and we haven\'t already done this,\n  	// we notify the parent if there is one, otherwise\n  	// start detaching nodes\n  	if (!tm.outrosComplete) {\n  		if (tm.parent) {\n  			tm.parent.decrementOutros(tm);\n  		} else {\n  			tm.detachNodes();\n  		}\n\n  		tm.outrosComplete = true;\n  	}\n\n  	// Once everything is done, we can notify parent transition\n  	// manager and call the callback\n  	if (!tm.intros.length && !tm.totalChildren) {\n  		if (typeof tm.callback === "function") {\n  			tm.callback();\n  		}\n\n  		if (tm.parent) {\n  			tm.parent.decrementTotal();\n  		}\n  	}\n  }\n\n  var global_TransitionManager = TransitionManager;\n\n  var batch,\n      runloop,\n      unresolved = [],\n      changeHook = new hooks_Hook("change");\n\n  runloop = {\n  	start: function (instance, returnPromise) {\n  		var promise, fulfilPromise;\n\n  		if (returnPromise) {\n  			promise = new utils_Promise(function (f) {\n  				return fulfilPromise = f;\n  			});\n  		}\n\n  		batch = {\n  			previousBatch: batch,\n  			transitionManager: new global_TransitionManager(fulfilPromise, batch && batch.transitionManager),\n  			views: [],\n  			tasks: [],\n  			ractives: [],\n  			instance: instance\n  		};\n\n  		if (instance) {\n  			batch.ractives.push(instance);\n  		}\n\n  		return promise;\n  	},\n\n  	end: function () {\n  		flushChanges();\n\n  		batch.transitionManager.init();\n  		if (!batch.previousBatch && !!batch.instance) batch.instance.viewmodel.changes = [];\n  		batch = batch.previousBatch;\n  	},\n\n  	addRactive: function (ractive) {\n  		if (batch) {\n  			addToArray(batch.ractives, ractive);\n  		}\n  	},\n\n  	registerTransition: function (transition) {\n  		transition._manager = batch.transitionManager;\n  		batch.transitionManager.add(transition);\n  	},\n\n  	registerDecorator: function (decorator) {\n  		batch.transitionManager.addDecorator(decorator);\n  	},\n\n  	addView: function (view) {\n  		batch.views.push(view);\n  	},\n\n  	addUnresolved: function (thing) {\n  		unresolved.push(thing);\n  	},\n\n  	removeUnresolved: function (thing) {\n  		removeFromArray(unresolved, thing);\n  	},\n\n  	// synchronise node detachments with transition ends\n  	detachWhenReady: function (thing) {\n  		batch.transitionManager.detachQueue.push(thing);\n  	},\n\n  	scheduleTask: function (task, postRender) {\n  		var _batch;\n\n  		if (!batch) {\n  			task();\n  		} else {\n  			_batch = batch;\n  			while (postRender && _batch.previousBatch) {\n  				// this can\'t happen until the DOM has been fully updated\n  				// otherwise in some situations (with components inside elements)\n  				// transitions and decorators will initialise prematurely\n  				_batch = _batch.previousBatch;\n  			}\n\n  			_batch.tasks.push(task);\n  		}\n  	}\n  };\n\n  var global_runloop = runloop;\n\n  function flushChanges() {\n  	var i, thing, changeHash;\n\n  	while (batch.ractives.length) {\n  		thing = batch.ractives.pop();\n  		changeHash = thing.viewmodel.applyChanges();\n\n  		if (changeHash) {\n  			changeHook.fire(thing, changeHash);\n  		}\n  	}\n\n  	attemptKeypathResolution();\n\n  	// Now that changes have been fully propagated, we can update the DOM\n  	// and complete other tasks\n  	for (i = 0; i < batch.views.length; i += 1) {\n  		batch.views[i].update();\n  	}\n  	batch.views.length = 0;\n\n  	for (i = 0; i < batch.tasks.length; i += 1) {\n  		batch.tasks[i]();\n  	}\n  	batch.tasks.length = 0;\n\n  	// If updating the view caused some model blowback - e.g. a triple\n  	// containing <option> elements caused the binding on the <select>\n  	// to update - then we start over\n  	if (batch.ractives.length) return flushChanges();\n  }\n\n  function attemptKeypathResolution() {\n  	var i, item, keypath, resolved;\n\n  	i = unresolved.length;\n\n  	// see if we can resolve any unresolved references\n  	while (i--) {\n  		item = unresolved[i];\n\n  		if (item.keypath) {\n  			// it resolved some other way. TODO how? two-way binding? Seems\n  			// weird that we\'d still end up here\n  			unresolved.splice(i, 1);\n  			continue; // avoid removing the wrong thing should the next condition be true\n  		}\n\n  		if (keypath = shared_resolveRef(item.root, item.ref, item.parentFragment)) {\n  			(resolved || (resolved = [])).push({\n  				item: item,\n  				keypath: keypath\n  			});\n\n  			unresolved.splice(i, 1);\n  		}\n  	}\n\n  	if (resolved) {\n  		resolved.forEach(global_runloop__resolve);\n  	}\n  }\n\n  function global_runloop__resolve(resolved) {\n  	resolved.item.resolve(resolved.keypath);\n  }\n\n  var queue = [];\n\n  var animations = {\n  	tick: function () {\n  		var i, animation, now;\n\n  		now = utils_getTime();\n\n  		global_runloop.start();\n\n  		for (i = 0; i < queue.length; i += 1) {\n  			animation = queue[i];\n\n  			if (!animation.tick(now)) {\n  				// animation is complete, remove it from the stack, and decrement i so we don\'t miss one\n  				queue.splice(i--, 1);\n  			}\n  		}\n\n  		global_runloop.end();\n\n  		if (queue.length) {\n  			rAF(animations.tick);\n  		} else {\n  			animations.running = false;\n  		}\n  	},\n\n  	add: function (animation) {\n  		queue.push(animation);\n\n  		if (!animations.running) {\n  			animations.running = true;\n  			rAF(animations.tick);\n  		}\n  	},\n\n  	// TODO optimise this\n  	abort: function (keypath, root) {\n  		var i = queue.length,\n  		    animation;\n\n  		while (i--) {\n  			animation = queue[i];\n\n  			if (animation.root === root && animation.keypath === keypath) {\n  				animation.stop();\n  			}\n  		}\n  	}\n  };\n\n  var shared_animations = animations;\n\n  var Animation = function (options) {\n  	var key;\n\n  	this.startTime = Date.now();\n\n  	// from and to\n  	for (key in options) {\n  		if (options.hasOwnProperty(key)) {\n  			this[key] = options[key];\n  		}\n  	}\n\n  	this.interpolator = shared_interpolate(this.from, this.to, this.root, this.interpolator);\n  	this.running = true;\n\n  	this.tick();\n  };\n\n  Animation.prototype = {\n  	tick: function () {\n  		var elapsed, t, value, timeNow, index, keypath;\n\n  		keypath = this.keypath;\n\n  		if (this.running) {\n  			timeNow = Date.now();\n  			elapsed = timeNow - this.startTime;\n\n  			if (elapsed >= this.duration) {\n  				if (keypath !== null) {\n  					global_runloop.start(this.root);\n  					this.root.viewmodel.set(keypath, this.to);\n  					global_runloop.end();\n  				}\n\n  				if (this.step) {\n  					this.step(1, this.to);\n  				}\n\n  				this.complete(this.to);\n\n  				index = this.root._animations.indexOf(this);\n\n  				// TODO investigate why this happens\n  				if (index === -1) {\n  					warnIfDebug("Animation was not found");\n  				}\n\n  				this.root._animations.splice(index, 1);\n\n  				this.running = false;\n  				return false; // remove from the stack\n  			}\n\n  			t = this.easing ? this.easing(elapsed / this.duration) : elapsed / this.duration;\n\n  			if (keypath !== null) {\n  				value = this.interpolator(t);\n  				global_runloop.start(this.root);\n  				this.root.viewmodel.set(keypath, value);\n  				global_runloop.end();\n  			}\n\n  			if (this.step) {\n  				this.step(t, value);\n  			}\n\n  			return true; // keep in the stack\n  		}\n\n  		return false; // remove from the stack\n  	},\n\n  	stop: function () {\n  		var index;\n\n  		this.running = false;\n\n  		index = this.root._animations.indexOf(this);\n\n  		// TODO investigate why this happens\n  		if (index === -1) {\n  			warnIfDebug("Animation was not found");\n  		}\n\n  		this.root._animations.splice(index, 1);\n  	}\n  };\n\n  var animate_Animation = Animation;\n\n  var prototype_animate = Ractive$animate;\n\n  var noAnimation = { stop: noop };\n  function Ractive$animate(keypath, to, options) {\n  	var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;\n\n  	promise = new utils_Promise(function (fulfil) {\n  		return fulfilPromise = fulfil;\n  	});\n\n  	// animate multiple keypaths\n  	if (typeof keypath === "object") {\n  		options = to || {};\n  		easing = options.easing;\n  		duration = options.duration;\n\n  		animations = [];\n\n  		// we don\'t want to pass the `step` and `complete` handlers, as they will\n  		// run for each animation! So instead we\'ll store the handlers and create\n  		// our own...\n  		step = options.step;\n  		complete = options.complete;\n\n  		if (step || complete) {\n  			currentValues = {};\n\n  			options.step = null;\n  			options.complete = null;\n\n  			makeValueCollector = function (keypath) {\n  				return function (t, value) {\n  					currentValues[keypath] = value;\n  				};\n  			};\n  		}\n\n  		for (k in keypath) {\n  			if (keypath.hasOwnProperty(k)) {\n  				if (step || complete) {\n  					collectValue = makeValueCollector(k);\n  					options = { easing: easing, duration: duration };\n\n  					if (step) {\n  						options.step = collectValue;\n  					}\n  				}\n\n  				options.complete = complete ? collectValue : noop;\n  				animations.push(animate(this, k, keypath[k], options));\n  			}\n  		}\n\n  		// Create a dummy animation, to facilitate step/complete\n  		// callbacks, and Promise fulfilment\n  		dummyOptions = { easing: easing, duration: duration };\n\n  		if (step) {\n  			dummyOptions.step = function (t) {\n  				return step(t, currentValues);\n  			};\n  		}\n\n  		if (complete) {\n  			promise.then(function (t) {\n  				return complete(t, currentValues);\n  			});\n  		}\n\n  		dummyOptions.complete = fulfilPromise;\n\n  		dummy = animate(this, null, null, dummyOptions);\n  		animations.push(dummy);\n\n  		promise.stop = function () {\n  			var animation;\n\n  			while (animation = animations.pop()) {\n  				animation.stop();\n  			}\n\n  			if (dummy) {\n  				dummy.stop();\n  			}\n  		};\n\n  		return promise;\n  	}\n\n  	// animate a single keypath\n  	options = options || {};\n\n  	if (options.complete) {\n  		promise.then(options.complete);\n  	}\n\n  	options.complete = fulfilPromise;\n  	animation = animate(this, keypath, to, options);\n\n  	promise.stop = function () {\n  		return animation.stop();\n  	};\n  	return promise;\n  }\n\n  function animate(root, keypath, to, options) {\n  	var easing, duration, animation, from;\n\n  	if (keypath) {\n  		keypath = getKeypath(normalise(keypath));\n  	}\n\n  	if (keypath !== null) {\n  		from = root.viewmodel.get(keypath);\n  	}\n\n  	// cancel any existing animation\n  	// TODO what about upstream/downstream keypaths?\n  	shared_animations.abort(keypath, root);\n\n  	// don\'t bother animating values that stay the same\n  	if (isEqual(from, to)) {\n  		if (options.complete) {\n  			options.complete(options.to);\n  		}\n\n  		return noAnimation;\n  	}\n\n  	// easing function\n  	if (options.easing) {\n  		if (typeof options.easing === "function") {\n  			easing = options.easing;\n  		} else {\n  			easing = root.easing[options.easing];\n  		}\n\n  		if (typeof easing !== "function") {\n  			easing = null;\n  		}\n  	}\n\n  	// duration\n  	duration = options.duration === undefined ? 400 : options.duration;\n\n  	// TODO store keys, use an internal set method\n  	animation = new animate_Animation({\n  		keypath: keypath,\n  		from: from,\n  		to: to,\n  		root: root,\n  		duration: duration,\n  		easing: easing,\n  		interpolator: options.interpolator,\n\n  		// TODO wrap callbacks if necessary, to use instance as context\n  		step: options.step,\n  		complete: options.complete\n  	});\n\n  	shared_animations.add(animation);\n  	root._animations.push(animation);\n\n  	return animation;\n  }\n\n  var prototype_detach = Ractive$detach;\n  var prototype_detach__detachHook = new hooks_Hook("detach");\n  function Ractive$detach() {\n  	if (this.detached) {\n  		return this.detached;\n  	}\n\n  	if (this.el) {\n  		removeFromArray(this.el.__ractive_instances__, this);\n  	}\n  	this.detached = this.fragment.detach();\n  	prototype_detach__detachHook.fire(this);\n  	return this.detached;\n  }\n\n  var prototype_find = Ractive$find;\n\n  function Ractive$find(selector) {\n  	if (!this.el) {\n  		return null;\n  	}\n\n  	return this.fragment.find(selector);\n  }\n\n  var test = Query$test;\n  function Query$test(item, noDirty) {\n  	var itemMatches;\n\n  	if (this._isComponentQuery) {\n  		itemMatches = !this.selector || item.name === this.selector;\n  	} else {\n  		itemMatches = item.node ? matches(item.node, this.selector) : null;\n  	}\n\n  	if (itemMatches) {\n  		this.push(item.node || item.instance);\n\n  		if (!noDirty) {\n  			this._makeDirty();\n  		}\n\n  		return true;\n  	}\n  }\n\n  var makeQuery_cancel = function () {\n  	var liveQueries, selector, index;\n\n  	liveQueries = this._root[this._isComponentQuery ? "liveComponentQueries" : "liveQueries"];\n  	selector = this.selector;\n\n  	index = liveQueries.indexOf(selector);\n\n  	if (index !== -1) {\n  		liveQueries.splice(index, 1);\n  		liveQueries[selector] = null;\n  	}\n  };\n\n  var sortByItemPosition = function (a, b) {\n  	var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;\n\n  	ancestryA = getAncestry(a.component || a._ractive.proxy);\n  	ancestryB = getAncestry(b.component || b._ractive.proxy);\n\n  	oldestA = lastItem(ancestryA);\n  	oldestB = lastItem(ancestryB);\n\n  	// remove items from the end of both ancestries as long as they are identical\n  	// - the final one removed is the closest mutual ancestor\n  	while (oldestA && oldestA === oldestB) {\n  		ancestryA.pop();\n  		ancestryB.pop();\n\n  		mutualAncestor = oldestA;\n\n  		oldestA = lastItem(ancestryA);\n  		oldestB = lastItem(ancestryB);\n  	}\n\n  	// now that we have the mutual ancestor, we can find which is earliest\n  	oldestA = oldestA.component || oldestA;\n  	oldestB = oldestB.component || oldestB;\n\n  	fragmentA = oldestA.parentFragment;\n  	fragmentB = oldestB.parentFragment;\n\n  	// if both items share a parent fragment, our job is easy\n  	if (fragmentA === fragmentB) {\n  		indexA = fragmentA.items.indexOf(oldestA);\n  		indexB = fragmentB.items.indexOf(oldestB);\n\n  		// if it\'s the same index, it means one contains the other,\n  		// so we see which has the longest ancestry\n  		return indexA - indexB || ancestryA.length - ancestryB.length;\n  	}\n\n  	// if mutual ancestor is a section, we first test to see which section\n  	// fragment comes first\n  	if (fragments = mutualAncestor.fragments) {\n  		indexA = fragments.indexOf(fragmentA);\n  		indexB = fragments.indexOf(fragmentB);\n\n  		return indexA - indexB || ancestryA.length - ancestryB.length;\n  	}\n\n  	throw new Error("An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!");\n  };\n\n  function getParent(item) {\n  	var parentFragment;\n\n  	if (parentFragment = item.parentFragment) {\n  		return parentFragment.owner;\n  	}\n\n  	if (item.component && (parentFragment = item.component.parentFragment)) {\n  		return parentFragment.owner;\n  	}\n  }\n\n  function getAncestry(item) {\n  	var ancestry, ancestor;\n\n  	ancestry = [item];\n\n  	ancestor = getParent(item);\n\n  	while (ancestor) {\n  		ancestry.push(ancestor);\n  		ancestor = getParent(ancestor);\n  	}\n\n  	return ancestry;\n  }\n\n  var sortByDocumentPosition = function (node, otherNode) {\n  	var bitmask;\n\n  	if (node.compareDocumentPosition) {\n  		bitmask = node.compareDocumentPosition(otherNode);\n  		return bitmask & 2 ? 1 : -1;\n  	}\n\n  	// In old IE, we can piggy back on the mechanism for\n  	// comparing component positions\n  	return sortByItemPosition(node, otherNode);\n  };\n\n  var sort = function () {\n  	this.sort(this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition);\n  	this._dirty = false;\n  };\n\n  var makeQuery_dirty = function () {\n  	var _this = this;\n\n  	if (!this._dirty) {\n  		this._dirty = true;\n\n  		// Once the DOM has been updated, ensure the query\n  		// is correctly ordered\n  		global_runloop.scheduleTask(function () {\n  			_this._sort();\n  		});\n  	}\n  };\n\n  var remove = function (nodeOrComponent) {\n  	var index = this.indexOf(this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent);\n\n  	if (index !== -1) {\n  		this.splice(index, 1);\n  	}\n  };\n\n  var _makeQuery = makeQuery;\n  function makeQuery(ractive, selector, live, isComponentQuery) {\n  	var query = [];\n\n  	defineProperties(query, {\n  		selector: { value: selector },\n  		live: { value: live },\n\n  		_isComponentQuery: { value: isComponentQuery },\n  		_test: { value: test }\n  	});\n\n  	if (!live) {\n  		return query;\n  	}\n\n  	defineProperties(query, {\n  		cancel: { value: makeQuery_cancel },\n\n  		_root: { value: ractive },\n  		_sort: { value: sort },\n  		_makeDirty: { value: makeQuery_dirty },\n  		_remove: { value: remove },\n\n  		_dirty: { value: false, writable: true }\n  	});\n\n  	return query;\n  }\n\n  var prototype_findAll = Ractive$findAll;\n  function Ractive$findAll(selector, options) {\n  	var liveQueries, query;\n\n  	if (!this.el) {\n  		return [];\n  	}\n\n  	options = options || {};\n  	liveQueries = this._liveQueries;\n\n  	// Shortcut: if we\'re maintaining a live query with this\n  	// selector, we don\'t need to traverse the parallel DOM\n  	if (query = liveQueries[selector]) {\n\n  		// Either return the exact same query, or (if not live) a snapshot\n  		return options && options.live ? query : query.slice();\n  	}\n\n  	query = _makeQuery(this, selector, !!options.live, false);\n\n  	// Add this to the list of live queries Ractive needs to maintain,\n  	// if applicable\n  	if (query.live) {\n  		liveQueries.push(selector);\n  		liveQueries["_" + selector] = query;\n  	}\n\n  	this.fragment.findAll(selector, query);\n  	return query;\n  }\n\n  var prototype_findAllComponents = Ractive$findAllComponents;\n  function Ractive$findAllComponents(selector, options) {\n  	var liveQueries, query;\n\n  	options = options || {};\n  	liveQueries = this._liveComponentQueries;\n\n  	// Shortcut: if we\'re maintaining a live query with this\n  	// selector, we don\'t need to traverse the parallel DOM\n  	if (query = liveQueries[selector]) {\n\n  		// Either return the exact same query, or (if not live) a snapshot\n  		return options && options.live ? query : query.slice();\n  	}\n\n  	query = _makeQuery(this, selector, !!options.live, true);\n\n  	// Add this to the list of live queries Ractive needs to maintain,\n  	// if applicable\n  	if (query.live) {\n  		liveQueries.push(selector);\n  		liveQueries["_" + selector] = query;\n  	}\n\n  	this.fragment.findAllComponents(selector, query);\n  	return query;\n  }\n\n  var prototype_findComponent = Ractive$findComponent;\n\n  function Ractive$findComponent(selector) {\n  	return this.fragment.findComponent(selector);\n  }\n\n  var findContainer = Ractive$findContainer;\n\n  function Ractive$findContainer(selector) {\n  	if (this.container) {\n  		if (this.container.component && this.container.component.name === selector) {\n  			return this.container;\n  		} else {\n  			return this.container.findContainer(selector);\n  		}\n  	}\n\n  	return null;\n  }\n\n  var findParent = Ractive$findParent;\n\n  function Ractive$findParent(selector) {\n\n  	if (this.parent) {\n  		if (this.parent.component && this.parent.component.name === selector) {\n  			return this.parent;\n  		} else {\n  			return this.parent.findParent(selector);\n  		}\n  	}\n\n  	return null;\n  }\n\n  var eventStack = {\n  	enqueue: function (ractive, event) {\n  		if (ractive.event) {\n  			ractive._eventQueue = ractive._eventQueue || [];\n  			ractive._eventQueue.push(ractive.event);\n  		}\n  		ractive.event = event;\n  	},\n  	dequeue: function (ractive) {\n  		if (ractive._eventQueue && ractive._eventQueue.length) {\n  			ractive.event = ractive._eventQueue.pop();\n  		} else {\n  			delete ractive.event;\n  		}\n  	}\n  };\n\n  var shared_eventStack = eventStack;\n\n  var shared_fireEvent = fireEvent;\n\n  function fireEvent(ractive, eventName) {\n  	var options = arguments[2] === undefined ? {} : arguments[2];\n\n  	if (!eventName) {\n  		return;\n  	}\n\n  	if (!options.event) {\n  		options.event = {\n  			name: eventName,\n  			// until event not included as argument default\n  			_noArg: true\n  		};\n  	} else {\n  		options.event.name = eventName;\n  	}\n\n  	var eventNames = getKeypath(eventName).wildcardMatches();\n  	fireEventAs(ractive, eventNames, options.event, options.args, true);\n  }\n\n  function fireEventAs(ractive, eventNames, event, args) {\n  	var initialFire = arguments[4] === undefined ? false : arguments[4];\n\n  	var subscribers,\n  	    i,\n  	    bubble = true;\n\n  	shared_eventStack.enqueue(ractive, event);\n\n  	for (i = eventNames.length; i >= 0; i--) {\n  		subscribers = ractive._subs[eventNames[i]];\n\n  		if (subscribers) {\n  			bubble = notifySubscribers(ractive, subscribers, event, args) && bubble;\n  		}\n  	}\n\n  	shared_eventStack.dequeue(ractive);\n\n  	if (ractive.parent && bubble) {\n\n  		if (initialFire && ractive.component) {\n  			var fullName = ractive.component.name + "." + eventNames[eventNames.length - 1];\n  			eventNames = getKeypath(fullName).wildcardMatches();\n\n  			if (event) {\n  				event.component = ractive;\n  			}\n  		}\n\n  		fireEventAs(ractive.parent, eventNames, event, args);\n  	}\n  }\n\n  function notifySubscribers(ractive, subscribers, event, args) {\n  	var originalEvent = null,\n  	    stopEvent = false;\n\n  	if (event && !event._noArg) {\n  		args = [event].concat(args);\n  	}\n\n  	// subscribers can be modified inflight, e.g. "once" functionality\n  	// so we need to copy to make sure everyone gets called\n  	subscribers = subscribers.slice();\n\n  	for (var i = 0, len = subscribers.length; i < len; i += 1) {\n  		if (subscribers[i].apply(ractive, args) === false) {\n  			stopEvent = true;\n  		}\n  	}\n\n  	if (event && !event._noArg && stopEvent && (originalEvent = event.original)) {\n  		originalEvent.preventDefault && originalEvent.preventDefault();\n  		originalEvent.stopPropagation && originalEvent.stopPropagation();\n  	}\n\n  	return !stopEvent;\n  }\n\n  var prototype_fire = Ractive$fire;\n  function Ractive$fire(eventName) {\n\n  	var options = {\n  		args: Array.prototype.slice.call(arguments, 1)\n  	};\n\n  	shared_fireEvent(this, eventName, options);\n  }\n\n  var prototype_get = Ractive$get;\n  var options = {\n  	capture: true, // top-level calls should be intercepted\n  	noUnwrap: true, // wrapped values should NOT be unwrapped\n  	fullRootGet: true // root get should return mappings\n  };\n  function Ractive$get(keypath) {\n  	var value;\n\n  	keypath = getKeypath(normalise(keypath));\n  	value = this.viewmodel.get(keypath, options);\n\n  	// Create inter-component binding, if necessary\n  	if (value === undefined && this.parent && !this.isolated) {\n  		if (shared_resolveRef(this, keypath.str, this.component.parentFragment)) {\n  			// creates binding as side-effect, if appropriate\n  			value = this.viewmodel.get(keypath);\n  		}\n  	}\n\n  	return value;\n  }\n\n  var insert = Ractive$insert;\n\n  var insertHook = new hooks_Hook("insert");\n  function Ractive$insert(target, anchor) {\n  	if (!this.fragment.rendered) {\n  		// TODO create, and link to, documentation explaining this\n  		throw new Error("The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.");\n  	}\n\n  	target = getElement(target);\n  	anchor = getElement(anchor) || null;\n\n  	if (!target) {\n  		throw new Error("You must specify a valid target to insert into");\n  	}\n\n  	target.insertBefore(this.detach(), anchor);\n  	this.el = target;\n\n  	(target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(this);\n  	this.detached = null;\n\n  	fireInsertHook(this);\n  }\n\n  function fireInsertHook(ractive) {\n  	insertHook.fire(ractive);\n\n  	ractive.findAllComponents("*").forEach(function (child) {\n  		fireInsertHook(child.instance);\n  	});\n  }\n\n  var prototype_merge = Ractive$merge;\n  function Ractive$merge(keypath, array, options) {\n  	var currentArray, promise;\n\n  	keypath = getKeypath(normalise(keypath));\n  	currentArray = this.viewmodel.get(keypath);\n\n  	// If either the existing value or the new value isn\'t an\n  	// array, just do a regular set\n  	if (!isArray(currentArray) || !isArray(array)) {\n  		return this.set(keypath, array, options && options.complete);\n  	}\n\n  	// Manage transitions\n  	promise = global_runloop.start(this, true);\n  	this.viewmodel.merge(keypath, currentArray, array, options);\n  	global_runloop.end();\n\n  	return promise;\n  }\n\n  var Observer = function (ractive, keypath, callback, options) {\n  	this.root = ractive;\n  	this.keypath = keypath;\n  	this.callback = callback;\n  	this.defer = options.defer;\n\n  	// default to root as context, but allow it to be overridden\n  	this.context = options && options.context ? options.context : ractive;\n  };\n\n  Observer.prototype = {\n  	init: function (immediate) {\n  		this.value = this.root.get(this.keypath.str);\n\n  		if (immediate !== false) {\n  			this.update();\n  		} else {\n  			this.oldValue = this.value;\n  		}\n  	},\n\n  	setValue: function (value) {\n  		var _this = this;\n\n  		if (!isEqual(value, this.value)) {\n  			this.value = value;\n\n  			if (this.defer && this.ready) {\n  				global_runloop.scheduleTask(function () {\n  					return _this.update();\n  				});\n  			} else {\n  				this.update();\n  			}\n  		}\n  	},\n\n  	update: function () {\n  		// Prevent infinite loops\n  		if (this.updating) {\n  			return;\n  		}\n\n  		this.updating = true;\n\n  		this.callback.call(this.context, this.value, this.oldValue, this.keypath.str);\n  		this.oldValue = this.value;\n\n  		this.updating = false;\n  	}\n  };\n\n  var observe_Observer = Observer;\n\n  var observe_getPattern = getPattern;\n  function getPattern(ractive, pattern) {\n  	var matchingKeypaths, values;\n\n  	matchingKeypaths = getMatchingKeypaths(ractive, pattern);\n\n  	values = {};\n  	matchingKeypaths.forEach(function (keypath) {\n  		values[keypath.str] = ractive.get(keypath.str);\n  	});\n\n  	return values;\n  }\n\n  var PatternObserver,\n      slice = Array.prototype.slice;\n\n  PatternObserver = function (ractive, keypath, callback, options) {\n  	this.root = ractive;\n\n  	this.callback = callback;\n  	this.defer = options.defer;\n\n  	this.keypath = keypath;\n  	this.regex = new RegExp("^" + keypath.str.replace(/\\./g, "\\\\.").replace(/\\*/g, "([^\\\\.]+)") + "$");\n  	this.values = {};\n\n  	if (this.defer) {\n  		this.proxies = [];\n  	}\n\n  	// default to root as context, but allow it to be overridden\n  	this.context = options && options.context ? options.context : ractive;\n  };\n\n  PatternObserver.prototype = {\n  	init: function (immediate) {\n  		var values, keypath;\n\n  		values = observe_getPattern(this.root, this.keypath);\n\n  		if (immediate !== false) {\n  			for (keypath in values) {\n  				if (values.hasOwnProperty(keypath)) {\n  					this.update(getKeypath(keypath));\n  				}\n  			}\n  		} else {\n  			this.values = values;\n  		}\n  	},\n\n  	update: function (keypath) {\n  		var _this = this;\n\n  		var values;\n\n  		if (keypath.isPattern) {\n  			values = observe_getPattern(this.root, keypath);\n\n  			for (keypath in values) {\n  				if (values.hasOwnProperty(keypath)) {\n  					this.update(getKeypath(keypath));\n  				}\n  			}\n\n  			return;\n  		}\n\n  		// special case - array mutation should not trigger `array.*`\n  		// pattern observer with `array.length`\n  		if (this.root.viewmodel.implicitChanges[keypath.str]) {\n  			return;\n  		}\n\n  		if (this.defer && this.ready) {\n  			global_runloop.scheduleTask(function () {\n  				return _this.getProxy(keypath).update();\n  			});\n  			return;\n  		}\n\n  		this.reallyUpdate(keypath);\n  	},\n\n  	reallyUpdate: function (keypath) {\n  		var keypathStr, value, keys, args;\n\n  		keypathStr = keypath.str;\n  		value = this.root.viewmodel.get(keypath);\n\n  		// Prevent infinite loops\n  		if (this.updating) {\n  			this.values[keypathStr] = value;\n  			return;\n  		}\n\n  		this.updating = true;\n\n  		if (!isEqual(value, this.values[keypathStr]) || !this.ready) {\n  			keys = slice.call(this.regex.exec(keypathStr), 1);\n  			args = [value, this.values[keypathStr], keypathStr].concat(keys);\n\n  			this.values[keypathStr] = value;\n  			this.callback.apply(this.context, args);\n  		}\n\n  		this.updating = false;\n  	},\n\n  	getProxy: function (keypath) {\n  		var _this = this;\n\n  		if (!this.proxies[keypath.str]) {\n  			this.proxies[keypath.str] = {\n  				update: function () {\n  					return _this.reallyUpdate(keypath);\n  				}\n  			};\n  		}\n\n  		return this.proxies[keypath.str];\n  	}\n  };\n\n  var observe_PatternObserver = PatternObserver;\n\n  var observe_getObserverFacade = getObserverFacade;\n  var emptyObject = {};\n  function getObserverFacade(ractive, keypath, callback, options) {\n  	var observer, isPatternObserver, cancelled;\n\n  	keypath = getKeypath(normalise(keypath));\n  	options = options || emptyObject;\n\n  	// pattern observers are treated differently\n  	if (keypath.isPattern) {\n  		observer = new observe_PatternObserver(ractive, keypath, callback, options);\n  		ractive.viewmodel.patternObservers.push(observer);\n  		isPatternObserver = true;\n  	} else {\n  		observer = new observe_Observer(ractive, keypath, callback, options);\n  	}\n\n  	observer.init(options.init);\n  	ractive.viewmodel.register(keypath, observer, isPatternObserver ? "patternObservers" : "observers");\n\n  	// This flag allows observers to initialise even with undefined values\n  	observer.ready = true;\n\n  	var facade = {\n  		cancel: function () {\n  			var index;\n\n  			if (cancelled) {\n  				return;\n  			}\n\n  			if (isPatternObserver) {\n  				index = ractive.viewmodel.patternObservers.indexOf(observer);\n\n  				ractive.viewmodel.patternObservers.splice(index, 1);\n  				ractive.viewmodel.unregister(keypath, observer, "patternObservers");\n  			} else {\n  				ractive.viewmodel.unregister(keypath, observer, "observers");\n  			}\n  			cancelled = true;\n  		}\n  	};\n\n  	ractive._observers.push(facade);\n  	return facade;\n  }\n\n  var observe = Ractive$observe;\n  function Ractive$observe(keypath, callback, options) {\n\n  	var observers, map, keypaths, i;\n\n  	// Allow a map of keypaths to handlers\n  	if (isObject(keypath)) {\n  		options = callback;\n  		map = keypath;\n\n  		observers = [];\n\n  		for (keypath in map) {\n  			if (map.hasOwnProperty(keypath)) {\n  				callback = map[keypath];\n  				observers.push(this.observe(keypath, callback, options));\n  			}\n  		}\n\n  		return {\n  			cancel: function () {\n  				while (observers.length) {\n  					observers.pop().cancel();\n  				}\n  			}\n  		};\n  	}\n\n  	// Allow `ractive.observe( callback )` - i.e. observe entire model\n  	if (typeof keypath === "function") {\n  		options = callback;\n  		callback = keypath;\n  		keypath = "";\n\n  		return observe_getObserverFacade(this, keypath, callback, options);\n  	}\n\n  	keypaths = keypath.split(" ");\n\n  	// Single keypath\n  	if (keypaths.length === 1) {\n  		return observe_getObserverFacade(this, keypath, callback, options);\n  	}\n\n  	// Multiple space-separated keypaths\n  	observers = [];\n\n  	i = keypaths.length;\n  	while (i--) {\n  		keypath = keypaths[i];\n\n  		if (keypath) {\n  			observers.push(observe_getObserverFacade(this, keypath, callback, options));\n  		}\n  	}\n\n  	return {\n  		cancel: function () {\n  			while (observers.length) {\n  				observers.pop().cancel();\n  			}\n  		}\n  	};\n  }\n\n  var observeOnce = Ractive$observeOnce;\n\n  function Ractive$observeOnce(property, callback, options) {\n\n  	var observer = this.observe(property, function () {\n  		callback.apply(this, arguments);\n  		observer.cancel();\n  	}, { init: false, defer: options && options.defer });\n\n  	return observer;\n  }\n\n  var shared_trim = function (str) {\n    return str.trim();\n  };\n\n  var notEmptyString = function (str) {\n    return str !== "";\n  };\n\n  var off = Ractive$off;\n  function Ractive$off(eventName, callback) {\n  	var _this = this;\n\n  	var eventNames;\n\n  	// if no arguments specified, remove all callbacks\n  	if (!eventName) {\n  		// TODO use this code instead, once the following issue has been resolved\n  		// in PhantomJS (tests are unpassable otherwise!)\n  		// https://github.com/ariya/phantomjs/issues/11856\n  		// defineProperty( this, \'_subs\', { value: create( null ), configurable: true });\n  		for (eventName in this._subs) {\n  			delete this._subs[eventName];\n  		}\n  	} else {\n  		// Handle multiple space-separated event names\n  		eventNames = eventName.split(" ").map(shared_trim).filter(notEmptyString);\n\n  		eventNames.forEach(function (eventName) {\n  			var subscribers, index;\n\n  			// If we have subscribers for this event...\n  			if (subscribers = _this._subs[eventName]) {\n  				// ...if a callback was specified, only remove that\n  				if (callback) {\n  					index = subscribers.indexOf(callback);\n  					if (index !== -1) {\n  						subscribers.splice(index, 1);\n  					}\n  				}\n\n  				// ...otherwise remove all callbacks\n  				else {\n  					_this._subs[eventName] = [];\n  				}\n  			}\n  		});\n  	}\n\n  	return this;\n  }\n\n  var on = Ractive$on;\n  function Ractive$on(eventName, callback) {\n  	var _this = this;\n\n  	var listeners, n, eventNames;\n\n  	// allow mutliple listeners to be bound in one go\n  	if (typeof eventName === "object") {\n  		listeners = [];\n\n  		for (n in eventName) {\n  			if (eventName.hasOwnProperty(n)) {\n  				listeners.push(this.on(n, eventName[n]));\n  			}\n  		}\n\n  		return {\n  			cancel: function () {\n  				var listener;\n\n  				while (listener = listeners.pop()) {\n  					listener.cancel();\n  				}\n  			}\n  		};\n  	}\n\n  	// Handle multiple space-separated event names\n  	eventNames = eventName.split(" ").map(shared_trim).filter(notEmptyString);\n\n  	eventNames.forEach(function (eventName) {\n  		(_this._subs[eventName] || (_this._subs[eventName] = [])).push(callback);\n  	});\n\n  	return {\n  		cancel: function () {\n  			return _this.off(eventName, callback);\n  		}\n  	};\n  }\n\n  var once = Ractive$once;\n\n  function Ractive$once(eventName, handler) {\n\n  	var listener = this.on(eventName, function () {\n  		handler.apply(this, arguments);\n  		listener.cancel();\n  	});\n\n  	// so we can still do listener.cancel() manually\n  	return listener;\n  }\n\n  // This function takes an array, the name of a mutator method, and the\n  // arguments to call that mutator method with, and returns an array that\n  // maps the old indices to their new indices.\n\n  // So if you had something like this...\n  //\n  //     array = [ \'a\', \'b\', \'c\', \'d\' ];\n  //     array.push( \'e\' );\n  //\n  // ...you\'d get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n  // have changed. If you then did this...\n  //\n  //     array.unshift( \'z\' );\n  //\n  // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n  // one higher to make room for the \'z\'. If you removed an item, the new index\n  // would be -1...\n  //\n  //     array.splice( 2, 2 );\n  //\n  // ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n  //\n  // This information is used to enable fast, non-destructive shuffling of list\n  // sections when you do e.g. `ractive.splice( \'items\', 2, 2 );\n\n  var shared_getNewIndices = getNewIndices;\n\n  function getNewIndices(array, methodName, args) {\n  	var spliceArguments,\n  	    len,\n  	    newIndices = [],\n  	    removeStart,\n  	    removeEnd,\n  	    balance,\n  	    i;\n\n  	spliceArguments = getSpliceEquivalent(array, methodName, args);\n\n  	if (!spliceArguments) {\n  		return null; // TODO support reverse and sort?\n  	}\n\n  	len = array.length;\n  	balance = spliceArguments.length - 2 - spliceArguments[1];\n\n  	removeStart = Math.min(len, spliceArguments[0]);\n  	removeEnd = removeStart + spliceArguments[1];\n\n  	for (i = 0; i < removeStart; i += 1) {\n  		newIndices.push(i);\n  	}\n\n  	for (; i < removeEnd; i += 1) {\n  		newIndices.push(-1);\n  	}\n\n  	for (; i < len; i += 1) {\n  		newIndices.push(i + balance);\n  	}\n\n  	// there is a net shift for the rest of the array starting with index + balance\n  	if (balance !== 0) {\n  		newIndices.touchedFrom = spliceArguments[0];\n  	} else {\n  		newIndices.touchedFrom = array.length;\n  	}\n\n  	return newIndices;\n  }\n\n  // The pop, push, shift an unshift methods can all be represented\n  // as an equivalent splice\n  function getSpliceEquivalent(array, methodName, args) {\n  	switch (methodName) {\n  		case "splice":\n  			if (args[0] !== undefined && args[0] < 0) {\n  				args[0] = array.length + Math.max(args[0], -array.length);\n  			}\n\n  			while (args.length < 2) {\n  				args.push(0);\n  			}\n\n  			// ensure we only remove elements that exist\n  			args[1] = Math.min(args[1], array.length - args[0]);\n\n  			return args;\n\n  		case "sort":\n  		case "reverse":\n  			return null;\n\n  		case "pop":\n  			if (array.length) {\n  				return [array.length - 1, 1];\n  			}\n  			return [0, 0];\n\n  		case "push":\n  			return [array.length, 0].concat(args);\n\n  		case "shift":\n  			return [0, array.length ? 1 : 0];\n\n  		case "unshift":\n  			return [0, 0].concat(args);\n  	}\n  }\n\n  var arrayProto = Array.prototype;\n\n  var makeArrayMethod = function (methodName) {\n  	return function (keypath) {\n  		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  			args[_key - 1] = arguments[_key];\n  		}\n\n  		var array,\n  		    newIndices = [],\n  		    len,\n  		    promise,\n  		    result;\n\n  		keypath = getKeypath(normalise(keypath));\n\n  		array = this.viewmodel.get(keypath);\n  		len = array.length;\n\n  		if (!isArray(array)) {\n  			throw new Error("Called ractive." + methodName + "(\'" + keypath.str + "\'), but \'" + keypath.str + "\' does not refer to an array");\n  		}\n\n  		newIndices = shared_getNewIndices(array, methodName, args);\n\n  		result = arrayProto[methodName].apply(array, args);\n  		promise = global_runloop.start(this, true).then(function () {\n  			return result;\n  		});\n\n  		if (!!newIndices) {\n  			this.viewmodel.smartUpdate(keypath, array, newIndices);\n  		} else {\n  			this.viewmodel.mark(keypath);\n  		}\n\n  		global_runloop.end();\n\n  		return promise;\n  	};\n  };\n\n  var pop = makeArrayMethod("pop");\n\n  var push = makeArrayMethod("push");\n\n  var css,\n      update,\n      styleElement,\n      head,\n      styleSheet,\n      inDom,\n      global_css__prefix = "/* Ractive.js component styles */\\n",\n      styles = [],\n      dirty = false;\n\n  if (!isClient) {\n  	// TODO handle encapsulated CSS in server-rendered HTML!\n  	css = {\n  		add: noop,\n  		apply: noop\n  	};\n  } else {\n  	styleElement = document.createElement("style");\n  	styleElement.type = "text/css";\n\n  	head = document.getElementsByTagName("head")[0];\n\n  	inDom = false;\n\n  	// Internet Exploder won\'t let you use styleSheet.innerHTML - we have to\n  	// use styleSheet.cssText instead\n  	styleSheet = styleElement.styleSheet;\n\n  	update = function () {\n  		var css = global_css__prefix + styles.map(function (s) {\n  			return "\\n/* {" + s.id + "} */\\n" + s.styles;\n  		}).join("\\n");\n\n  		if (styleSheet) {\n  			styleSheet.cssText = css;\n  		} else {\n  			styleElement.innerHTML = css;\n  		}\n\n  		if (!inDom) {\n  			head.appendChild(styleElement);\n  			inDom = true;\n  		}\n  	};\n\n  	css = {\n  		add: function (s) {\n  			styles.push(s);\n  			dirty = true;\n  		},\n\n  		apply: function () {\n  			if (dirty) {\n  				update();\n  				dirty = false;\n  			}\n  		}\n  	};\n  }\n\n  var global_css = css;\n\n  var prototype_render = Ractive$render;\n\n  var renderHook = new hooks_Hook("render"),\n      completeHook = new hooks_Hook("complete");\n  function Ractive$render(target, anchor) {\n  	var _this = this;\n\n  	var promise, instances, transitionsEnabled;\n\n  	// if `noIntro` is `true`, temporarily disable transitions\n  	transitionsEnabled = this.transitionsEnabled;\n  	if (this.noIntro) {\n  		this.transitionsEnabled = false;\n  	}\n\n  	promise = global_runloop.start(this, true);\n  	global_runloop.scheduleTask(function () {\n  		return renderHook.fire(_this);\n  	}, true);\n\n  	if (this.fragment.rendered) {\n  		throw new Error("You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first");\n  	}\n\n  	target = getElement(target) || this.el;\n  	anchor = getElement(anchor) || this.anchor;\n\n  	this.el = target;\n  	this.anchor = anchor;\n\n  	if (!this.append && target) {\n  		// Teardown any existing instances *before* trying to set up the new one -\n  		// avoids certain weird bugs\n  		var others = target.__ractive_instances__;\n  		if (others && others.length) {\n  			removeOtherInstances(others);\n  		}\n\n  		// make sure we are the only occupants\n  		target.innerHTML = ""; // TODO is this quicker than removeChild? Initial research inconclusive\n  	}\n\n  	if (this.cssId) {\n  		// ensure encapsulated CSS is up-to-date\n  		global_css.apply();\n  	}\n\n  	if (target) {\n  		if (!(instances = target.__ractive_instances__)) {\n  			target.__ractive_instances__ = [this];\n  		} else {\n  			instances.push(this);\n  		}\n\n  		if (anchor) {\n  			target.insertBefore(this.fragment.render(), anchor);\n  		} else {\n  			target.appendChild(this.fragment.render());\n  		}\n  	}\n\n  	global_runloop.end();\n\n  	this.transitionsEnabled = transitionsEnabled;\n\n  	return promise.then(function () {\n  		return completeHook.fire(_this);\n  	});\n  }\n\n  function removeOtherInstances(others) {\n  	others.splice(0, others.length).forEach(teardown);\n  }\n\n  var adaptConfigurator = {\n  	extend: function (Parent, proto, options) {\n  		proto.adapt = custom_adapt__combine(proto.adapt, ensureArray(options.adapt));\n  	},\n\n  	init: function () {}\n  };\n\n  var custom_adapt = adaptConfigurator;\n\n  function custom_adapt__combine(a, b) {\n  	var c = a.slice(),\n  	    i = b.length;\n\n  	while (i--) {\n  		if (! ~c.indexOf(b[i])) {\n  			c.push(b[i]);\n  		}\n  	}\n\n  	return c;\n  }\n\n  var transform = transformCss;\n\n  var selectorsPattern = /(?:^|\\})?\\s*([^\\{\\}]+)\\s*\\{/g,\n      commentsPattern = /\\/\\*.*?\\*\\//g,\n      selectorUnitPattern = /((?:(?:\\[[^\\]+]\\])|(?:[^\\s\\+\\>\\~:]))+)((?::[^\\s\\+\\>\\~\\(]+(?:\\([^\\)]+\\))?)?\\s*[\\s\\+\\>\\~]?)\\s*/g,\n      mediaQueryPattern = /^@media/,\n      dataRvcGuidPattern = /\\[data-ractive-css~="\\{[a-z0-9-]+\\}"]/g;\n  function transformCss(css, id) {\n  	var transformed, dataAttr, addGuid;\n\n  	dataAttr = "[data-ractive-css~=\\"{" + id + "}\\"]";\n\n  	addGuid = function (selector) {\n  		var selectorUnits,\n  		    match,\n  		    unit,\n  		    base,\n  		    prepended,\n  		    appended,\n  		    i,\n  		    transformed = [];\n\n  		selectorUnits = [];\n\n  		while (match = selectorUnitPattern.exec(selector)) {\n  			selectorUnits.push({\n  				str: match[0],\n  				base: match[1],\n  				modifiers: match[2]\n  			});\n  		}\n\n  		// For each simple selector within the selector, we need to create a version\n  		// that a) combines with the id, and b) is inside the id\n  		base = selectorUnits.map(extractString);\n\n  		i = selectorUnits.length;\n  		while (i--) {\n  			appended = base.slice();\n\n  			// Pseudo-selectors should go after the attribute selector\n  			unit = selectorUnits[i];\n  			appended[i] = unit.base + dataAttr + unit.modifiers || "";\n\n  			prepended = base.slice();\n  			prepended[i] = dataAttr + " " + prepended[i];\n\n  			transformed.push(appended.join(" "), prepended.join(" "));\n  		}\n\n  		return transformed.join(", ");\n  	};\n\n  	if (dataRvcGuidPattern.test(css)) {\n  		transformed = css.replace(dataRvcGuidPattern, dataAttr);\n  	} else {\n  		transformed = css.replace(commentsPattern, "").replace(selectorsPattern, function (match, $1) {\n  			var selectors, transformed;\n\n  			// don\'t transform media queries!\n  			if (mediaQueryPattern.test($1)) return match;\n\n  			selectors = $1.split(",").map(trim);\n  			transformed = selectors.map(addGuid).join(", ") + " ";\n\n  			return match.replace($1, transformed);\n  		});\n  	}\n\n  	return transformed;\n  }\n\n  function trim(str) {\n  	if (str.trim) {\n  		return str.trim();\n  	}\n\n  	return str.replace(/^\\s+/, "").replace(/\\s+$/, "");\n  }\n\n  function extractString(unit) {\n  	return unit.str;\n  }\n\n  var css_css__uid = 1;\n\n  var cssConfigurator = {\n  	name: "css",\n\n  	extend: function (Parent, proto, options) {\n  		if (options.css) {\n  			var id = css_css__uid++;\n  			var styles = options.noCssTransform ? options.css : transform(options.css, id);\n\n  			proto.cssId = id;\n  			global_css.add({ id: id, styles: styles });\n  		}\n  	},\n\n  	init: function () {}\n  };\n\n  var css_css = cssConfigurator;\n\n  function validate(data) {\n  	// Warn if userOptions.data is a non-POJO\n  	if (data && data.constructor !== Object) {\n  		if (typeof data === "function") {} else if (typeof data !== "object") {\n  			fatal("data option must be an object or a function, `" + data + "` is not valid");\n  		} else {\n  			warnIfDebug("If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged");\n  		}\n  	}\n  }\n\n  var dataConfigurator = {\n  	name: "data",\n\n  	extend: function (Parent, proto, options) {\n  		var key = undefined,\n  		    value = undefined;\n\n  		// check for non-primitives, which could cause mutation-related bugs\n  		if (options.data && isObject(options.data)) {\n  			for (key in options.data) {\n  				value = options.data[key];\n\n  				if (value && typeof value === "object") {\n  					if (isObject(value) || isArray(value)) {\n  						warnIfDebug("Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\\n\\n  // this...\\n  data: function () {\\n    return {\\n      myObject: {}\\n    };\\n  })\\n\\n  // instead of this:\\n  data: {\\n    myObject: {}\\n  }");\n  					}\n  				}\n  			}\n  		}\n\n  		proto.data = custom_data__combine(proto.data, options.data);\n  	},\n\n  	init: function (Parent, ractive, options) {\n  		var result = custom_data__combine(Parent.prototype.data, options.data);\n\n  		if (typeof result === "function") {\n  			result = result.call(ractive);\n  		}\n\n  		return result || {};\n  	},\n\n  	reset: function (ractive) {\n  		var result = this.init(ractive.constructor, ractive, ractive.viewmodel);\n\n  		ractive.viewmodel.reset(result);\n  		return true;\n  	}\n  };\n\n  var custom_data = dataConfigurator;\n\n  function custom_data__combine(parentValue, childValue) {\n  	validate(childValue);\n\n  	var parentIsFn = typeof parentValue === "function";\n  	var childIsFn = typeof childValue === "function";\n\n  	// Very important, otherwise child instance can become\n  	// the default data object on Ractive or a component.\n  	// then ractive.set() ends up setting on the prototype!\n  	if (!childValue && !parentIsFn) {\n  		childValue = {};\n  	}\n\n  	// Fast path, where we just need to copy properties from\n  	// parent to child\n  	if (!parentIsFn && !childIsFn) {\n  		return fromProperties(childValue, parentValue);\n  	}\n\n  	return function () {\n  		var child = childIsFn ? callDataFunction(childValue, this) : childValue;\n  		var parent = parentIsFn ? callDataFunction(parentValue, this) : parentValue;\n\n  		return fromProperties(child, parent);\n  	};\n  }\n\n  function callDataFunction(fn, context) {\n  	var data = fn.call(context);\n\n  	if (!data) return;\n\n  	if (typeof data !== "object") {\n  		fatal("Data function must return an object");\n  	}\n\n  	if (data.constructor !== Object) {\n  		warnOnceIfDebug("Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged");\n  	}\n\n  	return data;\n  }\n\n  function fromProperties(primary, secondary) {\n  	if (primary && secondary) {\n  		for (var key in secondary) {\n  			if (!(key in primary)) {\n  				primary[key] = secondary[key];\n  			}\n  		}\n\n  		return primary;\n  	}\n\n  	return primary || secondary;\n  }\n\n  // TODO do we need to support this in the new Ractive() case?\n\n  var Parser,\n      ParseError,\n      parse_Parser__leadingWhitespace = /^\\s+/;\n\n  ParseError = function (message) {\n  	this.name = "ParseError";\n  	this.message = message;\n  	try {\n  		throw new Error(message);\n  	} catch (e) {\n  		this.stack = e.stack;\n  	}\n  };\n\n  ParseError.prototype = Error.prototype;\n\n  Parser = function (str, options) {\n  	var items,\n  	    item,\n  	    lineStart = 0;\n\n  	this.str = str;\n  	this.options = options || {};\n  	this.pos = 0;\n\n  	this.lines = this.str.split("\\n");\n  	this.lineEnds = this.lines.map(function (line) {\n  		var lineEnd = lineStart + line.length + 1; // +1 for the newline\n\n  		lineStart = lineEnd;\n  		return lineEnd;\n  	}, 0);\n\n  	// Custom init logic\n  	if (this.init) this.init(str, options);\n\n  	items = [];\n\n  	while (this.pos < this.str.length && (item = this.read())) {\n  		items.push(item);\n  	}\n\n  	this.leftover = this.remaining();\n  	this.result = this.postProcess ? this.postProcess(items, options) : items;\n  };\n\n  Parser.prototype = {\n  	read: function (converters) {\n  		var pos, i, len, item;\n\n  		if (!converters) converters = this.converters;\n\n  		pos = this.pos;\n\n  		len = converters.length;\n  		for (i = 0; i < len; i += 1) {\n  			this.pos = pos; // reset for each attempt\n\n  			if (item = converters[i](this)) {\n  				return item;\n  			}\n  		}\n\n  		return null;\n  	},\n\n  	getLinePos: function (char) {\n  		var lineNum = 0,\n  		    lineStart = 0,\n  		    columnNum;\n\n  		while (char >= this.lineEnds[lineNum]) {\n  			lineStart = this.lineEnds[lineNum];\n  			lineNum += 1;\n  		}\n\n  		columnNum = char - lineStart;\n  		return [lineNum + 1, columnNum + 1, char]; // line/col should be one-based, not zero-based!\n  	},\n\n  	error: function (message) {\n  		var pos = this.getLinePos(this.pos);\n  		var lineNum = pos[0];\n  		var columnNum = pos[1];\n\n  		var line = this.lines[pos[0] - 1];\n  		var numTabs = 0;\n  		var annotation = line.replace(/\\t/g, function (match, char) {\n  			if (char < pos[1]) {\n  				numTabs += 1;\n  			}\n\n  			return "  ";\n  		}) + "\\n" + new Array(pos[1] + numTabs).join(" ") + "^----";\n\n  		var error = new ParseError("" + message + " at line " + lineNum + " character " + columnNum + ":\\n" + annotation);\n\n  		error.line = pos[0];\n  		error.character = pos[1];\n  		error.shortMessage = message;\n\n  		throw error;\n  	},\n\n  	matchString: function (string) {\n  		if (this.str.substr(this.pos, string.length) === string) {\n  			this.pos += string.length;\n  			return string;\n  		}\n  	},\n\n  	matchPattern: function (pattern) {\n  		var match;\n\n  		if (match = pattern.exec(this.remaining())) {\n  			this.pos += match[0].length;\n  			return match[1] || match[0];\n  		}\n  	},\n\n  	allowWhitespace: function () {\n  		this.matchPattern(parse_Parser__leadingWhitespace);\n  	},\n\n  	remaining: function () {\n  		return this.str.substring(this.pos);\n  	},\n\n  	nextChar: function () {\n  		return this.str.charAt(this.pos);\n  	}\n  };\n\n  Parser.extend = function (proto) {\n  	var Parent = this,\n  	    Child,\n  	    key;\n\n  	Child = function (str, options) {\n  		Parser.call(this, str, options);\n  	};\n\n  	Child.prototype = create(Parent.prototype);\n\n  	for (key in proto) {\n  		if (hasOwn.call(proto, key)) {\n  			Child.prototype[key] = proto[key];\n  		}\n  	}\n\n  	Child.extend = Parser.extend;\n  	return Child;\n  };\n\n  var parse_Parser = Parser;\n\n  var TEXT = 1;\n  var INTERPOLATOR = 2;\n  var TRIPLE = 3;\n  var SECTION = 4;\n  var INVERTED = 5;\n  var CLOSING = 6;\n  var ELEMENT = 7;\n  var PARTIAL = 8;\n  var COMMENT = 9;\n  var DELIMCHANGE = 10;\n  var ATTRIBUTE = 13;\n  var CLOSING_TAG = 14;\n  var COMPONENT = 15;\n  var YIELDER = 16;\n  var INLINE_PARTIAL = 17;\n  var DOCTYPE = 18;\n\n  var NUMBER_LITERAL = 20;\n  var STRING_LITERAL = 21;\n  var ARRAY_LITERAL = 22;\n  var OBJECT_LITERAL = 23;\n  var BOOLEAN_LITERAL = 24;\n  var REGEXP_LITERAL = 25;\n\n  var GLOBAL = 26;\n  var KEY_VALUE_PAIR = 27;\n\n  var REFERENCE = 30;\n  var REFINEMENT = 31;\n  var MEMBER = 32;\n  var PREFIX_OPERATOR = 33;\n  var BRACKETED = 34;\n  var CONDITIONAL = 35;\n  var INFIX_OPERATOR = 36;\n\n  var INVOCATION = 40;\n\n  var SECTION_IF = 50;\n  var SECTION_UNLESS = 51;\n  var SECTION_EACH = 52;\n  var SECTION_WITH = 53;\n  var SECTION_IF_WITH = 54;\n\n  var ELSE = 60;\n  var ELSEIF = 61;\n\n  var mustache_readDelimiterChange = readDelimiterChange;\n  var delimiterChangePattern = /^[^\\s=]+/,\n      whitespacePattern = /^\\s+/;\n  function readDelimiterChange(parser) {\n  	var start, opening, closing;\n\n  	if (!parser.matchString("=")) {\n  		return null;\n  	}\n\n  	start = parser.pos;\n\n  	// allow whitespace before new opening delimiter\n  	parser.allowWhitespace();\n\n  	opening = parser.matchPattern(delimiterChangePattern);\n  	if (!opening) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	// allow whitespace (in fact, it\'s necessary...)\n  	if (!parser.matchPattern(whitespacePattern)) {\n  		return null;\n  	}\n\n  	closing = parser.matchPattern(delimiterChangePattern);\n  	if (!closing) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	// allow whitespace before closing \'=\'\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("=")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	return [opening, closing];\n  }\n\n  var readRegexpLiteral = readRegexpLiteral__readNumberLiteral;\n  var regexpPattern = /^(\\/(?:[^\\n\\r\\u2028\\u2029/\\\\[]|\\\\.|\\[(?:[^\\n\\r\\u2028\\u2029\\]\\\\]|\\\\.)*])+\\/(?:([gimuy])(?![a-z]*\\2))*(?![a-zA-Z_$0-9]))/;\n  function readRegexpLiteral__readNumberLiteral(parser) {\n  	var result;\n\n  	if (result = parser.matchPattern(regexpPattern)) {\n  		return {\n  			t: REGEXP_LITERAL,\n  			v: result\n  		};\n  	}\n\n  	return null;\n  }\n\n  var converters_readMustache = readMustache;\n\n  var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };\n  function readMustache(parser) {\n  	var mustache, i;\n\n  	// If we\'re inside a <script> or <style> tag, and we\'re not\n  	// interpolating, bug out\n  	if (parser.interpolate[parser.inside] === false) {\n  		return null;\n  	}\n\n  	for (i = 0; i < parser.tags.length; i += 1) {\n  		if (mustache = readMustacheOfType(parser, parser.tags[i])) {\n  			return mustache;\n  		}\n  	}\n  }\n\n  function readMustacheOfType(parser, tag) {\n  	var start, mustache, reader, i;\n\n  	start = parser.pos;\n\n  	if (parser.matchString("\\\\" + tag.open)) {\n  		if (start === 0 || parser.str[start - 1] !== "\\\\") {\n  			return tag.open;\n  		}\n  	} else if (!parser.matchString(tag.open)) {\n  		return null;\n  	}\n\n  	// delimiter change?\n  	if (mustache = mustache_readDelimiterChange(parser)) {\n  		// find closing delimiter or abort...\n  		if (!parser.matchString(tag.close)) {\n  			return null;\n  		}\n\n  		// ...then make the switch\n  		tag.open = mustache[0];\n  		tag.close = mustache[1];\n  		parser.sortMustacheTags();\n\n  		return delimiterChangeToken;\n  	}\n\n  	parser.allowWhitespace();\n\n  	// illegal section closer\n  	if (parser.matchString("/")) {\n  		parser.pos -= 1;\n  		var rewind = parser.pos;\n  		if (!readRegexpLiteral(parser)) {\n  			parser.pos = rewind - tag.close.length;\n  			parser.error("Attempted to close a section that wasn\'t open");\n  		} else {\n  			parser.pos = rewind;\n  		}\n  	}\n\n  	for (i = 0; i < tag.readers.length; i += 1) {\n  		reader = tag.readers[i];\n\n  		if (mustache = reader(parser, tag)) {\n  			if (tag.isStatic) {\n  				mustache.s = true; // TODO make this `1` instead - more compact\n  			}\n\n  			if (parser.includeLinePositions) {\n  				mustache.p = parser.getLinePos(start);\n  			}\n\n  			return mustache;\n  		}\n  	}\n\n  	parser.pos = start;\n  	return null;\n  }\n\n  var expectedExpression = "Expected a JavaScript expression";\n  var expectedParen = "Expected closing paren";\n\n  var literal_readNumberLiteral = literal_readNumberLiteral__readNumberLiteral;\n  var literal_readNumberLiteral__numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n  function literal_readNumberLiteral__readNumberLiteral(parser) {\n  	var result;\n\n  	if (result = parser.matchPattern(literal_readNumberLiteral__numberPattern)) {\n  		return {\n  			t: NUMBER_LITERAL,\n  			v: result\n  		};\n  	}\n\n  	return null;\n  }\n\n  var literal_readBooleanLiteral = readBooleanLiteral;\n  function readBooleanLiteral(parser) {\n  	var remaining = parser.remaining();\n\n  	if (remaining.substr(0, 4) === "true") {\n  		parser.pos += 4;\n  		return {\n  			t: BOOLEAN_LITERAL,\n  			v: "true"\n  		};\n  	}\n\n  	if (remaining.substr(0, 5) === "false") {\n  		parser.pos += 5;\n  		return {\n  			t: BOOLEAN_LITERAL,\n  			v: "false"\n  		};\n  	}\n\n  	return null;\n  }\n\n  var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;\n\n  // Match one or more characters until: ", \', \\, or EOL/EOF.\n  // EOL/EOF is written as (?!.) (meaning there\'s no non-newline char next).\n  stringMiddlePattern = /^(?=.)[^"\'\\\\]+?(?:(?!.)|(?=["\'\\\\]))/;\n\n  // Match one escape sequence, including the backslash.\n  escapeSequencePattern = /^\\\\(?:[\'"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\n  // Match one ES5 line continuation (backslash + line terminator).\n  lineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\n  // Helper for defining getDoubleQuotedString and getSingleQuotedString.\n  var makeQuotedStringMatcher = function (okQuote) {\n  	return function (parser) {\n  		var start, literal, done, next;\n\n  		start = parser.pos;\n  		literal = "\\"";\n  		done = false;\n\n  		while (!done) {\n  			next = parser.matchPattern(stringMiddlePattern) || parser.matchPattern(escapeSequencePattern) || parser.matchString(okQuote);\n  			if (next) {\n  				if (next === "\\"") {\n  					literal += "\\\\\\"";\n  				} else if (next === "\\\\\'") {\n  					literal += "\'";\n  				} else {\n  					literal += next;\n  				}\n  			} else {\n  				next = parser.matchPattern(lineContinuationPattern);\n  				if (next) {\n  					// convert \\(newline-like) into a \\u escape, which is allowed in JSON\n  					literal += "\\\\u" + ("000" + next.charCodeAt(1).toString(16)).slice(-4);\n  				} else {\n  					done = true;\n  				}\n  			}\n  		}\n\n  		literal += "\\"";\n\n  		// use JSON.parse to interpret escapes\n  		return JSON.parse(literal);\n  	};\n  };\n\n  var getSingleQuotedString = makeQuotedStringMatcher("\\"");\n  var getDoubleQuotedString = makeQuotedStringMatcher("\'");\n\n  var readStringLiteral = function (parser) {\n  	var start, string;\n\n  	start = parser.pos;\n\n  	if (parser.matchString("\\"")) {\n  		string = getDoubleQuotedString(parser);\n\n  		if (!parser.matchString("\\"")) {\n  			parser.pos = start;\n  			return null;\n  		}\n\n  		return {\n  			t: STRING_LITERAL,\n  			v: string\n  		};\n  	}\n\n  	if (parser.matchString("\'")) {\n  		string = getSingleQuotedString(parser);\n\n  		if (!parser.matchString("\'")) {\n  			parser.pos = start;\n  			return null;\n  		}\n\n  		return {\n  			t: STRING_LITERAL,\n  			v: string\n  		};\n  	}\n\n  	return null;\n  };\n\n  var patterns__name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;\n\n  // http://mathiasbynens.be/notes/javascript-properties\n  // can be any name, string literal, or number literal\n  var shared_readKey = readKey;\n  var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n  function readKey(parser) {\n  	var token;\n\n  	if (token = readStringLiteral(parser)) {\n  		return identifier.test(token.v) ? token.v : "\\"" + token.v.replace(/"/g, "\\\\\\"") + "\\"";\n  	}\n\n  	if (token = literal_readNumberLiteral(parser)) {\n  		return token.v;\n  	}\n\n  	if (token = parser.matchPattern(patterns__name)) {\n  		return token;\n  	}\n  }\n\n  var keyValuePair = readKeyValuePair;\n  function readKeyValuePair(parser) {\n  	var start, key, value;\n\n  	start = parser.pos;\n\n  	// allow whitespace between \'{\' and key\n  	parser.allowWhitespace();\n\n  	key = shared_readKey(parser);\n  	if (key === null) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	// allow whitespace between key and \':\'\n  	parser.allowWhitespace();\n\n  	// next character must be \':\'\n  	if (!parser.matchString(":")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	// allow whitespace between \':\' and value\n  	parser.allowWhitespace();\n\n  	// next expression must be a, well... expression\n  	value = converters_readExpression(parser);\n  	if (value === null) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	return {\n  		t: KEY_VALUE_PAIR,\n  		k: key,\n  		v: value\n  	};\n  }\n\n  var objectLiteral_keyValuePairs = readKeyValuePairs;\n  function readKeyValuePairs(parser) {\n  	var start, pairs, pair, keyValuePairs;\n\n  	start = parser.pos;\n\n  	pair = keyValuePair(parser);\n  	if (pair === null) {\n  		return null;\n  	}\n\n  	pairs = [pair];\n\n  	if (parser.matchString(",")) {\n  		keyValuePairs = readKeyValuePairs(parser);\n\n  		if (!keyValuePairs) {\n  			parser.pos = start;\n  			return null;\n  		}\n\n  		return pairs.concat(keyValuePairs);\n  	}\n\n  	return pairs;\n  }\n\n  var readObjectLiteral = function (parser) {\n  	var start, keyValuePairs;\n\n  	start = parser.pos;\n\n  	// allow whitespace\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("{")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	keyValuePairs = objectLiteral_keyValuePairs(parser);\n\n  	// allow whitespace between final value and \'}\'\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("}")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	return {\n  		t: OBJECT_LITERAL,\n  		m: keyValuePairs\n  	};\n  };\n\n  var shared_readExpressionList = readExpressionList;\n  function readExpressionList(parser) {\n  	var start, expressions, expr, next;\n\n  	start = parser.pos;\n\n  	parser.allowWhitespace();\n\n  	expr = converters_readExpression(parser);\n\n  	if (expr === null) {\n  		return null;\n  	}\n\n  	expressions = [expr];\n\n  	// allow whitespace between expression and \',\'\n  	parser.allowWhitespace();\n\n  	if (parser.matchString(",")) {\n  		next = readExpressionList(parser);\n  		if (next === null) {\n  			parser.error(expectedExpression);\n  		}\n\n  		next.forEach(append);\n  	}\n\n  	function append(expression) {\n  		expressions.push(expression);\n  	}\n\n  	return expressions;\n  }\n\n  var readArrayLiteral = function (parser) {\n  	var start, expressionList;\n\n  	start = parser.pos;\n\n  	// allow whitespace before \'[\'\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("[")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	expressionList = shared_readExpressionList(parser);\n\n  	if (!parser.matchString("]")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	return {\n  		t: ARRAY_LITERAL,\n  		m: expressionList\n  	};\n  };\n\n  var primary_readLiteral = readLiteral;\n  function readLiteral(parser) {\n  	return literal_readNumberLiteral(parser) || literal_readBooleanLiteral(parser) || readStringLiteral(parser) || readObjectLiteral(parser) || readArrayLiteral(parser) || readRegexpLiteral(parser);\n  }\n\n  var primary_readReference = readReference;\n  var prefixPattern = /^(?:~\\/|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/,\n      globals,\n      keywords;\n\n  // if a reference is a browser global, we don\'t deference it later, so it needs special treatment\n  globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)\\b/;\n\n  // keywords are not valid references, with the exception of `this`\n  keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\n  var legalReference = /^[a-zA-Z$_0-9]+(?:(?:\\.[a-zA-Z$_0-9]+)|(?:\\[[0-9]+\\]))*/;\n  var relaxedName = /^[a-zA-Z_$][-a-zA-Z_$0-9]*/;\n  function readReference(parser) {\n  	var startPos, prefix, name, global, reference, lastDotIndex;\n\n  	startPos = parser.pos;\n\n  	name = parser.matchPattern(/^@(?:keypath|index|key)/);\n\n  	if (!name) {\n  		prefix = parser.matchPattern(prefixPattern) || "";\n  		name = !prefix && parser.relaxedNames && parser.matchPattern(relaxedName) || parser.matchPattern(legalReference);\n\n  		if (!name && prefix === ".") {\n  			prefix = "";\n  			name = ".";\n  		}\n  	}\n\n  	if (!name) {\n  		return null;\n  	}\n\n  	// bug out if it\'s a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)\n  	if (!prefix && !parser.relaxedNames && keywords.test(name)) {\n  		parser.pos = startPos;\n  		return null;\n  	}\n\n  	// if this is a browser global, stop here\n  	if (!prefix && globals.test(name)) {\n  		global = globals.exec(name)[0];\n  		parser.pos = startPos + global.length;\n\n  		return {\n  			t: GLOBAL,\n  			v: global\n  		};\n  	}\n\n  	reference = (prefix || "") + normalise(name);\n\n  	if (parser.matchString("(")) {\n  		// if this is a method invocation (as opposed to a function) we need\n  		// to strip the method name from the reference combo, else the context\n  		// will be wrong\n  		lastDotIndex = reference.lastIndexOf(".");\n  		if (lastDotIndex !== -1) {\n  			reference = reference.substr(0, lastDotIndex);\n  			parser.pos = startPos + reference.length;\n  		} else {\n  			parser.pos -= 1;\n  		}\n  	}\n\n  	return {\n  		t: REFERENCE,\n  		n: reference.replace(/^this\\./, "./").replace(/^this$/, ".")\n  	};\n  }\n\n  var primary_readBracketedExpression = readBracketedExpression;\n  function readBracketedExpression(parser) {\n  	var start, expr;\n\n  	start = parser.pos;\n\n  	if (!parser.matchString("(")) {\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	expr = converters_readExpression(parser);\n  	if (!expr) {\n  		parser.error(expectedExpression);\n  	}\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString(")")) {\n  		parser.error(expectedParen);\n  	}\n\n  	return {\n  		t: BRACKETED,\n  		x: expr\n  	};\n  }\n\n  var readPrimary = function (parser) {\n  	return primary_readLiteral(parser) || primary_readReference(parser) || primary_readBracketedExpression(parser);\n  };\n\n  var shared_readRefinement = readRefinement;\n  function readRefinement(parser) {\n  	var start, name, expr;\n\n  	start = parser.pos;\n\n  	parser.allowWhitespace();\n\n  	// "." name\n  	if (parser.matchString(".")) {\n  		parser.allowWhitespace();\n\n  		if (name = parser.matchPattern(patterns__name)) {\n  			return {\n  				t: REFINEMENT,\n  				n: name\n  			};\n  		}\n\n  		parser.error("Expected a property name");\n  	}\n\n  	// "[" expression "]"\n  	if (parser.matchString("[")) {\n  		parser.allowWhitespace();\n\n  		expr = converters_readExpression(parser);\n  		if (!expr) {\n  			parser.error(expectedExpression);\n  		}\n\n  		parser.allowWhitespace();\n\n  		if (!parser.matchString("]")) {\n  			parser.error("Expected \']\'");\n  		}\n\n  		return {\n  			t: REFINEMENT,\n  			x: expr\n  		};\n  	}\n\n  	return null;\n  }\n\n  var readMemberOrInvocation = function (parser) {\n  	var current, expression, refinement, expressionList;\n\n  	expression = readPrimary(parser);\n\n  	if (!expression) {\n  		return null;\n  	}\n\n  	while (expression) {\n  		current = parser.pos;\n\n  		if (refinement = shared_readRefinement(parser)) {\n  			expression = {\n  				t: MEMBER,\n  				x: expression,\n  				r: refinement\n  			};\n  		} else if (parser.matchString("(")) {\n  			parser.allowWhitespace();\n  			expressionList = shared_readExpressionList(parser);\n\n  			parser.allowWhitespace();\n\n  			if (!parser.matchString(")")) {\n  				parser.error(expectedParen);\n  			}\n\n  			expression = {\n  				t: INVOCATION,\n  				x: expression\n  			};\n\n  			if (expressionList) {\n  				expression.o = expressionList;\n  			}\n  		} else {\n  			break;\n  		}\n  	}\n\n  	return expression;\n  };\n\n  var readTypeOf, makePrefixSequenceMatcher;\n\n  makePrefixSequenceMatcher = function (symbol, fallthrough) {\n  	return function (parser) {\n  		var expression;\n\n  		if (expression = fallthrough(parser)) {\n  			return expression;\n  		}\n\n  		if (!parser.matchString(symbol)) {\n  			return null;\n  		}\n\n  		parser.allowWhitespace();\n\n  		expression = converters_readExpression(parser);\n  		if (!expression) {\n  			parser.error(expectedExpression);\n  		}\n\n  		return {\n  			s: symbol,\n  			o: expression,\n  			t: PREFIX_OPERATOR\n  		};\n  	};\n  };\n\n  // create all prefix sequence matchers, return readTypeOf\n  (function () {\n  	var i, len, matcher, prefixOperators, fallthrough;\n\n  	prefixOperators = "! ~ + - typeof".split(" ");\n\n  	fallthrough = readMemberOrInvocation;\n  	for (i = 0, len = prefixOperators.length; i < len; i += 1) {\n  		matcher = makePrefixSequenceMatcher(prefixOperators[i], fallthrough);\n  		fallthrough = matcher;\n  	}\n\n  	// typeof operator is higher precedence than multiplication, so provides the\n  	// fallthrough for the multiplication sequence matcher we\'re about to create\n  	// (we\'re skipping void and delete)\n  	readTypeOf = fallthrough;\n  })();\n\n  var readTypeof = readTypeOf;\n\n  var readLogicalOr, makeInfixSequenceMatcher;\n\n  makeInfixSequenceMatcher = function (symbol, fallthrough) {\n  	return function (parser) {\n  		var start, left, right;\n\n  		left = fallthrough(parser);\n  		if (!left) {\n  			return null;\n  		}\n\n  		// Loop to handle left-recursion in a case like `a * b * c` and produce\n  		// left association, i.e. `(a * b) * c`.  The matcher can\'t call itself\n  		// to parse `left` because that would be infinite regress.\n  		while (true) {\n  			start = parser.pos;\n\n  			parser.allowWhitespace();\n\n  			if (!parser.matchString(symbol)) {\n  				parser.pos = start;\n  				return left;\n  			}\n\n  			// special case - in operator must not be followed by [a-zA-Z_$0-9]\n  			if (symbol === "in" && /[a-zA-Z_$0-9]/.test(parser.remaining().charAt(0))) {\n  				parser.pos = start;\n  				return left;\n  			}\n\n  			parser.allowWhitespace();\n\n  			// right operand must also consist of only higher-precedence operators\n  			right = fallthrough(parser);\n  			if (!right) {\n  				parser.pos = start;\n  				return left;\n  			}\n\n  			left = {\n  				t: INFIX_OPERATOR,\n  				s: symbol,\n  				o: [left, right]\n  			};\n\n  			// Loop back around.  If we don\'t see another occurrence of the symbol,\n  			// we\'ll return left.\n  		}\n  	};\n  };\n\n  // create all infix sequence matchers, and return readLogicalOr\n  (function () {\n  	var i, len, matcher, infixOperators, fallthrough;\n\n  	// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n  	// Each sequence matcher will initially fall through to its higher precedence\n  	// neighbour, and only attempt to match if one of the higher precedence operators\n  	// (or, ultimately, a literal, reference, or bracketed expression) already matched\n  	infixOperators = "* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||".split(" ");\n\n  	// A typeof operator is higher precedence than multiplication\n  	fallthrough = readTypeof;\n  	for (i = 0, len = infixOperators.length; i < len; i += 1) {\n  		matcher = makeInfixSequenceMatcher(infixOperators[i], fallthrough);\n  		fallthrough = matcher;\n  	}\n\n  	// Logical OR is the fallthrough for the conditional matcher\n  	readLogicalOr = fallthrough;\n  })();\n\n  var expressions_readLogicalOr = readLogicalOr;\n\n  // The conditional operator is the lowest precedence operator, so we start here\n  var readConditional = getConditional;\n  function getConditional(parser) {\n  	var start, expression, ifTrue, ifFalse;\n\n  	expression = expressions_readLogicalOr(parser);\n  	if (!expression) {\n  		return null;\n  	}\n\n  	start = parser.pos;\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("?")) {\n  		parser.pos = start;\n  		return expression;\n  	}\n\n  	parser.allowWhitespace();\n\n  	ifTrue = converters_readExpression(parser);\n  	if (!ifTrue) {\n  		parser.error(expectedExpression);\n  	}\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString(":")) {\n  		parser.error("Expected \\":\\"");\n  	}\n\n  	parser.allowWhitespace();\n\n  	ifFalse = converters_readExpression(parser);\n  	if (!ifFalse) {\n  		parser.error(expectedExpression);\n  	}\n\n  	return {\n  		t: CONDITIONAL,\n  		o: [expression, ifTrue, ifFalse]\n  	};\n  }\n\n  var converters_readExpression = readExpression;\n  function readExpression(parser) {\n  	// The conditional operator is the lowest precedence operator (except yield,\n  	// assignment operators, and commas, none of which are supported), so we\n  	// start there. If it doesn\'t match, it \'falls through\' to progressively\n  	// higher precedence operators, until it eventually matches (or fails to\n  	// match) a \'primary\' - a literal or a reference. This way, the abstract syntax\n  	// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n  	return readConditional(parser);\n  }\n\n  var utils_flattenExpression = flattenExpression;\n\n  function flattenExpression(expression) {\n  	var refs;\n\n  	extractRefs(expression, refs = []);\n\n  	return {\n  		r: refs,\n  		s: stringify(expression)\n  	};\n\n  	function stringify(node) {\n  		switch (node.t) {\n  			case BOOLEAN_LITERAL:\n  			case GLOBAL:\n  			case NUMBER_LITERAL:\n  			case REGEXP_LITERAL:\n  				return node.v;\n\n  			case STRING_LITERAL:\n  				return JSON.stringify(String(node.v));\n\n  			case ARRAY_LITERAL:\n  				return "[" + (node.m ? node.m.map(stringify).join(",") : "") + "]";\n\n  			case OBJECT_LITERAL:\n  				return "{" + (node.m ? node.m.map(stringify).join(",") : "") + "}";\n\n  			case KEY_VALUE_PAIR:\n  				return node.k + ":" + stringify(node.v);\n\n  			case PREFIX_OPERATOR:\n  				return (node.s === "typeof" ? "typeof " : node.s) + stringify(node.o);\n\n  			case INFIX_OPERATOR:\n  				return stringify(node.o[0]) + (node.s.substr(0, 2) === "in" ? " " + node.s + " " : node.s) + stringify(node.o[1]);\n\n  			case INVOCATION:\n  				return stringify(node.x) + "(" + (node.o ? node.o.map(stringify).join(",") : "") + ")";\n\n  			case BRACKETED:\n  				return "(" + stringify(node.x) + ")";\n\n  			case MEMBER:\n  				return stringify(node.x) + stringify(node.r);\n\n  			case REFINEMENT:\n  				return node.n ? "." + node.n : "[" + stringify(node.x) + "]";\n\n  			case CONDITIONAL:\n  				return stringify(node.o[0]) + "?" + stringify(node.o[1]) + ":" + stringify(node.o[2]);\n\n  			case REFERENCE:\n  				return "_" + refs.indexOf(node.n);\n\n  			default:\n  				throw new Error("Expected legal JavaScript");\n  		}\n  	}\n  }\n\n  // TODO maybe refactor this?\n  function extractRefs(node, refs) {\n  	var i, list;\n\n  	if (node.t === REFERENCE) {\n  		if (refs.indexOf(node.n) === -1) {\n  			refs.unshift(node.n);\n  		}\n  	}\n\n  	list = node.o || node.m;\n  	if (list) {\n  		if (isObject(list)) {\n  			extractRefs(list, refs);\n  		} else {\n  			i = list.length;\n  			while (i--) {\n  				extractRefs(list[i], refs);\n  			}\n  		}\n  	}\n\n  	if (node.x) {\n  		extractRefs(node.x, refs);\n  	}\n\n  	if (node.r) {\n  		extractRefs(node.r, refs);\n  	}\n\n  	if (node.v) {\n  		extractRefs(node.v, refs);\n  	}\n  }\n\n  var utils_refineExpression = refineExpression;\n\n  var arrayMemberPattern = /^[0-9][1-9]*$/;\n  function refineExpression(expression, mustache) {\n  	var referenceExpression;\n\n  	if (expression) {\n  		while (expression.t === BRACKETED && expression.x) {\n  			expression = expression.x;\n  		}\n\n  		// special case - integers should be treated as array members references,\n  		// rather than as expressions in their own right\n  		if (expression.t === REFERENCE) {\n  			mustache.r = expression.n;\n  		} else {\n  			if (expression.t === NUMBER_LITERAL && arrayMemberPattern.test(expression.v)) {\n  				mustache.r = expression.v;\n  			} else if (referenceExpression = getReferenceExpression(expression)) {\n  				mustache.rx = referenceExpression;\n  			} else {\n  				mustache.x = utils_flattenExpression(expression);\n  			}\n  		}\n\n  		return mustache;\n  	}\n  }\n\n  // TODO refactor this! it\'s bewildering\n  function getReferenceExpression(expression) {\n  	var members = [],\n  	    refinement;\n\n  	while (expression.t === MEMBER && expression.r.t === REFINEMENT) {\n  		refinement = expression.r;\n\n  		if (refinement.x) {\n  			if (refinement.x.t === REFERENCE) {\n  				members.unshift(refinement.x);\n  			} else {\n  				members.unshift(utils_flattenExpression(refinement.x));\n  			}\n  		} else {\n  			members.unshift(refinement.n);\n  		}\n\n  		expression = expression.x;\n  	}\n\n  	if (expression.t !== REFERENCE) {\n  		return null;\n  	}\n\n  	return {\n  		r: expression.n,\n  		m: members\n  	};\n  }\n\n  var mustache_readTriple = readTriple;\n  function readTriple(parser, tag) {\n  	var expression = converters_readExpression(parser),\n  	    triple;\n\n  	if (!expression) {\n  		return null;\n  	}\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	triple = { t: TRIPLE };\n  	utils_refineExpression(expression, triple); // TODO handle this differently - it\'s mysterious\n\n  	return triple;\n  }\n\n  var mustache_readUnescaped = readUnescaped;\n  function readUnescaped(parser, tag) {\n  	var expression, triple;\n\n  	if (!parser.matchString("&")) {\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	expression = converters_readExpression(parser);\n\n  	if (!expression) {\n  		return null;\n  	}\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	triple = { t: TRIPLE };\n  	utils_refineExpression(expression, triple); // TODO handle this differently - it\'s mysterious\n\n  	return triple;\n  }\n\n  var mustache_readPartial = readPartial;\n  function readPartial(parser, tag) {\n  	var start, nameStart, expression, context, partial;\n\n  	start = parser.pos;\n\n  	if (!parser.matchString(">")) {\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n  	nameStart = parser.pos;\n\n  	// Partial names can include hyphens, so we can\'t use readExpression\n  	// blindly. Instead, we use the `relaxedNames` flag to indicate that\n  	// `foo-bar` should be read as a single name, rather than \'subtract\n  	// bar from foo\'\n  	parser.relaxedNames = true;\n  	expression = converters_readExpression(parser);\n  	parser.relaxedNames = false;\n\n  	parser.allowWhitespace();\n  	context = converters_readExpression(parser);\n  	parser.allowWhitespace();\n\n  	if (!expression) {\n  		return null;\n  	}\n\n  	partial = { t: PARTIAL };\n  	utils_refineExpression(expression, partial); // TODO...\n\n  	parser.allowWhitespace();\n\n  	// if we have another expression - e.g. `{{>foo bar}}` - then\n  	// we turn it into `{{#with bar}}{{>foo}}{{/with}}`\n  	if (context) {\n  		partial = {\n  			t: SECTION,\n  			n: SECTION_WITH,\n  			f: [partial]\n  		};\n\n  		utils_refineExpression(context, partial);\n  	}\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	return partial;\n  }\n\n  var readMustacheComment = readComment;\n  function readComment(parser, tag) {\n  	var index;\n\n  	if (!parser.matchString("!")) {\n  		return null;\n  	}\n\n  	index = parser.remaining().indexOf(tag.close);\n\n  	if (index !== -1) {\n  		parser.pos += index + tag.close.length;\n  		return { t: COMMENT };\n  	}\n  }\n\n  var converters_readExpressionOrReference = readExpressionOrReference;\n  function readExpressionOrReference(parser, expectedFollowers) {\n  	var start, expression, i;\n\n  	start = parser.pos;\n  	expression = converters_readExpression(parser);\n\n  	if (!expression) {\n  		return null;\n  	}\n\n  	for (i = 0; i < expectedFollowers.length; i += 1) {\n  		if (parser.remaining().substr(0, expectedFollowers[i].length) === expectedFollowers[i]) {\n  			return expression;\n  		}\n  	}\n\n  	parser.pos = start;\n  	return primary_readReference(parser);\n  }\n\n  var mustache_readInterpolator = readInterpolator;\n  function readInterpolator(parser, tag) {\n  	var start, expression, interpolator, err;\n\n  	start = parser.pos;\n\n  	// TODO would be good for perf if we could do away with the try-catch\n  	try {\n  		expression = converters_readExpressionOrReference(parser, [tag.close]);\n  	} catch (e) {\n  		err = e;\n  	}\n\n  	if (!expression) {\n  		if (parser.str.charAt(start) === "!") {\n  			// special case - comment\n  			parser.pos = start;\n  			return null;\n  		}\n\n  		if (err) {\n  			throw err;\n  		}\n  	}\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\' after reference");\n\n  		if (!expression) {\n  			// special case - comment\n  			if (parser.nextChar() === "!") {\n  				return null;\n  			}\n\n  			parser.error("Expected expression or legal reference");\n  		}\n  	}\n\n  	interpolator = { t: INTERPOLATOR };\n  	utils_refineExpression(expression, interpolator); // TODO handle this differently - it\'s mysterious\n\n  	return interpolator;\n  }\n\n  var mustache_readYielder = readYielder;\n  var yieldPattern = /^yield\\s*/;\n  function readYielder(parser, tag) {\n  	var start, name, yielder;\n\n  	if (!parser.matchPattern(yieldPattern)) {\n  		return null;\n  	}\n\n  	start = parser.pos;\n  	name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/);\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("expected legal partial name");\n  	}\n\n  	yielder = { t: YIELDER };\n\n  	if (name) {\n  		yielder.n = name;\n  	}\n\n  	return yielder;\n  }\n\n  var section_readClosing = readClosing;\n  function readClosing(parser, tag) {\n  	var start, remaining, index, closing;\n\n  	start = parser.pos;\n\n  	if (!parser.matchString(tag.open)) {\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("/")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	remaining = parser.remaining();\n  	index = remaining.indexOf(tag.close);\n\n  	if (index !== -1) {\n  		closing = {\n  			t: CLOSING,\n  			r: remaining.substr(0, index).split(" ")[0]\n  		};\n\n  		parser.pos += index;\n\n  		if (!parser.matchString(tag.close)) {\n  			parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  		}\n\n  		return closing;\n  	}\n\n  	parser.pos = start;\n  	return null;\n  }\n\n  var section_readElse = section_readElse__readElse;\n  var section_readElse__elsePattern = /^\\s*else\\s*/;\n  function section_readElse__readElse(parser, tag) {\n  	var start = parser.pos;\n\n  	if (!parser.matchString(tag.open)) {\n  		return null;\n  	}\n\n  	if (!parser.matchPattern(section_readElse__elsePattern)) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	return {\n  		t: ELSE\n  	};\n  }\n\n  var readElseIf = readElseIf__readElse;\n  var readElseIf__elsePattern = /^\\s*elseif\\s+/;\n  function readElseIf__readElse(parser, tag) {\n  	var start = parser.pos,\n  	    expression;\n\n  	if (!parser.matchString(tag.open)) {\n  		return null;\n  	}\n\n  	if (!parser.matchPattern(readElseIf__elsePattern)) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	expression = converters_readExpression(parser);\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	return {\n  		t: ELSEIF,\n  		x: expression\n  	};\n  }\n\n  var handlebarsBlockCodes = {\n  	each: SECTION_EACH,\n  	"if": SECTION_IF,\n  	"if-with": SECTION_IF_WITH,\n  	"with": SECTION_WITH,\n  	unless: SECTION_UNLESS\n  };\n\n  var mustache_readSection = readSection;\n\n  var indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n      keyIndexRefPattern = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n      handlebarsBlockPattern = new RegExp("^(" + Object.keys(handlebarsBlockCodes).join("|") + ")\\\\b");\n  function readSection(parser, tag) {\n  	var start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose;\n\n  	start = parser.pos;\n\n  	if (parser.matchString("^")) {\n  		section = { t: SECTION, f: [], n: SECTION_UNLESS };\n  	} else if (parser.matchString("#")) {\n  		section = { t: SECTION, f: [] };\n\n  		if (parser.matchString("partial")) {\n  			parser.pos = start - parser.standardDelimiters[0].length;\n  			parser.error("Partial definitions can only be at the top level of the template, or immediately inside components");\n  		}\n\n  		if (block = parser.matchPattern(handlebarsBlockPattern)) {\n  			expectedClose = block;\n  			section.n = handlebarsBlockCodes[block];\n  		}\n  	} else {\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	expression = converters_readExpression(parser);\n\n  	if (!expression) {\n  		parser.error("Expected expression");\n  	}\n\n  	// optional index and key references\n  	if (i = parser.matchPattern(indexRefPattern)) {\n  		var extra = undefined;\n\n  		if (extra = parser.matchPattern(keyIndexRefPattern)) {\n  			section.i = i + "," + extra;\n  		} else {\n  			section.i = i;\n  		}\n  	}\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	parser.sectionDepth += 1;\n  	children = section.f;\n\n  	conditions = [];\n\n  	do {\n  		if (child = section_readClosing(parser, tag)) {\n  			if (expectedClose && child.r !== expectedClose) {\n  				parser.error("Expected " + tag.open + "/" + expectedClose + "" + tag.close);\n  			}\n\n  			parser.sectionDepth -= 1;\n  			closed = true;\n  		} else if (child = readElseIf(parser, tag)) {\n  			if (section.n === SECTION_UNLESS) {\n  				parser.error("{{else}} not allowed in {{#unless}}");\n  			}\n\n  			if (hasElse) {\n  				parser.error("illegal {{elseif...}} after {{else}}");\n  			}\n\n  			if (!unlessBlock) {\n  				unlessBlock = createUnlessBlock(expression, section.n);\n  			}\n\n  			unlessBlock.f.push({\n  				t: SECTION,\n  				n: SECTION_IF,\n  				x: utils_flattenExpression(mustache_readSection__combine(conditions.concat(child.x))),\n  				f: children = []\n  			});\n\n  			conditions.push(invert(child.x));\n  		} else if (child = section_readElse(parser, tag)) {\n  			if (section.n === SECTION_UNLESS) {\n  				parser.error("{{else}} not allowed in {{#unless}}");\n  			}\n\n  			if (hasElse) {\n  				parser.error("there can only be one {{else}} block, at the end of a section");\n  			}\n\n  			hasElse = true;\n\n  			// use an unless block if there\'s no elseif\n  			if (!unlessBlock) {\n  				unlessBlock = createUnlessBlock(expression, section.n);\n  				children = unlessBlock.f;\n  			} else {\n  				unlessBlock.f.push({\n  					t: SECTION,\n  					n: SECTION_IF,\n  					x: utils_flattenExpression(mustache_readSection__combine(conditions)),\n  					f: children = []\n  				});\n  			}\n  		} else {\n  			child = parser.read(READERS);\n\n  			if (!child) {\n  				break;\n  			}\n\n  			children.push(child);\n  		}\n  	} while (!closed);\n\n  	if (unlessBlock) {\n  		// special case - `with` should become `if-with` (TODO is this right?\n  		// seems to me that `with` ought to behave consistently, regardless\n  		// of the presence/absence of `else`. In other words should always\n  		// be `if-with`\n  		if (section.n === SECTION_WITH) {\n  			section.n = SECTION_IF_WITH;\n  		}\n\n  		section.l = unlessBlock;\n  	}\n\n  	utils_refineExpression(expression, section);\n\n  	// TODO if a section is empty it should be discarded. Don\'t do\n  	// that here though - we need to clean everything up first, as\n  	// it may contain removeable whitespace. As a temporary measure,\n  	// to pass the existing tests, remove empty `f` arrays\n  	if (!section.f.length) {\n  		delete section.f;\n  	}\n\n  	return section;\n  }\n\n  function createUnlessBlock(expression, sectionType) {\n  	var unlessBlock;\n\n  	if (sectionType === SECTION_WITH) {\n  		// special case - a `{{#with foo}}` section will render if `foo` is\n  		// truthy, so the `{{else}}` section needs to render if `foo` is falsy,\n  		// rather than adhering to the normal `{{#unless foo}}` logic (which\n  		// treats empty arrays/objects as falsy)\n  		unlessBlock = {\n  			t: SECTION,\n  			n: SECTION_IF,\n  			f: []\n  		};\n\n  		utils_refineExpression(invert(expression), unlessBlock);\n  	} else {\n  		unlessBlock = {\n  			t: SECTION,\n  			n: SECTION_UNLESS,\n  			f: []\n  		};\n\n  		utils_refineExpression(expression, unlessBlock);\n  	}\n\n  	return unlessBlock;\n  }\n\n  function invert(expression) {\n  	if (expression.t === PREFIX_OPERATOR && expression.s === "!") {\n  		return expression.o;\n  	}\n\n  	return {\n  		t: PREFIX_OPERATOR,\n  		s: "!",\n  		o: parensIfNecessary(expression)\n  	};\n  }\n\n  function mustache_readSection__combine(expressions) {\n  	if (expressions.length === 1) {\n  		return expressions[0];\n  	}\n\n  	return {\n  		t: INFIX_OPERATOR,\n  		s: "&&",\n  		o: [parensIfNecessary(expressions[0]), parensIfNecessary(mustache_readSection__combine(expressions.slice(1)))]\n  	};\n  }\n\n  function parensIfNecessary(expression) {\n  	// TODO only wrap if necessary\n  	return {\n  		t: BRACKETED,\n  		x: expression\n  	};\n  }\n\n  var converters_readHtmlComment = readHtmlComment;\n  var OPEN_COMMENT = "<!--",\n      CLOSE_COMMENT = "-->";\n  function readHtmlComment(parser) {\n  	var start, content, remaining, endIndex, comment;\n\n  	start = parser.pos;\n\n  	if (!parser.matchString(OPEN_COMMENT)) {\n  		return null;\n  	}\n\n  	remaining = parser.remaining();\n  	endIndex = remaining.indexOf(CLOSE_COMMENT);\n\n  	if (endIndex === -1) {\n  		parser.error("Illegal HTML - expected closing comment sequence (\'-->\')");\n  	}\n\n  	content = remaining.substr(0, endIndex);\n  	parser.pos += endIndex + 3;\n\n  	comment = {\n  		t: COMMENT,\n  		c: content\n  	};\n\n  	if (parser.includeLinePositions) {\n  		comment.p = parser.getLinePos(start);\n  	}\n\n  	return comment;\n  }\n\n  var booleanAttributes, voidElementNames, htmlEntities, controlCharacters, entityPattern, lessThan, greaterThan, amp;\n\n  // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n  booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\n  voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\n\n  htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 };\n  controlCharacters = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376];\n  entityPattern = new RegExp("&(#?(?:x[\\\\w\\\\d]+|\\\\d+|" + Object.keys(htmlEntities).join("|") + "));?", "g");\n\n  function decodeCharacterReferences(html) {\n  	return html.replace(entityPattern, function (match, entity) {\n  		var code;\n\n  		// Handle named entities\n  		if (entity[0] !== "#") {\n  			code = htmlEntities[entity];\n  		} else if (entity[1] === "x") {\n  			code = parseInt(entity.substring(2), 16);\n  		} else {\n  			code = parseInt(entity.substring(1), 10);\n  		}\n\n  		if (!code) {\n  			return match;\n  		}\n\n  		return String.fromCharCode(validateCode(code));\n  	});\n  }\n\n  // some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n  // code points with alternatives in some cases - since we\'re bypassing that mechanism, we need\n  // to replace them ourselves\n  //\n  // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n  function validateCode(code) {\n  	if (!code) {\n  		return 65533;\n  	}\n\n  	// line feed becomes generic whitespace\n  	if (code === 10) {\n  		return 32;\n  	}\n\n  	// ASCII range. (Why someone would use HTML entities for ASCII characters I don\'t know, but...)\n  	if (code < 128) {\n  		return code;\n  	}\n\n  	// code points 128-159 are dealt with leniently by browsers, but they\'re incorrect. We need\n  	// to correct the mistake or we\'ll end up with missing € signs and so on\n  	if (code <= 159) {\n  		return controlCharacters[code - 128];\n  	}\n\n  	// basic multilingual plane\n  	if (code < 55296) {\n  		return code;\n  	}\n\n  	// UTF-16 surrogate halves\n  	if (code <= 57343) {\n  		return 65533;\n  	}\n\n  	// rest of the basic multilingual plane\n  	if (code <= 65535) {\n  		return code;\n  	}\n\n  	return 65533;\n  }\n\n  lessThan = /</g;\n  greaterThan = />/g;\n  amp = /&/g;\n\n  function escapeHtml(str) {\n  	return str.replace(amp, "&amp;").replace(lessThan, "&lt;").replace(greaterThan, "&gt;");\n  }\n\n  var leadingLinebreak = /^\\s*\\r?\\n/,\n      trailingLinebreak = /\\r?\\n\\s*$/;\n\n  var stripStandalones = function (items) {\n  	var i, current, backOne, backTwo, lastSectionItem;\n\n  	for (i = 1; i < items.length; i += 1) {\n  		current = items[i];\n  		backOne = items[i - 1];\n  		backTwo = items[i - 2];\n\n  		// if we\'re at the end of a [text][comment][text] sequence...\n  		if (isString(current) && isComment(backOne) && isString(backTwo)) {\n\n  			// ... and the comment is a standalone (i.e. line breaks either side)...\n  			if (trailingLinebreak.test(backTwo) && leadingLinebreak.test(current)) {\n\n  				// ... then we want to remove the whitespace after the first line break\n  				items[i - 2] = backTwo.replace(trailingLinebreak, "\\n");\n\n  				// and the leading line break of the second text token\n  				items[i] = current.replace(leadingLinebreak, "");\n  			}\n  		}\n\n  		// if the current item is a section, and it is preceded by a linebreak, and\n  		// its first item is a linebreak...\n  		if (isSection(current) && isString(backOne)) {\n  			if (trailingLinebreak.test(backOne) && isString(current.f[0]) && leadingLinebreak.test(current.f[0])) {\n  				items[i - 1] = backOne.replace(trailingLinebreak, "\\n");\n  				current.f[0] = current.f[0].replace(leadingLinebreak, "");\n  			}\n  		}\n\n  		// if the last item was a section, and it is followed by a linebreak, and\n  		// its last item is a linebreak...\n  		if (isString(current) && isSection(backOne)) {\n  			lastSectionItem = lastItem(backOne.f);\n\n  			if (isString(lastSectionItem) && trailingLinebreak.test(lastSectionItem) && leadingLinebreak.test(current)) {\n  				backOne.f[backOne.f.length - 1] = lastSectionItem.replace(trailingLinebreak, "\\n");\n  				items[i] = current.replace(leadingLinebreak, "");\n  			}\n  		}\n  	}\n\n  	return items;\n  };\n\n  function isString(item) {\n  	return typeof item === "string";\n  }\n\n  function isComment(item) {\n  	return item.t === COMMENT || item.t === DELIMCHANGE;\n  }\n\n  function isSection(item) {\n  	return (item.t === SECTION || item.t === INVERTED) && item.f;\n  }\n\n  var trimWhitespace = function (items, leadingPattern, trailingPattern) {\n  	var item;\n\n  	if (leadingPattern) {\n  		item = items[0];\n  		if (typeof item === "string") {\n  			item = item.replace(leadingPattern, "");\n\n  			if (!item) {\n  				items.shift();\n  			} else {\n  				items[0] = item;\n  			}\n  		}\n  	}\n\n  	if (trailingPattern) {\n  		item = lastItem(items);\n  		if (typeof item === "string") {\n  			item = item.replace(trailingPattern, "");\n\n  			if (!item) {\n  				items.pop();\n  			} else {\n  				items[items.length - 1] = item;\n  			}\n  		}\n  	}\n  };\n\n  var utils_cleanup = cleanup;\n  var contiguousWhitespace = /[ \\t\\f\\r\\n]+/g;\n  var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;\n  var utils_cleanup__leadingWhitespace = /^[ \\t\\f\\r\\n]+/;\n  var trailingWhitespace = /[ \\t\\f\\r\\n]+$/;\n  var leadingNewLine = /^(?:\\r\\n|\\r|\\n)/;\n  var trailingNewLine = /(?:\\r\\n|\\r|\\n)$/;\n  function cleanup(items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace) {\n  	var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, key;\n\n  	// First pass - remove standalones and comments etc\n  	stripStandalones(items);\n\n  	i = items.length;\n  	while (i--) {\n  		item = items[i];\n\n  		// Remove delimiter changes, unsafe elements etc\n  		if (item.exclude) {\n  			items.splice(i, 1);\n  		}\n\n  		// Remove comments, unless we want to keep them\n  		else if (stripComments && item.t === COMMENT) {\n  			items.splice(i, 1);\n  		}\n  	}\n\n  	// If necessary, remove leading and trailing whitespace\n  	trimWhitespace(items, removeLeadingWhitespace ? utils_cleanup__leadingWhitespace : null, removeTrailingWhitespace ? trailingWhitespace : null);\n\n  	i = items.length;\n  	while (i--) {\n  		item = items[i];\n\n  		// Recurse\n  		if (item.f) {\n  			var isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test(item.e);\n  			preserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;\n\n  			if (!preserveWhitespace && isPreserveWhitespaceElement) {\n  				trimWhitespace(item.f, leadingNewLine, trailingNewLine);\n  			}\n\n  			if (!preserveWhitespaceInsideFragment) {\n  				previousItem = items[i - 1];\n  				nextItem = items[i + 1];\n\n  				// if the previous item was a text item with trailing whitespace,\n  				// remove leading whitespace inside the fragment\n  				if (!previousItem || typeof previousItem === "string" && trailingWhitespace.test(previousItem)) {\n  					removeLeadingWhitespaceInsideFragment = true;\n  				}\n\n  				// and vice versa\n  				if (!nextItem || typeof nextItem === "string" && utils_cleanup__leadingWhitespace.test(nextItem)) {\n  					removeTrailingWhitespaceInsideFragment = true;\n  				}\n  			}\n\n  			cleanup(item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  		}\n\n  		// Split if-else blocks into two (an if, and an unless)\n  		if (item.l) {\n  			cleanup(item.l.f, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n\n  			items.splice(i + 1, 0, item.l);\n  			delete item.l; // TODO would be nice if there was a way around this\n  		}\n\n  		// Clean up element attributes\n  		if (item.a) {\n  			for (key in item.a) {\n  				if (item.a.hasOwnProperty(key) && typeof item.a[key] !== "string") {\n  					cleanup(item.a[key], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  				}\n  			}\n  		}\n\n  		// Clean up conditional attributes\n  		if (item.m) {\n  			cleanup(item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  		}\n\n  		// Clean up event handlers\n  		if (item.v) {\n  			for (key in item.v) {\n  				if (item.v.hasOwnProperty(key)) {\n  					// clean up names\n  					if (isArray(item.v[key].n)) {\n  						cleanup(item.v[key].n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  					}\n\n  					// clean up params\n  					if (isArray(item.v[key].d)) {\n  						cleanup(item.v[key].d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  					}\n  				}\n  			}\n  		}\n  	}\n\n  	// final pass - fuse text nodes together\n  	i = items.length;\n  	while (i--) {\n  		if (typeof items[i] === "string") {\n  			if (typeof items[i + 1] === "string") {\n  				items[i] = items[i] + items[i + 1];\n  				items.splice(i + 1, 1);\n  			}\n\n  			if (!preserveWhitespace) {\n  				items[i] = items[i].replace(contiguousWhitespace, " ");\n  			}\n\n  			if (items[i] === "") {\n  				items.splice(i, 1);\n  			}\n  		}\n  	}\n  }\n\n  var element_readClosingTag = readClosingTag;\n  var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n  function readClosingTag(parser) {\n  	var start, tag;\n\n  	start = parser.pos;\n\n  	// are we looking at a closing tag?\n  	if (!parser.matchString("</")) {\n  		return null;\n  	}\n\n  	if (tag = parser.matchPattern(closingTagPattern)) {\n  		if (parser.inside && tag !== parser.inside) {\n  			parser.pos = start;\n  			return null;\n  		}\n\n  		return {\n  			t: CLOSING_TAG,\n  			e: tag\n  		};\n  	}\n\n  	// We have an illegal closing tag, report it\n  	parser.pos -= 2;\n  	parser.error("Illegal closing tag");\n  }\n\n  var getLowestIndex = function (haystack, needles) {\n  	var i, index, lowest;\n\n  	i = needles.length;\n  	while (i--) {\n  		index = haystack.indexOf(needles[i]);\n\n  		// short circuit\n  		if (!index) {\n  			return 0;\n  		}\n\n  		if (index === -1) {\n  			continue;\n  		}\n\n  		if (!lowest || index < lowest) {\n  			lowest = index;\n  		}\n  	}\n\n  	return lowest || -1;\n  };\n\n  var element_readAttribute = readAttribute;\n\n  var attributeNamePattern = /^[^\\s"\'>\\/=]+/,\n      unquotedAttributeValueTextPattern = /^[^\\s"\'=<>`]+/;\n  function readAttribute(parser) {\n  	var attr, name, value;\n\n  	parser.allowWhitespace();\n\n  	name = parser.matchPattern(attributeNamePattern);\n  	if (!name) {\n  		return null;\n  	}\n\n  	attr = { name: name };\n\n  	value = readAttributeValue(parser);\n  	if (value != null) {\n  		// not null/undefined\n  		attr.value = value;\n  	}\n\n  	return attr;\n  }\n\n  function readAttributeValue(parser) {\n  	var start, valueStart, startDepth, value;\n\n  	start = parser.pos;\n\n  	// next character must be `=`, `/`, `>` or whitespace\n  	if (!/[=\\/>\\s]/.test(parser.nextChar())) {\n  		parser.error("Expected `=`, `/`, `>` or whitespace");\n  	}\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("=")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	valueStart = parser.pos;\n  	startDepth = parser.sectionDepth;\n\n  	value = readQuotedAttributeValue(parser, "\'") || readQuotedAttributeValue(parser, "\\"") || readUnquotedAttributeValue(parser);\n\n  	if (value === null) {\n  		parser.error("Expected valid attribute value");\n  	}\n\n  	if (parser.sectionDepth !== startDepth) {\n  		parser.pos = valueStart;\n  		parser.error("An attribute value must contain as many opening section tags as closing section tags");\n  	}\n\n  	if (!value.length) {\n  		return "";\n  	}\n\n  	if (value.length === 1 && typeof value[0] === "string") {\n  		return decodeCharacterReferences(value[0]);\n  	}\n\n  	return value;\n  }\n\n  function readUnquotedAttributeValueToken(parser) {\n  	var start, text, haystack, needles, index;\n\n  	start = parser.pos;\n\n  	text = parser.matchPattern(unquotedAttributeValueTextPattern);\n\n  	if (!text) {\n  		return null;\n  	}\n\n  	haystack = text;\n  	needles = parser.tags.map(function (t) {\n  		return t.open;\n  	}); // TODO refactor... we do this in readText.js as well\n\n  	if ((index = getLowestIndex(haystack, needles)) !== -1) {\n  		text = text.substr(0, index);\n  		parser.pos = start + text.length;\n  	}\n\n  	return text;\n  }\n\n  function readUnquotedAttributeValue(parser) {\n  	var tokens, token;\n\n  	parser.inAttribute = true;\n\n  	tokens = [];\n\n  	token = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  	while (token !== null) {\n  		tokens.push(token);\n  		token = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  	}\n\n  	if (!tokens.length) {\n  		return null;\n  	}\n\n  	parser.inAttribute = false;\n  	return tokens;\n  }\n\n  function readQuotedAttributeValue(parser, quoteMark) {\n  	var start, tokens, token;\n\n  	start = parser.pos;\n\n  	if (!parser.matchString(quoteMark)) {\n  		return null;\n  	}\n\n  	parser.inAttribute = quoteMark;\n\n  	tokens = [];\n\n  	token = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  	while (token !== null) {\n  		tokens.push(token);\n  		token = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  	}\n\n  	if (!parser.matchString(quoteMark)) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	parser.inAttribute = false;\n\n  	return tokens;\n  }\n\n  function readQuotedStringToken(parser, quoteMark) {\n  	var start, index, haystack, needles;\n\n  	start = parser.pos;\n  	haystack = parser.remaining();\n\n  	needles = parser.tags.map(function (t) {\n  		return t.open;\n  	}); // TODO refactor... we do this in readText.js as well\n  	needles.push(quoteMark);\n\n  	index = getLowestIndex(haystack, needles);\n\n  	if (index === -1) {\n  		parser.error("Quoted attribute value must have a closing quote");\n  	}\n\n  	if (!index) {\n  		return null;\n  	}\n\n  	parser.pos += index;\n  	return haystack.substr(0, index);\n  }\n\n  var JsonParser, specials, specialsPattern, parseJSON__numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;\n\n  specials = {\n  	"true": true,\n  	"false": false,\n  	undefined: undefined,\n  	"null": null\n  };\n\n  specialsPattern = new RegExp("^(?:" + Object.keys(specials).join("|") + ")");\n  parseJSON__numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n  placeholderPattern = /\\$\\{([^\\}]+)\\}/g;\n  placeholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\n  onlyWhitespace = /^\\s*$/;\n\n  JsonParser = parse_Parser.extend({\n  	init: function (str, options) {\n  		this.values = options.values;\n  		this.allowWhitespace();\n  	},\n\n  	postProcess: function (result) {\n  		if (result.length !== 1 || !onlyWhitespace.test(this.leftover)) {\n  			return null;\n  		}\n\n  		return { value: result[0].v };\n  	},\n\n  	converters: [function getPlaceholder(parser) {\n  		var placeholder;\n\n  		if (!parser.values) {\n  			return null;\n  		}\n\n  		placeholder = parser.matchPattern(placeholderAtStartPattern);\n\n  		if (placeholder && parser.values.hasOwnProperty(placeholder)) {\n  			return { v: parser.values[placeholder] };\n  		}\n  	}, function getSpecial(parser) {\n  		var special;\n\n  		if (special = parser.matchPattern(specialsPattern)) {\n  			return { v: specials[special] };\n  		}\n  	}, function getNumber(parser) {\n  		var number;\n\n  		if (number = parser.matchPattern(parseJSON__numberPattern)) {\n  			return { v: +number };\n  		}\n  	}, function getString(parser) {\n  		var stringLiteral = readStringLiteral(parser),\n  		    values;\n\n  		if (stringLiteral && (values = parser.values)) {\n  			return {\n  				v: stringLiteral.v.replace(placeholderPattern, function (match, $1) {\n  					return $1 in values ? values[$1] : $1;\n  				})\n  			};\n  		}\n\n  		return stringLiteral;\n  	}, function getObject(parser) {\n  		var result, pair;\n\n  		if (!parser.matchString("{")) {\n  			return null;\n  		}\n\n  		result = {};\n\n  		parser.allowWhitespace();\n\n  		if (parser.matchString("}")) {\n  			return { v: result };\n  		}\n\n  		while (pair = getKeyValuePair(parser)) {\n  			result[pair.key] = pair.value;\n\n  			parser.allowWhitespace();\n\n  			if (parser.matchString("}")) {\n  				return { v: result };\n  			}\n\n  			if (!parser.matchString(",")) {\n  				return null;\n  			}\n  		}\n\n  		return null;\n  	}, function getArray(parser) {\n  		var result, valueToken;\n\n  		if (!parser.matchString("[")) {\n  			return null;\n  		}\n\n  		result = [];\n\n  		parser.allowWhitespace();\n\n  		if (parser.matchString("]")) {\n  			return { v: result };\n  		}\n\n  		while (valueToken = parser.read()) {\n  			result.push(valueToken.v);\n\n  			parser.allowWhitespace();\n\n  			if (parser.matchString("]")) {\n  				return { v: result };\n  			}\n\n  			if (!parser.matchString(",")) {\n  				return null;\n  			}\n\n  			parser.allowWhitespace();\n  		}\n\n  		return null;\n  	}]\n  });\n\n  function getKeyValuePair(parser) {\n  	var key, valueToken, pair;\n\n  	parser.allowWhitespace();\n\n  	key = shared_readKey(parser);\n\n  	if (!key) {\n  		return null;\n  	}\n\n  	pair = { key: key };\n\n  	parser.allowWhitespace();\n  	if (!parser.matchString(":")) {\n  		return null;\n  	}\n  	parser.allowWhitespace();\n\n  	valueToken = parser.read();\n  	if (!valueToken) {\n  		return null;\n  	}\n\n  	pair.value = valueToken.v;\n\n  	return pair;\n  }\n\n  var parseJSON = function (str, values) {\n  	var parser = new JsonParser(str, {\n  		values: values\n  	});\n\n  	return parser.result;\n  };\n\n  // TODO clean this up, it\'s shocking\n  var element_processDirective = processDirective;\n  var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\\(/,\n      methodCallExcessPattern = /\\)\\s*$/,\n      ExpressionParser;\n\n  ExpressionParser = parse_Parser.extend({\n  	converters: [converters_readExpression]\n  });\n  function processDirective(tokens, parentParser) {\n  	var result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;\n\n  	if (typeof tokens === "string") {\n  		if (match = methodCallPattern.exec(tokens)) {\n  			var end = tokens.lastIndexOf(")");\n\n  			// check for invalid method calls\n  			if (!methodCallExcessPattern.test(tokens)) {\n  				parentParser.error("Invalid input after method call expression \'" + tokens.slice(end + 1) + "\'");\n  			}\n\n  			result = { m: match[1] };\n  			args = "[" + tokens.slice(result.m.length + 1, end) + "]";\n\n  			parser = new ExpressionParser(args);\n  			result.a = utils_flattenExpression(parser.result[0]);\n\n  			return result;\n  		}\n\n  		if (tokens.indexOf(":") === -1) {\n  			return tokens.trim();\n  		}\n\n  		tokens = [tokens];\n  	}\n\n  	result = {};\n\n  	directiveName = [];\n  	directiveArgs = [];\n\n  	if (tokens) {\n  		while (tokens.length) {\n  			token = tokens.shift();\n\n  			if (typeof token === "string") {\n  				colonIndex = token.indexOf(":");\n\n  				if (colonIndex === -1) {\n  					directiveName.push(token);\n  				} else {\n\n  					// is the colon the first character?\n  					if (colonIndex) {\n  						// no\n  						directiveName.push(token.substr(0, colonIndex));\n  					}\n\n  					// if there is anything after the colon in this token, treat\n  					// it as the first token of the directiveArgs fragment\n  					if (token.length > colonIndex + 1) {\n  						directiveArgs[0] = token.substring(colonIndex + 1);\n  					}\n\n  					break;\n  				}\n  			} else {\n  				directiveName.push(token);\n  			}\n  		}\n\n  		directiveArgs = directiveArgs.concat(tokens);\n  	}\n\n  	if (!directiveName.length) {\n  		result = "";\n  	} else if (directiveArgs.length || typeof directiveName !== "string") {\n  		result = {\n  			// TODO is this really necessary? just use the array\n  			n: directiveName.length === 1 && typeof directiveName[0] === "string" ? directiveName[0] : directiveName\n  		};\n\n  		if (directiveArgs.length === 1 && typeof directiveArgs[0] === "string") {\n  			parsed = parseJSON("[" + directiveArgs[0] + "]");\n  			result.a = parsed ? parsed.value : directiveArgs[0].trim();\n  		} else {\n  			result.d = directiveArgs;\n  		}\n  	} else {\n  		result = directiveName;\n  	}\n\n  	return result;\n  }\n\n  var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/,\n      validTagNameFollower = /^[\\s\\n\\/>]/,\n      onPattern = /^on/,\n      proxyEventPattern = /^on-([a-zA-Z\\\\*\\\\.$_][a-zA-Z\\\\*\\\\.$_0-9\\-]+)$/,\n      reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,\n      directives = { "intro-outro": "t0", intro: "t1", outro: "t2", decorator: "o" },\n      exclude = { exclude: true },\n      disallowedContents;\n\n  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\n  disallowedContents = {\n  	li: ["li"],\n  	dt: ["dt", "dd"],\n  	dd: ["dt", "dd"],\n  	p: "address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(" "),\n  	rt: ["rt", "rp"],\n  	rp: ["rt", "rp"],\n  	optgroup: ["optgroup"],\n  	option: ["option", "optgroup"],\n  	thead: ["tbody", "tfoot"],\n  	tbody: ["tbody", "tfoot"],\n  	tfoot: ["tbody"],\n  	tr: ["tr", "tbody"],\n  	td: ["td", "th", "tr"],\n  	th: ["td", "th", "tr"]\n  };\n\n  var converters_readElement = readElement;\n\n  function readElement(parser) {\n  	var start, element, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, partials, hasPartials, child, closed, pos, remaining, closingTag;\n\n  	start = parser.pos;\n\n  	if (parser.inside || parser.inAttribute) {\n  		return null;\n  	}\n\n  	if (!parser.matchString("<")) {\n  		return null;\n  	}\n\n  	// if this is a closing tag, abort straight away\n  	if (parser.nextChar() === "/") {\n  		return null;\n  	}\n\n  	element = {};\n  	if (parser.includeLinePositions) {\n  		element.p = parser.getLinePos(start);\n  	}\n\n  	if (parser.matchString("!")) {\n  		element.t = DOCTYPE;\n  		if (!parser.matchPattern(/^doctype/i)) {\n  			parser.error("Expected DOCTYPE declaration");\n  		}\n\n  		element.a = parser.matchPattern(/^(.+?)>/);\n  		return element;\n  	}\n\n  	element.t = ELEMENT;\n\n  	// element name\n  	element.e = parser.matchPattern(tagNamePattern);\n  	if (!element.e) {\n  		return null;\n  	}\n\n  	// next character must be whitespace, closing solidus or \'>\'\n  	if (!validTagNameFollower.test(parser.nextChar())) {\n  		parser.error("Illegal tag name");\n  	}\n\n  	addProxyEvent = function (name, directive) {\n  		var directiveName = directive.n || directive;\n\n  		if (reservedEventNames.test(directiveName)) {\n  			parser.pos -= directiveName.length;\n  			parser.error("Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)");\n  		}\n\n  		element.v[name] = directive;\n  	};\n\n  	parser.allowWhitespace();\n\n  	// directives and attributes\n  	while (attribute = converters_readMustache(parser) || element_readAttribute(parser)) {\n  		// regular attributes\n  		if (attribute.name) {\n  			// intro, outro, decorator\n  			if (directiveName = directives[attribute.name]) {\n  				element[directiveName] = element_processDirective(attribute.value, parser);\n  			}\n\n  			// on-click etc\n  			else if (match = proxyEventPattern.exec(attribute.name)) {\n  				if (!element.v) element.v = {};\n  				directive = element_processDirective(attribute.value, parser);\n  				addProxyEvent(match[1], directive);\n  			} else {\n  				if (!parser.sanitizeEventAttributes || !onPattern.test(attribute.name)) {\n  					if (!element.a) element.a = {};\n  					element.a[attribute.name] = attribute.value || (attribute.value === "" ? "" : 0);\n  				}\n  			}\n  		}\n\n  		// {{#if foo}}class=\'foo\'{{/if}}\n  		else {\n  			if (!element.m) element.m = [];\n  			element.m.push(attribute);\n  		}\n\n  		parser.allowWhitespace();\n  	}\n\n  	// allow whitespace before closing solidus\n  	parser.allowWhitespace();\n\n  	// self-closing solidus?\n  	if (parser.matchString("/")) {\n  		selfClosing = true;\n  	}\n\n  	// closing angle bracket\n  	if (!parser.matchString(">")) {\n  		return null;\n  	}\n\n  	var lowerCaseName = element.e.toLowerCase();\n  	var preserveWhitespace = parser.preserveWhitespace;\n\n  	if (!selfClosing && !voidElementNames.test(element.e)) {\n  		parser.elementStack.push(lowerCaseName);\n\n  		// Special case - if we open a script element, further tags should\n  		// be ignored unless they\'re a closing script element\n  		if (lowerCaseName === "script" || lowerCaseName === "style") {\n  			parser.inside = lowerCaseName;\n  		}\n\n  		children = [];\n  		partials = create(null);\n\n  		do {\n  			pos = parser.pos;\n  			remaining = parser.remaining();\n\n  			// if for example we\'re in an <li> element, and we see another\n  			// <li> tag, close the first so they become siblings\n  			if (!canContain(lowerCaseName, remaining)) {\n  				closed = true;\n  			}\n\n  			// closing tag\n  			else if (closingTag = element_readClosingTag(parser)) {\n  				closed = true;\n\n  				var closingTagName = closingTag.e.toLowerCase();\n\n  				// if this *isn\'t* the closing tag for the current element...\n  				if (closingTagName !== lowerCaseName) {\n  					// rewind parser\n  					parser.pos = pos;\n\n  					// if it doesn\'t close a parent tag, error\n  					if (! ~parser.elementStack.indexOf(closingTagName)) {\n  						var errorMessage = "Unexpected closing tag";\n\n  						// add additional help for void elements, since component names\n  						// might clash with them\n  						if (voidElementNames.test(closingTagName)) {\n  							errorMessage += " (<" + closingTagName + "> is a void element - it cannot contain children)";\n  						}\n\n  						parser.error(errorMessage);\n  					}\n  				}\n  			}\n\n  			// implicit close by closing section tag. TODO clean this up\n  			else if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {\n  				closed = true;\n  				parser.pos = pos;\n  			} else {\n  				if (child = parser.read(PARTIAL_READERS)) {\n  					if (partials[child.n]) {\n  						parser.pos = pos;\n  						parser.error("Duplicate partial definition");\n  					}\n\n  					utils_cleanup(child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);\n\n  					partials[child.n] = child.f;\n  					hasPartials = true;\n  				} else {\n  					if (child = parser.read(READERS)) {\n  						children.push(child);\n  					} else {\n  						closed = true;\n  					}\n  				}\n  			}\n  		} while (!closed);\n\n  		if (children.length) {\n  			element.f = children;\n  		}\n\n  		if (hasPartials) {\n  			element.p = partials;\n  		}\n\n  		parser.elementStack.pop();\n  	}\n\n  	parser.inside = null;\n\n  	if (parser.sanitizeElements && parser.sanitizeElements.indexOf(lowerCaseName) !== -1) {\n  		return exclude;\n  	}\n\n  	return element;\n  }\n\n  function canContain(name, remaining) {\n  	var match, disallowed;\n\n  	match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(remaining);\n  	disallowed = disallowedContents[name];\n\n  	if (!match || !disallowed) {\n  		return true;\n  	}\n\n  	return ! ~disallowed.indexOf(match[1].toLowerCase());\n  }\n\n  var converters_readText = readText;\n  function readText(parser) {\n  	var index, remaining, disallowed, barrier;\n\n  	remaining = parser.remaining();\n\n  	barrier = parser.inside ? "</" + parser.inside : "<";\n\n  	if (parser.inside && !parser.interpolate[parser.inside]) {\n  		index = remaining.indexOf(barrier);\n  	} else {\n  		disallowed = parser.tags.map(function (t) {\n  			return t.open;\n  		});\n  		disallowed = disallowed.concat(parser.tags.map(function (t) {\n  			return "\\\\" + t.open;\n  		}));\n\n  		// http://developers.whatwg.org/syntax.html#syntax-attributes\n  		if (parser.inAttribute === true) {\n  			// we\'re inside an unquoted attribute value\n  			disallowed.push("\\"", "\'", "=", "<", ">", "`");\n  		} else if (parser.inAttribute) {\n  			// quoted attribute value\n  			disallowed.push(parser.inAttribute);\n  		} else {\n  			disallowed.push(barrier);\n  		}\n\n  		index = getLowestIndex(remaining, disallowed);\n  	}\n\n  	if (!index) {\n  		return null;\n  	}\n\n  	if (index === -1) {\n  		index = remaining.length;\n  	}\n\n  	parser.pos += index;\n\n  	return parser.inside ? remaining.substr(0, index) : decodeCharacterReferences(remaining.substr(0, index));\n  }\n\n  var utils_escapeRegExp = escapeRegExp;\n  var utils_escapeRegExp__pattern = /[-/\\\\^$*+?.()|[\\]{}]/g;\n  function escapeRegExp(str) {\n  	return str.replace(utils_escapeRegExp__pattern, "\\\\$&");\n  }\n\n  var converters_readPartialDefinitionComment = readPartialDefinitionComment;\n\n  var startPattern = /^<!--\\s*/,\n      namePattern = /s*>\\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\\s*/,\n      finishPattern = /\\s*-->/,\n      child;\n\n  function readPartialDefinitionComment(parser) {\n  	var firstPos = parser.pos,\n  	    open = parser.standardDelimiters[0],\n  	    close = parser.standardDelimiters[1],\n  	    content = undefined,\n  	    closed = undefined;\n\n  	if (!parser.matchPattern(startPattern) || !parser.matchString(open)) {\n  		parser.pos = firstPos;\n  		return null;\n  	}\n\n  	var name = parser.matchPattern(namePattern);\n\n  	warnOnceIfDebug("Inline partial comments are deprecated.\\nUse this...\\n  {{#partial " + name + "}} ... {{/partial}}\\n\\n...instead of this:\\n  <!-- {{>" + name + "}} --> ... <!-- {{/" + name + "}} -->\'");\n\n  	// make sure the rest of the comment is in the correct place\n  	if (!parser.matchString(close) || !parser.matchPattern(finishPattern)) {\n  		parser.pos = firstPos;\n  		return null;\n  	}\n\n  	content = [];\n\n  	var endPattern = new RegExp("^<!--\\\\s*" + utils_escapeRegExp(open) + "\\\\s*\\\\/\\\\s*" + name + "\\\\s*" + utils_escapeRegExp(close) + "\\\\s*-->");\n\n  	do {\n  		if (parser.matchPattern(endPattern)) {\n  			closed = true;\n  		} else {\n  			child = parser.read(READERS);\n  			if (!child) {\n  				parser.error("expected closing comment (\'<!-- " + open + "/" + name + "" + close + " -->\')");\n  			}\n\n  			content.push(child);\n  		}\n  	} while (!closed);\n\n  	return {\n  		t: INLINE_PARTIAL,\n  		f: content,\n  		n: name\n  	};\n  }\n\n  var converters_readPartialDefinitionSection = readPartialDefinitionSection;\n  var partialDefinitionSectionPattern = /^#\\s*partial\\s+/;\n  function readPartialDefinitionSection(parser) {\n  	var start, name, content, child, closed;\n\n  	start = parser.pos;\n\n  	var delimiters = parser.standardDelimiters;\n\n  	if (!parser.matchString(delimiters[0])) {\n  		return null;\n  	}\n\n  	if (!parser.matchPattern(partialDefinitionSectionPattern)) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/);\n\n  	if (!name) {\n  		parser.error("expected legal partial name");\n  	}\n\n  	if (!parser.matchString(delimiters[1])) {\n  		parser.error("Expected closing delimiter \'" + delimiters[1] + "\'");\n  	}\n\n  	content = [];\n\n  	do {\n  		// TODO clean this up\n  		if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {\n  			if (!child.r === "partial") {\n  				parser.error("Expected " + delimiters[0] + "/partial" + delimiters[1]);\n  			}\n\n  			closed = true;\n  		} else {\n  			child = parser.read(READERS);\n\n  			if (!child) {\n  				parser.error("Expected " + delimiters[0] + "/partial" + delimiters[1]);\n  			}\n\n  			content.push(child);\n  		}\n  	} while (!closed);\n\n  	return {\n  		t: INLINE_PARTIAL,\n  		n: name,\n  		f: content\n  	};\n  }\n\n  var converters_readTemplate = readTemplate;\n  function readTemplate(parser) {\n  	var fragment = [];\n  	var partials = create(null);\n  	var hasPartials = false;\n\n  	var preserveWhitespace = parser.preserveWhitespace;\n\n  	while (parser.pos < parser.str.length) {\n  		var pos = parser.pos,\n  		    item = undefined,\n  		    partial = undefined;\n\n  		if (partial = parser.read(PARTIAL_READERS)) {\n  			if (partials[partial.n]) {\n  				parser.pos = pos;\n  				parser.error("Duplicated partial definition");\n  			}\n\n  			utils_cleanup(partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);\n\n  			partials[partial.n] = partial.f;\n  			hasPartials = true;\n  		} else if (item = parser.read(READERS)) {\n  			fragment.push(item);\n  		} else {\n  			parser.error("Unexpected template content");\n  		}\n  	}\n\n  	var result = {\n  		v: TEMPLATE_VERSION,\n  		t: fragment\n  	};\n\n  	if (hasPartials) {\n  		result.p = partials;\n  	}\n\n  	return result;\n  }\n\n  var _parse = parse;\n\n  var STANDARD_READERS = [mustache_readPartial, mustache_readUnescaped, mustache_readSection, mustache_readYielder, mustache_readInterpolator, readMustacheComment];\n  var TRIPLE_READERS = [mustache_readTriple];\n  var STATIC_READERS = [mustache_readUnescaped, mustache_readSection, mustache_readInterpolator]; // TODO does it make sense to have a static section?\n\n  var StandardParser = undefined;\n  function parse(template, options) {\n  	return new StandardParser(template, options || {}).result;\n  }\n\n  var READERS = [converters_readMustache, converters_readHtmlComment, converters_readElement, converters_readText];\n  var PARTIAL_READERS = [converters_readPartialDefinitionComment, converters_readPartialDefinitionSection];\n\n  StandardParser = parse_Parser.extend({\n  	init: function (str, options) {\n  		var tripleDelimiters = options.tripleDelimiters || ["{{{", "}}}"],\n  		    staticDelimiters = options.staticDelimiters || ["[[", "]]"],\n  		    staticTripleDelimiters = options.staticTripleDelimiters || ["[[[", "]]]"];\n\n  		this.standardDelimiters = options.delimiters || ["{{", "}}"];\n\n  		this.tags = [{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS }, { isStatic: false, isTriple: true, open: tripleDelimiters[0], close: tripleDelimiters[1], readers: TRIPLE_READERS }, { isStatic: true, isTriple: false, open: staticDelimiters[0], close: staticDelimiters[1], readers: STATIC_READERS }, { isStatic: true, isTriple: true, open: staticTripleDelimiters[0], close: staticTripleDelimiters[1], readers: TRIPLE_READERS }];\n\n  		this.sortMustacheTags();\n\n  		this.sectionDepth = 0;\n  		this.elementStack = [];\n\n  		this.interpolate = {\n  			script: !options.interpolate || options.interpolate.script !== false,\n  			style: !options.interpolate || options.interpolate.style !== false\n  		};\n\n  		if (options.sanitize === true) {\n  			options.sanitize = {\n  				// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n  				elements: "applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title".split(" "),\n  				eventAttributes: true\n  			};\n  		}\n\n  		this.stripComments = options.stripComments !== false;\n  		this.preserveWhitespace = options.preserveWhitespace;\n  		this.sanitizeElements = options.sanitize && options.sanitize.elements;\n  		this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n  		this.includeLinePositions = options.includeLinePositions;\n  	},\n\n  	postProcess: function (result) {\n  		// special case - empty string\n  		if (!result.length) {\n  			return { t: [], v: TEMPLATE_VERSION };\n  		}\n\n  		if (this.sectionDepth > 0) {\n  			this.error("A section was left open");\n  		}\n\n  		utils_cleanup(result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace);\n\n  		return result[0];\n  	},\n\n  	converters: [converters_readTemplate],\n\n  	sortMustacheTags: function () {\n  		// Sort in order of descending opening delimiter length (longer first),\n  		// to protect against opening delimiters being substrings of each other\n  		this.tags.sort(function (a, b) {\n  			return b.open.length - a.open.length;\n  		});\n  	}\n  });\n\n  var parseOptions = ["preserveWhitespace", "sanitize", "stripComments", "delimiters", "tripleDelimiters", "interpolate"];\n\n  var parser = {\n  	fromId: fromId, isHashedId: isHashedId, isParsed: isParsed, getParseOptions: getParseOptions, createHelper: template_parser__createHelper,\n  	parse: doParse\n  };\n\n  function template_parser__createHelper(parseOptions) {\n  	var helper = create(parser);\n  	helper.parse = function (template, options) {\n  		return doParse(template, options || parseOptions);\n  	};\n  	return helper;\n  }\n\n  function doParse(template, parseOptions) {\n  	if (!_parse) {\n  		throw new Error("Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser");\n  	}\n\n  	return _parse(template, parseOptions || this.options);\n  }\n\n  function fromId(id, options) {\n  	var template;\n\n  	if (!isClient) {\n  		if (options && options.noThrow) {\n  			return;\n  		}\n  		throw new Error("Cannot retrieve template #" + id + " as Ractive is not running in a browser.");\n  	}\n\n  	if (isHashedId(id)) {\n  		id = id.substring(1);\n  	}\n\n  	if (!(template = document.getElementById(id))) {\n  		if (options && options.noThrow) {\n  			return;\n  		}\n  		throw new Error("Could not find template element with id #" + id);\n  	}\n\n  	if (template.tagName.toUpperCase() !== "SCRIPT") {\n  		if (options && options.noThrow) {\n  			return;\n  		}\n  		throw new Error("Template element with id #" + id + ", must be a <script> element");\n  	}\n\n  	return "textContent" in template ? template.textContent : template.innerHTML;\n  }\n\n  function isHashedId(id) {\n  	return id && id[0] === "#";\n  }\n\n  function isParsed(template) {\n  	return !(typeof template === "string");\n  }\n\n  function getParseOptions(ractive) {\n  	// Could be Ractive or a Component\n  	if (ractive.defaults) {\n  		ractive = ractive.defaults;\n  	}\n\n  	return parseOptions.reduce(function (val, key) {\n  		val[key] = ractive[key];\n  		return val;\n  	}, {});\n  }\n\n  var template_parser = parser;\n\n  var templateConfigurator = {\n  	name: "template",\n\n  	extend: function extend(Parent, proto, options) {\n  		var template;\n\n  		// only assign if exists\n  		if ("template" in options) {\n  			template = options.template;\n\n  			if (typeof template === "function") {\n  				proto.template = template;\n  			} else {\n  				proto.template = parseIfString(template, proto);\n  			}\n  		}\n  	},\n\n  	init: function init(Parent, ractive, options) {\n  		var template, fn;\n\n  		// TODO because of prototypal inheritance, we might just be able to use\n  		// ractive.template, and not bother passing through the Parent object.\n  		// At present that breaks the test mocks\' expectations\n  		template = "template" in options ? options.template : Parent.prototype.template;\n\n  		if (typeof template === "function") {\n  			fn = template;\n  			template = getDynamicTemplate(ractive, fn);\n\n  			ractive._config.template = {\n  				fn: fn,\n  				result: template\n  			};\n  		}\n\n  		template = parseIfString(template, ractive);\n\n  		// TODO the naming of this is confusing - ractive.template refers to [...],\n  		// but Component.prototype.template refers to {v:1,t:[],p:[]}...\n  		// it\'s unnecessary, because the developer never needs to access\n  		// ractive.template\n  		ractive.template = template.t;\n\n  		if (template.p) {\n  			extendPartials(ractive.partials, template.p);\n  		}\n  	},\n\n  	reset: function (ractive) {\n  		var result = resetValue(ractive),\n  		    parsed;\n\n  		if (result) {\n  			parsed = parseIfString(result, ractive);\n\n  			ractive.template = parsed.t;\n  			extendPartials(ractive.partials, parsed.p, true);\n\n  			return true;\n  		}\n  	}\n  };\n\n  function resetValue(ractive) {\n  	var initial = ractive._config.template,\n  	    result;\n\n  	// If this isn\'t a dynamic template, there\'s nothing to do\n  	if (!initial || !initial.fn) {\n  		return;\n  	}\n\n  	result = getDynamicTemplate(ractive, initial.fn);\n\n  	// TODO deep equality check to prevent unnecessary re-rendering\n  	// in the case of already-parsed templates\n  	if (result !== initial.result) {\n  		initial.result = result;\n  		result = parseIfString(result, ractive);\n  		return result;\n  	}\n  }\n\n  function getDynamicTemplate(ractive, fn) {\n  	var helper = template_template__createHelper(template_parser.getParseOptions(ractive));\n  	return fn.call(ractive, helper);\n  }\n\n  function template_template__createHelper(parseOptions) {\n  	var helper = create(template_parser);\n  	helper.parse = function (template, options) {\n  		return template_parser.parse(template, options || parseOptions);\n  	};\n  	return helper;\n  }\n\n  function parseIfString(template, ractive) {\n  	if (typeof template === "string") {\n  		// ID of an element containing the template?\n  		if (template[0] === "#") {\n  			template = template_parser.fromId(template);\n  		}\n\n  		template = _parse(template, template_parser.getParseOptions(ractive));\n  	}\n\n  	// Check that the template even exists\n  	else if (template == undefined) {\n  		throw new Error("The template cannot be " + template + ".");\n  	}\n\n  	// Check the parsed template has a version at all\n  	else if (typeof template.v !== "number") {\n  		throw new Error("The template parser was passed a non-string template, but the template doesn\'t have a version.  Make sure you\'re passing in the template you think you are.");\n  	}\n\n  	// Check we\'re using the correct version\n  	else if (template.v !== TEMPLATE_VERSION) {\n  		throw new Error("Mismatched template version (expected " + TEMPLATE_VERSION + ", got " + template.v + ") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app");\n  	}\n\n  	return template;\n  }\n\n  function extendPartials(existingPartials, newPartials, overwrite) {\n  	if (!newPartials) return;\n\n  	// TODO there\'s an ambiguity here - we need to overwrite in the `reset()`\n  	// case, but not initially...\n\n  	for (var key in newPartials) {\n  		if (overwrite || !existingPartials.hasOwnProperty(key)) {\n  			existingPartials[key] = newPartials[key];\n  		}\n  	}\n  }\n\n  var template_template = templateConfigurator;\n\n  var config_registries__registryNames, Registry, registries;\n\n  config_registries__registryNames = ["adaptors", "components", "computed", "decorators", "easing", "events", "interpolators", "partials", "transitions"];\n\n  Registry = function (name, useDefaults) {\n  	this.name = name;\n  	this.useDefaults = useDefaults;\n  };\n\n  Registry.prototype = {\n  	constructor: Registry,\n\n  	extend: function (Parent, proto, options) {\n  		this.configure(this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options);\n  	},\n\n  	init: function () {},\n\n  	configure: function (Parent, target, options) {\n  		var name = this.name,\n  		    option = options[name],\n  		    registry;\n\n  		registry = create(Parent[name]);\n\n  		for (var key in option) {\n  			registry[key] = option[key];\n  		}\n\n  		target[name] = registry;\n  	},\n\n  	reset: function (ractive) {\n  		var registry = ractive[this.name];\n  		var changed = false;\n  		Object.keys(registry).forEach(function (key) {\n  			var item = registry[key];\n  			if (item._fn) {\n  				if (item._fn.isOwner) {\n  					registry[key] = item._fn;\n  				} else {\n  					delete registry[key];\n  				}\n  				changed = true;\n  			}\n  		});\n  		return changed;\n  	}\n  };\n\n  registries = config_registries__registryNames.map(function (name) {\n  	return new Registry(name, name === "computed");\n  });\n\n  var config_registries = registries;\n\n  /*this.configure(\n  	this.useDefaults ? Parent.defaults : Parent,\n  	ractive,\n  	options );*/\n\n  var wrapPrototype = wrap;\n\n  function wrap(parent, name, method) {\n  	if (!/_super/.test(method)) {\n  		return method;\n  	}\n\n  	var wrapper = function wrapSuper() {\n  		var superMethod = getSuperMethod(wrapper._parent, name),\n  		    hasSuper = ("_super" in this),\n  		    oldSuper = this._super,\n  		    result;\n\n  		this._super = superMethod;\n\n  		result = method.apply(this, arguments);\n\n  		if (hasSuper) {\n  			this._super = oldSuper;\n  		} else {\n  			delete this._super;\n  		}\n\n  		return result;\n  	};\n\n  	wrapper._parent = parent;\n  	wrapper._method = method;\n\n  	return wrapper;\n  }\n\n  function getSuperMethod(parent, name) {\n  	var value, method;\n\n  	if (name in parent) {\n  		value = parent[name];\n\n  		if (typeof value === "function") {\n  			method = value;\n  		} else {\n  			method = function returnValue() {\n  				return value;\n  			};\n  		}\n  	} else {\n  		method = noop;\n  	}\n\n  	return method;\n  }\n\n  var config_deprecate = deprecate;\n  function getMessage(deprecated, correct, isError) {\n  	return "options." + deprecated + " has been deprecated in favour of options." + correct + "." + (isError ? " You cannot specify both options, please use options." + correct + "." : "");\n  }\n\n  function deprecateOption(options, deprecatedOption, correct) {\n  	if (deprecatedOption in options) {\n  		if (!(correct in options)) {\n  			warnIfDebug(getMessage(deprecatedOption, correct));\n  			options[correct] = options[deprecatedOption];\n  		} else {\n  			throw new Error(getMessage(deprecatedOption, correct, true));\n  		}\n  	}\n  }\n  function deprecate(options) {\n  	deprecateOption(options, "beforeInit", "onconstruct");\n  	deprecateOption(options, "init", "onrender");\n  	deprecateOption(options, "complete", "oncomplete");\n  	deprecateOption(options, "eventDefinitions", "events");\n\n  	// Using extend with Component instead of options,\n  	// like Human.extend( Spider ) means adaptors as a registry\n  	// gets copied to options. So we have to check if actually an array\n  	if (isArray(options.adaptors)) {\n  		deprecateOption(options, "adaptors", "adapt");\n  	}\n  }\n\n  var config, order, defaultKeys, custom, isBlacklisted, isStandardKey;\n\n  custom = {\n  	adapt: custom_adapt,\n  	css: css_css,\n  	data: custom_data,\n  	template: template_template\n  };\n\n  defaultKeys = Object.keys(config_defaults);\n\n  isStandardKey = makeObj(defaultKeys.filter(function (key) {\n  	return !custom[key];\n  }));\n\n  // blacklisted keys that we don\'t double extend\n  isBlacklisted = makeObj(defaultKeys.concat(config_registries.map(function (r) {\n  	return r.name;\n  })));\n\n  order = [].concat(defaultKeys.filter(function (key) {\n  	return !config_registries[key] && !custom[key];\n  }), config_registries, custom.data, custom.template, custom.css);\n\n  config = {\n  	extend: function (Parent, proto, options) {\n  		return configure("extend", Parent, proto, options);\n  	},\n\n  	init: function (Parent, ractive, options) {\n  		return configure("init", Parent, ractive, options);\n  	},\n\n  	reset: function (ractive) {\n  		return order.filter(function (c) {\n  			return c.reset && c.reset(ractive);\n  		}).map(function (c) {\n  			return c.name;\n  		});\n  	},\n\n  	// this defines the order. TODO this isn\'t used anywhere in the codebase,\n  	// only in the test suite - should get rid of it\n  	order: order };\n\n  function configure(method, Parent, target, options) {\n  	config_deprecate(options);\n\n  	for (var key in options) {\n  		if (isStandardKey.hasOwnProperty(key)) {\n  			var value = options[key];\n\n  			// warn the developer if they passed a function and ignore its value\n\n  			// NOTE: we allow some functions on "el" because we duck type element lists\n  			// and some libraries or ef\'ed-up virtual browsers (phantomJS) return a\n  			// function object as the result of querySelector methods\n  			if (key !== "el" && typeof value === "function") {\n  				warnIfDebug("" + key + " is a Ractive option that does not expect a function and will be ignored", method === "init" ? target : null);\n  			} else {\n  				target[key] = value;\n  			}\n  		}\n  	}\n\n  	config_registries.forEach(function (registry) {\n  		registry[method](Parent, target, options);\n  	});\n\n  	custom_adapt[method](Parent, target, options);\n  	template_template[method](Parent, target, options);\n  	css_css[method](Parent, target, options);\n\n  	extendOtherMethods(Parent.prototype, target, options);\n  }\n\n  function extendOtherMethods(parent, target, options) {\n  	for (var key in options) {\n  		if (!isBlacklisted[key] && options.hasOwnProperty(key)) {\n  			var member = options[key];\n\n  			// if this is a method that overwrites a method, wrap it:\n  			if (typeof member === "function") {\n  				member = wrapPrototype(parent, key, member);\n  			}\n\n  			target[key] = member;\n  		}\n  	}\n  }\n\n  function makeObj(array) {\n  	var obj = {};\n  	array.forEach(function (x) {\n  		return obj[x] = true;\n  	});\n  	return obj;\n  }\n\n  var config_config = config;\n\n  var prototype_bubble = Fragment$bubble;\n\n  function Fragment$bubble() {\n  	this.dirtyValue = this.dirtyArgs = true;\n\n  	if (this.bound && typeof this.owner.bubble === "function") {\n  		this.owner.bubble();\n  	}\n  }\n\n  var Fragment_prototype_detach = Fragment$detach;\n\n  function Fragment$detach() {\n  	var docFrag;\n\n  	if (this.items.length === 1) {\n  		return this.items[0].detach();\n  	}\n\n  	docFrag = document.createDocumentFragment();\n\n  	this.items.forEach(function (item) {\n  		var node = item.detach();\n\n  		// TODO The if {...} wasn\'t previously required - it is now, because we\'re\n  		// forcibly detaching everything to reorder sections after an update. That\'s\n  		// a non-ideal brute force approach, implemented to get all the tests to pass\n  		// - as soon as it\'s replaced with something more elegant, this should\n  		// revert to `docFrag.appendChild( item.detach() )`\n  		if (node) {\n  			docFrag.appendChild(node);\n  		}\n  	});\n\n  	return docFrag;\n  }\n\n  var Fragment_prototype_find = Fragment$find;\n\n  function Fragment$find(selector) {\n  	var i, len, item, queryResult;\n\n  	if (this.items) {\n  		len = this.items.length;\n  		for (i = 0; i < len; i += 1) {\n  			item = this.items[i];\n\n  			if (item.find && (queryResult = item.find(selector))) {\n  				return queryResult;\n  			}\n  		}\n\n  		return null;\n  	}\n  }\n\n  var Fragment_prototype_findAll = Fragment$findAll;\n\n  function Fragment$findAll(selector, query) {\n  	var i, len, item;\n\n  	if (this.items) {\n  		len = this.items.length;\n  		for (i = 0; i < len; i += 1) {\n  			item = this.items[i];\n\n  			if (item.findAll) {\n  				item.findAll(selector, query);\n  			}\n  		}\n  	}\n\n  	return query;\n  }\n\n  var Fragment_prototype_findAllComponents = Fragment$findAllComponents;\n\n  function Fragment$findAllComponents(selector, query) {\n  	var i, len, item;\n\n  	if (this.items) {\n  		len = this.items.length;\n  		for (i = 0; i < len; i += 1) {\n  			item = this.items[i];\n\n  			if (item.findAllComponents) {\n  				item.findAllComponents(selector, query);\n  			}\n  		}\n  	}\n\n  	return query;\n  }\n\n  var Fragment_prototype_findComponent = Fragment$findComponent;\n\n  function Fragment$findComponent(selector) {\n  	var len, i, item, queryResult;\n\n  	if (this.items) {\n  		len = this.items.length;\n  		for (i = 0; i < len; i += 1) {\n  			item = this.items[i];\n\n  			if (item.findComponent && (queryResult = item.findComponent(selector))) {\n  				return queryResult;\n  			}\n  		}\n\n  		return null;\n  	}\n  }\n\n  var prototype_findNextNode = Fragment$findNextNode;\n\n  function Fragment$findNextNode(item) {\n  	var index = item.index,\n  	    node;\n\n  	if (this.items[index + 1]) {\n  		node = this.items[index + 1].firstNode();\n  	}\n\n  	// if this is the root fragment, and there are no more items,\n  	// it means we\'re at the end...\n  	else if (this.owner === this.root) {\n  		if (!this.owner.component) {\n  			// TODO but something else could have been appended to\n  			// this.root.el, no?\n  			node = null;\n  		}\n\n  		// ...unless this is a component\n  		else {\n  			node = this.owner.component.findNextNode();\n  		}\n  	} else {\n  		node = this.owner.findNextNode(this);\n  	}\n\n  	return node;\n  }\n\n  var prototype_firstNode = Fragment$firstNode;\n\n  function Fragment$firstNode() {\n  	if (this.items && this.items[0]) {\n  		return this.items[0].firstNode();\n  	}\n\n  	return null;\n  }\n\n  var shared_processItems = processItems;\n\n  function processItems(items, values, guid, counter) {\n  	counter = counter || 0;\n\n  	return items.map(function (item) {\n  		var placeholderId, wrapped, value;\n\n  		if (item.text) {\n  			return item.text;\n  		}\n\n  		if (item.fragments) {\n  			return item.fragments.map(function (fragment) {\n  				return processItems(fragment.items, values, guid, counter);\n  			}).join("");\n  		}\n\n  		placeholderId = guid + "-" + counter++;\n\n  		if (item.keypath && (wrapped = item.root.viewmodel.wrapped[item.keypath.str])) {\n  			value = wrapped.value;\n  		} else {\n  			value = item.getValue();\n  		}\n\n  		values[placeholderId] = value;\n\n  		return "${" + placeholderId + "}";\n  	}).join("");\n  }\n\n  var getArgsList = Fragment$getArgsList;\n  function Fragment$getArgsList() {\n  	var values, source, parsed, result;\n\n  	if (this.dirtyArgs) {\n  		source = shared_processItems(this.items, values = {}, this.root._guid);\n  		parsed = parseJSON("[" + source + "]", values);\n\n  		if (!parsed) {\n  			result = [this.toString()];\n  		} else {\n  			result = parsed.value;\n  		}\n\n  		this.argsList = result;\n  		this.dirtyArgs = false;\n  	}\n\n  	return this.argsList;\n  }\n\n  var getNode = Fragment$getNode;\n\n  function Fragment$getNode() {\n  	var fragment = this;\n\n  	do {\n  		if (fragment.pElement) {\n  			return fragment.pElement.node;\n  		}\n  	} while (fragment = fragment.parent);\n\n  	return this.root.detached || this.root.el;\n  }\n\n  var prototype_getValue = Fragment$getValue;\n  function Fragment$getValue() {\n  	var values, source, parsed, result;\n\n  	if (this.dirtyValue) {\n  		source = shared_processItems(this.items, values = {}, this.root._guid);\n  		parsed = parseJSON(source, values);\n\n  		if (!parsed) {\n  			result = this.toString();\n  		} else {\n  			result = parsed.value;\n  		}\n\n  		this.value = result;\n  		this.dirtyValue = false;\n  	}\n\n  	return this.value;\n  }\n\n  var shared_detach = function () {\n  	return detachNode(this.node);\n  };\n\n  var Text = function (options) {\n  	this.type = TEXT;\n  	this.text = options.template;\n  };\n\n  Text.prototype = {\n  	detach: shared_detach,\n\n  	firstNode: function () {\n  		return this.node;\n  	},\n\n  	render: function () {\n  		if (!this.node) {\n  			this.node = document.createTextNode(this.text);\n  		}\n\n  		return this.node;\n  	},\n\n  	toString: function (escape) {\n  		return escape ? escapeHtml(this.text) : this.text;\n  	},\n\n  	unrender: function (shouldDestroy) {\n  		if (shouldDestroy) {\n  			return this.detach();\n  		}\n  	}\n  };\n\n  var items_Text = Text;\n\n  var shared_unbind = shared_unbind__unbind;\n\n  function shared_unbind__unbind() {\n  	if (this.registered) {\n  		// this was registered as a dependant\n  		this.root.viewmodel.unregister(this.keypath, this);\n  	}\n\n  	if (this.resolver) {\n  		this.resolver.unbind();\n  	}\n  }\n\n  var Mustache_getValue = Mustache$getValue;\n\n  function Mustache$getValue() {\n  	return this.value;\n  }\n\n  var ReferenceResolver = function (owner, ref, callback) {\n  	var keypath;\n\n  	this.ref = ref;\n  	this.resolved = false;\n\n  	this.root = owner.root;\n  	this.parentFragment = owner.parentFragment;\n  	this.callback = callback;\n\n  	keypath = shared_resolveRef(owner.root, ref, owner.parentFragment);\n  	if (keypath != undefined) {\n  		this.resolve(keypath);\n  	} else {\n  		global_runloop.addUnresolved(this);\n  	}\n  };\n\n  ReferenceResolver.prototype = {\n  	resolve: function (keypath) {\n  		if (this.keypath && !keypath) {\n  			// it was resolved, and now it\'s not. Can happen if e.g. `bar` in\n  			// `{{foo[bar]}}` becomes undefined\n  			global_runloop.addUnresolved(this);\n  		}\n\n  		this.resolved = true;\n\n  		this.keypath = keypath;\n  		this.callback(keypath);\n  	},\n\n  	forceResolution: function () {\n  		this.resolve(getKeypath(this.ref));\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		var keypath;\n\n  		if (this.keypath != undefined) {\n  			keypath = this.keypath.replace(oldKeypath, newKeypath);\n  			// was a new keypath created?\n  			if (keypath !== undefined) {\n  				// resolve it\n  				this.resolve(keypath);\n  			}\n  		}\n  	},\n\n  	unbind: function () {\n  		if (!this.resolved) {\n  			global_runloop.removeUnresolved(this);\n  		}\n  	}\n  };\n\n  var Resolvers_ReferenceResolver = ReferenceResolver;\n\n  var SpecialResolver = function (owner, ref, callback) {\n  	this.parentFragment = owner.parentFragment;\n  	this.ref = ref;\n  	this.callback = callback;\n\n  	this.rebind();\n  };\n\n  var props = {\n  	"@keypath": { prefix: "c", prop: ["context"] },\n  	"@index": { prefix: "i", prop: ["index"] },\n  	"@key": { prefix: "k", prop: ["key", "index"] }\n  };\n\n  function getProp(target, prop) {\n  	var value;\n  	for (var i = 0; i < prop.prop.length; i++) {\n  		if ((value = target[prop.prop[i]]) !== undefined) {\n  			return value;\n  		}\n  	}\n  }\n\n  SpecialResolver.prototype = {\n  	rebind: function () {\n  		var ref = this.ref,\n  		    fragment = this.parentFragment,\n  		    prop = props[ref],\n  		    value;\n\n  		if (!prop) {\n  			throw new Error("Unknown special reference \\"" + ref + "\\" - valid references are @index, @key and @keypath");\n  		}\n\n  		// have we already found the nearest parent?\n  		if (this.cached) {\n  			return this.callback(getKeypath("@" + prop.prefix + getProp(this.cached, prop)));\n  		}\n\n  		// special case for indices, which may cross component boundaries\n  		if (prop.prop.indexOf("index") !== -1 || prop.prop.indexOf("key") !== -1) {\n  			while (fragment) {\n  				if (fragment.owner.currentSubtype === SECTION_EACH && (value = getProp(fragment, prop)) !== undefined) {\n  					this.cached = fragment;\n\n  					fragment.registerIndexRef(this);\n\n  					return this.callback(getKeypath("@" + prop.prefix + value));\n  				}\n\n  				// watch for component boundaries\n  				if (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {\n  					fragment = fragment.owner.component.parentFragment;\n  				} else {\n  					fragment = fragment.parent;\n  				}\n  			}\n  		} else {\n  			while (fragment) {\n  				if ((value = getProp(fragment, prop)) !== undefined) {\n  					return this.callback(getKeypath("@" + prop.prefix + value.str));\n  				}\n\n  				fragment = fragment.parent;\n  			}\n  		}\n  	},\n\n  	unbind: function () {\n  		if (this.cached) {\n  			this.cached.unregisterIndexRef(this);\n  		}\n  	}\n  };\n\n  var Resolvers_SpecialResolver = SpecialResolver;\n\n  var IndexResolver = function (owner, ref, callback) {\n  	this.parentFragment = owner.parentFragment;\n  	this.ref = ref;\n  	this.callback = callback;\n\n  	ref.ref.fragment.registerIndexRef(this);\n\n  	this.rebind();\n  };\n\n  IndexResolver.prototype = {\n  	rebind: function () {\n  		var index,\n  		    ref = this.ref.ref;\n\n  		if (ref.ref.t === "k") {\n  			index = "k" + ref.fragment.key;\n  		} else {\n  			index = "i" + ref.fragment.index;\n  		}\n\n  		if (index !== undefined) {\n  			this.callback(getKeypath("@" + index));\n  		}\n  	},\n\n  	unbind: function () {\n  		this.ref.ref.fragment.unregisterIndexRef(this);\n  	}\n  };\n\n  var Resolvers_IndexResolver = IndexResolver;\n\n  var Resolvers_findIndexRefs = findIndexRefs;\n\n  function findIndexRefs(fragment, refName) {\n  	var result = {},\n  	    refs,\n  	    fragRefs,\n  	    ref,\n  	    i,\n  	    owner,\n  	    hit = false;\n\n  	if (!refName) {\n  		result.refs = refs = {};\n  	}\n\n  	while (fragment) {\n  		if ((owner = fragment.owner) && (fragRefs = owner.indexRefs)) {\n\n  			// we\'re looking for a particular ref, and it\'s here\n  			if (refName && (ref = owner.getIndexRef(refName))) {\n  				result.ref = {\n  					fragment: fragment,\n  					ref: ref\n  				};\n  				return result;\n  			}\n\n  			// we\'re collecting refs up-tree\n  			else if (!refName) {\n  				for (i in fragRefs) {\n  					ref = fragRefs[i];\n\n  					// don\'t overwrite existing refs - they should shadow parents\n  					if (!refs[ref.n]) {\n  						hit = true;\n  						refs[ref.n] = {\n  							fragment: fragment,\n  							ref: ref\n  						};\n  					}\n  				}\n  			}\n  		}\n\n  		// watch for component boundaries\n  		if (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {\n  			result.componentBoundary = true;\n  			fragment = fragment.owner.component.parentFragment;\n  		} else {\n  			fragment = fragment.parent;\n  		}\n  	}\n\n  	if (!hit) {\n  		return undefined;\n  	} else {\n  		return result;\n  	}\n  }\n\n  findIndexRefs.resolve = function resolve(indices) {\n  	var refs = {},\n  	    k,\n  	    ref;\n\n  	for (k in indices.refs) {\n  		ref = indices.refs[k];\n  		refs[ref.ref.n] = ref.ref.t === "k" ? ref.fragment.key : ref.fragment.index;\n  	}\n\n  	return refs;\n  };\n\n  var Resolvers_createReferenceResolver = createReferenceResolver;\n  function createReferenceResolver(owner, ref, callback) {\n  	var indexRef;\n\n  	if (ref.charAt(0) === "@") {\n  		return new Resolvers_SpecialResolver(owner, ref, callback);\n  	}\n\n  	if (indexRef = Resolvers_findIndexRefs(owner.parentFragment, ref)) {\n  		return new Resolvers_IndexResolver(owner, indexRef, callback);\n  	}\n\n  	return new Resolvers_ReferenceResolver(owner, ref, callback);\n  }\n\n  var shared_getFunctionFromString = getFunctionFromString;\n  var cache = {};\n  function getFunctionFromString(str, i) {\n  	var fn, args;\n\n  	if (cache[str]) {\n  		return cache[str];\n  	}\n\n  	args = [];\n  	while (i--) {\n  		args[i] = "_" + i;\n  	}\n\n  	fn = new Function(args.join(","), "return(" + str + ")");\n\n  	cache[str] = fn;\n  	return fn;\n  }\n\n  var ExpressionResolver,\n      Resolvers_ExpressionResolver__bind = Function.prototype.bind;\n\n  ExpressionResolver = function (owner, parentFragment, expression, callback) {\n  	var _this = this;\n\n  	var ractive;\n\n  	ractive = owner.root;\n\n  	this.root = ractive;\n  	this.parentFragment = parentFragment;\n  	this.callback = callback;\n  	this.owner = owner;\n  	this.str = expression.s;\n  	this.keypaths = [];\n\n  	// Create resolvers for each reference\n  	this.pending = expression.r.length;\n  	this.refResolvers = expression.r.map(function (ref, i) {\n  		return Resolvers_createReferenceResolver(_this, ref, function (keypath) {\n  			_this.resolve(i, keypath);\n  		});\n  	});\n\n  	this.ready = true;\n  	this.bubble();\n  };\n\n  ExpressionResolver.prototype = {\n  	bubble: function () {\n  		if (!this.ready) {\n  			return;\n  		}\n\n  		this.uniqueString = getUniqueString(this.str, this.keypaths);\n  		this.keypath = createExpressionKeypath(this.uniqueString);\n\n  		this.createEvaluator();\n  		this.callback(this.keypath);\n  	},\n\n  	unbind: function () {\n  		var resolver;\n\n  		while (resolver = this.refResolvers.pop()) {\n  			resolver.unbind();\n  		}\n  	},\n\n  	resolve: function (index, keypath) {\n  		this.keypaths[index] = keypath;\n  		this.bubble();\n  	},\n\n  	createEvaluator: function () {\n  		var _this = this;\n\n  		var computation, valueGetters, signature, keypath, fn;\n\n  		keypath = this.keypath;\n  		computation = this.root.viewmodel.computations[keypath.str];\n\n  		// only if it doesn\'t exist yet!\n  		if (!computation) {\n  			fn = shared_getFunctionFromString(this.str, this.refResolvers.length);\n\n  			valueGetters = this.keypaths.map(function (keypath) {\n  				var value;\n\n  				if (keypath === "undefined") {\n  					return function () {\n  						return undefined;\n  					};\n  				}\n\n  				// \'special\' keypaths encode a value\n  				if (keypath.isSpecial) {\n  					value = keypath.value;\n  					return function () {\n  						return value;\n  					};\n  				}\n\n  				return function () {\n  					var value = _this.root.viewmodel.get(keypath, { noUnwrap: true, fullRootGet: true });\n  					if (typeof value === "function") {\n  						value = wrapFunction(value, _this.root);\n  					}\n  					return value;\n  				};\n  			});\n\n  			signature = {\n  				deps: this.keypaths.filter(isValidDependency),\n  				getter: function () {\n  					var args = valueGetters.map(call);\n  					return fn.apply(null, args);\n  				}\n  			};\n\n  			computation = this.root.viewmodel.compute(keypath, signature);\n  		} else {\n  			this.root.viewmodel.mark(keypath);\n  		}\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		// TODO only bubble once, no matter how many references are affected by the rebind\n  		this.refResolvers.forEach(function (r) {\n  			return r.rebind(oldKeypath, newKeypath);\n  		});\n  	}\n  };\n\n  var Resolvers_ExpressionResolver = ExpressionResolver;\n\n  function call(value) {\n  	return value.call();\n  }\n\n  function getUniqueString(str, keypaths) {\n  	// get string that is unique to this expression\n  	return str.replace(/_([0-9]+)/g, function (match, $1) {\n  		var keypath, value;\n\n  		// make sure we\'re not replacing a non-keypath _[0-9]\n  		if (+$1 >= keypaths.length) {\n  			return "_" + $1;\n  		}\n\n  		keypath = keypaths[$1];\n\n  		if (keypath === undefined) {\n  			return "undefined";\n  		}\n\n  		if (keypath.isSpecial) {\n  			value = keypath.value;\n  			return typeof value === "number" ? value : "\\"" + value + "\\"";\n  		}\n\n  		return keypath.str;\n  	});\n  }\n\n  function createExpressionKeypath(uniqueString) {\n  	// Sanitize by removing any periods or square brackets. Otherwise\n  	// we can\'t split the keypath into keys!\n  	// Remove asterisks too, since they mess with pattern observers\n  	return getKeypath("${" + uniqueString.replace(/[\\.\\[\\]]/g, "-").replace(/\\*/, "#MUL#") + "}");\n  }\n\n  function isValidDependency(keypath) {\n  	return keypath !== undefined && keypath[0] !== "@";\n  }\n\n  function wrapFunction(fn, ractive) {\n  	var wrapped, prop, key;\n\n  	if (fn.__ractive_nowrap) {\n  		return fn;\n  	}\n\n  	prop = "__ractive_" + ractive._guid;\n  	wrapped = fn[prop];\n\n  	if (wrapped) {\n  		return wrapped;\n  	} else if (/this/.test(fn.toString())) {\n  		defineProperty(fn, prop, {\n  			value: Resolvers_ExpressionResolver__bind.call(fn, ractive),\n  			configurable: true\n  		});\n\n  		// Add properties/methods to wrapped function\n  		for (key in fn) {\n  			if (fn.hasOwnProperty(key)) {\n  				fn[prop][key] = fn[key];\n  			}\n  		}\n\n  		ractive._boundFunctions.push({\n  			fn: fn,\n  			prop: prop\n  		});\n\n  		return fn[prop];\n  	}\n\n  	defineProperty(fn, "__ractive_nowrap", {\n  		value: fn\n  	});\n\n  	return fn.__ractive_nowrap;\n  }\n\n  var MemberResolver = function (template, resolver, parentFragment) {\n  	var _this = this;\n\n  	this.resolver = resolver;\n  	this.root = resolver.root;\n  	this.parentFragment = parentFragment;\n  	this.viewmodel = resolver.root.viewmodel;\n\n  	if (typeof template === "string") {\n  		this.value = template;\n  	}\n\n  	// Simple reference?\n  	else if (template.t === REFERENCE) {\n  		this.refResolver = Resolvers_createReferenceResolver(this, template.n, function (keypath) {\n  			_this.resolve(keypath);\n  		});\n  	}\n\n  	// Otherwise we have an expression in its own right\n  	else {\n  		new Resolvers_ExpressionResolver(resolver, parentFragment, template, function (keypath) {\n  			_this.resolve(keypath);\n  		});\n  	}\n  };\n\n  MemberResolver.prototype = {\n  	resolve: function (keypath) {\n  		if (this.keypath) {\n  			this.viewmodel.unregister(this.keypath, this);\n  		}\n\n  		this.keypath = keypath;\n  		this.value = this.viewmodel.get(keypath);\n\n  		this.bind();\n\n  		this.resolver.bubble();\n  	},\n\n  	bind: function () {\n  		this.viewmodel.register(this.keypath, this);\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		if (this.refResolver) {\n  			this.refResolver.rebind(oldKeypath, newKeypath);\n  		}\n  	},\n\n  	setValue: function (value) {\n  		this.value = value;\n  		this.resolver.bubble();\n  	},\n\n  	unbind: function () {\n  		if (this.keypath) {\n  			this.viewmodel.unregister(this.keypath, this);\n  		}\n\n  		if (this.refResolver) {\n  			this.refResolver.unbind();\n  		}\n  	},\n\n  	forceResolution: function () {\n  		if (this.refResolver) {\n  			this.refResolver.forceResolution();\n  		}\n  	}\n  };\n\n  var ReferenceExpressionResolver_MemberResolver = MemberResolver;\n\n  var ReferenceExpressionResolver = function (mustache, template, callback) {\n  	var _this = this;\n\n  	var ractive, ref, keypath, parentFragment;\n\n  	this.parentFragment = parentFragment = mustache.parentFragment;\n  	this.root = ractive = mustache.root;\n  	this.mustache = mustache;\n\n  	this.ref = ref = template.r;\n  	this.callback = callback;\n\n  	this.unresolved = [];\n\n  	// Find base keypath\n  	if (keypath = shared_resolveRef(ractive, ref, parentFragment)) {\n  		this.base = keypath;\n  	} else {\n  		this.baseResolver = new Resolvers_ReferenceResolver(this, ref, function (keypath) {\n  			_this.base = keypath;\n  			_this.baseResolver = null;\n  			_this.bubble();\n  		});\n  	}\n\n  	// Find values for members, or mark them as unresolved\n  	this.members = template.m.map(function (template) {\n  		return new ReferenceExpressionResolver_MemberResolver(template, _this, parentFragment);\n  	});\n\n  	this.ready = true;\n  	this.bubble(); // trigger initial resolution if possible\n  };\n\n  ReferenceExpressionResolver.prototype = {\n  	getKeypath: function () {\n  		var values = this.members.map(ReferenceExpressionResolver_ReferenceExpressionResolver__getValue);\n\n  		if (!values.every(isDefined) || this.baseResolver) {\n  			return null;\n  		}\n\n  		return this.base.join(values.join("."));\n  	},\n\n  	bubble: function () {\n  		if (!this.ready || this.baseResolver) {\n  			return;\n  		}\n\n  		this.callback(this.getKeypath());\n  	},\n\n  	unbind: function () {\n  		this.members.forEach(methodCallers__unbind);\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		var changed;\n\n  		if (this.base) {\n  			var newBase = this.base.replace(oldKeypath, newKeypath);\n  			if (newBase && newBase !== this.base) {\n  				this.base = newBase;\n  				changed = true;\n  			}\n  		}\n\n  		this.members.forEach(function (members) {\n  			if (members.rebind(oldKeypath, newKeypath)) {\n  				changed = true;\n  			}\n  		});\n\n  		if (changed) {\n  			this.bubble();\n  		}\n  	},\n\n  	forceResolution: function () {\n  		if (this.baseResolver) {\n  			this.base = getKeypath(this.ref);\n\n  			this.baseResolver.unbind();\n  			this.baseResolver = null;\n  		}\n\n  		this.members.forEach(forceResolution);\n  		this.bubble();\n  	}\n  };\n\n  function ReferenceExpressionResolver_ReferenceExpressionResolver__getValue(member) {\n  	return member.value;\n  }\n\n  function isDefined(value) {\n  	return value != undefined;\n  }\n\n  function forceResolution(member) {\n  	member.forceResolution();\n  }\n\n  var ReferenceExpressionResolver_ReferenceExpressionResolver = ReferenceExpressionResolver;\n\n  var Mustache_initialise = Mustache$init;\n  function Mustache$init(mustache, options) {\n\n  	var ref, parentFragment, template;\n\n  	parentFragment = options.parentFragment;\n  	template = options.template;\n\n  	mustache.root = parentFragment.root;\n  	mustache.parentFragment = parentFragment;\n  	mustache.pElement = parentFragment.pElement;\n\n  	mustache.template = options.template;\n  	mustache.index = options.index || 0;\n  	mustache.isStatic = options.template.s;\n\n  	mustache.type = options.template.t;\n\n  	mustache.registered = false;\n\n  	// if this is a simple mustache, with a reference, we just need to resolve\n  	// the reference to a keypath\n  	if (ref = template.r) {\n  		mustache.resolver = Resolvers_createReferenceResolver(mustache, ref, resolve);\n  	}\n\n  	// if it\'s an expression, we have a bit more work to do\n  	if (options.template.x) {\n  		mustache.resolver = new Resolvers_ExpressionResolver(mustache, parentFragment, options.template.x, resolveAndRebindChildren);\n  	}\n\n  	if (options.template.rx) {\n  		mustache.resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(mustache, options.template.rx, resolveAndRebindChildren);\n  	}\n\n  	// Special case - inverted sections\n  	if (mustache.template.n === SECTION_UNLESS && !mustache.hasOwnProperty("value")) {\n  		mustache.setValue(undefined);\n  	}\n\n  	function resolve(keypath) {\n  		mustache.resolve(keypath);\n  	}\n\n  	function resolveAndRebindChildren(newKeypath) {\n  		var oldKeypath = mustache.keypath;\n\n  		if (newKeypath != oldKeypath) {\n  			mustache.resolve(newKeypath);\n\n  			if (oldKeypath !== undefined) {\n  				mustache.fragments && mustache.fragments.forEach(function (f) {\n  					f.rebind(oldKeypath, newKeypath);\n  				});\n  			}\n  		}\n  	}\n  }\n\n  var Mustache_resolve = Mustache$resolve;\n\n  function Mustache$resolve(keypath) {\n  	var wasResolved, value, twowayBinding;\n\n  	// \'Special\' keypaths, e.g. @foo or @7, encode a value\n  	if (keypath && keypath.isSpecial) {\n  		this.keypath = keypath;\n  		this.setValue(keypath.value);\n  		return;\n  	}\n\n  	// If we resolved previously, we need to unregister\n  	if (this.registered) {\n  		// undefined or null\n  		this.root.viewmodel.unregister(this.keypath, this);\n  		this.registered = false;\n\n  		wasResolved = true;\n  	}\n\n  	this.keypath = keypath;\n\n  	// If the new keypath exists, we need to register\n  	// with the viewmodel\n  	if (keypath != undefined) {\n  		// undefined or null\n  		value = this.root.viewmodel.get(keypath);\n  		this.root.viewmodel.register(keypath, this);\n\n  		this.registered = true;\n  	}\n\n  	// Either way we need to queue up a render (`value`\n  	// will be `undefined` if there\'s no keypath)\n  	this.setValue(value);\n\n  	// Two-way bindings need to point to their new target keypath\n  	if (wasResolved && (twowayBinding = this.twowayBinding)) {\n  		twowayBinding.rebound();\n  	}\n  }\n\n  var Mustache_rebind = Mustache$rebind;\n\n  function Mustache$rebind(oldKeypath, newKeypath) {\n  	// Children first\n  	if (this.fragments) {\n  		this.fragments.forEach(function (f) {\n  			return f.rebind(oldKeypath, newKeypath);\n  		});\n  	}\n\n  	// Expression mustache?\n  	if (this.resolver) {\n  		this.resolver.rebind(oldKeypath, newKeypath);\n  	}\n  }\n\n  var Mustache = {\n  	getValue: Mustache_getValue,\n  	init: Mustache_initialise,\n  	resolve: Mustache_resolve,\n  	rebind: Mustache_rebind\n  };\n\n  var Interpolator = function (options) {\n  	this.type = INTERPOLATOR;\n  	Mustache.init(this, options);\n  };\n\n  Interpolator.prototype = {\n  	update: function () {\n  		this.node.data = this.value == undefined ? "" : this.value;\n  	},\n  	resolve: Mustache.resolve,\n  	rebind: Mustache.rebind,\n  	detach: shared_detach,\n\n  	unbind: shared_unbind,\n\n  	render: function () {\n  		if (!this.node) {\n  			this.node = document.createTextNode(safeToStringValue(this.value));\n  		}\n\n  		return this.node;\n  	},\n\n  	unrender: function (shouldDestroy) {\n  		if (shouldDestroy) {\n  			detachNode(this.node);\n  		}\n  	},\n\n  	getValue: Mustache.getValue,\n\n  	// TEMP\n  	setValue: function (value) {\n  		var wrapper;\n\n  		// TODO is there a better way to approach this?\n  		if (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {\n  			value = wrapper.get();\n  		}\n\n  		if (!isEqual(value, this.value)) {\n  			this.value = value;\n  			this.parentFragment.bubble();\n\n  			if (this.node) {\n  				global_runloop.addView(this);\n  			}\n  		}\n  	},\n\n  	firstNode: function () {\n  		return this.node;\n  	},\n\n  	toString: function (escape) {\n  		var string = "" + safeToStringValue(this.value);\n  		return escape ? escapeHtml(string) : string;\n  	}\n  };\n\n  var items_Interpolator = Interpolator;\n\n  var Section_prototype_bubble = Section$bubble;\n\n  function Section$bubble() {\n  	this.parentFragment.bubble();\n  }\n\n  var Section_prototype_detach = Section$detach;\n\n  function Section$detach() {\n  	var docFrag;\n\n  	if (this.fragments.length === 1) {\n  		return this.fragments[0].detach();\n  	}\n\n  	docFrag = document.createDocumentFragment();\n\n  	this.fragments.forEach(function (item) {\n  		docFrag.appendChild(item.detach());\n  	});\n\n  	return docFrag;\n  }\n\n  var find = Section$find;\n\n  function Section$find(selector) {\n  	var i, len, queryResult;\n\n  	len = this.fragments.length;\n  	for (i = 0; i < len; i += 1) {\n  		if (queryResult = this.fragments[i].find(selector)) {\n  			return queryResult;\n  		}\n  	}\n\n  	return null;\n  }\n\n  var findAll = Section$findAll;\n\n  function Section$findAll(selector, query) {\n  	var i, len;\n\n  	len = this.fragments.length;\n  	for (i = 0; i < len; i += 1) {\n  		this.fragments[i].findAll(selector, query);\n  	}\n  }\n\n  var findAllComponents = Section$findAllComponents;\n\n  function Section$findAllComponents(selector, query) {\n  	var i, len;\n\n  	len = this.fragments.length;\n  	for (i = 0; i < len; i += 1) {\n  		this.fragments[i].findAllComponents(selector, query);\n  	}\n  }\n\n  var findComponent = Section$findComponent;\n\n  function Section$findComponent(selector) {\n  	var i, len, queryResult;\n\n  	len = this.fragments.length;\n  	for (i = 0; i < len; i += 1) {\n  		if (queryResult = this.fragments[i].findComponent(selector)) {\n  			return queryResult;\n  		}\n  	}\n\n  	return null;\n  }\n\n  var findNextNode = Section$findNextNode;\n\n  function Section$findNextNode(fragment) {\n  	if (this.fragments[fragment.index + 1]) {\n  		return this.fragments[fragment.index + 1].firstNode();\n  	}\n\n  	return this.parentFragment.findNextNode(this);\n  }\n\n  var firstNode = Section$firstNode;\n\n  function Section$firstNode() {\n  	var len, i, node;\n\n  	if (len = this.fragments.length) {\n  		for (i = 0; i < len; i += 1) {\n  			if (node = this.fragments[i].firstNode()) {\n  				return node;\n  			}\n  		}\n  	}\n\n  	return this.parentFragment.findNextNode(this);\n  }\n\n  var shuffle = Section$shuffle;\n\n  function Section$shuffle(newIndices) {\n  	var _this = this;\n\n  	var parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;\n\n  	// short circuit any double-updates, and ensure that this isn\'t applied to\n  	// non-list sections\n  	if (this.shuffling || this.unbound || this.currentSubtype !== SECTION_EACH) {\n  		return;\n  	}\n\n  	this.shuffling = true;\n  	global_runloop.scheduleTask(function () {\n  		return _this.shuffling = false;\n  	});\n\n  	parentFragment = this.parentFragment;\n\n  	reboundFragments = [];\n\n  	// TODO: need to update this\n  	// first, rebind existing fragments\n  	newIndices.forEach(function (newIndex, oldIndex) {\n  		var fragment, by, oldKeypath, newKeypath, deps;\n\n  		if (newIndex === oldIndex) {\n  			reboundFragments[newIndex] = _this.fragments[oldIndex];\n  			return;\n  		}\n\n  		fragment = _this.fragments[oldIndex];\n\n  		if (firstChange === undefined) {\n  			firstChange = oldIndex;\n  		}\n\n  		// does this fragment need to be torn down?\n  		if (newIndex === -1) {\n  			_this.fragmentsToUnrender.push(fragment);\n  			fragment.unbind();\n  			return;\n  		}\n\n  		// Otherwise, it needs to be rebound to a new index\n  		by = newIndex - oldIndex;\n  		oldKeypath = _this.keypath.join(oldIndex);\n  		newKeypath = _this.keypath.join(newIndex);\n\n  		fragment.index = newIndex;\n\n  		// notify any registered index refs directly\n  		if (deps = fragment.registeredIndexRefs) {\n  			deps.forEach(shuffle__blindRebind);\n  		}\n\n  		fragment.rebind(oldKeypath, newKeypath);\n  		reboundFragments[newIndex] = fragment;\n  	});\n\n  	newLength = this.root.viewmodel.get(this.keypath).length;\n\n  	// If nothing changed with the existing fragments, then we start adding\n  	// new fragments at the end...\n  	if (firstChange === undefined) {\n  		// ...unless there are no new fragments to add\n  		if (this.length === newLength) {\n  			return;\n  		}\n\n  		firstChange = this.length;\n  	}\n\n  	this.length = this.fragments.length = newLength;\n\n  	if (this.rendered) {\n  		global_runloop.addView(this);\n  	}\n\n  	// Prepare new fragment options\n  	fragmentOptions = {\n  		template: this.template.f,\n  		root: this.root,\n  		owner: this\n  	};\n\n  	// Add as many new fragments as we need to, or add back existing\n  	// (detached) fragments\n  	for (i = firstChange; i < newLength; i += 1) {\n  		fragment = reboundFragments[i];\n\n  		if (!fragment) {\n  			this.fragmentsToCreate.push(i);\n  		}\n\n  		this.fragments[i] = fragment;\n  	}\n  }\n\n  function shuffle__blindRebind(dep) {\n  	// the keypath doesn\'t actually matter here as it won\'t have changed\n  	dep.rebind("", "");\n  }\n\n  var prototype_rebind = function (oldKeypath, newKeypath) {\n  	Mustache.rebind.call(this, oldKeypath, newKeypath);\n  };\n\n  var Section_prototype_render = Section$render;\n\n  function Section$render() {\n  	var _this = this;\n\n  	this.docFrag = document.createDocumentFragment();\n\n  	this.fragments.forEach(function (f) {\n  		return _this.docFrag.appendChild(f.render());\n  	});\n\n  	this.renderedFragments = this.fragments.slice();\n  	this.fragmentsToRender = [];\n\n  	this.rendered = true;\n  	return this.docFrag;\n  }\n\n  var setValue = Section$setValue;\n\n  function Section$setValue(value) {\n  	var _this = this;\n\n  	var wrapper, fragmentOptions;\n\n  	if (this.updating) {\n  		// If a child of this section causes a re-evaluation - for example, an\n  		// expression refers to a function that mutates the array that this\n  		// section depends on - we\'ll end up with a double rendering bug (see\n  		// https://github.com/ractivejs/ractive/issues/748). This prevents it.\n  		return;\n  	}\n\n  	this.updating = true;\n\n  	// with sections, we need to get the fake value if we have a wrapped object\n  	if (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {\n  		value = wrapper.get();\n  	}\n\n  	// If any fragments are awaiting creation after a splice,\n  	// this is the place to do it\n  	if (this.fragmentsToCreate.length) {\n  		fragmentOptions = {\n  			template: this.template.f || [],\n  			root: this.root,\n  			pElement: this.pElement,\n  			owner: this\n  		};\n\n  		this.fragmentsToCreate.forEach(function (index) {\n  			var fragment;\n\n  			fragmentOptions.context = _this.keypath.join(index);\n  			fragmentOptions.index = index;\n\n  			fragment = new virtualdom_Fragment(fragmentOptions);\n  			_this.fragmentsToRender.push(_this.fragments[index] = fragment);\n  		});\n\n  		this.fragmentsToCreate.length = 0;\n  	} else if (reevaluateSection(this, value)) {\n  		this.bubble();\n\n  		if (this.rendered) {\n  			global_runloop.addView(this);\n  		}\n  	}\n\n  	this.value = value;\n  	this.updating = false;\n  }\n\n  function changeCurrentSubtype(section, value, obj) {\n  	if (value === SECTION_EACH) {\n  		// make sure ref type is up to date for key or value indices\n  		if (section.indexRefs && section.indexRefs[0]) {\n  			var ref = section.indexRefs[0];\n\n  			// when switching flavors, make sure the section gets updated\n  			if (obj && ref.t === "i" || !obj && ref.t === "k") {\n  				// if switching from object to list, unbind all of the old fragments\n  				if (!obj) {\n  					section.length = 0;\n  					section.fragmentsToUnrender = section.fragments.slice(0);\n  					section.fragmentsToUnrender.forEach(function (f) {\n  						return f.unbind();\n  					});\n  				}\n  			}\n\n  			ref.t = obj ? "k" : "i";\n  		}\n  	}\n\n  	section.currentSubtype = value;\n  }\n\n  function reevaluateSection(section, value) {\n  	var fragmentOptions = {\n  		template: section.template.f || [],\n  		root: section.root,\n  		pElement: section.parentFragment.pElement,\n  		owner: section\n  	};\n\n  	section.hasContext = true;\n\n  	// If we already know the section type, great\n  	// TODO can this be optimised? i.e. pick an reevaluateSection function during init\n  	// and avoid doing this each time?\n  	if (section.subtype) {\n  		switch (section.subtype) {\n  			case SECTION_IF:\n  				section.hasContext = false;\n  				return reevaluateConditionalSection(section, value, false, fragmentOptions);\n\n  			case SECTION_UNLESS:\n  				section.hasContext = false;\n  				return reevaluateConditionalSection(section, value, true, fragmentOptions);\n\n  			case SECTION_WITH:\n  				return reevaluateContextSection(section, fragmentOptions);\n\n  			case SECTION_IF_WITH:\n  				return reevaluateConditionalContextSection(section, value, fragmentOptions);\n\n  			case SECTION_EACH:\n  				if (isObject(value)) {\n  					changeCurrentSubtype(section, section.subtype, true);\n  					return reevaluateListObjectSection(section, value, fragmentOptions);\n  				}\n\n  				// Fallthrough - if it\'s a conditional or an array we need to continue\n  		}\n  	}\n\n  	// Otherwise we need to work out what sort of section we\'re dealing with\n  	section.ordered = !!isArrayLike(value);\n\n  	// Ordered list section\n  	if (section.ordered) {\n  		changeCurrentSubtype(section, SECTION_EACH, false);\n  		return reevaluateListSection(section, value, fragmentOptions);\n  	}\n\n  	// Unordered list, or context\n  	if (isObject(value) || typeof value === "function") {\n  		// Index reference indicates section should be treated as a list\n  		if (section.template.i) {\n  			changeCurrentSubtype(section, SECTION_EACH, true);\n  			return reevaluateListObjectSection(section, value, fragmentOptions);\n  		}\n\n  		// Otherwise, object provides context for contents\n  		changeCurrentSubtype(section, SECTION_WITH, false);\n  		return reevaluateContextSection(section, fragmentOptions);\n  	}\n\n  	// Conditional section\n  	changeCurrentSubtype(section, SECTION_IF, false);\n  	section.hasContext = false;\n  	return reevaluateConditionalSection(section, value, false, fragmentOptions);\n  }\n\n  function reevaluateListSection(section, value, fragmentOptions) {\n  	var i, length, fragment;\n\n  	length = value.length;\n\n  	if (length === section.length) {\n  		// Nothing to do\n  		return false;\n  	}\n\n  	// if the array is shorter than it was previously, remove items\n  	if (length < section.length) {\n  		section.fragmentsToUnrender = section.fragments.splice(length, section.length - length);\n  		section.fragmentsToUnrender.forEach(methodCallers__unbind);\n  	}\n\n  	// otherwise...\n  	else {\n  		if (length > section.length) {\n  			// add any new ones\n  			for (i = section.length; i < length; i += 1) {\n  				// append list item to context stack\n  				fragmentOptions.context = section.keypath.join(i);\n  				fragmentOptions.index = i;\n\n  				fragment = new virtualdom_Fragment(fragmentOptions);\n  				section.fragmentsToRender.push(section.fragments[i] = fragment);\n  			}\n  		}\n  	}\n\n  	section.length = length;\n  	return true;\n  }\n\n  function reevaluateListObjectSection(section, value, fragmentOptions) {\n  	var id, i, hasKey, fragment, changed, deps;\n\n  	hasKey = section.hasKey || (section.hasKey = {});\n\n  	// remove any fragments that should no longer exist\n  	i = section.fragments.length;\n  	while (i--) {\n  		fragment = section.fragments[i];\n\n  		if (!(fragment.key in value)) {\n  			changed = true;\n\n  			fragment.unbind();\n  			section.fragmentsToUnrender.push(fragment);\n  			section.fragments.splice(i, 1);\n\n  			hasKey[fragment.key] = false;\n  		}\n  	}\n\n  	// notify any dependents about changed indices\n  	i = section.fragments.length;\n  	while (i--) {\n  		fragment = section.fragments[i];\n\n  		if (fragment.index !== i) {\n  			fragment.index = i;\n  			if (deps = fragment.registeredIndexRefs) {\n  				deps.forEach(setValue__blindRebind);\n  			}\n  		}\n  	}\n\n  	// add any that haven\'t been created yet\n  	i = section.fragments.length;\n  	for (id in value) {\n  		if (!hasKey[id]) {\n  			changed = true;\n\n  			fragmentOptions.context = section.keypath.join(id);\n  			fragmentOptions.key = id;\n  			fragmentOptions.index = i++;\n\n  			fragment = new virtualdom_Fragment(fragmentOptions);\n\n  			section.fragmentsToRender.push(fragment);\n  			section.fragments.push(fragment);\n  			hasKey[id] = true;\n  		}\n  	}\n\n  	section.length = section.fragments.length;\n  	return changed;\n  }\n\n  function reevaluateConditionalContextSection(section, value, fragmentOptions) {\n  	if (value) {\n  		return reevaluateContextSection(section, fragmentOptions);\n  	} else {\n  		return removeSectionFragments(section);\n  	}\n  }\n\n  function reevaluateContextSection(section, fragmentOptions) {\n  	var fragment;\n\n  	// ...then if it isn\'t rendered, render it, adding section.keypath to the context stack\n  	// (if it is already rendered, then any children dependent on the context stack\n  	// will update themselves without any prompting)\n  	if (!section.length) {\n  		// append this section to the context stack\n  		fragmentOptions.context = section.keypath;\n  		fragmentOptions.index = 0;\n\n  		fragment = new virtualdom_Fragment(fragmentOptions);\n\n  		section.fragmentsToRender.push(section.fragments[0] = fragment);\n  		section.length = 1;\n\n  		return true;\n  	}\n  }\n\n  function reevaluateConditionalSection(section, value, inverted, fragmentOptions) {\n  	var doRender, emptyArray, emptyObject, fragment, name;\n\n  	emptyArray = isArrayLike(value) && value.length === 0;\n  	emptyObject = false;\n  	if (!isArrayLike(value) && isObject(value)) {\n  		emptyObject = true;\n  		for (name in value) {\n  			emptyObject = false;\n  			break;\n  		}\n  	}\n\n  	if (inverted) {\n  		doRender = emptyArray || emptyObject || !value;\n  	} else {\n  		doRender = value && !emptyArray && !emptyObject;\n  	}\n\n  	if (doRender) {\n  		if (!section.length) {\n  			// no change to context stack\n  			fragmentOptions.index = 0;\n\n  			fragment = new virtualdom_Fragment(fragmentOptions);\n  			section.fragmentsToRender.push(section.fragments[0] = fragment);\n  			section.length = 1;\n\n  			return true;\n  		}\n\n  		if (section.length > 1) {\n  			section.fragmentsToUnrender = section.fragments.splice(1);\n  			section.fragmentsToUnrender.forEach(methodCallers__unbind);\n\n  			return true;\n  		}\n  	} else {\n  		return removeSectionFragments(section);\n  	}\n  }\n\n  function removeSectionFragments(section) {\n  	if (section.length) {\n  		section.fragmentsToUnrender = section.fragments.splice(0, section.fragments.length).filter(isRendered);\n  		section.fragmentsToUnrender.forEach(methodCallers__unbind);\n  		section.length = section.fragmentsToRender.length = 0;\n  		return true;\n  	}\n  }\n\n  function isRendered(fragment) {\n  	return fragment.rendered;\n  }\n\n  function setValue__blindRebind(dep) {\n  	// the keypath doesn\'t actually matter here as it won\'t have changed\n  	dep.rebind("", "");\n  }\n\n  var prototype_toString = Section$toString;\n\n  function Section$toString(escape) {\n  	var str, i, len;\n\n  	str = "";\n\n  	i = 0;\n  	len = this.length;\n\n  	for (i = 0; i < len; i += 1) {\n  		str += this.fragments[i].toString(escape);\n  	}\n\n  	return str;\n  }\n\n  var prototype_unbind = Section$unbind;\n  function Section$unbind() {\n  	var _this = this;\n\n  	this.fragments.forEach(methodCallers__unbind);\n  	this.fragmentsToRender.forEach(function (f) {\n  		return removeFromArray(_this.fragments, f);\n  	});\n  	this.fragmentsToRender = [];\n  	shared_unbind.call(this);\n\n  	this.length = 0;\n  	this.unbound = true;\n  }\n\n  var prototype_unrender = Section$unrender;\n\n  function Section$unrender(shouldDestroy) {\n  	this.fragments.forEach(shouldDestroy ? unrenderAndDestroy : prototype_unrender__unrender);\n  	this.renderedFragments = [];\n  	this.rendered = false;\n  }\n\n  function unrenderAndDestroy(fragment) {\n  	fragment.unrender(true);\n  }\n\n  function prototype_unrender__unrender(fragment) {\n  	fragment.unrender(false);\n  }\n\n  var prototype_update = Section$update;\n\n  function Section$update() {\n  	var fragment, renderIndex, renderedFragments, anchor, target, i, len;\n\n  	// `this.renderedFragments` is in the order of the previous render.\n  	// If fragments have shuffled about, this allows us to quickly\n  	// reinsert them in the correct place\n  	renderedFragments = this.renderedFragments;\n\n  	// Remove fragments that have been marked for destruction\n  	while (fragment = this.fragmentsToUnrender.pop()) {\n  		fragment.unrender(true);\n  		renderedFragments.splice(renderedFragments.indexOf(fragment), 1);\n  	}\n\n  	// Render new fragments (but don\'t insert them yet)\n  	while (fragment = this.fragmentsToRender.shift()) {\n  		fragment.render();\n  	}\n\n  	if (this.rendered) {\n  		target = this.parentFragment.getNode();\n  	}\n\n  	len = this.fragments.length;\n  	for (i = 0; i < len; i += 1) {\n  		fragment = this.fragments[i];\n  		renderIndex = renderedFragments.indexOf(fragment, i); // search from current index - it\'s guaranteed to be the same or higher\n\n  		if (renderIndex === i) {\n  			// already in the right place. insert accumulated nodes (if any) and carry on\n  			if (this.docFrag.childNodes.length) {\n  				anchor = fragment.firstNode();\n  				target.insertBefore(this.docFrag, anchor);\n  			}\n\n  			continue;\n  		}\n\n  		this.docFrag.appendChild(fragment.detach());\n\n  		// update renderedFragments\n  		if (renderIndex !== -1) {\n  			renderedFragments.splice(renderIndex, 1);\n  		}\n  		renderedFragments.splice(i, 0, fragment);\n  	}\n\n  	if (this.rendered && this.docFrag.childNodes.length) {\n  		anchor = this.parentFragment.findNextNode(this);\n  		target.insertBefore(this.docFrag, anchor);\n  	}\n\n  	// Save the rendering order for next time\n  	this.renderedFragments = this.fragments.slice();\n  }\n\n  var Section = function (options) {\n  	this.type = SECTION;\n  	this.subtype = this.currentSubtype = options.template.n;\n  	this.inverted = this.subtype === SECTION_UNLESS;\n\n  	this.pElement = options.pElement;\n\n  	this.fragments = [];\n  	this.fragmentsToCreate = [];\n  	this.fragmentsToRender = [];\n  	this.fragmentsToUnrender = [];\n\n  	if (options.template.i) {\n  		this.indexRefs = options.template.i.split(",").map(function (k, i) {\n  			return { n: k, t: i === 0 ? "k" : "i" };\n  		});\n  	}\n\n  	this.renderedFragments = [];\n\n  	this.length = 0; // number of times this section is rendered\n\n  	Mustache.init(this, options);\n  };\n\n  Section.prototype = {\n  	bubble: Section_prototype_bubble,\n  	detach: Section_prototype_detach,\n  	find: find,\n  	findAll: findAll,\n  	findAllComponents: findAllComponents,\n  	findComponent: findComponent,\n  	findNextNode: findNextNode,\n  	firstNode: firstNode,\n  	getIndexRef: function (name) {\n  		if (this.indexRefs) {\n  			var i = this.indexRefs.length;\n  			while (i--) {\n  				var ref = this.indexRefs[i];\n  				if (ref.n === name) {\n  					return ref;\n  				}\n  			}\n  		}\n  	},\n  	getValue: Mustache.getValue,\n  	shuffle: shuffle,\n  	rebind: prototype_rebind,\n  	render: Section_prototype_render,\n  	resolve: Mustache.resolve,\n  	setValue: setValue,\n  	toString: prototype_toString,\n  	unbind: prototype_unbind,\n  	unrender: prototype_unrender,\n  	update: prototype_update\n  };\n\n  var _Section = Section;\n\n  var Triple_prototype_detach = Triple$detach;\n\n  function Triple$detach() {\n  	var len, i;\n\n  	if (this.docFrag) {\n  		len = this.nodes.length;\n  		for (i = 0; i < len; i += 1) {\n  			this.docFrag.appendChild(this.nodes[i]);\n  		}\n\n  		return this.docFrag;\n  	}\n  }\n\n  var Triple_prototype_find = Triple$find;\n  function Triple$find(selector) {\n  	var i, len, node, queryResult;\n\n  	len = this.nodes.length;\n  	for (i = 0; i < len; i += 1) {\n  		node = this.nodes[i];\n\n  		if (node.nodeType !== 1) {\n  			continue;\n  		}\n\n  		if (matches(node, selector)) {\n  			return node;\n  		}\n\n  		if (queryResult = node.querySelector(selector)) {\n  			return queryResult;\n  		}\n  	}\n\n  	return null;\n  }\n\n  var Triple_prototype_findAll = Triple$findAll;\n  function Triple$findAll(selector, queryResult) {\n  	var i, len, node, queryAllResult, numNodes, j;\n\n  	len = this.nodes.length;\n  	for (i = 0; i < len; i += 1) {\n  		node = this.nodes[i];\n\n  		if (node.nodeType !== 1) {\n  			continue;\n  		}\n\n  		if (matches(node, selector)) {\n  			queryResult.push(node);\n  		}\n\n  		if (queryAllResult = node.querySelectorAll(selector)) {\n  			numNodes = queryAllResult.length;\n  			for (j = 0; j < numNodes; j += 1) {\n  				queryResult.push(queryAllResult[j]);\n  			}\n  		}\n  	}\n  }\n\n  var Triple_prototype_firstNode = Triple$firstNode;\n\n  function Triple$firstNode() {\n  	if (this.rendered && this.nodes[0]) {\n  		return this.nodes[0];\n  	}\n\n  	return this.parentFragment.findNextNode(this);\n  }\n\n  var elementCache = {},\n      ieBug,\n      ieBlacklist;\n\n  try {\n  	createElement("table").innerHTML = "foo";\n  } catch (err) {\n  	ieBug = true;\n\n  	ieBlacklist = {\n  		TABLE: ["<table class=\\"x\\">", "</table>"],\n  		THEAD: ["<table><thead class=\\"x\\">", "</thead></table>"],\n  		TBODY: ["<table><tbody class=\\"x\\">", "</tbody></table>"],\n  		TR: ["<table><tr class=\\"x\\">", "</tr></table>"],\n  		SELECT: ["<select class=\\"x\\">", "</select>"]\n  	};\n  }\n\n  var insertHtml = function (html, node, docFrag) {\n  	var container,\n  	    nodes = [],\n  	    wrapper,\n  	    selectedOption,\n  	    child,\n  	    i;\n\n  	// render 0 and false\n  	if (html != null && html !== "") {\n  		if (ieBug && (wrapper = ieBlacklist[node.tagName])) {\n  			container = element("DIV");\n  			container.innerHTML = wrapper[0] + html + wrapper[1];\n  			container = container.querySelector(".x");\n\n  			if (container.tagName === "SELECT") {\n  				selectedOption = container.options[container.selectedIndex];\n  			}\n  		} else if (node.namespaceURI === namespaces.svg) {\n  			container = element("DIV");\n  			container.innerHTML = "<svg class=\\"x\\">" + html + "</svg>";\n  			container = container.querySelector(".x");\n  		} else {\n  			container = element(node.tagName);\n  			container.innerHTML = html;\n\n  			if (container.tagName === "SELECT") {\n  				selectedOption = container.options[container.selectedIndex];\n  			}\n  		}\n\n  		while (child = container.firstChild) {\n  			nodes.push(child);\n  			docFrag.appendChild(child);\n  		}\n\n  		// This is really annoying. Extracting <option> nodes from the\n  		// temporary container <select> causes the remaining ones to\n  		// become selected. So now we have to deselect them. IE8, you\n  		// amaze me. You really do\n  		// ...and now Chrome too\n  		if (node.tagName === "SELECT") {\n  			i = nodes.length;\n  			while (i--) {\n  				if (nodes[i] !== selectedOption) {\n  					nodes[i].selected = false;\n  				}\n  			}\n  		}\n  	}\n\n  	return nodes;\n  };\n\n  function element(tagName) {\n  	return elementCache[tagName] || (elementCache[tagName] = createElement(tagName));\n  }\n\n  var helpers_updateSelect = updateSelect;\n\n  function updateSelect(parentElement) {\n  	var selectedOptions, option, value;\n\n  	if (!parentElement || parentElement.name !== "select" || !parentElement.binding) {\n  		return;\n  	}\n\n  	selectedOptions = toArray(parentElement.node.options).filter(isSelected);\n\n  	// If one of them had a `selected` attribute, we need to sync\n  	// the model to the view\n  	if (parentElement.getAttribute("multiple")) {\n  		value = selectedOptions.map(function (o) {\n  			return o.value;\n  		});\n  	} else if (option = selectedOptions[0]) {\n  		value = option.value;\n  	}\n\n  	if (value !== undefined) {\n  		parentElement.binding.setValue(value);\n  	}\n\n  	parentElement.bubble();\n  }\n\n  function isSelected(option) {\n  	return option.selected;\n  }\n\n  var Triple_prototype_render = Triple$render;\n  function Triple$render() {\n  	if (this.rendered) {\n  		throw new Error("Attempted to render an item that was already rendered");\n  	}\n\n  	this.docFrag = document.createDocumentFragment();\n  	this.nodes = insertHtml(this.value, this.parentFragment.getNode(), this.docFrag);\n\n  	// Special case - we\'re inserting the contents of a <select>\n  	helpers_updateSelect(this.pElement);\n\n  	this.rendered = true;\n  	return this.docFrag;\n  }\n\n  var prototype_setValue = Triple$setValue;\n  function Triple$setValue(value) {\n  	var wrapper;\n\n  	// TODO is there a better way to approach this?\n  	if (wrapper = this.root.viewmodel.wrapped[this.keypath.str]) {\n  		value = wrapper.get();\n  	}\n\n  	if (value !== this.value) {\n  		this.value = value;\n  		this.parentFragment.bubble();\n\n  		if (this.rendered) {\n  			global_runloop.addView(this);\n  		}\n  	}\n  }\n\n  var Triple_prototype_toString = Triple$toString;\n  function Triple$toString() {\n  	return this.value != undefined ? decodeCharacterReferences("" + this.value) : "";\n  }\n\n  var Triple_prototype_unrender = Triple$unrender;\n  function Triple$unrender(shouldDestroy) {\n  	if (this.rendered && shouldDestroy) {\n  		this.nodes.forEach(detachNode);\n  		this.rendered = false;\n  	}\n\n  	// TODO update live queries\n  }\n\n  var Triple_prototype_update = Triple$update;\n  function Triple$update() {\n  	var node, parentNode;\n\n  	if (!this.rendered) {\n  		return;\n  	}\n\n  	// Remove existing nodes\n  	while (this.nodes && this.nodes.length) {\n  		node = this.nodes.pop();\n  		node.parentNode.removeChild(node);\n  	}\n\n  	// Insert new nodes\n  	parentNode = this.parentFragment.getNode();\n\n  	this.nodes = insertHtml(this.value, parentNode, this.docFrag);\n  	parentNode.insertBefore(this.docFrag, this.parentFragment.findNextNode(this));\n\n  	// Special case - we\'re inserting the contents of a <select>\n  	helpers_updateSelect(this.pElement);\n  }\n\n  var Triple = function (options) {\n  	this.type = TRIPLE;\n  	Mustache.init(this, options);\n  };\n\n  Triple.prototype = {\n  	detach: Triple_prototype_detach,\n  	find: Triple_prototype_find,\n  	findAll: Triple_prototype_findAll,\n  	firstNode: Triple_prototype_firstNode,\n  	getValue: Mustache.getValue,\n  	rebind: Mustache.rebind,\n  	render: Triple_prototype_render,\n  	resolve: Mustache.resolve,\n  	setValue: prototype_setValue,\n  	toString: Triple_prototype_toString,\n  	unbind: shared_unbind,\n  	unrender: Triple_prototype_unrender,\n  	update: Triple_prototype_update\n  };\n\n  var _Triple = Triple;\n\n  var Element_prototype_bubble = function () {\n  	this.parentFragment.bubble();\n  };\n\n  var Element_prototype_detach = Element$detach;\n\n  function Element$detach() {\n  	var node = this.node,\n  	    parentNode;\n\n  	if (node) {\n  		// need to check for parent node - DOM may have been altered\n  		// by something other than Ractive! e.g. jQuery UI...\n  		if (parentNode = node.parentNode) {\n  			parentNode.removeChild(node);\n  		}\n\n  		return node;\n  	}\n  }\n\n  var Element_prototype_find = function (selector) {\n  	if (!this.node) {\n  		// this element hasn\'t been rendered yet\n  		return null;\n  	}\n\n  	if (matches(this.node, selector)) {\n  		return this.node;\n  	}\n\n  	if (this.fragment && this.fragment.find) {\n  		return this.fragment.find(selector);\n  	}\n  };\n\n  var Element_prototype_findAll = function (selector, query) {\n  	// Add this node to the query, if applicable, and register the\n  	// query on this element\n  	if (query._test(this, true) && query.live) {\n  		(this.liveQueries || (this.liveQueries = [])).push(query);\n  	}\n\n  	if (this.fragment) {\n  		this.fragment.findAll(selector, query);\n  	}\n  };\n\n  var Element_prototype_findAllComponents = function (selector, query) {\n  	if (this.fragment) {\n  		this.fragment.findAllComponents(selector, query);\n  	}\n  };\n\n  var Element_prototype_findComponent = function (selector) {\n  	if (this.fragment) {\n  		return this.fragment.findComponent(selector);\n  	}\n  };\n\n  var Element_prototype_findNextNode = Element$findNextNode;\n\n  function Element$findNextNode() {\n  	return null;\n  }\n\n  var Element_prototype_firstNode = Element$firstNode;\n\n  function Element$firstNode() {\n  	return this.node;\n  }\n\n  var getAttribute = Element$getAttribute;\n\n  function Element$getAttribute(name) {\n  	if (!this.attributes || !this.attributes[name]) {\n  		return;\n  	}\n\n  	return this.attributes[name].value;\n  }\n\n  var truthy = /^true|on|yes|1$/i;\n  var processBindingAttributes__isNumeric = /^[0-9]+$/;\n\n  var processBindingAttributes = function (element, template) {\n  	var val, attrs, attributes;\n\n  	attributes = template.a || {};\n  	attrs = {};\n\n  	// attributes that are present but don\'t have a value (=)\n  	// will be set to the number 0, which we condider to be true\n  	// the string \'0\', however is false\n\n  	val = attributes.twoway;\n  	if (val !== undefined) {\n  		attrs.twoway = val === 0 || truthy.test(val);\n  	}\n\n  	val = attributes.lazy;\n  	if (val !== undefined) {\n  		// check for timeout value\n  		if (val !== 0 && processBindingAttributes__isNumeric.test(val)) {\n  			attrs.lazy = parseInt(val);\n  		} else {\n  			attrs.lazy = val === 0 || truthy.test(val);\n  		}\n  	}\n\n  	return attrs;\n  };\n\n  var Attribute_prototype_bubble = Attribute$bubble;\n  function Attribute$bubble() {\n  	var value = this.useProperty || !this.rendered ? this.fragment.getValue() : this.fragment.toString();\n\n  	// TODO this can register the attribute multiple times (see render test\n  	// \'Attribute with nested mustaches\')\n  	if (!isEqual(value, this.value)) {\n\n  		// Need to clear old id from ractive.nodes\n  		if (this.name === "id" && this.value) {\n  			delete this.root.nodes[this.value];\n  		}\n\n  		this.value = value;\n\n  		if (this.name === "value" && this.node) {\n  			// We need to store the value on the DOM like this so we\n  			// can retrieve it later without it being coerced to a string\n  			this.node._ractive.value = value;\n  		}\n\n  		if (this.rendered) {\n  			global_runloop.addView(this);\n  		}\n  	}\n  }\n\n  var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;\n  svgCamelCaseElements = "altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern".split(" ");\n  svgCamelCaseAttributes = "attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan".split(" ");\n\n  createMap = function (items) {\n  	var map = {},\n  	    i = items.length;\n  	while (i--) {\n  		map[items[i].toLowerCase()] = items[i];\n  	}\n  	return map;\n  };\n\n  map = createMap(svgCamelCaseElements.concat(svgCamelCaseAttributes));\n\n  var enforceCase = function (elementName) {\n  	var lowerCaseElementName = elementName.toLowerCase();\n  	return map[lowerCaseElementName] || lowerCaseElementName;\n  };\n\n  var determineNameAndNamespace = function (attribute, name) {\n  	var colonIndex, namespacePrefix;\n\n  	// are we dealing with a namespaced attribute, e.g. xlink:href?\n  	colonIndex = name.indexOf(":");\n  	if (colonIndex !== -1) {\n\n  		// looks like we are, yes...\n  		namespacePrefix = name.substr(0, colonIndex);\n\n  		// ...unless it\'s a namespace *declaration*, which we ignore (on the assumption\n  		// that only valid namespaces will be used)\n  		if (namespacePrefix !== "xmlns") {\n  			name = name.substring(colonIndex + 1);\n\n  			attribute.name = enforceCase(name);\n  			attribute.namespace = namespaces[namespacePrefix.toLowerCase()];\n  			attribute.namespacePrefix = namespacePrefix;\n\n  			if (!attribute.namespace) {\n  				throw "Unknown namespace (\\"" + namespacePrefix + "\\")";\n  			}\n\n  			return;\n  		}\n  	}\n\n  	// SVG attribute names are case sensitive\n  	attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase(name) : name;\n  };\n\n  var helpers_getInterpolator = getInterpolator;\n  function getInterpolator(attribute) {\n  	var items = attribute.fragment.items;\n\n  	if (items.length !== 1) {\n  		return;\n  	}\n\n  	if (items[0].type === INTERPOLATOR) {\n  		return items[0];\n  	}\n  }\n\n  var prototype_init = Attribute$init;\n  function Attribute$init(options) {\n  	this.type = ATTRIBUTE;\n  	this.element = options.element;\n  	this.root = options.root;\n\n  	determineNameAndNamespace(this, options.name);\n  	this.isBoolean = booleanAttributes.test(this.name);\n\n  	// if it\'s an empty attribute, or just a straight key-value pair, with no\n  	// mustache shenanigans, set the attribute accordingly and go home\n  	if (!options.value || typeof options.value === "string") {\n  		this.value = this.isBoolean ? true : options.value || "";\n  		return;\n  	}\n\n  	// otherwise we need to do some work\n\n  	// share parentFragment with parent element\n  	this.parentFragment = this.element.parentFragment;\n\n  	this.fragment = new virtualdom_Fragment({\n  		template: options.value,\n  		root: this.root,\n  		owner: this\n  	});\n\n  	// TODO can we use this.fragment.toString() in some cases? It\'s quicker\n  	this.value = this.fragment.getValue();\n\n  	// Store a reference to this attribute\'s interpolator, if its fragment\n  	// takes the form `{{foo}}`. This is necessary for two-way binding and\n  	// for correctly rendering HTML later\n  	this.interpolator = helpers_getInterpolator(this);\n  	this.isBindable = !!this.interpolator && !this.interpolator.isStatic;\n\n  	// mark as ready\n  	this.ready = true;\n  }\n\n  var Attribute_prototype_rebind = Attribute$rebind;\n\n  function Attribute$rebind(oldKeypath, newKeypath) {\n  	if (this.fragment) {\n  		this.fragment.rebind(oldKeypath, newKeypath);\n  	}\n  }\n\n  var Attribute_prototype_render = Attribute$render;\n  var propertyNames = {\n  	"accept-charset": "acceptCharset",\n  	accesskey: "accessKey",\n  	bgcolor: "bgColor",\n  	"class": "className",\n  	codebase: "codeBase",\n  	colspan: "colSpan",\n  	contenteditable: "contentEditable",\n  	datetime: "dateTime",\n  	dirname: "dirName",\n  	"for": "htmlFor",\n  	"http-equiv": "httpEquiv",\n  	ismap: "isMap",\n  	maxlength: "maxLength",\n  	novalidate: "noValidate",\n  	pubdate: "pubDate",\n  	readonly: "readOnly",\n  	rowspan: "rowSpan",\n  	tabindex: "tabIndex",\n  	usemap: "useMap"\n  };\n  function Attribute$render(node) {\n  	var propertyName;\n\n  	this.node = node;\n\n  	// should we use direct property access, or setAttribute?\n  	if (!node.namespaceURI || node.namespaceURI === namespaces.html) {\n  		propertyName = propertyNames[this.name] || this.name;\n\n  		if (node[propertyName] !== undefined) {\n  			this.propertyName = propertyName;\n  		}\n\n  		// is attribute a boolean attribute or \'value\'? If so we\'re better off doing e.g.\n  		// node.selected = true rather than node.setAttribute( \'selected\', \'\' )\n  		if (this.isBoolean || this.isTwoway) {\n  			this.useProperty = true;\n  		}\n\n  		if (propertyName === "value") {\n  			node._ractive.value = this.value;\n  		}\n  	}\n\n  	this.rendered = true;\n  	this.update();\n  }\n\n  var Attribute_prototype_toString = Attribute$toString;\n\n  function Attribute$toString() {\n  	var _ref = this;\n\n  	var name = _ref.name;\n  	var namespacePrefix = _ref.namespacePrefix;\n  	var value = _ref.value;\n  	var interpolator = _ref.interpolator;\n  	var fragment = _ref.fragment;\n\n  	// Special case - select and textarea values (should not be stringified)\n  	if (name === "value" && (this.element.name === "select" || this.element.name === "textarea")) {\n  		return;\n  	}\n\n  	// Special case - content editable\n  	if (name === "value" && this.element.getAttribute("contenteditable") !== undefined) {\n  		return;\n  	}\n\n  	// Special case - radio names\n  	if (name === "name" && this.element.name === "input" && interpolator) {\n  		return "name={{" + (interpolator.keypath.str || interpolator.ref) + "}}";\n  	}\n\n  	// Boolean attributes\n  	if (this.isBoolean) {\n  		return value ? name : "";\n  	}\n\n  	if (fragment) {\n  		// special case - this catches undefined/null values (#1211)\n  		if (fragment.items.length === 1 && fragment.items[0].value == null) {\n  			return "";\n  		}\n\n  		value = fragment.toString();\n  	}\n\n  	if (namespacePrefix) {\n  		name = namespacePrefix + ":" + name;\n  	}\n\n  	return value ? name + "=\\"" + Attribute_prototype_toString__escape(value) + "\\"" : name;\n  }\n\n  function Attribute_prototype_toString__escape(value) {\n  	return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/\'/g, "&#39;");\n  }\n\n  var Attribute_prototype_unbind = Attribute$unbind;\n\n  function Attribute$unbind() {\n  	// ignore non-dynamic attributes\n  	if (this.fragment) {\n  		this.fragment.unbind();\n  	}\n\n  	if (this.name === "id") {\n  		delete this.root.nodes[this.value];\n  	}\n  }\n\n  var updateSelectValue = Attribute$updateSelect;\n\n  function Attribute$updateSelect() {\n  	var value = this.value,\n  	    options,\n  	    option,\n  	    optionValue,\n  	    i;\n\n  	if (!this.locked) {\n  		this.node._ractive.value = value;\n\n  		options = this.node.options;\n  		i = options.length;\n\n  		while (i--) {\n  			option = options[i];\n  			optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don\'t have _ractive\n\n  			if (optionValue == value) {\n  				// double equals as we may be comparing numbers with strings\n  				option.selected = true;\n  				break;\n  			}\n  		}\n  	}\n\n  	// if we\'re still here, it means the new value didn\'t match any of the options...\n  	// TODO figure out what to do in this situation\n  }\n\n  var updateMultipleSelectValue = Attribute$updateMultipleSelect;\n  function Attribute$updateMultipleSelect() {\n  	var value = this.value,\n  	    options,\n  	    i,\n  	    option,\n  	    optionValue;\n\n  	if (!isArray(value)) {\n  		value = [value];\n  	}\n\n  	options = this.node.options;\n  	i = options.length;\n\n  	while (i--) {\n  		option = options[i];\n  		optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don\'t have _ractive\n  		option.selected = arrayContains(value, optionValue);\n  	}\n  }\n\n  var updateRadioName = Attribute$updateRadioName;\n\n  function Attribute$updateRadioName() {\n  	var _ref = this;\n\n  	var node = _ref.node;\n  	var value = _ref.value;\n\n  	node.checked = value == node._ractive.value;\n  }\n\n  var updateRadioValue = Attribute$updateRadioValue;\n  function Attribute$updateRadioValue() {\n  	var wasChecked,\n  	    node = this.node,\n  	    binding,\n  	    bindings,\n  	    i;\n\n  	wasChecked = node.checked;\n\n  	node.value = this.element.getAttribute("value");\n  	node.checked = this.element.getAttribute("value") === this.element.getAttribute("name");\n\n  	// This is a special case - if the input was checked, and the value\n  	// changed so that it\'s no longer checked, the twoway binding is\n  	// most likely out of date. To fix it we have to jump through some\n  	// hoops... this is a little kludgy but it works\n  	if (wasChecked && !node.checked && this.element.binding) {\n  		bindings = this.element.binding.siblings;\n\n  		if (i = bindings.length) {\n  			while (i--) {\n  				binding = bindings[i];\n\n  				if (!binding.element.node) {\n  					// this is the initial render, siblings are still rendering!\n  					// we\'ll come back later...\n  					return;\n  				}\n\n  				if (binding.element.node.checked) {\n  					global_runloop.addRactive(binding.root);\n  					return binding.handleChange();\n  				}\n  			}\n\n  			this.root.viewmodel.set(binding.keypath, undefined);\n  		}\n  	}\n  }\n\n  var updateCheckboxName = Attribute$updateCheckboxName;\n  function Attribute$updateCheckboxName() {\n  	var _ref = this;\n\n  	var element = _ref.element;\n  	var node = _ref.node;\n  	var value = _ref.value;var binding = element.binding;var valueAttribute;var i;\n\n  	valueAttribute = element.getAttribute("value");\n\n  	if (!isArray(value)) {\n  		binding.isChecked = node.checked = value == valueAttribute;\n  	} else {\n  		i = value.length;\n  		while (i--) {\n  			if (valueAttribute == value[i]) {\n  				binding.isChecked = node.checked = true;\n  				return;\n  			}\n  		}\n  		binding.isChecked = node.checked = false;\n  	}\n  }\n\n  var updateClassName = Attribute$updateClassName;\n  function Attribute$updateClassName() {\n  	this.node.className = safeToStringValue(this.value);\n  }\n\n  var updateIdAttribute = Attribute$updateIdAttribute;\n\n  function Attribute$updateIdAttribute() {\n  	var _ref = this;\n\n  	var node = _ref.node;\n  	var value = _ref.value;\n\n  	this.root.nodes[value] = node;\n  	node.id = value;\n  }\n\n  var updateIEStyleAttribute = Attribute$updateIEStyleAttribute;\n\n  function Attribute$updateIEStyleAttribute() {\n  	var node, value;\n\n  	node = this.node;\n  	value = this.value;\n\n  	if (value === undefined) {\n  		value = "";\n  	}\n\n  	node.style.setAttribute("cssText", value);\n  }\n\n  var updateContentEditableValue = Attribute$updateContentEditableValue;\n\n  function Attribute$updateContentEditableValue() {\n  	var value = this.value;\n\n  	if (value === undefined) {\n  		value = "";\n  	}\n\n  	if (!this.locked) {\n  		this.node.innerHTML = value;\n  	}\n  }\n\n  var updateValue = Attribute$updateValue;\n\n  function Attribute$updateValue() {\n  	var _ref = this;\n\n  	var node = _ref.node;\n  	var value = _ref.value;\n\n  	// store actual value, so it doesn\'t get coerced to a string\n  	node._ractive.value = value;\n\n  	// with two-way binding, only update if the change wasn\'t initiated by the user\n  	// otherwise the cursor will often be sent to the wrong place\n  	if (!this.locked) {\n  		node.value = value == undefined ? "" : value;\n  	}\n  }\n\n  var updateBoolean = Attribute$updateBooleanAttribute;\n\n  function Attribute$updateBooleanAttribute() {\n  	// with two-way binding, only update if the change wasn\'t initiated by the user\n  	// otherwise the cursor will often be sent to the wrong place\n  	if (!this.locked) {\n  		this.node[this.propertyName] = this.value;\n  	}\n  }\n\n  var updateEverythingElse = Attribute$updateEverythingElse;\n\n  function Attribute$updateEverythingElse() {\n  	var _ref = this;\n\n  	var node = _ref.node;\n  	var namespace = _ref.namespace;\n  	var name = _ref.name;\n  	var value = _ref.value;\n  	var fragment = _ref.fragment;\n\n  	if (namespace) {\n  		node.setAttributeNS(namespace, name, (fragment || value).toString());\n  	} else if (!this.isBoolean) {\n  		if (value == null) {\n  			node.removeAttribute(name);\n  		} else {\n  			node.setAttribute(name, (fragment || value).toString());\n  		}\n  	}\n\n  	// Boolean attributes - truthy becomes \'\', falsy means \'remove attribute\'\n  	else {\n  		if (value) {\n  			node.setAttribute(name, "");\n  		} else {\n  			node.removeAttribute(name);\n  		}\n  	}\n  }\n\n  // There are a few special cases when it comes to updating attributes. For this reason,\n  // the prototype .update() method points to this method, which waits until the\n  // attribute has finished initialising, then replaces the prototype method with a more\n  // suitable one. That way, we save ourselves doing a bunch of tests on each call\n  var Attribute_prototype_update = Attribute$update;\n  function Attribute$update() {\n  	var _ref = this;\n\n  	var name = _ref.name;\n  	var element = _ref.element;\n  	var node = _ref.node;var type;var updateMethod;\n\n  	if (name === "id") {\n  		updateMethod = updateIdAttribute;\n  	} else if (name === "value") {\n  		// special case - selects\n  		if (element.name === "select" && name === "value") {\n  			updateMethod = element.getAttribute("multiple") ? updateMultipleSelectValue : updateSelectValue;\n  		} else if (element.name === "textarea") {\n  			updateMethod = updateValue;\n  		}\n\n  		// special case - contenteditable\n  		else if (element.getAttribute("contenteditable") != null) {\n  			updateMethod = updateContentEditableValue;\n  		}\n\n  		// special case - <input>\n  		else if (element.name === "input") {\n  			type = element.getAttribute("type");\n\n  			// type=\'file\' value=\'{{fileList}}\'>\n  			if (type === "file") {\n  				updateMethod = noop; // read-only\n  			}\n\n  			// type=\'radio\' name=\'{{twoway}}\'\n  			else if (type === "radio" && element.binding && element.binding.name === "name") {\n  				updateMethod = updateRadioValue;\n  			} else {\n  				updateMethod = updateValue;\n  			}\n  		}\n  	}\n\n  	// special case - <input type=\'radio\' name=\'{{twoway}}\' value=\'foo\'>\n  	else if (this.isTwoway && name === "name") {\n  		if (node.type === "radio") {\n  			updateMethod = updateRadioName;\n  		} else if (node.type === "checkbox") {\n  			updateMethod = updateCheckboxName;\n  		}\n  	}\n\n  	// special case - style attributes in Internet Exploder\n  	else if (name === "style" && node.style.setAttribute) {\n  		updateMethod = updateIEStyleAttribute;\n  	}\n\n  	// special case - class names. IE fucks things up, again\n  	else if (name === "class" && (!node.namespaceURI || node.namespaceURI === namespaces.html)) {\n  		updateMethod = updateClassName;\n  	} else if (this.useProperty) {\n  		updateMethod = updateBoolean;\n  	}\n\n  	if (!updateMethod) {\n  		updateMethod = updateEverythingElse;\n  	}\n\n  	this.update = updateMethod;\n  	this.update();\n  }\n\n  var Attribute = function (options) {\n  	this.init(options);\n  };\n\n  Attribute.prototype = {\n  	bubble: Attribute_prototype_bubble,\n  	init: prototype_init,\n  	rebind: Attribute_prototype_rebind,\n  	render: Attribute_prototype_render,\n  	toString: Attribute_prototype_toString,\n  	unbind: Attribute_prototype_unbind,\n  	update: Attribute_prototype_update\n  };\n\n  var _Attribute = Attribute;\n\n  var createAttributes = function (element, attributes) {\n  	var name,\n  	    attribute,\n  	    result = [];\n\n  	for (name in attributes) {\n  		// skip binding attributes\n  		if (name === "twoway" || name === "lazy") {\n  			continue;\n  		}\n\n  		if (attributes.hasOwnProperty(name)) {\n  			attribute = new _Attribute({\n  				element: element,\n  				name: name,\n  				value: attributes[name],\n  				root: element.root\n  			});\n\n  			result[name] = attribute;\n\n  			if (name !== "value") {\n  				result.push(attribute);\n  			}\n  		}\n  	}\n\n  	// value attribute goes last. This is because it\n  	// may get clamped on render otherwise, e.g. in\n  	// `<input type=\'range\' value=\'999\' min=\'0\' max=\'1000\'>`\n  	// since default max is 100\n  	if (attribute = result.value) {\n  		result.push(attribute);\n  	}\n\n  	return result;\n  };\n\n  var _ConditionalAttribute__div;\n\n  if (typeof document !== "undefined") {\n  	_ConditionalAttribute__div = createElement("div");\n  }\n\n  var ConditionalAttribute = function (element, template) {\n  	this.element = element;\n  	this.root = element.root;\n  	this.parentFragment = element.parentFragment;\n\n  	this.attributes = [];\n\n  	this.fragment = new virtualdom_Fragment({\n  		root: element.root,\n  		owner: this,\n  		template: [template]\n  	});\n  };\n\n  ConditionalAttribute.prototype = {\n  	bubble: function () {\n  		if (this.node) {\n  			this.update();\n  		}\n\n  		this.element.bubble();\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		this.fragment.rebind(oldKeypath, newKeypath);\n  	},\n\n  	render: function (node) {\n  		this.node = node;\n  		this.isSvg = node.namespaceURI === namespaces.svg;\n\n  		this.update();\n  	},\n\n  	unbind: function () {\n  		this.fragment.unbind();\n  	},\n\n  	update: function () {\n  		var _this = this;\n\n  		var str, attrs;\n\n  		str = this.fragment.toString();\n  		attrs = parseAttributes(str, this.isSvg);\n\n  		// any attributes that previously existed but no longer do\n  		// must be removed\n  		this.attributes.filter(function (a) {\n  			return notIn(attrs, a);\n  		}).forEach(function (a) {\n  			_this.node.removeAttribute(a.name);\n  		});\n\n  		attrs.forEach(function (a) {\n  			_this.node.setAttribute(a.name, a.value);\n  		});\n\n  		this.attributes = attrs;\n  	},\n\n  	toString: function () {\n  		return this.fragment.toString();\n  	}\n  };\n\n  var _ConditionalAttribute = ConditionalAttribute;\n\n  function parseAttributes(str, isSvg) {\n  	var tag = isSvg ? "svg" : "div";\n  	_ConditionalAttribute__div.innerHTML = "<" + tag + " " + str + "></" + tag + ">";\n\n  	return toArray(_ConditionalAttribute__div.childNodes[0].attributes);\n  }\n\n  function notIn(haystack, needle) {\n  	var i = haystack.length;\n\n  	while (i--) {\n  		if (haystack[i].name === needle.name) {\n  			return false;\n  		}\n  	}\n\n  	return true;\n  }\n\n  var createConditionalAttributes = function (element, attributes) {\n  	if (!attributes) {\n  		return [];\n  	}\n\n  	return attributes.map(function (a) {\n  		return new _ConditionalAttribute(element, a);\n  	});\n  };\n\n  var Binding = function (element) {\n  	var interpolator, keypath, value, parentForm;\n\n  	this.element = element;\n  	this.root = element.root;\n  	this.attribute = element.attributes[this.name || "value"];\n\n  	interpolator = this.attribute.interpolator;\n  	interpolator.twowayBinding = this;\n\n  	if (keypath = interpolator.keypath) {\n  		if (keypath.str.slice(-1) === "}") {\n  			warnOnceIfDebug("Two-way binding does not work with expressions (`%s` on <%s>)", interpolator.resolver.uniqueString, element.name, { ractive: this.root });\n  			return false;\n  		}\n\n  		if (keypath.isSpecial) {\n  			warnOnceIfDebug("Two-way binding does not work with %s", interpolator.resolver.ref, { ractive: this.root });\n  			return false;\n  		}\n  	} else {\n  		// A mustache may be *ambiguous*. Let\'s say we were given\n  		// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`\n  		// *wasn\'t* `undefined`, the keypath would be `foo.bar`.\n  		// Then, any user input would result in `foo.bar` being updated.\n  		//\n  		// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be\n  		// left with an unresolved partial keypath - so we are forced to make an\n  		// assumption. That assumption is that the input in question should\n  		// be forced to resolve to `bar`, and any user input would affect `bar`\n  		// and not `foo.bar`.\n  		//\n  		// Did that make any sense? No? Oh. Sorry. Well the moral of the story is\n  		// be explicit when using two-way data-binding about what keypath you\'re\n  		// updating. Using it in lists is probably a recipe for confusion...\n  		var ref = interpolator.template.r ? "\'" + interpolator.template.r + "\' reference" : "expression";\n  		warnIfDebug("The %s being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity", ref, { ractive: this.root });\n  		interpolator.resolver.forceResolution();\n  		keypath = interpolator.keypath;\n  	}\n\n  	this.attribute.isTwoway = true;\n  	this.keypath = keypath;\n\n  	// initialise value, if it\'s undefined\n  	value = this.root.viewmodel.get(keypath);\n\n  	if (value === undefined && this.getInitialValue) {\n  		value = this.getInitialValue();\n\n  		if (value !== undefined) {\n  			this.root.viewmodel.set(keypath, value);\n  		}\n  	}\n\n  	if (parentForm = findParentForm(element)) {\n  		this.resetValue = value;\n  		parentForm.formBindings.push(this);\n  	}\n  };\n\n  Binding.prototype = {\n  	handleChange: function () {\n  		var _this = this;\n\n  		global_runloop.start(this.root);\n  		this.attribute.locked = true;\n  		this.root.viewmodel.set(this.keypath, this.getValue());\n  		global_runloop.scheduleTask(function () {\n  			return _this.attribute.locked = false;\n  		});\n  		global_runloop.end();\n  	},\n\n  	rebound: function () {\n  		var bindings, oldKeypath, newKeypath;\n\n  		oldKeypath = this.keypath;\n  		newKeypath = this.attribute.interpolator.keypath;\n\n  		// The attribute this binding is linked to has already done the work\n  		if (oldKeypath === newKeypath) {\n  			return;\n  		}\n\n  		removeFromArray(this.root._twowayBindings[oldKeypath.str], this);\n\n  		this.keypath = newKeypath;\n\n  		bindings = this.root._twowayBindings[newKeypath.str] || (this.root._twowayBindings[newKeypath.str] = []);\n  		bindings.push(this);\n  	},\n\n  	unbind: function () {}\n  };\n\n  Binding.extend = function (properties) {\n  	var Parent = this,\n  	    SpecialisedBinding;\n\n  	SpecialisedBinding = function (element) {\n  		Binding.call(this, element);\n\n  		if (this.init) {\n  			this.init();\n  		}\n  	};\n\n  	SpecialisedBinding.prototype = create(Parent.prototype);\n  	utils_object__extend(SpecialisedBinding.prototype, properties);\n\n  	SpecialisedBinding.extend = Binding.extend;\n\n  	return SpecialisedBinding;\n  };\n\n  var Binding_Binding = Binding;\n\n  function findParentForm(element) {\n  	while (element = element.parent) {\n  		if (element.name === "form") {\n  			return element;\n  		}\n  	}\n  }\n\n  // this is called when the element is unbound.\n  // Specialised bindings can override it\n\n  // This is the handler for DOM events that would lead to a change in the model\n  // (i.e. change, sometimes, input, and occasionally click and keyup)\n  var handleDomEvent = handleChange;\n\n  function handleChange() {\n  	this._ractive.binding.handleChange();\n  }\n\n  var GenericBinding;\n\n  GenericBinding = Binding_Binding.extend({\n  	getInitialValue: function () {\n  		return "";\n  	},\n\n  	getValue: function () {\n  		return this.element.node.value;\n  	},\n\n  	render: function () {\n  		var node = this.element.node,\n  		    lazy,\n  		    timeout = false;\n  		this.rendered = true;\n\n  		// any lazy setting for this element overrides the root\n  		// if the value is a number, it\'s a timeout\n  		lazy = this.root.lazy;\n  		if (this.element.lazy === true) {\n  			lazy = true;\n  		} else if (this.element.lazy === false) {\n  			lazy = false;\n  		} else if (is__isNumeric(this.element.lazy)) {\n  			lazy = false;\n  			timeout = +this.element.lazy;\n  		} else if (is__isNumeric(lazy || "")) {\n  			timeout = +lazy;\n  			lazy = false;\n\n  			// make sure the timeout is available to the handler\n  			this.element.lazy = timeout;\n  		}\n\n  		this.handler = timeout ? handleDelay : handleDomEvent;\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		if (!lazy) {\n  			node.addEventListener("input", this.handler, false);\n\n  			if (node.attachEvent) {\n  				node.addEventListener("keyup", this.handler, false);\n  			}\n  		}\n\n  		node.addEventListener("blur", handleBlur, false);\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n  		this.rendered = false;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("input", this.handler, false);\n  		node.removeEventListener("keyup", this.handler, false);\n  		node.removeEventListener("blur", handleBlur, false);\n  	}\n  });\n\n  var Binding_GenericBinding = GenericBinding;\n\n  function handleBlur() {\n  	var value;\n\n  	handleDomEvent.call(this);\n\n  	value = this._ractive.root.viewmodel.get(this._ractive.binding.keypath);\n  	this.value = value == undefined ? "" : value;\n  }\n\n  function handleDelay() {\n  	var binding = this._ractive.binding,\n  	    el = this;\n\n  	if (!!binding._timeout) clearTimeout(binding._timeout);\n\n  	binding._timeout = setTimeout(function () {\n  		if (binding.rendered) handleDomEvent.call(el);\n  		binding._timeout = undefined;\n  	}, binding.element.lazy);\n  }\n\n  var ContentEditableBinding = Binding_GenericBinding.extend({\n  	getInitialValue: function () {\n  		return this.element.fragment ? this.element.fragment.toString() : "";\n  	},\n\n  	getValue: function () {\n  		return this.element.node.innerHTML;\n  	}\n  });\n\n  var Binding_ContentEditableBinding = ContentEditableBinding;\n\n  var shared_getSiblings = getSiblings;\n  var sets = {};\n  function getSiblings(id, group, keypath) {\n  	var hash = id + group + keypath;\n  	return sets[hash] || (sets[hash] = []);\n  }\n\n  var RadioBinding = Binding_Binding.extend({\n  	name: "checked",\n\n  	init: function () {\n  		this.siblings = shared_getSiblings(this.root._guid, "radio", this.element.getAttribute("name"));\n  		this.siblings.push(this);\n  	},\n\n  	render: function () {\n  		var node = this.element.node;\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		if (node.attachEvent) {\n  			node.addEventListener("click", handleDomEvent, false);\n  		}\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("click", handleDomEvent, false);\n  	},\n\n  	handleChange: function () {\n  		global_runloop.start(this.root);\n\n  		this.siblings.forEach(function (binding) {\n  			binding.root.viewmodel.set(binding.keypath, binding.getValue());\n  		});\n\n  		global_runloop.end();\n  	},\n\n  	getValue: function () {\n  		return this.element.node.checked;\n  	},\n\n  	unbind: function () {\n  		removeFromArray(this.siblings, this);\n  	}\n  });\n\n  var Binding_RadioBinding = RadioBinding;\n\n  var RadioNameBinding = Binding_Binding.extend({\n  	name: "name",\n\n  	init: function () {\n  		this.siblings = shared_getSiblings(this.root._guid, "radioname", this.keypath.str);\n  		this.siblings.push(this);\n\n  		this.radioName = true; // so that ractive.updateModel() knows what to do with this\n  	},\n\n  	getInitialValue: function () {\n  		if (this.element.getAttribute("checked")) {\n  			return this.element.getAttribute("value");\n  		}\n  	},\n\n  	render: function () {\n  		var node = this.element.node;\n\n  		node.name = "{{" + this.keypath.str + "}}";\n  		node.checked = this.root.viewmodel.get(this.keypath) == this.element.getAttribute("value");\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		if (node.attachEvent) {\n  			node.addEventListener("click", handleDomEvent, false);\n  		}\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("click", handleDomEvent, false);\n  	},\n\n  	getValue: function () {\n  		var node = this.element.node;\n  		return node._ractive ? node._ractive.value : node.value;\n  	},\n\n  	handleChange: function () {\n  		// If this <input> is the one that\'s checked, then the value of its\n  		// `name` keypath gets set to its value\n  		if (this.element.node.checked) {\n  			Binding_Binding.prototype.handleChange.call(this);\n  		}\n  	},\n\n  	rebound: function (oldKeypath, newKeypath) {\n  		var node;\n\n  		Binding_Binding.prototype.rebound.call(this, oldKeypath, newKeypath);\n\n  		if (node = this.element.node) {\n  			node.name = "{{" + this.keypath.str + "}}";\n  		}\n  	},\n\n  	unbind: function () {\n  		removeFromArray(this.siblings, this);\n  	}\n  });\n\n  var Binding_RadioNameBinding = RadioNameBinding;\n\n  var CheckboxNameBinding = Binding_Binding.extend({\n  	name: "name",\n\n  	getInitialValue: function () {\n  		// This only gets called once per group (of inputs that\n  		// share a name), because it only gets called if there\n  		// isn\'t an initial value. By the same token, we can make\n  		// a note of that fact that there was no initial value,\n  		// and populate it using any `checked` attributes that\n  		// exist (which users should avoid, but which we should\n  		// support anyway to avoid breaking expectations)\n  		this.noInitialValue = true;\n  		return [];\n  	},\n\n  	init: function () {\n  		var existingValue, bindingValue;\n\n  		this.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\n  		// Each input has a reference to an array containing it and its\n  		// siblings, as two-way binding depends on being able to ascertain\n  		// the status of all inputs within the group\n  		this.siblings = shared_getSiblings(this.root._guid, "checkboxes", this.keypath.str);\n  		this.siblings.push(this);\n\n  		if (this.noInitialValue) {\n  			this.siblings.noInitialValue = true;\n  		}\n\n  		// If no initial value was set, and this input is checked, we\n  		// update the model\n  		if (this.siblings.noInitialValue && this.element.getAttribute("checked")) {\n  			existingValue = this.root.viewmodel.get(this.keypath);\n  			bindingValue = this.element.getAttribute("value");\n\n  			existingValue.push(bindingValue);\n  		}\n  	},\n\n  	unbind: function () {\n  		removeFromArray(this.siblings, this);\n  	},\n\n  	render: function () {\n  		var node = this.element.node,\n  		    existingValue,\n  		    bindingValue;\n\n  		existingValue = this.root.viewmodel.get(this.keypath);\n  		bindingValue = this.element.getAttribute("value");\n\n  		if (isArray(existingValue)) {\n  			this.isChecked = arrayContains(existingValue, bindingValue);\n  		} else {\n  			this.isChecked = existingValue == bindingValue;\n  		}\n\n  		node.name = "{{" + this.keypath.str + "}}";\n  		node.checked = this.isChecked;\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		// in case of IE emergency, bind to click event as well\n  		if (node.attachEvent) {\n  			node.addEventListener("click", handleDomEvent, false);\n  		}\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("click", handleDomEvent, false);\n  	},\n\n  	changed: function () {\n  		var wasChecked = !!this.isChecked;\n  		this.isChecked = this.element.node.checked;\n  		return this.isChecked === wasChecked;\n  	},\n\n  	handleChange: function () {\n  		this.isChecked = this.element.node.checked;\n  		Binding_Binding.prototype.handleChange.call(this);\n  	},\n\n  	getValue: function () {\n  		return this.siblings.filter(isChecked).map(Binding_CheckboxNameBinding__getValue);\n  	}\n  });\n\n  function isChecked(binding) {\n  	return binding.isChecked;\n  }\n\n  function Binding_CheckboxNameBinding__getValue(binding) {\n  	return binding.element.getAttribute("value");\n  }\n\n  var Binding_CheckboxNameBinding = CheckboxNameBinding;\n\n  var CheckboxBinding = Binding_Binding.extend({\n  	name: "checked",\n\n  	render: function () {\n  		var node = this.element.node;\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		if (node.attachEvent) {\n  			node.addEventListener("click", handleDomEvent, false);\n  		}\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("click", handleDomEvent, false);\n  	},\n\n  	getValue: function () {\n  		return this.element.node.checked;\n  	}\n  });\n\n  var Binding_CheckboxBinding = CheckboxBinding;\n\n  var SelectBinding = Binding_Binding.extend({\n  	getInitialValue: function () {\n  		var options = this.element.options,\n  		    len,\n  		    i,\n  		    value,\n  		    optionWasSelected;\n\n  		if (this.element.getAttribute("value") !== undefined) {\n  			return;\n  		}\n\n  		i = len = options.length;\n\n  		if (!len) {\n  			return;\n  		}\n\n  		// take the final selected option...\n  		while (i--) {\n  			if (options[i].getAttribute("selected")) {\n  				value = options[i].getAttribute("value");\n  				optionWasSelected = true;\n  				break;\n  			}\n  		}\n\n  		// or the first non-disabled option, if none are selected\n  		if (!optionWasSelected) {\n  			while (++i < len) {\n  				if (!options[i].getAttribute("disabled")) {\n  					value = options[i].getAttribute("value");\n  					break;\n  				}\n  			}\n  		}\n\n  		// This is an optimisation (aka hack) that allows us to forgo some\n  		// other more expensive work\n  		if (value !== undefined) {\n  			this.element.attributes.value.value = value;\n  		}\n\n  		return value;\n  	},\n\n  	render: function () {\n  		this.element.node.addEventListener("change", handleDomEvent, false);\n  	},\n\n  	unrender: function () {\n  		this.element.node.removeEventListener("change", handleDomEvent, false);\n  	},\n\n  	// TODO this method is an anomaly... is it necessary?\n  	setValue: function (value) {\n  		this.root.viewmodel.set(this.keypath, value);\n  	},\n\n  	getValue: function () {\n  		var options, i, len, option, optionValue;\n\n  		options = this.element.node.options;\n  		len = options.length;\n\n  		for (i = 0; i < len; i += 1) {\n  			option = options[i];\n\n  			if (options[i].selected) {\n  				optionValue = option._ractive ? option._ractive.value : option.value;\n  				return optionValue;\n  			}\n  		}\n  	},\n\n  	forceUpdate: function () {\n  		var _this = this;\n\n  		var value = this.getValue();\n\n  		if (value !== undefined) {\n  			this.attribute.locked = true;\n  			global_runloop.scheduleTask(function () {\n  				return _this.attribute.locked = false;\n  			});\n  			this.root.viewmodel.set(this.keypath, value);\n  		}\n  	}\n  });\n\n  var Binding_SelectBinding = SelectBinding;\n\n  var MultipleSelectBinding = Binding_SelectBinding.extend({\n  	getInitialValue: function () {\n  		return this.element.options.filter(function (option) {\n  			return option.getAttribute("selected");\n  		}).map(function (option) {\n  			return option.getAttribute("value");\n  		});\n  	},\n\n  	render: function () {\n  		var valueFromModel;\n\n  		this.element.node.addEventListener("change", handleDomEvent, false);\n\n  		valueFromModel = this.root.viewmodel.get(this.keypath);\n\n  		if (valueFromModel === undefined) {\n  			// get value from DOM, if possible\n  			this.handleChange();\n  		}\n  	},\n\n  	unrender: function () {\n  		this.element.node.removeEventListener("change", handleDomEvent, false);\n  	},\n\n  	setValue: function () {\n  		throw new Error("TODO not implemented yet");\n  	},\n\n  	getValue: function () {\n  		var selectedValues, options, i, len, option, optionValue;\n\n  		selectedValues = [];\n  		options = this.element.node.options;\n  		len = options.length;\n\n  		for (i = 0; i < len; i += 1) {\n  			option = options[i];\n\n  			if (option.selected) {\n  				optionValue = option._ractive ? option._ractive.value : option.value;\n  				selectedValues.push(optionValue);\n  			}\n  		}\n\n  		return selectedValues;\n  	},\n\n  	handleChange: function () {\n  		var attribute, previousValue, value;\n\n  		attribute = this.attribute;\n  		previousValue = attribute.value;\n\n  		value = this.getValue();\n\n  		if (previousValue === undefined || !arrayContentsMatch(value, previousValue)) {\n  			Binding_SelectBinding.prototype.handleChange.call(this);\n  		}\n\n  		return this;\n  	},\n\n  	forceUpdate: function () {\n  		var _this = this;\n\n  		var value = this.getValue();\n\n  		if (value !== undefined) {\n  			this.attribute.locked = true;\n  			global_runloop.scheduleTask(function () {\n  				return _this.attribute.locked = false;\n  			});\n  			this.root.viewmodel.set(this.keypath, value);\n  		}\n  	},\n\n  	updateModel: function () {\n  		if (this.attribute.value === undefined || !this.attribute.value.length) {\n  			this.root.viewmodel.set(this.keypath, this.initialValue);\n  		}\n  	}\n  });\n\n  var Binding_MultipleSelectBinding = MultipleSelectBinding;\n\n  var FileListBinding = Binding_Binding.extend({\n  	render: function () {\n  		this.element.node.addEventListener("change", handleDomEvent, false);\n  	},\n\n  	unrender: function () {\n  		this.element.node.removeEventListener("change", handleDomEvent, false);\n  	},\n\n  	getValue: function () {\n  		return this.element.node.files;\n  	}\n  });\n\n  var Binding_FileListBinding = FileListBinding;\n\n  var NumericBinding = Binding_GenericBinding.extend({\n  	getInitialValue: function () {\n  		return undefined;\n  	},\n\n  	getValue: function () {\n  		var value = parseFloat(this.element.node.value);\n  		return isNaN(value) ? undefined : value;\n  	}\n  });\n\n  var init_createTwowayBinding = createTwowayBinding;\n\n  function createTwowayBinding(element) {\n  	var attributes = element.attributes,\n  	    type,\n  	    Binding,\n  	    bindName,\n  	    bindChecked,\n  	    binding;\n\n  	// if this is a late binding, and there\'s already one, it\n  	// needs to be torn down\n  	if (element.binding) {\n  		element.binding.teardown();\n  		element.binding = null;\n  	}\n\n  	// contenteditable\n  	if (\n  	// if the contenteditable attribute is true or is bindable and may thus become true\n  	(element.getAttribute("contenteditable") || !!attributes.contenteditable && isBindable(attributes.contenteditable)) && isBindable(attributes.value)) {\n  		Binding = Binding_ContentEditableBinding;\n  	}\n\n  	// <input>\n  	else if (element.name === "input") {\n  		type = element.getAttribute("type");\n\n  		if (type === "radio" || type === "checkbox") {\n  			bindName = isBindable(attributes.name);\n  			bindChecked = isBindable(attributes.checked);\n\n  			// we can either bind the name attribute, or the checked attribute - not both\n  			if (bindName && bindChecked) {\n  				warnIfDebug("A radio input can have two-way binding on its name attribute, or its checked attribute - not both", { ractive: element.root });\n  			}\n\n  			if (bindName) {\n  				Binding = type === "radio" ? Binding_RadioNameBinding : Binding_CheckboxNameBinding;\n  			} else if (bindChecked) {\n  				Binding = type === "radio" ? Binding_RadioBinding : Binding_CheckboxBinding;\n  			}\n  		} else if (type === "file" && isBindable(attributes.value)) {\n  			Binding = Binding_FileListBinding;\n  		} else if (isBindable(attributes.value)) {\n  			Binding = type === "number" || type === "range" ? NumericBinding : Binding_GenericBinding;\n  		}\n  	}\n\n  	// <select>\n  	else if (element.name === "select" && isBindable(attributes.value)) {\n  		Binding = element.getAttribute("multiple") ? Binding_MultipleSelectBinding : Binding_SelectBinding;\n  	}\n\n  	// <textarea>\n  	else if (element.name === "textarea" && isBindable(attributes.value)) {\n  		Binding = Binding_GenericBinding;\n  	}\n\n  	if (Binding && (binding = new Binding(element)) && binding.keypath) {\n  		return binding;\n  	}\n  }\n\n  function isBindable(attribute) {\n  	return attribute && attribute.isBindable;\n  }\n\n  // and this element also has a value attribute to bind\n\n  var EventHandler_prototype_bubble = EventHandler$bubble;\n\n  function EventHandler$bubble() {\n  	var hasAction = this.getAction();\n\n  	if (hasAction && !this.hasListener) {\n  		this.listen();\n  	} else if (!hasAction && this.hasListener) {\n  		this.unrender();\n  	}\n  }\n\n  // This function may be overwritten, if the event directive\n  // includes parameters\n  var EventHandler_prototype_fire = EventHandler$fire;\n  function EventHandler$fire(event) {\n  	shared_fireEvent(this.root, this.getAction(), { event: event });\n  }\n\n  var getAction = EventHandler$getAction;\n\n  function EventHandler$getAction() {\n  	return this.action.toString().trim();\n  }\n\n  var EventHandler_prototype_init = EventHandler$init;\n\n  var eventPattern = /^event(?:\\.(.+))?/;\n  function EventHandler$init(element, name, template) {\n  	var _this = this;\n\n  	var action, refs, ractive;\n\n  	this.element = element;\n  	this.root = element.root;\n  	this.parentFragment = element.parentFragment;\n  	this.name = name;\n\n  	if (name.indexOf("*") !== -1) {\n  		fatal("Only component proxy-events may contain \\"*\\" wildcards, <%s on-%s=\\"...\\"/> is not valid", element.name, name);\n  		this.invalid = true;\n  	}\n\n  	if (template.m) {\n  		refs = template.a.r;\n\n  		// This is a method call\n  		this.method = template.m;\n  		this.keypaths = [];\n  		this.fn = shared_getFunctionFromString(template.a.s, refs.length);\n\n  		this.parentFragment = element.parentFragment;\n  		ractive = this.root;\n\n  		// Create resolvers for each reference\n  		this.refResolvers = [];\n  		refs.forEach(function (ref, i) {\n  			var match = undefined;\n\n  			// special case - the `event` object\n  			if (match = eventPattern.exec(ref)) {\n  				_this.keypaths[i] = {\n  					eventObject: true,\n  					refinements: match[1] ? match[1].split(".") : []\n  				};\n  			} else {\n  				_this.refResolvers.push(Resolvers_createReferenceResolver(_this, ref, function (keypath) {\n  					return _this.resolve(i, keypath);\n  				}));\n  			}\n  		});\n\n  		this.fire = fireMethodCall;\n  	} else {\n  		// Get action (\'foo\' in \'on-click=\'foo\')\n  		action = template.n || template;\n  		if (typeof action !== "string") {\n  			action = new virtualdom_Fragment({\n  				template: action,\n  				root: this.root,\n  				owner: this\n  			});\n  		}\n\n  		this.action = action;\n\n  		// Get parameters\n  		if (template.d) {\n  			this.dynamicParams = new virtualdom_Fragment({\n  				template: template.d,\n  				root: this.root,\n  				owner: this.element\n  			});\n\n  			this.fire = fireEventWithDynamicParams;\n  		} else if (template.a) {\n  			this.params = template.a;\n  			this.fire = fireEventWithParams;\n  		}\n  	}\n  }\n\n  function fireMethodCall(event) {\n  	var ractive, values, args;\n\n  	ractive = this.root;\n\n  	if (typeof ractive[this.method] !== "function") {\n  		throw new Error("Attempted to call a non-existent method (\\"" + this.method + "\\")");\n  	}\n\n  	values = this.keypaths.map(function (keypath) {\n  		var value, len, i;\n\n  		if (keypath === undefined) {\n  			// not yet resolved\n  			return undefined;\n  		}\n\n  		// TODO the refinements stuff would be better handled at parse time\n  		if (keypath.eventObject) {\n  			value = event;\n\n  			if (len = keypath.refinements.length) {\n  				for (i = 0; i < len; i += 1) {\n  					value = value[keypath.refinements[i]];\n  				}\n  			}\n  		} else {\n  			value = ractive.viewmodel.get(keypath);\n  		}\n\n  		return value;\n  	});\n\n  	shared_eventStack.enqueue(ractive, event);\n\n  	args = this.fn.apply(null, values);\n  	ractive[this.method].apply(ractive, args);\n\n  	shared_eventStack.dequeue(ractive);\n  }\n\n  function fireEventWithParams(event) {\n  	shared_fireEvent(this.root, this.getAction(), { event: event, args: this.params });\n  }\n\n  function fireEventWithDynamicParams(event) {\n  	var args = this.dynamicParams.getArgsList();\n\n  	// need to strip [] from ends if a string!\n  	if (typeof args === "string") {\n  		args = args.substr(1, args.length - 2);\n  	}\n\n  	shared_fireEvent(this.root, this.getAction(), { event: event, args: args });\n  }\n\n  var shared_genericHandler = genericHandler;\n  function genericHandler(event) {\n  	var storage,\n  	    handler,\n  	    indices,\n  	    index = {};\n\n  	storage = this._ractive;\n  	handler = storage.events[event.type];\n\n  	if (indices = Resolvers_findIndexRefs(handler.element.parentFragment)) {\n  		index = Resolvers_findIndexRefs.resolve(indices);\n  	}\n\n  	handler.fire({\n  		node: this,\n  		original: event,\n  		index: index,\n  		keypath: storage.keypath.str,\n  		context: storage.root.viewmodel.get(storage.keypath)\n  	});\n  }\n\n  var listen = EventHandler$listen;\n\n  var customHandlers = {},\n      touchEvents = {\n  	touchstart: true,\n  	touchmove: true,\n  	touchend: true,\n  	touchcancel: true,\n  	//not w3c, but supported in some browsers\n  	touchleave: true\n  };\n  function EventHandler$listen() {\n  	var definition,\n  	    name = this.name;\n\n  	if (this.invalid) {\n  		return;\n  	}\n\n  	if (definition = findInViewHierarchy("events", this.root, name)) {\n  		this.custom = definition(this.node, getCustomHandler(name));\n  	} else {\n  		// Looks like we\'re dealing with a standard DOM event... but let\'s check\n  		if (!("on" + name in this.node) && !(window && "on" + name in window) && !isJsdom) {\n\n  			// okay to use touch events if this browser doesn\'t support them\n  			if (!touchEvents[name]) {\n  				warnOnceIfDebug(missingPlugin(name, "event"), { node: this.node });\n  			}\n\n  			return;\n  		}\n\n  		this.node.addEventListener(name, shared_genericHandler, false);\n  	}\n\n  	this.hasListener = true;\n  }\n\n  function getCustomHandler(name) {\n  	if (!customHandlers[name]) {\n  		customHandlers[name] = function (event) {\n  			var storage = event.node._ractive;\n\n  			event.index = storage.index;\n  			event.keypath = storage.keypath.str;\n  			event.context = storage.root.viewmodel.get(storage.keypath);\n\n  			storage.events[name].fire(event);\n  		};\n  	}\n\n  	return customHandlers[name];\n  }\n\n  var EventHandler_prototype_rebind = EventHandler$rebind;\n\n  function EventHandler$rebind(oldKeypath, newKeypath) {\n  	var fragment;\n  	if (this.method) {\n  		fragment = this.element.parentFragment;\n  		this.refResolvers.forEach(rebind);\n\n  		return;\n  	}\n\n  	if (typeof this.action !== "string") {\n  		rebind(this.action);\n  	}\n\n  	if (this.dynamicParams) {\n  		rebind(this.dynamicParams);\n  	}\n\n  	function rebind(thing) {\n  		thing && thing.rebind(oldKeypath, newKeypath);\n  	}\n  }\n\n  var EventHandler_prototype_render = EventHandler$render;\n\n  function EventHandler$render() {\n  	this.node = this.element.node;\n  	// store this on the node itself, so it can be retrieved by a\n  	// universal handler\n  	this.node._ractive.events[this.name] = this;\n\n  	if (this.method || this.getAction()) {\n  		this.listen();\n  	}\n  }\n\n  var prototype_resolve = EventHandler$resolve;\n\n  function EventHandler$resolve(index, keypath) {\n  	this.keypaths[index] = keypath;\n  }\n\n  var EventHandler_prototype_unbind = EventHandler$unbind;\n  function EventHandler$unbind() {\n  	if (this.method) {\n  		this.refResolvers.forEach(methodCallers__unbind);\n  		return;\n  	}\n\n  	// Tear down dynamic name\n  	if (typeof this.action !== "string") {\n  		this.action.unbind();\n  	}\n\n  	// Tear down dynamic parameters\n  	if (this.dynamicParams) {\n  		this.dynamicParams.unbind();\n  	}\n  }\n\n  var EventHandler_prototype_unrender = EventHandler$unrender;\n  function EventHandler$unrender() {\n\n  	if (this.custom) {\n  		this.custom.teardown();\n  	} else {\n  		this.node.removeEventListener(this.name, shared_genericHandler, false);\n  	}\n\n  	this.hasListener = false;\n  }\n\n  var EventHandler = function (element, name, template) {\n  	this.init(element, name, template);\n  };\n\n  EventHandler.prototype = {\n  	bubble: EventHandler_prototype_bubble,\n  	fire: EventHandler_prototype_fire,\n  	getAction: getAction,\n  	init: EventHandler_prototype_init,\n  	listen: listen,\n  	rebind: EventHandler_prototype_rebind,\n  	render: EventHandler_prototype_render,\n  	resolve: prototype_resolve,\n  	unbind: EventHandler_prototype_unbind,\n  	unrender: EventHandler_prototype_unrender\n  };\n\n  var _EventHandler = EventHandler;\n\n  var createEventHandlers = function (element, template) {\n  	var i,\n  	    name,\n  	    names,\n  	    handler,\n  	    result = [];\n\n  	for (name in template) {\n  		if (template.hasOwnProperty(name)) {\n  			names = name.split("-");\n  			i = names.length;\n\n  			while (i--) {\n  				handler = new _EventHandler(element, names[i], template[name]);\n  				result.push(handler);\n  			}\n  		}\n  	}\n\n  	return result;\n  };\n\n  var Decorator = function (element, template) {\n  	var self = this,\n  	    ractive,\n  	    name,\n  	    fragment;\n\n  	this.element = element;\n  	this.root = ractive = element.root;\n\n  	name = template.n || template;\n\n  	if (typeof name !== "string") {\n  		fragment = new virtualdom_Fragment({\n  			template: name,\n  			root: ractive,\n  			owner: element\n  		});\n\n  		name = fragment.toString();\n  		fragment.unbind();\n\n  		if (name === "") {\n  			// empty string okay, just no decorator\n  			return;\n  		}\n  	}\n\n  	if (template.a) {\n  		this.params = template.a;\n  	} else if (template.d) {\n  		this.fragment = new virtualdom_Fragment({\n  			template: template.d,\n  			root: ractive,\n  			owner: element\n  		});\n\n  		this.params = this.fragment.getArgsList();\n\n  		this.fragment.bubble = function () {\n  			this.dirtyArgs = this.dirtyValue = true;\n  			self.params = this.getArgsList();\n\n  			if (self.ready) {\n  				self.update();\n  			}\n  		};\n  	}\n\n  	this.fn = findInViewHierarchy("decorators", ractive, name);\n\n  	if (!this.fn) {\n  		fatal(missingPlugin(name, "decorator"));\n  	}\n  };\n\n  Decorator.prototype = {\n  	init: function () {\n  		var node, result, args;\n\n  		node = this.element.node;\n\n  		if (this.params) {\n  			args = [node].concat(this.params);\n  			result = this.fn.apply(this.root, args);\n  		} else {\n  			result = this.fn.call(this.root, node);\n  		}\n\n  		if (!result || !result.teardown) {\n  			throw new Error("Decorator definition must return an object with a teardown method");\n  		}\n\n  		// TODO does this make sense?\n  		this.actual = result;\n  		this.ready = true;\n  	},\n\n  	update: function () {\n  		if (this.actual.update) {\n  			this.actual.update.apply(this.root, this.params);\n  		} else {\n  			this.actual.teardown(true);\n  			this.init();\n  		}\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		if (this.fragment) {\n  			this.fragment.rebind(oldKeypath, newKeypath);\n  		}\n  	},\n\n  	teardown: function (updating) {\n  		this.torndown = true;\n  		if (this.ready) {\n  			this.actual.teardown();\n  		}\n\n  		if (!updating && this.fragment) {\n  			this.fragment.unbind();\n  		}\n  	}\n  };\n\n  var _Decorator = Decorator;\n\n  function select__bubble() {\n  	var _this = this;\n\n  	if (!this.dirty) {\n  		this.dirty = true;\n\n  		global_runloop.scheduleTask(function () {\n  			sync(_this);\n  			_this.dirty = false;\n  		});\n  	}\n\n  	this.parentFragment.bubble(); // default behaviour\n  }\n\n  function sync(selectElement) {\n  	var selectNode, selectValue, isMultiple, options, optionWasSelected;\n\n  	selectNode = selectElement.node;\n\n  	if (!selectNode) {\n  		return;\n  	}\n\n  	options = toArray(selectNode.options);\n\n  	selectValue = selectElement.getAttribute("value");\n  	isMultiple = selectElement.getAttribute("multiple");\n\n  	// If the <select> has a specified value, that should override\n  	// these options\n  	if (selectValue !== undefined) {\n  		options.forEach(function (o) {\n  			var optionValue, shouldSelect;\n\n  			optionValue = o._ractive ? o._ractive.value : o.value;\n  			shouldSelect = isMultiple ? valueContains(selectValue, optionValue) : selectValue == optionValue;\n\n  			if (shouldSelect) {\n  				optionWasSelected = true;\n  			}\n\n  			o.selected = shouldSelect;\n  		});\n\n  		if (!optionWasSelected) {\n  			if (options[0]) {\n  				options[0].selected = true;\n  			}\n\n  			if (selectElement.binding) {\n  				selectElement.binding.forceUpdate();\n  			}\n  		}\n  	}\n\n  	// Otherwise the value should be initialised according to which\n  	// <option> element is selected, if twoway binding is in effect\n  	else if (selectElement.binding) {\n  		selectElement.binding.forceUpdate();\n  	}\n  }\n\n  function valueContains(selectValue, optionValue) {\n  	var i = selectValue.length;\n  	while (i--) {\n  		if (selectValue[i] == optionValue) {\n  			return true;\n  		}\n  	}\n  }\n\n  function special_option__init(option, template) {\n  	option.select = findParentSelect(option.parent);\n\n  	// we might be inside a <datalist> element\n  	if (!option.select) {\n  		return;\n  	}\n\n  	option.select.options.push(option);\n\n  	// If the value attribute is missing, use the element\'s content\n  	if (!template.a) {\n  		template.a = {};\n  	}\n\n  	// ...as long as it isn\'t disabled\n  	if (template.a.value === undefined && !template.a.hasOwnProperty("disabled")) {\n  		template.a.value = template.f;\n  	}\n\n  	// If there is a `selected` attribute, but the <select>\n  	// already has a value, delete it\n  	if ("selected" in template.a && option.select.getAttribute("value") !== undefined) {\n  		delete template.a.selected;\n  	}\n  }\n\n  function special_option__unbind(option) {\n  	if (option.select) {\n  		removeFromArray(option.select.options, option);\n  	}\n  }\n\n  function findParentSelect(element) {\n  	if (!element) {\n  		return;\n  	}\n\n  	do {\n  		if (element.name === "select") {\n  			return element;\n  		}\n  	} while (element = element.parent);\n  }\n\n  var Element_prototype_init = Element$init;\n  function Element$init(options) {\n  	var parentFragment, template, ractive, binding, bindings, twoway, bindingAttrs;\n\n  	this.type = ELEMENT;\n\n  	// stuff we\'ll need later\n  	parentFragment = this.parentFragment = options.parentFragment;\n  	template = this.template = options.template;\n\n  	this.parent = options.pElement || parentFragment.pElement;\n\n  	this.root = ractive = parentFragment.root;\n  	this.index = options.index;\n  	this.key = options.key;\n\n  	this.name = enforceCase(template.e);\n\n  	// Special case - <option> elements\n  	if (this.name === "option") {\n  		special_option__init(this, template);\n  	}\n\n  	// Special case - <select> elements\n  	if (this.name === "select") {\n  		this.options = [];\n  		this.bubble = select__bubble; // TODO this is a kludge\n  	}\n\n  	// Special case - <form> elements\n  	if (this.name === "form") {\n  		this.formBindings = [];\n  	}\n\n  	// handle binding attributes first (twoway, lazy)\n  	bindingAttrs = processBindingAttributes(this, template);\n\n  	// create attributes\n  	this.attributes = createAttributes(this, template.a);\n  	this.conditionalAttributes = createConditionalAttributes(this, template.m);\n\n  	// append children, if there are any\n  	if (template.f) {\n  		this.fragment = new virtualdom_Fragment({\n  			template: template.f,\n  			root: ractive,\n  			owner: this,\n  			pElement: this,\n  			cssIds: null\n  		});\n  	}\n\n  	// the element setting should override the ractive setting\n  	twoway = ractive.twoway;\n  	if (bindingAttrs.twoway === false) twoway = false;else if (bindingAttrs.twoway === true) twoway = true;\n\n  	this.twoway = twoway;\n  	this.lazy = bindingAttrs.lazy;\n\n  	// create twoway binding\n  	if (twoway && (binding = init_createTwowayBinding(this, template.a))) {\n  		this.binding = binding;\n\n  		// register this with the root, so that we can do ractive.updateModel()\n  		bindings = this.root._twowayBindings[binding.keypath.str] || (this.root._twowayBindings[binding.keypath.str] = []);\n  		bindings.push(binding);\n  	}\n\n  	// create event proxies\n  	if (template.v) {\n  		this.eventHandlers = createEventHandlers(this, template.v);\n  	}\n\n  	// create decorator\n  	if (template.o) {\n  		this.decorator = new _Decorator(this, template.o);\n  	}\n\n  	// create transitions\n  	this.intro = template.t0 || template.t1;\n  	this.outro = template.t0 || template.t2;\n  }\n\n  var Element_prototype_rebind = Element$rebind;\n  function Element$rebind(oldKeypath, newKeypath) {\n  	var i, storage, liveQueries, ractive;\n\n  	if (this.attributes) {\n  		this.attributes.forEach(rebind);\n  	}\n\n  	if (this.conditionalAttributes) {\n  		this.conditionalAttributes.forEach(rebind);\n  	}\n\n  	if (this.eventHandlers) {\n  		this.eventHandlers.forEach(rebind);\n  	}\n\n  	if (this.decorator) {\n  		rebind(this.decorator);\n  	}\n\n  	// rebind children\n  	if (this.fragment) {\n  		rebind(this.fragment);\n  	}\n\n  	// Update live queries, if necessary\n  	if (liveQueries = this.liveQueries) {\n  		ractive = this.root;\n\n  		i = liveQueries.length;\n  		while (i--) {\n  			liveQueries[i]._makeDirty();\n  		}\n  	}\n\n  	if (this.node && (storage = this.node._ractive)) {\n\n  		// adjust keypath if needed\n  		assignNewKeypath(storage, "keypath", oldKeypath, newKeypath);\n  	}\n\n  	function rebind(thing) {\n  		thing.rebind(oldKeypath, newKeypath);\n  	}\n  }\n\n  function special_img__render(img) {\n  	var loadHandler;\n\n  	// if this is an <img>, and we\'re in a crap browser, we may need to prevent it\n  	// from overriding width and height when it loads the src\n  	if (img.attributes.width || img.attributes.height) {\n  		img.node.addEventListener("load", loadHandler = function () {\n  			var width = img.getAttribute("width"),\n  			    height = img.getAttribute("height");\n\n  			if (width !== undefined) {\n  				img.node.setAttribute("width", width);\n  			}\n\n  			if (height !== undefined) {\n  				img.node.setAttribute("height", height);\n  			}\n\n  			img.node.removeEventListener("load", loadHandler, false);\n  		}, false);\n  	}\n  }\n\n  function form__render(element) {\n  	element.node.addEventListener("reset", handleReset, false);\n  }\n\n  function form__unrender(element) {\n  	element.node.removeEventListener("reset", handleReset, false);\n  }\n\n  function handleReset() {\n  	var element = this._ractive.proxy;\n\n  	global_runloop.start();\n  	element.formBindings.forEach(updateModel);\n  	global_runloop.end();\n  }\n\n  function updateModel(binding) {\n  	binding.root.viewmodel.set(binding.keypath, binding.resetValue);\n  }\n\n  var Transition_prototype_init = Transition$init;\n  function Transition$init(element, template, isIntro) {\n  	var ractive, name, fragment;\n\n  	this.element = element;\n  	this.root = ractive = element.root;\n  	this.isIntro = isIntro;\n\n  	name = template.n || template;\n\n  	if (typeof name !== "string") {\n  		fragment = new virtualdom_Fragment({\n  			template: name,\n  			root: ractive,\n  			owner: element\n  		});\n\n  		name = fragment.toString();\n  		fragment.unbind();\n\n  		if (name === "") {\n  			// empty string okay, just no transition\n  			return;\n  		}\n  	}\n\n  	this.name = name;\n\n  	if (template.a) {\n  		this.params = template.a;\n  	} else if (template.d) {\n  		// TODO is there a way to interpret dynamic arguments without all the\n  		// \'dependency thrashing\'?\n  		fragment = new virtualdom_Fragment({\n  			template: template.d,\n  			root: ractive,\n  			owner: element\n  		});\n\n  		this.params = fragment.getArgsList();\n  		fragment.unbind();\n  	}\n\n  	this._fn = findInViewHierarchy("transitions", ractive, name);\n\n  	if (!this._fn) {\n  		warnOnceIfDebug(missingPlugin(name, "transition"), { ractive: this.root });\n  	}\n  }\n\n  var camelCase = function (hyphenatedStr) {\n  	return hyphenatedStr.replace(/-([a-zA-Z])/g, function (match, $1) {\n  		return $1.toUpperCase();\n  	});\n  };\n\n  var helpers_prefix__prefix, prefixCache, helpers_prefix__testStyle;\n\n  if (!isClient) {\n  	helpers_prefix__prefix = null;\n  } else {\n  	prefixCache = {};\n  	helpers_prefix__testStyle = createElement("div").style;\n\n  	helpers_prefix__prefix = function (prop) {\n  		var i, vendor, capped;\n\n  		prop = camelCase(prop);\n\n  		if (!prefixCache[prop]) {\n  			if (helpers_prefix__testStyle[prop] !== undefined) {\n  				prefixCache[prop] = prop;\n  			} else {\n  				// test vendors...\n  				capped = prop.charAt(0).toUpperCase() + prop.substring(1);\n\n  				i = vendors.length;\n  				while (i--) {\n  					vendor = vendors[i];\n  					if (helpers_prefix__testStyle[vendor + capped] !== undefined) {\n  						prefixCache[prop] = vendor + capped;\n  						break;\n  					}\n  				}\n  			}\n  		}\n\n  		return prefixCache[prop];\n  	};\n  }\n\n  var helpers_prefix = helpers_prefix__prefix;\n\n  var getStyle, prototype_getStyle__getComputedStyle;\n\n  if (!isClient) {\n  	getStyle = null;\n  } else {\n  	prototype_getStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n  	getStyle = function (props) {\n  		var computedStyle, styles, i, prop, value;\n\n  		computedStyle = prototype_getStyle__getComputedStyle(this.node);\n\n  		if (typeof props === "string") {\n  			value = computedStyle[helpers_prefix(props)];\n  			if (value === "0px") {\n  				value = 0;\n  			}\n  			return value;\n  		}\n\n  		if (!isArray(props)) {\n  			throw new Error("Transition$getStyle must be passed a string, or an array of strings representing CSS properties");\n  		}\n\n  		styles = {};\n\n  		i = props.length;\n  		while (i--) {\n  			prop = props[i];\n  			value = computedStyle[helpers_prefix(prop)];\n  			if (value === "0px") {\n  				value = 0;\n  			}\n  			styles[prop] = value;\n  		}\n\n  		return styles;\n  	};\n  }\n\n  var prototype_getStyle = getStyle;\n\n  var setStyle = function (style, value) {\n  	var prop;\n\n  	if (typeof style === "string") {\n  		this.node.style[helpers_prefix(style)] = value;\n  	} else {\n  		for (prop in style) {\n  			if (style.hasOwnProperty(prop)) {\n  				this.node.style[helpers_prefix(prop)] = style[prop];\n  			}\n  		}\n  	}\n\n  	return this;\n  };\n\n  var Ticker = function (options) {\n  	var easing;\n\n  	this.duration = options.duration;\n  	this.step = options.step;\n  	this.complete = options.complete;\n\n  	// easing\n  	if (typeof options.easing === "string") {\n  		easing = options.root.easing[options.easing];\n\n  		if (!easing) {\n  			warnOnceIfDebug(missingPlugin(options.easing, "easing"));\n  			easing = linear;\n  		}\n  	} else if (typeof options.easing === "function") {\n  		easing = options.easing;\n  	} else {\n  		easing = linear;\n  	}\n\n  	this.easing = easing;\n\n  	this.start = utils_getTime();\n  	this.end = this.start + this.duration;\n\n  	this.running = true;\n  	shared_animations.add(this);\n  };\n\n  Ticker.prototype = {\n  	tick: function (now) {\n  		var elapsed, eased;\n\n  		if (!this.running) {\n  			return false;\n  		}\n\n  		if (now > this.end) {\n  			if (this.step) {\n  				this.step(1);\n  			}\n\n  			if (this.complete) {\n  				this.complete(1);\n  			}\n\n  			return false;\n  		}\n\n  		elapsed = now - this.start;\n  		eased = this.easing(elapsed / this.duration);\n\n  		if (this.step) {\n  			this.step(eased);\n  		}\n\n  		return true;\n  	},\n\n  	stop: function () {\n  		if (this.abort) {\n  			this.abort();\n  		}\n\n  		this.running = false;\n  	}\n  };\n\n  var shared_Ticker = Ticker;\n  function linear(t) {\n  	return t;\n  }\n\n  var unprefixPattern = new RegExp("^-(?:" + vendors.join("|") + ")-");\n\n  var unprefix = function (prop) {\n  	return prop.replace(unprefixPattern, "");\n  };\n\n  var vendorPattern = new RegExp("^(?:" + vendors.join("|") + ")([A-Z])");\n\n  var hyphenate = function (str) {\n  	var hyphenated;\n\n  	if (!str) {\n  		return ""; // edge case\n  	}\n\n  	if (vendorPattern.test(str)) {\n  		str = "-" + str;\n  	}\n\n  	hyphenated = str.replace(/[A-Z]/g, function (match) {\n  		return "-" + match.toLowerCase();\n  	});\n\n  	return hyphenated;\n  };\n\n  var createTransitions,\n      animateStyle_createTransitions__testStyle,\n      TRANSITION,\n      TRANSITIONEND,\n      CSS_TRANSITIONS_ENABLED,\n      TRANSITION_DURATION,\n      TRANSITION_PROPERTY,\n      TRANSITION_TIMING_FUNCTION,\n      canUseCssTransitions = {},\n      cannotUseCssTransitions = {};\n\n  if (!isClient) {\n  	createTransitions = null;\n  } else {\n  	animateStyle_createTransitions__testStyle = createElement("div").style;\n\n  	// determine some facts about our environment\n  	(function () {\n  		if (animateStyle_createTransitions__testStyle.transition !== undefined) {\n  			TRANSITION = "transition";\n  			TRANSITIONEND = "transitionend";\n  			CSS_TRANSITIONS_ENABLED = true;\n  		} else if (animateStyle_createTransitions__testStyle.webkitTransition !== undefined) {\n  			TRANSITION = "webkitTransition";\n  			TRANSITIONEND = "webkitTransitionEnd";\n  			CSS_TRANSITIONS_ENABLED = true;\n  		} else {\n  			CSS_TRANSITIONS_ENABLED = false;\n  		}\n  	})();\n\n  	if (TRANSITION) {\n  		TRANSITION_DURATION = TRANSITION + "Duration";\n  		TRANSITION_PROPERTY = TRANSITION + "Property";\n  		TRANSITION_TIMING_FUNCTION = TRANSITION + "TimingFunction";\n  	}\n\n  	createTransitions = function (t, to, options, changedProperties, resolve) {\n\n  		// Wait a beat (otherwise the target styles will be applied immediately)\n  		// TODO use a fastdom-style mechanism?\n  		setTimeout(function () {\n\n  			var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;\n\n  			checkComplete = function () {\n  				if (jsTransitionsComplete && cssTransitionsComplete) {\n  					// will changes to events and fire have an unexpected consequence here?\n  					t.root.fire(t.name + ":end", t.node, t.isIntro);\n  					resolve();\n  				}\n  			};\n\n  			// this is used to keep track of which elements can use CSS to animate\n  			// which properties\n  			hashPrefix = (t.node.namespaceURI || "") + t.node.tagName;\n\n  			t.node.style[TRANSITION_PROPERTY] = changedProperties.map(helpers_prefix).map(hyphenate).join(",");\n  			t.node.style[TRANSITION_TIMING_FUNCTION] = hyphenate(options.easing || "linear");\n  			t.node.style[TRANSITION_DURATION] = options.duration / 1000 + "s";\n\n  			transitionEndHandler = function (event) {\n  				var index;\n\n  				index = changedProperties.indexOf(camelCase(unprefix(event.propertyName)));\n  				if (index !== -1) {\n  					changedProperties.splice(index, 1);\n  				}\n\n  				if (changedProperties.length) {\n  					// still transitioning...\n  					return;\n  				}\n\n  				t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n  				cssTransitionsComplete = true;\n  				checkComplete();\n  			};\n\n  			t.node.addEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n  			setTimeout(function () {\n  				var i = changedProperties.length,\n  				    hash,\n  				    originalValue,\n  				    index,\n  				    propertiesToTransitionInJs = [],\n  				    prop,\n  				    suffix;\n\n  				while (i--) {\n  					prop = changedProperties[i];\n  					hash = hashPrefix + prop;\n\n  					if (CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[hash]) {\n  						t.node.style[helpers_prefix(prop)] = to[prop];\n\n  						// If we\'re not sure if CSS transitions are supported for\n  						// this tag/property combo, find out now\n  						if (!canUseCssTransitions[hash]) {\n  							originalValue = t.getStyle(prop);\n\n  							// if this property is transitionable in this browser,\n  							// the current style will be different from the target style\n  							canUseCssTransitions[hash] = t.getStyle(prop) != to[prop];\n  							cannotUseCssTransitions[hash] = !canUseCssTransitions[hash];\n\n  							// Reset, if we\'re going to use timers after all\n  							if (cannotUseCssTransitions[hash]) {\n  								t.node.style[helpers_prefix(prop)] = originalValue;\n  							}\n  						}\n  					}\n\n  					if (!CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[hash]) {\n  						// we need to fall back to timer-based stuff\n  						if (originalValue === undefined) {\n  							originalValue = t.getStyle(prop);\n  						}\n\n  						// need to remove this from changedProperties, otherwise transitionEndHandler\n  						// will get confused\n  						index = changedProperties.indexOf(prop);\n  						if (index === -1) {\n  							warnIfDebug("Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!", { node: t.node });\n  						} else {\n  							changedProperties.splice(index, 1);\n  						}\n\n  						// TODO Determine whether this property is animatable at all\n\n  						suffix = /[^\\d]*$/.exec(to[prop])[0];\n\n  						// ...then kick off a timer-based transition\n  						propertiesToTransitionInJs.push({\n  							name: helpers_prefix(prop),\n  							interpolator: shared_interpolate(parseFloat(originalValue), parseFloat(to[prop])),\n  							suffix: suffix\n  						});\n  					}\n  				}\n\n  				// javascript transitions\n  				if (propertiesToTransitionInJs.length) {\n  					new shared_Ticker({\n  						root: t.root,\n  						duration: options.duration,\n  						easing: camelCase(options.easing || ""),\n  						step: function (pos) {\n  							var prop, i;\n\n  							i = propertiesToTransitionInJs.length;\n  							while (i--) {\n  								prop = propertiesToTransitionInJs[i];\n  								t.node.style[prop.name] = prop.interpolator(pos) + prop.suffix;\n  							}\n  						},\n  						complete: function () {\n  							jsTransitionsComplete = true;\n  							checkComplete();\n  						}\n  					});\n  				} else {\n  					jsTransitionsComplete = true;\n  				}\n\n  				if (!changedProperties.length) {\n  					// We need to cancel the transitionEndHandler, and deal with\n  					// the fact that it will never fire\n  					t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n  					cssTransitionsComplete = true;\n  					checkComplete();\n  				}\n  			}, 0);\n  		}, options.delay || 0);\n  	};\n  }\n\n  var animateStyle_createTransitions = createTransitions;\n\n  var hidden, vendor, animateStyle_visibility__prefix, animateStyle_visibility__i, visibility;\n\n  if (typeof document !== "undefined") {\n  	hidden = "hidden";\n\n  	visibility = {};\n\n  	if (hidden in document) {\n  		animateStyle_visibility__prefix = "";\n  	} else {\n  		animateStyle_visibility__i = vendors.length;\n  		while (animateStyle_visibility__i--) {\n  			vendor = vendors[animateStyle_visibility__i];\n  			hidden = vendor + "Hidden";\n\n  			if (hidden in document) {\n  				animateStyle_visibility__prefix = vendor;\n  			}\n  		}\n  	}\n\n  	if (animateStyle_visibility__prefix !== undefined) {\n  		document.addEventListener(animateStyle_visibility__prefix + "visibilitychange", onChange);\n\n  		// initialise\n  		onChange();\n  	} else {\n  		// gah, we\'re in an old browser\n  		if ("onfocusout" in document) {\n  			document.addEventListener("focusout", onHide);\n  			document.addEventListener("focusin", onShow);\n  		} else {\n  			window.addEventListener("pagehide", onHide);\n  			window.addEventListener("blur", onHide);\n\n  			window.addEventListener("pageshow", onShow);\n  			window.addEventListener("focus", onShow);\n  		}\n\n  		visibility.hidden = false; // until proven otherwise. Not ideal but hey\n  	}\n  }\n\n  function onChange() {\n  	visibility.hidden = document[hidden];\n  }\n\n  function onHide() {\n  	visibility.hidden = true;\n  }\n\n  function onShow() {\n  	visibility.hidden = false;\n  }\n\n  var animateStyle_visibility = visibility;\n\n  var animateStyle, _animateStyle__getComputedStyle, resolved;\n\n  if (!isClient) {\n  	animateStyle = null;\n  } else {\n  	_animateStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n  	animateStyle = function (style, value, options) {\n  		var _this = this;\n\n  		var to;\n\n  		if (arguments.length === 4) {\n  			throw new Error("t.animateStyle() returns a promise - use .then() instead of passing a callback");\n  		}\n\n  		// Special case - page isn\'t visible. Don\'t animate anything, because\n  		// that way you\'ll never get CSS transitionend events\n  		if (animateStyle_visibility.hidden) {\n  			this.setStyle(style, value);\n  			return resolved || (resolved = utils_Promise.resolve());\n  		}\n\n  		if (typeof style === "string") {\n  			to = {};\n  			to[style] = value;\n  		} else {\n  			to = style;\n\n  			// shuffle arguments\n  			options = value;\n  		}\n\n  		// As of 0.3.9, transition authors should supply an `option` object with\n  		// `duration` and `easing` properties (and optional `delay`), plus a\n  		// callback function that gets called after the animation completes\n\n  		// TODO remove this check in a future version\n  		if (!options) {\n  			warnOnceIfDebug("The \\"%s\\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340", this.name);\n  			options = this;\n  		}\n\n  		var promise = new utils_Promise(function (resolve) {\n  			var propertyNames, changedProperties, computedStyle, current, from, i, prop;\n\n  			// Edge case - if duration is zero, set style synchronously and complete\n  			if (!options.duration) {\n  				_this.setStyle(to);\n  				resolve();\n  				return;\n  			}\n\n  			// Get a list of the properties we\'re animating\n  			propertyNames = Object.keys(to);\n  			changedProperties = [];\n\n  			// Store the current styles\n  			computedStyle = _animateStyle__getComputedStyle(_this.node);\n\n  			from = {};\n  			i = propertyNames.length;\n  			while (i--) {\n  				prop = propertyNames[i];\n  				current = computedStyle[helpers_prefix(prop)];\n\n  				if (current === "0px") {\n  					current = 0;\n  				}\n\n  				// we need to know if we\'re actually changing anything\n  				if (current != to[prop]) {\n  					// use != instead of !==, so we can compare strings with numbers\n  					changedProperties.push(prop);\n\n  					// make the computed style explicit, so we can animate where\n  					// e.g. height=\'auto\'\n  					_this.node.style[helpers_prefix(prop)] = current;\n  				}\n  			}\n\n  			// If we\'re not actually changing anything, the transitionend event\n  			// will never fire! So we complete early\n  			if (!changedProperties.length) {\n  				resolve();\n  				return;\n  			}\n\n  			animateStyle_createTransitions(_this, to, options, changedProperties, resolve);\n  		});\n\n  		return promise;\n  	};\n  }\n\n  var _animateStyle = animateStyle;\n\n  var processParams = function (params, defaults) {\n  	if (typeof params === "number") {\n  		params = { duration: params };\n  	} else if (typeof params === "string") {\n  		if (params === "slow") {\n  			params = { duration: 600 };\n  		} else if (params === "fast") {\n  			params = { duration: 200 };\n  		} else {\n  			params = { duration: 400 };\n  		}\n  	} else if (!params) {\n  		params = {};\n  	}\n\n  	return fillGaps({}, params, defaults);\n  };\n\n  var prototype_start = Transition$start;\n\n  function Transition$start() {\n  	var _this = this;\n\n  	var node, originalStyle, completed;\n\n  	node = this.node = this.element.node;\n  	originalStyle = node.getAttribute("style");\n\n  	// create t.complete() - we don\'t want this on the prototype,\n  	// because we don\'t want `this` silliness when passing it as\n  	// an argument\n  	this.complete = function (noReset) {\n  		if (completed) {\n  			return;\n  		}\n\n  		if (!noReset && _this.isIntro) {\n  			resetStyle(node, originalStyle);\n  		}\n\n  		node._ractive.transition = null;\n  		_this._manager.remove(_this);\n\n  		completed = true;\n  	};\n\n  	// If the transition function doesn\'t exist, abort\n  	if (!this._fn) {\n  		this.complete();\n  		return;\n  	}\n\n  	this._fn.apply(this.root, [this].concat(this.params));\n  }\n\n  function resetStyle(node, style) {\n  	if (style) {\n  		node.setAttribute("style", style);\n  	} else {\n\n  		// Next line is necessary, to remove empty style attribute!\n  		// See http://stackoverflow.com/a/7167553\n  		node.getAttribute("style");\n  		node.removeAttribute("style");\n  	}\n  }\n\n  var Transition = function (owner, template, isIntro) {\n  	this.init(owner, template, isIntro);\n  };\n\n  Transition.prototype = {\n  	init: Transition_prototype_init,\n  	start: prototype_start,\n  	getStyle: prototype_getStyle,\n  	setStyle: setStyle,\n  	animateStyle: _animateStyle,\n  	processParams: processParams\n  };\n\n  var _Transition = Transition;\n\n  var Element_prototype_render = Element$render;\n\n  var updateCss, updateScript;\n\n  updateCss = function () {\n  	var node = this.node,\n  	    content = this.fragment.toString(false);\n\n  	// IE8 has no styleSheet unless there\'s a type text/css\n  	if (window && window.appearsToBeIELessEqual8) {\n  		node.type = "text/css";\n  	}\n\n  	if (node.styleSheet) {\n  		node.styleSheet.cssText = content;\n  	} else {\n\n  		while (node.hasChildNodes()) {\n  			node.removeChild(node.firstChild);\n  		}\n\n  		node.appendChild(document.createTextNode(content));\n  	}\n  };\n\n  updateScript = function () {\n  	if (!this.node.type || this.node.type === "text/javascript") {\n  		warnIfDebug("Script tag was updated. This does not cause the code to be re-evaluated!", { ractive: this.root });\n  		// As it happens, we ARE in a position to re-evaluate the code if we wanted\n  		// to - we could eval() it, or insert it into a fresh (temporary) script tag.\n  		// But this would be a terrible idea with unpredictable results, so let\'s not.\n  	}\n\n  	this.node.text = this.fragment.toString(false);\n  };\n  function Element$render() {\n  	var _this = this;\n\n  	var root = this.root,\n  	    namespace,\n  	    node,\n  	    transition;\n\n  	namespace = getNamespace(this);\n  	node = this.node = createElement(this.name, namespace);\n\n  	// Is this a top-level node of a component? If so, we may need to add\n  	// a data-ractive-css attribute, for CSS encapsulation\n  	if (this.parentFragment.cssIds) {\n  		this.node.setAttribute("data-ractive-css", this.parentFragment.cssIds.map(function (x) {\n  			return "{" + x + "}";\n  		}).join(" "));\n  	}\n\n  	// Add _ractive property to the node - we use this object to store stuff\n  	// related to proxy events, two-way bindings etc\n  	defineProperty(this.node, "_ractive", {\n  		value: {\n  			proxy: this,\n  			keypath: getInnerContext(this.parentFragment),\n  			events: create(null),\n  			root: root\n  		}\n  	});\n\n  	// Render attributes\n  	this.attributes.forEach(function (a) {\n  		return a.render(node);\n  	});\n  	this.conditionalAttributes.forEach(function (a) {\n  		return a.render(node);\n  	});\n\n  	// Render children\n  	if (this.fragment) {\n  		// Special case - <script> element\n  		if (this.name === "script") {\n  			this.bubble = updateScript;\n  			this.node.text = this.fragment.toString(false); // bypass warning initially\n  			this.fragment.unrender = noop; // TODO this is a kludge\n  		}\n\n  		// Special case - <style> element\n  		else if (this.name === "style") {\n  			this.bubble = updateCss;\n  			this.bubble();\n  			this.fragment.unrender = noop;\n  		}\n\n  		// Special case - contenteditable\n  		else if (this.binding && this.getAttribute("contenteditable")) {\n  			this.fragment.unrender = noop;\n  		} else {\n  			this.node.appendChild(this.fragment.render());\n  		}\n  	}\n\n  	// deal with two-way bindings\n  	if (this.binding) {\n  		this.binding.render();\n  		this.node._ractive.binding = this.binding;\n  	}\n\n  	// Add proxy event handlers\n  	if (this.eventHandlers) {\n  		this.eventHandlers.forEach(function (h) {\n  			return h.render();\n  		});\n  	}\n\n  	if (this.name === "option") {\n  		processOption(this);\n  	}\n\n  	// Special cases\n  	if (this.name === "img") {\n  		// if this is an <img>, and we\'re in a crap browser, we may\n  		// need to prevent it from overriding width and height when\n  		// it loads the src\n  		special_img__render(this);\n  	} else if (this.name === "form") {\n  		// forms need to keep track of their bindings, in case of reset\n  		form__render(this);\n  	} else if (this.name === "input" || this.name === "textarea") {\n  		// inputs and textareas should store their initial value as\n  		// `defaultValue` in case of reset\n  		this.node.defaultValue = this.node.value;\n  	} else if (this.name === "option") {\n  		// similarly for option nodes\n  		this.node.defaultSelected = this.node.selected;\n  	}\n\n  	// apply decorator(s)\n  	if (this.decorator && this.decorator.fn) {\n  		global_runloop.scheduleTask(function () {\n  			if (!_this.decorator.torndown) {\n  				_this.decorator.init();\n  			}\n  		}, true);\n  	}\n\n  	// trigger intro transition\n  	if (root.transitionsEnabled && this.intro) {\n  		transition = new _Transition(this, this.intro, true);\n  		global_runloop.registerTransition(transition);\n  		global_runloop.scheduleTask(function () {\n  			return transition.start();\n  		}, true);\n\n  		this.transition = transition;\n  	}\n\n  	if (this.node.autofocus) {\n  		// Special case. Some browsers (*cough* Firefix *cough*) have a problem\n  		// with dynamically-generated elements having autofocus, and they won\'t\n  		// allow you to programmatically focus the element until it\'s in the DOM\n  		global_runloop.scheduleTask(function () {\n  			return _this.node.focus();\n  		}, true);\n  	}\n\n  	updateLiveQueries(this);\n  	return this.node;\n  }\n\n  function getNamespace(element) {\n  	var namespace, xmlns, parent;\n\n  	// Use specified namespace...\n  	if (xmlns = element.getAttribute("xmlns")) {\n  		namespace = xmlns;\n  	}\n\n  	// ...or SVG namespace, if this is an <svg> element\n  	else if (element.name === "svg") {\n  		namespace = namespaces.svg;\n  	} else if (parent = element.parent) {\n  		// ...or HTML, if the parent is a <foreignObject>\n  		if (parent.name === "foreignObject") {\n  			namespace = namespaces.html;\n  		}\n\n  		// ...or inherit from the parent node\n  		else {\n  			namespace = parent.node.namespaceURI;\n  		}\n  	} else {\n  		namespace = element.root.el.namespaceURI;\n  	}\n\n  	return namespace;\n  }\n\n  function processOption(option) {\n  	var optionValue, selectValue, i;\n\n  	if (!option.select) {\n  		return;\n  	}\n\n  	selectValue = option.select.getAttribute("value");\n  	if (selectValue === undefined) {\n  		return;\n  	}\n\n  	optionValue = option.getAttribute("value");\n\n  	if (option.select.node.multiple && isArray(selectValue)) {\n  		i = selectValue.length;\n  		while (i--) {\n  			if (optionValue == selectValue[i]) {\n  				option.node.selected = true;\n  				break;\n  			}\n  		}\n  	} else {\n  		option.node.selected = optionValue == selectValue;\n  	}\n  }\n\n  function updateLiveQueries(element) {\n  	var instance, liveQueries, i, selector, query;\n\n  	// Does this need to be added to any live queries?\n  	instance = element.root;\n\n  	do {\n  		liveQueries = instance._liveQueries;\n\n  		i = liveQueries.length;\n  		while (i--) {\n  			selector = liveQueries[i];\n  			query = liveQueries["_" + selector];\n\n  			if (query._test(element)) {\n  				// keep register of applicable selectors, for when we teardown\n  				(element.liveQueries || (element.liveQueries = [])).push(query);\n  			}\n  		}\n  	} while (instance = instance.parent);\n  }\n\n  var Element_prototype_toString = function () {\n  	var str, escape;\n\n  	if (this.template.y) {\n  		// DOCTYPE declaration\n  		return "<!DOCTYPE" + this.template.dd + ">";\n  	}\n\n  	str = "<" + this.template.e;\n\n  	str += this.attributes.map(stringifyAttribute).join("") + this.conditionalAttributes.map(stringifyAttribute).join("");\n\n  	// Special case - selected options\n  	if (this.name === "option" && optionIsSelected(this)) {\n  		str += " selected";\n  	}\n\n  	// Special case - two-way radio name bindings\n  	if (this.name === "input" && inputIsCheckedRadio(this)) {\n  		str += " checked";\n  	}\n\n  	str += ">";\n\n  	// Special case - textarea\n  	if (this.name === "textarea" && this.getAttribute("value") !== undefined) {\n  		str += escapeHtml(this.getAttribute("value"));\n  	}\n\n  	// Special case - contenteditable\n  	else if (this.getAttribute("contenteditable") !== undefined) {\n  		str += this.getAttribute("value") || "";\n  	}\n\n  	if (this.fragment) {\n  		escape = this.name !== "script" && this.name !== "style";\n  		str += this.fragment.toString(escape);\n  	}\n\n  	// add a closing tag if this isn\'t a void element\n  	if (!voidElementNames.test(this.template.e)) {\n  		str += "</" + this.template.e + ">";\n  	}\n\n  	return str;\n  };\n\n  function optionIsSelected(element) {\n  	var optionValue, selectValue, i;\n\n  	optionValue = element.getAttribute("value");\n\n  	if (optionValue === undefined || !element.select) {\n  		return false;\n  	}\n\n  	selectValue = element.select.getAttribute("value");\n\n  	if (selectValue == optionValue) {\n  		return true;\n  	}\n\n  	if (element.select.getAttribute("multiple") && isArray(selectValue)) {\n  		i = selectValue.length;\n  		while (i--) {\n  			if (selectValue[i] == optionValue) {\n  				return true;\n  			}\n  		}\n  	}\n  }\n\n  function inputIsCheckedRadio(element) {\n  	var attributes, typeAttribute, valueAttribute, nameAttribute;\n\n  	attributes = element.attributes;\n\n  	typeAttribute = attributes.type;\n  	valueAttribute = attributes.value;\n  	nameAttribute = attributes.name;\n\n  	if (!typeAttribute || typeAttribute.value !== "radio" || !valueAttribute || !nameAttribute.interpolator) {\n  		return;\n  	}\n\n  	if (valueAttribute.value === nameAttribute.interpolator.value) {\n  		return true;\n  	}\n  }\n\n  function stringifyAttribute(attribute) {\n  	var str = attribute.toString();\n  	return str ? " " + str : "";\n  }\n\n  var Element_prototype_unbind = Element$unbind;\n  function Element$unbind() {\n  	if (this.fragment) {\n  		this.fragment.unbind();\n  	}\n\n  	if (this.binding) {\n  		this.binding.unbind();\n  	}\n\n  	if (this.eventHandlers) {\n  		this.eventHandlers.forEach(methodCallers__unbind);\n  	}\n\n  	// Special case - <option>\n  	if (this.name === "option") {\n  		special_option__unbind(this);\n  	}\n\n  	this.attributes.forEach(methodCallers__unbind);\n  	this.conditionalAttributes.forEach(methodCallers__unbind);\n  }\n\n  var Element_prototype_unrender = Element$unrender;\n\n  function Element$unrender(shouldDestroy) {\n  	var binding, bindings, transition;\n\n  	if (transition = this.transition) {\n  		transition.complete();\n  	}\n\n  	// Detach as soon as we can\n  	if (this.name === "option") {\n  		// <option> elements detach immediately, so that\n  		// their parent <select> element syncs correctly, and\n  		// since option elements can\'t have transitions anyway\n  		this.detach();\n  	} else if (shouldDestroy) {\n  		global_runloop.detachWhenReady(this);\n  	}\n\n  	// Children first. that way, any transitions on child elements will be\n  	// handled by the current transitionManager\n  	if (this.fragment) {\n  		this.fragment.unrender(false);\n  	}\n\n  	if (binding = this.binding) {\n  		this.binding.unrender();\n\n  		this.node._ractive.binding = null;\n  		bindings = this.root._twowayBindings[binding.keypath.str];\n  		bindings.splice(bindings.indexOf(binding), 1);\n  	}\n\n  	// Remove event handlers\n  	if (this.eventHandlers) {\n  		this.eventHandlers.forEach(methodCallers__unrender);\n  	}\n\n  	if (this.decorator) {\n  		global_runloop.registerDecorator(this.decorator);\n  	}\n\n  	// trigger outro transition if necessary\n  	if (this.root.transitionsEnabled && this.outro) {\n  		transition = new _Transition(this, this.outro, false);\n  		global_runloop.registerTransition(transition);\n  		global_runloop.scheduleTask(function () {\n  			return transition.start();\n  		});\n  	}\n\n  	// Remove this node from any live queries\n  	if (this.liveQueries) {\n  		removeFromLiveQueries(this);\n  	}\n\n  	if (this.name === "form") {\n  		form__unrender(this);\n  	}\n  }\n\n  function removeFromLiveQueries(element) {\n  	var query, selector, i;\n\n  	i = element.liveQueries.length;\n  	while (i--) {\n  		query = element.liveQueries[i];\n  		selector = query.selector;\n\n  		query._remove(element.node);\n  	}\n  }\n\n  var Element = function (options) {\n  	this.init(options);\n  };\n\n  Element.prototype = {\n  	bubble: Element_prototype_bubble,\n  	detach: Element_prototype_detach,\n  	find: Element_prototype_find,\n  	findAll: Element_prototype_findAll,\n  	findAllComponents: Element_prototype_findAllComponents,\n  	findComponent: Element_prototype_findComponent,\n  	findNextNode: Element_prototype_findNextNode,\n  	firstNode: Element_prototype_firstNode,\n  	getAttribute: getAttribute,\n  	init: Element_prototype_init,\n  	rebind: Element_prototype_rebind,\n  	render: Element_prototype_render,\n  	toString: Element_prototype_toString,\n  	unbind: Element_prototype_unbind,\n  	unrender: Element_prototype_unrender\n  };\n\n  var _Element = Element;\n\n  var deIndent__empty = /^\\s*$/,\n      deIndent__leadingWhitespace = /^\\s*/;\n\n  var deIndent = function (str) {\n  	var lines, firstLine, lastLine, minIndent;\n\n  	lines = str.split("\\n");\n\n  	// remove first and last line, if they only contain whitespace\n  	firstLine = lines[0];\n  	if (firstLine !== undefined && deIndent__empty.test(firstLine)) {\n  		lines.shift();\n  	}\n\n  	lastLine = lastItem(lines);\n  	if (lastLine !== undefined && deIndent__empty.test(lastLine)) {\n  		lines.pop();\n  	}\n\n  	minIndent = lines.reduce(reducer, null);\n\n  	if (minIndent) {\n  		str = lines.map(function (line) {\n  			return line.replace(minIndent, "");\n  		}).join("\\n");\n  	}\n\n  	return str;\n  };\n\n  function reducer(previous, line) {\n  	var lineIndent = deIndent__leadingWhitespace.exec(line)[0];\n\n  	if (previous === null || lineIndent.length < previous.length) {\n  		return lineIndent;\n  	}\n\n  	return previous;\n  }\n\n  var Partial_getPartialTemplate = getPartialTemplate;\n\n  function getPartialTemplate(ractive, name, parentFragment) {\n  	var partial;\n\n  	// If the partial in instance or view heirarchy instances, great\n  	if (partial = getPartialFromRegistry(ractive, name, parentFragment || {})) {\n  		return partial;\n  	}\n\n  	// Does it exist on the page as a script tag?\n  	partial = template_parser.fromId(name, { noThrow: true });\n\n  	if (partial) {\n  		// is this necessary?\n  		partial = deIndent(partial);\n\n  		// parse and register to this ractive instance\n  		var parsed = template_parser.parse(partial, template_parser.getParseOptions(ractive));\n\n  		// register (and return main partial if there are others in the template)\n  		return ractive.partials[name] = parsed.t;\n  	}\n  }\n\n  function getPartialFromRegistry(ractive, name, parentFragment) {\n  	var fn = undefined,\n  	    partial = findParentPartial(name, parentFragment.owner);\n\n  	// if there was an instance up-hierarchy, cool\n  	if (partial) return partial;\n\n  	// find first instance in the ractive or view hierarchy that has this partial\n  	var instance = findInstance("partials", ractive, name);\n\n  	if (!instance) {\n  		return;\n  	}\n\n  	partial = instance.partials[name];\n\n  	// partial is a function?\n  	if (typeof partial === "function") {\n  		fn = partial.bind(instance);\n  		fn.isOwner = instance.partials.hasOwnProperty(name);\n  		partial = fn.call(ractive, template_parser);\n  	}\n\n  	if (!partial && partial !== "") {\n  		warnIfDebug(noRegistryFunctionReturn, name, "partial", "partial", { ractive: ractive });\n  		return;\n  	}\n\n  	// If this was added manually to the registry,\n  	// but hasn\'t been parsed, parse it now\n  	if (!template_parser.isParsed(partial)) {\n\n  		// use the parseOptions of the ractive instance on which it was found\n  		var parsed = template_parser.parse(partial, template_parser.getParseOptions(instance));\n\n  		// Partials cannot contain nested partials!\n  		// TODO add a test for this\n  		if (parsed.p) {\n  			warnIfDebug("Partials ({{>%s}}) cannot contain nested inline partials", name, { ractive: ractive });\n  		}\n\n  		// if fn, use instance to store result, otherwise needs to go\n  		// in the correct point in prototype chain on instance or constructor\n  		var target = fn ? instance : findOwner(instance, name);\n\n  		// may be a template with partials, which need to be registered and main template extracted\n  		target.partials[name] = partial = parsed.t;\n  	}\n\n  	// store for reset\n  	if (fn) {\n  		partial._fn = fn;\n  	}\n\n  	return partial.v ? partial.t : partial;\n  }\n\n  function findOwner(ractive, key) {\n  	return ractive.partials.hasOwnProperty(key) ? ractive : findConstructor(ractive.constructor, key);\n  }\n\n  function findConstructor(constructor, key) {\n  	if (!constructor) {\n  		return;\n  	}\n  	return constructor.partials.hasOwnProperty(key) ? constructor : findConstructor(constructor._Parent, key);\n  }\n\n  function findParentPartial(name, parent) {\n  	if (parent) {\n  		if (parent.template && parent.template.p && parent.template.p[name]) {\n  			return parent.template.p[name];\n  		} else if (parent.parentFragment && parent.parentFragment.owner) {\n  			return findParentPartial(name, parent.parentFragment.owner);\n  		}\n  	}\n  }\n\n  var applyIndent = function (string, indent) {\n  	var indented;\n\n  	if (!indent) {\n  		return string;\n  	}\n\n  	indented = string.split("\\n").map(function (line, notFirstLine) {\n  		return notFirstLine ? indent + line : line;\n  	}).join("\\n");\n\n  	return indented;\n  };\n\n  var missingPartialMessage = "Could not find template for partial \\"%s\\"";\n\n  var Partial = function (options) {\n  	var parentFragment, template;\n\n  	parentFragment = this.parentFragment = options.parentFragment;\n\n  	this.root = parentFragment.root;\n  	this.type = PARTIAL;\n  	this.index = options.index;\n  	this.name = options.template.r;\n  	this.rendered = false;\n\n  	this.fragment = this.fragmentToRender = this.fragmentToUnrender = null;\n\n  	Mustache.init(this, options);\n\n  	// If this didn\'t resolve, it most likely means we have a named partial\n  	// (i.e. `{{>foo}}` means \'use the foo partial\', not \'use the partial\n  	// whose name is the value of `foo`\')\n  	if (!this.keypath) {\n  		if (template = Partial_getPartialTemplate(this.root, this.name, parentFragment)) {\n  			shared_unbind.call(this); // prevent any further changes\n  			this.isNamed = true;\n  			this.setTemplate(template);\n  		} else {\n  			warnOnceIfDebug(missingPartialMessage, this.name);\n  		}\n  	}\n  };\n\n  Partial.prototype = {\n  	bubble: function () {\n  		this.parentFragment.bubble();\n  	},\n\n  	detach: function () {\n  		return this.fragment.detach();\n  	},\n\n  	find: function (selector) {\n  		return this.fragment.find(selector);\n  	},\n\n  	findAll: function (selector, query) {\n  		return this.fragment.findAll(selector, query);\n  	},\n\n  	findComponent: function (selector) {\n  		return this.fragment.findComponent(selector);\n  	},\n\n  	findAllComponents: function (selector, query) {\n  		return this.fragment.findAllComponents(selector, query);\n  	},\n\n  	firstNode: function () {\n  		return this.fragment.firstNode();\n  	},\n\n  	findNextNode: function () {\n  		return this.parentFragment.findNextNode(this);\n  	},\n\n  	getPartialName: function () {\n  		if (this.isNamed && this.name) return this.name;else if (this.value === undefined) return this.name;else return this.value;\n  	},\n\n  	getValue: function () {\n  		return this.fragment.getValue();\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		// named partials aren\'t bound, so don\'t rebind\n  		if (!this.isNamed) {\n  			Mustache_rebind.call(this, oldKeypath, newKeypath);\n  		}\n\n  		if (this.fragment) {\n  			this.fragment.rebind(oldKeypath, newKeypath);\n  		}\n  	},\n\n  	render: function () {\n  		this.docFrag = document.createDocumentFragment();\n  		this.update();\n\n  		this.rendered = true;\n  		return this.docFrag;\n  	},\n\n  	resolve: Mustache.resolve,\n\n  	setValue: function (value) {\n  		var template;\n\n  		if (value !== undefined && value === this.value) {\n  			// nothing has changed, so no work to be done\n  			return;\n  		}\n\n  		if (value !== undefined) {\n  			template = Partial_getPartialTemplate(this.root, "" + value, this.parentFragment);\n  		}\n\n  		// we may be here if we have a partial like `{{>foo}}` and `foo` is the\n  		// name of both a data property (whose value ISN\'T the name of a partial)\n  		// and a partial. In those cases, this becomes a named partial\n  		if (!template && this.name && (template = Partial_getPartialTemplate(this.root, this.name, this.parentFragment))) {\n  			shared_unbind.call(this);\n  			this.isNamed = true;\n  		}\n\n  		if (!template) {\n  			warnOnceIfDebug(missingPartialMessage, this.name, { ractive: this.root });\n  		}\n\n  		this.value = value;\n\n  		this.setTemplate(template || []);\n\n  		this.bubble();\n\n  		if (this.rendered) {\n  			global_runloop.addView(this);\n  		}\n  	},\n\n  	setTemplate: function (template) {\n  		if (this.fragment) {\n  			this.fragment.unbind();\n  			if (this.rendered) {\n  				this.fragmentToUnrender = this.fragment;\n  			}\n  		}\n\n  		this.fragment = new virtualdom_Fragment({\n  			template: template,\n  			root: this.root,\n  			owner: this,\n  			pElement: this.parentFragment.pElement\n  		});\n\n  		this.fragmentToRender = this.fragment;\n  	},\n\n  	toString: function (toString) {\n  		var string, previousItem, lastLine, match;\n\n  		string = this.fragment.toString(toString);\n\n  		previousItem = this.parentFragment.items[this.index - 1];\n\n  		if (!previousItem || previousItem.type !== TEXT) {\n  			return string;\n  		}\n\n  		lastLine = previousItem.text.split("\\n").pop();\n\n  		if (match = /^\\s+$/.exec(lastLine)) {\n  			return applyIndent(string, match[0]);\n  		}\n\n  		return string;\n  	},\n\n  	unbind: function () {\n  		if (!this.isNamed) {\n  			// dynamic partial - need to unbind self\n  			shared_unbind.call(this);\n  		}\n\n  		if (this.fragment) {\n  			this.fragment.unbind();\n  		}\n  	},\n\n  	unrender: function (shouldDestroy) {\n  		if (this.rendered) {\n  			if (this.fragment) {\n  				this.fragment.unrender(shouldDestroy);\n  			}\n  			this.rendered = false;\n  		}\n  	},\n\n  	update: function () {\n  		var target, anchor;\n\n  		if (this.fragmentToUnrender) {\n  			this.fragmentToUnrender.unrender(true);\n  			this.fragmentToUnrender = null;\n  		}\n\n  		if (this.fragmentToRender) {\n  			this.docFrag.appendChild(this.fragmentToRender.render());\n  			this.fragmentToRender = null;\n  		}\n\n  		if (this.rendered) {\n  			target = this.parentFragment.getNode();\n  			anchor = this.parentFragment.findNextNode(this);\n  			target.insertBefore(this.docFrag, anchor);\n  		}\n  	}\n  };\n\n  var _Partial = Partial;\n\n  // finds the component constructor in the registry or view hierarchy registries\n\n  var Component_getComponent = getComponent;\n  function getComponent(ractive, name) {\n\n  	var Component,\n  	    instance = findInstance("components", ractive, name);\n\n  	if (instance) {\n  		Component = instance.components[name];\n\n  		// best test we have for not Ractive.extend\n  		if (!Component._Parent) {\n  			// function option, execute and store for reset\n  			var fn = Component.bind(instance);\n  			fn.isOwner = instance.components.hasOwnProperty(name);\n  			Component = fn();\n\n  			if (!Component) {\n  				warnIfDebug(noRegistryFunctionReturn, name, "component", "component", { ractive: ractive });\n\n  				return;\n  			}\n\n  			if (typeof Component === "string") {\n  				// allow string lookup\n  				Component = getComponent(ractive, Component);\n  			}\n\n  			Component._fn = fn;\n  			instance.components[name] = Component;\n  		}\n  	}\n\n  	return Component;\n  }\n\n  var Component_prototype_detach = Component$detach;\n  var Component_prototype_detach__detachHook = new hooks_Hook("detach");\n  function Component$detach() {\n  	var detached = this.instance.fragment.detach();\n  	Component_prototype_detach__detachHook.fire(this.instance);\n  	return detached;\n  }\n\n  var Component_prototype_find = Component$find;\n\n  function Component$find(selector) {\n  	return this.instance.fragment.find(selector);\n  }\n\n  var Component_prototype_findAll = Component$findAll;\n\n  function Component$findAll(selector, query) {\n  	return this.instance.fragment.findAll(selector, query);\n  }\n\n  var Component_prototype_findAllComponents = Component$findAllComponents;\n\n  function Component$findAllComponents(selector, query) {\n  	query._test(this, true);\n\n  	if (this.instance.fragment) {\n  		this.instance.fragment.findAllComponents(selector, query);\n  	}\n  }\n\n  var Component_prototype_findComponent = Component$findComponent;\n\n  function Component$findComponent(selector) {\n  	if (!selector || selector === this.name) {\n  		return this.instance;\n  	}\n\n  	if (this.instance.fragment) {\n  		return this.instance.fragment.findComponent(selector);\n  	}\n\n  	return null;\n  }\n\n  var Component_prototype_findNextNode = Component$findNextNode;\n\n  function Component$findNextNode() {\n  	return this.parentFragment.findNextNode(this);\n  }\n\n  var Component_prototype_firstNode = Component$firstNode;\n\n  function Component$firstNode() {\n  	if (this.rendered) {\n  		return this.instance.fragment.firstNode();\n  	}\n\n  	return null;\n  }\n\n  var processWrapper = function (wrapper, array, methodName, newIndices) {\n  	var root = wrapper.root;\n  	var keypath = wrapper.keypath;\n\n  	if (!!newIndices) {\n  		root.viewmodel.smartUpdate(keypath, array, newIndices);\n  	} else {\n  		// If this is a sort or reverse, we just do root.set()...\n  		// TODO use merge logic?\n  		root.viewmodel.mark(keypath);\n  	}\n  };\n\n  var patchedArrayProto = [],\n      mutatorMethods = ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"],\n      testObj,\n      patchArrayMethods,\n      unpatchArrayMethods;\n\n  mutatorMethods.forEach(function (methodName) {\n  	var method = function () {\n  		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n  			args[_key] = arguments[_key];\n  		}\n\n  		var newIndices, result, wrapper, i;\n\n  		newIndices = shared_getNewIndices(this, methodName, args);\n\n  		// apply the underlying method\n  		result = Array.prototype[methodName].apply(this, arguments);\n\n  		// trigger changes\n  		global_runloop.start();\n\n  		this._ractive.setting = true;\n  		i = this._ractive.wrappers.length;\n  		while (i--) {\n  			wrapper = this._ractive.wrappers[i];\n\n  			global_runloop.addRactive(wrapper.root);\n  			processWrapper(wrapper, this, methodName, newIndices);\n  		}\n\n  		global_runloop.end();\n\n  		this._ractive.setting = false;\n  		return result;\n  	};\n\n  	defineProperty(patchedArrayProto, methodName, {\n  		value: method\n  	});\n  });\n\n  // can we use prototype chain injection?\n  // http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\n  testObj = {};\n\n  if (testObj.__proto__) {\n  	// yes, we can\n  	patchArrayMethods = function (array) {\n  		array.__proto__ = patchedArrayProto;\n  	};\n\n  	unpatchArrayMethods = function (array) {\n  		array.__proto__ = Array.prototype;\n  	};\n  } else {\n  	// no, we can\'t\n  	patchArrayMethods = function (array) {\n  		var i, methodName;\n\n  		i = mutatorMethods.length;\n  		while (i--) {\n  			methodName = mutatorMethods[i];\n  			defineProperty(array, methodName, {\n  				value: patchedArrayProto[methodName],\n  				configurable: true\n  			});\n  		}\n  	};\n\n  	unpatchArrayMethods = function (array) {\n  		var i;\n\n  		i = mutatorMethods.length;\n  		while (i--) {\n  			delete array[mutatorMethods[i]];\n  		}\n  	};\n  }\n\n  patchArrayMethods.unpatch = unpatchArrayMethods;\n  var patch = patchArrayMethods;\n\n  var arrayAdaptor,\n\n  // helpers\n  ArrayWrapper, array_index__errorMessage;\n\n  arrayAdaptor = {\n  	filter: function (object) {\n  		// wrap the array if a) b) it\'s an array, and b) either it hasn\'t been wrapped already,\n  		// or the array didn\'t trigger the get() itself\n  		return isArray(object) && (!object._ractive || !object._ractive.setting);\n  	},\n  	wrap: function (ractive, array, keypath) {\n  		return new ArrayWrapper(ractive, array, keypath);\n  	}\n  };\n\n  ArrayWrapper = function (ractive, array, keypath) {\n  	this.root = ractive;\n  	this.value = array;\n  	this.keypath = getKeypath(keypath);\n\n  	// if this array hasn\'t already been ractified, ractify it\n  	if (!array._ractive) {\n\n  		// define a non-enumerable _ractive property to store the wrappers\n  		defineProperty(array, "_ractive", {\n  			value: {\n  				wrappers: [],\n  				instances: [],\n  				setting: false\n  			},\n  			configurable: true\n  		});\n\n  		patch(array);\n  	}\n\n  	// store the ractive instance, so we can handle transitions later\n  	if (!array._ractive.instances[ractive._guid]) {\n  		array._ractive.instances[ractive._guid] = 0;\n  		array._ractive.instances.push(ractive);\n  	}\n\n  	array._ractive.instances[ractive._guid] += 1;\n  	array._ractive.wrappers.push(this);\n  };\n\n  ArrayWrapper.prototype = {\n  	get: function () {\n  		return this.value;\n  	},\n  	teardown: function () {\n  		var array, storage, wrappers, instances, index;\n\n  		array = this.value;\n  		storage = array._ractive;\n  		wrappers = storage.wrappers;\n  		instances = storage.instances;\n\n  		// if teardown() was invoked because we\'re clearing the cache as a result of\n  		// a change that the array itself triggered, we can save ourselves the teardown\n  		// and immediate setup\n  		if (storage.setting) {\n  			return false; // so that we don\'t remove it from this.root.viewmodel.wrapped\n  		}\n\n  		index = wrappers.indexOf(this);\n  		if (index === -1) {\n  			throw new Error(array_index__errorMessage);\n  		}\n\n  		wrappers.splice(index, 1);\n\n  		// if nothing else depends on this array, we can revert it to its\n  		// natural state\n  		if (!wrappers.length) {\n  			delete array._ractive;\n  			patch.unpatch(this.value);\n  		} else {\n  			// remove ractive instance if possible\n  			instances[this.root._guid] -= 1;\n  			if (!instances[this.root._guid]) {\n  				index = instances.indexOf(this.root);\n\n  				if (index === -1) {\n  					throw new Error(array_index__errorMessage);\n  				}\n\n  				instances.splice(index, 1);\n  			}\n  		}\n  	}\n  };\n\n  array_index__errorMessage = "Something went wrong in a rather interesting way";\n  var array_index = arrayAdaptor;\n\n  var numeric = /^\\s*[0-9]+\\s*$/;\n\n  var createBranch = function (key) {\n  	return numeric.test(key) ? [] : {};\n  };\n\n  var magicAdaptor, MagicWrapper;\n\n  try {\n  	Object.defineProperty({}, "test", { value: 0 });\n\n  	magicAdaptor = {\n  		filter: function (object, keypath, ractive) {\n  			var parentWrapper, parentValue;\n\n  			if (!keypath) {\n  				return false;\n  			}\n\n  			keypath = getKeypath(keypath);\n\n  			// If the parent value is a wrapper, other than a magic wrapper,\n  			// we shouldn\'t wrap this property\n  			if ((parentWrapper = ractive.viewmodel.wrapped[keypath.parent.str]) && !parentWrapper.magic) {\n  				return false;\n  			}\n\n  			parentValue = ractive.viewmodel.get(keypath.parent);\n\n  			// if parentValue is an array that doesn\'t include this member,\n  			// we should return false otherwise lengths will get messed up\n  			if (isArray(parentValue) && /^[0-9]+$/.test(keypath.lastKey)) {\n  				return false;\n  			}\n\n  			return parentValue && (typeof parentValue === "object" || typeof parentValue === "function");\n  		},\n  		wrap: function (ractive, property, keypath) {\n  			return new MagicWrapper(ractive, property, keypath);\n  		}\n  	};\n\n  	MagicWrapper = function (ractive, value, keypath) {\n  		var objKeypath, template, siblings;\n\n  		keypath = getKeypath(keypath);\n\n  		this.magic = true;\n\n  		this.ractive = ractive;\n  		this.keypath = keypath;\n  		this.value = value;\n\n  		this.prop = keypath.lastKey;\n\n  		objKeypath = keypath.parent;\n  		this.obj = objKeypath.isRoot ? ractive.viewmodel.data : ractive.viewmodel.get(objKeypath);\n\n  		template = this.originalDescriptor = Object.getOwnPropertyDescriptor(this.obj, this.prop);\n\n  		// Has this property already been wrapped?\n  		if (template && template.set && (siblings = template.set._ractiveWrappers)) {\n\n  			// Yes. Register this wrapper to this property, if it hasn\'t been already\n  			if (siblings.indexOf(this) === -1) {\n  				siblings.push(this);\n  			}\n\n  			return; // already wrapped\n  		}\n\n  		// No, it hasn\'t been wrapped\n  		createAccessors(this, value, template);\n  	};\n\n  	MagicWrapper.prototype = {\n  		get: function () {\n  			return this.value;\n  		},\n  		reset: function (value) {\n  			if (this.updating) {\n  				return;\n  			}\n\n  			this.updating = true;\n  			this.obj[this.prop] = value; // trigger set() accessor\n  			global_runloop.addRactive(this.ractive);\n  			this.ractive.viewmodel.mark(this.keypath, { keepExistingWrapper: true });\n  			this.updating = false;\n  			return true;\n  		},\n  		set: function (key, value) {\n  			if (this.updating) {\n  				return;\n  			}\n\n  			if (!this.obj[this.prop]) {\n  				this.updating = true;\n  				this.obj[this.prop] = createBranch(key);\n  				this.updating = false;\n  			}\n\n  			this.obj[this.prop][key] = value;\n  		},\n  		teardown: function () {\n  			var template, set, value, wrappers, index;\n\n  			// If this method was called because the cache was being cleared as a\n  			// result of a set()/update() call made by this wrapper, we return false\n  			// so that it doesn\'t get torn down\n  			if (this.updating) {\n  				return false;\n  			}\n\n  			template = Object.getOwnPropertyDescriptor(this.obj, this.prop);\n  			set = template && template.set;\n\n  			if (!set) {\n  				// most likely, this was an array member that was spliced out\n  				return;\n  			}\n\n  			wrappers = set._ractiveWrappers;\n\n  			index = wrappers.indexOf(this);\n  			if (index !== -1) {\n  				wrappers.splice(index, 1);\n  			}\n\n  			// Last one out, turn off the lights\n  			if (!wrappers.length) {\n  				value = this.obj[this.prop];\n\n  				Object.defineProperty(this.obj, this.prop, this.originalDescriptor || {\n  					writable: true,\n  					enumerable: true,\n  					configurable: true\n  				});\n\n  				this.obj[this.prop] = value;\n  			}\n  		}\n  	};\n  } catch (err) {\n  	magicAdaptor = false; // no magic in this browser\n  }\n\n  var adaptors_magic = magicAdaptor;\n\n  function createAccessors(originalWrapper, value, template) {\n\n  	var object, property, oldGet, oldSet, get, set;\n\n  	object = originalWrapper.obj;\n  	property = originalWrapper.prop;\n\n  	// Is this template configurable?\n  	if (template && !template.configurable) {\n  		// Special case - array length\n  		if (property === "length") {\n  			return;\n  		}\n\n  		throw new Error("Cannot use magic mode with property \\"" + property + "\\" - object is not configurable");\n  	}\n\n  	// Time to wrap this property\n  	if (template) {\n  		oldGet = template.get;\n  		oldSet = template.set;\n  	}\n\n  	get = oldGet || function () {\n  		return value;\n  	};\n\n  	set = function (v) {\n  		if (oldSet) {\n  			oldSet(v);\n  		}\n\n  		value = oldGet ? oldGet() : v;\n  		set._ractiveWrappers.forEach(updateWrapper);\n  	};\n\n  	function updateWrapper(wrapper) {\n  		var keypath, ractive;\n\n  		wrapper.value = value;\n\n  		if (wrapper.updating) {\n  			return;\n  		}\n\n  		ractive = wrapper.ractive;\n  		keypath = wrapper.keypath;\n\n  		wrapper.updating = true;\n  		global_runloop.start(ractive);\n\n  		ractive.viewmodel.mark(keypath);\n\n  		global_runloop.end();\n  		wrapper.updating = false;\n  	}\n\n  	// Create an array of wrappers, in case other keypaths/ractives depend on this property.\n  	// Handily, we can store them as a property of the set function. Yay JavaScript.\n  	set._ractiveWrappers = [originalWrapper];\n  	Object.defineProperty(object, property, { get: get, set: set, enumerable: true, configurable: true });\n  }\n\n  var magicArrayAdaptor, MagicArrayWrapper;\n\n  if (adaptors_magic) {\n  	magicArrayAdaptor = {\n  		filter: function (object, keypath, ractive) {\n  			return adaptors_magic.filter(object, keypath, ractive) && array_index.filter(object);\n  		},\n\n  		wrap: function (ractive, array, keypath) {\n  			return new MagicArrayWrapper(ractive, array, keypath);\n  		}\n  	};\n\n  	MagicArrayWrapper = function (ractive, array, keypath) {\n  		this.value = array;\n\n  		this.magic = true;\n\n  		this.magicWrapper = adaptors_magic.wrap(ractive, array, keypath);\n  		this.arrayWrapper = array_index.wrap(ractive, array, keypath);\n  	};\n\n  	MagicArrayWrapper.prototype = {\n  		get: function () {\n  			return this.value;\n  		},\n  		teardown: function () {\n  			this.arrayWrapper.teardown();\n  			this.magicWrapper.teardown();\n  		},\n  		reset: function (value) {\n  			return this.magicWrapper.reset(value);\n  		}\n  	};\n  }\n\n  var magicArray = magicArrayAdaptor;\n\n  var prototype_adapt = Viewmodel$adapt;\n\n  var prefixers = {};\n  function Viewmodel$adapt(keypath, value) {\n  	var len, i, adaptor, wrapped;\n\n  	if (!this.adaptors) return;\n\n  	// Do we have an adaptor for this value?\n  	len = this.adaptors.length;\n  	for (i = 0; i < len; i += 1) {\n  		adaptor = this.adaptors[i];\n\n  		if (adaptor.filter(value, keypath, this.ractive)) {\n  			wrapped = this.wrapped[keypath] = adaptor.wrap(this.ractive, value, keypath, getPrefixer(keypath));\n  			wrapped.value = value;\n  			return;\n  		}\n  	}\n  }\n\n  function prefixKeypath(obj, prefix) {\n  	var prefixed = {},\n  	    key;\n\n  	if (!prefix) {\n  		return obj;\n  	}\n\n  	prefix += ".";\n\n  	for (key in obj) {\n  		if (obj.hasOwnProperty(key)) {\n  			prefixed[prefix + key] = obj[key];\n  		}\n  	}\n\n  	return prefixed;\n  }\n\n  function getPrefixer(rootKeypath) {\n  	var rootDot;\n\n  	if (!prefixers[rootKeypath]) {\n  		rootDot = rootKeypath ? rootKeypath + "." : "";\n\n  		prefixers[rootKeypath] = function (relativeKeypath, value) {\n  			var obj;\n\n  			if (typeof relativeKeypath === "string") {\n  				obj = {};\n  				obj[rootDot + relativeKeypath] = value;\n  				return obj;\n  			}\n\n  			if (typeof relativeKeypath === "object") {\n  				// \'relativeKeypath\' is in fact a hash, not a keypath\n  				return rootDot ? prefixKeypath(relativeKeypath, rootKeypath) : relativeKeypath;\n  			}\n  		};\n  	}\n\n  	return prefixers[rootKeypath];\n  }\n\n  // TEMP\n\n  var helpers_getUpstreamChanges = getUpstreamChanges;\n  function getUpstreamChanges(changes) {\n  	var upstreamChanges = [rootKeypath],\n  	    i,\n  	    keypath;\n\n  	i = changes.length;\n  	while (i--) {\n  		keypath = changes[i].parent;\n\n  		while (keypath && !keypath.isRoot) {\n  			if (changes.indexOf(keypath) === -1) {\n  				addToArray(upstreamChanges, keypath);\n  			}\n  			keypath = keypath.parent;\n  		}\n  	}\n\n  	return upstreamChanges;\n  }\n\n  var applyChanges_notifyPatternObservers = notifyPatternObservers;\n\n  function notifyPatternObservers(viewmodel, keypath, onlyDirect) {\n  	var potentialWildcardMatches;\n\n  	updateMatchingPatternObservers(viewmodel, keypath);\n\n  	if (onlyDirect) {\n  		return;\n  	}\n\n  	potentialWildcardMatches = keypath.wildcardMatches();\n  	potentialWildcardMatches.forEach(function (upstreamPattern) {\n  		cascade(viewmodel, upstreamPattern, keypath);\n  	});\n  }\n\n  function cascade(viewmodel, upstreamPattern, keypath) {\n  	var group, map, actualChildKeypath;\n\n  	// TODO should be one or the other\n  	upstreamPattern = upstreamPattern.str || upstreamPattern;\n\n  	group = viewmodel.depsMap.patternObservers;\n  	map = group && group[upstreamPattern];\n\n  	if (!map) {\n  		return;\n  	}\n\n  	map.forEach(function (childKeypath) {\n  		actualChildKeypath = keypath.join(childKeypath.lastKey); // \'foo.bar.baz\'\n\n  		updateMatchingPatternObservers(viewmodel, actualChildKeypath);\n  		cascade(viewmodel, childKeypath, actualChildKeypath);\n  	});\n  }\n\n  function updateMatchingPatternObservers(viewmodel, keypath) {\n  	viewmodel.patternObservers.forEach(function (observer) {\n  		if (observer.regex.test(keypath.str)) {\n  			observer.update(keypath);\n  		}\n  	});\n  }\n\n  var applyChanges = Viewmodel$applyChanges;\n\n  function Viewmodel$applyChanges() {\n  	var _this = this;\n\n  	var self = this,\n  	    changes,\n  	    upstreamChanges,\n  	    hash = {},\n  	    bindings;\n\n  	changes = this.changes;\n\n  	if (!changes.length) {\n  		// TODO we end up here on initial render. Perhaps we shouldn\'t?\n  		return;\n  	}\n\n  	function invalidateComputation(computation) {\n  		var key = computation.key;\n\n  		if (computation.viewmodel === self) {\n  			self.clearCache(key.str);\n  			computation.invalidate();\n\n  			changes.push(key);\n  			cascade(key);\n  		} else {\n  			computation.viewmodel.mark(key);\n  		}\n  	}\n\n  	function cascade(keypath) {\n  		var map, computations;\n\n  		if (self.noCascade.hasOwnProperty(keypath.str)) {\n  			return;\n  		}\n\n  		if (computations = self.deps.computed[keypath.str]) {\n  			computations.forEach(invalidateComputation);\n  		}\n\n  		if (map = self.depsMap.computed[keypath.str]) {\n  			map.forEach(cascade);\n  		}\n  	}\n\n  	changes.slice().forEach(cascade);\n\n  	upstreamChanges = helpers_getUpstreamChanges(changes);\n  	upstreamChanges.forEach(function (keypath) {\n  		var computations;\n\n  		// make sure we haven\'t already been down this particular keypath in this turn\n  		if (changes.indexOf(keypath) === -1 && (computations = self.deps.computed[keypath.str])) {\n  			computations.forEach(invalidateComputation);\n  		}\n  	});\n\n  	this.changes = [];\n\n  	// Pattern observers are a weird special case\n  	if (this.patternObservers.length) {\n  		upstreamChanges.forEach(function (keypath) {\n  			return applyChanges_notifyPatternObservers(_this, keypath, true);\n  		});\n  		changes.forEach(function (keypath) {\n  			return applyChanges_notifyPatternObservers(_this, keypath);\n  		});\n  	}\n\n  	if (this.deps.observers) {\n  		upstreamChanges.forEach(function (keypath) {\n  			return notifyUpstreamDependants(_this, null, keypath, "observers");\n  		});\n  		notifyAllDependants(this, changes, "observers");\n  	}\n\n  	if (this.deps["default"]) {\n  		bindings = [];\n  		upstreamChanges.forEach(function (keypath) {\n  			return notifyUpstreamDependants(_this, bindings, keypath, "default");\n  		});\n\n  		if (bindings.length) {\n  			notifyBindings(this, bindings, changes);\n  		}\n\n  		notifyAllDependants(this, changes, "default");\n  	}\n\n  	// Return a hash of keypaths to updated values\n  	changes.forEach(function (keypath) {\n  		hash[keypath.str] = _this.get(keypath);\n  	});\n\n  	this.implicitChanges = {};\n  	this.noCascade = {};\n\n  	return hash;\n  }\n\n  function notifyUpstreamDependants(viewmodel, bindings, keypath, groupName) {\n  	var dependants, value;\n\n  	if (dependants = findDependants(viewmodel, keypath, groupName)) {\n  		value = viewmodel.get(keypath);\n\n  		dependants.forEach(function (d) {\n  			// don\'t "set" the parent value, refine it\n  			// i.e. not data = value, but data[foo] = fooValue\n  			if (bindings && d.refineValue) {\n  				bindings.push(d);\n  			} else {\n  				d.setValue(value);\n  			}\n  		});\n  	}\n  }\n\n  function notifyBindings(viewmodel, bindings, changes) {\n\n  	bindings.forEach(function (binding) {\n  		var useSet = false,\n  		    i = 0,\n  		    length = changes.length,\n  		    refinements = [];\n\n  		while (i < length) {\n  			var keypath = changes[i];\n\n  			if (keypath === binding.keypath) {\n  				useSet = true;\n  				break;\n  			}\n\n  			if (keypath.slice(0, binding.keypath.length) === binding.keypath) {\n  				refinements.push(keypath);\n  			}\n\n  			i++;\n  		}\n\n  		if (useSet) {\n  			binding.setValue(viewmodel.get(binding.keypath));\n  		}\n\n  		if (refinements.length) {\n  			binding.refineValue(refinements);\n  		}\n  	});\n  }\n\n  function notifyAllDependants(viewmodel, keypaths, groupName) {\n  	var queue = [];\n\n  	addKeypaths(keypaths);\n  	queue.forEach(dispatch);\n\n  	function addKeypaths(keypaths) {\n  		keypaths.forEach(addKeypath);\n  		keypaths.forEach(cascade);\n  	}\n\n  	function addKeypath(keypath) {\n  		var deps = findDependants(viewmodel, keypath, groupName);\n\n  		if (deps) {\n  			queue.push({\n  				keypath: keypath,\n  				deps: deps\n  			});\n  		}\n  	}\n\n  	function cascade(keypath) {\n  		var childDeps;\n\n  		if (childDeps = viewmodel.depsMap[groupName][keypath.str]) {\n  			addKeypaths(childDeps);\n  		}\n  	}\n\n  	function dispatch(set) {\n  		var value = viewmodel.get(set.keypath);\n  		set.deps.forEach(function (d) {\n  			return d.setValue(value);\n  		});\n  	}\n  }\n\n  function findDependants(viewmodel, keypath, groupName) {\n  	var group = viewmodel.deps[groupName];\n  	return group ? group[keypath.str] : null;\n  }\n\n  var capture = Viewmodel$capture;\n\n  function Viewmodel$capture() {\n  	this.captureGroups.push([]);\n  }\n\n  var clearCache = Viewmodel$clearCache;\n\n  function Viewmodel$clearCache(keypath, keepExistingWrapper) {\n  	var cacheMap, wrapper;\n\n  	if (!keepExistingWrapper) {\n  		// Is there a wrapped property at this keypath?\n  		if (wrapper = this.wrapped[keypath]) {\n  			// Did we unwrap it?\n  			if (wrapper.teardown() !== false) {\n  				// Is this right?\n  				// What\'s the meaning of returning false from teardown?\n  				// Could there be a GC ramification if this is a "real" ractive.teardown()?\n  				this.wrapped[keypath] = null;\n  			}\n  		}\n  	}\n\n  	this.cache[keypath] = undefined;\n\n  	if (cacheMap = this.cacheMap[keypath]) {\n  		while (cacheMap.length) {\n  			this.clearCache(cacheMap.pop());\n  		}\n  	}\n  }\n\n  var UnresolvedDependency = function (computation, ref) {\n  	this.computation = computation;\n  	this.viewmodel = computation.viewmodel;\n  	this.ref = ref;\n\n  	// TODO this seems like a red flag!\n  	this.root = this.viewmodel.ractive;\n  	this.parentFragment = this.root.component && this.root.component.parentFragment;\n  };\n\n  UnresolvedDependency.prototype = {\n  	resolve: function (keypath) {\n  		this.computation.softDeps.push(keypath);\n  		this.computation.unresolvedDeps[keypath.str] = null;\n  		this.viewmodel.register(keypath, this.computation, "computed");\n  	}\n  };\n\n  var Computation_UnresolvedDependency = UnresolvedDependency;\n\n  var Computation = function (key, signature) {\n  	this.key = key;\n\n  	this.getter = signature.getter;\n  	this.setter = signature.setter;\n\n  	this.hardDeps = signature.deps || [];\n  	this.softDeps = [];\n  	this.unresolvedDeps = {};\n\n  	this.depValues = {};\n\n  	this._dirty = this._firstRun = true;\n  };\n\n  Computation.prototype = {\n  	constructor: Computation,\n\n  	init: function (viewmodel) {\n  		var _this = this;\n\n  		var initial;\n\n  		this.viewmodel = viewmodel;\n  		this.bypass = true;\n\n  		initial = viewmodel.get(this.key);\n  		viewmodel.clearCache(this.key.str);\n\n  		this.bypass = false;\n\n  		if (this.setter && initial !== undefined) {\n  			this.set(initial);\n  		}\n\n  		if (this.hardDeps) {\n  			this.hardDeps.forEach(function (d) {\n  				return viewmodel.register(d, _this, "computed");\n  			});\n  		}\n  	},\n\n  	invalidate: function () {\n  		this._dirty = true;\n  	},\n\n  	get: function () {\n  		var _this = this;\n\n  		var newDeps,\n  		    dependenciesChanged,\n  		    dependencyValuesChanged = false;\n\n  		if (this.getting) {\n  			// prevent double-computation (e.g. caused by array mutation inside computation)\n  			var msg = "The " + this.key.str + " computation indirectly called itself. This probably indicates a bug in the computation. It is commonly caused by `array.sort(...)` - if that\'s the case, clone the array first with `array.slice().sort(...)`";\n  			warnOnce(msg);\n  			return this.value;\n  		}\n\n  		this.getting = true;\n\n  		if (this._dirty) {\n  			// determine whether the inputs have changed, in case this depends on\n  			// other computed values\n  			if (this._firstRun || !this.hardDeps.length && !this.softDeps.length) {\n  				dependencyValuesChanged = true;\n  			} else {\n  				[this.hardDeps, this.softDeps].forEach(function (deps) {\n  					var keypath, value, i;\n\n  					if (dependencyValuesChanged) {\n  						return;\n  					}\n\n  					i = deps.length;\n  					while (i--) {\n  						keypath = deps[i];\n  						value = _this.viewmodel.get(keypath);\n\n  						if (!isEqual(value, _this.depValues[keypath.str])) {\n  							_this.depValues[keypath.str] = value;\n  							dependencyValuesChanged = true;\n\n  							return;\n  						}\n  					}\n  				});\n  			}\n\n  			if (dependencyValuesChanged) {\n  				this.viewmodel.capture();\n\n  				try {\n  					this.value = this.getter();\n  				} catch (err) {\n  					warnIfDebug("Failed to compute \\"%s\\"", this.key.str);\n  					logIfDebug(err.stack || err);\n\n  					this.value = void 0;\n  				}\n\n  				newDeps = this.viewmodel.release();\n  				dependenciesChanged = this.updateDependencies(newDeps);\n\n  				if (dependenciesChanged) {\n  					[this.hardDeps, this.softDeps].forEach(function (deps) {\n  						deps.forEach(function (keypath) {\n  							_this.depValues[keypath.str] = _this.viewmodel.get(keypath);\n  						});\n  					});\n  				}\n  			}\n\n  			this._dirty = false;\n  		}\n\n  		this.getting = this._firstRun = false;\n  		return this.value;\n  	},\n\n  	set: function (value) {\n  		if (this.setting) {\n  			this.value = value;\n  			return;\n  		}\n\n  		if (!this.setter) {\n  			throw new Error("Computed properties without setters are read-only. (This may change in a future version of Ractive!)");\n  		}\n\n  		this.setter(value);\n  	},\n\n  	updateDependencies: function (newDeps) {\n  		var i, oldDeps, keypath, dependenciesChanged, unresolved;\n\n  		oldDeps = this.softDeps;\n\n  		// remove dependencies that are no longer used\n  		i = oldDeps.length;\n  		while (i--) {\n  			keypath = oldDeps[i];\n\n  			if (newDeps.indexOf(keypath) === -1) {\n  				dependenciesChanged = true;\n  				this.viewmodel.unregister(keypath, this, "computed");\n  			}\n  		}\n\n  		// create references for any new dependencies\n  		i = newDeps.length;\n  		while (i--) {\n  			keypath = newDeps[i];\n\n  			if (oldDeps.indexOf(keypath) === -1 && (!this.hardDeps || this.hardDeps.indexOf(keypath) === -1)) {\n  				dependenciesChanged = true;\n\n  				// if this keypath is currently unresolved, we need to mark\n  				// it as such. TODO this is a bit muddy...\n  				if (isUnresolved(this.viewmodel, keypath) && !this.unresolvedDeps[keypath.str]) {\n  					unresolved = new Computation_UnresolvedDependency(this, keypath.str);\n  					newDeps.splice(i, 1);\n\n  					this.unresolvedDeps[keypath.str] = unresolved;\n  					global_runloop.addUnresolved(unresolved);\n  				} else {\n  					this.viewmodel.register(keypath, this, "computed");\n  				}\n  			}\n  		}\n\n  		if (dependenciesChanged) {\n  			this.softDeps = newDeps.slice();\n  		}\n\n  		return dependenciesChanged;\n  	}\n  };\n\n  function isUnresolved(viewmodel, keypath) {\n  	var key = keypath.firstKey;\n\n  	return !(key in viewmodel.data) && !(key in viewmodel.computations) && !(key in viewmodel.mappings);\n  }\n\n  var Computation_Computation = Computation;\n\n  var compute = Viewmodel$compute;\n  function Viewmodel$compute(key, signature) {\n  	var computation = new Computation_Computation(key, signature);\n\n  	if (this.ready) {\n  		computation.init(this);\n  	}\n\n  	return this.computations[key.str] = computation;\n  }\n\n  var FAILED_LOOKUP = { FAILED_LOOKUP: true };\n\n  var viewmodel_prototype_get = Viewmodel$get;\n\n  var viewmodel_prototype_get__empty = {};\n  function Viewmodel$get(keypath, options) {\n  	var cache = this.cache,\n  	    value,\n  	    computation,\n  	    wrapped,\n  	    captureGroup,\n  	    keypathStr = keypath.str,\n  	    key;\n\n  	options = options || viewmodel_prototype_get__empty;\n\n  	// capture the keypath, if we\'re inside a computation\n  	if (options.capture && (captureGroup = lastItem(this.captureGroups))) {\n  		if (! ~captureGroup.indexOf(keypath)) {\n  			captureGroup.push(keypath);\n  		}\n  	}\n\n  	if (hasOwn.call(this.mappings, keypath.firstKey)) {\n  		return this.mappings[keypath.firstKey].get(keypath, options);\n  	}\n\n  	if (keypath.isSpecial) {\n  		return keypath.value;\n  	}\n\n  	if (cache[keypathStr] === undefined) {\n\n  		// Is this a computed property?\n  		if ((computation = this.computations[keypathStr]) && !computation.bypass) {\n  			value = computation.get();\n  			this.adapt(keypathStr, value);\n  		}\n\n  		// Is this a wrapped property?\n  		else if (wrapped = this.wrapped[keypathStr]) {\n  			value = wrapped.value;\n  		}\n\n  		// Is it the root?\n  		else if (keypath.isRoot) {\n  			this.adapt("", this.data);\n  			value = this.data;\n  		}\n\n  		// No? Then we need to retrieve the value one key at a time\n  		else {\n  			value = retrieve(this, keypath);\n  		}\n\n  		cache[keypathStr] = value;\n  	} else {\n  		value = cache[keypathStr];\n  	}\n\n  	if (!options.noUnwrap && (wrapped = this.wrapped[keypathStr])) {\n  		value = wrapped.get();\n  	}\n\n  	if (keypath.isRoot && options.fullRootGet) {\n  		for (key in this.mappings) {\n  			value[key] = this.mappings[key].getValue();\n  		}\n  	}\n\n  	return value === FAILED_LOOKUP ? void 0 : value;\n  }\n\n  function retrieve(viewmodel, keypath) {\n\n  	var parentValue, cacheMap, value, wrapped;\n\n  	parentValue = viewmodel.get(keypath.parent);\n\n  	if (wrapped = viewmodel.wrapped[keypath.parent.str]) {\n  		parentValue = wrapped.get();\n  	}\n\n  	if (parentValue === null || parentValue === undefined) {\n  		return;\n  	}\n\n  	// update cache map\n  	if (!(cacheMap = viewmodel.cacheMap[keypath.parent.str])) {\n  		viewmodel.cacheMap[keypath.parent.str] = [keypath.str];\n  	} else {\n  		if (cacheMap.indexOf(keypath.str) === -1) {\n  			cacheMap.push(keypath.str);\n  		}\n  	}\n\n  	// If this property doesn\'t exist, we return a sentinel value\n  	// so that we know to query parent scope (if such there be)\n  	if (typeof parentValue === "object" && !(keypath.lastKey in parentValue)) {\n  		return viewmodel.cache[keypath.str] = FAILED_LOOKUP;\n  	}\n\n  	value = parentValue[keypath.lastKey];\n\n  	// Do we have an adaptor for this value?\n  	viewmodel.adapt(keypath.str, value, false);\n\n  	// Update cache\n  	viewmodel.cache[keypath.str] = value;\n  	return value;\n  }\n\n  var viewmodel_prototype_init = Viewmodel$init;\n\n  function Viewmodel$init() {\n  	var key;\n\n  	for (key in this.computations) {\n  		this.computations[key].init(this);\n  	}\n  }\n\n  var prototype_map = Viewmodel$map;\n\n  function Viewmodel$map(key, options) {\n  	var mapping = this.mappings[key.str] = new Mapping(key, options);\n  	mapping.initViewmodel(this);\n  	return mapping;\n  }\n\n  var Mapping = function (localKey, options) {\n  	this.localKey = localKey;\n  	this.keypath = options.keypath;\n  	this.origin = options.origin;\n\n  	this.deps = [];\n  	this.unresolved = [];\n\n  	this.resolved = false;\n  };\n\n  Mapping.prototype = {\n  	forceResolution: function () {\n  		// TODO warn, as per #1692?\n  		this.keypath = this.localKey;\n  		this.setup();\n  	},\n\n  	get: function (keypath, options) {\n  		if (!this.resolved) {\n  			return undefined;\n  		}\n  		return this.origin.get(this.map(keypath), options);\n  	},\n\n  	getValue: function () {\n  		if (!this.keypath) {\n  			return undefined;\n  		}\n  		return this.origin.get(this.keypath);\n  	},\n\n  	initViewmodel: function (viewmodel) {\n  		this.local = viewmodel;\n  		this.setup();\n  	},\n\n  	map: function (keypath) {\n  		if (typeof this.keypath === undefined) {\n  			return this.localKey;\n  		}\n  		return keypath.replace(this.localKey, this.keypath);\n  	},\n\n  	register: function (keypath, dependant, group) {\n  		this.deps.push({ keypath: keypath, dep: dependant, group: group });\n\n  		if (this.resolved) {\n  			this.origin.register(this.map(keypath), dependant, group);\n  		}\n  	},\n\n  	resolve: function (keypath) {\n  		if (this.keypath !== undefined) {\n  			this.unbind(true);\n  		}\n\n  		this.keypath = keypath;\n  		this.setup();\n  	},\n\n  	set: function (keypath, value) {\n  		if (!this.resolved) {\n  			this.forceResolution();\n  		}\n\n  		this.origin.set(this.map(keypath), value);\n  	},\n\n  	setup: function () {\n  		var _this = this;\n\n  		if (this.keypath === undefined) {\n  			return;\n  		}\n\n  		this.resolved = true;\n\n  		// accumulated dependants can now be registered\n  		if (this.deps.length) {\n  			this.deps.forEach(function (d) {\n  				var keypath = _this.map(d.keypath);\n  				_this.origin.register(keypath, d.dep, d.group);\n\n  				// TODO this is a bit of a red flag... all deps should be the same?\n  				if (d.dep.setValue) {\n  					d.dep.setValue(_this.origin.get(keypath));\n  				} else if (d.dep.invalidate) {\n  					d.dep.invalidate();\n  				} else {\n  					throw new Error("An unexpected error occurred. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!");\n  				}\n  			});\n\n  			this.origin.mark(this.keypath);\n  		}\n  	},\n\n  	setValue: function (value) {\n  		if (!this.keypath) {\n  			throw new Error("Mapping does not have keypath, cannot set value. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!");\n  		}\n\n  		this.origin.set(this.keypath, value);\n  	},\n\n  	unbind: function (keepLocal) {\n  		var _this = this;\n\n  		if (!keepLocal) {\n  			delete this.local.mappings[this.localKey];\n  		}\n\n  		if (!this.resolved) {\n  			return;\n  		}\n\n  		this.deps.forEach(function (d) {\n  			_this.origin.unregister(_this.map(d.keypath), d.dep, d.group);\n  		});\n\n  		if (this.tracker) {\n  			this.origin.unregister(this.keypath, this.tracker);\n  		}\n  	},\n\n  	unregister: function (keypath, dependant, group) {\n  		var deps, i;\n\n  		if (!this.resolved) {\n  			return;\n  		}\n\n  		deps = this.deps;\n  		i = deps.length;\n\n  		while (i--) {\n  			if (deps[i].dep === dependant) {\n  				deps.splice(i, 1);\n  				break;\n  			}\n  		}\n  		this.origin.unregister(this.map(keypath), dependant, group);\n  	}\n  };\n\n  var mark = Viewmodel$mark;\n\n  function Viewmodel$mark(keypath, options) {\n  	var computation,\n  	    keypathStr = keypath.str;\n\n  	// implicit changes (i.e. `foo.length` on `ractive.push(\'foo\',42)`)\n  	// should not be picked up by pattern observers\n  	if (options) {\n  		if (options.implicit) {\n  			this.implicitChanges[keypathStr] = true;\n  		}\n  		if (options.noCascade) {\n  			this.noCascade[keypathStr] = true;\n  		}\n  	}\n\n  	if (computation = this.computations[keypathStr]) {\n  		computation.invalidate();\n  	}\n\n  	if (this.changes.indexOf(keypath) === -1) {\n  		this.changes.push(keypath);\n  	}\n\n  	// pass on keepExistingWrapper, if we can\n  	var keepExistingWrapper = options ? options.keepExistingWrapper : false;\n\n  	this.clearCache(keypathStr, keepExistingWrapper);\n\n  	if (this.ready) {\n  		this.onchange();\n  	}\n  }\n\n  var mapOldToNewIndex = function (oldArray, newArray) {\n  	var usedIndices, firstUnusedIndex, newIndices, changed;\n\n  	usedIndices = {};\n  	firstUnusedIndex = 0;\n\n  	newIndices = oldArray.map(function (item, i) {\n  		var index, start, len;\n\n  		start = firstUnusedIndex;\n  		len = newArray.length;\n\n  		do {\n  			index = newArray.indexOf(item, start);\n\n  			if (index === -1) {\n  				changed = true;\n  				return -1;\n  			}\n\n  			start = index + 1;\n  		} while (usedIndices[index] && start < len);\n\n  		// keep track of the first unused index, so we don\'t search\n  		// the whole of newArray for each item in oldArray unnecessarily\n  		if (index === firstUnusedIndex) {\n  			firstUnusedIndex += 1;\n  		}\n\n  		if (index !== i) {\n  			changed = true;\n  		}\n\n  		usedIndices[index] = true;\n  		return index;\n  	});\n\n  	return newIndices;\n  };\n\n  var merge = Viewmodel$merge;\n\n  var comparators = {};\n  function Viewmodel$merge(keypath, currentArray, array, options) {\n  	var oldArray, newArray, comparator, newIndices;\n\n  	this.mark(keypath);\n\n  	if (options && options.compare) {\n\n  		comparator = getComparatorFunction(options.compare);\n\n  		try {\n  			oldArray = currentArray.map(comparator);\n  			newArray = array.map(comparator);\n  		} catch (err) {\n  			// fallback to an identity check - worst case scenario we have\n  			// to do more DOM manipulation than we thought...\n  			warnIfDebug("merge(): \\"%s\\" comparison failed. Falling back to identity checking", keypath);\n\n  			oldArray = currentArray;\n  			newArray = array;\n  		}\n  	} else {\n  		oldArray = currentArray;\n  		newArray = array;\n  	}\n\n  	// find new indices for members of oldArray\n  	newIndices = mapOldToNewIndex(oldArray, newArray);\n\n  	this.smartUpdate(keypath, array, newIndices, currentArray.length !== array.length);\n  }\n\n  function stringify(item) {\n  	return JSON.stringify(item);\n  }\n\n  function getComparatorFunction(comparator) {\n  	// If `compare` is `true`, we use JSON.stringify to compare\n  	// objects that are the same shape, but non-identical - i.e.\n  	// { foo: \'bar\' } !== { foo: \'bar\' }\n  	if (comparator === true) {\n  		return stringify;\n  	}\n\n  	if (typeof comparator === "string") {\n  		if (!comparators[comparator]) {\n  			comparators[comparator] = function (item) {\n  				return item[comparator];\n  			};\n  		}\n\n  		return comparators[comparator];\n  	}\n\n  	if (typeof comparator === "function") {\n  		return comparator;\n  	}\n\n  	throw new Error("The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)");\n  }\n\n  var register = Viewmodel$register;\n\n  function Viewmodel$register(keypath, dependant) {\n  	var group = arguments[2] === undefined ? "default" : arguments[2];\n\n  	var mapping, depsByKeypath, deps;\n\n  	if (dependant.isStatic) {\n  		return; // TODO we should never get here if a dependant is static...\n  	}\n\n  	if (mapping = this.mappings[keypath.firstKey]) {\n  		mapping.register(keypath, dependant, group);\n  	} else {\n  		depsByKeypath = this.deps[group] || (this.deps[group] = {});\n  		deps = depsByKeypath[keypath.str] || (depsByKeypath[keypath.str] = []);\n\n  		deps.push(dependant);\n\n  		if (!this.depsMap[group]) {\n  			this.depsMap[group] = {};\n  		}\n\n  		if (!keypath.isRoot) {\n  			register__updateDependantsMap(this, keypath, group);\n  		}\n  	}\n  }\n\n  function register__updateDependantsMap(viewmodel, keypath, group) {\n  	var map, parent, keypathStr;\n\n  	// update dependants map\n  	while (!keypath.isRoot) {\n  		map = viewmodel.depsMap[group];\n  		parent = map[keypath.parent.str] || (map[keypath.parent.str] = []);\n\n  		keypathStr = keypath.str;\n\n  		// TODO find an alternative to this nasty approach\n  		if (parent["_" + keypathStr] === undefined) {\n  			parent["_" + keypathStr] = 0;\n  			parent.push(keypath);\n  		}\n\n  		parent["_" + keypathStr] += 1;\n  		keypath = keypath.parent;\n  	}\n  }\n\n  var release = Viewmodel$release;\n\n  function Viewmodel$release() {\n  	return this.captureGroups.pop();\n  }\n\n  var reset = Viewmodel$reset;\n\n  function Viewmodel$reset(data) {\n  	this.data = data;\n  	this.clearCache("");\n  }\n\n  var prototype_set = Viewmodel$set;\n\n  function Viewmodel$set(keypath, value) {\n  	var options = arguments[2] === undefined ? {} : arguments[2];\n\n  	var mapping, computation, wrapper, keepExistingWrapper;\n\n  	// unless data is being set for data tracking purposes\n  	if (!options.noMapping) {\n  		// If this data belongs to a different viewmodel,\n  		// pass the change along\n  		if (mapping = this.mappings[keypath.firstKey]) {\n  			return mapping.set(keypath, value);\n  		}\n  	}\n\n  	computation = this.computations[keypath.str];\n  	if (computation) {\n  		if (computation.setting) {\n  			// let the other computation set() handle things...\n  			return;\n  		}\n  		computation.set(value);\n  		value = computation.get();\n  	}\n\n  	if (isEqual(this.cache[keypath.str], value)) {\n  		return;\n  	}\n\n  	wrapper = this.wrapped[keypath.str];\n\n  	// If we have a wrapper with a `reset()` method, we try and use it. If the\n  	// `reset()` method returns false, the wrapper should be torn down, and\n  	// (most likely) a new one should be created later\n  	if (wrapper && wrapper.reset) {\n  		keepExistingWrapper = wrapper.reset(value) !== false;\n\n  		if (keepExistingWrapper) {\n  			value = wrapper.get();\n  		}\n  	}\n\n  	if (!computation && !keepExistingWrapper) {\n  		resolveSet(this, keypath, value);\n  	}\n\n  	if (!options.silent) {\n  		this.mark(keypath);\n  	} else {\n  		// We\'re setting a parent of the original target keypath (i.e.\n  		// creating a fresh branch) - we need to clear the cache, but\n  		// not mark it as a change\n  		this.clearCache(keypath.str);\n  	}\n  }\n\n  function resolveSet(viewmodel, keypath, value) {\n  	var wrapper, parentValue, wrapperSet, valueSet;\n\n  	wrapperSet = function () {\n  		if (wrapper.set) {\n  			wrapper.set(keypath.lastKey, value);\n  		} else {\n  			parentValue = wrapper.get();\n  			valueSet();\n  		}\n  	};\n\n  	valueSet = function () {\n  		if (!parentValue) {\n  			parentValue = createBranch(keypath.lastKey);\n  			viewmodel.set(keypath.parent, parentValue, { silent: true });\n  		}\n  		parentValue[keypath.lastKey] = value;\n  	};\n\n  	wrapper = viewmodel.wrapped[keypath.parent.str];\n\n  	if (wrapper) {\n  		wrapperSet();\n  	} else {\n  		parentValue = viewmodel.get(keypath.parent);\n\n  		// may have been wrapped via the above .get()\n  		// call on viewmodel if this is first access via .set()!\n  		if (wrapper = viewmodel.wrapped[keypath.parent.str]) {\n  			wrapperSet();\n  		} else {\n  			valueSet();\n  		}\n  	}\n  }\n\n  var smartUpdate = Viewmodel$smartUpdate;\n\n  var implicitOption = { implicit: true },\n      noCascadeOption = { noCascade: true };\n  function Viewmodel$smartUpdate(keypath, array, newIndices) {\n  	var _this = this;\n\n  	var dependants, oldLength, i;\n\n  	oldLength = newIndices.length;\n\n  	// Indices that are being removed should be marked as dirty\n  	newIndices.forEach(function (newIndex, oldIndex) {\n  		if (newIndex === -1) {\n  			_this.mark(keypath.join(oldIndex), noCascadeOption);\n  		}\n  	});\n\n  	// Update the model\n  	// TODO allow existing array to be updated in place, rather than replaced?\n  	this.set(keypath, array, { silent: true });\n\n  	if (dependants = this.deps["default"][keypath.str]) {\n  		dependants.filter(canShuffle).forEach(function (d) {\n  			return d.shuffle(newIndices, array);\n  		});\n  	}\n\n  	if (oldLength !== array.length) {\n  		this.mark(keypath.join("length"), implicitOption);\n\n  		for (i = newIndices.touchedFrom; i < array.length; i += 1) {\n  			this.mark(keypath.join(i));\n  		}\n\n  		// don\'t allow removed indexes beyond end of new array to trigger recomputations\n  		// TODO is this still necessary, now that computations are lazy?\n  		for (i = array.length; i < oldLength; i += 1) {\n  			this.mark(keypath.join(i), noCascadeOption);\n  		}\n  	}\n  }\n\n  function canShuffle(dependant) {\n  	return typeof dependant.shuffle === "function";\n  }\n\n  var prototype_teardown = Viewmodel$teardown;\n\n  function Viewmodel$teardown() {\n  	var _this = this;\n\n  	var unresolvedImplicitDependency;\n\n  	// Clear entire cache - this has the desired side-effect\n  	// of unwrapping adapted values (e.g. arrays)\n  	Object.keys(this.cache).forEach(function (keypath) {\n  		return _this.clearCache(keypath);\n  	});\n\n  	// Teardown any failed lookups - we don\'t need them to resolve any more\n  	while (unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop()) {\n  		unresolvedImplicitDependency.teardown();\n  	}\n  }\n\n  var unregister = Viewmodel$unregister;\n\n  function Viewmodel$unregister(keypath, dependant) {\n  	var group = arguments[2] === undefined ? "default" : arguments[2];\n\n  	var mapping, deps, index;\n\n  	if (dependant.isStatic) {\n  		return;\n  	}\n\n  	if (mapping = this.mappings[keypath.firstKey]) {\n  		return mapping.unregister(keypath, dependant, group);\n  	}\n\n  	deps = this.deps[group][keypath.str];\n  	index = deps.indexOf(dependant);\n\n  	if (index === -1) {\n  		throw new Error("Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks");\n  	}\n\n  	deps.splice(index, 1);\n\n  	if (keypath.isRoot) {\n  		return;\n  	}\n\n  	unregister__updateDependantsMap(this, keypath, group);\n  }\n\n  function unregister__updateDependantsMap(viewmodel, keypath, group) {\n  	var map, parent;\n\n  	// update dependants map\n  	while (!keypath.isRoot) {\n  		map = viewmodel.depsMap[group];\n  		parent = map[keypath.parent.str];\n\n  		parent["_" + keypath.str] -= 1;\n\n  		if (!parent["_" + keypath.str]) {\n  			// remove from parent deps map\n  			removeFromArray(parent, keypath);\n  			parent["_" + keypath.str] = undefined;\n  		}\n\n  		keypath = keypath.parent;\n  	}\n  }\n\n  var Viewmodel = function (options) {\n  	var adapt = options.adapt;\n  	var data = options.data;\n  	var ractive = options.ractive;\n  	var computed = options.computed;\n  	var mappings = options.mappings;\n  	var key;\n  	var mapping;\n\n  	// TODO is it possible to remove this reference?\n  	this.ractive = ractive;\n\n  	this.adaptors = adapt;\n  	this.onchange = options.onchange;\n\n  	this.cache = {}; // we need to be able to use hasOwnProperty, so can\'t inherit from null\n  	this.cacheMap = create(null);\n\n  	this.deps = {\n  		computed: create(null),\n  		"default": create(null)\n  	};\n  	this.depsMap = {\n  		computed: create(null),\n  		"default": create(null)\n  	};\n\n  	this.patternObservers = [];\n\n  	this.specials = create(null);\n\n  	this.wrapped = create(null);\n  	this.computations = create(null);\n\n  	this.captureGroups = [];\n  	this.unresolvedImplicitDependencies = [];\n\n  	this.changes = [];\n  	this.implicitChanges = {};\n  	this.noCascade = {};\n\n  	this.data = data;\n\n  	// set up explicit mappings\n  	this.mappings = create(null);\n  	for (key in mappings) {\n  		this.map(getKeypath(key), mappings[key]);\n  	}\n\n  	if (data) {\n  		// if data exists locally, but is missing on the parent,\n  		// we transfer ownership to the parent\n  		for (key in data) {\n  			if ((mapping = this.mappings[key]) && mapping.getValue() === undefined) {\n  				mapping.setValue(data[key]);\n  			}\n  		}\n  	}\n\n  	for (key in computed) {\n  		if (mappings && key in mappings) {\n  			fatal("Cannot map to a computed property (\'%s\')", key);\n  		}\n\n  		this.compute(getKeypath(key), computed[key]);\n  	}\n\n  	this.ready = true;\n  };\n\n  Viewmodel.prototype = {\n  	adapt: prototype_adapt,\n  	applyChanges: applyChanges,\n  	capture: capture,\n  	clearCache: clearCache,\n  	compute: compute,\n  	get: viewmodel_prototype_get,\n  	init: viewmodel_prototype_init,\n  	map: prototype_map,\n  	mark: mark,\n  	merge: merge,\n  	register: register,\n  	release: release,\n  	reset: reset,\n  	set: prototype_set,\n  	smartUpdate: smartUpdate,\n  	teardown: prototype_teardown,\n  	unregister: unregister\n  };\n\n  var viewmodel_Viewmodel = Viewmodel;\n\n  function HookQueue(event) {\n  	this.hook = new hooks_Hook(event);\n  	this.inProcess = {};\n  	this.queue = {};\n  }\n\n  HookQueue.prototype = {\n\n  	constructor: HookQueue,\n\n  	begin: function (ractive) {\n  		this.inProcess[ractive._guid] = true;\n  	},\n\n  	end: function (ractive) {\n\n  		var parent = ractive.parent;\n\n  		// If this is *isn\'t* a child of a component that\'s in process,\n  		// it should call methods or fire at this point\n  		if (!parent || !this.inProcess[parent._guid]) {\n  			fire(this, ractive);\n  		}\n  		// elsewise, handoff to parent to fire when ready\n  		else {\n  			getChildQueue(this.queue, parent).push(ractive);\n  		}\n\n  		delete this.inProcess[ractive._guid];\n  	}\n  };\n\n  function getChildQueue(queue, ractive) {\n  	return queue[ractive._guid] || (queue[ractive._guid] = []);\n  }\n\n  function fire(hookQueue, ractive) {\n\n  	var childQueue = getChildQueue(hookQueue.queue, ractive);\n\n  	hookQueue.hook.fire(ractive);\n\n  	// queue is "live" because components can end up being\n  	// added while hooks fire on parents that modify data values.\n  	while (childQueue.length) {\n  		fire(hookQueue, childQueue.shift());\n  	}\n\n  	delete hookQueue.queue[ractive._guid];\n  }\n\n  var hooks_HookQueue = HookQueue;\n\n  var helpers_getComputationSignatures = getComputationSignatures;\n\n  var helpers_getComputationSignatures__pattern = /\\$\\{([^\\}]+)\\}/g;\n  function getComputationSignatures(ractive, computed) {\n  	var signatures = {},\n  	    key;\n\n  	for (key in computed) {\n  		signatures[key] = getComputationSignature(ractive, key, computed[key]);\n  	}\n\n  	return signatures;\n  }\n\n  function getComputationSignature(ractive, key, signature) {\n  	var getter, setter;\n\n  	if (typeof signature === "function") {\n  		getter = helpers_getComputationSignatures__bind(signature, ractive);\n  	}\n\n  	if (typeof signature === "string") {\n  		getter = createFunctionFromString(ractive, signature);\n  	}\n\n  	if (typeof signature === "object") {\n  		if (typeof signature.get === "string") {\n  			getter = createFunctionFromString(ractive, signature.get);\n  		} else if (typeof signature.get === "function") {\n  			getter = helpers_getComputationSignatures__bind(signature.get, ractive);\n  		} else {\n  			fatal("`%s` computation must have a `get()` method", key);\n  		}\n\n  		if (typeof signature.set === "function") {\n  			setter = helpers_getComputationSignatures__bind(signature.set, ractive);\n  		}\n  	}\n\n  	return { getter: getter, setter: setter };\n  }\n\n  function createFunctionFromString(ractive, str) {\n  	var functionBody, hasThis, fn;\n\n  	functionBody = "return (" + str.replace(helpers_getComputationSignatures__pattern, function (match, keypath) {\n  		hasThis = true;\n  		return "__ractive.get(\\"" + keypath + "\\")";\n  	}) + ");";\n\n  	if (hasThis) {\n  		functionBody = "var __ractive = this; " + functionBody;\n  	}\n\n  	fn = new Function(functionBody);\n  	return hasThis ? fn.bind(ractive) : fn;\n  }\n\n  function helpers_getComputationSignatures__bind(fn, context) {\n  	return /this/.test(fn.toString()) ? fn.bind(context) : fn;\n  }\n\n  var constructHook = new hooks_Hook("construct");\n  var configHook = new hooks_Hook("config");\n  var initHook = new hooks_HookQueue("init");\n  var initialise__uid = 0;\n\n  var initialise__registryNames = ["adaptors", "components", "decorators", "easing", "events", "interpolators", "partials", "transitions"];\n\n  var initialise = initialiseRactiveInstance;\n\n  function initialiseRactiveInstance(ractive) {\n  	var userOptions = arguments[1] === undefined ? {} : arguments[1];\n  	var options = arguments[2] === undefined ? {} : arguments[2];\n\n  	var el, viewmodel;\n\n  	if (_Ractive.DEBUG) {\n  		welcome();\n  	}\n\n  	initialiseProperties(ractive, options);\n\n  	// TODO remove this, eventually\n  	defineProperty(ractive, "data", { get: deprecateRactiveData });\n\n  	// TODO don\'t allow `onconstruct` with `new Ractive()`, there\'s no need for it\n  	constructHook.fire(ractive, userOptions);\n\n  	// Add registries\n  	initialise__registryNames.forEach(function (name) {\n  		ractive[name] = utils_object__extend(create(ractive.constructor[name] || null), userOptions[name]);\n  	});\n\n  	// Create a viewmodel\n  	viewmodel = new viewmodel_Viewmodel({\n  		adapt: getAdaptors(ractive, ractive.adapt, userOptions),\n  		data: custom_data.init(ractive.constructor, ractive, userOptions),\n  		computed: helpers_getComputationSignatures(ractive, utils_object__extend(create(ractive.constructor.prototype.computed), userOptions.computed)),\n  		mappings: options.mappings,\n  		ractive: ractive,\n  		onchange: function () {\n  			return global_runloop.addRactive(ractive);\n  		}\n  	});\n\n  	ractive.viewmodel = viewmodel;\n\n  	// This can\'t happen earlier, because computed properties may call `ractive.get()`, etc\n  	viewmodel.init();\n\n  	// init config from Parent and options\n  	config_config.init(ractive.constructor, ractive, userOptions);\n\n  	configHook.fire(ractive);\n  	initHook.begin(ractive);\n\n  	// // If this is a component with a function `data` property, call the function\n  	// // with `ractive` as context (unless the child was also a function)\n  	// if ( typeof ractive.constructor.prototype.data === \'function\' && typeof userOptions.data !== \'function\' ) {\n  	// 	viewmodel.reset( ractive.constructor.prototype.data.call( ractive ) || fatal( \'`data` functions must return a data object\' ) );\n  	// }\n\n  	// Render virtual DOM\n  	if (ractive.template) {\n  		var cssIds = undefined;\n\n  		if (options.cssIds || ractive.cssId) {\n  			cssIds = options.cssIds ? options.cssIds.slice() : [];\n\n  			if (ractive.cssId) {\n  				cssIds.push(ractive.cssId);\n  			}\n  		}\n\n  		ractive.fragment = new virtualdom_Fragment({\n  			template: ractive.template,\n  			root: ractive,\n  			owner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on\n  			cssIds: cssIds\n  		});\n  	}\n\n  	initHook.end(ractive);\n\n  	// render automatically ( if `el` is specified )\n  	if (el = getElement(ractive.el)) {\n  		var promise = ractive.render(el, ractive.append);\n\n  		if (_Ractive.DEBUG_PROMISES) {\n  			promise["catch"](function (err) {\n  				warnOnceIfDebug("Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;");\n  				warnIfDebug("An error happened during rendering", { ractive: ractive });\n  				err.stack && logIfDebug(err.stack);\n\n  				throw err;\n  			});\n  		}\n  	}\n  }\n\n  function getAdaptors(ractive, protoAdapt, userOptions) {\n  	var adapt, magic, modifyArrays;\n\n  	protoAdapt = protoAdapt.map(lookup);\n  	adapt = ensureArray(userOptions.adapt).map(lookup);\n\n  	adapt = initialise__combine(protoAdapt, adapt);\n\n  	magic = "magic" in userOptions ? userOptions.magic : ractive.magic;\n  	modifyArrays = "modifyArrays" in userOptions ? userOptions.modifyArrays : ractive.modifyArrays;\n\n  	if (magic) {\n  		if (!environment__magic) {\n  			throw new Error("Getters and setters (magic mode) are not supported in this browser");\n  		}\n\n  		if (modifyArrays) {\n  			adapt.push(magicArray);\n  		}\n\n  		adapt.push(adaptors_magic);\n  	}\n\n  	if (modifyArrays) {\n  		adapt.push(array_index);\n  	}\n\n  	return adapt;\n\n  	function lookup(adaptor) {\n  		if (typeof adaptor === "string") {\n  			adaptor = findInViewHierarchy("adaptors", ractive, adaptor);\n\n  			if (!adaptor) {\n  				fatal(missingPlugin(adaptor, "adaptor"));\n  			}\n  		}\n\n  		return adaptor;\n  	}\n  }\n\n  function initialise__combine(a, b) {\n  	var c = a.slice(),\n  	    i = b.length;\n\n  	while (i--) {\n  		if (! ~c.indexOf(b[i])) {\n  			c.push(b[i]);\n  		}\n  	}\n\n  	return c;\n  }\n\n  function initialiseProperties(ractive, options) {\n  	// Generate a unique identifier, for places where you\'d use a weak map if it\n  	// existed\n  	ractive._guid = "r-" + initialise__uid++;\n\n  	// events\n  	ractive._subs = create(null);\n\n  	// storage for item configuration from instantiation to reset,\n  	// like dynamic functions or original values\n  	ractive._config = {};\n\n  	// two-way bindings\n  	ractive._twowayBindings = create(null);\n\n  	// animations (so we can stop any in progress at teardown)\n  	ractive._animations = [];\n\n  	// nodes registry\n  	ractive.nodes = {};\n\n  	// live queries\n  	ractive._liveQueries = [];\n  	ractive._liveComponentQueries = [];\n\n  	// bound data functions\n  	ractive._boundFunctions = [];\n\n  	// observers\n  	ractive._observers = [];\n\n  	// properties specific to inline components\n  	if (options.component) {\n  		ractive.parent = options.parent;\n  		ractive.container = options.container || null;\n  		ractive.root = ractive.parent.root;\n\n  		ractive.component = options.component;\n  		options.component.instance = ractive;\n\n  		// for hackability, this could be an open option\n  		// for any ractive instance, but for now, just\n  		// for components and just for ractive...\n  		ractive._inlinePartials = options.inlinePartials;\n  	} else {\n  		ractive.root = ractive;\n  		ractive.parent = ractive.container = null;\n  	}\n  }\n\n  function deprecateRactiveData() {\n  	throw new Error("Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead");\n  }\n\n  function ComplexParameter(component, template, callback) {\n  	this.parentFragment = component.parentFragment;\n  	this.callback = callback;\n\n  	this.fragment = new virtualdom_Fragment({\n  		template: template,\n  		root: component.root,\n  		owner: this\n  	});\n\n  	this.update();\n  }\n\n  var initialise_ComplexParameter = ComplexParameter;\n\n  ComplexParameter.prototype = {\n  	bubble: function () {\n  		if (!this.dirty) {\n  			this.dirty = true;\n  			global_runloop.addView(this);\n  		}\n  	},\n\n  	update: function () {\n  		this.callback(this.fragment.getValue());\n  		this.dirty = false;\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		this.fragment.rebind(oldKeypath, newKeypath);\n  	},\n\n  	unbind: function () {\n  		this.fragment.unbind();\n  	}\n  };\n\n  var createInstance = function (component, Component, attributes, yieldTemplate, partials) {\n  	var instance,\n  	    parentFragment,\n  	    ractive,\n  	    fragment,\n  	    container,\n  	    inlinePartials = {},\n  	    data = {},\n  	    mappings = {},\n  	    ready,\n  	    resolvers = [];\n\n  	parentFragment = component.parentFragment;\n  	ractive = component.root;\n\n  	partials = partials || {};\n  	utils_object__extend(inlinePartials, partials);\n\n  	// Make contents available as a {{>content}} partial\n  	partials.content = yieldTemplate || [];\n\n  	// set a default partial for yields with no name\n  	inlinePartials[""] = partials.content;\n\n  	if (Component.defaults.el) {\n  		warnIfDebug("The <%s/> component has a default `el` property; it has been disregarded", component.name);\n  	}\n\n  	// find container\n  	fragment = parentFragment;\n  	while (fragment) {\n  		if (fragment.owner.type === YIELDER) {\n  			container = fragment.owner.container;\n  			break;\n  		}\n\n  		fragment = fragment.parent;\n  	}\n\n  	// each attribute represents either a) data or b) a mapping\n  	if (attributes) {\n  		Object.keys(attributes).forEach(function (key) {\n  			var attribute = attributes[key],\n  			    parsed,\n  			    resolver;\n\n  			if (typeof attribute === "string") {\n  				// it\'s static data\n  				parsed = parseJSON(attribute);\n  				data[key] = parsed ? parsed.value : attribute;\n  			} else if (attribute === 0) {\n  				// it had no \'=\', so we\'ll call it true\n  				data[key] = true;\n  			} else if (isArray(attribute)) {\n  				// this represents dynamic data\n  				if (isSingleInterpolator(attribute)) {\n  					mappings[key] = {\n  						origin: component.root.viewmodel,\n  						keypath: undefined\n  					};\n\n  					resolver = createResolver(component, attribute[0], function (keypath) {\n  						if (keypath.isSpecial) {\n  							if (ready) {\n  								instance.set(key, keypath.value); // TODO use viewmodel?\n  							} else {\n  								data[key] = keypath.value;\n\n  								// TODO errr.... would be better if we didn\'t have to do this\n  								delete mappings[key];\n  							}\n  						} else {\n  							if (ready) {\n  								instance.viewmodel.mappings[key].resolve(keypath);\n  							} else {\n  								// resolved immediately\n  								mappings[key].keypath = keypath;\n  							}\n  						}\n  					});\n  				} else {\n  					resolver = new initialise_ComplexParameter(component, attribute, function (value) {\n  						if (ready) {\n  							instance.set(key, value); // TODO use viewmodel?\n  						} else {\n  							data[key] = value;\n  						}\n  					});\n  				}\n\n  				resolvers.push(resolver);\n  			} else {\n  				throw new Error("erm wut");\n  			}\n  		});\n  	}\n\n  	instance = create(Component.prototype);\n\n  	initialise(instance, {\n  		el: null,\n  		append: true,\n  		data: data,\n  		partials: partials,\n  		magic: ractive.magic || Component.defaults.magic,\n  		modifyArrays: ractive.modifyArrays,\n  		// need to inherit runtime parent adaptors\n  		adapt: ractive.adapt\n  	}, {\n  		parent: ractive,\n  		component: component,\n  		container: container,\n  		mappings: mappings,\n  		inlinePartials: inlinePartials,\n  		cssIds: parentFragment.cssIds\n  	});\n\n  	ready = true;\n  	component.resolvers = resolvers;\n\n  	return instance;\n  };\n\n  function createResolver(component, template, callback) {\n  	var resolver;\n\n  	if (template.r) {\n  		resolver = Resolvers_createReferenceResolver(component, template.r, callback);\n  	} else if (template.x) {\n  		resolver = new Resolvers_ExpressionResolver(component, component.parentFragment, template.x, callback);\n  	} else if (template.rx) {\n  		resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(component, template.rx, callback);\n  	}\n\n  	return resolver;\n  }\n\n  function isSingleInterpolator(template) {\n  	return template.length === 1 && template[0].t === INTERPOLATOR;\n  }\n\n  // TODO how should event arguments be handled? e.g.\n  // <widget on-foo=\'bar:1,2,3\'/>\n  // The event \'bar\' will be fired on the parent instance\n  // when \'foo\' fires on the child, but the 1,2,3 arguments\n  // will be lost\n\n  var initialise_propagateEvents = propagateEvents;\n\n  function propagateEvents(component, eventsDescriptor) {\n  	var eventName;\n\n  	for (eventName in eventsDescriptor) {\n  		if (eventsDescriptor.hasOwnProperty(eventName)) {\n  			propagateEvent(component.instance, component.root, eventName, eventsDescriptor[eventName]);\n  		}\n  	}\n  }\n\n  function propagateEvent(childInstance, parentInstance, eventName, proxyEventName) {\n  	if (typeof proxyEventName !== "string") {\n  		fatal("Components currently only support simple events - you cannot include arguments. Sorry!");\n  	}\n\n  	childInstance.on(eventName, function () {\n  		var event, args;\n\n  		// semi-weak test, but what else? tag the event obj ._isEvent ?\n  		if (arguments.length && arguments[0] && arguments[0].node) {\n  			event = Array.prototype.shift.call(arguments);\n  		}\n\n  		args = Array.prototype.slice.call(arguments);\n\n  		shared_fireEvent(parentInstance, proxyEventName, { event: event, args: args });\n\n  		// cancel bubbling\n  		return false;\n  	});\n  }\n\n  var initialise_updateLiveQueries = function (component) {\n  	var ancestor, query;\n\n  	// If there\'s a live query for this component type, add it\n  	ancestor = component.root;\n  	while (ancestor) {\n  		if (query = ancestor._liveComponentQueries["_" + component.name]) {\n  			query.push(component.instance);\n  		}\n\n  		ancestor = ancestor.parent;\n  	}\n  };\n\n  var Component_prototype_init = Component$init;\n  function Component$init(options, Component) {\n  	var parentFragment, root;\n\n  	if (!Component) {\n  		throw new Error("Component \\"" + this.name + "\\" not found");\n  	}\n\n  	parentFragment = this.parentFragment = options.parentFragment;\n  	root = parentFragment.root;\n\n  	this.root = root;\n  	this.type = COMPONENT;\n  	this.name = options.template.e;\n  	this.index = options.index;\n  	this.indexRefBindings = {};\n  	this.yielders = {};\n  	this.resolvers = [];\n\n  	createInstance(this, Component, options.template.a, options.template.f, options.template.p);\n  	initialise_propagateEvents(this, options.template.v);\n\n  	// intro, outro and decorator directives have no effect\n  	if (options.template.t0 || options.template.t1 || options.template.t2 || options.template.o) {\n  		warnIfDebug("The \\"intro\\", \\"outro\\" and \\"decorator\\" directives have no effect on components", { ractive: this.instance });\n  	}\n\n  	initialise_updateLiveQueries(this);\n  }\n\n  var Component_prototype_rebind = Component$rebind;\n\n  function Component$rebind(oldKeypath, newKeypath) {\n  	var query;\n\n  	this.resolvers.forEach(rebind);\n\n  	for (var k in this.yielders) {\n  		if (this.yielders[k][0]) {\n  			rebind(this.yielders[k][0]);\n  		}\n  	}\n\n  	if (query = this.root._liveComponentQueries["_" + this.name]) {\n  		query._makeDirty();\n  	}\n\n  	function rebind(x) {\n  		x.rebind(oldKeypath, newKeypath);\n  	}\n  }\n\n  var Component_prototype_render = Component$render;\n\n  function Component$render() {\n  	var instance = this.instance;\n\n  	instance.render(this.parentFragment.getNode());\n\n  	this.rendered = true;\n  	return instance.fragment.detach();\n  }\n\n  var Component_prototype_toString = Component$toString;\n\n  function Component$toString() {\n  	return this.instance.fragment.toString();\n  }\n\n  var Component_prototype_unbind = Component$unbind;\n\n  var Component_prototype_unbind__teardownHook = new hooks_Hook("teardown");\n  function Component$unbind() {\n  	var instance = this.instance;\n\n  	this.resolvers.forEach(methodCallers__unbind);\n\n  	removeFromLiveComponentQueries(this);\n\n  	instance._observers.forEach(cancel);\n\n  	// teardown the instance\n  	instance.fragment.unbind();\n  	instance.viewmodel.teardown();\n\n  	if (instance.fragment.rendered && instance.el.__ractive_instances__) {\n  		removeFromArray(instance.el.__ractive_instances__, instance);\n  	}\n\n  	Component_prototype_unbind__teardownHook.fire(instance);\n  }\n\n  function removeFromLiveComponentQueries(component) {\n  	var instance, query;\n\n  	instance = component.root;\n\n  	do {\n  		if (query = instance._liveComponentQueries["_" + component.name]) {\n  			query._remove(component);\n  		}\n  	} while (instance = instance.parent);\n  }\n\n  var Component_prototype_unrender = Component$unrender;\n\n  function Component$unrender(shouldDestroy) {\n  	this.shouldDestroy = shouldDestroy;\n  	this.instance.unrender();\n  }\n\n  var Component = function (options, Constructor) {\n  	this.init(options, Constructor);\n  };\n\n  Component.prototype = {\n  	detach: Component_prototype_detach,\n  	find: Component_prototype_find,\n  	findAll: Component_prototype_findAll,\n  	findAllComponents: Component_prototype_findAllComponents,\n  	findComponent: Component_prototype_findComponent,\n  	findNextNode: Component_prototype_findNextNode,\n  	firstNode: Component_prototype_firstNode,\n  	init: Component_prototype_init,\n  	rebind: Component_prototype_rebind,\n  	render: Component_prototype_render,\n  	toString: Component_prototype_toString,\n  	unbind: Component_prototype_unbind,\n  	unrender: Component_prototype_unrender\n  };\n\n  var _Component = Component;\n\n  var Comment = function (options) {\n  	this.type = COMMENT;\n  	this.value = options.template.c;\n  };\n\n  Comment.prototype = {\n  	detach: shared_detach,\n\n  	firstNode: function () {\n  		return this.node;\n  	},\n\n  	render: function () {\n  		if (!this.node) {\n  			this.node = document.createComment(this.value);\n  		}\n\n  		return this.node;\n  	},\n\n  	toString: function () {\n  		return "<!--" + this.value + "-->";\n  	},\n\n  	unrender: function (shouldDestroy) {\n  		if (shouldDestroy) {\n  			this.node.parentNode.removeChild(this.node);\n  		}\n  	}\n  };\n\n  var items_Comment = Comment;\n\n  var Yielder = function (options) {\n  	var container, component;\n\n  	this.type = YIELDER;\n\n  	this.container = container = options.parentFragment.root;\n  	this.component = component = container.component;\n\n  	this.container = container;\n  	this.containerFragment = options.parentFragment;\n  	this.parentFragment = component.parentFragment;\n\n  	var name = this.name = options.template.n || "";\n\n  	var template = container._inlinePartials[name];\n\n  	if (!template) {\n  		warnIfDebug("Could not find template for partial \\"" + name + "\\"", { ractive: options.root });\n  		template = [];\n  	}\n\n  	this.fragment = new virtualdom_Fragment({\n  		owner: this,\n  		root: container.parent,\n  		template: template,\n  		pElement: this.containerFragment.pElement\n  	});\n\n  	// even though only one yielder is allowed, we need to have an array of them\n  	// as it\'s possible to cause a yielder to be created before the last one\n  	// was destroyed in the same turn of the runloop\n  	if (!isArray(component.yielders[name])) {\n  		component.yielders[name] = [this];\n  	} else {\n  		component.yielders[name].push(this);\n  	}\n\n  	global_runloop.scheduleTask(function () {\n  		if (component.yielders[name].length > 1) {\n  			throw new Error("A component template can only have one {{yield" + (name ? " " + name : "") + "}} declaration at a time");\n  		}\n  	});\n  };\n\n  Yielder.prototype = {\n  	detach: function () {\n  		return this.fragment.detach();\n  	},\n\n  	find: function (selector) {\n  		return this.fragment.find(selector);\n  	},\n\n  	findAll: function (selector, query) {\n  		return this.fragment.findAll(selector, query);\n  	},\n\n  	findComponent: function (selector) {\n  		return this.fragment.findComponent(selector);\n  	},\n\n  	findAllComponents: function (selector, query) {\n  		return this.fragment.findAllComponents(selector, query);\n  	},\n\n  	findNextNode: function () {\n  		return this.containerFragment.findNextNode(this);\n  	},\n\n  	firstNode: function () {\n  		return this.fragment.firstNode();\n  	},\n\n  	getValue: function (options) {\n  		return this.fragment.getValue(options);\n  	},\n\n  	render: function () {\n  		return this.fragment.render();\n  	},\n\n  	unbind: function () {\n  		this.fragment.unbind();\n  	},\n\n  	unrender: function (shouldDestroy) {\n  		this.fragment.unrender(shouldDestroy);\n  		removeFromArray(this.component.yielders[this.name], this);\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		this.fragment.rebind(oldKeypath, newKeypath);\n  	},\n\n  	toString: function () {\n  		return this.fragment.toString();\n  	}\n  };\n\n  var items_Yielder = Yielder;\n\n  var Doctype = function (options) {\n  	this.declaration = options.template.a;\n  };\n\n  Doctype.prototype = {\n  	init: noop,\n  	render: noop,\n  	unrender: noop,\n  	teardown: noop,\n  	toString: function () {\n  		return "<!DOCTYPE" + this.declaration + ">";\n  	}\n  };\n\n  var items_Doctype = Doctype;\n\n  var Fragment_prototype_init = Fragment$init;\n\n  function Fragment$init(options) {\n  	var _this = this;\n\n  	this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n  	this.parent = this.owner.parentFragment;\n\n  	// inherited properties\n  	this.root = options.root;\n  	this.pElement = options.pElement;\n  	this.context = options.context;\n  	this.index = options.index;\n  	this.key = options.key;\n  	this.registeredIndexRefs = [];\n\n  	// encapsulated styles should be inherited until they get applied by an element\n  	this.cssIds = "cssIds" in options ? options.cssIds : this.parent ? this.parent.cssIds : null;\n\n  	this.items = options.template.map(function (template, i) {\n  		return createItem({\n  			parentFragment: _this,\n  			pElement: options.pElement,\n  			template: template,\n  			index: i\n  		});\n  	});\n\n  	this.value = this.argsList = null;\n  	this.dirtyArgs = this.dirtyValue = true;\n\n  	this.bound = true;\n  }\n\n  function createItem(options) {\n  	if (typeof options.template === "string") {\n  		return new items_Text(options);\n  	}\n\n  	switch (options.template.t) {\n  		case YIELDER:\n  			return new items_Yielder(options);\n  		case INTERPOLATOR:\n  			return new items_Interpolator(options);\n  		case SECTION:\n  			return new _Section(options);\n  		case TRIPLE:\n  			return new _Triple(options);\n  		case ELEMENT:\n  			var constructor = undefined;\n  			if (constructor = Component_getComponent(options.parentFragment.root, options.template.e)) {\n  				return new _Component(options, constructor);\n  			}\n  			return new _Element(options);\n  		case PARTIAL:\n  			return new _Partial(options);\n  		case COMMENT:\n  			return new items_Comment(options);\n  		case DOCTYPE:\n  			return new items_Doctype(options);\n\n  		default:\n  			throw new Error("Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!");\n  	}\n  }\n\n  var Fragment_prototype_rebind = Fragment$rebind;\n  function Fragment$rebind(oldKeypath, newKeypath) {\n\n  	// assign new context keypath if needed\n  	if (!this.owner || this.owner.hasContext) {\n  		assignNewKeypath(this, "context", oldKeypath, newKeypath);\n  	}\n\n  	this.items.forEach(function (item) {\n  		if (item.rebind) {\n  			item.rebind(oldKeypath, newKeypath);\n  		}\n  	});\n  }\n\n  var Fragment_prototype_render = Fragment$render;\n\n  function Fragment$render() {\n  	var result;\n\n  	if (this.items.length === 1) {\n  		result = this.items[0].render();\n  	} else {\n  		result = document.createDocumentFragment();\n\n  		this.items.forEach(function (item) {\n  			result.appendChild(item.render());\n  		});\n  	}\n\n  	this.rendered = true;\n  	return result;\n  }\n\n  var Fragment_prototype_toString = Fragment$toString;\n\n  function Fragment$toString(escape) {\n  	if (!this.items) {\n  		return "";\n  	}\n\n  	return this.items.map(escape ? toEscapedString : Fragment_prototype_toString__toString).join("");\n  }\n\n  function Fragment_prototype_toString__toString(item) {\n  	return item.toString();\n  }\n\n  function toEscapedString(item) {\n  	return item.toString(true);\n  }\n\n  var Fragment_prototype_unbind = Fragment$unbind;\n\n  function Fragment$unbind() {\n  	if (!this.bound) {\n  		return;\n  	}\n\n  	this.items.forEach(unbindItem);\n  	this.bound = false;\n  }\n\n  function unbindItem(item) {\n  	if (item.unbind) {\n  		item.unbind();\n  	}\n  }\n\n  var Fragment_prototype_unrender = Fragment$unrender;\n\n  function Fragment$unrender(shouldDestroy) {\n  	if (!this.rendered) {\n  		throw new Error("Attempted to unrender a fragment that was not rendered");\n  	}\n\n  	this.items.forEach(function (i) {\n  		return i.unrender(shouldDestroy);\n  	});\n  	this.rendered = false;\n  }\n\n  var Fragment = function (options) {\n  	this.init(options);\n  };\n\n  Fragment.prototype = {\n  	bubble: prototype_bubble,\n  	detach: Fragment_prototype_detach,\n  	find: Fragment_prototype_find,\n  	findAll: Fragment_prototype_findAll,\n  	findAllComponents: Fragment_prototype_findAllComponents,\n  	findComponent: Fragment_prototype_findComponent,\n  	findNextNode: prototype_findNextNode,\n  	firstNode: prototype_firstNode,\n  	getArgsList: getArgsList,\n  	getNode: getNode,\n  	getValue: prototype_getValue,\n  	init: Fragment_prototype_init,\n  	rebind: Fragment_prototype_rebind,\n  	registerIndexRef: function (idx) {\n  		var idxs = this.registeredIndexRefs;\n  		if (idxs.indexOf(idx) === -1) {\n  			idxs.push(idx);\n  		}\n  	},\n  	render: Fragment_prototype_render,\n  	toString: Fragment_prototype_toString,\n  	unbind: Fragment_prototype_unbind,\n  	unregisterIndexRef: function (idx) {\n  		var idxs = this.registeredIndexRefs;\n  		idxs.splice(idxs.indexOf(idx), 1);\n  	},\n  	unrender: Fragment_prototype_unrender\n  };\n\n  var virtualdom_Fragment = Fragment;\n\n  var prototype_reset = Ractive$reset;\n  var shouldRerender = ["template", "partials", "components", "decorators", "events"],\n      resetHook = new hooks_Hook("reset");\n  function Ractive$reset(data) {\n  	var promise, wrapper, changes, i, rerender;\n\n  	data = data || {};\n\n  	if (typeof data !== "object") {\n  		throw new Error("The reset method takes either no arguments, or an object containing new data");\n  	}\n\n  	// If the root object is wrapped, try and use the wrapper\'s reset value\n  	if ((wrapper = this.viewmodel.wrapped[""]) && wrapper.reset) {\n  		if (wrapper.reset(data) === false) {\n  			// reset was rejected, we need to replace the object\n  			this.viewmodel.reset(data);\n  		}\n  	} else {\n  		this.viewmodel.reset(data);\n  	}\n\n  	// reset config items and track if need to rerender\n  	changes = config_config.reset(this);\n\n  	i = changes.length;\n  	while (i--) {\n  		if (shouldRerender.indexOf(changes[i]) > -1) {\n  			rerender = true;\n  			break;\n  		}\n  	}\n\n  	if (rerender) {\n  		var component = undefined;\n\n  		this.viewmodel.mark(rootKeypath);\n\n  		// Is this is a component, we need to set the `shouldDestroy`\n  		// flag, otherwise it will assume by default that a parent node\n  		// will be detached, and therefore it doesn\'t need to bother\n  		// detaching its own nodes\n  		if (component = this.component) {\n  			component.shouldDestroy = true;\n  		}\n\n  		this.unrender();\n\n  		if (component) {\n  			component.shouldDestroy = false;\n  		}\n\n  		// If the template changed, we need to destroy the parallel DOM\n  		// TODO if we\'re here, presumably it did?\n  		if (this.fragment.template !== this.template) {\n  			this.fragment.unbind();\n\n  			this.fragment = new virtualdom_Fragment({\n  				template: this.template,\n  				root: this,\n  				owner: this\n  			});\n  		}\n\n  		promise = this.render(this.el, this.anchor);\n  	} else {\n  		promise = global_runloop.start(this, true);\n  		this.viewmodel.mark(rootKeypath);\n  		global_runloop.end();\n  	}\n\n  	resetHook.fire(this, data);\n\n  	return promise;\n  }\n\n  var resetPartial = function (name, partial) {\n  	var promise,\n  	    collection = [];\n\n  	function collect(source, dest, ractive) {\n  		// if this is a component and it has its own partial, bail\n  		if (ractive && ractive.partials[name]) return;\n\n  		source.forEach(function (item) {\n  			// queue to rerender if the item is a partial and the current name matches\n  			if (item.type === PARTIAL && item.getPartialName() === name) {\n  				dest.push(item);\n  			}\n\n  			// if it has a fragment, process its items\n  			if (item.fragment) {\n  				collect(item.fragment.items, dest, ractive);\n  			}\n\n  			// or if it has fragments\n  			if (isArray(item.fragments)) {\n  				collect(item.fragments, dest, ractive);\n  			}\n\n  			// or if it is itself a fragment, process its items\n  			else if (isArray(item.items)) {\n  				collect(item.items, dest, ractive);\n  			}\n\n  			// or if it is a component, step in and process its items\n  			else if (item.type === COMPONENT && item.instance) {\n  				collect(item.instance.fragment.items, dest, item.instance);\n  			}\n\n  			// if the item is an element, process its attributes too\n  			if (item.type === ELEMENT) {\n  				if (isArray(item.attributes)) {\n  					collect(item.attributes, dest, ractive);\n  				}\n\n  				if (isArray(item.conditionalAttributes)) {\n  					collect(item.conditionalAttributes, dest, ractive);\n  				}\n  			}\n  		});\n  	}\n\n  	collect(this.fragment.items, collection);\n  	this.partials[name] = partial;\n\n  	promise = global_runloop.start(this, true);\n\n  	collection.forEach(function (item) {\n  		item.value = undefined;\n  		item.setValue(name);\n  	});\n\n  	global_runloop.end();\n\n  	return promise;\n  };\n\n  // TODO should resetTemplate be asynchronous? i.e. should it be a case\n  // of outro, update template, intro? I reckon probably not, since that\n  // could be achieved with unrender-resetTemplate-render. Also, it should\n  // conceptually be similar to resetPartial, which couldn\'t be async\n\n  var resetTemplate = Ractive$resetTemplate;\n  function Ractive$resetTemplate(template) {\n  	var transitionsEnabled, component;\n\n  	template_template.init(null, this, { template: template });\n\n  	transitionsEnabled = this.transitionsEnabled;\n  	this.transitionsEnabled = false;\n\n  	// Is this is a component, we need to set the `shouldDestroy`\n  	// flag, otherwise it will assume by default that a parent node\n  	// will be detached, and therefore it doesn\'t need to bother\n  	// detaching its own nodes\n  	if (component = this.component) {\n  		component.shouldDestroy = true;\n  	}\n\n  	this.unrender();\n\n  	if (component) {\n  		component.shouldDestroy = false;\n  	}\n\n  	// remove existing fragment and create new one\n  	this.fragment.unbind();\n  	this.fragment = new virtualdom_Fragment({\n  		template: this.template,\n  		root: this,\n  		owner: this\n  	});\n\n  	this.render(this.el, this.anchor);\n\n  	this.transitionsEnabled = transitionsEnabled;\n  }\n\n  var reverse = makeArrayMethod("reverse");\n\n  var Ractive_prototype_set = Ractive$set;\n\n  function Ractive$set(keypath, value) {\n  	var map, promise;\n\n  	promise = global_runloop.start(this, true);\n\n  	// Set multiple keypaths in one go\n  	if (isObject(keypath)) {\n  		map = keypath;\n\n  		for (keypath in map) {\n  			if (map.hasOwnProperty(keypath)) {\n  				value = map[keypath];\n  				set(this, keypath, value);\n  			}\n  		}\n  	}\n\n  	// Set a single keypath\n  	else {\n  		set(this, keypath, value);\n  	}\n\n  	global_runloop.end();\n\n  	return promise;\n  }\n\n  function set(ractive, keypath, value) {\n  	keypath = getKeypath(normalise(keypath));\n\n  	if (keypath.isPattern) {\n  		getMatchingKeypaths(ractive, keypath).forEach(function (keypath) {\n  			ractive.viewmodel.set(keypath, value);\n  		});\n  	} else {\n  		ractive.viewmodel.set(keypath, value);\n  	}\n  }\n\n  var shift = makeArrayMethod("shift");\n\n  var prototype_sort = makeArrayMethod("sort");\n\n  var splice = makeArrayMethod("splice");\n\n  var subtract = Ractive$subtract;\n  function Ractive$subtract(keypath, d) {\n  	return shared_add(this, keypath, d === undefined ? -1 : -d);\n  }\n\n  // Teardown. This goes through the root fragment and all its children, removing observers\n  // and generally cleaning up after itself\n\n  var Ractive_prototype_teardown = Ractive$teardown;\n\n  var Ractive_prototype_teardown__teardownHook = new hooks_Hook("teardown");\n  function Ractive$teardown() {\n  	var promise;\n\n  	this.fragment.unbind();\n  	this.viewmodel.teardown();\n\n  	this._observers.forEach(cancel);\n\n  	if (this.fragment.rendered && this.el.__ractive_instances__) {\n  		removeFromArray(this.el.__ractive_instances__, this);\n  	}\n\n  	this.shouldDestroy = true;\n  	promise = this.fragment.rendered ? this.unrender() : utils_Promise.resolve();\n\n  	Ractive_prototype_teardown__teardownHook.fire(this);\n\n  	this._boundFunctions.forEach(deleteFunctionCopy);\n\n  	return promise;\n  }\n\n  function deleteFunctionCopy(bound) {\n  	delete bound.fn[bound.prop];\n  }\n\n  var toggle = Ractive$toggle;\n  function Ractive$toggle(keypath) {\n  	var _this = this;\n\n  	if (typeof keypath !== "string") {\n  		throw new TypeError(badArguments);\n  	}\n\n  	var changes = undefined;\n\n  	if (/\\*/.test(keypath)) {\n  		changes = {};\n\n  		getMatchingKeypaths(this, getKeypath(normalise(keypath))).forEach(function (keypath) {\n  			changes[keypath.str] = !_this.viewmodel.get(keypath);\n  		});\n\n  		return this.set(changes);\n  	}\n\n  	return this.set(keypath, !this.get(keypath));\n  }\n\n  var toHTML = Ractive$toHTML;\n\n  function Ractive$toHTML() {\n  	return this.fragment.toString(true);\n  }\n\n  var Ractive_prototype_unrender = Ractive$unrender;\n  var unrenderHook = new hooks_Hook("unrender");\n  function Ractive$unrender() {\n  	var promise, shouldDestroy;\n\n  	if (!this.fragment.rendered) {\n  		warnIfDebug("ractive.unrender() was called on a Ractive instance that was not rendered");\n  		return utils_Promise.resolve();\n  	}\n\n  	promise = global_runloop.start(this, true);\n\n  	// If this is a component, and the component isn\'t marked for destruction,\n  	// don\'t detach nodes from the DOM unnecessarily\n  	shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\n  	// Cancel any animations in progress\n  	while (this._animations[0]) {\n  		this._animations[0].stop(); // it will remove itself from the index\n  	}\n\n  	this.fragment.unrender(shouldDestroy);\n\n  	removeFromArray(this.el.__ractive_instances__, this);\n\n  	unrenderHook.fire(this);\n\n  	global_runloop.end();\n  	return promise;\n  }\n\n  var unshift = makeArrayMethod("unshift");\n\n  var Ractive_prototype_update = Ractive$update;\n  var updateHook = new hooks_Hook("update");\n  function Ractive$update(keypath) {\n  	var promise;\n\n  	keypath = getKeypath(keypath) || rootKeypath;\n\n  	promise = global_runloop.start(this, true);\n  	this.viewmodel.mark(keypath);\n  	global_runloop.end();\n\n  	updateHook.fire(this, keypath);\n\n  	return promise;\n  }\n\n  var prototype_updateModel = Ractive$updateModel;\n\n  function Ractive$updateModel(keypath, cascade) {\n  	var values, key, bindings;\n\n  	if (typeof keypath === "string" && !cascade) {\n  		bindings = this._twowayBindings[keypath];\n  	} else {\n  		bindings = [];\n\n  		for (key in this._twowayBindings) {\n  			if (!keypath || getKeypath(key).equalsOrStartsWith(keypath)) {\n  				// TODO is this right?\n  				bindings.push.apply(bindings, this._twowayBindings[key]);\n  			}\n  		}\n  	}\n\n  	values = consolidate(this, bindings);\n  	return this.set(values);\n  }\n\n  function consolidate(ractive, bindings) {\n  	var values = {},\n  	    checkboxGroups = [];\n\n  	bindings.forEach(function (b) {\n  		var oldValue, newValue;\n\n  		// special case - radio name bindings\n  		if (b.radioName && !b.element.node.checked) {\n  			return;\n  		}\n\n  		// special case - checkbox name bindings come in groups, so\n  		// we want to get the value once at most\n  		if (b.checkboxName) {\n  			if (!checkboxGroups[b.keypath.str] && !b.changed()) {\n  				checkboxGroups.push(b.keypath);\n  				checkboxGroups[b.keypath.str] = b;\n  			}\n\n  			return;\n  		}\n\n  		oldValue = b.attribute.value;\n  		newValue = b.getValue();\n\n  		if (arrayContentsMatch(oldValue, newValue)) {\n  			return;\n  		}\n\n  		if (!isEqual(oldValue, newValue)) {\n  			values[b.keypath.str] = newValue;\n  		}\n  	});\n\n  	// Handle groups of `<input type=\'checkbox\' name=\'{{foo}}\' ...>`\n  	if (checkboxGroups.length) {\n  		checkboxGroups.forEach(function (keypath) {\n  			var binding, oldValue, newValue;\n\n  			binding = checkboxGroups[keypath.str]; // one to represent the entire group\n  			oldValue = binding.attribute.value;\n  			newValue = binding.getValue();\n\n  			if (!arrayContentsMatch(oldValue, newValue)) {\n  				values[keypath.str] = newValue;\n  			}\n  		});\n  	}\n\n  	return values;\n  }\n\n  var prototype = {\n  	add: prototype_add,\n  	animate: prototype_animate,\n  	detach: prototype_detach,\n  	find: prototype_find,\n  	findAll: prototype_findAll,\n  	findAllComponents: prototype_findAllComponents,\n  	findComponent: prototype_findComponent,\n  	findContainer: findContainer,\n  	findParent: findParent,\n  	fire: prototype_fire,\n  	get: prototype_get,\n  	insert: insert,\n  	merge: prototype_merge,\n  	observe: observe,\n  	observeOnce: observeOnce,\n  	off: off,\n  	on: on,\n  	once: once,\n  	pop: pop,\n  	push: push,\n  	render: prototype_render,\n  	reset: prototype_reset,\n  	resetPartial: resetPartial,\n  	resetTemplate: resetTemplate,\n  	reverse: reverse,\n  	set: Ractive_prototype_set,\n  	shift: shift,\n  	sort: prototype_sort,\n  	splice: splice,\n  	subtract: subtract,\n  	teardown: Ractive_prototype_teardown,\n  	toggle: toggle,\n  	toHTML: toHTML,\n  	toHtml: toHTML,\n  	unrender: Ractive_prototype_unrender,\n  	unshift: unshift,\n  	update: Ractive_prototype_update,\n  	updateModel: prototype_updateModel\n  };\n\n  var wrapMethod = function (method, superMethod, force) {\n\n  	if (force || needsSuper(method, superMethod)) {\n\n  		return function () {\n\n  			var hasSuper = ("_super" in this),\n  			    _super = this._super,\n  			    result;\n\n  			this._super = superMethod;\n\n  			result = method.apply(this, arguments);\n\n  			if (hasSuper) {\n  				this._super = _super;\n  			}\n\n  			return result;\n  		};\n  	} else {\n  		return method;\n  	}\n  };\n\n  function needsSuper(method, superMethod) {\n  	return typeof superMethod === "function" && /_super/.test(method);\n  }\n\n  var unwrapExtended = unwrap;\n\n  function unwrap(Child) {\n  	var options = {};\n\n  	while (Child) {\n  		addRegistries(Child, options);\n  		addOtherOptions(Child, options);\n\n  		if (Child._Parent !== _Ractive) {\n  			Child = Child._Parent;\n  		} else {\n  			Child = false;\n  		}\n  	}\n\n  	return options;\n  }\n\n  function addRegistries(Child, options) {\n  	config_registries.forEach(function (r) {\n  		addRegistry(r.useDefaults ? Child.prototype : Child, options, r.name);\n  	});\n  }\n\n  function addRegistry(target, options, name) {\n  	var registry,\n  	    keys = Object.keys(target[name]);\n\n  	if (!keys.length) {\n  		return;\n  	}\n\n  	if (!(registry = options[name])) {\n  		registry = options[name] = {};\n  	}\n\n  	keys.filter(function (key) {\n  		return !(key in registry);\n  	}).forEach(function (key) {\n  		return registry[key] = target[name][key];\n  	});\n  }\n\n  function addOtherOptions(Child, options) {\n  	Object.keys(Child.prototype).forEach(function (key) {\n  		if (key === "computed") {\n  			return;\n  		}\n\n  		var value = Child.prototype[key];\n\n  		if (!(key in options)) {\n  			options[key] = value._method ? value._method : value;\n  		}\n\n  		// is it a wrapped function?\n  		else if (typeof options[key] === "function" && typeof value === "function" && options[key]._method) {\n\n  			var result = undefined,\n  			    needsSuper = value._method;\n\n  			if (needsSuper) {\n  				value = value._method;\n  			}\n\n  			// rewrap bound directly to parent fn\n  			result = wrapMethod(options[key]._method, value);\n\n  			if (needsSuper) {\n  				result._method = result;\n  			}\n\n  			options[key] = result;\n  		}\n  	});\n  }\n\n  var _extend = _extend__extend;\n\n  function _extend__extend() {\n  	for (var _len = arguments.length, options = Array(_len), _key = 0; _key < _len; _key++) {\n  		options[_key] = arguments[_key];\n  	}\n\n  	if (!options.length) {\n  		return extendOne(this);\n  	} else {\n  		return options.reduce(extendOne, this);\n  	}\n  }\n\n  function extendOne(Parent) {\n  	var options = arguments[1] === undefined ? {} : arguments[1];\n\n  	var Child, proto;\n\n  	// if we\'re extending with another Ractive instance...\n  	//\n  	//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);\n  	//   var Spiderman = Human.extend( Spider );\n  	//\n  	// ...inherit prototype methods and default options as well\n  	if (options.prototype instanceof _Ractive) {\n  		options = unwrapExtended(options);\n  	}\n\n  	Child = function (options) {\n  		if (!(this instanceof Child)) return new Child(options);\n  		initialise(this, options);\n  	};\n\n  	proto = create(Parent.prototype);\n  	proto.constructor = Child;\n\n  	// Static properties\n  	defineProperties(Child, {\n  		// alias prototype as defaults\n  		defaults: { value: proto },\n\n  		// extendable\n  		extend: { value: _extend__extend, writable: true, configurable: true },\n\n  		// Parent - for IE8, can\'t use Object.getPrototypeOf\n  		_Parent: { value: Parent }\n  	});\n\n  	// extend configuration\n  	config_config.extend(Parent, proto, options);\n\n  	custom_data.extend(Parent, proto, options);\n\n  	if (options.computed) {\n  		proto.computed = utils_object__extend(create(Parent.prototype.computed), options.computed);\n  	}\n\n  	Child.prototype = proto;\n\n  	return Child;\n  }\n\n  var getNodeInfo = function (node) {\n  	var info = {},\n  	    priv,\n  	    indices;\n\n  	if (!node || !(priv = node._ractive)) {\n  		return info;\n  	}\n\n  	info.ractive = priv.root;\n  	info.keypath = priv.keypath.str;\n  	info.index = {};\n\n  	// find all index references and resolve them\n  	if (indices = Resolvers_findIndexRefs(priv.proxy.parentFragment)) {\n  		info.index = Resolvers_findIndexRefs.resolve(indices);\n  	}\n\n  	return info;\n  };\n\n  var Ractive, properties;\n\n  // Main Ractive required object\n  Ractive = function (options) {\n  	if (!(this instanceof Ractive)) return new Ractive(options);\n  	initialise(this, options);\n  };\n\n  // Ractive properties\n  properties = {\n\n  	// debug flag\n  	DEBUG: { writable: true, value: true },\n  	DEBUG_PROMISES: { writable: true, value: true },\n\n  	// static methods:\n  	extend: { value: _extend },\n  	getNodeInfo: { value: getNodeInfo },\n  	parse: { value: _parse },\n\n  	// Namespaced constructors\n  	Promise: { value: utils_Promise },\n\n  	// support\n  	svg: { value: svg },\n  	magic: { value: environment__magic },\n\n  	// version\n  	VERSION: { value: "0.7.3" },\n\n  	// Plugins\n  	adaptors: { writable: true, value: {} },\n  	components: { writable: true, value: {} },\n  	decorators: { writable: true, value: {} },\n  	easing: { writable: true, value: static_easing },\n  	events: { writable: true, value: {} },\n  	interpolators: { writable: true, value: static_interpolators },\n  	partials: { writable: true, value: {} },\n  	transitions: { writable: true, value: {} }\n  };\n\n  // Ractive properties\n  defineProperties(Ractive, properties);\n\n  Ractive.prototype = utils_object__extend(prototype, config_defaults);\n\n  Ractive.prototype.constructor = Ractive;\n\n  // alias prototype as defaults\n  Ractive.defaults = Ractive.prototype;\n\n  // Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n  // older browsers, these are made available via a shim - here, we do a quick\n  // pre-flight check to make sure that either a) we\'re not in a shit browser,\n  // or b) we\'re using a Ractive-legacy.js build\n  var FUNCTION = "function";\n\n  if (typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== "undefined" && typeof window.addEventListener !== FUNCTION) {\n  	throw new Error("It looks like you\'re attempting to use Ractive.js in an older browser. You\'ll need to use one of the \'legacy builds\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.");\n  }\n\n  var _Ractive = Ractive;\n\n  return _Ractive;\n\n}));\n//# sourceMappingURL=ractive.js.map\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JhY3RpdmUvcmFjdGl2ZS5qcz9mMGIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjs7QUFFckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyw2QkFBNkI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekIsMEJBQTBCLE9BQU87QUFDakM7O0FBRUE7QUFDQSxXQUFXO0FBQ1gsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCLFdBQVcsV0FBVztBQUNqRDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsV0FBVyxXQUFXOztBQUVqRDtBQUNBLGtFQUFrRSxXQUFXO0FBQzdFOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLEdBQUcsUUFBUSxXQUFXLEVBQUU7QUFDdEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxRQUFRLFdBQVcsRUFBRTtBQUN4RTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSx3RkFBd0YsYUFBYTtBQUNyRztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3RkFBd0YsYUFBYTtBQUNyRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxR0FBcUcscUJBQXFCLDJCQUEyQixxQkFBcUIsMkJBQTJCLHFCQUFxQiw2QkFBNkIscUJBQXFCLDRCQUE0QjtBQUN4UyxrUUFBa1EsdUhBQXVILGVBQWUsRUFBRTs7QUFFMVk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRkFBMEYsMkJBQTJCO0FBQ3JIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxxRkFBcUYsYUFBYTtBQUNsRztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUZBQXFGLGFBQWE7QUFDbEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRkFBcUYsYUFBYTtBQUNsRztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBOztBQUVBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHFEQUFxRDtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVTtBQUNWLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0wsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7O0FBRUEsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsa0JBQWtCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBLGlCQUFpQjtBQUNqQixJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxXQUFXLGNBQWM7O0FBRXpCLHdCQUF3QiwwQkFBMEI7QUFDbEQsWUFBWTtBQUNaLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSwwQkFBMEI7O0FBRXZDLFlBQVksaUJBQWlCO0FBQzdCLFlBQVksY0FBYztBQUMxQixpQkFBaUIseUJBQXlCO0FBQzFDLGNBQWMsZ0JBQWdCOztBQUU5QixhQUFhO0FBQ2IsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhCQUE4QixRQUFRO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEdBQUcsK0NBQStDOztBQUV0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNENBQTRDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBOztBQUVBLFNBQVMsZUFBZTtBQUN4QjtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNGQUFzRixhQUFhO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWE7QUFDaEMsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxpQ0FBaUMsVUFBVSxFQUFFLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFlBQVk7QUFDL0Q7QUFDQTs7QUFFQSxxQ0FBcUMsV0FBVzs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsME9BQTBPLGNBQWMsb0JBQW9CLFFBQVEsS0FBSyxxQ0FBcUMsa0JBQWtCLEtBQUs7QUFDclY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxlQUFlLFNBQVM7QUFDeEIsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUMsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx3QkFBd0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRSxFQUFFLGNBQWMsRUFBRTs7QUFFdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlEQUFpRDtBQUNqRDs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHdEQUF3RDs7QUFFdkU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiLDhDQUE4Qzs7QUFFOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiLDhDQUE4Qzs7QUFFOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2QsK0NBQStDOztBQUUvQzs7QUFFQSw4Q0FBOEMsVUFBVTtBQUN4RCx5QkFBeUIsYUFBYSxRQUFRLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLG9EQUFvRDs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZUFBZTtBQUNmLElBQUk7QUFDSixlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0IsTUFBTSxrQkFBa0IsU0FBUztBQUN2RDs7QUFFQTtBQUNBLDhCQUE4QixXQUFXLFNBQVMsTUFBTTtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0IsTUFBTSxrQkFBa0IsU0FBUztBQUN2RDs7QUFFQTtBQUNBLDRDQUE0QyxNQUFNO0FBQ2xEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsV0FBVztBQUN0Qyx5QkFBeUIsTUFBTTtBQUMvQiw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQSxtR0FBbUc7O0FBRW5HO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsMEJBQTBCLDZCQUE2QjtBQUN4Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsR0FBRztBQUN6QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUU7O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLEVBQUU7QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixLQUFLLEtBQUs7QUFDdEMsb0NBQW9DLEtBQUssS0FBSztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBOztBQUVBOztBQUVBLDZCQUE2QjtBQUM3QixhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw4QkFBOEI7QUFDOUIsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDLEdBQUc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0VBQWdFO0FBQ3BGLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVMsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsMEVBQTBFO0FBQzdIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4RUFBOEUsdUJBQXVCLE9BQU8sVUFBVSxrQ0FBa0MsZUFBZSxnQkFBZ0IsZUFBZTs7QUFFdE07QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsMEVBQTBFO0FBQ3ZIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUdBQWlHOztBQUVqRztBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RCxPQUFPO0FBQ25FO0FBQ0E7O0FBRUEsd0RBQXdELE1BQU07O0FBRTlELGtCQUFrQixtSUFBbUksR0FBRyxrSEFBa0gsR0FBRyxrSEFBa0gsR0FBRyw2SEFBNkg7O0FBRS9mOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbURBQW1ELGNBQWM7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxzQkFBc0I7QUFDcEMsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQsY0FBYywrQkFBK0I7QUFDN0MsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCxvQ0FBb0M7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNFQUFzRTtBQUM5Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7O0FBRUE7O0FBRUEsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHdEQUF3RDtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0Msd0JBQXdCLHVCQUF1QjtBQUNuRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCLG1CQUFtQjs7QUFFM0U7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixTQUFTOztBQUVqQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDLHlJQUF5SSxxQkFBcUI7QUFDOUo7QUFDQTs7QUFFQTtBQUNBLDBGQUEwRixxQkFBcUI7QUFDL0c7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGlCQUFpQixLQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEtBQTBLLHFCQUFxQjtBQUMvTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsbUJBQW1CLDBCQUEwQjtBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLG1CQUFtQiwwQkFBMEI7QUFDN0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3SEFBd0gsd0JBQXdCO0FBQ2hKOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCxrQ0FBa0M7QUFDcEY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsMkJBQTJCO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFELGtCQUFrQjtBQUN2RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSkFBMEosZUFBZTtBQUN6SyxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxJQUFJO0FBQ0o7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMLGVBQWU7QUFDZixLQUFLO0FBQ0wsZUFBZTtBQUNmO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkZBQTZGLHFCQUFxQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxnQkFBZ0I7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVFQUF1RSxtQkFBbUI7QUFDMUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSyxpREFBaUQsbUJBQW1CO0FBQ3ZHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxvREFBb0Qsb0RBQW9EO0FBQ3hHLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZFQUE2RSxtQkFBbUI7O0FBRWhHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsV0FBVyxXQUFXOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxnREFBZ0QsNEJBQTRCO0FBQzVFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCO0FBQ3hCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJEQUEyRDtBQUN2Rzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLG9CQUFvQixpREFBaUQ7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxhQUFhLE1BQU07QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSiw4REFBOEQ7QUFDOUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUFnRDs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxlQUFlO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixpQkFBaUI7QUFDekMseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLDZCQUE2QixlQUFlOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVEQUF1RCxLQUFLLEtBQUs7QUFDakU7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTzs7QUFFWDtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BELGdEQUFnRDs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DLDRCQUE0Qjs7QUFFaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxVQUFVO0FBQ25FO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscVBBQXFQO0FBQ3JQLHlEQUF5RCxtQkFBbUI7QUFDNUU7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLFVBQVU7QUFDL0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRTtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzREFBc0QsMkJBQTJCOztBQUVqRjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUdBQXVHLHlCQUF5QjtBQUNoSTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EseUVBQXlFLHdCQUF3QjtBQUNqRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStELHVDQUF1QztBQUN0RztBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMscUJBQXFCOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosdURBQXVELEtBQUs7QUFDNUQ7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0EscUVBQXFFLGFBQWE7QUFDbEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlOztBQUU5QjtBQUNBLGFBQWEsNkRBQTZEOztBQUUxRTtBQUNBLGNBQWM7QUFDZCxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyw4QkFBOEI7QUFDekMsb0JBQW9CLDhCQUE4Qjs7QUFFbEQ7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixpQkFBaUIscUJBQXFCO0FBQ3RDLFdBQVcsZ0JBQWdCOztBQUUzQjtBQUNBLGFBQWEsdUJBQXVCOztBQUVwQztBQUNBLFNBQVMsYUFBYTtBQUN0QixXQUFXLDRCQUE0Qjs7QUFFdkM7QUFDQSxhQUFhLGlCQUFpQjs7QUFFOUI7QUFDQSxjQUFjLDBCQUEwQixFQUFFO0FBQzFDLGdCQUFnQiwwQkFBMEIsRUFBRTtBQUM1QyxnQkFBZ0IsMEJBQTBCLEVBQUU7QUFDNUMsWUFBWSx1Q0FBdUM7QUFDbkQsWUFBWSwwQkFBMEIsRUFBRTtBQUN4QyxtQkFBbUIsOENBQThDO0FBQ2pFLGNBQWMsMEJBQTBCLEVBQUU7QUFDMUMsaUJBQWlCLDBCQUEwQjtBQUMzQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRSYWN0aXZlLmpzIHYwLjcuM1xuXHRTYXQgQXByIDI1IDIwMTUgMTM6NTI6MzggR01ULTA0MDAgKEVEVCkgLSBjb21taXQgZGE0MGY4MWM2NjBiYTJmMDljNDVhMDlhOWMyMGZkZDM0ZWUzNmQ4MFxuXG5cdGh0dHA6Ly9yYWN0aXZlanMub3JnXG5cdGh0dHA6Ly90d2l0dGVyLmNvbS9SYWN0aXZlSlNcblxuXHRSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIGdsb2JhbC5SYWN0aXZlID0gZmFjdG9yeSgpXG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBURU1QTEFURV9WRVJTSU9OID0gMztcblxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cbiAgXHQvLyByZW5kZXIgcGxhY2VtZW50OlxuICBcdGVsOiB2b2lkIDAsXG4gIFx0YXBwZW5kOiBmYWxzZSxcblxuICBcdC8vIHRlbXBsYXRlOlxuICBcdHRlbXBsYXRlOiB7IHY6IFRFTVBMQVRFX1ZFUlNJT04sIHQ6IFtdIH0sXG5cbiAgXHQvLyBwYXJzZTogICAgIC8vIFRPRE8gc3RhdGljIGRlbGltaXRlcnM/XG4gIFx0cHJlc2VydmVXaGl0ZXNwYWNlOiBmYWxzZSxcbiAgXHRzYW5pdGl6ZTogZmFsc2UsXG4gIFx0c3RyaXBDb21tZW50czogdHJ1ZSxcbiAgXHRkZWxpbWl0ZXJzOiBbXCJ7e1wiLCBcIn19XCJdLFxuICBcdHRyaXBsZURlbGltaXRlcnM6IFtcInt7e1wiLCBcIn19fVwiXSxcbiAgXHRpbnRlcnBvbGF0ZTogZmFsc2UsXG5cbiAgXHQvLyBkYXRhICYgYmluZGluZzpcbiAgXHRkYXRhOiB7fSxcbiAgXHRjb21wdXRlZDoge30sXG4gIFx0bWFnaWM6IGZhbHNlLFxuICBcdG1vZGlmeUFycmF5czogdHJ1ZSxcbiAgXHRhZGFwdDogW10sXG4gIFx0aXNvbGF0ZWQ6IGZhbHNlLFxuICBcdHR3b3dheTogdHJ1ZSxcbiAgXHRsYXp5OiBmYWxzZSxcblxuICBcdC8vIHRyYW5zaXRpb25zOlxuICBcdG5vSW50cm86IGZhbHNlLFxuICBcdHRyYW5zaXRpb25zRW5hYmxlZDogdHJ1ZSxcbiAgXHRjb21wbGV0ZTogdm9pZCAwLFxuXG4gIFx0Ly8gY3NzOlxuICBcdGNzczogbnVsbCxcbiAgXHRub0Nzc1RyYW5zZm9ybTogZmFsc2VcbiAgfTtcblxuICB2YXIgY29uZmlnX2RlZmF1bHRzID0gZGVmYXVsdE9wdGlvbnM7XG5cbiAgLy8gVGhlc2UgYXJlIGEgc3Vic2V0IG9mIHRoZSBlYXNpbmcgZXF1YXRpb25zIGZvdW5kIGF0XG4gIC8vIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZGFucm8vZWFzaW5nLWpzIC0gbGljZW5zZSBpbmZvXG4gIC8vIGZvbGxvd3M6XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gZWFzaW5nLmpzIHYwLjUuNFxuICAvLyBHZW5lcmljIHNldCBvZiBlYXNpbmcgZnVuY3Rpb25zIHdpdGggQU1EIHN1cHBvcnRcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RhbnJvL2Vhc2luZy1qc1xuICAvLyBUaGlzIGNvZGUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAgLy8gaHR0cDovL2RhbnJvLm1pdC1saWNlbnNlLm9yZy9cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQWxsIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb20gVGhvbWFzIEZ1Y2hzICYgSmVyZW15IEthaG5cbiAgLy8gRWFzaW5nIEVxdWF0aW9ucyAoYykgMjAwMyBSb2JlcnQgUGVubmVyLCBCU0QgbGljZW5zZVxuICAvLyBodHRwczovL3Jhdy5naXRodWIuY29tL2RhbnJvL2Vhc2luZy1qcy9tYXN0ZXIvTElDRU5TRVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEluIHRoYXQgbGlicmFyeSwgdGhlIGZ1bmN0aW9ucyBuYW1lZCBlYXNlSW4sIGVhc2VPdXQsIGFuZFxuICAvLyBlYXNlSW5PdXQgYmVsb3cgYXJlIG5hbWVkIGVhc2VJbkN1YmljLCBlYXNlT3V0Q3ViaWMsIGFuZFxuICAvLyAoeW91IGd1ZXNzZWQgaXQpIGVhc2VJbk91dEN1YmljLlxuICAvL1xuICAvLyBZb3UgY2FuIGFkZCBhZGRpdGlvbmFsIGVhc2luZyBmdW5jdGlvbnMgdG8gdGhpcyBsaXN0LCBhbmQgdGhleVxuICAvLyB3aWxsIGJlIGdsb2JhbGx5IGF2YWlsYWJsZS5cblxuICB2YXIgc3RhdGljX2Vhc2luZyA9IHtcbiAgXHRsaW5lYXI6IGZ1bmN0aW9uIChwb3MpIHtcbiAgXHRcdHJldHVybiBwb3M7XG4gIFx0fSxcbiAgXHRlYXNlSW46IGZ1bmN0aW9uIChwb3MpIHtcbiAgXHRcdHJldHVybiBNYXRoLnBvdyhwb3MsIDMpO1xuICBcdH0sXG4gIFx0ZWFzZU91dDogZnVuY3Rpb24gKHBvcykge1xuICBcdFx0cmV0dXJuIE1hdGgucG93KHBvcyAtIDEsIDMpICsgMTtcbiAgXHR9LFxuICBcdGVhc2VJbk91dDogZnVuY3Rpb24gKHBvcykge1xuICBcdFx0aWYgKChwb3MgLz0gMC41KSA8IDEpIHtcbiAgXHRcdFx0cmV0dXJuIDAuNSAqIE1hdGgucG93KHBvcywgMyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gMC41ICogKE1hdGgucG93KHBvcyAtIDIsIDMpICsgMik7XG4gIFx0fVxuICB9O1xuXG4gIC8qZ2xvYmFsIGNvbnNvbGUsIG5hdmlnYXRvciAqL1xuICB2YXIgaXNDbGllbnQsIGlzSnNkb20sIGhhc0NvbnNvbGUsIGVudmlyb25tZW50X19tYWdpYywgbmFtZXNwYWNlcywgc3ZnLCB2ZW5kb3JzO1xuXG4gIGlzQ2xpZW50ID0gdHlwZW9mIGRvY3VtZW50ID09PSBcIm9iamVjdFwiO1xuXG4gIGlzSnNkb20gPSB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIC9qc0RvbS8udGVzdChuYXZpZ2F0b3IuYXBwTmFtZSk7XG5cbiAgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgY29uc29sZS53YXJuLmFwcGx5ID09PSBcImZ1bmN0aW9uXCI7XG5cbiAgdHJ5IHtcbiAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwidGVzdFwiLCB7IHZhbHVlOiAwIH0pO1xuICBcdGVudmlyb25tZW50X19tYWdpYyA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgXHRlbnZpcm9ubWVudF9fbWFnaWMgPSBmYWxzZTtcbiAgfVxuXG4gIG5hbWVzcGFjZXMgPSB7XG4gIFx0aHRtbDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsXG4gIFx0bWF0aG1sOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIixcbiAgXHRzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgXHR4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gIFx0eG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICBcdHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbiAgfTtcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIFx0c3ZnID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gIFx0c3ZnID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcImh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmVcIiwgXCIxLjFcIik7XG4gIH1cblxuICB2ZW5kb3JzID0gW1wib1wiLCBcIm1zXCIsIFwibW96XCIsIFwid2Via2l0XCJdO1xuXG4gIHZhciBjcmVhdGVFbGVtZW50LCBtYXRjaGVzLCBkb21fX2RpdiwgbWV0aG9kTmFtZXMsIHVucHJlZml4ZWQsIHByZWZpeGVkLCBkb21fX2ksIGosIG1ha2VGdW5jdGlvbjtcblxuICAvLyBUZXN0IGZvciBTVkcgc3VwcG9ydFxuICBpZiAoIXN2Zykge1xuICBcdGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgbnMpIHtcbiAgXHRcdGlmIChucyAmJiBucyAhPT0gbmFtZXNwYWNlcy5odG1sKSB7XG4gIFx0XHRcdHRocm93IFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbmFtZXNwYWNlcyBvdGhlciB0aGFuIGh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwuIFRoZSBtb3N0IGxpa2VseSBjYXVzZSBvZiB0aGlzIGVycm9yIGlzIHRoYXQgeW91J3JlIHRyeWluZyB0byByZW5kZXIgU1ZHIGluIGFuIG9sZGVyIGJyb3dzZXIuIFNlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9zdmctYW5kLW9sZGVyLWJyb3dzZXJzIGZvciBtb3JlIGluZm9ybWF0aW9uXCI7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICBcdH07XG4gIH0gZWxzZSB7XG4gIFx0Y3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBucykge1xuICBcdFx0aWYgKCFucyB8fCBucyA9PT0gbmFtZXNwYWNlcy5odG1sKSB7XG4gIFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0eXBlKTtcbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudChpbnB1dCkge1xuICBcdHZhciBvdXRwdXQ7XG5cbiAgXHRpZiAoIWlucHV0IHx8IHR5cGVvZiBpbnB1dCA9PT0gXCJib29sZWFuXCIpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhZG9jdW1lbnQgfHwgIWlucHV0KSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBXZSBhbHJlYWR5IGhhdmUgYSBET00gbm9kZSAtIG5vIHdvcmsgdG8gZG8uIChEdWNrIHR5cGluZyBhbGVydCEpXG4gIFx0aWYgKGlucHV0Lm5vZGVUeXBlKSB7XG4gIFx0XHRyZXR1cm4gaW5wdXQ7XG4gIFx0fVxuXG4gIFx0Ly8gR2V0IG5vZGUgZnJvbSBzdHJpbmdcbiAgXHRpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHQvLyB0cnkgSUQgZmlyc3RcbiAgXHRcdG91dHB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlucHV0KTtcblxuICBcdFx0Ly8gdGhlbiBhcyBzZWxlY3RvciwgaWYgcG9zc2libGVcbiAgXHRcdGlmICghb3V0cHV0ICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IpIHtcbiAgXHRcdFx0b3V0cHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihpbnB1dCk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGRpZCBpdCB3b3JrP1xuICBcdFx0aWYgKG91dHB1dCAmJiBvdXRwdXQubm9kZVR5cGUpIHtcbiAgXHRcdFx0cmV0dXJuIG91dHB1dDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBJZiB3ZSd2ZSBiZWVuIGdpdmVuIGEgY29sbGVjdGlvbiAoalF1ZXJ5LCBaZXB0byBldGMpLCBleHRyYWN0IHRoZSBmaXJzdCBpdGVtXG4gIFx0aWYgKGlucHV0WzBdICYmIGlucHV0WzBdLm5vZGVUeXBlKSB7XG4gIFx0XHRyZXR1cm4gaW5wdXRbMF07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIWlzQ2xpZW50KSB7XG4gIFx0bWF0Y2hlcyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gIFx0ZG9tX19kaXYgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBcdG1ldGhvZE5hbWVzID0gW1wibWF0Y2hlc1wiLCBcIm1hdGNoZXNTZWxlY3RvclwiXTtcblxuICBcdG1ha2VGdW5jdGlvbiA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKG5vZGUsIHNlbGVjdG9yKSB7XG4gIFx0XHRcdHJldHVybiBub2RlW21ldGhvZE5hbWVdKHNlbGVjdG9yKTtcbiAgXHRcdH07XG4gIFx0fTtcblxuICBcdGRvbV9faSA9IG1ldGhvZE5hbWVzLmxlbmd0aDtcblxuICBcdHdoaWxlIChkb21fX2ktLSAmJiAhbWF0Y2hlcykge1xuICBcdFx0dW5wcmVmaXhlZCA9IG1ldGhvZE5hbWVzW2RvbV9faV07XG5cbiAgXHRcdGlmIChkb21fX2Rpdlt1bnByZWZpeGVkXSkge1xuICBcdFx0XHRtYXRjaGVzID0gbWFrZUZ1bmN0aW9uKHVucHJlZml4ZWQpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0aiA9IHZlbmRvcnMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoai0tKSB7XG4gIFx0XHRcdFx0cHJlZml4ZWQgPSB2ZW5kb3JzW2RvbV9faV0gKyB1bnByZWZpeGVkLnN1YnN0cigwLCAxKS50b1VwcGVyQ2FzZSgpICsgdW5wcmVmaXhlZC5zdWJzdHJpbmcoMSk7XG5cbiAgXHRcdFx0XHRpZiAoZG9tX19kaXZbcHJlZml4ZWRdKSB7XG4gIFx0XHRcdFx0XHRtYXRjaGVzID0gbWFrZUZ1bmN0aW9uKHByZWZpeGVkKTtcbiAgXHRcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIElFOC4uLlxuICBcdGlmICghbWF0Y2hlcykge1xuICBcdFx0bWF0Y2hlcyA9IGZ1bmN0aW9uIChub2RlLCBzZWxlY3Rvcikge1xuICBcdFx0XHR2YXIgbm9kZXMsIHBhcmVudE5vZGUsIGk7XG5cbiAgXHRcdFx0cGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblxuICBcdFx0XHRpZiAoIXBhcmVudE5vZGUpIHtcbiAgXHRcdFx0XHQvLyBlbXB0eSBkdW1teSA8ZGl2PlxuICBcdFx0XHRcdGRvbV9fZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cbiAgXHRcdFx0XHRwYXJlbnROb2RlID0gZG9tX19kaXY7XG4gIFx0XHRcdFx0bm9kZSA9IG5vZGUuY2xvbmVOb2RlKCk7XG5cbiAgXHRcdFx0XHRkb21fX2Rpdi5hcHBlbmRDaGlsZChub2RlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdG5vZGVzID0gcGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICBcdFx0XHRpID0gbm9kZXMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0aWYgKG5vZGVzW2ldID09PSBub2RlKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9O1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRldGFjaE5vZGUobm9kZSkge1xuICBcdGlmIChub2RlICYmIHR5cGVvZiBub2RlLnBhcmVudE5vZGUgIT09IFwidW5rbm93blwiICYmIG5vZGUucGFyZW50Tm9kZSkge1xuICBcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICBcdH1cblxuICBcdHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2FmZVRvU3RyaW5nVmFsdWUodmFsdWUpIHtcbiAgXHRyZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCAhdmFsdWUudG9TdHJpbmcgPyBcIlwiIDogdmFsdWU7XG4gIH1cblxuICB2YXIgbGVnYWN5ID0gbnVsbDtcblxuICB2YXIgY3JlYXRlLCBkZWZpbmVQcm9wZXJ0eSwgZGVmaW5lUHJvcGVydGllcztcblxuICB0cnkge1xuICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJ0ZXN0XCIsIHsgdmFsdWU6IDAgfSk7XG5cbiAgXHRpZiAoaXNDbGllbnQpIHtcbiAgXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBcInRlc3RcIiwgeyB2YWx1ZTogMCB9KTtcbiAgXHR9XG5cbiAgXHRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIFx0Ly8gT2JqZWN0LmRlZmluZVByb3BlcnR5IGRvZXNuJ3QgZXhpc3QsIG9yIHdlJ3JlIGluIElFOCB3aGVyZSB5b3UgY2FuXG4gIFx0Ly8gb25seSB1c2UgaXQgd2l0aCBET00gb2JqZWN0cyAod2hhdCB3ZXJlIHlvdSBzbW9raW5nLCBNU0ZUPylcbiAgXHRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIGRlc2MpIHtcbiAgXHRcdG9ialtwcm9wXSA9IGRlc2MudmFsdWU7XG4gIFx0fTtcbiAgfVxuXG4gIHRyeSB7XG4gIFx0dHJ5IHtcbiAgXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHt9LCB7IHRlc3Q6IHsgdmFsdWU6IDAgfSB9KTtcbiAgXHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdC8vIFRPRE8gaG93IGRvIHdlIGFjY291bnQgZm9yIHRoaXM/IG5vTWFnaWMgPSB0cnVlO1xuICBcdFx0dGhyb3cgZXJyO1xuICBcdH1cblxuICBcdGlmIChpc0NsaWVudCkge1xuICBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY3JlYXRlRWxlbWVudChcImRpdlwiKSwgeyB0ZXN0OiB7IHZhbHVlOiAwIH0gfSk7XG4gIFx0fVxuXG4gIFx0ZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgXHRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaiwgcHJvcHMpIHtcbiAgXHRcdHZhciBwcm9wO1xuXG4gIFx0XHRmb3IgKHByb3AgaW4gcHJvcHMpIHtcbiAgXHRcdFx0aWYgKHByb3BzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gIFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBwcm9wc1twcm9wXSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgdHJ5IHtcbiAgXHRPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIFx0Y3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIFx0Ly8gc2lnaFxuICBcdGNyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgRiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvLCBwcm9wcykge1xuICBcdFx0XHR2YXIgb2JqO1xuXG4gIFx0XHRcdGlmIChwcm90byA9PT0gbnVsbCkge1xuICBcdFx0XHRcdHJldHVybiB7fTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdEYucHJvdG90eXBlID0gcHJvdG87XG4gIFx0XHRcdG9iaiA9IG5ldyBGKCk7XG5cbiAgXHRcdFx0aWYgKHByb3BzKSB7XG4gIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqLCBwcm9wcyk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gb2JqO1xuICBcdFx0fTtcbiAgXHR9KSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXRpbHNfb2JqZWN0X19leHRlbmQodGFyZ2V0KSB7XG4gIFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRzb3VyY2VzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHR9XG5cbiAgXHR2YXIgcHJvcCwgc291cmNlO1xuXG4gIFx0d2hpbGUgKHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKSkge1xuICBcdFx0Zm9yIChwcm9wIGluIHNvdXJjZSkge1xuICBcdFx0XHRpZiAoaGFzT3duLmNhbGwoc291cmNlLCBwcm9wKSkge1xuICBcdFx0XHRcdHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxsR2Fwcyh0YXJnZXQpIHtcbiAgXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdHNvdXJjZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICBcdFx0Zm9yICh2YXIga2V5IGluIHMpIHtcbiAgXHRcdFx0aWYgKHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gIFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBzW2tleV07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyB0aGFua3MsIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2luc3RhbmNlb2YtY29uc2lkZXJlZC1oYXJtZnVsLW9yLWhvdy10by13cml0ZS1hLXJvYnVzdC1pc2FycmF5L1xuICB2YXIgaXNfX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgIGFycmF5TGlrZVBhdHRlcm4gPSAvXlxcW29iamVjdCAoPzpBcnJheXxGaWxlTGlzdClcXF0kLztcbiAgZnVuY3Rpb24gaXNBcnJheSh0aGluZykge1xuICBcdHJldHVybiBpc19fdG9TdHJpbmcuY2FsbCh0aGluZykgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKG9iaikge1xuICBcdHJldHVybiBhcnJheUxpa2VQYXR0ZXJuLnRlc3QoaXNfX3RvU3RyaW5nLmNhbGwob2JqKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgXHRpZiAoYSA9PT0gbnVsbCAmJiBiID09PSBudWxsKSB7XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIGEgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGIgPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYSA9PT0gYjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzX19pc051bWVyaWModGhpbmcpIHtcbiAgXHRyZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQodGhpbmcpKSAmJiBpc0Zpbml0ZSh0aGluZyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc09iamVjdCh0aGluZykge1xuICBcdHJldHVybiB0aGluZyAmJiBpc19fdG9TdHJpbmcuY2FsbCh0aGluZykgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gIH1cblxuICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIC8qIGdsb2JhbCBjb25zb2xlICovXG4gIHZhciBhbHJlYWR5V2FybmVkID0ge30sXG4gICAgICBsb2csXG4gICAgICBwcmludFdhcm5pbmcsXG4gICAgICB3ZWxjb21lO1xuXG4gIGlmIChoYXNDb25zb2xlKSB7XG4gIFx0KGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB3ZWxjb21lSW50cm8gPSBbXCIlY1JhY3RpdmUuanMgJWMwLjcuMyAlY2luIGRlYnVnIG1vZGUsICVjbW9yZS4uLlwiLCBcImNvbG9yOiByZ2IoMTE0LCAxNTcsIDUyKTsgZm9udC13ZWlnaHQ6IG5vcm1hbDtcIiwgXCJjb2xvcjogcmdiKDg1LCA4NSwgODUpOyBmb250LXdlaWdodDogbm9ybWFsO1wiLCBcImNvbG9yOiByZ2IoODUsIDg1LCA4NSk7IGZvbnQtd2VpZ2h0OiBub3JtYWw7XCIsIFwiY29sb3I6IHJnYig4MiwgMTQwLCAyMjQpOyBmb250LXdlaWdodDogbm9ybWFsOyB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcIl07XG4gIFx0XHR2YXIgd2VsY29tZU1lc3NhZ2UgPSBcIllvdSdyZSBydW5uaW5nIFJhY3RpdmUgMC43LjMgaW4gZGVidWcgbW9kZSAtIG1lc3NhZ2VzIHdpbGwgYmUgcHJpbnRlZCB0byB0aGUgY29uc29sZSB0byBoZWxwIHlvdSBmaXggcHJvYmxlbXMgYW5kIG9wdGltaXNlIHlvdXIgYXBwbGljYXRpb24uXFxuXFxuVG8gZGlzYWJsZSBkZWJ1ZyBtb2RlLCBhZGQgdGhpcyBsaW5lIGF0IHRoZSBzdGFydCBvZiB5b3VyIGFwcDpcXG4gIFJhY3RpdmUuREVCVUcgPSBmYWxzZTtcXG5cXG5UbyBkaXNhYmxlIGRlYnVnIG1vZGUgd2hlbiB5b3VyIGFwcCBpcyBtaW5pZmllZCwgYWRkIHRoaXMgc25pcHBldDpcXG4gIFJhY3RpdmUuREVCVUcgPSAvdW5taW5pZmllZC8udGVzdChmdW5jdGlvbigpey8qdW5taW5pZmllZCovfSk7XFxuXFxuR2V0IGhlbHAgYW5kIHN1cHBvcnQ6XFxuICBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnXFxuICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zL3RhZ2dlZC9yYWN0aXZlanNcXG4gIGh0dHA6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIWZvcnVtL3JhY3RpdmUtanNcXG4gIGh0dHA6Ly90d2l0dGVyLmNvbS9yYWN0aXZlanNcXG5cXG5Gb3VuZCBhIGJ1Zz8gUmFpc2UgYW4gaXNzdWU6XFxuICBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzXFxuXFxuXCI7XG5cbiAgXHRcdHdlbGNvbWUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHZhciBoYXNHcm91cCA9ICEhY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgXHRcdFx0Y29uc29sZVtoYXNHcm91cCA/IFwiZ3JvdXBDb2xsYXBzZWRcIiA6IFwibG9nXCJdLmFwcGx5KGNvbnNvbGUsIHdlbGNvbWVJbnRybyk7XG4gIFx0XHRcdGNvbnNvbGUubG9nKHdlbGNvbWVNZXNzYWdlKTtcbiAgXHRcdFx0aWYgKGhhc0dyb3VwKSB7XG4gIFx0XHRcdFx0Y29uc29sZS5ncm91cEVuZCh3ZWxjb21lSW50cm8pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0d2VsY29tZSA9IG5vb3A7XG4gIFx0XHR9O1xuXG4gIFx0XHRwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAobWVzc2FnZSwgYXJncykge1xuICBcdFx0XHR3ZWxjb21lKCk7XG5cbiAgXHRcdFx0Ly8gZXh0cmFjdCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5zdGFuY2UgdGhpcyBtZXNzYWdlIHBlcnRhaW5zIHRvLCBpZiBhcHBsaWNhYmxlXG4gIFx0XHRcdGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRcdFx0dmFyIG9wdGlvbnMgPSBhcmdzLnBvcCgpO1xuICBcdFx0XHRcdHZhciByYWN0aXZlID0gb3B0aW9ucyA/IG9wdGlvbnMucmFjdGl2ZSA6IG51bGw7XG5cbiAgXHRcdFx0XHRpZiAocmFjdGl2ZSkge1xuICBcdFx0XHRcdFx0Ly8gaWYgdGhpcyBpcyBhbiBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCB0aGF0IHdlIGtub3cgdGhlIG5hbWUgb2YsIGFkZFxuICBcdFx0XHRcdFx0Ly8gaXQgdG8gdGhlIG1lc3NhZ2VcbiAgXHRcdFx0XHRcdHZhciBfbmFtZSA9IHVuZGVmaW5lZDtcbiAgXHRcdFx0XHRcdGlmIChyYWN0aXZlLmNvbXBvbmVudCAmJiAoX25hbWUgPSByYWN0aXZlLmNvbXBvbmVudC5uYW1lKSkge1xuICBcdFx0XHRcdFx0XHRtZXNzYWdlID0gXCI8XCIgKyBfbmFtZSArIFwiPiBcIiArIG1lc3NhZ2U7XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdHZhciBub2RlID0gdW5kZWZpbmVkO1xuICBcdFx0XHRcdFx0aWYgKG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgcmFjdGl2ZS5mcmFnbWVudCAmJiByYWN0aXZlLmZyYWdtZW50LnJlbmRlcmVkICYmIHJhY3RpdmUuZmluZChcIipcIikpIHtcbiAgXHRcdFx0XHRcdFx0YXJncy5wdXNoKG5vZGUpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBbXCIlY1JhY3RpdmUuanM6ICVjXCIgKyBtZXNzYWdlLCBcImNvbG9yOiByZ2IoMTE0LCAxNTcsIDUyKTtcIiwgXCJjb2xvcjogcmdiKDg1LCA4NSwgODUpO1wiXS5jb25jYXQoYXJncykpO1xuICBcdFx0fTtcblxuICBcdFx0bG9nID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHRjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICBcdFx0fTtcbiAgXHR9KSgpO1xuICB9IGVsc2Uge1xuICBcdHByaW50V2FybmluZyA9IGxvZyA9IHdlbGNvbWUgPSBub29wO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpIHtcbiAgXHRyZXR1cm4gbWVzc2FnZS5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gYXJncy5zaGlmdCgpO1xuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZmF0YWwobWVzc2FnZSkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0YXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0fVxuXG4gIFx0bWVzc2FnZSA9IGZvcm1hdChtZXNzYWdlLCBhcmdzKTtcbiAgXHR0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cblxuICBmdW5jdGlvbiBsb2dJZkRlYnVnKCkge1xuICBcdGlmIChfUmFjdGl2ZS5ERUJVRykge1xuICBcdFx0bG9nLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XG4gIFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHR9XG5cbiAgXHRtZXNzYWdlID0gZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpO1xuICBcdHByaW50V2FybmluZyhtZXNzYWdlLCBhcmdzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlKG1lc3NhZ2UpIHtcbiAgXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdG1lc3NhZ2UgPSBmb3JtYXQobWVzc2FnZSwgYXJncyk7XG5cbiAgXHRpZiAoYWxyZWFkeVdhcm5lZFttZXNzYWdlXSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGFscmVhZHlXYXJuZWRbbWVzc2FnZV0gPSB0cnVlO1xuICBcdHByaW50V2FybmluZyhtZXNzYWdlLCBhcmdzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm5JZkRlYnVnKCkge1xuICBcdGlmIChfUmFjdGl2ZS5ERUJVRykge1xuICBcdFx0d2Fybi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlSWZEZWJ1ZygpIHtcbiAgXHRpZiAoX1JhY3RpdmUuREVCVUcpIHtcbiAgXHRcdHdhcm5PbmNlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIFx0fVxuICB9XG5cbiAgLy8gRXJyb3IgbWVzc2FnZXMgdGhhdCBhcmUgdXNlZCAob3IgY291bGQgYmUpIGluIG11bHRpcGxlIHBsYWNlc1xuICB2YXIgYmFkQXJndW1lbnRzID0gXCJCYWQgYXJndW1lbnRzXCI7XG4gIHZhciBub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm4gPSBcIkEgZnVuY3Rpb24gd2FzIHNwZWNpZmllZCBmb3IgXFxcIiVzXFxcIiAlcywgYnV0IG5vICVzIHdhcyByZXR1cm5lZFwiO1xuICB2YXIgbWlzc2luZ1BsdWdpbiA9IGZ1bmN0aW9uIChuYW1lLCB0eXBlKSB7XG4gICAgcmV0dXJuIFwiTWlzc2luZyBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIFwiICsgdHlwZSArIFwiIHBsdWdpbi4gWW91IG1heSBuZWVkIHRvIGRvd25sb2FkIGEgcGx1Z2luIHZpYSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9wbHVnaW5zI1wiICsgdHlwZSArIFwic1wiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZpbmRJblZpZXdIaWVyYXJjaHkocmVnaXN0cnlOYW1lLCByYWN0aXZlLCBuYW1lKSB7XG4gIFx0dmFyIGluc3RhbmNlID0gZmluZEluc3RhbmNlKHJlZ2lzdHJ5TmFtZSwgcmFjdGl2ZSwgbmFtZSk7XG4gIFx0cmV0dXJuIGluc3RhbmNlID8gaW5zdGFuY2VbcmVnaXN0cnlOYW1lXVtuYW1lXSA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSW5zdGFuY2UocmVnaXN0cnlOYW1lLCByYWN0aXZlLCBuYW1lKSB7XG4gIFx0d2hpbGUgKHJhY3RpdmUpIHtcbiAgXHRcdGlmIChuYW1lIGluIHJhY3RpdmVbcmVnaXN0cnlOYW1lXSkge1xuICBcdFx0XHRyZXR1cm4gcmFjdGl2ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHJhY3RpdmUuaXNvbGF0ZWQpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJhY3RpdmUgPSByYWN0aXZlLnBhcmVudDtcbiAgXHR9XG4gIH1cblxuICB2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHJhY3RpdmUsIHR5cGUpIHtcbiAgXHRpZiAoZnJvbSA9PT0gdG8pIHtcbiAgXHRcdHJldHVybiBzbmFwKHRvKTtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZSkge1xuXG4gIFx0XHR2YXIgaW50ZXJwb2wgPSBmaW5kSW5WaWV3SGllcmFyY2h5KFwiaW50ZXJwb2xhdG9yc1wiLCByYWN0aXZlLCB0eXBlKTtcbiAgXHRcdGlmIChpbnRlcnBvbCkge1xuICBcdFx0XHRyZXR1cm4gaW50ZXJwb2woZnJvbSwgdG8pIHx8IHNuYXAodG8pO1xuICBcdFx0fVxuXG4gIFx0XHRmYXRhbChtaXNzaW5nUGx1Z2luKHR5cGUsIFwiaW50ZXJwb2xhdG9yXCIpKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3RhdGljX2ludGVycG9sYXRvcnMubnVtYmVyKGZyb20sIHRvKSB8fCBzdGF0aWNfaW50ZXJwb2xhdG9ycy5hcnJheShmcm9tLCB0bykgfHwgc3RhdGljX2ludGVycG9sYXRvcnMub2JqZWN0KGZyb20sIHRvKSB8fCBzbmFwKHRvKTtcbiAgfTtcblxuICB2YXIgc2hhcmVkX2ludGVycG9sYXRlID0gaW50ZXJwb2xhdGU7XG5cbiAgZnVuY3Rpb24gc25hcCh0bykge1xuICBcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdG87XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBpbnRlcnBvbGF0b3JzID0ge1xuICBcdG51bWJlcjogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIFx0XHR2YXIgZGVsdGE7XG5cbiAgXHRcdGlmICghaXNfX2lzTnVtZXJpYyhmcm9tKSB8fCAhaXNfX2lzTnVtZXJpYyh0bykpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdGZyb20gPSArZnJvbTtcbiAgXHRcdHRvID0gK3RvO1xuXG4gIFx0XHRkZWx0YSA9IHRvIC0gZnJvbTtcblxuICBcdFx0aWYgKCFkZWx0YSkge1xuICBcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHJldHVybiBmcm9tO1xuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0cmV0dXJuIGZyb20gKyB0ICogZGVsdGE7XG4gIFx0XHR9O1xuICBcdH0sXG5cbiAgXHRhcnJheTogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIFx0XHR2YXIgaW50ZXJtZWRpYXRlLCBpbnRlcnBvbGF0b3JzLCBsZW4sIGk7XG5cbiAgXHRcdGlmICghaXNBcnJheShmcm9tKSB8fCAhaXNBcnJheSh0bykpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdGludGVybWVkaWF0ZSA9IFtdO1xuICBcdFx0aW50ZXJwb2xhdG9ycyA9IFtdO1xuXG4gIFx0XHRpID0gbGVuID0gTWF0aC5taW4oZnJvbS5sZW5ndGgsIHRvLmxlbmd0aCk7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGludGVycG9sYXRvcnNbaV0gPSBzaGFyZWRfaW50ZXJwb2xhdGUoZnJvbVtpXSwgdG9baV0pO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzdXJwbHVzIHZhbHVlcyAtIGRvbid0IGludGVycG9sYXRlLCBidXQgZG9uJ3QgZXhjbHVkZSB0aGVtIGVpdGhlclxuICBcdFx0Zm9yIChpID0gbGVuOyBpIDwgZnJvbS5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0XHRpbnRlcm1lZGlhdGVbaV0gPSBmcm9tW2ldO1xuICBcdFx0fVxuXG4gIFx0XHRmb3IgKGkgPSBsZW47IGkgPCB0by5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0XHRpbnRlcm1lZGlhdGVbaV0gPSB0b1tpXTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdHZhciBpID0gbGVuO1xuXG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRpbnRlcm1lZGlhdGVbaV0gPSBpbnRlcnBvbGF0b3JzW2ldKHQpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIGludGVybWVkaWF0ZTtcbiAgXHRcdH07XG4gIFx0fSxcblxuICBcdG9iamVjdDogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIFx0XHR2YXIgcHJvcGVydGllcywgbGVuLCBpbnRlcnBvbGF0b3JzLCBpbnRlcm1lZGlhdGUsIHByb3A7XG5cbiAgXHRcdGlmICghaXNPYmplY3QoZnJvbSkgfHwgIWlzT2JqZWN0KHRvKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cHJvcGVydGllcyA9IFtdO1xuICBcdFx0aW50ZXJtZWRpYXRlID0ge307XG4gIFx0XHRpbnRlcnBvbGF0b3JzID0ge307XG5cbiAgXHRcdGZvciAocHJvcCBpbiBmcm9tKSB7XG4gIFx0XHRcdGlmIChoYXNPd24uY2FsbChmcm9tLCBwcm9wKSkge1xuICBcdFx0XHRcdGlmIChoYXNPd24uY2FsbCh0bywgcHJvcCkpIHtcbiAgXHRcdFx0XHRcdHByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgXHRcdFx0XHRcdGludGVycG9sYXRvcnNbcHJvcF0gPSBzaGFyZWRfaW50ZXJwb2xhdGUoZnJvbVtwcm9wXSwgdG9bcHJvcF0pO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbcHJvcF0gPSBmcm9tW3Byb3BdO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRmb3IgKHByb3AgaW4gdG8pIHtcbiAgXHRcdFx0aWYgKGhhc093bi5jYWxsKHRvLCBwcm9wKSAmJiAhaGFzT3duLmNhbGwoZnJvbSwgcHJvcCkpIHtcbiAgXHRcdFx0XHRpbnRlcm1lZGlhdGVbcHJvcF0gPSB0b1twcm9wXTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRsZW4gPSBwcm9wZXJ0aWVzLmxlbmd0aDtcblxuICBcdFx0cmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdHZhciBpID0gbGVuLFxuICBcdFx0XHQgICAgcHJvcDtcblxuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0cHJvcCA9IHByb3BlcnRpZXNbaV07XG5cbiAgXHRcdFx0XHRpbnRlcm1lZGlhdGVbcHJvcF0gPSBpbnRlcnBvbGF0b3JzW3Byb3BdKHQpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIGludGVybWVkaWF0ZTtcbiAgXHRcdH07XG4gIFx0fVxuICB9O1xuXG4gIHZhciBzdGF0aWNfaW50ZXJwb2xhdG9ycyA9IGludGVycG9sYXRvcnM7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIGtleXBhdGggc3VjaCBhcyAnZm9vLmJhci5iYXonLCBhbmQgcmV0dXJuc1xuICAvLyBhbGwgdGhlIHZhcmlhbnRzIG9mIHRoYXQga2V5cGF0aCB0aGF0IGluY2x1ZGUgYSB3aWxkY2FyZCBpbiBwbGFjZVxuICAvLyBvZiBhIGtleSwgc3VjaCBhcyAnZm9vLmJhci4qJywgJ2Zvby4qLmJheicsICdmb28uKi4qJyBhbmQgc28gb24uXG4gIC8vIFRoZXNlIGFyZSB0aGVuIGNoZWNrZWQgYWdhaW5zdCB0aGUgZGVwZW5kYW50cyBtYXAgKHJhY3RpdmUudmlld21vZGVsLmRlcHNNYXApXG4gIC8vIHRvIHNlZSBpZiBhbnkgcGF0dGVybiBvYnNlcnZlcnMgYXJlIGRvd25zdHJlYW0gb2Ygb25lIG9yIG1vcmUgb2ZcbiAgLy8gdGhlc2Ugd2lsZGNhcmQga2V5cGF0aHMgKGUuZy4gJ2Zvby5iYXIuKi5zdGF0dXMnKVxuICB2YXIgdXRpbHNfZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzID0gZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzO1xuXG4gIHZhciBzdGFyTWFwcyA9IHt9O1xuICBmdW5jdGlvbiBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMoa2V5cGF0aCkge1xuICBcdHZhciBrZXlzLCBzdGFyTWFwLCBtYXBwZXIsIGksIHJlc3VsdCwgd2lsZGNhcmRLZXlwYXRoO1xuXG4gIFx0a2V5cyA9IGtleXBhdGguc3BsaXQoXCIuXCIpO1xuICBcdGlmICghKHN0YXJNYXAgPSBzdGFyTWFwc1trZXlzLmxlbmd0aF0pKSB7XG4gIFx0XHRzdGFyTWFwID0gZ2V0U3Rhck1hcChrZXlzLmxlbmd0aCk7XG4gIFx0fVxuXG4gIFx0cmVzdWx0ID0gW107XG5cbiAgXHRtYXBwZXIgPSBmdW5jdGlvbiAoc3RhciwgaSkge1xuICBcdFx0cmV0dXJuIHN0YXIgPyBcIipcIiA6IGtleXNbaV07XG4gIFx0fTtcblxuICBcdGkgPSBzdGFyTWFwLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHR3aWxkY2FyZEtleXBhdGggPSBzdGFyTWFwW2ldLm1hcChtYXBwZXIpLmpvaW4oXCIuXCIpO1xuXG4gIFx0XHRpZiAoIXJlc3VsdC5oYXNPd25Qcm9wZXJ0eSh3aWxkY2FyZEtleXBhdGgpKSB7XG4gIFx0XHRcdHJlc3VsdC5wdXNoKHdpbGRjYXJkS2V5cGF0aCk7XG4gIFx0XHRcdHJlc3VsdFt3aWxkY2FyZEtleXBhdGhdID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFsbCB0aGUgcG9zc2libGUgdHJ1ZS9mYWxzZSBjb21iaW5hdGlvbnMgZm9yXG4gIC8vIGEgZ2l2ZW4gbnVtYmVyIC0gZS5nLiBmb3IgdHdvLCB0aGUgcG9zc2libGUgY29tYmluYXRpb25zIGFyZVxuICAvLyBbIHRydWUsIHRydWUgXSwgWyB0cnVlLCBmYWxzZSBdLCBbIGZhbHNlLCB0cnVlIF0sIFsgZmFsc2UsIGZhbHNlIF0uXG4gIC8vIEl0IGRvZXMgc28gYnkgZ2V0dGluZyBhbGwgdGhlIGJpbmFyeSB2YWx1ZXMgYmV0d2VlbiAwIGFuZCBlLmcuIDExXG4gIGZ1bmN0aW9uIGdldFN0YXJNYXAobnVtKSB7XG4gIFx0dmFyIG9uZXMgPSBcIlwiLFxuICBcdCAgICBtYXgsXG4gIFx0ICAgIGJpbmFyeSxcbiAgXHQgICAgc3Rhck1hcCxcbiAgXHQgICAgbWFwcGVyLFxuICBcdCAgICBpLFxuICBcdCAgICBqLFxuICBcdCAgICBsLFxuICBcdCAgICBtYXA7XG5cbiAgXHRpZiAoIXN0YXJNYXBzW251bV0pIHtcbiAgXHRcdHN0YXJNYXAgPSBbXTtcblxuICBcdFx0d2hpbGUgKG9uZXMubGVuZ3RoIDwgbnVtKSB7XG4gIFx0XHRcdG9uZXMgKz0gMTtcbiAgXHRcdH1cblxuICBcdFx0bWF4ID0gcGFyc2VJbnQob25lcywgMik7XG5cbiAgXHRcdG1hcHBlciA9IGZ1bmN0aW9uIChkaWdpdCkge1xuICBcdFx0XHRyZXR1cm4gZGlnaXQgPT09IFwiMVwiO1xuICBcdFx0fTtcblxuICBcdFx0Zm9yIChpID0gMDsgaSA8PSBtYXg7IGkgKz0gMSkge1xuICBcdFx0XHRiaW5hcnkgPSBpLnRvU3RyaW5nKDIpO1xuICBcdFx0XHR3aGlsZSAoYmluYXJ5Lmxlbmd0aCA8IG51bSkge1xuICBcdFx0XHRcdGJpbmFyeSA9IFwiMFwiICsgYmluYXJ5O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0bWFwID0gW107XG4gIFx0XHRcdGwgPSBiaW5hcnkubGVuZ3RoO1xuICBcdFx0XHRmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gIFx0XHRcdFx0bWFwLnB1c2gobWFwcGVyKGJpbmFyeVtqXSkpO1xuICBcdFx0XHR9XG4gIFx0XHRcdHN0YXJNYXBbaV0gPSBtYXA7XG4gIFx0XHR9XG5cbiAgXHRcdHN0YXJNYXBzW251bV0gPSBzdGFyTWFwO1xuICBcdH1cblxuICBcdHJldHVybiBzdGFyTWFwc1tudW1dO1xuICB9XG5cbiAgdmFyIHJlZlBhdHRlcm4gPSAvXFxbXFxzKihcXCp8WzAtOV18WzEtOV1bMC05XSspXFxzKlxcXS9nO1xuICB2YXIgcGF0dGVyblBhdHRlcm4gPSAvXFwqLztcbiAgdmFyIGtleXBhdGhDYWNoZSA9IHt9O1xuXG4gIHZhciBLZXlwYXRoID0gZnVuY3Rpb24gKHN0cikge1xuICBcdHZhciBrZXlzID0gc3RyLnNwbGl0KFwiLlwiKTtcblxuICBcdHRoaXMuc3RyID0gc3RyO1xuXG4gIFx0aWYgKHN0clswXSA9PT0gXCJAXCIpIHtcbiAgXHRcdHRoaXMuaXNTcGVjaWFsID0gdHJ1ZTtcbiAgXHRcdHRoaXMudmFsdWUgPSBkZWNvZGVLZXlwYXRoKHN0cik7XG4gIFx0fVxuXG4gIFx0dGhpcy5maXJzdEtleSA9IGtleXNbMF07XG4gIFx0dGhpcy5sYXN0S2V5ID0ga2V5cy5wb3AoKTtcblxuICBcdHRoaXMuaXNQYXR0ZXJuID0gcGF0dGVyblBhdHRlcm4udGVzdChzdHIpO1xuXG4gIFx0dGhpcy5wYXJlbnQgPSBzdHIgPT09IFwiXCIgPyBudWxsIDogZ2V0S2V5cGF0aChrZXlzLmpvaW4oXCIuXCIpKTtcbiAgXHR0aGlzLmlzUm9vdCA9ICFzdHI7XG4gIH07XG5cbiAgS2V5cGF0aC5wcm90b3R5cGUgPSB7XG4gIFx0ZXF1YWxzT3JTdGFydHNXaXRoOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0cmV0dXJuIGtleXBhdGggPT09IHRoaXMgfHwgdGhpcy5zdGFydHNXaXRoKGtleXBhdGgpO1xuICBcdH0sXG5cbiAgXHRqb2luOiBmdW5jdGlvbiAoc3RyKSB7XG4gIFx0XHRyZXR1cm4gZ2V0S2V5cGF0aCh0aGlzLmlzUm9vdCA/IFN0cmluZyhzdHIpIDogdGhpcy5zdHIgKyBcIi5cIiArIHN0cik7XG4gIFx0fSxcblxuICBcdHJlcGxhY2U6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHRpZiAodGhpcyA9PT0gb2xkS2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gbmV3S2V5cGF0aDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuc3RhcnRzV2l0aChvbGRLZXlwYXRoKSkge1xuICBcdFx0XHRyZXR1cm4gbmV3S2V5cGF0aCA9PT0gbnVsbCA/IG5ld0tleXBhdGggOiBnZXRLZXlwYXRoKHRoaXMuc3RyLnJlcGxhY2Uob2xkS2V5cGF0aC5zdHIgKyBcIi5cIiwgbmV3S2V5cGF0aC5zdHIgKyBcIi5cIikpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRzdGFydHNXaXRoOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0aWYgKCFrZXlwYXRoKSB7XG4gIFx0XHRcdC8vIFRPRE8gdW5kZXIgd2hhdCBjaXJjdW1zdGFuY2VzIGRvZXMgdGhpcyBoYXBwZW4/XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGtleXBhdGggJiYgdGhpcy5zdHIuc3Vic3RyKDAsIGtleXBhdGguc3RyLmxlbmd0aCArIDEpID09PSBrZXlwYXRoLnN0ciArIFwiLlwiO1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQmFkIGNvZXJjaW9uXCIpO1xuICBcdH0sXG5cbiAgXHR2YWx1ZU9mOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJCYWQgY29lcmNpb25cIik7XG4gIFx0fSxcblxuICBcdHdpbGRjYXJkTWF0Y2hlczogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3dpbGRjYXJkTWF0Y2hlcyB8fCAodGhpcy5fd2lsZGNhcmRNYXRjaGVzID0gdXRpbHNfZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzKHRoaXMuc3RyKSk7XG4gIFx0fVxuICB9O1xuICBmdW5jdGlvbiBhc3NpZ25OZXdLZXlwYXRoKHRhcmdldCwgcHJvcGVydHksIG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHR2YXIgZXhpc3RpbmdLZXlwYXRoID0gdGFyZ2V0W3Byb3BlcnR5XTtcblxuICBcdGlmIChleGlzdGluZ0tleXBhdGggJiYgKGV4aXN0aW5nS2V5cGF0aC5lcXVhbHNPclN0YXJ0c1dpdGgobmV3S2V5cGF0aCkgfHwgIWV4aXN0aW5nS2V5cGF0aC5lcXVhbHNPclN0YXJ0c1dpdGgob2xkS2V5cGF0aCkpKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dGFyZ2V0W3Byb3BlcnR5XSA9IGV4aXN0aW5nS2V5cGF0aCA/IGV4aXN0aW5nS2V5cGF0aC5yZXBsYWNlKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIDogbmV3S2V5cGF0aDtcbiAgXHRyZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZUtleXBhdGgoa2V5cGF0aCkge1xuICBcdHZhciB2YWx1ZSA9IGtleXBhdGguc2xpY2UoMik7XG5cbiAgXHRpZiAoa2V5cGF0aFsxXSA9PT0gXCJpXCIpIHtcbiAgXHRcdHJldHVybiBpc19faXNOdW1lcmljKHZhbHVlKSA/ICt2YWx1ZSA6IHZhbHVlO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0S2V5cGF0aChzdHIpIHtcbiAgXHRpZiAoc3RyID09IG51bGwpIHtcbiAgXHRcdHJldHVybiBzdHI7XG4gIFx0fVxuXG4gIFx0Ly8gVE9ETyBpdCAqbWF5KiBiZSB3b3J0aCBoYXZpbmcgdHdvIHZlcnNpb25zIG9mIHRoaXMgZnVuY3Rpb24gLSBvbmUgd2hlcmVcbiAgXHQvLyBrZXlwYXRoQ2FjaGUgaW5oZXJpdHMgZnJvbSBudWxsLCBhbmQgb25lIGZvciBJRTguIERlcGVuZHMgb24gaG93XG4gIFx0Ly8gbXVjaCBvZiBhbiBvdmVyaGVhZCBoYXNPd25Qcm9wZXJ0eSBpcyAtIHByb2JhYmx5IG5lZ2xpZ2libGVcbiAgXHRpZiAoIWtleXBhdGhDYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHIpKSB7XG4gIFx0XHRrZXlwYXRoQ2FjaGVbc3RyXSA9IG5ldyBLZXlwYXRoKHN0cik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGtleXBhdGhDYWNoZVtzdHJdO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWF0Y2hpbmdLZXlwYXRocyhyYWN0aXZlLCBrZXlwYXRoKSB7XG4gIFx0dmFyIGtleXMsIGtleSwgbWF0Y2hpbmdLZXlwYXRocztcblxuICBcdGtleXMgPSBrZXlwYXRoLnN0ci5zcGxpdChcIi5cIik7XG4gIFx0bWF0Y2hpbmdLZXlwYXRocyA9IFtyb290S2V5cGF0aF07XG5cbiAgXHR3aGlsZSAoa2V5ID0ga2V5cy5zaGlmdCgpKSB7XG4gIFx0XHRpZiAoa2V5ID09PSBcIipcIikge1xuICBcdFx0XHQvLyBleHBhbmQgdG8gZmluZCBhbGwgdmFsaWQgY2hpbGQga2V5cGF0aHNcbiAgXHRcdFx0bWF0Y2hpbmdLZXlwYXRocyA9IG1hdGNoaW5nS2V5cGF0aHMucmVkdWNlKGV4cGFuZCwgW10pO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0aWYgKG1hdGNoaW5nS2V5cGF0aHNbMF0gPT09IHJvb3RLZXlwYXRoKSB7XG4gIFx0XHRcdFx0Ly8gZmlyc3Qga2V5XG4gIFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRoc1swXSA9IGdldEtleXBhdGgoa2V5KTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gbWF0Y2hpbmdLZXlwYXRocy5tYXAoY29uY2F0ZW5hdGUoa2V5KSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbWF0Y2hpbmdLZXlwYXRocztcblxuICBcdGZ1bmN0aW9uIGV4cGFuZChtYXRjaGluZ0tleXBhdGhzLCBrZXlwYXRoKSB7XG4gIFx0XHR2YXIgd3JhcHBlciwgdmFsdWUsIGtleXM7XG5cbiAgXHRcdGlmIChrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0XHRrZXlzID0gW10uY29uY2F0KE9iamVjdC5rZXlzKHJhY3RpdmUudmlld21vZGVsLmRhdGEpLCBPYmplY3Qua2V5cyhyYWN0aXZlLnZpZXdtb2RlbC5tYXBwaW5ncyksIE9iamVjdC5rZXlzKHJhY3RpdmUudmlld21vZGVsLmNvbXB1dGF0aW9ucykpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0d3JhcHBlciA9IHJhY3RpdmUudmlld21vZGVsLndyYXBwZWRba2V5cGF0aC5zdHJdO1xuICBcdFx0XHR2YWx1ZSA9IHdyYXBwZXIgPyB3cmFwcGVyLmdldCgpIDogcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0XHRcdGtleXMgPSB2YWx1ZSA/IE9iamVjdC5rZXlzKHZhbHVlKSA6IG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChrZXlzKSB7XG4gIFx0XHRcdGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHRcdFx0aWYgKGtleSAhPT0gXCJfcmFjdGl2ZVwiIHx8ICFpc0FycmF5KHZhbHVlKSkge1xuICBcdFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRocy5wdXNoKGtleXBhdGguam9pbihrZXkpKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbWF0Y2hpbmdLZXlwYXRocztcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBjb25jYXRlbmF0ZShrZXkpIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHJldHVybiBrZXlwYXRoLmpvaW4oa2V5KTtcbiAgXHR9O1xuICB9XG4gIGZ1bmN0aW9uIG5vcm1hbGlzZShyZWYpIHtcbiAgXHRyZXR1cm4gcmVmID8gcmVmLnJlcGxhY2UocmVmUGF0dGVybiwgXCIuJDFcIikgOiBcIlwiO1xuICB9XG5cbiAgdmFyIHJvb3RLZXlwYXRoID0gZ2V0S2V5cGF0aChcIlwiKTtcblxuICB2YXIgc2hhcmVkX2FkZCA9IGFkZDtcbiAgdmFyIHNoYXJlZF9hZGRfX2Vycm9yTWVzc2FnZSA9IFwiQ2Fubm90IGFkZCB0byBhIG5vbi1udW1lcmljIHZhbHVlXCI7XG4gIGZ1bmN0aW9uIGFkZChyb290LCBrZXlwYXRoLCBkKSB7XG4gIFx0aWYgKHR5cGVvZiBrZXlwYXRoICE9PSBcInN0cmluZ1wiIHx8ICFpc19faXNOdW1lcmljKGQpKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJCYWQgYXJndW1lbnRzXCIpO1xuICBcdH1cblxuICBcdHZhciB2YWx1ZSA9IHVuZGVmaW5lZCxcbiAgXHQgICAgY2hhbmdlcyA9IHVuZGVmaW5lZDtcblxuICBcdGlmICgvXFwqLy50ZXN0KGtleXBhdGgpKSB7XG4gIFx0XHRjaGFuZ2VzID0ge307XG5cbiAgXHRcdGdldE1hdGNoaW5nS2V5cGF0aHMocm9vdCwgZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdHZhciB2YWx1ZSA9IHJvb3Qudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdFx0XHRpZiAoIWlzX19pc051bWVyaWModmFsdWUpKSB7XG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKHNoYXJlZF9hZGRfX2Vycm9yTWVzc2FnZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjaGFuZ2VzW2tleXBhdGguc3RyXSA9IHZhbHVlICsgZDtcbiAgXHRcdH0pO1xuXG4gIFx0XHRyZXR1cm4gcm9vdC5zZXQoY2hhbmdlcyk7XG4gIFx0fVxuXG4gIFx0dmFsdWUgPSByb290LmdldChrZXlwYXRoKTtcblxuICBcdGlmICghaXNfX2lzTnVtZXJpYyh2YWx1ZSkpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihzaGFyZWRfYWRkX19lcnJvck1lc3NhZ2UpO1xuICBcdH1cblxuICBcdHJldHVybiByb290LnNldChrZXlwYXRoLCArdmFsdWUgKyBkKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfYWRkID0gUmFjdGl2ZSRhZGQ7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkYWRkKGtleXBhdGgsIGQpIHtcbiAgXHRyZXR1cm4gc2hhcmVkX2FkZCh0aGlzLCBrZXlwYXRoLCBkID09PSB1bmRlZmluZWQgPyAxIDogK2QpO1xuICB9XG5cbiAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblxuICAvLyBJZiB3aW5kb3cgZG9lc24ndCBleGlzdCwgd2UgZG9uJ3QgbmVlZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgXHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxXG4gIFx0KGZ1bmN0aW9uICh2ZW5kb3JzLCBsYXN0VGltZSwgd2luZG93KSB7XG5cbiAgXHRcdHZhciB4LCBzZXRUaW1lb3V0O1xuXG4gIFx0XHRpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XG4gIFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSArIFwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgXHRcdFx0c2V0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0O1xuXG4gIFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgXHRcdFx0XHR2YXIgY3VyclRpbWUsIHRpbWVUb0NhbGwsIGlkO1xuXG4gIFx0XHRcdFx0Y3VyclRpbWUgPSBEYXRlLm5vdygpO1xuICBcdFx0XHRcdHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XG4gIFx0XHRcdFx0aWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XG4gIFx0XHRcdFx0fSwgdGltZVRvQ2FsbCk7XG5cbiAgXHRcdFx0XHRsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgXHRcdFx0XHRyZXR1cm4gaWQ7XG4gIFx0XHRcdH07XG4gIFx0XHR9XG4gIFx0fSkodmVuZG9ycywgMCwgd2luZG93KTtcblxuICBcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gIH1cblxuICB2YXIgckFGID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG4gIHZhciBnZXRUaW1lO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB0eXBlb2Ygd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0Z2V0VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gIFx0fTtcbiAgfSBlbHNlIHtcbiAgXHRnZXRUaW1lID0gZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIERhdGUubm93KCk7XG4gIFx0fTtcbiAgfVxuXG4gIHZhciB1dGlsc19nZXRUaW1lID0gZ2V0VGltZTtcblxuICB2YXIgZGVwcmVjYXRpb25zID0ge1xuICBcdGNvbnN0cnVjdDoge1xuICBcdFx0ZGVwcmVjYXRlZDogXCJiZWZvcmVJbml0XCIsXG4gIFx0XHRyZXBsYWNlbWVudDogXCJvbmNvbnN0cnVjdFwiXG4gIFx0fSxcbiAgXHRyZW5kZXI6IHtcbiAgXHRcdGRlcHJlY2F0ZWQ6IFwiaW5pdFwiLFxuICBcdFx0bWVzc2FnZTogXCJUaGUgXFxcImluaXRcXFwiIG1ldGhvZCBoYXMgYmVlbiBkZXByZWNhdGVkIFwiICsgXCJhbmQgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiBcIiArIFwiWW91IGNhbiBlaXRoZXIgdXNlIHRoZSBcXFwib25pbml0XFxcIiBtZXRob2Qgd2hpY2ggd2lsbCBmaXJlIFwiICsgXCJvbmx5IG9uY2UgcHJpb3IgdG8sIGFuZCByZWdhcmRsZXNzIG9mLCBhbnkgZXZlbnR1YWwgcmFjdGl2ZSBcIiArIFwiaW5zdGFuY2UgYmVpbmcgcmVuZGVyZWQsIG9yIGlmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgXCIgKyBcInJlbmRlcmVkIERPTSwgdXNlIFxcXCJvbnJlbmRlclxcXCIgaW5zdGVhZC4gXCIgKyBcIlNlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9taWdyYXRpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgXHR9LFxuICBcdGNvbXBsZXRlOiB7XG4gIFx0XHRkZXByZWNhdGVkOiBcImNvbXBsZXRlXCIsXG4gIFx0XHRyZXBsYWNlbWVudDogXCJvbmNvbXBsZXRlXCJcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gSG9vayhldmVudCkge1xuICBcdHRoaXMuZXZlbnQgPSBldmVudDtcbiAgXHR0aGlzLm1ldGhvZCA9IFwib25cIiArIGV2ZW50O1xuICBcdHRoaXMuZGVwcmVjYXRlID0gZGVwcmVjYXRpb25zW2V2ZW50XTtcbiAgfVxuXG4gIEhvb2sucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbiAocmFjdGl2ZSwgYXJnKSB7XG4gIFx0ZnVuY3Rpb24gY2FsbChtZXRob2QpIHtcbiAgXHRcdGlmIChyYWN0aXZlW21ldGhvZF0pIHtcbiAgXHRcdFx0YXJnID8gcmFjdGl2ZVttZXRob2RdKGFyZykgOiByYWN0aXZlW21ldGhvZF0oKTtcbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Y2FsbCh0aGlzLm1ldGhvZCk7XG5cbiAgXHRpZiAoIXJhY3RpdmVbdGhpcy5tZXRob2RdICYmIHRoaXMuZGVwcmVjYXRlICYmIGNhbGwodGhpcy5kZXByZWNhdGUuZGVwcmVjYXRlZCkpIHtcbiAgXHRcdGlmICh0aGlzLmRlcHJlY2F0ZS5tZXNzYWdlKSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKHRoaXMuZGVwcmVjYXRlLm1lc3NhZ2UpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0d2FybklmRGVidWcoXCJUaGUgbWV0aG9kIFxcXCIlc1xcXCIgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBcXFwiJXNcXFwiIGFuZCB3aWxsIGxpa2VseSBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuIFNlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9taWdyYXRpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIsIHRoaXMuZGVwcmVjYXRlLmRlcHJlY2F0ZWQsIHRoaXMuZGVwcmVjYXRlLnJlcGxhY2VtZW50KTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRhcmcgPyByYWN0aXZlLmZpcmUodGhpcy5ldmVudCwgYXJnKSA6IHJhY3RpdmUuZmlyZSh0aGlzLmV2ZW50KTtcbiAgfTtcblxuICB2YXIgaG9va3NfSG9vayA9IEhvb2s7XG5cbiAgZnVuY3Rpb24gYWRkVG9BcnJheShhcnJheSwgdmFsdWUpIHtcbiAgXHR2YXIgaW5kZXggPSBhcnJheS5pbmRleE9mKHZhbHVlKTtcblxuICBcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdGFycmF5LnB1c2godmFsdWUpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5Q29udGFpbnMoYXJyYXksIHZhbHVlKSB7XG4gIFx0Zm9yICh2YXIgaSA9IDAsIGMgPSBhcnJheS5sZW5ndGg7IGkgPCBjOyBpKyspIHtcbiAgXHRcdGlmIChhcnJheVtpXSA9PSB2YWx1ZSkge1xuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUNvbnRlbnRzTWF0Y2goYSwgYikge1xuICBcdHZhciBpO1xuXG4gIFx0aWYgKCFpc0FycmF5KGEpIHx8ICFpc0FycmF5KGIpKSB7XG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuXG4gIFx0aWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdGkgPSBhLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoYVtpXSAhPT0gYltpXSkge1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVBcnJheSh4KSB7XG4gIFx0aWYgKHR5cGVvZiB4ID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRyZXR1cm4gW3hdO1xuICBcdH1cblxuICBcdGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdHJldHVybiBbXTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4geDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxhc3RJdGVtKGFycmF5KSB7XG4gIFx0cmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRnJvbUFycmF5KGFycmF5LCBtZW1iZXIpIHtcbiAgXHR2YXIgaW5kZXggPSBhcnJheS5pbmRleE9mKG1lbWJlcik7XG5cbiAgXHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvQXJyYXkoYXJyYXlMaWtlKSB7XG4gIFx0dmFyIGFycmF5ID0gW10sXG4gIFx0ICAgIGkgPSBhcnJheUxpa2UubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGFycmF5W2ldID0gYXJyYXlMaWtlW2ldO1xuICBcdH1cblxuICBcdHJldHVybiBhcnJheTtcbiAgfVxuXG4gIHZhciBfUHJvbWlzZSxcbiAgICAgIFBFTkRJTkcgPSB7fSxcbiAgICAgIEZVTEZJTExFRCA9IHt9LFxuICAgICAgUkVKRUNURUQgPSB7fTtcblxuICBpZiAodHlwZW9mIFByb21pc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdC8vIHVzZSBuYXRpdmUgUHJvbWlzZVxuICBcdF9Qcm9taXNlID0gUHJvbWlzZTtcbiAgfSBlbHNlIHtcbiAgXHRfUHJvbWlzZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBcdFx0dmFyIGZ1bGZpbGxlZEhhbmRsZXJzID0gW10sXG4gIFx0XHQgICAgcmVqZWN0ZWRIYW5kbGVycyA9IFtdLFxuICBcdFx0ICAgIHN0YXRlID0gUEVORElORyxcbiAgXHRcdCAgICByZXN1bHQsXG4gIFx0XHQgICAgZGlzcGF0Y2hIYW5kbGVycyxcbiAgXHRcdCAgICBtYWtlUmVzb2x2ZXIsXG4gIFx0XHQgICAgZnVsZmlsLFxuICBcdFx0ICAgIHJlamVjdCxcbiAgXHRcdCAgICBwcm9taXNlO1xuXG4gIFx0XHRtYWtlUmVzb2x2ZXIgPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0XHRcdGlmIChzdGF0ZSAhPT0gUEVORElORykge1xuICBcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdHJlc3VsdCA9IHZhbHVlO1xuICBcdFx0XHRcdHN0YXRlID0gbmV3U3RhdGU7XG5cbiAgXHRcdFx0XHRkaXNwYXRjaEhhbmRsZXJzID0gbWFrZURpc3BhdGNoZXIoc3RhdGUgPT09IEZVTEZJTExFRCA/IGZ1bGZpbGxlZEhhbmRsZXJzIDogcmVqZWN0ZWRIYW5kbGVycywgcmVzdWx0KTtcblxuICBcdFx0XHRcdC8vIGRpc3BhdGNoIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGhhbmRsZXJzIGFzeW5jaHJvbm91c2x5XG4gIFx0XHRcdFx0d2FpdChkaXNwYXRjaEhhbmRsZXJzKTtcbiAgXHRcdFx0fTtcbiAgXHRcdH07XG5cbiAgXHRcdGZ1bGZpbCA9IG1ha2VSZXNvbHZlcihGVUxGSUxMRUQpO1xuICBcdFx0cmVqZWN0ID0gbWFrZVJlc29sdmVyKFJFSkVDVEVEKTtcblxuICBcdFx0dHJ5IHtcbiAgXHRcdFx0Y2FsbGJhY2soZnVsZmlsLCByZWplY3QpO1xuICBcdFx0fSBjYXRjaCAoZXJyKSB7XG4gIFx0XHRcdHJlamVjdChlcnIpO1xuICBcdFx0fVxuXG4gIFx0XHRwcm9taXNlID0ge1xuICBcdFx0XHQvLyBgdGhlbigpYCByZXR1cm5zIGEgUHJvbWlzZSAtIDIuMi43XG4gIFx0XHRcdHRoZW46IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBcdFx0XHRcdHZhciBwcm9taXNlMiA9IG5ldyBfUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsLCByZWplY3QpIHtcblxuICBcdFx0XHRcdFx0dmFyIHByb2Nlc3NSZXNvbHV0aW9uSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyLCBoYW5kbGVycywgZm9yd2FyZCkge1xuXG4gIFx0XHRcdFx0XHRcdC8vIDIuMi4xLjFcbiAgXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHRcdFx0XHRoYW5kbGVycy5wdXNoKGZ1bmN0aW9uIChwMXJlc3VsdCkge1xuICBcdFx0XHRcdFx0XHRcdFx0dmFyIHg7XG5cbiAgXHRcdFx0XHRcdFx0XHRcdHRyeSB7XG4gIFx0XHRcdFx0XHRcdFx0XHRcdHggPSBoYW5kbGVyKHAxcmVzdWx0KTtcbiAgXHRcdFx0XHRcdFx0XHRcdFx0dXRpbHNfUHJvbWlzZV9fcmVzb2x2ZShwcm9taXNlMiwgeCwgZnVsZmlsLCByZWplY3QpO1xuICBcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG4gIFx0XHRcdFx0XHRcdFx0XHRcdHJlamVjdChlcnIpO1xuICBcdFx0XHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0XHRcdC8vIEZvcndhcmQgdGhlIHJlc3VsdCBvZiBwcm9taXNlMSB0byBwcm9taXNlMiwgaWYgcmVzb2x1dGlvbiBoYW5kbGVyc1xuICBcdFx0XHRcdFx0XHRcdC8vIGFyZSBub3QgZ2l2ZW5cbiAgXHRcdFx0XHRcdFx0XHRoYW5kbGVycy5wdXNoKGZvcndhcmQpO1xuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9O1xuXG4gIFx0XHRcdFx0XHQvLyAyLjJcbiAgXHRcdFx0XHRcdHByb2Nlc3NSZXNvbHV0aW9uSGFuZGxlcihvbkZ1bGZpbGxlZCwgZnVsZmlsbGVkSGFuZGxlcnMsIGZ1bGZpbCk7XG4gIFx0XHRcdFx0XHRwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIob25SZWplY3RlZCwgcmVqZWN0ZWRIYW5kbGVycywgcmVqZWN0KTtcblxuICBcdFx0XHRcdFx0aWYgKHN0YXRlICE9PSBQRU5ESU5HKSB7XG4gIFx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcm9taXNlIGhhcyByZXNvbHZlZCBhbHJlYWR5LCBkaXNwYXRjaCB0aGUgYXBwcm9wcmlhdGUgaGFuZGxlcnMgYXN5bmNocm9ub3VzbHlcbiAgXHRcdFx0XHRcdFx0d2FpdChkaXNwYXRjaEhhbmRsZXJzKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9KTtcblxuICBcdFx0XHRcdHJldHVybiBwcm9taXNlMjtcbiAgXHRcdFx0fVxuICBcdFx0fTtcblxuICBcdFx0cHJvbWlzZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbiAgXHRcdH07XG5cbiAgXHRcdHJldHVybiBwcm9taXNlO1xuICBcdH07XG5cbiAgXHRfUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgXHRcdHJldHVybiBuZXcgX1Byb21pc2UoZnVuY3Rpb24gKGZ1bGZpbCwgcmVqZWN0KSB7XG4gIFx0XHRcdHZhciByZXN1bHQgPSBbXSxcbiAgXHRcdFx0ICAgIHBlbmRpbmcsXG4gIFx0XHRcdCAgICBpLFxuICBcdFx0XHQgICAgcHJvY2Vzc1Byb21pc2U7XG5cbiAgXHRcdFx0aWYgKCFwcm9taXNlcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRmdWxmaWwocmVzdWx0KTtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwcm9jZXNzUHJvbWlzZSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpKSB7XG4gIFx0XHRcdFx0aWYgKHByb21pc2UgJiYgdHlwZW9mIHByb21pc2UudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdFx0XHRwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRcdFx0XHRcdHJlc3VsdFtpXSA9IHZhbHVlO1xuICBcdFx0XHRcdFx0XHQtLXBlbmRpbmcgfHwgZnVsZmlsKHJlc3VsdCk7XG4gIFx0XHRcdFx0XHR9LCByZWplY3QpO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRyZXN1bHRbaV0gPSBwcm9taXNlO1xuICBcdFx0XHRcdFx0LS1wZW5kaW5nIHx8IGZ1bGZpbChyZXN1bHQpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fTtcblxuICBcdFx0XHRwZW5kaW5nID0gaSA9IHByb21pc2VzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdHByb2Nlc3NQcm9taXNlKHByb21pc2VzW2ldLCBpKTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fTtcblxuICBcdF9Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdHJldHVybiBuZXcgX1Byb21pc2UoZnVuY3Rpb24gKGZ1bGZpbCkge1xuICBcdFx0XHRmdWxmaWwodmFsdWUpO1xuICBcdFx0fSk7XG4gIFx0fTtcblxuICBcdF9Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgXHRcdHJldHVybiBuZXcgX1Byb21pc2UoZnVuY3Rpb24gKGZ1bGZpbCwgcmVqZWN0KSB7XG4gIFx0XHRcdHJlamVjdChyZWFzb24pO1xuICBcdFx0fSk7XG4gIFx0fTtcbiAgfVxuXG4gIHZhciB1dGlsc19Qcm9taXNlID0gX1Byb21pc2U7XG5cbiAgLy8gVE9ETyB1c2UgTXV0YXRpb25PYnNlcnZlcnMgb3Igc29tZXRoaW5nIHRvIHNpbXVsYXRlIHNldEltbWVkaWF0ZVxuICBmdW5jdGlvbiB3YWl0KGNhbGxiYWNrKSB7XG4gIFx0c2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlRGlzcGF0Y2hlcihoYW5kbGVycywgcmVzdWx0KSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBoYW5kbGVyO1xuXG4gIFx0XHR3aGlsZSAoaGFuZGxlciA9IGhhbmRsZXJzLnNoaWZ0KCkpIHtcbiAgXHRcdFx0aGFuZGxlcihyZXN1bHQpO1xuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICBmdW5jdGlvbiB1dGlsc19Qcm9taXNlX19yZXNvbHZlKHByb21pc2UsIHgsIGZ1bGZpbCwgcmVqZWN0KSB7XG4gIFx0Ly8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZVxuICBcdHZhciB0aGVuO1xuXG4gIFx0Ly8gMi4zLjFcbiAgXHRpZiAoeCA9PT0gcHJvbWlzZSkge1xuICBcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgcHJvbWlzZSdzIGZ1bGZpbGxtZW50IGhhbmRsZXIgY2Fubm90IHJldHVybiB0aGUgc2FtZSBwcm9taXNlXCIpO1xuICBcdH1cblxuICBcdC8vIDIuMy4yXG4gIFx0aWYgKHggaW5zdGFuY2VvZiBfUHJvbWlzZSkge1xuICBcdFx0eC50aGVuKGZ1bGZpbCwgcmVqZWN0KTtcbiAgXHR9XG5cbiAgXHQvLyAyLjMuM1xuICBcdGVsc2UgaWYgKHggJiYgKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gIFx0XHR0cnkge1xuICBcdFx0XHR0aGVuID0geC50aGVuOyAvLyAyLjMuMy4xXG4gIFx0XHR9IGNhdGNoIChlKSB7XG4gIFx0XHRcdHJlamVjdChlKTsgLy8gMi4zLjMuMlxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdC8vIDIuMy4zLjNcbiAgXHRcdGlmICh0eXBlb2YgdGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdHZhciBjYWxsZWQsIHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlO1xuXG4gIFx0XHRcdHJlc29sdmVQcm9taXNlID0gZnVuY3Rpb24gKHkpIHtcbiAgXHRcdFx0XHRpZiAoY2FsbGVkKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuICBcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG4gIFx0XHRcdFx0dXRpbHNfUHJvbWlzZV9fcmVzb2x2ZShwcm9taXNlLCB5LCBmdWxmaWwsIHJlamVjdCk7XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0cmVqZWN0UHJvbWlzZSA9IGZ1bmN0aW9uIChyKSB7XG4gIFx0XHRcdFx0aWYgKGNhbGxlZCkge1xuICBcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHRjYWxsZWQgPSB0cnVlO1xuICBcdFx0XHRcdHJlamVjdChyKTtcbiAgXHRcdFx0fTtcblxuICBcdFx0XHR0cnkge1xuICBcdFx0XHRcdHRoZW4uY2FsbCh4LCByZXNvbHZlUHJvbWlzZSwgcmVqZWN0UHJvbWlzZSk7XG4gIFx0XHRcdH0gY2F0Y2ggKGUpIHtcbiAgXHRcdFx0XHRpZiAoIWNhbGxlZCkge1xuICBcdFx0XHRcdFx0Ly8gMi4zLjMuMy40LjFcbiAgXHRcdFx0XHRcdHJlamVjdChlKTsgLy8gMi4zLjMuMy40LjJcbiAgXHRcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmdWxmaWwoeCk7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGZ1bGZpbCh4KTtcbiAgXHR9XG4gIH1cblxuICB2YXIgZ2V0SW5uZXJDb250ZXh0ID0gZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gIFx0ZG8ge1xuICBcdFx0aWYgKGZyYWdtZW50LmNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm4gZnJhZ21lbnQuY29udGV4dDtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlIChmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudCk7XG5cbiAgXHRyZXR1cm4gcm9vdEtleXBhdGg7XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9yZXNvbHZlUmVmID0gcmVzb2x2ZVJlZjtcblxuICBmdW5jdGlvbiByZXNvbHZlUmVmKHJhY3RpdmUsIHJlZiwgZnJhZ21lbnQpIHtcbiAgXHR2YXIga2V5cGF0aDtcblxuICBcdHJlZiA9IG5vcm1hbGlzZShyZWYpO1xuXG4gIFx0Ly8gSWYgYSByZWZlcmVuY2UgYmVnaW5zICd+LycsIGl0J3MgYSB0b3AtbGV2ZWwgcmVmZXJlbmNlXG4gIFx0aWYgKHJlZi5zdWJzdHIoMCwgMikgPT09IFwifi9cIikge1xuICBcdFx0a2V5cGF0aCA9IGdldEtleXBhdGgocmVmLnN1YnN0cmluZygyKSk7XG4gIFx0XHRjcmVhdGVNYXBwaW5nSWZOZWNlc3NhcnkocmFjdGl2ZSwga2V5cGF0aC5maXJzdEtleSwgZnJhZ21lbnQpO1xuICBcdH1cblxuICBcdC8vIElmIGEgcmVmZXJlbmNlIGJlZ2lucyB3aXRoICcuJywgaXQncyBlaXRoZXIgYSByZXN0cmljdGVkIHJlZmVyZW5jZSBvclxuICBcdC8vIGFuIGFuY2VzdG9yIHJlZmVyZW5jZS4uLlxuICBcdGVsc2UgaWYgKHJlZlswXSA9PT0gXCIuXCIpIHtcbiAgXHRcdGtleXBhdGggPSByZXNvbHZlQW5jZXN0b3JSZWYoZ2V0SW5uZXJDb250ZXh0KGZyYWdtZW50KSwgcmVmKTtcblxuICBcdFx0aWYgKGtleXBhdGgpIHtcbiAgXHRcdFx0Y3JlYXRlTWFwcGluZ0lmTmVjZXNzYXJ5KHJhY3RpdmUsIGtleXBhdGguZmlyc3RLZXksIGZyYWdtZW50KTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyAuLi5vdGhlcndpc2Ugd2UgbmVlZCB0byBmaWd1cmUgb3V0IHRoZSBrZXlwYXRoIGJhc2VkIG9uIGNvbnRleHRcbiAgXHRlbHNlIHtcbiAgXHRcdGtleXBhdGggPSByZXNvbHZlQW1iaWd1b3VzUmVmZXJlbmNlKHJhY3RpdmUsIGdldEtleXBhdGgocmVmKSwgZnJhZ21lbnQpO1xuICBcdH1cblxuICBcdHJldHVybiBrZXlwYXRoO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUFuY2VzdG9yUmVmKGJhc2VDb250ZXh0LCByZWYpIHtcbiAgXHR2YXIgY29udGV4dEtleXM7XG5cbiAgXHQvLyBUT0RPLi4uXG4gIFx0aWYgKGJhc2VDb250ZXh0ICE9IHVuZGVmaW5lZCAmJiB0eXBlb2YgYmFzZUNvbnRleHQgIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGJhc2VDb250ZXh0ID0gYmFzZUNvbnRleHQuc3RyO1xuICBcdH1cblxuICBcdC8vIHt7Ln19IG1lYW5zICdjdXJyZW50IGNvbnRleHQnXG4gIFx0aWYgKHJlZiA9PT0gXCIuXCIpIHJldHVybiBnZXRLZXlwYXRoKGJhc2VDb250ZXh0KTtcblxuICBcdGNvbnRleHRLZXlzID0gYmFzZUNvbnRleHQgPyBiYXNlQ29udGV4dC5zcGxpdChcIi5cIikgOiBbXTtcblxuICBcdC8vIGFuY2VzdG9yIHJlZmVyZW5jZXMgKHN0YXJ0aW5nIFwiLi4vXCIpIGdvIHVwIHRoZSB0cmVlXG4gIFx0aWYgKHJlZi5zdWJzdHIoMCwgMykgPT09IFwiLi4vXCIpIHtcbiAgXHRcdHdoaWxlIChyZWYuc3Vic3RyKDAsIDMpID09PSBcIi4uL1wiKSB7XG4gIFx0XHRcdGlmICghY29udGV4dEtleXMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgcmVmZXJlbmNlIC0gdG9vIG1hbnkgXFxcIi4uL1xcXCIgcHJlZml4ZXNcIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb250ZXh0S2V5cy5wb3AoKTtcbiAgXHRcdFx0cmVmID0gcmVmLnN1YnN0cmluZygzKTtcbiAgXHRcdH1cblxuICBcdFx0Y29udGV4dEtleXMucHVzaChyZWYpO1xuICBcdFx0cmV0dXJuIGdldEtleXBhdGgoY29udGV4dEtleXMuam9pbihcIi5cIikpO1xuICBcdH1cblxuICBcdC8vIG5vdCBhbiBhbmNlc3RvciByZWZlcmVuY2UgLSBtdXN0IGJlIGEgcmVzdHJpY3RlZCByZWZlcmVuY2UgKHByZXBlbmRlZCB3aXRoIFwiLlwiIG9yIFwiLi9cIilcbiAgXHRpZiAoIWJhc2VDb250ZXh0KSB7XG4gIFx0XHRyZXR1cm4gZ2V0S2V5cGF0aChyZWYucmVwbGFjZSgvXlxcLlxcLz8vLCBcIlwiKSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGdldEtleXBhdGgoYmFzZUNvbnRleHQgKyByZWYucmVwbGFjZSgvXlxcLlxcLy8sIFwiLlwiKSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlQW1iaWd1b3VzUmVmZXJlbmNlKHJhY3RpdmUsIHJlZiwgZnJhZ21lbnQsIGlzUGFyZW50TG9va3VwKSB7XG4gIFx0dmFyIGNvbnRleHQsIGtleSwgcGFyZW50VmFsdWUsIGhhc0NvbnRleHRDaGFpbiwgcGFyZW50S2V5cGF0aDtcblxuICBcdGlmIChyZWYuaXNSb290KSB7XG4gIFx0XHRyZXR1cm4gcmVmO1xuICBcdH1cblxuICBcdGtleSA9IHJlZi5maXJzdEtleTtcblxuICBcdHdoaWxlIChmcmFnbWVudCkge1xuICBcdFx0Y29udGV4dCA9IGZyYWdtZW50LmNvbnRleHQ7XG4gIFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudDtcblxuICBcdFx0aWYgKCFjb250ZXh0KSB7XG4gIFx0XHRcdGNvbnRpbnVlO1xuICBcdFx0fVxuXG4gIFx0XHRoYXNDb250ZXh0Q2hhaW4gPSB0cnVlO1xuICBcdFx0cGFyZW50VmFsdWUgPSByYWN0aXZlLnZpZXdtb2RlbC5nZXQoY29udGV4dCk7XG5cbiAgXHRcdGlmIChwYXJlbnRWYWx1ZSAmJiAodHlwZW9mIHBhcmVudFZhbHVlID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSAmJiBrZXkgaW4gcGFyZW50VmFsdWUpIHtcbiAgXHRcdFx0cmV0dXJuIGNvbnRleHQuam9pbihyZWYuc3RyKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBSb290L2NvbXB1dGVkL21hcHBlZCBwcm9wZXJ0eT9cbiAgXHRpZiAoaXNSb290UHJvcGVydHkocmFjdGl2ZS52aWV3bW9kZWwsIGtleSkpIHtcbiAgXHRcdHJldHVybiByZWY7XG4gIFx0fVxuXG4gIFx0Ly8gSWYgdGhpcyBpcyBhbiBpbmxpbmUgY29tcG9uZW50LCBhbmQgaXQncyBub3QgaXNvbGF0ZWQsIHdlXG4gIFx0Ly8gY2FuIHRyeSBnb2luZyB1cCB0aGUgc2NvcGUgY2hhaW5cbiAgXHRpZiAocmFjdGl2ZS5wYXJlbnQgJiYgIXJhY3RpdmUuaXNvbGF0ZWQpIHtcbiAgXHRcdGhhc0NvbnRleHRDaGFpbiA9IHRydWU7XG4gIFx0XHRmcmFnbWVudCA9IHJhY3RpdmUuY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXG4gIFx0XHRrZXkgPSBnZXRLZXlwYXRoKGtleSk7XG5cbiAgXHRcdGlmIChwYXJlbnRLZXlwYXRoID0gcmVzb2x2ZUFtYmlndW91c1JlZmVyZW5jZShyYWN0aXZlLnBhcmVudCwga2V5LCBmcmFnbWVudCwgdHJ1ZSkpIHtcbiAgXHRcdFx0Ly8gV2UgbmVlZCB0byBjcmVhdGUgYW4gaW50ZXItY29tcG9uZW50IGJpbmRpbmdcbiAgXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwubWFwKGtleSwge1xuICBcdFx0XHRcdG9yaWdpbjogcmFjdGl2ZS5wYXJlbnQudmlld21vZGVsLFxuICBcdFx0XHRcdGtleXBhdGg6IHBhcmVudEtleXBhdGhcbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0cmV0dXJuIHJlZjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGVyZSdzIG5vIGNvbnRleHQgY2hhaW4sIGFuZCB0aGUgaW5zdGFuY2UgaXMgZWl0aGVyIGEpIGlzb2xhdGVkIG9yXG4gIFx0Ly8gYikgYW4gb3JwaGFuLCB0aGVuIHdlIGtub3cgdGhhdCB0aGUga2V5cGF0aCBpcyBpZGVudGljYWwgdG8gdGhlIHJlZmVyZW5jZVxuICBcdGlmICghaXNQYXJlbnRMb29rdXAgJiYgIWhhc0NvbnRleHRDaGFpbikge1xuICBcdFx0Ly8gdGhlIGRhdGEgb2JqZWN0IG5lZWRzIHRvIGhhdmUgYSBwcm9wZXJ0eSBieSB0aGlzIG5hbWUsXG4gIFx0XHQvLyB0byBwcmV2ZW50IGZ1dHVyZSBmYWlsZWQgbG9va3Vwc1xuICBcdFx0cmFjdGl2ZS52aWV3bW9kZWwuc2V0KHJlZiwgdW5kZWZpbmVkKTtcbiAgXHRcdHJldHVybiByZWY7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTWFwcGluZ0lmTmVjZXNzYXJ5KHJhY3RpdmUsIGtleSkge1xuICBcdHZhciBwYXJlbnRLZXlwYXRoO1xuXG4gIFx0aWYgKCFyYWN0aXZlLnBhcmVudCB8fCByYWN0aXZlLmlzb2xhdGVkIHx8IGlzUm9vdFByb3BlcnR5KHJhY3RpdmUudmlld21vZGVsLCBrZXkpKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0a2V5ID0gZ2V0S2V5cGF0aChrZXkpO1xuXG4gIFx0aWYgKHBhcmVudEtleXBhdGggPSByZXNvbHZlQW1iaWd1b3VzUmVmZXJlbmNlKHJhY3RpdmUucGFyZW50LCBrZXksIHJhY3RpdmUuY29tcG9uZW50LnBhcmVudEZyYWdtZW50LCB0cnVlKSkge1xuICBcdFx0cmFjdGl2ZS52aWV3bW9kZWwubWFwKGtleSwge1xuICBcdFx0XHRvcmlnaW46IHJhY3RpdmUucGFyZW50LnZpZXdtb2RlbCxcbiAgXHRcdFx0a2V5cGF0aDogcGFyZW50S2V5cGF0aFxuICBcdFx0fSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gaXNSb290UHJvcGVydHkodmlld21vZGVsLCBrZXkpIHtcbiAgXHQvLyBzcGVjaWFsIGNhc2UgZm9yIHJlZmVyZW5jZSB0byByb290XG4gIFx0cmV0dXJuIGtleSA9PT0gXCJcIiB8fCBrZXkgaW4gdmlld21vZGVsLmRhdGEgfHwga2V5IGluIHZpZXdtb2RlbC5jb21wdXRhdGlvbnMgfHwga2V5IGluIHZpZXdtb2RlbC5tYXBwaW5ncztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlYXJkb3duKHgpIHtcbiAgICB4LnRlYXJkb3duKCk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXRob2RDYWxsZXJzX191bmJpbmQoeCkge1xuICAgIHgudW5iaW5kKCk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXRob2RDYWxsZXJzX191bnJlbmRlcih4KSB7XG4gICAgeC51bnJlbmRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKHgpIHtcbiAgICB4LmNhbmNlbCgpO1xuICB9XG5cbiAgdmFyIFRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBwYXJlbnQpIHtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIFx0dGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgXHR0aGlzLmludHJvcyA9IFtdO1xuICBcdHRoaXMub3V0cm9zID0gW107XG5cbiAgXHR0aGlzLmNoaWxkcmVuID0gW107XG4gIFx0dGhpcy50b3RhbENoaWxkcmVuID0gdGhpcy5vdXRyb0NoaWxkcmVuID0gMDtcblxuICBcdHRoaXMuZGV0YWNoUXVldWUgPSBbXTtcbiAgXHR0aGlzLmRlY29yYXRvclF1ZXVlID0gW107XG4gIFx0dGhpcy5vdXRyb3NDb21wbGV0ZSA9IGZhbHNlO1xuXG4gIFx0aWYgKHBhcmVudCkge1xuICBcdFx0cGFyZW50LmFkZENoaWxkKHRoaXMpO1xuICBcdH1cbiAgfTtcblxuICBUcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gIFx0YWRkQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICBcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICBcdFx0dGhpcy50b3RhbENoaWxkcmVuICs9IDE7XG4gIFx0XHR0aGlzLm91dHJvQ2hpbGRyZW4gKz0gMTtcbiAgXHR9LFxuXG4gIFx0ZGVjcmVtZW50T3V0cm9zOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLm91dHJvQ2hpbGRyZW4gLT0gMTtcbiAgXHRcdGNoZWNrKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRkZWNyZW1lbnRUb3RhbDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy50b3RhbENoaWxkcmVuIC09IDE7XG4gIFx0XHRjaGVjayh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0YWRkOiBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICBcdFx0dmFyIGxpc3QgPSB0cmFuc2l0aW9uLmlzSW50cm8gPyB0aGlzLmludHJvcyA6IHRoaXMub3V0cm9zO1xuICBcdFx0bGlzdC5wdXNoKHRyYW5zaXRpb24pO1xuICBcdH0sXG5cbiAgXHRhZGREZWNvcmF0b3I6IGZ1bmN0aW9uIChkZWNvcmF0b3IpIHtcbiAgXHRcdHRoaXMuZGVjb3JhdG9yUXVldWUucHVzaChkZWNvcmF0b3IpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmU6IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gIFx0XHR2YXIgbGlzdCA9IHRyYW5zaXRpb24uaXNJbnRybyA/IHRoaXMuaW50cm9zIDogdGhpcy5vdXRyb3M7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkobGlzdCwgdHJhbnNpdGlvbik7XG4gIFx0XHRjaGVjayh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5yZWFkeSA9IHRydWU7XG4gIFx0XHRjaGVjayh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0ZGV0YWNoTm9kZXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZGVjb3JhdG9yUXVldWUuZm9yRWFjaCh0ZWFyZG93bik7XG4gIFx0XHR0aGlzLmRldGFjaFF1ZXVlLmZvckVhY2goZGV0YWNoKTtcbiAgXHRcdHRoaXMuY2hpbGRyZW4uZm9yRWFjaChkZXRhY2hOb2Rlcyk7XG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRldGFjaChlbGVtZW50KSB7XG4gIFx0ZWxlbWVudC5kZXRhY2goKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRldGFjaE5vZGVzKHRtKSB7XG4gIFx0dG0uZGV0YWNoTm9kZXMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrKHRtKSB7XG4gIFx0aWYgKCF0bS5yZWFkeSB8fCB0bS5vdXRyb3MubGVuZ3RoIHx8IHRtLm91dHJvQ2hpbGRyZW4pIHJldHVybjtcblxuICBcdC8vIElmIGFsbCBvdXRyb3MgYXJlIGNvbXBsZXRlLCBhbmQgd2UgaGF2ZW4ndCBhbHJlYWR5IGRvbmUgdGhpcyxcbiAgXHQvLyB3ZSBub3RpZnkgdGhlIHBhcmVudCBpZiB0aGVyZSBpcyBvbmUsIG90aGVyd2lzZVxuICBcdC8vIHN0YXJ0IGRldGFjaGluZyBub2Rlc1xuICBcdGlmICghdG0ub3V0cm9zQ29tcGxldGUpIHtcbiAgXHRcdGlmICh0bS5wYXJlbnQpIHtcbiAgXHRcdFx0dG0ucGFyZW50LmRlY3JlbWVudE91dHJvcyh0bSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0bS5kZXRhY2hOb2RlcygpO1xuICBcdFx0fVxuXG4gIFx0XHR0bS5vdXRyb3NDb21wbGV0ZSA9IHRydWU7XG4gIFx0fVxuXG4gIFx0Ly8gT25jZSBldmVyeXRoaW5nIGlzIGRvbmUsIHdlIGNhbiBub3RpZnkgcGFyZW50IHRyYW5zaXRpb25cbiAgXHQvLyBtYW5hZ2VyIGFuZCBjYWxsIHRoZSBjYWxsYmFja1xuICBcdGlmICghdG0uaW50cm9zLmxlbmd0aCAmJiAhdG0udG90YWxDaGlsZHJlbikge1xuICBcdFx0aWYgKHR5cGVvZiB0bS5jYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdHRtLmNhbGxiYWNrKCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0bS5wYXJlbnQpIHtcbiAgXHRcdFx0dG0ucGFyZW50LmRlY3JlbWVudFRvdGFsKCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIGdsb2JhbF9UcmFuc2l0aW9uTWFuYWdlciA9IFRyYW5zaXRpb25NYW5hZ2VyO1xuXG4gIHZhciBiYXRjaCxcbiAgICAgIHJ1bmxvb3AsXG4gICAgICB1bnJlc29sdmVkID0gW10sXG4gICAgICBjaGFuZ2VIb29rID0gbmV3IGhvb2tzX0hvb2soXCJjaGFuZ2VcIik7XG5cbiAgcnVubG9vcCA9IHtcbiAgXHRzdGFydDogZnVuY3Rpb24gKGluc3RhbmNlLCByZXR1cm5Qcm9taXNlKSB7XG4gIFx0XHR2YXIgcHJvbWlzZSwgZnVsZmlsUHJvbWlzZTtcblxuICBcdFx0aWYgKHJldHVyblByb21pc2UpIHtcbiAgXHRcdFx0cHJvbWlzZSA9IG5ldyB1dGlsc19Qcm9taXNlKGZ1bmN0aW9uIChmKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZ1bGZpbFByb21pc2UgPSBmO1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0YmF0Y2ggPSB7XG4gIFx0XHRcdHByZXZpb3VzQmF0Y2g6IGJhdGNoLFxuICBcdFx0XHR0cmFuc2l0aW9uTWFuYWdlcjogbmV3IGdsb2JhbF9UcmFuc2l0aW9uTWFuYWdlcihmdWxmaWxQcm9taXNlLCBiYXRjaCAmJiBiYXRjaC50cmFuc2l0aW9uTWFuYWdlciksXG4gIFx0XHRcdHZpZXdzOiBbXSxcbiAgXHRcdFx0dGFza3M6IFtdLFxuICBcdFx0XHRyYWN0aXZlczogW10sXG4gIFx0XHRcdGluc3RhbmNlOiBpbnN0YW5jZVxuICBcdFx0fTtcblxuICBcdFx0aWYgKGluc3RhbmNlKSB7XG4gIFx0XHRcdGJhdGNoLnJhY3RpdmVzLnB1c2goaW5zdGFuY2UpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gcHJvbWlzZTtcbiAgXHR9LFxuXG4gIFx0ZW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmbHVzaENoYW5nZXMoKTtcblxuICBcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuaW5pdCgpO1xuICBcdFx0aWYgKCFiYXRjaC5wcmV2aW91c0JhdGNoICYmICEhYmF0Y2guaW5zdGFuY2UpIGJhdGNoLmluc3RhbmNlLnZpZXdtb2RlbC5jaGFuZ2VzID0gW107XG4gIFx0XHRiYXRjaCA9IGJhdGNoLnByZXZpb3VzQmF0Y2g7XG4gIFx0fSxcblxuICBcdGFkZFJhY3RpdmU6IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG4gIFx0XHRpZiAoYmF0Y2gpIHtcbiAgXHRcdFx0YWRkVG9BcnJheShiYXRjaC5yYWN0aXZlcywgcmFjdGl2ZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlZ2lzdGVyVHJhbnNpdGlvbjogZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgXHRcdHRyYW5zaXRpb24uX21hbmFnZXIgPSBiYXRjaC50cmFuc2l0aW9uTWFuYWdlcjtcbiAgXHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmFkZCh0cmFuc2l0aW9uKTtcbiAgXHR9LFxuXG4gIFx0cmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uIChkZWNvcmF0b3IpIHtcbiAgXHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmFkZERlY29yYXRvcihkZWNvcmF0b3IpO1xuICBcdH0sXG5cbiAgXHRhZGRWaWV3OiBmdW5jdGlvbiAodmlldykge1xuICBcdFx0YmF0Y2gudmlld3MucHVzaCh2aWV3KTtcbiAgXHR9LFxuXG4gIFx0YWRkVW5yZXNvbHZlZDogZnVuY3Rpb24gKHRoaW5nKSB7XG4gIFx0XHR1bnJlc29sdmVkLnB1c2godGhpbmcpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVVbnJlc29sdmVkOiBmdW5jdGlvbiAodGhpbmcpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh1bnJlc29sdmVkLCB0aGluZyk7XG4gIFx0fSxcblxuICBcdC8vIHN5bmNocm9uaXNlIG5vZGUgZGV0YWNobWVudHMgd2l0aCB0cmFuc2l0aW9uIGVuZHNcbiAgXHRkZXRhY2hXaGVuUmVhZHk6IGZ1bmN0aW9uICh0aGluZykge1xuICBcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuZGV0YWNoUXVldWUucHVzaCh0aGluZyk7XG4gIFx0fSxcblxuICBcdHNjaGVkdWxlVGFzazogZnVuY3Rpb24gKHRhc2ssIHBvc3RSZW5kZXIpIHtcbiAgXHRcdHZhciBfYmF0Y2g7XG5cbiAgXHRcdGlmICghYmF0Y2gpIHtcbiAgXHRcdFx0dGFzaygpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0X2JhdGNoID0gYmF0Y2g7XG4gIFx0XHRcdHdoaWxlIChwb3N0UmVuZGVyICYmIF9iYXRjaC5wcmV2aW91c0JhdGNoKSB7XG4gIFx0XHRcdFx0Ly8gdGhpcyBjYW4ndCBoYXBwZW4gdW50aWwgdGhlIERPTSBoYXMgYmVlbiBmdWxseSB1cGRhdGVkXG4gIFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIGluIHNvbWUgc2l0dWF0aW9ucyAod2l0aCBjb21wb25lbnRzIGluc2lkZSBlbGVtZW50cylcbiAgXHRcdFx0XHQvLyB0cmFuc2l0aW9ucyBhbmQgZGVjb3JhdG9ycyB3aWxsIGluaXRpYWxpc2UgcHJlbWF0dXJlbHlcbiAgXHRcdFx0XHRfYmF0Y2ggPSBfYmF0Y2gucHJldmlvdXNCYXRjaDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdF9iYXRjaC50YXNrcy5wdXNoKHRhc2spO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgZ2xvYmFsX3J1bmxvb3AgPSBydW5sb29wO1xuXG4gIGZ1bmN0aW9uIGZsdXNoQ2hhbmdlcygpIHtcbiAgXHR2YXIgaSwgdGhpbmcsIGNoYW5nZUhhc2g7XG5cbiAgXHR3aGlsZSAoYmF0Y2gucmFjdGl2ZXMubGVuZ3RoKSB7XG4gIFx0XHR0aGluZyA9IGJhdGNoLnJhY3RpdmVzLnBvcCgpO1xuICBcdFx0Y2hhbmdlSGFzaCA9IHRoaW5nLnZpZXdtb2RlbC5hcHBseUNoYW5nZXMoKTtcblxuICBcdFx0aWYgKGNoYW5nZUhhc2gpIHtcbiAgXHRcdFx0Y2hhbmdlSG9vay5maXJlKHRoaW5nLCBjaGFuZ2VIYXNoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRhdHRlbXB0S2V5cGF0aFJlc29sdXRpb24oKTtcblxuICBcdC8vIE5vdyB0aGF0IGNoYW5nZXMgaGF2ZSBiZWVuIGZ1bGx5IHByb3BhZ2F0ZWQsIHdlIGNhbiB1cGRhdGUgdGhlIERPTVxuICBcdC8vIGFuZCBjb21wbGV0ZSBvdGhlciB0YXNrc1xuICBcdGZvciAoaSA9IDA7IGkgPCBiYXRjaC52aWV3cy5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0YmF0Y2gudmlld3NbaV0udXBkYXRlKCk7XG4gIFx0fVxuICBcdGJhdGNoLnZpZXdzLmxlbmd0aCA9IDA7XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgYmF0Y2gudGFza3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdGJhdGNoLnRhc2tzW2ldKCk7XG4gIFx0fVxuICBcdGJhdGNoLnRhc2tzLmxlbmd0aCA9IDA7XG5cbiAgXHQvLyBJZiB1cGRhdGluZyB0aGUgdmlldyBjYXVzZWQgc29tZSBtb2RlbCBibG93YmFjayAtIGUuZy4gYSB0cmlwbGVcbiAgXHQvLyBjb250YWluaW5nIDxvcHRpb24+IGVsZW1lbnRzIGNhdXNlZCB0aGUgYmluZGluZyBvbiB0aGUgPHNlbGVjdD5cbiAgXHQvLyB0byB1cGRhdGUgLSB0aGVuIHdlIHN0YXJ0IG92ZXJcbiAgXHRpZiAoYmF0Y2gucmFjdGl2ZXMubGVuZ3RoKSByZXR1cm4gZmx1c2hDaGFuZ2VzKCk7XG4gIH1cblxuICBmdW5jdGlvbiBhdHRlbXB0S2V5cGF0aFJlc29sdXRpb24oKSB7XG4gIFx0dmFyIGksIGl0ZW0sIGtleXBhdGgsIHJlc29sdmVkO1xuXG4gIFx0aSA9IHVucmVzb2x2ZWQubGVuZ3RoO1xuXG4gIFx0Ly8gc2VlIGlmIHdlIGNhbiByZXNvbHZlIGFueSB1bnJlc29sdmVkIHJlZmVyZW5jZXNcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpdGVtID0gdW5yZXNvbHZlZFtpXTtcblxuICBcdFx0aWYgKGl0ZW0ua2V5cGF0aCkge1xuICBcdFx0XHQvLyBpdCByZXNvbHZlZCBzb21lIG90aGVyIHdheS4gVE9ETyBob3c/IHR3by13YXkgYmluZGluZz8gU2VlbXNcbiAgXHRcdFx0Ly8gd2VpcmQgdGhhdCB3ZSdkIHN0aWxsIGVuZCB1cCBoZXJlXG4gIFx0XHRcdHVucmVzb2x2ZWQuc3BsaWNlKGksIDEpO1xuICBcdFx0XHRjb250aW51ZTsgLy8gYXZvaWQgcmVtb3ZpbmcgdGhlIHdyb25nIHRoaW5nIHNob3VsZCB0aGUgbmV4dCBjb25kaXRpb24gYmUgdHJ1ZVxuICBcdFx0fVxuXG4gIFx0XHRpZiAoa2V5cGF0aCA9IHNoYXJlZF9yZXNvbHZlUmVmKGl0ZW0ucm9vdCwgaXRlbS5yZWYsIGl0ZW0ucGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHRcdChyZXNvbHZlZCB8fCAocmVzb2x2ZWQgPSBbXSkpLnB1c2goe1xuICBcdFx0XHRcdGl0ZW06IGl0ZW0sXG4gIFx0XHRcdFx0a2V5cGF0aDoga2V5cGF0aFxuICBcdFx0XHR9KTtcblxuICBcdFx0XHR1bnJlc29sdmVkLnNwbGljZShpLCAxKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAocmVzb2x2ZWQpIHtcbiAgXHRcdHJlc29sdmVkLmZvckVhY2goZ2xvYmFsX3J1bmxvb3BfX3Jlc29sdmUpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdsb2JhbF9ydW5sb29wX19yZXNvbHZlKHJlc29sdmVkKSB7XG4gIFx0cmVzb2x2ZWQuaXRlbS5yZXNvbHZlKHJlc29sdmVkLmtleXBhdGgpO1xuICB9XG5cbiAgdmFyIHF1ZXVlID0gW107XG5cbiAgdmFyIGFuaW1hdGlvbnMgPSB7XG4gIFx0dGljazogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGksIGFuaW1hdGlvbiwgbm93O1xuXG4gIFx0XHRub3cgPSB1dGlsc19nZXRUaW1lKCk7XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KCk7XG5cbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0XHRhbmltYXRpb24gPSBxdWV1ZVtpXTtcblxuICBcdFx0XHRpZiAoIWFuaW1hdGlvbi50aWNrKG5vdykpIHtcbiAgXHRcdFx0XHQvLyBhbmltYXRpb24gaXMgY29tcGxldGUsIHJlbW92ZSBpdCBmcm9tIHRoZSBzdGFjaywgYW5kIGRlY3JlbWVudCBpIHNvIHdlIGRvbid0IG1pc3Mgb25lXG4gIFx0XHRcdFx0cXVldWUuc3BsaWNlKGktLSwgMSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHRcdGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgXHRcdFx0ckFGKGFuaW1hdGlvbnMudGljayk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRhbmltYXRpb25zLnJ1bm5pbmcgPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0YWRkOiBmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gIFx0XHRxdWV1ZS5wdXNoKGFuaW1hdGlvbik7XG5cbiAgXHRcdGlmICghYW5pbWF0aW9ucy5ydW5uaW5nKSB7XG4gIFx0XHRcdGFuaW1hdGlvbnMucnVubmluZyA9IHRydWU7XG4gIFx0XHRcdHJBRihhbmltYXRpb25zLnRpY2spO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHQvLyBUT0RPIG9wdGltaXNlIHRoaXNcbiAgXHRhYm9ydDogZnVuY3Rpb24gKGtleXBhdGgsIHJvb3QpIHtcbiAgXHRcdHZhciBpID0gcXVldWUubGVuZ3RoLFxuICBcdFx0ICAgIGFuaW1hdGlvbjtcblxuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRhbmltYXRpb24gPSBxdWV1ZVtpXTtcblxuICBcdFx0XHRpZiAoYW5pbWF0aW9uLnJvb3QgPT09IHJvb3QgJiYgYW5pbWF0aW9uLmtleXBhdGggPT09IGtleXBhdGgpIHtcbiAgXHRcdFx0XHRhbmltYXRpb24uc3RvcCgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBzaGFyZWRfYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG5cbiAgdmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dmFyIGtleTtcblxuICBcdHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICBcdC8vIGZyb20gYW5kIHRvXG4gIFx0Zm9yIChrZXkgaW4gb3B0aW9ucykge1xuICBcdFx0aWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBcdFx0XHR0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0dGhpcy5pbnRlcnBvbGF0b3IgPSBzaGFyZWRfaW50ZXJwb2xhdGUodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLnJvb3QsIHRoaXMuaW50ZXJwb2xhdG9yKTtcbiAgXHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXG4gIFx0dGhpcy50aWNrKCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcbiAgXHR0aWNrOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZWxhcHNlZCwgdCwgdmFsdWUsIHRpbWVOb3csIGluZGV4LCBrZXlwYXRoO1xuXG4gIFx0XHRrZXlwYXRoID0gdGhpcy5rZXlwYXRoO1xuXG4gIFx0XHRpZiAodGhpcy5ydW5uaW5nKSB7XG4gIFx0XHRcdHRpbWVOb3cgPSBEYXRlLm5vdygpO1xuICBcdFx0XHRlbGFwc2VkID0gdGltZU5vdyAtIHRoaXMuc3RhcnRUaW1lO1xuXG4gIFx0XHRcdGlmIChlbGFwc2VkID49IHRoaXMuZHVyYXRpb24pIHtcbiAgXHRcdFx0XHRpZiAoa2V5cGF0aCAhPT0gbnVsbCkge1xuICBcdFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcy5yb290KTtcbiAgXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KGtleXBhdGgsIHRoaXMudG8pO1xuICBcdFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKHRoaXMuc3RlcCkge1xuICBcdFx0XHRcdFx0dGhpcy5zdGVwKDEsIHRoaXMudG8pO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdHRoaXMuY29tcGxldGUodGhpcy50byk7XG5cbiAgXHRcdFx0XHRpbmRleCA9IHRoaXMucm9vdC5fYW5pbWF0aW9ucy5pbmRleE9mKHRoaXMpO1xuXG4gIFx0XHRcdFx0Ly8gVE9ETyBpbnZlc3RpZ2F0ZSB3aHkgdGhpcyBoYXBwZW5zXG4gIFx0XHRcdFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0XHRcdFx0d2FybklmRGVidWcoXCJBbmltYXRpb24gd2FzIG5vdCBmb3VuZFwiKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHR0aGlzLnJvb3QuX2FuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcblxuICBcdFx0XHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuICBcdFx0XHRcdHJldHVybiBmYWxzZTsgLy8gcmVtb3ZlIGZyb20gdGhlIHN0YWNrXG4gIFx0XHRcdH1cblxuICBcdFx0XHR0ID0gdGhpcy5lYXNpbmcgPyB0aGlzLmVhc2luZyhlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbikgOiBlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbjtcblxuICBcdFx0XHRpZiAoa2V5cGF0aCAhPT0gbnVsbCkge1xuICBcdFx0XHRcdHZhbHVlID0gdGhpcy5pbnRlcnBvbGF0b3IodCk7XG4gIFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcy5yb290KTtcbiAgXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldChrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAodGhpcy5zdGVwKSB7XG4gIFx0XHRcdFx0dGhpcy5zdGVwKHQsIHZhbHVlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiB0cnVlOyAvLyBrZWVwIGluIHRoZSBzdGFja1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZmFsc2U7IC8vIHJlbW92ZSBmcm9tIHRoZSBzdGFja1xuICBcdH0sXG5cbiAgXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgaW5kZXg7XG5cbiAgXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG4gIFx0XHRpbmRleCA9IHRoaXMucm9vdC5fYW5pbWF0aW9ucy5pbmRleE9mKHRoaXMpO1xuXG4gIFx0XHQvLyBUT0RPIGludmVzdGlnYXRlIHdoeSB0aGlzIGhhcHBlbnNcbiAgXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0d2FybklmRGVidWcoXCJBbmltYXRpb24gd2FzIG5vdCBmb3VuZFwiKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5yb290Ll9hbmltYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBhbmltYXRlX0FuaW1hdGlvbiA9IEFuaW1hdGlvbjtcblxuICB2YXIgcHJvdG90eXBlX2FuaW1hdGUgPSBSYWN0aXZlJGFuaW1hdGU7XG5cbiAgdmFyIG5vQW5pbWF0aW9uID0geyBzdG9wOiBub29wIH07XG4gIGZ1bmN0aW9uIFJhY3RpdmUkYW5pbWF0ZShrZXlwYXRoLCB0bywgb3B0aW9ucykge1xuICBcdHZhciBwcm9taXNlLCBmdWxmaWxQcm9taXNlLCBrLCBhbmltYXRpb24sIGFuaW1hdGlvbnMsIGVhc2luZywgZHVyYXRpb24sIHN0ZXAsIGNvbXBsZXRlLCBtYWtlVmFsdWVDb2xsZWN0b3IsIGN1cnJlbnRWYWx1ZXMsIGNvbGxlY3RWYWx1ZSwgZHVtbXksIGR1bW15T3B0aW9ucztcblxuICBcdHByb21pc2UgPSBuZXcgdXRpbHNfUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsKSB7XG4gIFx0XHRyZXR1cm4gZnVsZmlsUHJvbWlzZSA9IGZ1bGZpbDtcbiAgXHR9KTtcblxuICBcdC8vIGFuaW1hdGUgbXVsdGlwbGUga2V5cGF0aHNcbiAgXHRpZiAodHlwZW9mIGtleXBhdGggPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdG9wdGlvbnMgPSB0byB8fCB7fTtcbiAgXHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xuICBcdFx0ZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuXG4gIFx0XHRhbmltYXRpb25zID0gW107XG5cbiAgXHRcdC8vIHdlIGRvbid0IHdhbnQgdG8gcGFzcyB0aGUgYHN0ZXBgIGFuZCBgY29tcGxldGVgIGhhbmRsZXJzLCBhcyB0aGV5IHdpbGxcbiAgXHRcdC8vIHJ1biBmb3IgZWFjaCBhbmltYXRpb24hIFNvIGluc3RlYWQgd2UnbGwgc3RvcmUgdGhlIGhhbmRsZXJzIGFuZCBjcmVhdGVcbiAgXHRcdC8vIG91ciBvd24uLi5cbiAgXHRcdHN0ZXAgPSBvcHRpb25zLnN0ZXA7XG4gIFx0XHRjb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XG5cbiAgXHRcdGlmIChzdGVwIHx8IGNvbXBsZXRlKSB7XG4gIFx0XHRcdGN1cnJlbnRWYWx1ZXMgPSB7fTtcblxuICBcdFx0XHRvcHRpb25zLnN0ZXAgPSBudWxsO1xuICBcdFx0XHRvcHRpb25zLmNvbXBsZXRlID0gbnVsbDtcblxuICBcdFx0XHRtYWtlVmFsdWVDb2xsZWN0b3IgPSBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRcdHJldHVybiBmdW5jdGlvbiAodCwgdmFsdWUpIHtcbiAgXHRcdFx0XHRcdGN1cnJlbnRWYWx1ZXNba2V5cGF0aF0gPSB2YWx1ZTtcbiAgXHRcdFx0XHR9O1xuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRmb3IgKGsgaW4ga2V5cGF0aCkge1xuICBcdFx0XHRpZiAoa2V5cGF0aC5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICBcdFx0XHRcdGlmIChzdGVwIHx8IGNvbXBsZXRlKSB7XG4gIFx0XHRcdFx0XHRjb2xsZWN0VmFsdWUgPSBtYWtlVmFsdWVDb2xsZWN0b3Ioayk7XG4gIFx0XHRcdFx0XHRvcHRpb25zID0geyBlYXNpbmc6IGVhc2luZywgZHVyYXRpb246IGR1cmF0aW9uIH07XG5cbiAgXHRcdFx0XHRcdGlmIChzdGVwKSB7XG4gIFx0XHRcdFx0XHRcdG9wdGlvbnMuc3RlcCA9IGNvbGxlY3RWYWx1ZTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlID0gY29tcGxldGUgPyBjb2xsZWN0VmFsdWUgOiBub29wO1xuICBcdFx0XHRcdGFuaW1hdGlvbnMucHVzaChhbmltYXRlKHRoaXMsIGssIGtleXBhdGhba10sIG9wdGlvbnMpKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBDcmVhdGUgYSBkdW1teSBhbmltYXRpb24sIHRvIGZhY2lsaXRhdGUgc3RlcC9jb21wbGV0ZVxuICBcdFx0Ly8gY2FsbGJhY2tzLCBhbmQgUHJvbWlzZSBmdWxmaWxtZW50XG4gIFx0XHRkdW1teU9wdGlvbnMgPSB7IGVhc2luZzogZWFzaW5nLCBkdXJhdGlvbjogZHVyYXRpb24gfTtcblxuICBcdFx0aWYgKHN0ZXApIHtcbiAgXHRcdFx0ZHVtbXlPcHRpb25zLnN0ZXAgPSBmdW5jdGlvbiAodCkge1xuICBcdFx0XHRcdHJldHVybiBzdGVwKHQsIGN1cnJlbnRWYWx1ZXMpO1xuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoY29tcGxldGUpIHtcbiAgXHRcdFx0cHJvbWlzZS50aGVuKGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlKHQsIGN1cnJlbnRWYWx1ZXMpO1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0ZHVtbXlPcHRpb25zLmNvbXBsZXRlID0gZnVsZmlsUHJvbWlzZTtcblxuICBcdFx0ZHVtbXkgPSBhbmltYXRlKHRoaXMsIG51bGwsIG51bGwsIGR1bW15T3B0aW9ucyk7XG4gIFx0XHRhbmltYXRpb25zLnB1c2goZHVtbXkpO1xuXG4gIFx0XHRwcm9taXNlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHZhciBhbmltYXRpb247XG5cbiAgXHRcdFx0d2hpbGUgKGFuaW1hdGlvbiA9IGFuaW1hdGlvbnMucG9wKCkpIHtcbiAgXHRcdFx0XHRhbmltYXRpb24uc3RvcCgpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGR1bW15KSB7XG4gIFx0XHRcdFx0ZHVtbXkuc3RvcCgpO1xuICBcdFx0XHR9XG4gIFx0XHR9O1xuXG4gIFx0XHRyZXR1cm4gcHJvbWlzZTtcbiAgXHR9XG5cbiAgXHQvLyBhbmltYXRlIGEgc2luZ2xlIGtleXBhdGhcbiAgXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBcdGlmIChvcHRpb25zLmNvbXBsZXRlKSB7XG4gIFx0XHRwcm9taXNlLnRoZW4ob3B0aW9ucy5jb21wbGV0ZSk7XG4gIFx0fVxuXG4gIFx0b3B0aW9ucy5jb21wbGV0ZSA9IGZ1bGZpbFByb21pc2U7XG4gIFx0YW5pbWF0aW9uID0gYW5pbWF0ZSh0aGlzLCBrZXlwYXRoLCB0bywgb3B0aW9ucyk7XG5cbiAgXHRwcm9taXNlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gYW5pbWF0aW9uLnN0b3AoKTtcbiAgXHR9O1xuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gYW5pbWF0ZShyb290LCBrZXlwYXRoLCB0bywgb3B0aW9ucykge1xuICBcdHZhciBlYXNpbmcsIGR1cmF0aW9uLCBhbmltYXRpb24sIGZyb207XG5cbiAgXHRpZiAoa2V5cGF0aCkge1xuICBcdFx0a2V5cGF0aCA9IGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKTtcbiAgXHR9XG5cbiAgXHRpZiAoa2V5cGF0aCAhPT0gbnVsbCkge1xuICBcdFx0ZnJvbSA9IHJvb3Qudmlld21vZGVsLmdldChrZXlwYXRoKTtcbiAgXHR9XG5cbiAgXHQvLyBjYW5jZWwgYW55IGV4aXN0aW5nIGFuaW1hdGlvblxuICBcdC8vIFRPRE8gd2hhdCBhYm91dCB1cHN0cmVhbS9kb3duc3RyZWFtIGtleXBhdGhzP1xuICBcdHNoYXJlZF9hbmltYXRpb25zLmFib3J0KGtleXBhdGgsIHJvb3QpO1xuXG4gIFx0Ly8gZG9uJ3QgYm90aGVyIGFuaW1hdGluZyB2YWx1ZXMgdGhhdCBzdGF5IHRoZSBzYW1lXG4gIFx0aWYgKGlzRXF1YWwoZnJvbSwgdG8pKSB7XG4gIFx0XHRpZiAob3B0aW9ucy5jb21wbGV0ZSkge1xuICBcdFx0XHRvcHRpb25zLmNvbXBsZXRlKG9wdGlvbnMudG8pO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbm9BbmltYXRpb247XG4gIFx0fVxuXG4gIFx0Ly8gZWFzaW5nIGZ1bmN0aW9uXG4gIFx0aWYgKG9wdGlvbnMuZWFzaW5nKSB7XG4gIFx0XHRpZiAodHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRlYXNpbmcgPSByb290LmVhc2luZ1tvcHRpb25zLmVhc2luZ107XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0eXBlb2YgZWFzaW5nICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0ZWFzaW5nID0gbnVsbDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBkdXJhdGlvblxuICBcdGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkID8gNDAwIDogb3B0aW9ucy5kdXJhdGlvbjtcblxuICBcdC8vIFRPRE8gc3RvcmUga2V5cywgdXNlIGFuIGludGVybmFsIHNldCBtZXRob2RcbiAgXHRhbmltYXRpb24gPSBuZXcgYW5pbWF0ZV9BbmltYXRpb24oe1xuICBcdFx0a2V5cGF0aDoga2V5cGF0aCxcbiAgXHRcdGZyb206IGZyb20sXG4gIFx0XHR0bzogdG8sXG4gIFx0XHRyb290OiByb290LFxuICBcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuICBcdFx0ZWFzaW5nOiBlYXNpbmcsXG4gIFx0XHRpbnRlcnBvbGF0b3I6IG9wdGlvbnMuaW50ZXJwb2xhdG9yLFxuXG4gIFx0XHQvLyBUT0RPIHdyYXAgY2FsbGJhY2tzIGlmIG5lY2Vzc2FyeSwgdG8gdXNlIGluc3RhbmNlIGFzIGNvbnRleHRcbiAgXHRcdHN0ZXA6IG9wdGlvbnMuc3RlcCxcbiAgXHRcdGNvbXBsZXRlOiBvcHRpb25zLmNvbXBsZXRlXG4gIFx0fSk7XG5cbiAgXHRzaGFyZWRfYW5pbWF0aW9ucy5hZGQoYW5pbWF0aW9uKTtcbiAgXHRyb290Ll9hbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcblxuICBcdHJldHVybiBhbmltYXRpb247XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2RldGFjaCA9IFJhY3RpdmUkZGV0YWNoO1xuICB2YXIgcHJvdG90eXBlX2RldGFjaF9fZGV0YWNoSG9vayA9IG5ldyBob29rc19Ib29rKFwiZGV0YWNoXCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJGRldGFjaCgpIHtcbiAgXHRpZiAodGhpcy5kZXRhY2hlZCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZGV0YWNoZWQ7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZWwpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgdGhpcyk7XG4gIFx0fVxuICBcdHRoaXMuZGV0YWNoZWQgPSB0aGlzLmZyYWdtZW50LmRldGFjaCgpO1xuICBcdHByb3RvdHlwZV9kZXRhY2hfX2RldGFjaEhvb2suZmlyZSh0aGlzKTtcbiAgXHRyZXR1cm4gdGhpcy5kZXRhY2hlZDtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmluZCA9IFJhY3RpdmUkZmluZDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJGZpbmQoc2VsZWN0b3IpIHtcbiAgXHRpZiAoIXRoaXMuZWwpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoc2VsZWN0b3IpO1xuICB9XG5cbiAgdmFyIHRlc3QgPSBRdWVyeSR0ZXN0O1xuICBmdW5jdGlvbiBRdWVyeSR0ZXN0KGl0ZW0sIG5vRGlydHkpIHtcbiAgXHR2YXIgaXRlbU1hdGNoZXM7XG5cbiAgXHRpZiAodGhpcy5faXNDb21wb25lbnRRdWVyeSkge1xuICBcdFx0aXRlbU1hdGNoZXMgPSAhdGhpcy5zZWxlY3RvciB8fCBpdGVtLm5hbWUgPT09IHRoaXMuc2VsZWN0b3I7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGl0ZW1NYXRjaGVzID0gaXRlbS5ub2RlID8gbWF0Y2hlcyhpdGVtLm5vZGUsIHRoaXMuc2VsZWN0b3IpIDogbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoaXRlbU1hdGNoZXMpIHtcbiAgXHRcdHRoaXMucHVzaChpdGVtLm5vZGUgfHwgaXRlbS5pbnN0YW5jZSk7XG5cbiAgXHRcdGlmICghbm9EaXJ0eSkge1xuICBcdFx0XHR0aGlzLl9tYWtlRGlydHkoKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuICB9XG5cbiAgdmFyIG1ha2VRdWVyeV9jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gIFx0dmFyIGxpdmVRdWVyaWVzLCBzZWxlY3RvciwgaW5kZXg7XG5cbiAgXHRsaXZlUXVlcmllcyA9IHRoaXMuX3Jvb3RbdGhpcy5faXNDb21wb25lbnRRdWVyeSA/IFwibGl2ZUNvbXBvbmVudFF1ZXJpZXNcIiA6IFwibGl2ZVF1ZXJpZXNcIl07XG4gIFx0c2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuXG4gIFx0aW5kZXggPSBsaXZlUXVlcmllcy5pbmRleE9mKHNlbGVjdG9yKTtcblxuICBcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdGxpdmVRdWVyaWVzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRsaXZlUXVlcmllc1tzZWxlY3Rvcl0gPSBudWxsO1xuICBcdH1cbiAgfTtcblxuICB2YXIgc29ydEJ5SXRlbVBvc2l0aW9uID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgXHR2YXIgYW5jZXN0cnlBLCBhbmNlc3RyeUIsIG9sZGVzdEEsIG9sZGVzdEIsIG11dHVhbEFuY2VzdG9yLCBpbmRleEEsIGluZGV4QiwgZnJhZ21lbnRzLCBmcmFnbWVudEEsIGZyYWdtZW50QjtcblxuICBcdGFuY2VzdHJ5QSA9IGdldEFuY2VzdHJ5KGEuY29tcG9uZW50IHx8IGEuX3JhY3RpdmUucHJveHkpO1xuICBcdGFuY2VzdHJ5QiA9IGdldEFuY2VzdHJ5KGIuY29tcG9uZW50IHx8IGIuX3JhY3RpdmUucHJveHkpO1xuXG4gIFx0b2xkZXN0QSA9IGxhc3RJdGVtKGFuY2VzdHJ5QSk7XG4gIFx0b2xkZXN0QiA9IGxhc3RJdGVtKGFuY2VzdHJ5Qik7XG5cbiAgXHQvLyByZW1vdmUgaXRlbXMgZnJvbSB0aGUgZW5kIG9mIGJvdGggYW5jZXN0cmllcyBhcyBsb25nIGFzIHRoZXkgYXJlIGlkZW50aWNhbFxuICBcdC8vIC0gdGhlIGZpbmFsIG9uZSByZW1vdmVkIGlzIHRoZSBjbG9zZXN0IG11dHVhbCBhbmNlc3RvclxuICBcdHdoaWxlIChvbGRlc3RBICYmIG9sZGVzdEEgPT09IG9sZGVzdEIpIHtcbiAgXHRcdGFuY2VzdHJ5QS5wb3AoKTtcbiAgXHRcdGFuY2VzdHJ5Qi5wb3AoKTtcblxuICBcdFx0bXV0dWFsQW5jZXN0b3IgPSBvbGRlc3RBO1xuXG4gIFx0XHRvbGRlc3RBID0gbGFzdEl0ZW0oYW5jZXN0cnlBKTtcbiAgXHRcdG9sZGVzdEIgPSBsYXN0SXRlbShhbmNlc3RyeUIpO1xuICBcdH1cblxuICBcdC8vIG5vdyB0aGF0IHdlIGhhdmUgdGhlIG11dHVhbCBhbmNlc3Rvciwgd2UgY2FuIGZpbmQgd2hpY2ggaXMgZWFybGllc3RcbiAgXHRvbGRlc3RBID0gb2xkZXN0QS5jb21wb25lbnQgfHwgb2xkZXN0QTtcbiAgXHRvbGRlc3RCID0gb2xkZXN0Qi5jb21wb25lbnQgfHwgb2xkZXN0QjtcblxuICBcdGZyYWdtZW50QSA9IG9sZGVzdEEucGFyZW50RnJhZ21lbnQ7XG4gIFx0ZnJhZ21lbnRCID0gb2xkZXN0Qi5wYXJlbnRGcmFnbWVudDtcblxuICBcdC8vIGlmIGJvdGggaXRlbXMgc2hhcmUgYSBwYXJlbnQgZnJhZ21lbnQsIG91ciBqb2IgaXMgZWFzeVxuICBcdGlmIChmcmFnbWVudEEgPT09IGZyYWdtZW50Qikge1xuICBcdFx0aW5kZXhBID0gZnJhZ21lbnRBLml0ZW1zLmluZGV4T2Yob2xkZXN0QSk7XG4gIFx0XHRpbmRleEIgPSBmcmFnbWVudEIuaXRlbXMuaW5kZXhPZihvbGRlc3RCKTtcblxuICBcdFx0Ly8gaWYgaXQncyB0aGUgc2FtZSBpbmRleCwgaXQgbWVhbnMgb25lIGNvbnRhaW5zIHRoZSBvdGhlcixcbiAgXHRcdC8vIHNvIHdlIHNlZSB3aGljaCBoYXMgdGhlIGxvbmdlc3QgYW5jZXN0cnlcbiAgXHRcdHJldHVybiBpbmRleEEgLSBpbmRleEIgfHwgYW5jZXN0cnlBLmxlbmd0aCAtIGFuY2VzdHJ5Qi5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgbXV0dWFsIGFuY2VzdG9yIGlzIGEgc2VjdGlvbiwgd2UgZmlyc3QgdGVzdCB0byBzZWUgd2hpY2ggc2VjdGlvblxuICBcdC8vIGZyYWdtZW50IGNvbWVzIGZpcnN0XG4gIFx0aWYgKGZyYWdtZW50cyA9IG11dHVhbEFuY2VzdG9yLmZyYWdtZW50cykge1xuICBcdFx0aW5kZXhBID0gZnJhZ21lbnRzLmluZGV4T2YoZnJhZ21lbnRBKTtcbiAgXHRcdGluZGV4QiA9IGZyYWdtZW50cy5pbmRleE9mKGZyYWdtZW50Qik7XG5cbiAgXHRcdHJldHVybiBpbmRleEEgLSBpbmRleEIgfHwgYW5jZXN0cnlBLmxlbmd0aCAtIGFuY2VzdHJ5Qi5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0dGhyb3cgbmV3IEVycm9yKFwiQW4gdW5leHBlY3RlZCBjb25kaXRpb24gd2FzIG1ldCB3aGlsZSBjb21wYXJpbmcgdGhlIHBvc2l0aW9uIG9mIHR3byBjb21wb25lbnRzLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vUmFjdGl2ZUpTL1JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIVwiKTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRQYXJlbnQoaXRlbSkge1xuICBcdHZhciBwYXJlbnRGcmFnbWVudDtcblxuICBcdGlmIChwYXJlbnRGcmFnbWVudCA9IGl0ZW0ucGFyZW50RnJhZ21lbnQpIHtcbiAgXHRcdHJldHVybiBwYXJlbnRGcmFnbWVudC5vd25lcjtcbiAgXHR9XG5cbiAgXHRpZiAoaXRlbS5jb21wb25lbnQgJiYgKHBhcmVudEZyYWdtZW50ID0gaXRlbS5jb21wb25lbnQucGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHRyZXR1cm4gcGFyZW50RnJhZ21lbnQub3duZXI7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QW5jZXN0cnkoaXRlbSkge1xuICBcdHZhciBhbmNlc3RyeSwgYW5jZXN0b3I7XG5cbiAgXHRhbmNlc3RyeSA9IFtpdGVtXTtcblxuICBcdGFuY2VzdG9yID0gZ2V0UGFyZW50KGl0ZW0pO1xuXG4gIFx0d2hpbGUgKGFuY2VzdG9yKSB7XG4gIFx0XHRhbmNlc3RyeS5wdXNoKGFuY2VzdG9yKTtcbiAgXHRcdGFuY2VzdG9yID0gZ2V0UGFyZW50KGFuY2VzdG9yKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYW5jZXN0cnk7XG4gIH1cblxuICB2YXIgc29ydEJ5RG9jdW1lbnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBvdGhlck5vZGUpIHtcbiAgXHR2YXIgYml0bWFzaztcblxuICBcdGlmIChub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gIFx0XHRiaXRtYXNrID0gbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihvdGhlck5vZGUpO1xuICBcdFx0cmV0dXJuIGJpdG1hc2sgJiAyID8gMSA6IC0xO1xuICBcdH1cblxuICBcdC8vIEluIG9sZCBJRSwgd2UgY2FuIHBpZ2d5IGJhY2sgb24gdGhlIG1lY2hhbmlzbSBmb3JcbiAgXHQvLyBjb21wYXJpbmcgY29tcG9uZW50IHBvc2l0aW9uc1xuICBcdHJldHVybiBzb3J0QnlJdGVtUG9zaXRpb24obm9kZSwgb3RoZXJOb2RlKTtcbiAgfTtcblxuICB2YXIgc29ydCA9IGZ1bmN0aW9uICgpIHtcbiAgXHR0aGlzLnNvcnQodGhpcy5faXNDb21wb25lbnRRdWVyeSA/IHNvcnRCeUl0ZW1Qb3NpdGlvbiA6IHNvcnRCeURvY3VtZW50UG9zaXRpb24pO1xuICBcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gIH07XG5cbiAgdmFyIG1ha2VRdWVyeV9kaXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0aWYgKCF0aGlzLl9kaXJ0eSkge1xuICBcdFx0dGhpcy5fZGlydHkgPSB0cnVlO1xuXG4gIFx0XHQvLyBPbmNlIHRoZSBET00gaGFzIGJlZW4gdXBkYXRlZCwgZW5zdXJlIHRoZSBxdWVyeVxuICBcdFx0Ly8gaXMgY29ycmVjdGx5IG9yZGVyZWRcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdF90aGlzLl9zb3J0KCk7XG4gIFx0XHR9KTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIHJlbW92ZSA9IGZ1bmN0aW9uIChub2RlT3JDb21wb25lbnQpIHtcbiAgXHR2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YodGhpcy5faXNDb21wb25lbnRRdWVyeSA/IG5vZGVPckNvbXBvbmVudC5pbnN0YW5jZSA6IG5vZGVPckNvbXBvbmVudCk7XG5cbiAgXHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHR0aGlzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBfbWFrZVF1ZXJ5ID0gbWFrZVF1ZXJ5O1xuICBmdW5jdGlvbiBtYWtlUXVlcnkocmFjdGl2ZSwgc2VsZWN0b3IsIGxpdmUsIGlzQ29tcG9uZW50UXVlcnkpIHtcbiAgXHR2YXIgcXVlcnkgPSBbXTtcblxuICBcdGRlZmluZVByb3BlcnRpZXMocXVlcnksIHtcbiAgXHRcdHNlbGVjdG9yOiB7IHZhbHVlOiBzZWxlY3RvciB9LFxuICBcdFx0bGl2ZTogeyB2YWx1ZTogbGl2ZSB9LFxuXG4gIFx0XHRfaXNDb21wb25lbnRRdWVyeTogeyB2YWx1ZTogaXNDb21wb25lbnRRdWVyeSB9LFxuICBcdFx0X3Rlc3Q6IHsgdmFsdWU6IHRlc3QgfVxuICBcdH0pO1xuXG4gIFx0aWYgKCFsaXZlKSB7XG4gIFx0XHRyZXR1cm4gcXVlcnk7XG4gIFx0fVxuXG4gIFx0ZGVmaW5lUHJvcGVydGllcyhxdWVyeSwge1xuICBcdFx0Y2FuY2VsOiB7IHZhbHVlOiBtYWtlUXVlcnlfY2FuY2VsIH0sXG5cbiAgXHRcdF9yb290OiB7IHZhbHVlOiByYWN0aXZlIH0sXG4gIFx0XHRfc29ydDogeyB2YWx1ZTogc29ydCB9LFxuICBcdFx0X21ha2VEaXJ0eTogeyB2YWx1ZTogbWFrZVF1ZXJ5X2RpcnR5IH0sXG4gIFx0XHRfcmVtb3ZlOiB7IHZhbHVlOiByZW1vdmUgfSxcblxuICBcdFx0X2RpcnR5OiB7IHZhbHVlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUgfVxuICBcdH0pO1xuXG4gIFx0cmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maW5kQWxsID0gUmFjdGl2ZSRmaW5kQWxsO1xuICBmdW5jdGlvbiBSYWN0aXZlJGZpbmRBbGwoc2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgXHR2YXIgbGl2ZVF1ZXJpZXMsIHF1ZXJ5O1xuXG4gIFx0aWYgKCF0aGlzLmVsKSB7XG4gIFx0XHRyZXR1cm4gW107XG4gIFx0fVxuXG4gIFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFx0bGl2ZVF1ZXJpZXMgPSB0aGlzLl9saXZlUXVlcmllcztcblxuICBcdC8vIFNob3J0Y3V0OiBpZiB3ZSdyZSBtYWludGFpbmluZyBhIGxpdmUgcXVlcnkgd2l0aCB0aGlzXG4gIFx0Ly8gc2VsZWN0b3IsIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHBhcmFsbGVsIERPTVxuICBcdGlmIChxdWVyeSA9IGxpdmVRdWVyaWVzW3NlbGVjdG9yXSkge1xuXG4gIFx0XHQvLyBFaXRoZXIgcmV0dXJuIHRoZSBleGFjdCBzYW1lIHF1ZXJ5LCBvciAoaWYgbm90IGxpdmUpIGEgc25hcHNob3RcbiAgXHRcdHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMubGl2ZSA/IHF1ZXJ5IDogcXVlcnkuc2xpY2UoKTtcbiAgXHR9XG5cbiAgXHRxdWVyeSA9IF9tYWtlUXVlcnkodGhpcywgc2VsZWN0b3IsICEhb3B0aW9ucy5saXZlLCBmYWxzZSk7XG5cbiAgXHQvLyBBZGQgdGhpcyB0byB0aGUgbGlzdCBvZiBsaXZlIHF1ZXJpZXMgUmFjdGl2ZSBuZWVkcyB0byBtYWludGFpbixcbiAgXHQvLyBpZiBhcHBsaWNhYmxlXG4gIFx0aWYgKHF1ZXJ5LmxpdmUpIHtcbiAgXHRcdGxpdmVRdWVyaWVzLnB1c2goc2VsZWN0b3IpO1xuICBcdFx0bGl2ZVF1ZXJpZXNbXCJfXCIgKyBzZWxlY3Rvcl0gPSBxdWVyeTtcbiAgXHR9XG5cbiAgXHR0aGlzLmZyYWdtZW50LmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHRyZXR1cm4gcXVlcnk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzID0gUmFjdGl2ZSRmaW5kQWxsQ29tcG9uZW50cztcbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQWxsQ29tcG9uZW50cyhzZWxlY3Rvciwgb3B0aW9ucykge1xuICBcdHZhciBsaXZlUXVlcmllcywgcXVlcnk7XG5cbiAgXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgXHRsaXZlUXVlcmllcyA9IHRoaXMuX2xpdmVDb21wb25lbnRRdWVyaWVzO1xuXG4gIFx0Ly8gU2hvcnRjdXQ6IGlmIHdlJ3JlIG1haW50YWluaW5nIGEgbGl2ZSBxdWVyeSB3aXRoIHRoaXNcbiAgXHQvLyBzZWxlY3Rvciwgd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSB0aGUgcGFyYWxsZWwgRE9NXG4gIFx0aWYgKHF1ZXJ5ID0gbGl2ZVF1ZXJpZXNbc2VsZWN0b3JdKSB7XG5cbiAgXHRcdC8vIEVpdGhlciByZXR1cm4gdGhlIGV4YWN0IHNhbWUgcXVlcnksIG9yIChpZiBub3QgbGl2ZSkgYSBzbmFwc2hvdFxuICBcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5saXZlID8gcXVlcnkgOiBxdWVyeS5zbGljZSgpO1xuICBcdH1cblxuICBcdHF1ZXJ5ID0gX21ha2VRdWVyeSh0aGlzLCBzZWxlY3RvciwgISFvcHRpb25zLmxpdmUsIHRydWUpO1xuXG4gIFx0Ly8gQWRkIHRoaXMgdG8gdGhlIGxpc3Qgb2YgbGl2ZSBxdWVyaWVzIFJhY3RpdmUgbmVlZHMgdG8gbWFpbnRhaW4sXG4gIFx0Ly8gaWYgYXBwbGljYWJsZVxuICBcdGlmIChxdWVyeS5saXZlKSB7XG4gIFx0XHRsaXZlUXVlcmllcy5wdXNoKHNlbGVjdG9yKTtcbiAgXHRcdGxpdmVRdWVyaWVzW1wiX1wiICsgc2VsZWN0b3JdID0gcXVlcnk7XG4gIFx0fVxuXG4gIFx0dGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmluZENvbXBvbmVudCA9IFJhY3RpdmUkZmluZENvbXBvbmVudDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJGZpbmRDb21wb25lbnQoc2VsZWN0b3IpIHtcbiAgXHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KHNlbGVjdG9yKTtcbiAgfVxuXG4gIHZhciBmaW5kQ29udGFpbmVyID0gUmFjdGl2ZSRmaW5kQ29udGFpbmVyO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZENvbnRhaW5lcihzZWxlY3Rvcikge1xuICBcdGlmICh0aGlzLmNvbnRhaW5lcikge1xuICBcdFx0aWYgKHRoaXMuY29udGFpbmVyLmNvbXBvbmVudCAmJiB0aGlzLmNvbnRhaW5lci5jb21wb25lbnQubmFtZSA9PT0gc2VsZWN0b3IpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyLmZpbmRDb250YWluZXIoc2VsZWN0b3IpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGZpbmRQYXJlbnQgPSBSYWN0aXZlJGZpbmRQYXJlbnQ7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kUGFyZW50KHNlbGVjdG9yKSB7XG5cbiAgXHRpZiAodGhpcy5wYXJlbnQpIHtcbiAgXHRcdGlmICh0aGlzLnBhcmVudC5jb21wb25lbnQgJiYgdGhpcy5wYXJlbnQuY29tcG9uZW50Lm5hbWUgPT09IHNlbGVjdG9yKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLnBhcmVudDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLnBhcmVudC5maW5kUGFyZW50KHNlbGVjdG9yKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBldmVudFN0YWNrID0ge1xuICBcdGVucXVldWU6IGZ1bmN0aW9uIChyYWN0aXZlLCBldmVudCkge1xuICBcdFx0aWYgKHJhY3RpdmUuZXZlbnQpIHtcbiAgXHRcdFx0cmFjdGl2ZS5fZXZlbnRRdWV1ZSA9IHJhY3RpdmUuX2V2ZW50UXVldWUgfHwgW107XG4gIFx0XHRcdHJhY3RpdmUuX2V2ZW50UXVldWUucHVzaChyYWN0aXZlLmV2ZW50KTtcbiAgXHRcdH1cbiAgXHRcdHJhY3RpdmUuZXZlbnQgPSBldmVudDtcbiAgXHR9LFxuICBcdGRlcXVldWU6IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG4gIFx0XHRpZiAocmFjdGl2ZS5fZXZlbnRRdWV1ZSAmJiByYWN0aXZlLl9ldmVudFF1ZXVlLmxlbmd0aCkge1xuICBcdFx0XHRyYWN0aXZlLmV2ZW50ID0gcmFjdGl2ZS5fZXZlbnRRdWV1ZS5wb3AoKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGRlbGV0ZSByYWN0aXZlLmV2ZW50O1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgc2hhcmVkX2V2ZW50U3RhY2sgPSBldmVudFN0YWNrO1xuXG4gIHZhciBzaGFyZWRfZmlyZUV2ZW50ID0gZmlyZUV2ZW50O1xuXG4gIGZ1bmN0aW9uIGZpcmVFdmVudChyYWN0aXZlLCBldmVudE5hbWUpIHtcbiAgXHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cbiAgXHRpZiAoIWV2ZW50TmFtZSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmICghb3B0aW9ucy5ldmVudCkge1xuICBcdFx0b3B0aW9ucy5ldmVudCA9IHtcbiAgXHRcdFx0bmFtZTogZXZlbnROYW1lLFxuICBcdFx0XHQvLyB1bnRpbCBldmVudCBub3QgaW5jbHVkZWQgYXMgYXJndW1lbnQgZGVmYXVsdFxuICBcdFx0XHRfbm9Bcmc6IHRydWVcbiAgXHRcdH07XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG9wdGlvbnMuZXZlbnQubmFtZSA9IGV2ZW50TmFtZTtcbiAgXHR9XG5cbiAgXHR2YXIgZXZlbnROYW1lcyA9IGdldEtleXBhdGgoZXZlbnROYW1lKS53aWxkY2FyZE1hdGNoZXMoKTtcbiAgXHRmaXJlRXZlbnRBcyhyYWN0aXZlLCBldmVudE5hbWVzLCBvcHRpb25zLmV2ZW50LCBvcHRpb25zLmFyZ3MsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUV2ZW50QXMocmFjdGl2ZSwgZXZlbnROYW1lcywgZXZlbnQsIGFyZ3MpIHtcbiAgXHR2YXIgaW5pdGlhbEZpcmUgPSBhcmd1bWVudHNbNF0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzRdO1xuXG4gIFx0dmFyIHN1YnNjcmliZXJzLFxuICBcdCAgICBpLFxuICBcdCAgICBidWJibGUgPSB0cnVlO1xuXG4gIFx0c2hhcmVkX2V2ZW50U3RhY2suZW5xdWV1ZShyYWN0aXZlLCBldmVudCk7XG5cbiAgXHRmb3IgKGkgPSBldmVudE5hbWVzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgXHRcdHN1YnNjcmliZXJzID0gcmFjdGl2ZS5fc3Vic1tldmVudE5hbWVzW2ldXTtcblxuICBcdFx0aWYgKHN1YnNjcmliZXJzKSB7XG4gIFx0XHRcdGJ1YmJsZSA9IG5vdGlmeVN1YnNjcmliZXJzKHJhY3RpdmUsIHN1YnNjcmliZXJzLCBldmVudCwgYXJncykgJiYgYnViYmxlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHNoYXJlZF9ldmVudFN0YWNrLmRlcXVldWUocmFjdGl2ZSk7XG5cbiAgXHRpZiAocmFjdGl2ZS5wYXJlbnQgJiYgYnViYmxlKSB7XG5cbiAgXHRcdGlmIChpbml0aWFsRmlyZSAmJiByYWN0aXZlLmNvbXBvbmVudCkge1xuICBcdFx0XHR2YXIgZnVsbE5hbWUgPSByYWN0aXZlLmNvbXBvbmVudC5uYW1lICsgXCIuXCIgKyBldmVudE5hbWVzW2V2ZW50TmFtZXMubGVuZ3RoIC0gMV07XG4gIFx0XHRcdGV2ZW50TmFtZXMgPSBnZXRLZXlwYXRoKGZ1bGxOYW1lKS53aWxkY2FyZE1hdGNoZXMoKTtcblxuICBcdFx0XHRpZiAoZXZlbnQpIHtcbiAgXHRcdFx0XHRldmVudC5jb21wb25lbnQgPSByYWN0aXZlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGZpcmVFdmVudEFzKHJhY3RpdmUucGFyZW50LCBldmVudE5hbWVzLCBldmVudCwgYXJncyk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5U3Vic2NyaWJlcnMocmFjdGl2ZSwgc3Vic2NyaWJlcnMsIGV2ZW50LCBhcmdzKSB7XG4gIFx0dmFyIG9yaWdpbmFsRXZlbnQgPSBudWxsLFxuICBcdCAgICBzdG9wRXZlbnQgPSBmYWxzZTtcblxuICBcdGlmIChldmVudCAmJiAhZXZlbnQuX25vQXJnKSB7XG4gIFx0XHRhcmdzID0gW2V2ZW50XS5jb25jYXQoYXJncyk7XG4gIFx0fVxuXG4gIFx0Ly8gc3Vic2NyaWJlcnMgY2FuIGJlIG1vZGlmaWVkIGluZmxpZ2h0LCBlLmcuIFwib25jZVwiIGZ1bmN0aW9uYWxpdHlcbiAgXHQvLyBzbyB3ZSBuZWVkIHRvIGNvcHkgdG8gbWFrZSBzdXJlIGV2ZXJ5b25lIGdldHMgY2FsbGVkXG4gIFx0c3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5zbGljZSgpO1xuXG4gIFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHN1YnNjcmliZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRpZiAoc3Vic2NyaWJlcnNbaV0uYXBwbHkocmFjdGl2ZSwgYXJncykgPT09IGZhbHNlKSB7XG4gIFx0XHRcdHN0b3BFdmVudCA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKGV2ZW50ICYmICFldmVudC5fbm9BcmcgJiYgc3RvcEV2ZW50ICYmIChvcmlnaW5hbEV2ZW50ID0gZXZlbnQub3JpZ2luYWwpKSB7XG4gIFx0XHRvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0ICYmIG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgXHRcdG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uICYmIG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuICFzdG9wRXZlbnQ7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpcmUgPSBSYWN0aXZlJGZpcmU7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmlyZShldmVudE5hbWUpIHtcblxuICBcdHZhciBvcHRpb25zID0ge1xuICBcdFx0YXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICBcdH07XG5cbiAgXHRzaGFyZWRfZmlyZUV2ZW50KHRoaXMsIGV2ZW50TmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2dldCA9IFJhY3RpdmUkZ2V0O1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgXHRjYXB0dXJlOiB0cnVlLCAvLyB0b3AtbGV2ZWwgY2FsbHMgc2hvdWxkIGJlIGludGVyY2VwdGVkXG4gIFx0bm9VbndyYXA6IHRydWUsIC8vIHdyYXBwZWQgdmFsdWVzIHNob3VsZCBOT1QgYmUgdW53cmFwcGVkXG4gIFx0ZnVsbFJvb3RHZXQ6IHRydWUgLy8gcm9vdCBnZXQgc2hvdWxkIHJldHVybiBtYXBwaW5nc1xuICB9O1xuICBmdW5jdGlvbiBSYWN0aXZlJGdldChrZXlwYXRoKSB7XG4gIFx0dmFyIHZhbHVlO1xuXG4gIFx0a2V5cGF0aCA9IGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKTtcbiAgXHR2YWx1ZSA9IHRoaXMudmlld21vZGVsLmdldChrZXlwYXRoLCBvcHRpb25zKTtcblxuICBcdC8vIENyZWF0ZSBpbnRlci1jb21wb25lbnQgYmluZGluZywgaWYgbmVjZXNzYXJ5XG4gIFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgdGhpcy5wYXJlbnQgJiYgIXRoaXMuaXNvbGF0ZWQpIHtcbiAgXHRcdGlmIChzaGFyZWRfcmVzb2x2ZVJlZih0aGlzLCBrZXlwYXRoLnN0ciwgdGhpcy5jb21wb25lbnQucGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHRcdC8vIGNyZWF0ZXMgYmluZGluZyBhcyBzaWRlLWVmZmVjdCwgaWYgYXBwcm9wcmlhdGVcbiAgXHRcdFx0dmFsdWUgPSB0aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdmFyIGluc2VydCA9IFJhY3RpdmUkaW5zZXJ0O1xuXG4gIHZhciBpbnNlcnRIb29rID0gbmV3IGhvb2tzX0hvb2soXCJpbnNlcnRcIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkaW5zZXJ0KHRhcmdldCwgYW5jaG9yKSB7XG4gIFx0aWYgKCF0aGlzLmZyYWdtZW50LnJlbmRlcmVkKSB7XG4gIFx0XHQvLyBUT0RPIGNyZWF0ZSwgYW5kIGxpbmsgdG8sIGRvY3VtZW50YXRpb24gZXhwbGFpbmluZyB0aGlzXG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgQVBJIGhhcyBjaGFuZ2VkIC0geW91IG11c3QgY2FsbCBgcmFjdGl2ZS5yZW5kZXIodGFyZ2V0WywgYW5jaG9yXSlgIHRvIHJlbmRlciB5b3VyIFJhY3RpdmUgaW5zdGFuY2UuIE9uY2UgcmVuZGVyZWQgeW91IGNhbiB1c2UgYHJhY3RpdmUuaW5zZXJ0KClgLlwiKTtcbiAgXHR9XG5cbiAgXHR0YXJnZXQgPSBnZXRFbGVtZW50KHRhcmdldCk7XG4gIFx0YW5jaG9yID0gZ2V0RWxlbWVudChhbmNob3IpIHx8IG51bGw7XG5cbiAgXHRpZiAoIXRhcmdldCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3Qgc3BlY2lmeSBhIHZhbGlkIHRhcmdldCB0byBpbnNlcnQgaW50b1wiKTtcbiAgXHR9XG5cbiAgXHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuZGV0YWNoKCksIGFuY2hvcik7XG4gIFx0dGhpcy5lbCA9IHRhcmdldDtcblxuICBcdCh0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fIHx8ICh0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fID0gW10pKS5wdXNoKHRoaXMpO1xuICBcdHRoaXMuZGV0YWNoZWQgPSBudWxsO1xuXG4gIFx0ZmlyZUluc2VydEhvb2sodGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlSW5zZXJ0SG9vayhyYWN0aXZlKSB7XG4gIFx0aW5zZXJ0SG9vay5maXJlKHJhY3RpdmUpO1xuXG4gIFx0cmFjdGl2ZS5maW5kQWxsQ29tcG9uZW50cyhcIipcIikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgXHRcdGZpcmVJbnNlcnRIb29rKGNoaWxkLmluc3RhbmNlKTtcbiAgXHR9KTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfbWVyZ2UgPSBSYWN0aXZlJG1lcmdlO1xuICBmdW5jdGlvbiBSYWN0aXZlJG1lcmdlKGtleXBhdGgsIGFycmF5LCBvcHRpb25zKSB7XG4gIFx0dmFyIGN1cnJlbnRBcnJheSwgcHJvbWlzZTtcblxuICBcdGtleXBhdGggPSBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSk7XG4gIFx0Y3VycmVudEFycmF5ID0gdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0Ly8gSWYgZWl0aGVyIHRoZSBleGlzdGluZyB2YWx1ZSBvciB0aGUgbmV3IHZhbHVlIGlzbid0IGFuXG4gIFx0Ly8gYXJyYXksIGp1c3QgZG8gYSByZWd1bGFyIHNldFxuICBcdGlmICghaXNBcnJheShjdXJyZW50QXJyYXkpIHx8ICFpc0FycmF5KGFycmF5KSkge1xuICBcdFx0cmV0dXJuIHRoaXMuc2V0KGtleXBhdGgsIGFycmF5LCBvcHRpb25zICYmIG9wdGlvbnMuY29tcGxldGUpO1xuICBcdH1cblxuICBcdC8vIE1hbmFnZSB0cmFuc2l0aW9uc1xuICBcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcbiAgXHR0aGlzLnZpZXdtb2RlbC5tZXJnZShrZXlwYXRoLCBjdXJyZW50QXJyYXksIGFycmF5LCBvcHRpb25zKTtcbiAgXHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgdmFyIE9ic2VydmVyID0gZnVuY3Rpb24gKHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcbiAgXHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgXHR0aGlzLmRlZmVyID0gb3B0aW9ucy5kZWZlcjtcblxuICBcdC8vIGRlZmF1bHQgdG8gcm9vdCBhcyBjb250ZXh0LCBidXQgYWxsb3cgaXQgdG8gYmUgb3ZlcnJpZGRlblxuICBcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID8gb3B0aW9ucy5jb250ZXh0IDogcmFjdGl2ZTtcbiAgfTtcblxuICBPYnNlcnZlci5wcm90b3R5cGUgPSB7XG4gIFx0aW5pdDogZnVuY3Rpb24gKGltbWVkaWF0ZSkge1xuICBcdFx0dGhpcy52YWx1ZSA9IHRoaXMucm9vdC5nZXQodGhpcy5rZXlwYXRoLnN0cik7XG5cbiAgXHRcdGlmIChpbW1lZGlhdGUgIT09IGZhbHNlKSB7XG4gIFx0XHRcdHRoaXMudXBkYXRlKCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLm9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0aWYgKCFpc0VxdWFsKHZhbHVlLCB0aGlzLnZhbHVlKSkge1xuICBcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdFx0aWYgKHRoaXMuZGVmZXIgJiYgdGhpcy5yZWFkeSkge1xuICBcdFx0XHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gX3RoaXMudXBkYXRlKCk7XG4gIFx0XHRcdFx0fSk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAgXHRcdGlmICh0aGlzLnVwZGF0aW5nKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cbiAgXHRcdHRoaXMuY2FsbGJhY2suY2FsbCh0aGlzLmNvbnRleHQsIHRoaXMudmFsdWUsIHRoaXMub2xkVmFsdWUsIHRoaXMua2V5cGF0aC5zdHIpO1xuICBcdFx0dGhpcy5vbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG5cbiAgXHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIG9ic2VydmVfT2JzZXJ2ZXIgPSBPYnNlcnZlcjtcblxuICB2YXIgb2JzZXJ2ZV9nZXRQYXR0ZXJuID0gZ2V0UGF0dGVybjtcbiAgZnVuY3Rpb24gZ2V0UGF0dGVybihyYWN0aXZlLCBwYXR0ZXJuKSB7XG4gIFx0dmFyIG1hdGNoaW5nS2V5cGF0aHMsIHZhbHVlcztcblxuICBcdG1hdGNoaW5nS2V5cGF0aHMgPSBnZXRNYXRjaGluZ0tleXBhdGhzKHJhY3RpdmUsIHBhdHRlcm4pO1xuXG4gIFx0dmFsdWVzID0ge307XG4gIFx0bWF0Y2hpbmdLZXlwYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YWx1ZXNba2V5cGF0aC5zdHJdID0gcmFjdGl2ZS5nZXQoa2V5cGF0aC5zdHIpO1xuICBcdH0pO1xuXG4gIFx0cmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIHZhciBQYXR0ZXJuT2JzZXJ2ZXIsXG4gICAgICBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICBQYXR0ZXJuT2JzZXJ2ZXIgPSBmdW5jdGlvbiAocmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuXG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICBcdHRoaXMuZGVmZXIgPSBvcHRpb25zLmRlZmVyO1xuXG4gIFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHR0aGlzLnJlZ2V4ID0gbmV3IFJlZ0V4cChcIl5cIiArIGtleXBhdGguc3RyLnJlcGxhY2UoL1xcLi9nLCBcIlxcXFwuXCIpLnJlcGxhY2UoL1xcKi9nLCBcIihbXlxcXFwuXSspXCIpICsgXCIkXCIpO1xuICBcdHRoaXMudmFsdWVzID0ge307XG5cbiAgXHRpZiAodGhpcy5kZWZlcikge1xuICBcdFx0dGhpcy5wcm94aWVzID0gW107XG4gIFx0fVxuXG4gIFx0Ly8gZGVmYXVsdCB0byByb290IGFzIGNvbnRleHQsIGJ1dCBhbGxvdyBpdCB0byBiZSBvdmVycmlkZGVuXG4gIFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPyBvcHRpb25zLmNvbnRleHQgOiByYWN0aXZlO1xuICB9O1xuXG4gIFBhdHRlcm5PYnNlcnZlci5wcm90b3R5cGUgPSB7XG4gIFx0aW5pdDogZnVuY3Rpb24gKGltbWVkaWF0ZSkge1xuICBcdFx0dmFyIHZhbHVlcywga2V5cGF0aDtcblxuICBcdFx0dmFsdWVzID0gb2JzZXJ2ZV9nZXRQYXR0ZXJuKHRoaXMucm9vdCwgdGhpcy5rZXlwYXRoKTtcblxuICBcdFx0aWYgKGltbWVkaWF0ZSAhPT0gZmFsc2UpIHtcbiAgXHRcdFx0Zm9yIChrZXlwYXRoIGluIHZhbHVlcykge1xuICBcdFx0XHRcdGlmICh2YWx1ZXMuaGFzT3duUHJvcGVydHkoa2V5cGF0aCkpIHtcbiAgXHRcdFx0XHRcdHRoaXMudXBkYXRlKGdldEtleXBhdGgoa2V5cGF0aCkpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciB2YWx1ZXM7XG5cbiAgXHRcdGlmIChrZXlwYXRoLmlzUGF0dGVybikge1xuICBcdFx0XHR2YWx1ZXMgPSBvYnNlcnZlX2dldFBhdHRlcm4odGhpcy5yb290LCBrZXlwYXRoKTtcblxuICBcdFx0XHRmb3IgKGtleXBhdGggaW4gdmFsdWVzKSB7XG4gIFx0XHRcdFx0aWYgKHZhbHVlcy5oYXNPd25Qcm9wZXJ0eShrZXlwYXRoKSkge1xuICBcdFx0XHRcdFx0dGhpcy51cGRhdGUoZ2V0S2V5cGF0aChrZXlwYXRoKSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBhcnJheSBtdXRhdGlvbiBzaG91bGQgbm90IHRyaWdnZXIgYGFycmF5LipgXG4gIFx0XHQvLyBwYXR0ZXJuIG9ic2VydmVyIHdpdGggYGFycmF5Lmxlbmd0aGBcbiAgXHRcdGlmICh0aGlzLnJvb3Qudmlld21vZGVsLmltcGxpY2l0Q2hhbmdlc1trZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5kZWZlciAmJiB0aGlzLnJlYWR5KSB7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIF90aGlzLmdldFByb3h5KGtleXBhdGgpLnVwZGF0ZSgpO1xuICBcdFx0XHR9KTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnJlYWxseVVwZGF0ZShrZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0cmVhbGx5VXBkYXRlOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFyIGtleXBhdGhTdHIsIHZhbHVlLCBrZXlzLCBhcmdzO1xuXG4gIFx0XHRrZXlwYXRoU3RyID0ga2V5cGF0aC5zdHI7XG4gIFx0XHR2YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0XHQvLyBQcmV2ZW50IGluZmluaXRlIGxvb3BzXG4gIFx0XHRpZiAodGhpcy51cGRhdGluZykge1xuICBcdFx0XHR0aGlzLnZhbHVlc1trZXlwYXRoU3RyXSA9IHZhbHVlO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXG4gIFx0XHRpZiAoIWlzRXF1YWwodmFsdWUsIHRoaXMudmFsdWVzW2tleXBhdGhTdHJdKSB8fCAhdGhpcy5yZWFkeSkge1xuICBcdFx0XHRrZXlzID0gc2xpY2UuY2FsbCh0aGlzLnJlZ2V4LmV4ZWMoa2V5cGF0aFN0ciksIDEpO1xuICBcdFx0XHRhcmdzID0gW3ZhbHVlLCB0aGlzLnZhbHVlc1trZXlwYXRoU3RyXSwga2V5cGF0aFN0cl0uY29uY2F0KGtleXMpO1xuXG4gIFx0XHRcdHRoaXMudmFsdWVzW2tleXBhdGhTdHJdID0gdmFsdWU7XG4gIFx0XHRcdHRoaXMuY2FsbGJhY2suYXBwbHkodGhpcy5jb250ZXh0LCBhcmdzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuICBcdH0sXG5cbiAgXHRnZXRQcm94eTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdGlmICghdGhpcy5wcm94aWVzW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHR0aGlzLnByb3hpZXNba2V5cGF0aC5zdHJdID0ge1xuICBcdFx0XHRcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0cmV0dXJuIF90aGlzLnJlYWxseVVwZGF0ZShrZXlwYXRoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLnByb3hpZXNba2V5cGF0aC5zdHJdO1xuICBcdH1cbiAgfTtcblxuICB2YXIgb2JzZXJ2ZV9QYXR0ZXJuT2JzZXJ2ZXIgPSBQYXR0ZXJuT2JzZXJ2ZXI7XG5cbiAgdmFyIG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUgPSBnZXRPYnNlcnZlckZhY2FkZTtcbiAgdmFyIGVtcHR5T2JqZWN0ID0ge307XG4gIGZ1bmN0aW9uIGdldE9ic2VydmVyRmFjYWRlKHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIFx0dmFyIG9ic2VydmVyLCBpc1BhdHRlcm5PYnNlcnZlciwgY2FuY2VsbGVkO1xuXG4gIFx0a2V5cGF0aCA9IGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKTtcbiAgXHRvcHRpb25zID0gb3B0aW9ucyB8fCBlbXB0eU9iamVjdDtcblxuICBcdC8vIHBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSB0cmVhdGVkIGRpZmZlcmVudGx5XG4gIFx0aWYgKGtleXBhdGguaXNQYXR0ZXJuKSB7XG4gIFx0XHRvYnNlcnZlciA9IG5ldyBvYnNlcnZlX1BhdHRlcm5PYnNlcnZlcihyYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICBcdFx0aXNQYXR0ZXJuT2JzZXJ2ZXIgPSB0cnVlO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRvYnNlcnZlciA9IG5ldyBvYnNlcnZlX09ic2VydmVyKHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHRvYnNlcnZlci5pbml0KG9wdGlvbnMuaW5pdCk7XG4gIFx0cmFjdGl2ZS52aWV3bW9kZWwucmVnaXN0ZXIoa2V5cGF0aCwgb2JzZXJ2ZXIsIGlzUGF0dGVybk9ic2VydmVyID8gXCJwYXR0ZXJuT2JzZXJ2ZXJzXCIgOiBcIm9ic2VydmVyc1wiKTtcblxuICBcdC8vIFRoaXMgZmxhZyBhbGxvd3Mgb2JzZXJ2ZXJzIHRvIGluaXRpYWxpc2UgZXZlbiB3aXRoIHVuZGVmaW5lZCB2YWx1ZXNcbiAgXHRvYnNlcnZlci5yZWFkeSA9IHRydWU7XG5cbiAgXHR2YXIgZmFjYWRlID0ge1xuICBcdFx0Y2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHZhciBpbmRleDtcblxuICBcdFx0XHRpZiAoY2FuY2VsbGVkKSB7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGlzUGF0dGVybk9ic2VydmVyKSB7XG4gIFx0XHRcdFx0aW5kZXggPSByYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xuXG4gIFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwucGF0dGVybk9ic2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnVucmVnaXN0ZXIoa2V5cGF0aCwgb2JzZXJ2ZXIsIFwicGF0dGVybk9ic2VydmVyc1wiKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC51bnJlZ2lzdGVyKGtleXBhdGgsIG9ic2VydmVyLCBcIm9ic2VydmVyc1wiKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRjYW5jZWxsZWQgPSB0cnVlO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRyYWN0aXZlLl9vYnNlcnZlcnMucHVzaChmYWNhZGUpO1xuICBcdHJldHVybiBmYWNhZGU7XG4gIH1cblxuICB2YXIgb2JzZXJ2ZSA9IFJhY3RpdmUkb2JzZXJ2ZTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRvYnNlcnZlKGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG5cbiAgXHR2YXIgb2JzZXJ2ZXJzLCBtYXAsIGtleXBhdGhzLCBpO1xuXG4gIFx0Ly8gQWxsb3cgYSBtYXAgb2Yga2V5cGF0aHMgdG8gaGFuZGxlcnNcbiAgXHRpZiAoaXNPYmplY3Qoa2V5cGF0aCkpIHtcbiAgXHRcdG9wdGlvbnMgPSBjYWxsYmFjaztcbiAgXHRcdG1hcCA9IGtleXBhdGg7XG5cbiAgXHRcdG9ic2VydmVycyA9IFtdO1xuXG4gIFx0XHRmb3IgKGtleXBhdGggaW4gbWFwKSB7XG4gIFx0XHRcdGlmIChtYXAuaGFzT3duUHJvcGVydHkoa2V5cGF0aCkpIHtcbiAgXHRcdFx0XHRjYWxsYmFjayA9IG1hcFtrZXlwYXRoXTtcbiAgXHRcdFx0XHRvYnNlcnZlcnMucHVzaCh0aGlzLm9ic2VydmUoa2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHRjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHR3aGlsZSAob2JzZXJ2ZXJzLmxlbmd0aCkge1xuICBcdFx0XHRcdFx0b2JzZXJ2ZXJzLnBvcCgpLmNhbmNlbCgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHQvLyBBbGxvdyBgcmFjdGl2ZS5vYnNlcnZlKCBjYWxsYmFjayApYCAtIGkuZS4gb2JzZXJ2ZSBlbnRpcmUgbW9kZWxcbiAgXHRpZiAodHlwZW9mIGtleXBhdGggPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0b3B0aW9ucyA9IGNhbGxiYWNrO1xuICBcdFx0Y2FsbGJhY2sgPSBrZXlwYXRoO1xuICBcdFx0a2V5cGF0aCA9IFwiXCI7XG5cbiAgXHRcdHJldHVybiBvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlKHRoaXMsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHRrZXlwYXRocyA9IGtleXBhdGguc3BsaXQoXCIgXCIpO1xuXG4gIFx0Ly8gU2luZ2xlIGtleXBhdGhcbiAgXHRpZiAoa2V5cGF0aHMubGVuZ3RoID09PSAxKSB7XG4gIFx0XHRyZXR1cm4gb2JzZXJ2ZV9nZXRPYnNlcnZlckZhY2FkZSh0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0Ly8gTXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGtleXBhdGhzXG4gIFx0b2JzZXJ2ZXJzID0gW107XG5cbiAgXHRpID0ga2V5cGF0aHMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGtleXBhdGggPSBrZXlwYXRoc1tpXTtcblxuICBcdFx0aWYgKGtleXBhdGgpIHtcbiAgXHRcdFx0b2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZV9nZXRPYnNlcnZlckZhY2FkZSh0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHRjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0d2hpbGUgKG9ic2VydmVycy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRvYnNlcnZlcnMucG9wKCkuY2FuY2VsKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgdmFyIG9ic2VydmVPbmNlID0gUmFjdGl2ZSRvYnNlcnZlT25jZTtcblxuICBmdW5jdGlvbiBSYWN0aXZlJG9ic2VydmVPbmNlKHByb3BlcnR5LCBjYWxsYmFjaywgb3B0aW9ucykge1xuXG4gIFx0dmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlKHByb3BlcnR5LCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBcdFx0b2JzZXJ2ZXIuY2FuY2VsKCk7XG4gIFx0fSwgeyBpbml0OiBmYWxzZSwgZGVmZXI6IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWZlciB9KTtcblxuICBcdHJldHVybiBvYnNlcnZlcjtcbiAgfVxuXG4gIHZhciBzaGFyZWRfdHJpbSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKTtcbiAgfTtcblxuICB2YXIgbm90RW1wdHlTdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ciAhPT0gXCJcIjtcbiAgfTtcblxuICB2YXIgb2ZmID0gUmFjdGl2ZSRvZmY7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkb2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIGV2ZW50TmFtZXM7XG5cbiAgXHQvLyBpZiBubyBhcmd1bWVudHMgc3BlY2lmaWVkLCByZW1vdmUgYWxsIGNhbGxiYWNrc1xuICBcdGlmICghZXZlbnROYW1lKSB7XG4gIFx0XHQvLyBUT0RPIHVzZSB0aGlzIGNvZGUgaW5zdGVhZCwgb25jZSB0aGUgZm9sbG93aW5nIGlzc3VlIGhhcyBiZWVuIHJlc29sdmVkXG4gIFx0XHQvLyBpbiBQaGFudG9tSlMgKHRlc3RzIGFyZSB1bnBhc3NhYmxlIG90aGVyd2lzZSEpXG4gIFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTg1NlxuICBcdFx0Ly8gZGVmaW5lUHJvcGVydHkoIHRoaXMsICdfc3VicycsIHsgdmFsdWU6IGNyZWF0ZSggbnVsbCApLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIFx0XHRmb3IgKGV2ZW50TmFtZSBpbiB0aGlzLl9zdWJzKSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9zdWJzW2V2ZW50TmFtZV07XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgbmFtZXNcbiAgXHRcdGV2ZW50TmFtZXMgPSBldmVudE5hbWUuc3BsaXQoXCIgXCIpLm1hcChzaGFyZWRfdHJpbSkuZmlsdGVyKG5vdEVtcHR5U3RyaW5nKTtcblxuICBcdFx0ZXZlbnROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgXHRcdFx0dmFyIHN1YnNjcmliZXJzLCBpbmRleDtcblxuICBcdFx0XHQvLyBJZiB3ZSBoYXZlIHN1YnNjcmliZXJzIGZvciB0aGlzIGV2ZW50Li4uXG4gIFx0XHRcdGlmIChzdWJzY3JpYmVycyA9IF90aGlzLl9zdWJzW2V2ZW50TmFtZV0pIHtcbiAgXHRcdFx0XHQvLyAuLi5pZiBhIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIG9ubHkgcmVtb3ZlIHRoYXRcbiAgXHRcdFx0XHRpZiAoY2FsbGJhY2spIHtcbiAgXHRcdFx0XHRcdGluZGV4ID0gc3Vic2NyaWJlcnMuaW5kZXhPZihjYWxsYmFjayk7XG4gIFx0XHRcdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRcdFx0XHRcdHN1YnNjcmliZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHJlbW92ZSBhbGwgY2FsbGJhY2tzXG4gIFx0XHRcdFx0ZWxzZSB7XG4gIFx0XHRcdFx0XHRfdGhpcy5fc3Vic1tldmVudE5hbWVdID0gW107XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBvbiA9IFJhY3RpdmUkb247XG4gIGZ1bmN0aW9uIFJhY3RpdmUkb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgbGlzdGVuZXJzLCBuLCBldmVudE5hbWVzO1xuXG4gIFx0Ly8gYWxsb3cgbXV0bGlwbGUgbGlzdGVuZXJzIHRvIGJlIGJvdW5kIGluIG9uZSBnb1xuICBcdGlmICh0eXBlb2YgZXZlbnROYW1lID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRsaXN0ZW5lcnMgPSBbXTtcblxuICBcdFx0Zm9yIChuIGluIGV2ZW50TmFtZSkge1xuICBcdFx0XHRpZiAoZXZlbnROYW1lLmhhc093blByb3BlcnR5KG4pKSB7XG4gIFx0XHRcdFx0bGlzdGVuZXJzLnB1c2godGhpcy5vbihuLCBldmVudE5hbWVbbl0pKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHRjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHR2YXIgbGlzdGVuZXI7XG5cbiAgXHRcdFx0XHR3aGlsZSAobGlzdGVuZXIgPSBsaXN0ZW5lcnMucG9wKCkpIHtcbiAgXHRcdFx0XHRcdGxpc3RlbmVyLmNhbmNlbCgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHQvLyBIYW5kbGUgbXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGV2ZW50IG5hbWVzXG4gIFx0ZXZlbnROYW1lcyA9IGV2ZW50TmFtZS5zcGxpdChcIiBcIikubWFwKHNoYXJlZF90cmltKS5maWx0ZXIobm90RW1wdHlTdHJpbmcpO1xuXG4gIFx0ZXZlbnROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgXHRcdChfdGhpcy5fc3Vic1tldmVudE5hbWVdIHx8IChfdGhpcy5fc3Vic1tldmVudE5hbWVdID0gW10pKS5wdXNoKGNhbGxiYWNrKTtcbiAgXHR9KTtcblxuICBcdHJldHVybiB7XG4gIFx0XHRjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIF90aGlzLm9mZihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgdmFyIG9uY2UgPSBSYWN0aXZlJG9uY2U7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRvbmNlKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuXG4gIFx0dmFyIGxpc3RlbmVyID0gdGhpcy5vbihldmVudE5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgXHRcdGhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXHRcdGxpc3RlbmVyLmNhbmNlbCgpO1xuICBcdH0pO1xuXG4gIFx0Ly8gc28gd2UgY2FuIHN0aWxsIGRvIGxpc3RlbmVyLmNhbmNlbCgpIG1hbnVhbGx5XG4gIFx0cmV0dXJuIGxpc3RlbmVyO1xuICB9XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBhcnJheSwgdGhlIG5hbWUgb2YgYSBtdXRhdG9yIG1ldGhvZCwgYW5kIHRoZVxuICAvLyBhcmd1bWVudHMgdG8gY2FsbCB0aGF0IG11dGF0b3IgbWV0aG9kIHdpdGgsIGFuZCByZXR1cm5zIGFuIGFycmF5IHRoYXRcbiAgLy8gbWFwcyB0aGUgb2xkIGluZGljZXMgdG8gdGhlaXIgbmV3IGluZGljZXMuXG5cbiAgLy8gU28gaWYgeW91IGhhZCBzb21ldGhpbmcgbGlrZSB0aGlzLi4uXG4gIC8vXG4gIC8vICAgICBhcnJheSA9IFsgJ2EnLCAnYicsICdjJywgJ2QnIF07XG4gIC8vICAgICBhcnJheS5wdXNoKCAnZScgKTtcbiAgLy9cbiAgLy8gLi4ueW91J2QgZ2V0IGBbIDAsIDEsIDIsIDMgXWAgLSBpbiBvdGhlciB3b3Jkcywgbm9uZSBvZiB0aGUgb2xkIGluZGljZXNcbiAgLy8gaGF2ZSBjaGFuZ2VkLiBJZiB5b3UgdGhlbiBkaWQgdGhpcy4uLlxuICAvL1xuICAvLyAgICAgYXJyYXkudW5zaGlmdCggJ3onICk7XG4gIC8vXG4gIC8vIC4uLnRoZSBpbmRpY2VzIHdvdWxkIGJlIGBbIDEsIDIsIDMsIDQsIDUgXWAgLSBldmVyeSBpdGVtIGhhcyBiZWVuIG1vdmVkXG4gIC8vIG9uZSBoaWdoZXIgdG8gbWFrZSByb29tIGZvciB0aGUgJ3onLiBJZiB5b3UgcmVtb3ZlZCBhbiBpdGVtLCB0aGUgbmV3IGluZGV4XG4gIC8vIHdvdWxkIGJlIC0xLi4uXG4gIC8vXG4gIC8vICAgICBhcnJheS5zcGxpY2UoIDIsIDIgKTtcbiAgLy9cbiAgLy8gLi4udGhpcyB3b3VsZCByZXN1bHQgaW4gWyAwLCAxLCAtMSwgLTEsIDIsIDMgXS5cbiAgLy9cbiAgLy8gVGhpcyBpbmZvcm1hdGlvbiBpcyB1c2VkIHRvIGVuYWJsZSBmYXN0LCBub24tZGVzdHJ1Y3RpdmUgc2h1ZmZsaW5nIG9mIGxpc3RcbiAgLy8gc2VjdGlvbnMgd2hlbiB5b3UgZG8gZS5nLiBgcmFjdGl2ZS5zcGxpY2UoICdpdGVtcycsIDIsIDIgKTtcblxuICB2YXIgc2hhcmVkX2dldE5ld0luZGljZXMgPSBnZXROZXdJbmRpY2VzO1xuXG4gIGZ1bmN0aW9uIGdldE5ld0luZGljZXMoYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgXHR2YXIgc3BsaWNlQXJndW1lbnRzLFxuICBcdCAgICBsZW4sXG4gIFx0ICAgIG5ld0luZGljZXMgPSBbXSxcbiAgXHQgICAgcmVtb3ZlU3RhcnQsXG4gIFx0ICAgIHJlbW92ZUVuZCxcbiAgXHQgICAgYmFsYW5jZSxcbiAgXHQgICAgaTtcblxuICBcdHNwbGljZUFyZ3VtZW50cyA9IGdldFNwbGljZUVxdWl2YWxlbnQoYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MpO1xuXG4gIFx0aWYgKCFzcGxpY2VBcmd1bWVudHMpIHtcbiAgXHRcdHJldHVybiBudWxsOyAvLyBUT0RPIHN1cHBvcnQgcmV2ZXJzZSBhbmQgc29ydD9cbiAgXHR9XG5cbiAgXHRsZW4gPSBhcnJheS5sZW5ndGg7XG4gIFx0YmFsYW5jZSA9IHNwbGljZUFyZ3VtZW50cy5sZW5ndGggLSAyIC0gc3BsaWNlQXJndW1lbnRzWzFdO1xuXG4gIFx0cmVtb3ZlU3RhcnQgPSBNYXRoLm1pbihsZW4sIHNwbGljZUFyZ3VtZW50c1swXSk7XG4gIFx0cmVtb3ZlRW5kID0gcmVtb3ZlU3RhcnQgKyBzcGxpY2VBcmd1bWVudHNbMV07XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlU3RhcnQ7IGkgKz0gMSkge1xuICBcdFx0bmV3SW5kaWNlcy5wdXNoKGkpO1xuICBcdH1cblxuICBcdGZvciAoOyBpIDwgcmVtb3ZlRW5kOyBpICs9IDEpIHtcbiAgXHRcdG5ld0luZGljZXMucHVzaCgtMSk7XG4gIFx0fVxuXG4gIFx0Zm9yICg7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0bmV3SW5kaWNlcy5wdXNoKGkgKyBiYWxhbmNlKTtcbiAgXHR9XG5cbiAgXHQvLyB0aGVyZSBpcyBhIG5ldCBzaGlmdCBmb3IgdGhlIHJlc3Qgb2YgdGhlIGFycmF5IHN0YXJ0aW5nIHdpdGggaW5kZXggKyBiYWxhbmNlXG4gIFx0aWYgKGJhbGFuY2UgIT09IDApIHtcbiAgXHRcdG5ld0luZGljZXMudG91Y2hlZEZyb20gPSBzcGxpY2VBcmd1bWVudHNbMF07XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG5ld0luZGljZXMudG91Y2hlZEZyb20gPSBhcnJheS5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG5ld0luZGljZXM7XG4gIH1cblxuICAvLyBUaGUgcG9wLCBwdXNoLCBzaGlmdCBhbiB1bnNoaWZ0IG1ldGhvZHMgY2FuIGFsbCBiZSByZXByZXNlbnRlZFxuICAvLyBhcyBhbiBlcXVpdmFsZW50IHNwbGljZVxuICBmdW5jdGlvbiBnZXRTcGxpY2VFcXVpdmFsZW50KGFycmF5LCBtZXRob2ROYW1lLCBhcmdzKSB7XG4gIFx0c3dpdGNoIChtZXRob2ROYW1lKSB7XG4gIFx0XHRjYXNlIFwic3BsaWNlXCI6XG4gIFx0XHRcdGlmIChhcmdzWzBdICE9PSB1bmRlZmluZWQgJiYgYXJnc1swXSA8IDApIHtcbiAgXHRcdFx0XHRhcmdzWzBdID0gYXJyYXkubGVuZ3RoICsgTWF0aC5tYXgoYXJnc1swXSwgLWFycmF5Lmxlbmd0aCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR3aGlsZSAoYXJncy5sZW5ndGggPCAyKSB7XG4gIFx0XHRcdFx0YXJncy5wdXNoKDApO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gZW5zdXJlIHdlIG9ubHkgcmVtb3ZlIGVsZW1lbnRzIHRoYXQgZXhpc3RcbiAgXHRcdFx0YXJnc1sxXSA9IE1hdGgubWluKGFyZ3NbMV0sIGFycmF5Lmxlbmd0aCAtIGFyZ3NbMF0pO1xuXG4gIFx0XHRcdHJldHVybiBhcmdzO1xuXG4gIFx0XHRjYXNlIFwic29ydFwiOlxuICBcdFx0Y2FzZSBcInJldmVyc2VcIjpcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG5cbiAgXHRcdGNhc2UgXCJwb3BcIjpcbiAgXHRcdFx0aWYgKGFycmF5Lmxlbmd0aCkge1xuICBcdFx0XHRcdHJldHVybiBbYXJyYXkubGVuZ3RoIC0gMSwgMV07XG4gIFx0XHRcdH1cbiAgXHRcdFx0cmV0dXJuIFswLCAwXTtcblxuICBcdFx0Y2FzZSBcInB1c2hcIjpcbiAgXHRcdFx0cmV0dXJuIFthcnJheS5sZW5ndGgsIDBdLmNvbmNhdChhcmdzKTtcblxuICBcdFx0Y2FzZSBcInNoaWZ0XCI6XG4gIFx0XHRcdHJldHVybiBbMCwgYXJyYXkubGVuZ3RoID8gMSA6IDBdO1xuXG4gIFx0XHRjYXNlIFwidW5zaGlmdFwiOlxuICBcdFx0XHRyZXR1cm4gWzAsIDBdLmNvbmNhdChhcmdzKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuICB2YXIgbWFrZUFycmF5TWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0XHRhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGFycmF5LFxuICBcdFx0ICAgIG5ld0luZGljZXMgPSBbXSxcbiAgXHRcdCAgICBsZW4sXG4gIFx0XHQgICAgcHJvbWlzZSxcbiAgXHRcdCAgICByZXN1bHQ7XG5cbiAgXHRcdGtleXBhdGggPSBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSk7XG5cbiAgXHRcdGFycmF5ID0gdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0bGVuID0gYXJyYXkubGVuZ3RoO1xuXG4gIFx0XHRpZiAoIWlzQXJyYXkoYXJyYXkpKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNhbGxlZCByYWN0aXZlLlwiICsgbWV0aG9kTmFtZSArIFwiKCdcIiArIGtleXBhdGguc3RyICsgXCInKSwgYnV0ICdcIiArIGtleXBhdGguc3RyICsgXCInIGRvZXMgbm90IHJlZmVyIHRvIGFuIGFycmF5XCIpO1xuICBcdFx0fVxuXG4gIFx0XHRuZXdJbmRpY2VzID0gc2hhcmVkX2dldE5ld0luZGljZXMoYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MpO1xuXG4gIFx0XHRyZXN1bHQgPSBhcnJheVByb3RvW21ldGhvZE5hbWVdLmFwcGx5KGFycmF5LCBhcmdzKTtcbiAgXHRcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHRcdH0pO1xuXG4gIFx0XHRpZiAoISFuZXdJbmRpY2VzKSB7XG4gIFx0XHRcdHRoaXMudmlld21vZGVsLnNtYXJ0VXBkYXRlKGtleXBhdGgsIGFycmF5LCBuZXdJbmRpY2VzKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMudmlld21vZGVsLm1hcmsoa2V5cGF0aCk7XG4gIFx0XHR9XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0XHRyZXR1cm4gcHJvbWlzZTtcbiAgXHR9O1xuICB9O1xuXG4gIHZhciBwb3AgPSBtYWtlQXJyYXlNZXRob2QoXCJwb3BcIik7XG5cbiAgdmFyIHB1c2ggPSBtYWtlQXJyYXlNZXRob2QoXCJwdXNoXCIpO1xuXG4gIHZhciBjc3MsXG4gICAgICB1cGRhdGUsXG4gICAgICBzdHlsZUVsZW1lbnQsXG4gICAgICBoZWFkLFxuICAgICAgc3R5bGVTaGVldCxcbiAgICAgIGluRG9tLFxuICAgICAgZ2xvYmFsX2Nzc19fcHJlZml4ID0gXCIvKiBSYWN0aXZlLmpzIGNvbXBvbmVudCBzdHlsZXMgKi9cXG5cIixcbiAgICAgIHN0eWxlcyA9IFtdLFxuICAgICAgZGlydHkgPSBmYWxzZTtcblxuICBpZiAoIWlzQ2xpZW50KSB7XG4gIFx0Ly8gVE9ETyBoYW5kbGUgZW5jYXBzdWxhdGVkIENTUyBpbiBzZXJ2ZXItcmVuZGVyZWQgSFRNTCFcbiAgXHRjc3MgPSB7XG4gIFx0XHRhZGQ6IG5vb3AsXG4gIFx0XHRhcHBseTogbm9vcFxuICBcdH07XG4gIH0gZWxzZSB7XG4gIFx0c3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBcdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG4gIFx0aGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcblxuICBcdGluRG9tID0gZmFsc2U7XG5cbiAgXHQvLyBJbnRlcm5ldCBFeHBsb2RlciB3b24ndCBsZXQgeW91IHVzZSBzdHlsZVNoZWV0LmlubmVySFRNTCAtIHdlIGhhdmUgdG9cbiAgXHQvLyB1c2Ugc3R5bGVTaGVldC5jc3NUZXh0IGluc3RlYWRcbiAgXHRzdHlsZVNoZWV0ID0gc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQ7XG5cbiAgXHR1cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgY3NzID0gZ2xvYmFsX2Nzc19fcHJlZml4ICsgc3R5bGVzLm1hcChmdW5jdGlvbiAocykge1xuICBcdFx0XHRyZXR1cm4gXCJcXG4vKiB7XCIgKyBzLmlkICsgXCJ9ICovXFxuXCIgKyBzLnN0eWxlcztcbiAgXHRcdH0pLmpvaW4oXCJcXG5cIik7XG5cbiAgXHRcdGlmIChzdHlsZVNoZWV0KSB7XG4gIFx0XHRcdHN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBjc3M7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghaW5Eb20pIHtcbiAgXHRcdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICBcdFx0XHRpbkRvbSA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdGNzcyA9IHtcbiAgXHRcdGFkZDogZnVuY3Rpb24gKHMpIHtcbiAgXHRcdFx0c3R5bGVzLnB1c2gocyk7XG4gIFx0XHRcdGRpcnR5ID0gdHJ1ZTtcbiAgXHRcdH0sXG5cbiAgXHRcdGFwcGx5OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdGlmIChkaXJ0eSkge1xuICBcdFx0XHRcdHVwZGF0ZSgpO1xuICBcdFx0XHRcdGRpcnR5ID0gZmFsc2U7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgdmFyIGdsb2JhbF9jc3MgPSBjc3M7XG5cbiAgdmFyIHByb3RvdHlwZV9yZW5kZXIgPSBSYWN0aXZlJHJlbmRlcjtcblxuICB2YXIgcmVuZGVySG9vayA9IG5ldyBob29rc19Ib29rKFwicmVuZGVyXCIpLFxuICAgICAgY29tcGxldGVIb29rID0gbmV3IGhvb2tzX0hvb2soXCJjb21wbGV0ZVwiKTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRyZW5kZXIodGFyZ2V0LCBhbmNob3IpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHByb21pc2UsIGluc3RhbmNlcywgdHJhbnNpdGlvbnNFbmFibGVkO1xuXG4gIFx0Ly8gaWYgYG5vSW50cm9gIGlzIGB0cnVlYCwgdGVtcG9yYXJpbHkgZGlzYWJsZSB0cmFuc2l0aW9uc1xuICBcdHRyYW5zaXRpb25zRW5hYmxlZCA9IHRoaXMudHJhbnNpdGlvbnNFbmFibGVkO1xuICBcdGlmICh0aGlzLm5vSW50cm8pIHtcbiAgXHRcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuICBcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gcmVuZGVySG9vay5maXJlKF90aGlzKTtcbiAgXHR9LCB0cnVlKTtcblxuICBcdGlmICh0aGlzLmZyYWdtZW50LnJlbmRlcmVkKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IGNhbGwgcmFjdGl2ZS5yZW5kZXIoKSBvbiBhbiBhbHJlYWR5IHJlbmRlcmVkIGluc3RhbmNlISBDYWxsIHJhY3RpdmUudW5yZW5kZXIoKSBmaXJzdFwiKTtcbiAgXHR9XG5cbiAgXHR0YXJnZXQgPSBnZXRFbGVtZW50KHRhcmdldCkgfHwgdGhpcy5lbDtcbiAgXHRhbmNob3IgPSBnZXRFbGVtZW50KGFuY2hvcikgfHwgdGhpcy5hbmNob3I7XG5cbiAgXHR0aGlzLmVsID0gdGFyZ2V0O1xuICBcdHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuXG4gIFx0aWYgKCF0aGlzLmFwcGVuZCAmJiB0YXJnZXQpIHtcbiAgXHRcdC8vIFRlYXJkb3duIGFueSBleGlzdGluZyBpbnN0YW5jZXMgKmJlZm9yZSogdHJ5aW5nIHRvIHNldCB1cCB0aGUgbmV3IG9uZSAtXG4gIFx0XHQvLyBhdm9pZHMgY2VydGFpbiB3ZWlyZCBidWdzXG4gIFx0XHR2YXIgb3RoZXJzID0gdGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXztcbiAgXHRcdGlmIChvdGhlcnMgJiYgb3RoZXJzLmxlbmd0aCkge1xuICBcdFx0XHRyZW1vdmVPdGhlckluc3RhbmNlcyhvdGhlcnMpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBtYWtlIHN1cmUgd2UgYXJlIHRoZSBvbmx5IG9jY3VwYW50c1xuICBcdFx0dGFyZ2V0LmlubmVySFRNTCA9IFwiXCI7IC8vIFRPRE8gaXMgdGhpcyBxdWlja2VyIHRoYW4gcmVtb3ZlQ2hpbGQ/IEluaXRpYWwgcmVzZWFyY2ggaW5jb25jbHVzaXZlXG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuY3NzSWQpIHtcbiAgXHRcdC8vIGVuc3VyZSBlbmNhcHN1bGF0ZWQgQ1NTIGlzIHVwLXRvLWRhdGVcbiAgXHRcdGdsb2JhbF9jc3MuYXBwbHkoKTtcbiAgXHR9XG5cbiAgXHRpZiAodGFyZ2V0KSB7XG4gIFx0XHRpZiAoIShpbnN0YW5jZXMgPSB0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fKSkge1xuICBcdFx0XHR0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fID0gW3RoaXNdO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0aW5zdGFuY2VzLnB1c2godGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChhbmNob3IpIHtcbiAgXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLmZyYWdtZW50LnJlbmRlcigpLCBhbmNob3IpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHRoaXMuZnJhZ21lbnQucmVuZGVyKCkpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSB0cmFuc2l0aW9uc0VuYWJsZWQ7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBjb21wbGV0ZUhvb2suZmlyZShfdGhpcyk7XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVPdGhlckluc3RhbmNlcyhvdGhlcnMpIHtcbiAgXHRvdGhlcnMuc3BsaWNlKDAsIG90aGVycy5sZW5ndGgpLmZvckVhY2godGVhcmRvd24pO1xuICB9XG5cbiAgdmFyIGFkYXB0Q29uZmlndXJhdG9yID0ge1xuICBcdGV4dGVuZDogZnVuY3Rpb24gKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdHByb3RvLmFkYXB0ID0gY3VzdG9tX2FkYXB0X19jb21iaW5lKHByb3RvLmFkYXB0LCBlbnN1cmVBcnJheShvcHRpb25zLmFkYXB0KSk7XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHt9XG4gIH07XG5cbiAgdmFyIGN1c3RvbV9hZGFwdCA9IGFkYXB0Q29uZmlndXJhdG9yO1xuXG4gIGZ1bmN0aW9uIGN1c3RvbV9hZGFwdF9fY29tYmluZShhLCBiKSB7XG4gIFx0dmFyIGMgPSBhLnNsaWNlKCksXG4gIFx0ICAgIGkgPSBiLmxlbmd0aDtcblxuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmICghIH5jLmluZGV4T2YoYltpXSkpIHtcbiAgXHRcdFx0Yy5wdXNoKGJbaV0pO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBjO1xuICB9XG5cbiAgdmFyIHRyYW5zZm9ybSA9IHRyYW5zZm9ybUNzcztcblxuICB2YXIgc2VsZWN0b3JzUGF0dGVybiA9IC8oPzpefFxcfSk/XFxzKihbXlxce1xcfV0rKVxccypcXHsvZyxcbiAgICAgIGNvbW1lbnRzUGF0dGVybiA9IC9cXC9cXCouKj9cXCpcXC8vZyxcbiAgICAgIHNlbGVjdG9yVW5pdFBhdHRlcm4gPSAvKCg/Oig/OlxcW1teXFxdK11cXF0pfCg/OlteXFxzXFwrXFw+XFx+Ol0pKSspKCg/OjpbXlxcc1xcK1xcPlxcflxcKF0rKD86XFwoW15cXCldK1xcKSk/KT9cXHMqW1xcc1xcK1xcPlxcfl0/KVxccyovZyxcbiAgICAgIG1lZGlhUXVlcnlQYXR0ZXJuID0gL15AbWVkaWEvLFxuICAgICAgZGF0YVJ2Y0d1aWRQYXR0ZXJuID0gL1xcW2RhdGEtcmFjdGl2ZS1jc3N+PVwiXFx7W2EtejAtOS1dK1xcfVwiXS9nO1xuICBmdW5jdGlvbiB0cmFuc2Zvcm1Dc3MoY3NzLCBpZCkge1xuICBcdHZhciB0cmFuc2Zvcm1lZCwgZGF0YUF0dHIsIGFkZEd1aWQ7XG5cbiAgXHRkYXRhQXR0ciA9IFwiW2RhdGEtcmFjdGl2ZS1jc3N+PVxcXCJ7XCIgKyBpZCArIFwifVxcXCJdXCI7XG5cbiAgXHRhZGRHdWlkID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0XHR2YXIgc2VsZWN0b3JVbml0cyxcbiAgXHRcdCAgICBtYXRjaCxcbiAgXHRcdCAgICB1bml0LFxuICBcdFx0ICAgIGJhc2UsXG4gIFx0XHQgICAgcHJlcGVuZGVkLFxuICBcdFx0ICAgIGFwcGVuZGVkLFxuICBcdFx0ICAgIGksXG4gIFx0XHQgICAgdHJhbnNmb3JtZWQgPSBbXTtcblxuICBcdFx0c2VsZWN0b3JVbml0cyA9IFtdO1xuXG4gIFx0XHR3aGlsZSAobWF0Y2ggPSBzZWxlY3RvclVuaXRQYXR0ZXJuLmV4ZWMoc2VsZWN0b3IpKSB7XG4gIFx0XHRcdHNlbGVjdG9yVW5pdHMucHVzaCh7XG4gIFx0XHRcdFx0c3RyOiBtYXRjaFswXSxcbiAgXHRcdFx0XHRiYXNlOiBtYXRjaFsxXSxcbiAgXHRcdFx0XHRtb2RpZmllcnM6IG1hdGNoWzJdXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBGb3IgZWFjaCBzaW1wbGUgc2VsZWN0b3Igd2l0aGluIHRoZSBzZWxlY3Rvciwgd2UgbmVlZCB0byBjcmVhdGUgYSB2ZXJzaW9uXG4gIFx0XHQvLyB0aGF0IGEpIGNvbWJpbmVzIHdpdGggdGhlIGlkLCBhbmQgYikgaXMgaW5zaWRlIHRoZSBpZFxuICBcdFx0YmFzZSA9IHNlbGVjdG9yVW5pdHMubWFwKGV4dHJhY3RTdHJpbmcpO1xuXG4gIFx0XHRpID0gc2VsZWN0b3JVbml0cy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGFwcGVuZGVkID0gYmFzZS5zbGljZSgpO1xuXG4gIFx0XHRcdC8vIFBzZXVkby1zZWxlY3RvcnMgc2hvdWxkIGdvIGFmdGVyIHRoZSBhdHRyaWJ1dGUgc2VsZWN0b3JcbiAgXHRcdFx0dW5pdCA9IHNlbGVjdG9yVW5pdHNbaV07XG4gIFx0XHRcdGFwcGVuZGVkW2ldID0gdW5pdC5iYXNlICsgZGF0YUF0dHIgKyB1bml0Lm1vZGlmaWVycyB8fCBcIlwiO1xuXG4gIFx0XHRcdHByZXBlbmRlZCA9IGJhc2Uuc2xpY2UoKTtcbiAgXHRcdFx0cHJlcGVuZGVkW2ldID0gZGF0YUF0dHIgKyBcIiBcIiArIHByZXBlbmRlZFtpXTtcblxuICBcdFx0XHR0cmFuc2Zvcm1lZC5wdXNoKGFwcGVuZGVkLmpvaW4oXCIgXCIpLCBwcmVwZW5kZWQuam9pbihcIiBcIikpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdHJhbnNmb3JtZWQuam9pbihcIiwgXCIpO1xuICBcdH07XG5cbiAgXHRpZiAoZGF0YVJ2Y0d1aWRQYXR0ZXJuLnRlc3QoY3NzKSkge1xuICBcdFx0dHJhbnNmb3JtZWQgPSBjc3MucmVwbGFjZShkYXRhUnZjR3VpZFBhdHRlcm4sIGRhdGFBdHRyKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0dHJhbnNmb3JtZWQgPSBjc3MucmVwbGFjZShjb21tZW50c1BhdHRlcm4sIFwiXCIpLnJlcGxhY2Uoc2VsZWN0b3JzUGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoLCAkMSkge1xuICBcdFx0XHR2YXIgc2VsZWN0b3JzLCB0cmFuc2Zvcm1lZDtcblxuICBcdFx0XHQvLyBkb24ndCB0cmFuc2Zvcm0gbWVkaWEgcXVlcmllcyFcbiAgXHRcdFx0aWYgKG1lZGlhUXVlcnlQYXR0ZXJuLnRlc3QoJDEpKSByZXR1cm4gbWF0Y2g7XG5cbiAgXHRcdFx0c2VsZWN0b3JzID0gJDEuc3BsaXQoXCIsXCIpLm1hcCh0cmltKTtcbiAgXHRcdFx0dHJhbnNmb3JtZWQgPSBzZWxlY3RvcnMubWFwKGFkZEd1aWQpLmpvaW4oXCIsIFwiKSArIFwiIFwiO1xuXG4gIFx0XHRcdHJldHVybiBtYXRjaC5yZXBsYWNlKCQxLCB0cmFuc2Zvcm1lZCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdHJhbnNmb3JtZWQ7XG4gIH1cblxuICBmdW5jdGlvbiB0cmltKHN0cikge1xuICBcdGlmIChzdHIudHJpbSkge1xuICBcdFx0cmV0dXJuIHN0ci50cmltKCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKy8sIFwiXCIpLnJlcGxhY2UoL1xccyskLywgXCJcIik7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0U3RyaW5nKHVuaXQpIHtcbiAgXHRyZXR1cm4gdW5pdC5zdHI7XG4gIH1cblxuICB2YXIgY3NzX2Nzc19fdWlkID0gMTtcblxuICB2YXIgY3NzQ29uZmlndXJhdG9yID0ge1xuICBcdG5hbWU6IFwiY3NzXCIsXG5cbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIChQYXJlbnQsIHByb3RvLCBvcHRpb25zKSB7XG4gIFx0XHRpZiAob3B0aW9ucy5jc3MpIHtcbiAgXHRcdFx0dmFyIGlkID0gY3NzX2Nzc19fdWlkKys7XG4gIFx0XHRcdHZhciBzdHlsZXMgPSBvcHRpb25zLm5vQ3NzVHJhbnNmb3JtID8gb3B0aW9ucy5jc3MgOiB0cmFuc2Zvcm0ob3B0aW9ucy5jc3MsIGlkKTtcblxuICBcdFx0XHRwcm90by5jc3NJZCA9IGlkO1xuICBcdFx0XHRnbG9iYWxfY3NzLmFkZCh7IGlkOiBpZCwgc3R5bGVzOiBzdHlsZXMgfSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHt9XG4gIH07XG5cbiAgdmFyIGNzc19jc3MgPSBjc3NDb25maWd1cmF0b3I7XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUoZGF0YSkge1xuICBcdC8vIFdhcm4gaWYgdXNlck9wdGlvbnMuZGF0YSBpcyBhIG5vbi1QT0pPXG4gIFx0aWYgKGRhdGEgJiYgZGF0YS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gIFx0XHRpZiAodHlwZW9mIGRhdGEgPT09IFwiZnVuY3Rpb25cIikge30gZWxzZSBpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdFx0ZmF0YWwoXCJkYXRhIG9wdGlvbiBtdXN0IGJlIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uLCBgXCIgKyBkYXRhICsgXCJgIGlzIG5vdCB2YWxpZFwiKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKFwiSWYgc3VwcGxpZWQsIG9wdGlvbnMuZGF0YSBzaG91bGQgYmUgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCAtIHVzaW5nIGEgbm9uLVBPSk8gYXMgdGhlIHJvb3Qgb2JqZWN0IG1heSB3b3JrLCBidXQgaXMgZGlzY291cmFnZWRcIik7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIGRhdGFDb25maWd1cmF0b3IgPSB7XG4gIFx0bmFtZTogXCJkYXRhXCIsXG5cbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIChQYXJlbnQsIHByb3RvLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIga2V5ID0gdW5kZWZpbmVkLFxuICBcdFx0ICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuXG4gIFx0XHQvLyBjaGVjayBmb3Igbm9uLXByaW1pdGl2ZXMsIHdoaWNoIGNvdWxkIGNhdXNlIG11dGF0aW9uLXJlbGF0ZWQgYnVnc1xuICBcdFx0aWYgKG9wdGlvbnMuZGF0YSAmJiBpc09iamVjdChvcHRpb25zLmRhdGEpKSB7XG4gIFx0XHRcdGZvciAoa2V5IGluIG9wdGlvbnMuZGF0YSkge1xuICBcdFx0XHRcdHZhbHVlID0gb3B0aW9ucy5kYXRhW2tleV07XG5cbiAgXHRcdFx0XHRpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRcdFx0XHRpZiAoaXNPYmplY3QodmFsdWUpIHx8IGlzQXJyYXkodmFsdWUpKSB7XG4gIFx0XHRcdFx0XHRcdHdhcm5JZkRlYnVnKFwiUGFzc2luZyBhIGBkYXRhYCBvcHRpb24gd2l0aCBvYmplY3QgYW5kIGFycmF5IHByb3BlcnRpZXMgdG8gUmFjdGl2ZS5leHRlbmQoKSBpcyBkaXNjb3VyYWdlZCwgYXMgbXV0YXRpbmcgdGhlbSBpcyBsaWtlbHkgdG8gY2F1c2UgYnVncy4gQ29uc2lkZXIgdXNpbmcgYSBkYXRhIGZ1bmN0aW9uIGluc3RlYWQ6XFxuXFxuICAvLyB0aGlzLi4uXFxuICBkYXRhOiBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgbXlPYmplY3Q6IHt9XFxuICAgIH07XFxuICB9KVxcblxcbiAgLy8gaW5zdGVhZCBvZiB0aGlzOlxcbiAgZGF0YToge1xcbiAgICBteU9iamVjdDoge31cXG4gIH1cIik7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHByb3RvLmRhdGEgPSBjdXN0b21fZGF0YV9fY29tYmluZShwcm90by5kYXRhLCBvcHRpb25zLmRhdGEpO1xuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoUGFyZW50LCByYWN0aXZlLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgcmVzdWx0ID0gY3VzdG9tX2RhdGFfX2NvbWJpbmUoUGFyZW50LnByb3RvdHlwZS5kYXRhLCBvcHRpb25zLmRhdGEpO1xuXG4gIFx0XHRpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5jYWxsKHJhY3RpdmUpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gcmVzdWx0IHx8IHt9O1xuICBcdH0sXG5cbiAgXHRyZXNldDogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdHZhciByZXN1bHQgPSB0aGlzLmluaXQocmFjdGl2ZS5jb25zdHJ1Y3RvciwgcmFjdGl2ZSwgcmFjdGl2ZS52aWV3bW9kZWwpO1xuXG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5yZXNldChyZXN1bHQpO1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBjdXN0b21fZGF0YSA9IGRhdGFDb25maWd1cmF0b3I7XG5cbiAgZnVuY3Rpb24gY3VzdG9tX2RhdGFfX2NvbWJpbmUocGFyZW50VmFsdWUsIGNoaWxkVmFsdWUpIHtcbiAgXHR2YWxpZGF0ZShjaGlsZFZhbHVlKTtcblxuICBcdHZhciBwYXJlbnRJc0ZuID0gdHlwZW9mIHBhcmVudFZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG4gIFx0dmFyIGNoaWxkSXNGbiA9IHR5cGVvZiBjaGlsZFZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG5cbiAgXHQvLyBWZXJ5IGltcG9ydGFudCwgb3RoZXJ3aXNlIGNoaWxkIGluc3RhbmNlIGNhbiBiZWNvbWVcbiAgXHQvLyB0aGUgZGVmYXVsdCBkYXRhIG9iamVjdCBvbiBSYWN0aXZlIG9yIGEgY29tcG9uZW50LlxuICBcdC8vIHRoZW4gcmFjdGl2ZS5zZXQoKSBlbmRzIHVwIHNldHRpbmcgb24gdGhlIHByb3RvdHlwZSFcbiAgXHRpZiAoIWNoaWxkVmFsdWUgJiYgIXBhcmVudElzRm4pIHtcbiAgXHRcdGNoaWxkVmFsdWUgPSB7fTtcbiAgXHR9XG5cbiAgXHQvLyBGYXN0IHBhdGgsIHdoZXJlIHdlIGp1c3QgbmVlZCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICBcdC8vIHBhcmVudCB0byBjaGlsZFxuICBcdGlmICghcGFyZW50SXNGbiAmJiAhY2hpbGRJc0ZuKSB7XG4gIFx0XHRyZXR1cm4gZnJvbVByb3BlcnRpZXMoY2hpbGRWYWx1ZSwgcGFyZW50VmFsdWUpO1xuICBcdH1cblxuICBcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgY2hpbGQgPSBjaGlsZElzRm4gPyBjYWxsRGF0YUZ1bmN0aW9uKGNoaWxkVmFsdWUsIHRoaXMpIDogY2hpbGRWYWx1ZTtcbiAgXHRcdHZhciBwYXJlbnQgPSBwYXJlbnRJc0ZuID8gY2FsbERhdGFGdW5jdGlvbihwYXJlbnRWYWx1ZSwgdGhpcykgOiBwYXJlbnRWYWx1ZTtcblxuICBcdFx0cmV0dXJuIGZyb21Qcm9wZXJ0aWVzKGNoaWxkLCBwYXJlbnQpO1xuICBcdH07XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsRGF0YUZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XG4gIFx0dmFyIGRhdGEgPSBmbi5jYWxsKGNvbnRleHQpO1xuXG4gIFx0aWYgKCFkYXRhKSByZXR1cm47XG5cbiAgXHRpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdGZhdGFsKFwiRGF0YSBmdW5jdGlvbiBtdXN0IHJldHVybiBhbiBvYmplY3RcIik7XG4gIFx0fVxuXG4gIFx0aWYgKGRhdGEuY29uc3RydWN0b3IgIT09IE9iamVjdCkge1xuICBcdFx0d2Fybk9uY2VJZkRlYnVnKFwiRGF0YSBmdW5jdGlvbiByZXR1cm5lZCBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LiBUaGlzIG1pZ2h0IHdvcmssIGJ1dCBpcyBzdHJvbmdseSBkaXNjb3VyYWdlZFwiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21Qcm9wZXJ0aWVzKHByaW1hcnksIHNlY29uZGFyeSkge1xuICBcdGlmIChwcmltYXJ5ICYmIHNlY29uZGFyeSkge1xuICBcdFx0Zm9yICh2YXIga2V5IGluIHNlY29uZGFyeSkge1xuICBcdFx0XHRpZiAoIShrZXkgaW4gcHJpbWFyeSkpIHtcbiAgXHRcdFx0XHRwcmltYXJ5W2tleV0gPSBzZWNvbmRhcnlba2V5XTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gcHJpbWFyeTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcHJpbWFyeSB8fCBzZWNvbmRhcnk7XG4gIH1cblxuICAvLyBUT0RPIGRvIHdlIG5lZWQgdG8gc3VwcG9ydCB0aGlzIGluIHRoZSBuZXcgUmFjdGl2ZSgpIGNhc2U/XG5cbiAgdmFyIFBhcnNlcixcbiAgICAgIFBhcnNlRXJyb3IsXG4gICAgICBwYXJzZV9QYXJzZXJfX2xlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMrLztcblxuICBQYXJzZUVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgXHR0aGlzLm5hbWUgPSBcIlBhcnNlRXJyb3JcIjtcbiAgXHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICBcdHRyeSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIFx0fSBjYXRjaCAoZSkge1xuICBcdFx0dGhpcy5zdGFjayA9IGUuc3RhY2s7XG4gIFx0fVxuICB9O1xuXG4gIFBhcnNlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIFBhcnNlciA9IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcbiAgXHR2YXIgaXRlbXMsXG4gIFx0ICAgIGl0ZW0sXG4gIFx0ICAgIGxpbmVTdGFydCA9IDA7XG5cbiAgXHR0aGlzLnN0ciA9IHN0cjtcbiAgXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBcdHRoaXMucG9zID0gMDtcblxuICBcdHRoaXMubGluZXMgPSB0aGlzLnN0ci5zcGxpdChcIlxcblwiKTtcbiAgXHR0aGlzLmxpbmVFbmRzID0gdGhpcy5saW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgXHRcdHZhciBsaW5lRW5kID0gbGluZVN0YXJ0ICsgbGluZS5sZW5ndGggKyAxOyAvLyArMSBmb3IgdGhlIG5ld2xpbmVcblxuICBcdFx0bGluZVN0YXJ0ID0gbGluZUVuZDtcbiAgXHRcdHJldHVybiBsaW5lRW5kO1xuICBcdH0sIDApO1xuXG4gIFx0Ly8gQ3VzdG9tIGluaXQgbG9naWNcbiAgXHRpZiAodGhpcy5pbml0KSB0aGlzLmluaXQoc3RyLCBvcHRpb25zKTtcblxuICBcdGl0ZW1zID0gW107XG5cbiAgXHR3aGlsZSAodGhpcy5wb3MgPCB0aGlzLnN0ci5sZW5ndGggJiYgKGl0ZW0gPSB0aGlzLnJlYWQoKSkpIHtcbiAgXHRcdGl0ZW1zLnB1c2goaXRlbSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5sZWZ0b3ZlciA9IHRoaXMucmVtYWluaW5nKCk7XG4gIFx0dGhpcy5yZXN1bHQgPSB0aGlzLnBvc3RQcm9jZXNzID8gdGhpcy5wb3N0UHJvY2VzcyhpdGVtcywgb3B0aW9ucykgOiBpdGVtcztcbiAgfTtcblxuICBQYXJzZXIucHJvdG90eXBlID0ge1xuICBcdHJlYWQ6IGZ1bmN0aW9uIChjb252ZXJ0ZXJzKSB7XG4gIFx0XHR2YXIgcG9zLCBpLCBsZW4sIGl0ZW07XG5cbiAgXHRcdGlmICghY29udmVydGVycykgY29udmVydGVycyA9IHRoaXMuY29udmVydGVycztcblxuICBcdFx0cG9zID0gdGhpcy5wb3M7XG5cbiAgXHRcdGxlbiA9IGNvbnZlcnRlcnMubGVuZ3RoO1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdHRoaXMucG9zID0gcG9zOyAvLyByZXNldCBmb3IgZWFjaCBhdHRlbXB0XG5cbiAgXHRcdFx0aWYgKGl0ZW0gPSBjb252ZXJ0ZXJzW2ldKHRoaXMpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGl0ZW07XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fSxcblxuICBcdGdldExpbmVQb3M6IGZ1bmN0aW9uIChjaGFyKSB7XG4gIFx0XHR2YXIgbGluZU51bSA9IDAsXG4gIFx0XHQgICAgbGluZVN0YXJ0ID0gMCxcbiAgXHRcdCAgICBjb2x1bW5OdW07XG5cbiAgXHRcdHdoaWxlIChjaGFyID49IHRoaXMubGluZUVuZHNbbGluZU51bV0pIHtcbiAgXHRcdFx0bGluZVN0YXJ0ID0gdGhpcy5saW5lRW5kc1tsaW5lTnVtXTtcbiAgXHRcdFx0bGluZU51bSArPSAxO1xuICBcdFx0fVxuXG4gIFx0XHRjb2x1bW5OdW0gPSBjaGFyIC0gbGluZVN0YXJ0O1xuICBcdFx0cmV0dXJuIFtsaW5lTnVtICsgMSwgY29sdW1uTnVtICsgMSwgY2hhcl07IC8vIGxpbmUvY29sIHNob3VsZCBiZSBvbmUtYmFzZWQsIG5vdCB6ZXJvLWJhc2VkIVxuICBcdH0sXG5cbiAgXHRlcnJvcjogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgXHRcdHZhciBwb3MgPSB0aGlzLmdldExpbmVQb3ModGhpcy5wb3MpO1xuICBcdFx0dmFyIGxpbmVOdW0gPSBwb3NbMF07XG4gIFx0XHR2YXIgY29sdW1uTnVtID0gcG9zWzFdO1xuXG4gIFx0XHR2YXIgbGluZSA9IHRoaXMubGluZXNbcG9zWzBdIC0gMV07XG4gIFx0XHR2YXIgbnVtVGFicyA9IDA7XG4gIFx0XHR2YXIgYW5ub3RhdGlvbiA9IGxpbmUucmVwbGFjZSgvXFx0L2csIGZ1bmN0aW9uIChtYXRjaCwgY2hhcikge1xuICBcdFx0XHRpZiAoY2hhciA8IHBvc1sxXSkge1xuICBcdFx0XHRcdG51bVRhYnMgKz0gMTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBcIiAgXCI7XG4gIFx0XHR9KSArIFwiXFxuXCIgKyBuZXcgQXJyYXkocG9zWzFdICsgbnVtVGFicykuam9pbihcIiBcIikgKyBcIl4tLS0tXCI7XG5cbiAgXHRcdHZhciBlcnJvciA9IG5ldyBQYXJzZUVycm9yKFwiXCIgKyBtZXNzYWdlICsgXCIgYXQgbGluZSBcIiArIGxpbmVOdW0gKyBcIiBjaGFyYWN0ZXIgXCIgKyBjb2x1bW5OdW0gKyBcIjpcXG5cIiArIGFubm90YXRpb24pO1xuXG4gIFx0XHRlcnJvci5saW5lID0gcG9zWzBdO1xuICBcdFx0ZXJyb3IuY2hhcmFjdGVyID0gcG9zWzFdO1xuICBcdFx0ZXJyb3Iuc2hvcnRNZXNzYWdlID0gbWVzc2FnZTtcblxuICBcdFx0dGhyb3cgZXJyb3I7XG4gIFx0fSxcblxuICBcdG1hdGNoU3RyaW5nOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIFx0XHRpZiAodGhpcy5zdHIuc3Vic3RyKHRoaXMucG9zLCBzdHJpbmcubGVuZ3RoKSA9PT0gc3RyaW5nKSB7XG4gIFx0XHRcdHRoaXMucG9zICs9IHN0cmluZy5sZW5ndGg7XG4gIFx0XHRcdHJldHVybiBzdHJpbmc7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdG1hdGNoUGF0dGVybjogZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgXHRcdHZhciBtYXRjaDtcblxuICBcdFx0aWYgKG1hdGNoID0gcGF0dGVybi5leGVjKHRoaXMucmVtYWluaW5nKCkpKSB7XG4gIFx0XHRcdHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgXHRcdFx0cmV0dXJuIG1hdGNoWzFdIHx8IG1hdGNoWzBdO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRhbGxvd1doaXRlc3BhY2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMubWF0Y2hQYXR0ZXJuKHBhcnNlX1BhcnNlcl9fbGVhZGluZ1doaXRlc3BhY2UpO1xuICBcdH0sXG5cbiAgXHRyZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLnN0ci5zdWJzdHJpbmcodGhpcy5wb3MpO1xuICBcdH0sXG5cbiAgXHRuZXh0Q2hhcjogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuc3RyLmNoYXJBdCh0aGlzLnBvcyk7XG4gIFx0fVxuICB9O1xuXG4gIFBhcnNlci5leHRlbmQgPSBmdW5jdGlvbiAocHJvdG8pIHtcbiAgXHR2YXIgUGFyZW50ID0gdGhpcyxcbiAgXHQgICAgQ2hpbGQsXG4gIFx0ICAgIGtleTtcblxuICBcdENoaWxkID0gZnVuY3Rpb24gKHN0ciwgb3B0aW9ucykge1xuICBcdFx0UGFyc2VyLmNhbGwodGhpcywgc3RyLCBvcHRpb25zKTtcbiAgXHR9O1xuXG4gIFx0Q2hpbGQucHJvdG90eXBlID0gY3JlYXRlKFBhcmVudC5wcm90b3R5cGUpO1xuXG4gIFx0Zm9yIChrZXkgaW4gcHJvdG8pIHtcbiAgXHRcdGlmIChoYXNPd24uY2FsbChwcm90bywga2V5KSkge1xuICBcdFx0XHRDaGlsZC5wcm90b3R5cGVba2V5XSA9IHByb3RvW2tleV07XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Q2hpbGQuZXh0ZW5kID0gUGFyc2VyLmV4dGVuZDtcbiAgXHRyZXR1cm4gQ2hpbGQ7XG4gIH07XG5cbiAgdmFyIHBhcnNlX1BhcnNlciA9IFBhcnNlcjtcblxuICB2YXIgVEVYVCA9IDE7XG4gIHZhciBJTlRFUlBPTEFUT1IgPSAyO1xuICB2YXIgVFJJUExFID0gMztcbiAgdmFyIFNFQ1RJT04gPSA0O1xuICB2YXIgSU5WRVJURUQgPSA1O1xuICB2YXIgQ0xPU0lORyA9IDY7XG4gIHZhciBFTEVNRU5UID0gNztcbiAgdmFyIFBBUlRJQUwgPSA4O1xuICB2YXIgQ09NTUVOVCA9IDk7XG4gIHZhciBERUxJTUNIQU5HRSA9IDEwO1xuICB2YXIgQVRUUklCVVRFID0gMTM7XG4gIHZhciBDTE9TSU5HX1RBRyA9IDE0O1xuICB2YXIgQ09NUE9ORU5UID0gMTU7XG4gIHZhciBZSUVMREVSID0gMTY7XG4gIHZhciBJTkxJTkVfUEFSVElBTCA9IDE3O1xuICB2YXIgRE9DVFlQRSA9IDE4O1xuXG4gIHZhciBOVU1CRVJfTElURVJBTCA9IDIwO1xuICB2YXIgU1RSSU5HX0xJVEVSQUwgPSAyMTtcbiAgdmFyIEFSUkFZX0xJVEVSQUwgPSAyMjtcbiAgdmFyIE9CSkVDVF9MSVRFUkFMID0gMjM7XG4gIHZhciBCT09MRUFOX0xJVEVSQUwgPSAyNDtcbiAgdmFyIFJFR0VYUF9MSVRFUkFMID0gMjU7XG5cbiAgdmFyIEdMT0JBTCA9IDI2O1xuICB2YXIgS0VZX1ZBTFVFX1BBSVIgPSAyNztcblxuICB2YXIgUkVGRVJFTkNFID0gMzA7XG4gIHZhciBSRUZJTkVNRU5UID0gMzE7XG4gIHZhciBNRU1CRVIgPSAzMjtcbiAgdmFyIFBSRUZJWF9PUEVSQVRPUiA9IDMzO1xuICB2YXIgQlJBQ0tFVEVEID0gMzQ7XG4gIHZhciBDT05ESVRJT05BTCA9IDM1O1xuICB2YXIgSU5GSVhfT1BFUkFUT1IgPSAzNjtcblxuICB2YXIgSU5WT0NBVElPTiA9IDQwO1xuXG4gIHZhciBTRUNUSU9OX0lGID0gNTA7XG4gIHZhciBTRUNUSU9OX1VOTEVTUyA9IDUxO1xuICB2YXIgU0VDVElPTl9FQUNIID0gNTI7XG4gIHZhciBTRUNUSU9OX1dJVEggPSA1MztcbiAgdmFyIFNFQ1RJT05fSUZfV0lUSCA9IDU0O1xuXG4gIHZhciBFTFNFID0gNjA7XG4gIHZhciBFTFNFSUYgPSA2MTtcblxuICB2YXIgbXVzdGFjaGVfcmVhZERlbGltaXRlckNoYW5nZSA9IHJlYWREZWxpbWl0ZXJDaGFuZ2U7XG4gIHZhciBkZWxpbWl0ZXJDaGFuZ2VQYXR0ZXJuID0gL15bXlxccz1dKy8sXG4gICAgICB3aGl0ZXNwYWNlUGF0dGVybiA9IC9eXFxzKy87XG4gIGZ1bmN0aW9uIHJlYWREZWxpbWl0ZXJDaGFuZ2UocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBvcGVuaW5nLCBjbG9zaW5nO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI9XCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBuZXcgb3BlbmluZyBkZWxpbWl0ZXJcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRvcGVuaW5nID0gcGFyc2VyLm1hdGNoUGF0dGVybihkZWxpbWl0ZXJDaGFuZ2VQYXR0ZXJuKTtcbiAgXHRpZiAoIW9wZW5pbmcpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgKGluIGZhY3QsIGl0J3MgbmVjZXNzYXJ5Li4uKVxuICBcdGlmICghcGFyc2VyLm1hdGNoUGF0dGVybih3aGl0ZXNwYWNlUGF0dGVybikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGNsb3NpbmcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGRlbGltaXRlckNoYW5nZVBhdHRlcm4pO1xuICBcdGlmICghY2xvc2luZykge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgY2xvc2luZyAnPSdcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj1cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiBbb3BlbmluZywgY2xvc2luZ107XG4gIH1cblxuICB2YXIgcmVhZFJlZ2V4cExpdGVyYWwgPSByZWFkUmVnZXhwTGl0ZXJhbF9fcmVhZE51bWJlckxpdGVyYWw7XG4gIHZhciByZWdleHBQYXR0ZXJuID0gL14oXFwvKD86W15cXG5cXHJcXHUyMDI4XFx1MjAyOS9cXFxcW118XFxcXC58XFxbKD86W15cXG5cXHJcXHUyMDI4XFx1MjAyOVxcXVxcXFxdfFxcXFwuKSpdKStcXC8oPzooW2dpbXV5XSkoPyFbYS16XSpcXDIpKSooPyFbYS16QS1aXyQwLTldKSkvO1xuICBmdW5jdGlvbiByZWFkUmVnZXhwTGl0ZXJhbF9fcmVhZE51bWJlckxpdGVyYWwocGFyc2VyKSB7XG4gIFx0dmFyIHJlc3VsdDtcblxuICBcdGlmIChyZXN1bHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHJlZ2V4cFBhdHRlcm4pKSB7XG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBSRUdFWFBfTElURVJBTCxcbiAgXHRcdFx0djogcmVzdWx0XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlID0gcmVhZE11c3RhY2hlO1xuXG4gIHZhciBkZWxpbWl0ZXJDaGFuZ2VUb2tlbiA9IHsgdDogREVMSU1DSEFOR0UsIGV4Y2x1ZGU6IHRydWUgfTtcbiAgZnVuY3Rpb24gcmVhZE11c3RhY2hlKHBhcnNlcikge1xuICBcdHZhciBtdXN0YWNoZSwgaTtcblxuICBcdC8vIElmIHdlJ3JlIGluc2lkZSBhIDxzY3JpcHQ+IG9yIDxzdHlsZT4gdGFnLCBhbmQgd2UncmUgbm90XG4gIFx0Ly8gaW50ZXJwb2xhdGluZywgYnVnIG91dFxuICBcdGlmIChwYXJzZXIuaW50ZXJwb2xhdGVbcGFyc2VyLmluc2lkZV0gPT09IGZhbHNlKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgcGFyc2VyLnRhZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdGlmIChtdXN0YWNoZSA9IHJlYWRNdXN0YWNoZU9mVHlwZShwYXJzZXIsIHBhcnNlci50YWdzW2ldKSkge1xuICBcdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZE11c3RhY2hlT2ZUeXBlKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIHN0YXJ0LCBtdXN0YWNoZSwgcmVhZGVyLCBpO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIlxcXFxcIiArIHRhZy5vcGVuKSkge1xuICBcdFx0aWYgKHN0YXJ0ID09PSAwIHx8IHBhcnNlci5zdHJbc3RhcnQgLSAxXSAhPT0gXCJcXFxcXCIpIHtcbiAgXHRcdFx0cmV0dXJuIHRhZy5vcGVuO1xuICBcdFx0fVxuICBcdH0gZWxzZSBpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcub3BlbikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGRlbGltaXRlciBjaGFuZ2U/XG4gIFx0aWYgKG11c3RhY2hlID0gbXVzdGFjaGVfcmVhZERlbGltaXRlckNoYW5nZShwYXJzZXIpKSB7XG4gIFx0XHQvLyBmaW5kIGNsb3NpbmcgZGVsaW1pdGVyIG9yIGFib3J0Li4uXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHQvLyAuLi50aGVuIG1ha2UgdGhlIHN3aXRjaFxuICBcdFx0dGFnLm9wZW4gPSBtdXN0YWNoZVswXTtcbiAgXHRcdHRhZy5jbG9zZSA9IG11c3RhY2hlWzFdO1xuICBcdFx0cGFyc2VyLnNvcnRNdXN0YWNoZVRhZ3MoKTtcblxuICBcdFx0cmV0dXJuIGRlbGltaXRlckNoYW5nZVRva2VuO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIGlsbGVnYWwgc2VjdGlvbiBjbG9zZXJcbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiL1wiKSkge1xuICBcdFx0cGFyc2VyLnBvcyAtPSAxO1xuICBcdFx0dmFyIHJld2luZCA9IHBhcnNlci5wb3M7XG4gIFx0XHRpZiAoIXJlYWRSZWdleHBMaXRlcmFsKHBhcnNlcikpIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHJld2luZCAtIHRhZy5jbG9zZS5sZW5ndGg7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkF0dGVtcHRlZCB0byBjbG9zZSBhIHNlY3Rpb24gdGhhdCB3YXNuJ3Qgb3BlblwiKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSByZXdpbmQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Zm9yIChpID0gMDsgaSA8IHRhZy5yZWFkZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRyZWFkZXIgPSB0YWcucmVhZGVyc1tpXTtcblxuICBcdFx0aWYgKG11c3RhY2hlID0gcmVhZGVyKHBhcnNlciwgdGFnKSkge1xuICBcdFx0XHRpZiAodGFnLmlzU3RhdGljKSB7XG4gIFx0XHRcdFx0bXVzdGFjaGUucyA9IHRydWU7IC8vIFRPRE8gbWFrZSB0aGlzIGAxYCBpbnN0ZWFkIC0gbW9yZSBjb21wYWN0XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAocGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zKSB7XG4gIFx0XHRcdFx0bXVzdGFjaGUucCA9IHBhcnNlci5nZXRMaW5lUG9zKHN0YXJ0KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBtdXN0YWNoZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXhwZWN0ZWRFeHByZXNzaW9uID0gXCJFeHBlY3RlZCBhIEphdmFTY3JpcHQgZXhwcmVzc2lvblwiO1xuICB2YXIgZXhwZWN0ZWRQYXJlbiA9IFwiRXhwZWN0ZWQgY2xvc2luZyBwYXJlblwiO1xuXG4gIHZhciBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsID0gbGl0ZXJhbF9yZWFkTnVtYmVyTGl0ZXJhbF9fcmVhZE51bWJlckxpdGVyYWw7XG4gIHZhciBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsX19udW1iZXJQYXR0ZXJuID0gL14oPzpbKy1dPykwKig/Oig/Oig/OlsxLTldXFxkKik/XFwuXFxkKyl8KD86KD86MHxbMS05XVxcZCopXFwuKXwoPzowfFsxLTldXFxkKikpKD86W2VFXVsrLV0/XFxkKyk/LztcbiAgZnVuY3Rpb24gbGl0ZXJhbF9yZWFkTnVtYmVyTGl0ZXJhbF9fcmVhZE51bWJlckxpdGVyYWwocGFyc2VyKSB7XG4gIFx0dmFyIHJlc3VsdDtcblxuICBcdGlmIChyZXN1bHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWxfX251bWJlclBhdHRlcm4pKSB7XG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBOVU1CRVJfTElURVJBTCxcbiAgXHRcdFx0djogcmVzdWx0XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxpdGVyYWxfcmVhZEJvb2xlYW5MaXRlcmFsID0gcmVhZEJvb2xlYW5MaXRlcmFsO1xuICBmdW5jdGlvbiByZWFkQm9vbGVhbkxpdGVyYWwocGFyc2VyKSB7XG4gIFx0dmFyIHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblxuICBcdGlmIChyZW1haW5pbmcuc3Vic3RyKDAsIDQpID09PSBcInRydWVcIikge1xuICBcdFx0cGFyc2VyLnBvcyArPSA0O1xuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogQk9PTEVBTl9MSVRFUkFMLFxuICBcdFx0XHR2OiBcInRydWVcIlxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRpZiAocmVtYWluaW5nLnN1YnN0cigwLCA1KSA9PT0gXCJmYWxzZVwiKSB7XG4gIFx0XHRwYXJzZXIucG9zICs9IDU7XG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBCT09MRUFOX0xJVEVSQUwsXG4gIFx0XHRcdHY6IFwiZmFsc2VcIlxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzdHJpbmdNaWRkbGVQYXR0ZXJuLCBlc2NhcGVTZXF1ZW5jZVBhdHRlcm4sIGxpbmVDb250aW51YXRpb25QYXR0ZXJuO1xuXG4gIC8vIE1hdGNoIG9uZSBvciBtb3JlIGNoYXJhY3RlcnMgdW50aWw6IFwiLCAnLCBcXCwgb3IgRU9ML0VPRi5cbiAgLy8gRU9ML0VPRiBpcyB3cml0dGVuIGFzICg/IS4pIChtZWFuaW5nIHRoZXJlJ3Mgbm8gbm9uLW5ld2xpbmUgY2hhciBuZXh0KS5cbiAgc3RyaW5nTWlkZGxlUGF0dGVybiA9IC9eKD89LilbXlwiJ1xcXFxdKz8oPzooPyEuKXwoPz1bXCInXFxcXF0pKS87XG5cbiAgLy8gTWF0Y2ggb25lIGVzY2FwZSBzZXF1ZW5jZSwgaW5jbHVkaW5nIHRoZSBiYWNrc2xhc2guXG4gIGVzY2FwZVNlcXVlbmNlUGF0dGVybiA9IC9eXFxcXCg/OlsnXCJcXFxcYmZucnRdfDAoPyFbMC05XSl8eFswLTlhLWZBLUZdezJ9fHVbMC05YS1mQS1GXXs0fXwoPz0uKVtedXgwLTldKS87XG5cbiAgLy8gTWF0Y2ggb25lIEVTNSBsaW5lIGNvbnRpbnVhdGlvbiAoYmFja3NsYXNoICsgbGluZSB0ZXJtaW5hdG9yKS5cbiAgbGluZUNvbnRpbnVhdGlvblBhdHRlcm4gPSAvXlxcXFwoPzpcXHJcXG58W1xcdTAwMEFcXHUwMDBEXFx1MjAyOFxcdTIwMjldKS87XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyBnZXREb3VibGVRdW90ZWRTdHJpbmcgYW5kIGdldFNpbmdsZVF1b3RlZFN0cmluZy5cbiAgdmFyIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyID0gZnVuY3Rpb24gKG9rUXVvdGUpIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdFx0dmFyIHN0YXJ0LCBsaXRlcmFsLCBkb25lLCBuZXh0O1xuXG4gIFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG4gIFx0XHRsaXRlcmFsID0gXCJcXFwiXCI7XG4gIFx0XHRkb25lID0gZmFsc2U7XG5cbiAgXHRcdHdoaWxlICghZG9uZSkge1xuICBcdFx0XHRuZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybihzdHJpbmdNaWRkbGVQYXR0ZXJuKSB8fCBwYXJzZXIubWF0Y2hQYXR0ZXJuKGVzY2FwZVNlcXVlbmNlUGF0dGVybikgfHwgcGFyc2VyLm1hdGNoU3RyaW5nKG9rUXVvdGUpO1xuICBcdFx0XHRpZiAobmV4dCkge1xuICBcdFx0XHRcdGlmIChuZXh0ID09PSBcIlxcXCJcIikge1xuICBcdFx0XHRcdFx0bGl0ZXJhbCArPSBcIlxcXFxcXFwiXCI7XG4gIFx0XHRcdFx0fSBlbHNlIGlmIChuZXh0ID09PSBcIlxcXFwnXCIpIHtcbiAgXHRcdFx0XHRcdGxpdGVyYWwgKz0gXCInXCI7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGxpdGVyYWwgKz0gbmV4dDtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0bmV4dCA9IHBhcnNlci5tYXRjaFBhdHRlcm4obGluZUNvbnRpbnVhdGlvblBhdHRlcm4pO1xuICBcdFx0XHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdFx0XHQvLyBjb252ZXJ0IFxcKG5ld2xpbmUtbGlrZSkgaW50byBhIFxcdSBlc2NhcGUsIHdoaWNoIGlzIGFsbG93ZWQgaW4gSlNPTlxuICBcdFx0XHRcdFx0bGl0ZXJhbCArPSBcIlxcXFx1XCIgKyAoXCIwMDBcIiArIG5leHQuY2hhckNvZGVBdCgxKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0ZG9uZSA9IHRydWU7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGxpdGVyYWwgKz0gXCJcXFwiXCI7XG5cbiAgXHRcdC8vIHVzZSBKU09OLnBhcnNlIHRvIGludGVycHJldCBlc2NhcGVzXG4gIFx0XHRyZXR1cm4gSlNPTi5wYXJzZShsaXRlcmFsKTtcbiAgXHR9O1xuICB9O1xuXG4gIHZhciBnZXRTaW5nbGVRdW90ZWRTdHJpbmcgPSBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlcihcIlxcXCJcIik7XG4gIHZhciBnZXREb3VibGVRdW90ZWRTdHJpbmcgPSBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlcihcIidcIik7XG5cbiAgdmFyIHJlYWRTdHJpbmdMaXRlcmFsID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgc3RyaW5nO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIlxcXCJcIikpIHtcbiAgXHRcdHN0cmluZyA9IGdldERvdWJsZVF1b3RlZFN0cmluZyhwYXJzZXIpO1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIlxcXCJcIikpIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogU1RSSU5HX0xJVEVSQUwsXG4gIFx0XHRcdHY6IHN0cmluZ1xuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiJ1wiKSkge1xuICBcdFx0c3RyaW5nID0gZ2V0U2luZ2xlUXVvdGVkU3RyaW5nKHBhcnNlcik7XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiJ1wiKSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBTVFJJTkdfTElURVJBTCxcbiAgXHRcdFx0djogc3RyaW5nXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBwYXR0ZXJuc19fbmFtZSA9IC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qLztcblxuICAvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXByb3BlcnRpZXNcbiAgLy8gY2FuIGJlIGFueSBuYW1lLCBzdHJpbmcgbGl0ZXJhbCwgb3IgbnVtYmVyIGxpdGVyYWxcbiAgdmFyIHNoYXJlZF9yZWFkS2V5ID0gcmVhZEtleTtcbiAgdmFyIGlkZW50aWZpZXIgPSAvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKiQvO1xuICBmdW5jdGlvbiByZWFkS2V5KHBhcnNlcikge1xuICBcdHZhciB0b2tlbjtcblxuICBcdGlmICh0b2tlbiA9IHJlYWRTdHJpbmdMaXRlcmFsKHBhcnNlcikpIHtcbiAgXHRcdHJldHVybiBpZGVudGlmaWVyLnRlc3QodG9rZW4udikgPyB0b2tlbi52IDogXCJcXFwiXCIgKyB0b2tlbi52LnJlcGxhY2UoL1wiL2csIFwiXFxcXFxcXCJcIikgKyBcIlxcXCJcIjtcbiAgXHR9XG5cbiAgXHRpZiAodG9rZW4gPSBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsKHBhcnNlcikpIHtcbiAgXHRcdHJldHVybiB0b2tlbi52O1xuICBcdH1cblxuICBcdGlmICh0b2tlbiA9IHBhcnNlci5tYXRjaFBhdHRlcm4ocGF0dGVybnNfX25hbWUpKSB7XG4gIFx0XHRyZXR1cm4gdG9rZW47XG4gIFx0fVxuICB9XG5cbiAgdmFyIGtleVZhbHVlUGFpciA9IHJlYWRLZXlWYWx1ZVBhaXI7XG4gIGZ1bmN0aW9uIHJlYWRLZXlWYWx1ZVBhaXIocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBrZXksIHZhbHVlO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuICd7JyBhbmQga2V5XG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0a2V5ID0gc2hhcmVkX3JlYWRLZXkocGFyc2VyKTtcbiAgXHRpZiAoa2V5ID09PSBudWxsKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4ga2V5IGFuZCAnOidcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBuZXh0IGNoYXJhY3RlciBtdXN0IGJlICc6J1xuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiOlwiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuICc6JyBhbmQgdmFsdWVcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBuZXh0IGV4cHJlc3Npb24gbXVzdCBiZSBhLCB3ZWxsLi4uIGV4cHJlc3Npb25cbiAgXHR2YWx1ZSA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBLRVlfVkFMVUVfUEFJUixcbiAgXHRcdGs6IGtleSxcbiAgXHRcdHY6IHZhbHVlXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBvYmplY3RMaXRlcmFsX2tleVZhbHVlUGFpcnMgPSByZWFkS2V5VmFsdWVQYWlycztcbiAgZnVuY3Rpb24gcmVhZEtleVZhbHVlUGFpcnMocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBwYWlycywgcGFpciwga2V5VmFsdWVQYWlycztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdHBhaXIgPSBrZXlWYWx1ZVBhaXIocGFyc2VyKTtcbiAgXHRpZiAocGFpciA9PT0gbnVsbCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFpcnMgPSBbcGFpcl07XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiLFwiKSkge1xuICBcdFx0a2V5VmFsdWVQYWlycyA9IHJlYWRLZXlWYWx1ZVBhaXJzKHBhcnNlcik7XG5cbiAgXHRcdGlmICgha2V5VmFsdWVQYWlycykge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gcGFpcnMuY29uY2F0KGtleVZhbHVlUGFpcnMpO1xuICBcdH1cblxuICBcdHJldHVybiBwYWlycztcbiAgfVxuXG4gIHZhciByZWFkT2JqZWN0TGl0ZXJhbCA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGtleVZhbHVlUGFpcnM7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJ7XCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRrZXlWYWx1ZVBhaXJzID0gb2JqZWN0TGl0ZXJhbF9rZXlWYWx1ZVBhaXJzKHBhcnNlcik7XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gZmluYWwgdmFsdWUgYW5kICd9J1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwifVwiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IE9CSkVDVF9MSVRFUkFMLFxuICBcdFx0bToga2V5VmFsdWVQYWlyc1xuICBcdH07XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9yZWFkRXhwcmVzc2lvbkxpc3QgPSByZWFkRXhwcmVzc2lvbkxpc3Q7XG4gIGZ1bmN0aW9uIHJlYWRFeHByZXNzaW9uTGlzdChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb25zLCBleHByLCBuZXh0O1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0ZXhwciA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcblxuICBcdGlmIChleHByID09PSBudWxsKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRleHByZXNzaW9ucyA9IFtleHByXTtcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBleHByZXNzaW9uIGFuZCAnLCdcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiLFwiKSkge1xuICBcdFx0bmV4dCA9IHJlYWRFeHByZXNzaW9uTGlzdChwYXJzZXIpO1xuICBcdFx0aWYgKG5leHQgPT09IG51bGwpIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkRXhwcmVzc2lvbik7XG4gIFx0XHR9XG5cbiAgXHRcdG5leHQuZm9yRWFjaChhcHBlbmQpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIGFwcGVuZChleHByZXNzaW9uKSB7XG4gIFx0XHRleHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xuICBcdH1cblxuICBcdHJldHVybiBleHByZXNzaW9ucztcbiAgfVxuXG4gIHZhciByZWFkQXJyYXlMaXRlcmFsID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbkxpc3Q7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSAnWydcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIltcIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGV4cHJlc3Npb25MaXN0ID0gc2hhcmVkX3JlYWRFeHByZXNzaW9uTGlzdChwYXJzZXIpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJdXCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogQVJSQVlfTElURVJBTCxcbiAgXHRcdG06IGV4cHJlc3Npb25MaXN0XG4gIFx0fTtcbiAgfTtcblxuICB2YXIgcHJpbWFyeV9yZWFkTGl0ZXJhbCA9IHJlYWRMaXRlcmFsO1xuICBmdW5jdGlvbiByZWFkTGl0ZXJhbChwYXJzZXIpIHtcbiAgXHRyZXR1cm4gbGl0ZXJhbF9yZWFkTnVtYmVyTGl0ZXJhbChwYXJzZXIpIHx8IGxpdGVyYWxfcmVhZEJvb2xlYW5MaXRlcmFsKHBhcnNlcikgfHwgcmVhZFN0cmluZ0xpdGVyYWwocGFyc2VyKSB8fCByZWFkT2JqZWN0TGl0ZXJhbChwYXJzZXIpIHx8IHJlYWRBcnJheUxpdGVyYWwocGFyc2VyKSB8fCByZWFkUmVnZXhwTGl0ZXJhbChwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHByaW1hcnlfcmVhZFJlZmVyZW5jZSA9IHJlYWRSZWZlcmVuY2U7XG4gIHZhciBwcmVmaXhQYXR0ZXJuID0gL14oPzp+XFwvfCg/OlxcLlxcLlxcLykrfFxcLlxcLyg/OlxcLlxcLlxcLykqfFxcLikvLFxuICAgICAgZ2xvYmFscyxcbiAgICAgIGtleXdvcmRzO1xuXG4gIC8vIGlmIGEgcmVmZXJlbmNlIGlzIGEgYnJvd3NlciBnbG9iYWwsIHdlIGRvbid0IGRlZmVyZW5jZSBpdCBsYXRlciwgc28gaXQgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnRcbiAgZ2xvYmFscyA9IC9eKD86QXJyYXl8Y29uc29sZXxEYXRlfFJlZ0V4cHxkZWNvZGVVUklDb21wb25lbnR8ZGVjb2RlVVJJfGVuY29kZVVSSUNvbXBvbmVudHxlbmNvZGVVUkl8aXNGaW5pdGV8aXNOYU58cGFyc2VGbG9hdHxwYXJzZUludHxKU09OfE1hdGh8TmFOfHVuZGVmaW5lZHxudWxsKVxcYi87XG5cbiAgLy8ga2V5d29yZHMgYXJlIG5vdCB2YWxpZCByZWZlcmVuY2VzLCB3aXRoIHRoZSBleGNlcHRpb24gb2YgYHRoaXNgXG4gIGtleXdvcmRzID0gL14oPzpicmVha3xjYXNlfGNhdGNofGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZmluYWxseXxmb3J8ZnVuY3Rpb258aWZ8aW58aW5zdGFuY2VvZnxuZXd8cmV0dXJufHN3aXRjaHx0aHJvd3x0cnl8dHlwZW9mfHZhcnx2b2lkfHdoaWxlfHdpdGgpJC87XG5cbiAgdmFyIGxlZ2FsUmVmZXJlbmNlID0gL15bYS16QS1aJF8wLTldKyg/Oig/OlxcLlthLXpBLVokXzAtOV0rKXwoPzpcXFtbMC05XStcXF0pKSovO1xuICB2YXIgcmVsYXhlZE5hbWUgPSAvXlthLXpBLVpfJF1bLWEtekEtWl8kMC05XSovO1xuICBmdW5jdGlvbiByZWFkUmVmZXJlbmNlKHBhcnNlcikge1xuICBcdHZhciBzdGFydFBvcywgcHJlZml4LCBuYW1lLCBnbG9iYWwsIHJlZmVyZW5jZSwgbGFzdERvdEluZGV4O1xuXG4gIFx0c3RhcnRQb3MgPSBwYXJzZXIucG9zO1xuXG4gIFx0bmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oL15AKD86a2V5cGF0aHxpbmRleHxrZXkpLyk7XG5cbiAgXHRpZiAoIW5hbWUpIHtcbiAgXHRcdHByZWZpeCA9IHBhcnNlci5tYXRjaFBhdHRlcm4ocHJlZml4UGF0dGVybikgfHwgXCJcIjtcbiAgXHRcdG5hbWUgPSAhcHJlZml4ICYmIHBhcnNlci5yZWxheGVkTmFtZXMgJiYgcGFyc2VyLm1hdGNoUGF0dGVybihyZWxheGVkTmFtZSkgfHwgcGFyc2VyLm1hdGNoUGF0dGVybihsZWdhbFJlZmVyZW5jZSk7XG5cbiAgXHRcdGlmICghbmFtZSAmJiBwcmVmaXggPT09IFwiLlwiKSB7XG4gIFx0XHRcdHByZWZpeCA9IFwiXCI7XG4gIFx0XHRcdG5hbWUgPSBcIi5cIjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoIW5hbWUpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGJ1ZyBvdXQgaWYgaXQncyBhIGtleXdvcmQgKGV4Y2VwdGlvbiBmb3IgYW5jZXN0b3IvcmVzdHJpY3RlZCByZWZzIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMvMTQ5NylcbiAgXHRpZiAoIXByZWZpeCAmJiAhcGFyc2VyLnJlbGF4ZWROYW1lcyAmJiBrZXl3b3Jkcy50ZXN0KG5hbWUpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3M7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBpZiB0aGlzIGlzIGEgYnJvd3NlciBnbG9iYWwsIHN0b3AgaGVyZVxuICBcdGlmICghcHJlZml4ICYmIGdsb2JhbHMudGVzdChuYW1lKSkge1xuICBcdFx0Z2xvYmFsID0gZ2xvYmFscy5leGVjKG5hbWUpWzBdO1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0UG9zICsgZ2xvYmFsLmxlbmd0aDtcblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogR0xPQkFMLFxuICBcdFx0XHR2OiBnbG9iYWxcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmVmZXJlbmNlID0gKHByZWZpeCB8fCBcIlwiKSArIG5vcm1hbGlzZShuYW1lKTtcblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIoXCIpKSB7XG4gIFx0XHQvLyBpZiB0aGlzIGlzIGEgbWV0aG9kIGludm9jYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBmdW5jdGlvbikgd2UgbmVlZFxuICBcdFx0Ly8gdG8gc3RyaXAgdGhlIG1ldGhvZCBuYW1lIGZyb20gdGhlIHJlZmVyZW5jZSBjb21ibywgZWxzZSB0aGUgY29udGV4dFxuICBcdFx0Ly8gd2lsbCBiZSB3cm9uZ1xuICBcdFx0bGFzdERvdEluZGV4ID0gcmVmZXJlbmNlLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgXHRcdGlmIChsYXN0RG90SW5kZXggIT09IC0xKSB7XG4gIFx0XHRcdHJlZmVyZW5jZSA9IHJlZmVyZW5jZS5zdWJzdHIoMCwgbGFzdERvdEluZGV4KTtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0UG9zICsgcmVmZXJlbmNlLmxlbmd0aDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgLT0gMTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogUkVGRVJFTkNFLFxuICBcdFx0bjogcmVmZXJlbmNlLnJlcGxhY2UoL150aGlzXFwuLywgXCIuL1wiKS5yZXBsYWNlKC9edGhpcyQvLCBcIi5cIilcbiAgXHR9O1xuICB9XG5cbiAgdmFyIHByaW1hcnlfcmVhZEJyYWNrZXRlZEV4cHJlc3Npb24gPSByZWFkQnJhY2tldGVkRXhwcmVzc2lvbjtcbiAgZnVuY3Rpb24gcmVhZEJyYWNrZXRlZEV4cHJlc3Npb24ocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIoXCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRleHByID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdGlmICghZXhwcikge1xuICBcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkRXhwcmVzc2lvbik7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIpXCIpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRQYXJlbik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IEJSQUNLRVRFRCxcbiAgXHRcdHg6IGV4cHJcbiAgXHR9O1xuICB9XG5cbiAgdmFyIHJlYWRQcmltYXJ5ID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdHJldHVybiBwcmltYXJ5X3JlYWRMaXRlcmFsKHBhcnNlcikgfHwgcHJpbWFyeV9yZWFkUmVmZXJlbmNlKHBhcnNlcikgfHwgcHJpbWFyeV9yZWFkQnJhY2tldGVkRXhwcmVzc2lvbihwYXJzZXIpO1xuICB9O1xuXG4gIHZhciBzaGFyZWRfcmVhZFJlZmluZW1lbnQgPSByZWFkUmVmaW5lbWVudDtcbiAgZnVuY3Rpb24gcmVhZFJlZmluZW1lbnQocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBuYW1lLCBleHByO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gXCIuXCIgbmFtZVxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIuXCIpKSB7XG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGlmIChuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybihwYXR0ZXJuc19fbmFtZSkpIHtcbiAgXHRcdFx0cmV0dXJuIHtcbiAgXHRcdFx0XHR0OiBSRUZJTkVNRU5ULFxuICBcdFx0XHRcdG46IG5hbWVcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgYSBwcm9wZXJ0eSBuYW1lXCIpO1xuICBcdH1cblxuICBcdC8vIFwiW1wiIGV4cHJlc3Npb24gXCJdXCJcbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiW1wiKSkge1xuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRleHByID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdFx0aWYgKCFleHByKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihleHBlY3RlZEV4cHJlc3Npb24pO1xuICBcdFx0fVxuXG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiXVwiKSkge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCAnXSdcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IFJFRklORU1FTlQsXG4gIFx0XHRcdHg6IGV4cHJcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcmVhZE1lbWJlck9ySW52b2NhdGlvbiA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHR2YXIgY3VycmVudCwgZXhwcmVzc2lvbiwgcmVmaW5lbWVudCwgZXhwcmVzc2lvbkxpc3Q7XG5cbiAgXHRleHByZXNzaW9uID0gcmVhZFByaW1hcnkocGFyc2VyKTtcblxuICBcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0d2hpbGUgKGV4cHJlc3Npb24pIHtcbiAgXHRcdGN1cnJlbnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0XHRpZiAocmVmaW5lbWVudCA9IHNoYXJlZF9yZWFkUmVmaW5lbWVudChwYXJzZXIpKSB7XG4gIFx0XHRcdGV4cHJlc3Npb24gPSB7XG4gIFx0XHRcdFx0dDogTUVNQkVSLFxuICBcdFx0XHRcdHg6IGV4cHJlc3Npb24sXG4gIFx0XHRcdFx0cjogcmVmaW5lbWVudFxuICBcdFx0XHR9O1xuICBcdFx0fSBlbHNlIGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIoXCIpKSB7XG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHRcdFx0ZXhwcmVzc2lvbkxpc3QgPSBzaGFyZWRfcmVhZEV4cHJlc3Npb25MaXN0KHBhcnNlcik7XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiKVwiKSkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihleHBlY3RlZFBhcmVuKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGV4cHJlc3Npb24gPSB7XG4gIFx0XHRcdFx0dDogSU5WT0NBVElPTixcbiAgXHRcdFx0XHR4OiBleHByZXNzaW9uXG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0aWYgKGV4cHJlc3Npb25MaXN0KSB7XG4gIFx0XHRcdFx0ZXhwcmVzc2lvbi5vID0gZXhwcmVzc2lvbkxpc3Q7XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGJyZWFrO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBleHByZXNzaW9uO1xuICB9O1xuXG4gIHZhciByZWFkVHlwZU9mLCBtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyO1xuXG4gIG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXIgPSBmdW5jdGlvbiAoc3ltYm9sLCBmYWxsdGhyb3VnaCkge1xuICBcdHJldHVybiBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0XHR2YXIgZXhwcmVzc2lvbjtcblxuICBcdFx0aWYgKGV4cHJlc3Npb24gPSBmYWxsdGhyb3VnaChwYXJzZXIpKSB7XG4gIFx0XHRcdHJldHVybiBleHByZXNzaW9uO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhzeW1ib2wpKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0XHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkRXhwcmVzc2lvbik7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHM6IHN5bWJvbCxcbiAgXHRcdFx0bzogZXhwcmVzc2lvbixcbiAgXHRcdFx0dDogUFJFRklYX09QRVJBVE9SXG4gIFx0XHR9O1xuICBcdH07XG4gIH07XG5cbiAgLy8gY3JlYXRlIGFsbCBwcmVmaXggc2VxdWVuY2UgbWF0Y2hlcnMsIHJldHVybiByZWFkVHlwZU9mXG4gIChmdW5jdGlvbiAoKSB7XG4gIFx0dmFyIGksIGxlbiwgbWF0Y2hlciwgcHJlZml4T3BlcmF0b3JzLCBmYWxsdGhyb3VnaDtcblxuICBcdHByZWZpeE9wZXJhdG9ycyA9IFwiISB+ICsgLSB0eXBlb2ZcIi5zcGxpdChcIiBcIik7XG5cbiAgXHRmYWxsdGhyb3VnaCA9IHJlYWRNZW1iZXJPckludm9jYXRpb247XG4gIFx0Zm9yIChpID0gMCwgbGVuID0gcHJlZml4T3BlcmF0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRtYXRjaGVyID0gbWFrZVByZWZpeFNlcXVlbmNlTWF0Y2hlcihwcmVmaXhPcGVyYXRvcnNbaV0sIGZhbGx0aHJvdWdoKTtcbiAgXHRcdGZhbGx0aHJvdWdoID0gbWF0Y2hlcjtcbiAgXHR9XG5cbiAgXHQvLyB0eXBlb2Ygb3BlcmF0b3IgaXMgaGlnaGVyIHByZWNlZGVuY2UgdGhhbiBtdWx0aXBsaWNhdGlvbiwgc28gcHJvdmlkZXMgdGhlXG4gIFx0Ly8gZmFsbHRocm91Z2ggZm9yIHRoZSBtdWx0aXBsaWNhdGlvbiBzZXF1ZW5jZSBtYXRjaGVyIHdlJ3JlIGFib3V0IHRvIGNyZWF0ZVxuICBcdC8vICh3ZSdyZSBza2lwcGluZyB2b2lkIGFuZCBkZWxldGUpXG4gIFx0cmVhZFR5cGVPZiA9IGZhbGx0aHJvdWdoO1xuICB9KSgpO1xuXG4gIHZhciByZWFkVHlwZW9mID0gcmVhZFR5cGVPZjtcblxuICB2YXIgcmVhZExvZ2ljYWxPciwgbWFrZUluZml4U2VxdWVuY2VNYXRjaGVyO1xuXG4gIG1ha2VJbmZpeFNlcXVlbmNlTWF0Y2hlciA9IGZ1bmN0aW9uIChzeW1ib2wsIGZhbGx0aHJvdWdoKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHRcdHZhciBzdGFydCwgbGVmdCwgcmlnaHQ7XG5cbiAgXHRcdGxlZnQgPSBmYWxsdGhyb3VnaChwYXJzZXIpO1xuICBcdFx0aWYgKCFsZWZ0KSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBMb29wIHRvIGhhbmRsZSBsZWZ0LXJlY3Vyc2lvbiBpbiBhIGNhc2UgbGlrZSBgYSAqIGIgKiBjYCBhbmQgcHJvZHVjZVxuICBcdFx0Ly8gbGVmdCBhc3NvY2lhdGlvbiwgaS5lLiBgKGEgKiBiKSAqIGNgLiAgVGhlIG1hdGNoZXIgY2FuJ3QgY2FsbCBpdHNlbGZcbiAgXHRcdC8vIHRvIHBhcnNlIGBsZWZ0YCBiZWNhdXNlIHRoYXQgd291bGQgYmUgaW5maW5pdGUgcmVncmVzcy5cbiAgXHRcdHdoaWxlICh0cnVlKSB7XG4gIFx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoc3ltYm9sKSkge1xuICBcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0XHRyZXR1cm4gbGVmdDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGluIG9wZXJhdG9yIG11c3Qgbm90IGJlIGZvbGxvd2VkIGJ5IFthLXpBLVpfJDAtOV1cbiAgXHRcdFx0aWYgKHN5bWJvbCA9PT0gXCJpblwiICYmIC9bYS16QS1aXyQwLTldLy50ZXN0KHBhcnNlci5yZW1haW5pbmcoKS5jaGFyQXQoMCkpKSB7XG4gIFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRcdHJldHVybiBsZWZ0O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRcdC8vIHJpZ2h0IG9wZXJhbmQgbXVzdCBhbHNvIGNvbnNpc3Qgb2Ygb25seSBoaWdoZXItcHJlY2VkZW5jZSBvcGVyYXRvcnNcbiAgXHRcdFx0cmlnaHQgPSBmYWxsdGhyb3VnaChwYXJzZXIpO1xuICBcdFx0XHRpZiAoIXJpZ2h0KSB7XG4gIFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRcdHJldHVybiBsZWZ0O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0bGVmdCA9IHtcbiAgXHRcdFx0XHR0OiBJTkZJWF9PUEVSQVRPUixcbiAgXHRcdFx0XHRzOiBzeW1ib2wsXG4gIFx0XHRcdFx0bzogW2xlZnQsIHJpZ2h0XVxuICBcdFx0XHR9O1xuXG4gIFx0XHRcdC8vIExvb3AgYmFjayBhcm91bmQuICBJZiB3ZSBkb24ndCBzZWUgYW5vdGhlciBvY2N1cnJlbmNlIG9mIHRoZSBzeW1ib2wsXG4gIFx0XHRcdC8vIHdlJ2xsIHJldHVybiBsZWZ0LlxuICBcdFx0fVxuICBcdH07XG4gIH07XG5cbiAgLy8gY3JlYXRlIGFsbCBpbmZpeCBzZXF1ZW5jZSBtYXRjaGVycywgYW5kIHJldHVybiByZWFkTG9naWNhbE9yXG4gIChmdW5jdGlvbiAoKSB7XG4gIFx0dmFyIGksIGxlbiwgbWF0Y2hlciwgaW5maXhPcGVyYXRvcnMsIGZhbGx0aHJvdWdoO1xuXG4gIFx0Ly8gQWxsIHRoZSBpbmZpeCBvcGVyYXRvcnMgb24gb3JkZXIgb2YgcHJlY2VkZW5jZSAoc291cmNlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9PcGVyYXRvcl9QcmVjZWRlbmNlKVxuICBcdC8vIEVhY2ggc2VxdWVuY2UgbWF0Y2hlciB3aWxsIGluaXRpYWxseSBmYWxsIHRocm91Z2ggdG8gaXRzIGhpZ2hlciBwcmVjZWRlbmNlXG4gIFx0Ly8gbmVpZ2hib3VyLCBhbmQgb25seSBhdHRlbXB0IHRvIG1hdGNoIGlmIG9uZSBvZiB0aGUgaGlnaGVyIHByZWNlZGVuY2Ugb3BlcmF0b3JzXG4gIFx0Ly8gKG9yLCB1bHRpbWF0ZWx5LCBhIGxpdGVyYWwsIHJlZmVyZW5jZSwgb3IgYnJhY2tldGVkIGV4cHJlc3Npb24pIGFscmVhZHkgbWF0Y2hlZFxuICBcdGluZml4T3BlcmF0b3JzID0gXCIqIC8gJSArIC0gPDwgPj4gPj4+IDwgPD0gPiA+PSBpbiBpbnN0YW5jZW9mID09ICE9ID09PSAhPT0gJiBeIHwgJiYgfHxcIi5zcGxpdChcIiBcIik7XG5cbiAgXHQvLyBBIHR5cGVvZiBvcGVyYXRvciBpcyBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuIG11bHRpcGxpY2F0aW9uXG4gIFx0ZmFsbHRocm91Z2ggPSByZWFkVHlwZW9mO1xuICBcdGZvciAoaSA9IDAsIGxlbiA9IGluZml4T3BlcmF0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRtYXRjaGVyID0gbWFrZUluZml4U2VxdWVuY2VNYXRjaGVyKGluZml4T3BlcmF0b3JzW2ldLCBmYWxsdGhyb3VnaCk7XG4gIFx0XHRmYWxsdGhyb3VnaCA9IG1hdGNoZXI7XG4gIFx0fVxuXG4gIFx0Ly8gTG9naWNhbCBPUiBpcyB0aGUgZmFsbHRocm91Z2ggZm9yIHRoZSBjb25kaXRpb25hbCBtYXRjaGVyXG4gIFx0cmVhZExvZ2ljYWxPciA9IGZhbGx0aHJvdWdoO1xuICB9KSgpO1xuXG4gIHZhciBleHByZXNzaW9uc19yZWFkTG9naWNhbE9yID0gcmVhZExvZ2ljYWxPcjtcblxuICAvLyBUaGUgY29uZGl0aW9uYWwgb3BlcmF0b3IgaXMgdGhlIGxvd2VzdCBwcmVjZWRlbmNlIG9wZXJhdG9yLCBzbyB3ZSBzdGFydCBoZXJlXG4gIHZhciByZWFkQ29uZGl0aW9uYWwgPSBnZXRDb25kaXRpb25hbDtcbiAgZnVuY3Rpb24gZ2V0Q29uZGl0aW9uYWwocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uLCBpZlRydWUsIGlmRmFsc2U7XG5cbiAgXHRleHByZXNzaW9uID0gZXhwcmVzc2lvbnNfcmVhZExvZ2ljYWxPcihwYXJzZXIpO1xuICBcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI/XCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZlRydWUgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0aWYgKCFpZlRydWUpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihleHBlY3RlZEV4cHJlc3Npb24pO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiOlwiKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgXFxcIjpcXFwiXCIpO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmRmFsc2UgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0aWYgKCFpZkZhbHNlKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogQ09ORElUSU9OQUwsXG4gIFx0XHRvOiBbZXhwcmVzc2lvbiwgaWZUcnVlLCBpZkZhbHNlXVxuICBcdH07XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkRXhwcmVzc2lvbiA9IHJlYWRFeHByZXNzaW9uO1xuICBmdW5jdGlvbiByZWFkRXhwcmVzc2lvbihwYXJzZXIpIHtcbiAgXHQvLyBUaGUgY29uZGl0aW9uYWwgb3BlcmF0b3IgaXMgdGhlIGxvd2VzdCBwcmVjZWRlbmNlIG9wZXJhdG9yIChleGNlcHQgeWllbGQsXG4gIFx0Ly8gYXNzaWdubWVudCBvcGVyYXRvcnMsIGFuZCBjb21tYXMsIG5vbmUgb2Ygd2hpY2ggYXJlIHN1cHBvcnRlZCksIHNvIHdlXG4gIFx0Ly8gc3RhcnQgdGhlcmUuIElmIGl0IGRvZXNuJ3QgbWF0Y2gsIGl0ICdmYWxscyB0aHJvdWdoJyB0byBwcm9ncmVzc2l2ZWx5XG4gIFx0Ly8gaGlnaGVyIHByZWNlZGVuY2Ugb3BlcmF0b3JzLCB1bnRpbCBpdCBldmVudHVhbGx5IG1hdGNoZXMgKG9yIGZhaWxzIHRvXG4gIFx0Ly8gbWF0Y2gpIGEgJ3ByaW1hcnknIC0gYSBsaXRlcmFsIG9yIGEgcmVmZXJlbmNlLiBUaGlzIHdheSwgdGhlIGFic3RyYWN0IHN5bnRheFxuICBcdC8vIHRyZWUgaGFzIGV2ZXJ5dGhpbmcgaW4gaXRzIHByb3BlciBwbGFjZSwgaS5lLiAyICsgMyAqIDQgPT09IDE0LCBub3QgMjAuXG4gIFx0cmV0dXJuIHJlYWRDb25kaXRpb25hbChwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHV0aWxzX2ZsYXR0ZW5FeHByZXNzaW9uID0gZmxhdHRlbkV4cHJlc3Npb247XG5cbiAgZnVuY3Rpb24gZmxhdHRlbkV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICBcdHZhciByZWZzO1xuXG4gIFx0ZXh0cmFjdFJlZnMoZXhwcmVzc2lvbiwgcmVmcyA9IFtdKTtcblxuICBcdHJldHVybiB7XG4gIFx0XHRyOiByZWZzLFxuICBcdFx0czogc3RyaW5naWZ5KGV4cHJlc3Npb24pXG4gIFx0fTtcblxuICBcdGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlKSB7XG4gIFx0XHRzd2l0Y2ggKG5vZGUudCkge1xuICBcdFx0XHRjYXNlIEJPT0xFQU5fTElURVJBTDpcbiAgXHRcdFx0Y2FzZSBHTE9CQUw6XG4gIFx0XHRcdGNhc2UgTlVNQkVSX0xJVEVSQUw6XG4gIFx0XHRcdGNhc2UgUkVHRVhQX0xJVEVSQUw6XG4gIFx0XHRcdFx0cmV0dXJuIG5vZGUudjtcblxuICBcdFx0XHRjYXNlIFNUUklOR19MSVRFUkFMOlxuICBcdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShTdHJpbmcobm9kZS52KSk7XG5cbiAgXHRcdFx0Y2FzZSBBUlJBWV9MSVRFUkFMOlxuICBcdFx0XHRcdHJldHVybiBcIltcIiArIChub2RlLm0gPyBub2RlLm0ubWFwKHN0cmluZ2lmeSkuam9pbihcIixcIikgOiBcIlwiKSArIFwiXVwiO1xuXG4gIFx0XHRcdGNhc2UgT0JKRUNUX0xJVEVSQUw6XG4gIFx0XHRcdFx0cmV0dXJuIFwie1wiICsgKG5vZGUubSA/IG5vZGUubS5tYXAoc3RyaW5naWZ5KS5qb2luKFwiLFwiKSA6IFwiXCIpICsgXCJ9XCI7XG5cbiAgXHRcdFx0Y2FzZSBLRVlfVkFMVUVfUEFJUjpcbiAgXHRcdFx0XHRyZXR1cm4gbm9kZS5rICsgXCI6XCIgKyBzdHJpbmdpZnkobm9kZS52KTtcblxuICBcdFx0XHRjYXNlIFBSRUZJWF9PUEVSQVRPUjpcbiAgXHRcdFx0XHRyZXR1cm4gKG5vZGUucyA9PT0gXCJ0eXBlb2ZcIiA/IFwidHlwZW9mIFwiIDogbm9kZS5zKSArIHN0cmluZ2lmeShub2RlLm8pO1xuXG4gIFx0XHRcdGNhc2UgSU5GSVhfT1BFUkFUT1I6XG4gIFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeShub2RlLm9bMF0pICsgKG5vZGUucy5zdWJzdHIoMCwgMikgPT09IFwiaW5cIiA/IFwiIFwiICsgbm9kZS5zICsgXCIgXCIgOiBub2RlLnMpICsgc3RyaW5naWZ5KG5vZGUub1sxXSk7XG5cbiAgXHRcdFx0Y2FzZSBJTlZPQ0FUSU9OOlxuICBcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkobm9kZS54KSArIFwiKFwiICsgKG5vZGUubyA/IG5vZGUuby5tYXAoc3RyaW5naWZ5KS5qb2luKFwiLFwiKSA6IFwiXCIpICsgXCIpXCI7XG5cbiAgXHRcdFx0Y2FzZSBCUkFDS0VURUQ6XG4gIFx0XHRcdFx0cmV0dXJuIFwiKFwiICsgc3RyaW5naWZ5KG5vZGUueCkgKyBcIilcIjtcblxuICBcdFx0XHRjYXNlIE1FTUJFUjpcbiAgXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KG5vZGUueCkgKyBzdHJpbmdpZnkobm9kZS5yKTtcblxuICBcdFx0XHRjYXNlIFJFRklORU1FTlQ6XG4gIFx0XHRcdFx0cmV0dXJuIG5vZGUubiA/IFwiLlwiICsgbm9kZS5uIDogXCJbXCIgKyBzdHJpbmdpZnkobm9kZS54KSArIFwiXVwiO1xuXG4gIFx0XHRcdGNhc2UgQ09ORElUSU9OQUw6XG4gIFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeShub2RlLm9bMF0pICsgXCI/XCIgKyBzdHJpbmdpZnkobm9kZS5vWzFdKSArIFwiOlwiICsgc3RyaW5naWZ5KG5vZGUub1syXSk7XG5cbiAgXHRcdFx0Y2FzZSBSRUZFUkVOQ0U6XG4gIFx0XHRcdFx0cmV0dXJuIFwiX1wiICsgcmVmcy5pbmRleE9mKG5vZGUubik7XG5cbiAgXHRcdFx0ZGVmYXVsdDpcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBsZWdhbCBKYXZhU2NyaXB0XCIpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIC8vIFRPRE8gbWF5YmUgcmVmYWN0b3IgdGhpcz9cbiAgZnVuY3Rpb24gZXh0cmFjdFJlZnMobm9kZSwgcmVmcykge1xuICBcdHZhciBpLCBsaXN0O1xuXG4gIFx0aWYgKG5vZGUudCA9PT0gUkVGRVJFTkNFKSB7XG4gIFx0XHRpZiAocmVmcy5pbmRleE9mKG5vZGUubikgPT09IC0xKSB7XG4gIFx0XHRcdHJlZnMudW5zaGlmdChub2RlLm4pO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGxpc3QgPSBub2RlLm8gfHwgbm9kZS5tO1xuICBcdGlmIChsaXN0KSB7XG4gIFx0XHRpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgXHRcdFx0ZXh0cmFjdFJlZnMobGlzdCwgcmVmcyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpID0gbGlzdC5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRleHRyYWN0UmVmcyhsaXN0W2ldLCByZWZzKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChub2RlLngpIHtcbiAgXHRcdGV4dHJhY3RSZWZzKG5vZGUueCwgcmVmcyk7XG4gIFx0fVxuXG4gIFx0aWYgKG5vZGUucikge1xuICBcdFx0ZXh0cmFjdFJlZnMobm9kZS5yLCByZWZzKTtcbiAgXHR9XG5cbiAgXHRpZiAobm9kZS52KSB7XG4gIFx0XHRleHRyYWN0UmVmcyhub2RlLnYsIHJlZnMpO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1dGlsc19yZWZpbmVFeHByZXNzaW9uID0gcmVmaW5lRXhwcmVzc2lvbjtcblxuICB2YXIgYXJyYXlNZW1iZXJQYXR0ZXJuID0gL15bMC05XVsxLTldKiQvO1xuICBmdW5jdGlvbiByZWZpbmVFeHByZXNzaW9uKGV4cHJlc3Npb24sIG11c3RhY2hlKSB7XG4gIFx0dmFyIHJlZmVyZW5jZUV4cHJlc3Npb247XG5cbiAgXHRpZiAoZXhwcmVzc2lvbikge1xuICBcdFx0d2hpbGUgKGV4cHJlc3Npb24udCA9PT0gQlJBQ0tFVEVEICYmIGV4cHJlc3Npb24ueCkge1xuICBcdFx0XHRleHByZXNzaW9uID0gZXhwcmVzc2lvbi54O1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBpbnRlZ2VycyBzaG91bGQgYmUgdHJlYXRlZCBhcyBhcnJheSBtZW1iZXJzIHJlZmVyZW5jZXMsXG4gIFx0XHQvLyByYXRoZXIgdGhhbiBhcyBleHByZXNzaW9ucyBpbiB0aGVpciBvd24gcmlnaHRcbiAgXHRcdGlmIChleHByZXNzaW9uLnQgPT09IFJFRkVSRU5DRSkge1xuICBcdFx0XHRtdXN0YWNoZS5yID0gZXhwcmVzc2lvbi5uO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0aWYgKGV4cHJlc3Npb24udCA9PT0gTlVNQkVSX0xJVEVSQUwgJiYgYXJyYXlNZW1iZXJQYXR0ZXJuLnRlc3QoZXhwcmVzc2lvbi52KSkge1xuICBcdFx0XHRcdG11c3RhY2hlLnIgPSBleHByZXNzaW9uLnY7XG4gIFx0XHRcdH0gZWxzZSBpZiAocmVmZXJlbmNlRXhwcmVzc2lvbiA9IGdldFJlZmVyZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbikpIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS5yeCA9IHJlZmVyZW5jZUV4cHJlc3Npb247XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0bXVzdGFjaGUueCA9IHV0aWxzX2ZsYXR0ZW5FeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBtdXN0YWNoZTtcbiAgXHR9XG4gIH1cblxuICAvLyBUT0RPIHJlZmFjdG9yIHRoaXMhIGl0J3MgYmV3aWxkZXJpbmdcbiAgZnVuY3Rpb24gZ2V0UmVmZXJlbmNlRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gIFx0dmFyIG1lbWJlcnMgPSBbXSxcbiAgXHQgICAgcmVmaW5lbWVudDtcblxuICBcdHdoaWxlIChleHByZXNzaW9uLnQgPT09IE1FTUJFUiAmJiBleHByZXNzaW9uLnIudCA9PT0gUkVGSU5FTUVOVCkge1xuICBcdFx0cmVmaW5lbWVudCA9IGV4cHJlc3Npb24ucjtcblxuICBcdFx0aWYgKHJlZmluZW1lbnQueCkge1xuICBcdFx0XHRpZiAocmVmaW5lbWVudC54LnQgPT09IFJFRkVSRU5DRSkge1xuICBcdFx0XHRcdG1lbWJlcnMudW5zaGlmdChyZWZpbmVtZW50LngpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdG1lbWJlcnMudW5zaGlmdCh1dGlsc19mbGF0dGVuRXhwcmVzc2lvbihyZWZpbmVtZW50LngpKTtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bWVtYmVycy51bnNoaWZ0KHJlZmluZW1lbnQubik7XG4gIFx0XHR9XG5cbiAgXHRcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uLng7XG4gIFx0fVxuXG4gIFx0aWYgKGV4cHJlc3Npb24udCAhPT0gUkVGRVJFTkNFKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0cjogZXhwcmVzc2lvbi5uLFxuICBcdFx0bTogbWVtYmVyc1xuICBcdH07XG4gIH1cblxuICB2YXIgbXVzdGFjaGVfcmVhZFRyaXBsZSA9IHJlYWRUcmlwbGU7XG4gIGZ1bmN0aW9uIHJlYWRUcmlwbGUocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKSxcbiAgXHQgICAgdHJpcGxlO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0dHJpcGxlID0geyB0OiBUUklQTEUgfTtcbiAgXHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHRyaXBsZSk7IC8vIFRPRE8gaGFuZGxlIHRoaXMgZGlmZmVyZW50bHkgLSBpdCdzIG15c3RlcmlvdXNcblxuICBcdHJldHVybiB0cmlwbGU7XG4gIH1cblxuICB2YXIgbXVzdGFjaGVfcmVhZFVuZXNjYXBlZCA9IHJlYWRVbmVzY2FwZWQ7XG4gIGZ1bmN0aW9uIHJlYWRVbmVzY2FwZWQocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgZXhwcmVzc2lvbiwgdHJpcGxlO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCImXCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0dHJpcGxlID0geyB0OiBUUklQTEUgfTtcbiAgXHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHRyaXBsZSk7IC8vIFRPRE8gaGFuZGxlIHRoaXMgZGlmZmVyZW50bHkgLSBpdCdzIG15c3RlcmlvdXNcblxuICBcdHJldHVybiB0cmlwbGU7XG4gIH1cblxuICB2YXIgbXVzdGFjaGVfcmVhZFBhcnRpYWwgPSByZWFkUGFydGlhbDtcbiAgZnVuY3Rpb24gcmVhZFBhcnRpYWwocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIG5hbWVTdGFydCwgZXhwcmVzc2lvbiwgY29udGV4dCwgcGFydGlhbDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPlwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdG5hbWVTdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBQYXJ0aWFsIG5hbWVzIGNhbiBpbmNsdWRlIGh5cGhlbnMsIHNvIHdlIGNhbid0IHVzZSByZWFkRXhwcmVzc2lvblxuICBcdC8vIGJsaW5kbHkuIEluc3RlYWQsIHdlIHVzZSB0aGUgYHJlbGF4ZWROYW1lc2AgZmxhZyB0byBpbmRpY2F0ZSB0aGF0XG4gIFx0Ly8gYGZvby1iYXJgIHNob3VsZCBiZSByZWFkIGFzIGEgc2luZ2xlIG5hbWUsIHJhdGhlciB0aGFuICdzdWJ0cmFjdFxuICBcdC8vIGJhciBmcm9tIGZvbydcbiAgXHRwYXJzZXIucmVsYXhlZE5hbWVzID0gdHJ1ZTtcbiAgXHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdHBhcnNlci5yZWxheGVkTmFtZXMgPSBmYWxzZTtcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHRjb250ZXh0ID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFydGlhbCA9IHsgdDogUEFSVElBTCB9O1xuICBcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgcGFydGlhbCk7IC8vIFRPRE8uLi5cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIGlmIHdlIGhhdmUgYW5vdGhlciBleHByZXNzaW9uIC0gZS5nLiBge3s+Zm9vIGJhcn19YCAtIHRoZW5cbiAgXHQvLyB3ZSB0dXJuIGl0IGludG8gYHt7I3dpdGggYmFyfX17ez5mb299fXt7L3dpdGh9fWBcbiAgXHRpZiAoY29udGV4dCkge1xuICBcdFx0cGFydGlhbCA9IHtcbiAgXHRcdFx0dDogU0VDVElPTixcbiAgXHRcdFx0bjogU0VDVElPTl9XSVRILFxuICBcdFx0XHRmOiBbcGFydGlhbF1cbiAgXHRcdH07XG5cbiAgXHRcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oY29udGV4dCwgcGFydGlhbCk7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInXCIpO1xuICBcdH1cblxuICBcdHJldHVybiBwYXJ0aWFsO1xuICB9XG5cbiAgdmFyIHJlYWRNdXN0YWNoZUNvbW1lbnQgPSByZWFkQ29tbWVudDtcbiAgZnVuY3Rpb24gcmVhZENvbW1lbnQocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgaW5kZXg7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIiFcIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGluZGV4ID0gcGFyc2VyLnJlbWFpbmluZygpLmluZGV4T2YodGFnLmNsb3NlKTtcblxuICBcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdHBhcnNlci5wb3MgKz0gaW5kZXggKyB0YWcuY2xvc2UubGVuZ3RoO1xuICBcdFx0cmV0dXJuIHsgdDogQ09NTUVOVCB9O1xuICBcdH1cbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uT3JSZWZlcmVuY2UgPSByZWFkRXhwcmVzc2lvbk9yUmVmZXJlbmNlO1xuICBmdW5jdGlvbiByZWFkRXhwcmVzc2lvbk9yUmVmZXJlbmNlKHBhcnNlciwgZXhwZWN0ZWRGb2xsb3dlcnMpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb24sIGk7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG4gIFx0ZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcblxuICBcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Zm9yIChpID0gMDsgaSA8IGV4cGVjdGVkRm9sbG93ZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRpZiAocGFyc2VyLnJlbWFpbmluZygpLnN1YnN0cigwLCBleHBlY3RlZEZvbGxvd2Vyc1tpXS5sZW5ndGgpID09PSBleHBlY3RlZEZvbGxvd2Vyc1tpXSkge1xuICBcdFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0cmV0dXJuIHByaW1hcnlfcmVhZFJlZmVyZW5jZShwYXJzZXIpO1xuICB9XG5cbiAgdmFyIG11c3RhY2hlX3JlYWRJbnRlcnBvbGF0b3IgPSByZWFkSW50ZXJwb2xhdG9yO1xuICBmdW5jdGlvbiByZWFkSW50ZXJwb2xhdG9yKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uLCBpbnRlcnBvbGF0b3IsIGVycjtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIFRPRE8gd291bGQgYmUgZ29vZCBmb3IgcGVyZiBpZiB3ZSBjb3VsZCBkbyBhd2F5IHdpdGggdGhlIHRyeS1jYXRjaFxuICBcdHRyeSB7XG4gIFx0XHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbk9yUmVmZXJlbmNlKHBhcnNlciwgW3RhZy5jbG9zZV0pO1xuICBcdH0gY2F0Y2ggKGUpIHtcbiAgXHRcdGVyciA9IGU7XG4gIFx0fVxuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRpZiAocGFyc2VyLnN0ci5jaGFyQXQoc3RhcnQpID09PSBcIiFcIikge1xuICBcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBjb21tZW50XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChlcnIpIHtcbiAgXHRcdFx0dGhyb3cgZXJyO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJyBhZnRlciByZWZlcmVuY2VcIik7XG5cbiAgXHRcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBjb21tZW50XG4gIFx0XHRcdGlmIChwYXJzZXIubmV4dENoYXIoKSA9PT0gXCIhXCIpIHtcbiAgXHRcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGV4cHJlc3Npb24gb3IgbGVnYWwgcmVmZXJlbmNlXCIpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGludGVycG9sYXRvciA9IHsgdDogSU5URVJQT0xBVE9SIH07XG4gIFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCBpbnRlcnBvbGF0b3IpOyAvLyBUT0RPIGhhbmRsZSB0aGlzIGRpZmZlcmVudGx5IC0gaXQncyBteXN0ZXJpb3VzXG5cbiAgXHRyZXR1cm4gaW50ZXJwb2xhdG9yO1xuICB9XG5cbiAgdmFyIG11c3RhY2hlX3JlYWRZaWVsZGVyID0gcmVhZFlpZWxkZXI7XG4gIHZhciB5aWVsZFBhdHRlcm4gPSAvXnlpZWxkXFxzKi87XG4gIGZ1bmN0aW9uIHJlYWRZaWVsZGVyKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIHN0YXJ0LCBuYW1lLCB5aWVsZGVyO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHlpZWxkUGF0dGVybikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybigvXlthLXpBLVpfJF1bYS16QS1aXyQwLTlcXC1dKi8pO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiZXhwZWN0ZWQgbGVnYWwgcGFydGlhbCBuYW1lXCIpO1xuICBcdH1cblxuICBcdHlpZWxkZXIgPSB7IHQ6IFlJRUxERVIgfTtcblxuICBcdGlmIChuYW1lKSB7XG4gIFx0XHR5aWVsZGVyLm4gPSBuYW1lO1xuICBcdH1cblxuICBcdHJldHVybiB5aWVsZGVyO1xuICB9XG5cbiAgdmFyIHNlY3Rpb25fcmVhZENsb3NpbmcgPSByZWFkQ2xvc2luZztcbiAgZnVuY3Rpb24gcmVhZENsb3NpbmcocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIHJlbWFpbmluZywgaW5kZXgsIGNsb3Npbmc7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcub3BlbikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiL1wiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuICBcdGluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YodGFnLmNsb3NlKTtcblxuICBcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdGNsb3NpbmcgPSB7XG4gIFx0XHRcdHQ6IENMT1NJTkcsXG4gIFx0XHRcdHI6IHJlbWFpbmluZy5zdWJzdHIoMCwgaW5kZXgpLnNwbGl0KFwiIFwiKVswXVxuICBcdFx0fTtcblxuICBcdFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBjbG9zaW5nO1xuICBcdH1cblxuICBcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzZWN0aW9uX3JlYWRFbHNlID0gc2VjdGlvbl9yZWFkRWxzZV9fcmVhZEVsc2U7XG4gIHZhciBzZWN0aW9uX3JlYWRFbHNlX19lbHNlUGF0dGVybiA9IC9eXFxzKmVsc2VcXHMqLztcbiAgZnVuY3Rpb24gc2VjdGlvbl9yZWFkRWxzZV9fcmVhZEVsc2UocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLm9wZW4pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4oc2VjdGlvbl9yZWFkRWxzZV9fZWxzZVBhdHRlcm4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IEVMU0VcbiAgXHR9O1xuICB9XG5cbiAgdmFyIHJlYWRFbHNlSWYgPSByZWFkRWxzZUlmX19yZWFkRWxzZTtcbiAgdmFyIHJlYWRFbHNlSWZfX2Vsc2VQYXR0ZXJuID0gL15cXHMqZWxzZWlmXFxzKy87XG4gIGZ1bmN0aW9uIHJlYWRFbHNlSWZfX3JlYWRFbHNlKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIHN0YXJ0ID0gcGFyc2VyLnBvcyxcbiAgXHQgICAgZXhwcmVzc2lvbjtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5vcGVuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHJlYWRFbHNlSWZfX2Vsc2VQYXR0ZXJuKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0ZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogRUxTRUlGLFxuICBcdFx0eDogZXhwcmVzc2lvblxuICBcdH07XG4gIH1cblxuICB2YXIgaGFuZGxlYmFyc0Jsb2NrQ29kZXMgPSB7XG4gIFx0ZWFjaDogU0VDVElPTl9FQUNILFxuICBcdFwiaWZcIjogU0VDVElPTl9JRixcbiAgXHRcImlmLXdpdGhcIjogU0VDVElPTl9JRl9XSVRILFxuICBcdFwid2l0aFwiOiBTRUNUSU9OX1dJVEgsXG4gIFx0dW5sZXNzOiBTRUNUSU9OX1VOTEVTU1xuICB9O1xuXG4gIHZhciBtdXN0YWNoZV9yZWFkU2VjdGlvbiA9IHJlYWRTZWN0aW9uO1xuXG4gIHZhciBpbmRleFJlZlBhdHRlcm4gPSAvXlxccyo6XFxzKihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopLyxcbiAgICAgIGtleUluZGV4UmVmUGF0dGVybiA9IC9eXFxzKixcXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKikvLFxuICAgICAgaGFuZGxlYmFyc0Jsb2NrUGF0dGVybiA9IG5ldyBSZWdFeHAoXCJeKFwiICsgT2JqZWN0LmtleXMoaGFuZGxlYmFyc0Jsb2NrQ29kZXMpLmpvaW4oXCJ8XCIpICsgXCIpXFxcXGJcIik7XG4gIGZ1bmN0aW9uIHJlYWRTZWN0aW9uKHBhcnNlciwgdGFnKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uLCBzZWN0aW9uLCBjaGlsZCwgY2hpbGRyZW4sIGhhc0Vsc2UsIGJsb2NrLCB1bmxlc3NCbG9jaywgY29uZGl0aW9ucywgY2xvc2VkLCBpLCBleHBlY3RlZENsb3NlO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIl5cIikpIHtcbiAgXHRcdHNlY3Rpb24gPSB7IHQ6IFNFQ1RJT04sIGY6IFtdLCBuOiBTRUNUSU9OX1VOTEVTUyB9O1xuICBcdH0gZWxzZSBpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiI1wiKSkge1xuICBcdFx0c2VjdGlvbiA9IHsgdDogU0VDVElPTiwgZjogW10gfTtcblxuICBcdFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcInBhcnRpYWxcIikpIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0IC0gcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1swXS5sZW5ndGg7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIlBhcnRpYWwgZGVmaW5pdGlvbnMgY2FuIG9ubHkgYmUgYXQgdGhlIHRvcCBsZXZlbCBvZiB0aGUgdGVtcGxhdGUsIG9yIGltbWVkaWF0ZWx5IGluc2lkZSBjb21wb25lbnRzXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoYmxvY2sgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGhhbmRsZWJhcnNCbG9ja1BhdHRlcm4pKSB7XG4gIFx0XHRcdGV4cGVjdGVkQ2xvc2UgPSBibG9jaztcbiAgXHRcdFx0c2VjdGlvbi5uID0gaGFuZGxlYmFyc0Jsb2NrQ29kZXNbYmxvY2tdO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBleHByZXNzaW9uXCIpO1xuICBcdH1cblxuICBcdC8vIG9wdGlvbmFsIGluZGV4IGFuZCBrZXkgcmVmZXJlbmNlc1xuICBcdGlmIChpID0gcGFyc2VyLm1hdGNoUGF0dGVybihpbmRleFJlZlBhdHRlcm4pKSB7XG4gIFx0XHR2YXIgZXh0cmEgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdGlmIChleHRyYSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oa2V5SW5kZXhSZWZQYXR0ZXJuKSkge1xuICBcdFx0XHRzZWN0aW9uLmkgPSBpICsgXCIsXCIgKyBleHRyYTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHNlY3Rpb24uaSA9IGk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInXCIpO1xuICBcdH1cblxuICBcdHBhcnNlci5zZWN0aW9uRGVwdGggKz0gMTtcbiAgXHRjaGlsZHJlbiA9IHNlY3Rpb24uZjtcblxuICBcdGNvbmRpdGlvbnMgPSBbXTtcblxuICBcdGRvIHtcbiAgXHRcdGlmIChjaGlsZCA9IHNlY3Rpb25fcmVhZENsb3NpbmcocGFyc2VyLCB0YWcpKSB7XG4gIFx0XHRcdGlmIChleHBlY3RlZENsb3NlICYmIGNoaWxkLnIgIT09IGV4cGVjdGVkQ2xvc2UpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBcIiArIHRhZy5vcGVuICsgXCIvXCIgKyBleHBlY3RlZENsb3NlICsgXCJcIiArIHRhZy5jbG9zZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwYXJzZXIuc2VjdGlvbkRlcHRoIC09IDE7XG4gIFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHR9IGVsc2UgaWYgKGNoaWxkID0gcmVhZEVsc2VJZihwYXJzZXIsIHRhZykpIHtcbiAgXHRcdFx0aWYgKHNlY3Rpb24ubiA9PT0gU0VDVElPTl9VTkxFU1MpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJ7e2Vsc2V9fSBub3QgYWxsb3dlZCBpbiB7eyN1bmxlc3N9fVwiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChoYXNFbHNlKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiaWxsZWdhbCB7e2Vsc2VpZi4uLn19IGFmdGVyIHt7ZWxzZX19XCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCF1bmxlc3NCbG9jaykge1xuICBcdFx0XHRcdHVubGVzc0Jsb2NrID0gY3JlYXRlVW5sZXNzQmxvY2soZXhwcmVzc2lvbiwgc2VjdGlvbi5uKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHVubGVzc0Jsb2NrLmYucHVzaCh7XG4gIFx0XHRcdFx0dDogU0VDVElPTixcbiAgXHRcdFx0XHRuOiBTRUNUSU9OX0lGLFxuICBcdFx0XHRcdHg6IHV0aWxzX2ZsYXR0ZW5FeHByZXNzaW9uKG11c3RhY2hlX3JlYWRTZWN0aW9uX19jb21iaW5lKGNvbmRpdGlvbnMuY29uY2F0KGNoaWxkLngpKSksXG4gIFx0XHRcdFx0ZjogY2hpbGRyZW4gPSBbXVxuICBcdFx0XHR9KTtcblxuICBcdFx0XHRjb25kaXRpb25zLnB1c2goaW52ZXJ0KGNoaWxkLngpKTtcbiAgXHRcdH0gZWxzZSBpZiAoY2hpbGQgPSBzZWN0aW9uX3JlYWRFbHNlKHBhcnNlciwgdGFnKSkge1xuICBcdFx0XHRpZiAoc2VjdGlvbi5uID09PSBTRUNUSU9OX1VOTEVTUykge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcInt7ZWxzZX19IG5vdCBhbGxvd2VkIGluIHt7I3VubGVzc319XCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGhhc0Vsc2UpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJ0aGVyZSBjYW4gb25seSBiZSBvbmUge3tlbHNlfX0gYmxvY2ssIGF0IHRoZSBlbmQgb2YgYSBzZWN0aW9uXCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aGFzRWxzZSA9IHRydWU7XG5cbiAgXHRcdFx0Ly8gdXNlIGFuIHVubGVzcyBibG9jayBpZiB0aGVyZSdzIG5vIGVsc2VpZlxuICBcdFx0XHRpZiAoIXVubGVzc0Jsb2NrKSB7XG4gIFx0XHRcdFx0dW5sZXNzQmxvY2sgPSBjcmVhdGVVbmxlc3NCbG9jayhleHByZXNzaW9uLCBzZWN0aW9uLm4pO1xuICBcdFx0XHRcdGNoaWxkcmVuID0gdW5sZXNzQmxvY2suZjtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR1bmxlc3NCbG9jay5mLnB1c2goe1xuICBcdFx0XHRcdFx0dDogU0VDVElPTixcbiAgXHRcdFx0XHRcdG46IFNFQ1RJT05fSUYsXG4gIFx0XHRcdFx0XHR4OiB1dGlsc19mbGF0dGVuRXhwcmVzc2lvbihtdXN0YWNoZV9yZWFkU2VjdGlvbl9fY29tYmluZShjb25kaXRpb25zKSksXG4gIFx0XHRcdFx0XHRmOiBjaGlsZHJlbiA9IFtdXG4gIFx0XHRcdFx0fSk7XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNoaWxkID0gcGFyc2VyLnJlYWQoUkVBREVSUyk7XG5cbiAgXHRcdFx0aWYgKCFjaGlsZCkge1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoIWNsb3NlZCk7XG5cbiAgXHRpZiAodW5sZXNzQmxvY2spIHtcbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGB3aXRoYCBzaG91bGQgYmVjb21lIGBpZi13aXRoYCAoVE9ETyBpcyB0aGlzIHJpZ2h0P1xuICBcdFx0Ly8gc2VlbXMgdG8gbWUgdGhhdCBgd2l0aGAgb3VnaHQgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSwgcmVnYXJkbGVzc1xuICBcdFx0Ly8gb2YgdGhlIHByZXNlbmNlL2Fic2VuY2Ugb2YgYGVsc2VgLiBJbiBvdGhlciB3b3JkcyBzaG91bGQgYWx3YXlzXG4gIFx0XHQvLyBiZSBgaWYtd2l0aGBcbiAgXHRcdGlmIChzZWN0aW9uLm4gPT09IFNFQ1RJT05fV0lUSCkge1xuICBcdFx0XHRzZWN0aW9uLm4gPSBTRUNUSU9OX0lGX1dJVEg7XG4gIFx0XHR9XG5cbiAgXHRcdHNlY3Rpb24ubCA9IHVubGVzc0Jsb2NrO1xuICBcdH1cblxuICBcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgc2VjdGlvbik7XG5cbiAgXHQvLyBUT0RPIGlmIGEgc2VjdGlvbiBpcyBlbXB0eSBpdCBzaG91bGQgYmUgZGlzY2FyZGVkLiBEb24ndCBkb1xuICBcdC8vIHRoYXQgaGVyZSB0aG91Z2ggLSB3ZSBuZWVkIHRvIGNsZWFuIGV2ZXJ5dGhpbmcgdXAgZmlyc3QsIGFzXG4gIFx0Ly8gaXQgbWF5IGNvbnRhaW4gcmVtb3ZlYWJsZSB3aGl0ZXNwYWNlLiBBcyBhIHRlbXBvcmFyeSBtZWFzdXJlLFxuICBcdC8vIHRvIHBhc3MgdGhlIGV4aXN0aW5nIHRlc3RzLCByZW1vdmUgZW1wdHkgYGZgIGFycmF5c1xuICBcdGlmICghc2VjdGlvbi5mLmxlbmd0aCkge1xuICBcdFx0ZGVsZXRlIHNlY3Rpb24uZjtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc2VjdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVubGVzc0Jsb2NrKGV4cHJlc3Npb24sIHNlY3Rpb25UeXBlKSB7XG4gIFx0dmFyIHVubGVzc0Jsb2NrO1xuXG4gIFx0aWYgKHNlY3Rpb25UeXBlID09PSBTRUNUSU9OX1dJVEgpIHtcbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGEgYHt7I3dpdGggZm9vfX1gIHNlY3Rpb24gd2lsbCByZW5kZXIgaWYgYGZvb2AgaXNcbiAgXHRcdC8vIHRydXRoeSwgc28gdGhlIGB7e2Vsc2V9fWAgc2VjdGlvbiBuZWVkcyB0byByZW5kZXIgaWYgYGZvb2AgaXMgZmFsc3ksXG4gIFx0XHQvLyByYXRoZXIgdGhhbiBhZGhlcmluZyB0byB0aGUgbm9ybWFsIGB7eyN1bmxlc3MgZm9vfX1gIGxvZ2ljICh3aGljaFxuICBcdFx0Ly8gdHJlYXRzIGVtcHR5IGFycmF5cy9vYmplY3RzIGFzIGZhbHN5KVxuICBcdFx0dW5sZXNzQmxvY2sgPSB7XG4gIFx0XHRcdHQ6IFNFQ1RJT04sXG4gIFx0XHRcdG46IFNFQ1RJT05fSUYsXG4gIFx0XHRcdGY6IFtdXG4gIFx0XHR9O1xuXG4gIFx0XHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGludmVydChleHByZXNzaW9uKSwgdW5sZXNzQmxvY2spO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR1bmxlc3NCbG9jayA9IHtcbiAgXHRcdFx0dDogU0VDVElPTixcbiAgXHRcdFx0bjogU0VDVElPTl9VTkxFU1MsXG4gIFx0XHRcdGY6IFtdXG4gIFx0XHR9O1xuXG4gIFx0XHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHVubGVzc0Jsb2NrKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdW5sZXNzQmxvY2s7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZlcnQoZXhwcmVzc2lvbikge1xuICBcdGlmIChleHByZXNzaW9uLnQgPT09IFBSRUZJWF9PUEVSQVRPUiAmJiBleHByZXNzaW9uLnMgPT09IFwiIVwiKSB7XG4gIFx0XHRyZXR1cm4gZXhwcmVzc2lvbi5vO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBQUkVGSVhfT1BFUkFUT1IsXG4gIFx0XHRzOiBcIiFcIixcbiAgXHRcdG86IHBhcmVuc0lmTmVjZXNzYXJ5KGV4cHJlc3Npb24pXG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG11c3RhY2hlX3JlYWRTZWN0aW9uX19jb21iaW5lKGV4cHJlc3Npb25zKSB7XG4gIFx0aWYgKGV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMSkge1xuICBcdFx0cmV0dXJuIGV4cHJlc3Npb25zWzBdO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBJTkZJWF9PUEVSQVRPUixcbiAgXHRcdHM6IFwiJiZcIixcbiAgXHRcdG86IFtwYXJlbnNJZk5lY2Vzc2FyeShleHByZXNzaW9uc1swXSksIHBhcmVuc0lmTmVjZXNzYXJ5KG11c3RhY2hlX3JlYWRTZWN0aW9uX19jb21iaW5lKGV4cHJlc3Npb25zLnNsaWNlKDEpKSldXG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcmVuc0lmTmVjZXNzYXJ5KGV4cHJlc3Npb24pIHtcbiAgXHQvLyBUT0RPIG9ubHkgd3JhcCBpZiBuZWNlc3NhcnlcbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogQlJBQ0tFVEVELFxuICBcdFx0eDogZXhwcmVzc2lvblxuICBcdH07XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkSHRtbENvbW1lbnQgPSByZWFkSHRtbENvbW1lbnQ7XG4gIHZhciBPUEVOX0NPTU1FTlQgPSBcIjwhLS1cIixcbiAgICAgIENMT1NFX0NPTU1FTlQgPSBcIi0tPlwiO1xuICBmdW5jdGlvbiByZWFkSHRtbENvbW1lbnQocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBjb250ZW50LCByZW1haW5pbmcsIGVuZEluZGV4LCBjb21tZW50O1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoT1BFTl9DT01NRU5UKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuICBcdGVuZEluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YoQ0xPU0VfQ09NTUVOVCk7XG5cbiAgXHRpZiAoZW5kSW5kZXggPT09IC0xKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJJbGxlZ2FsIEhUTUwgLSBleHBlY3RlZCBjbG9zaW5nIGNvbW1lbnQgc2VxdWVuY2UgKCctLT4nKVwiKTtcbiAgXHR9XG5cbiAgXHRjb250ZW50ID0gcmVtYWluaW5nLnN1YnN0cigwLCBlbmRJbmRleCk7XG4gIFx0cGFyc2VyLnBvcyArPSBlbmRJbmRleCArIDM7XG5cbiAgXHRjb21tZW50ID0ge1xuICBcdFx0dDogQ09NTUVOVCxcbiAgXHRcdGM6IGNvbnRlbnRcbiAgXHR9O1xuXG4gIFx0aWYgKHBhcnNlci5pbmNsdWRlTGluZVBvc2l0aW9ucykge1xuICBcdFx0Y29tbWVudC5wID0gcGFyc2VyLmdldExpbmVQb3Moc3RhcnQpO1xuICBcdH1cblxuICBcdHJldHVybiBjb21tZW50O1xuICB9XG5cbiAgdmFyIGJvb2xlYW5BdHRyaWJ1dGVzLCB2b2lkRWxlbWVudE5hbWVzLCBodG1sRW50aXRpZXMsIGNvbnRyb2xDaGFyYWN0ZXJzLCBlbnRpdHlQYXR0ZXJuLCBsZXNzVGhhbiwgZ3JlYXRlclRoYW4sIGFtcDtcblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2h0bWwtbWluaWZpZXIvaXNzdWVzLzYzI2lzc3VlY29tbWVudC0zNzc2MzMxNlxuICBib29sZWFuQXR0cmlidXRlcyA9IC9eKGFsbG93RnVsbHNjcmVlbnxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y2hlY2tlZHxjb21wYWN0fGNvbnRyb2xzfGRlY2xhcmV8ZGVmYXVsdHxkZWZhdWx0Q2hlY2tlZHxkZWZhdWx0TXV0ZWR8ZGVmYXVsdFNlbGVjdGVkfGRlZmVyfGRpc2FibGVkfGVuYWJsZWR8Zm9ybU5vVmFsaWRhdGV8aGlkZGVufGluZGV0ZXJtaW5hdGV8aW5lcnR8aXNNYXB8aXRlbVNjb3BlfGxvb3B8bXVsdGlwbGV8bXV0ZWR8bm9IcmVmfG5vUmVzaXplfG5vU2hhZGV8bm9WYWxpZGF0ZXxub1dyYXB8b3BlbnxwYXVzZU9uRXhpdHxyZWFkT25seXxyZXF1aXJlZHxyZXZlcnNlZHxzY29wZWR8c2VhbWxlc3N8c2VsZWN0ZWR8c29ydGFibGV8dHJhbnNsYXRlfHRydWVTcGVlZHx0eXBlTXVzdE1hdGNofHZpc2libGUpJC9pO1xuICB2b2lkRWxlbWVudE5hbWVzID0gL14oPzphcmVhfGJhc2V8YnJ8Y29sfGNvbW1hbmR8ZG9jdHlwZXxlbWJlZHxocnxpbWd8aW5wdXR8a2V5Z2VufGxpbmt8bWV0YXxwYXJhbXxzb3VyY2V8dHJhY2t8d2JyKSQvaTtcblxuICBodG1sRW50aXRpZXMgPSB7IHF1b3Q6IDM0LCBhbXA6IDM4LCBhcG9zOiAzOSwgbHQ6IDYwLCBndDogNjIsIG5ic3A6IDE2MCwgaWV4Y2w6IDE2MSwgY2VudDogMTYyLCBwb3VuZDogMTYzLCBjdXJyZW46IDE2NCwgeWVuOiAxNjUsIGJydmJhcjogMTY2LCBzZWN0OiAxNjcsIHVtbDogMTY4LCBjb3B5OiAxNjksIG9yZGY6IDE3MCwgbGFxdW86IDE3MSwgbm90OiAxNzIsIHNoeTogMTczLCByZWc6IDE3NCwgbWFjcjogMTc1LCBkZWc6IDE3NiwgcGx1c21uOiAxNzcsIHN1cDI6IDE3OCwgc3VwMzogMTc5LCBhY3V0ZTogMTgwLCBtaWNybzogMTgxLCBwYXJhOiAxODIsIG1pZGRvdDogMTgzLCBjZWRpbDogMTg0LCBzdXAxOiAxODUsIG9yZG06IDE4NiwgcmFxdW86IDE4NywgZnJhYzE0OiAxODgsIGZyYWMxMjogMTg5LCBmcmFjMzQ6IDE5MCwgaXF1ZXN0OiAxOTEsIEFncmF2ZTogMTkyLCBBYWN1dGU6IDE5MywgQWNpcmM6IDE5NCwgQXRpbGRlOiAxOTUsIEF1bWw6IDE5NiwgQXJpbmc6IDE5NywgQUVsaWc6IDE5OCwgQ2NlZGlsOiAxOTksIEVncmF2ZTogMjAwLCBFYWN1dGU6IDIwMSwgRWNpcmM6IDIwMiwgRXVtbDogMjAzLCBJZ3JhdmU6IDIwNCwgSWFjdXRlOiAyMDUsIEljaXJjOiAyMDYsIEl1bWw6IDIwNywgRVRIOiAyMDgsIE50aWxkZTogMjA5LCBPZ3JhdmU6IDIxMCwgT2FjdXRlOiAyMTEsIE9jaXJjOiAyMTIsIE90aWxkZTogMjEzLCBPdW1sOiAyMTQsIHRpbWVzOiAyMTUsIE9zbGFzaDogMjE2LCBVZ3JhdmU6IDIxNywgVWFjdXRlOiAyMTgsIFVjaXJjOiAyMTksIFV1bWw6IDIyMCwgWWFjdXRlOiAyMjEsIFRIT1JOOiAyMjIsIHN6bGlnOiAyMjMsIGFncmF2ZTogMjI0LCBhYWN1dGU6IDIyNSwgYWNpcmM6IDIyNiwgYXRpbGRlOiAyMjcsIGF1bWw6IDIyOCwgYXJpbmc6IDIyOSwgYWVsaWc6IDIzMCwgY2NlZGlsOiAyMzEsIGVncmF2ZTogMjMyLCBlYWN1dGU6IDIzMywgZWNpcmM6IDIzNCwgZXVtbDogMjM1LCBpZ3JhdmU6IDIzNiwgaWFjdXRlOiAyMzcsIGljaXJjOiAyMzgsIGl1bWw6IDIzOSwgZXRoOiAyNDAsIG50aWxkZTogMjQxLCBvZ3JhdmU6IDI0Miwgb2FjdXRlOiAyNDMsIG9jaXJjOiAyNDQsIG90aWxkZTogMjQ1LCBvdW1sOiAyNDYsIGRpdmlkZTogMjQ3LCBvc2xhc2g6IDI0OCwgdWdyYXZlOiAyNDksIHVhY3V0ZTogMjUwLCB1Y2lyYzogMjUxLCB1dW1sOiAyNTIsIHlhY3V0ZTogMjUzLCB0aG9ybjogMjU0LCB5dW1sOiAyNTUsIE9FbGlnOiAzMzgsIG9lbGlnOiAzMzksIFNjYXJvbjogMzUyLCBzY2Fyb246IDM1MywgWXVtbDogMzc2LCBmbm9mOiA0MDIsIGNpcmM6IDcxMCwgdGlsZGU6IDczMiwgQWxwaGE6IDkxMywgQmV0YTogOTE0LCBHYW1tYTogOTE1LCBEZWx0YTogOTE2LCBFcHNpbG9uOiA5MTcsIFpldGE6IDkxOCwgRXRhOiA5MTksIFRoZXRhOiA5MjAsIElvdGE6IDkyMSwgS2FwcGE6IDkyMiwgTGFtYmRhOiA5MjMsIE11OiA5MjQsIE51OiA5MjUsIFhpOiA5MjYsIE9taWNyb246IDkyNywgUGk6IDkyOCwgUmhvOiA5MjksIFNpZ21hOiA5MzEsIFRhdTogOTMyLCBVcHNpbG9uOiA5MzMsIFBoaTogOTM0LCBDaGk6IDkzNSwgUHNpOiA5MzYsIE9tZWdhOiA5MzcsIGFscGhhOiA5NDUsIGJldGE6IDk0NiwgZ2FtbWE6IDk0NywgZGVsdGE6IDk0OCwgZXBzaWxvbjogOTQ5LCB6ZXRhOiA5NTAsIGV0YTogOTUxLCB0aGV0YTogOTUyLCBpb3RhOiA5NTMsIGthcHBhOiA5NTQsIGxhbWJkYTogOTU1LCBtdTogOTU2LCBudTogOTU3LCB4aTogOTU4LCBvbWljcm9uOiA5NTksIHBpOiA5NjAsIHJobzogOTYxLCBzaWdtYWY6IDk2Miwgc2lnbWE6IDk2MywgdGF1OiA5NjQsIHVwc2lsb246IDk2NSwgcGhpOiA5NjYsIGNoaTogOTY3LCBwc2k6IDk2OCwgb21lZ2E6IDk2OSwgdGhldGFzeW06IDk3NywgdXBzaWg6IDk3OCwgcGl2OiA5ODIsIGVuc3A6IDgxOTQsIGVtc3A6IDgxOTUsIHRoaW5zcDogODIwMSwgenduajogODIwNCwgendqOiA4MjA1LCBscm06IDgyMDYsIHJsbTogODIwNywgbmRhc2g6IDgyMTEsIG1kYXNoOiA4MjEyLCBsc3F1bzogODIxNiwgcnNxdW86IDgyMTcsIHNicXVvOiA4MjE4LCBsZHF1bzogODIyMCwgcmRxdW86IDgyMjEsIGJkcXVvOiA4MjIyLCBkYWdnZXI6IDgyMjQsIERhZ2dlcjogODIyNSwgYnVsbDogODIyNiwgaGVsbGlwOiA4MjMwLCBwZXJtaWw6IDgyNDAsIHByaW1lOiA4MjQyLCBQcmltZTogODI0MywgbHNhcXVvOiA4MjQ5LCByc2FxdW86IDgyNTAsIG9saW5lOiA4MjU0LCBmcmFzbDogODI2MCwgZXVybzogODM2NCwgaW1hZ2U6IDg0NjUsIHdlaWVycDogODQ3MiwgcmVhbDogODQ3NiwgdHJhZGU6IDg0ODIsIGFsZWZzeW06IDg1MDEsIGxhcnI6IDg1OTIsIHVhcnI6IDg1OTMsIHJhcnI6IDg1OTQsIGRhcnI6IDg1OTUsIGhhcnI6IDg1OTYsIGNyYXJyOiA4NjI5LCBsQXJyOiA4NjU2LCB1QXJyOiA4NjU3LCByQXJyOiA4NjU4LCBkQXJyOiA4NjU5LCBoQXJyOiA4NjYwLCBmb3JhbGw6IDg3MDQsIHBhcnQ6IDg3MDYsIGV4aXN0OiA4NzA3LCBlbXB0eTogODcwOSwgbmFibGE6IDg3MTEsIGlzaW46IDg3MTIsIG5vdGluOiA4NzEzLCBuaTogODcxNSwgcHJvZDogODcxOSwgc3VtOiA4NzIxLCBtaW51czogODcyMiwgbG93YXN0OiA4NzI3LCByYWRpYzogODczMCwgcHJvcDogODczMywgaW5maW46IDg3MzQsIGFuZzogODczNiwgYW5kOiA4NzQzLCBvcjogODc0NCwgY2FwOiA4NzQ1LCBjdXA6IDg3NDYsIGludDogODc0NywgdGhlcmU0OiA4NzU2LCBzaW06IDg3NjQsIGNvbmc6IDg3NzMsIGFzeW1wOiA4Nzc2LCBuZTogODgwMCwgZXF1aXY6IDg4MDEsIGxlOiA4ODA0LCBnZTogODgwNSwgc3ViOiA4ODM0LCBzdXA6IDg4MzUsIG5zdWI6IDg4MzYsIHN1YmU6IDg4MzgsIHN1cGU6IDg4MzksIG9wbHVzOiA4ODUzLCBvdGltZXM6IDg4NTUsIHBlcnA6IDg4NjksIHNkb3Q6IDg5MDEsIGxjZWlsOiA4OTY4LCByY2VpbDogODk2OSwgbGZsb29yOiA4OTcwLCByZmxvb3I6IDg5NzEsIGxhbmc6IDkwMDEsIHJhbmc6IDkwMDIsIGxvejogOTY3NCwgc3BhZGVzOiA5ODI0LCBjbHViczogOTgyNywgaGVhcnRzOiA5ODI5LCBkaWFtczogOTgzMCB9O1xuICBjb250cm9sQ2hhcmFjdGVycyA9IFs4MzY0LCAxMjksIDgyMTgsIDQwMiwgODIyMiwgODIzMCwgODIyNCwgODIyNSwgNzEwLCA4MjQwLCAzNTIsIDgyNDksIDMzOCwgMTQxLCAzODEsIDE0MywgMTQ0LCA4MjE2LCA4MjE3LCA4MjIwLCA4MjIxLCA4MjI2LCA4MjExLCA4MjEyLCA3MzIsIDg0ODIsIDM1MywgODI1MCwgMzM5LCAxNTcsIDM4MiwgMzc2XTtcbiAgZW50aXR5UGF0dGVybiA9IG5ldyBSZWdFeHAoXCImKCM/KD86eFtcXFxcd1xcXFxkXSt8XFxcXGQrfFwiICsgT2JqZWN0LmtleXMoaHRtbEVudGl0aWVzKS5qb2luKFwifFwiKSArIFwiKSk7P1wiLCBcImdcIik7XG5cbiAgZnVuY3Rpb24gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyhodG1sKSB7XG4gIFx0cmV0dXJuIGh0bWwucmVwbGFjZShlbnRpdHlQYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gsIGVudGl0eSkge1xuICBcdFx0dmFyIGNvZGU7XG5cbiAgXHRcdC8vIEhhbmRsZSBuYW1lZCBlbnRpdGllc1xuICBcdFx0aWYgKGVudGl0eVswXSAhPT0gXCIjXCIpIHtcbiAgXHRcdFx0Y29kZSA9IGh0bWxFbnRpdGllc1tlbnRpdHldO1xuICBcdFx0fSBlbHNlIGlmIChlbnRpdHlbMV0gPT09IFwieFwiKSB7XG4gIFx0XHRcdGNvZGUgPSBwYXJzZUludChlbnRpdHkuc3Vic3RyaW5nKDIpLCAxNik7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjb2RlID0gcGFyc2VJbnQoZW50aXR5LnN1YnN0cmluZygxKSwgMTApO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWNvZGUpIHtcbiAgXHRcdFx0cmV0dXJuIG1hdGNoO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWxpZGF0ZUNvZGUoY29kZSkpO1xuICBcdH0pO1xuICB9XG5cbiAgLy8gc29tZSBjb2RlIHBvaW50cyBhcmUgdmVyYm90ZW4uIElmIHdlIHdlcmUgaW5zZXJ0aW5nIEhUTUwsIHRoZSBicm93c2VyIHdvdWxkIHJlcGxhY2UgdGhlIGlsbGVnYWxcbiAgLy8gY29kZSBwb2ludHMgd2l0aCBhbHRlcm5hdGl2ZXMgaW4gc29tZSBjYXNlcyAtIHNpbmNlIHdlJ3JlIGJ5cGFzc2luZyB0aGF0IG1lY2hhbmlzbSwgd2UgbmVlZFxuICAvLyB0byByZXBsYWNlIHRoZW0gb3Vyc2VsdmVzXG4gIC8vXG4gIC8vIFNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DaGFyYWN0ZXJfZW5jb2RpbmdzX2luX0hUTUwjSWxsZWdhbF9jaGFyYWN0ZXJzXG4gIGZ1bmN0aW9uIHZhbGlkYXRlQ29kZShjb2RlKSB7XG4gIFx0aWYgKCFjb2RlKSB7XG4gIFx0XHRyZXR1cm4gNjU1MzM7XG4gIFx0fVxuXG4gIFx0Ly8gbGluZSBmZWVkIGJlY29tZXMgZ2VuZXJpYyB3aGl0ZXNwYWNlXG4gIFx0aWYgKGNvZGUgPT09IDEwKSB7XG4gIFx0XHRyZXR1cm4gMzI7XG4gIFx0fVxuXG4gIFx0Ly8gQVNDSUkgcmFuZ2UuIChXaHkgc29tZW9uZSB3b3VsZCB1c2UgSFRNTCBlbnRpdGllcyBmb3IgQVNDSUkgY2hhcmFjdGVycyBJIGRvbid0IGtub3csIGJ1dC4uLilcbiAgXHRpZiAoY29kZSA8IDEyOCkge1xuICBcdFx0cmV0dXJuIGNvZGU7XG4gIFx0fVxuXG4gIFx0Ly8gY29kZSBwb2ludHMgMTI4LTE1OSBhcmUgZGVhbHQgd2l0aCBsZW5pZW50bHkgYnkgYnJvd3NlcnMsIGJ1dCB0aGV5J3JlIGluY29ycmVjdC4gV2UgbmVlZFxuICBcdC8vIHRvIGNvcnJlY3QgdGhlIG1pc3Rha2Ugb3Igd2UnbGwgZW5kIHVwIHdpdGggbWlzc2luZyDigqwgc2lnbnMgYW5kIHNvIG9uXG4gIFx0aWYgKGNvZGUgPD0gMTU5KSB7XG4gIFx0XHRyZXR1cm4gY29udHJvbENoYXJhY3RlcnNbY29kZSAtIDEyOF07XG4gIFx0fVxuXG4gIFx0Ly8gYmFzaWMgbXVsdGlsaW5ndWFsIHBsYW5lXG4gIFx0aWYgKGNvZGUgPCA1NTI5Nikge1xuICBcdFx0cmV0dXJuIGNvZGU7XG4gIFx0fVxuXG4gIFx0Ly8gVVRGLTE2IHN1cnJvZ2F0ZSBoYWx2ZXNcbiAgXHRpZiAoY29kZSA8PSA1NzM0Mykge1xuICBcdFx0cmV0dXJuIDY1NTMzO1xuICBcdH1cblxuICBcdC8vIHJlc3Qgb2YgdGhlIGJhc2ljIG11bHRpbGluZ3VhbCBwbGFuZVxuICBcdGlmIChjb2RlIDw9IDY1NTM1KSB7XG4gIFx0XHRyZXR1cm4gY29kZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gNjU1MzM7XG4gIH1cblxuICBsZXNzVGhhbiA9IC88L2c7XG4gIGdyZWF0ZXJUaGFuID0gLz4vZztcbiAgYW1wID0gLyYvZztcblxuICBmdW5jdGlvbiBlc2NhcGVIdG1sKHN0cikge1xuICBcdHJldHVybiBzdHIucmVwbGFjZShhbXAsIFwiJmFtcDtcIikucmVwbGFjZShsZXNzVGhhbiwgXCImbHQ7XCIpLnJlcGxhY2UoZ3JlYXRlclRoYW4sIFwiJmd0O1wiKTtcbiAgfVxuXG4gIHZhciBsZWFkaW5nTGluZWJyZWFrID0gL15cXHMqXFxyP1xcbi8sXG4gICAgICB0cmFpbGluZ0xpbmVicmVhayA9IC9cXHI/XFxuXFxzKiQvO1xuXG4gIHZhciBzdHJpcFN0YW5kYWxvbmVzID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gIFx0dmFyIGksIGN1cnJlbnQsIGJhY2tPbmUsIGJhY2tUd28sIGxhc3RTZWN0aW9uSXRlbTtcblxuICBcdGZvciAoaSA9IDE7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0Y3VycmVudCA9IGl0ZW1zW2ldO1xuICBcdFx0YmFja09uZSA9IGl0ZW1zW2kgLSAxXTtcbiAgXHRcdGJhY2tUd28gPSBpdGVtc1tpIC0gMl07XG5cbiAgXHRcdC8vIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgYSBbdGV4dF1bY29tbWVudF1bdGV4dF0gc2VxdWVuY2UuLi5cbiAgXHRcdGlmIChpc1N0cmluZyhjdXJyZW50KSAmJiBpc0NvbW1lbnQoYmFja09uZSkgJiYgaXNTdHJpbmcoYmFja1R3bykpIHtcblxuICBcdFx0XHQvLyAuLi4gYW5kIHRoZSBjb21tZW50IGlzIGEgc3RhbmRhbG9uZSAoaS5lLiBsaW5lIGJyZWFrcyBlaXRoZXIgc2lkZSkuLi5cbiAgXHRcdFx0aWYgKHRyYWlsaW5nTGluZWJyZWFrLnRlc3QoYmFja1R3bykgJiYgbGVhZGluZ0xpbmVicmVhay50ZXN0KGN1cnJlbnQpKSB7XG5cbiAgXHRcdFx0XHQvLyAuLi4gdGhlbiB3ZSB3YW50IHRvIHJlbW92ZSB0aGUgd2hpdGVzcGFjZSBhZnRlciB0aGUgZmlyc3QgbGluZSBicmVha1xuICBcdFx0XHRcdGl0ZW1zW2kgLSAyXSA9IGJhY2tUd28ucmVwbGFjZSh0cmFpbGluZ0xpbmVicmVhaywgXCJcXG5cIik7XG5cbiAgXHRcdFx0XHQvLyBhbmQgdGhlIGxlYWRpbmcgbGluZSBicmVhayBvZiB0aGUgc2Vjb25kIHRleHQgdG9rZW5cbiAgXHRcdFx0XHRpdGVtc1tpXSA9IGN1cnJlbnQucmVwbGFjZShsZWFkaW5nTGluZWJyZWFrLCBcIlwiKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBpZiB0aGUgY3VycmVudCBpdGVtIGlzIGEgc2VjdGlvbiwgYW5kIGl0IGlzIHByZWNlZGVkIGJ5IGEgbGluZWJyZWFrLCBhbmRcbiAgXHRcdC8vIGl0cyBmaXJzdCBpdGVtIGlzIGEgbGluZWJyZWFrLi4uXG4gIFx0XHRpZiAoaXNTZWN0aW9uKGN1cnJlbnQpICYmIGlzU3RyaW5nKGJhY2tPbmUpKSB7XG4gIFx0XHRcdGlmICh0cmFpbGluZ0xpbmVicmVhay50ZXN0KGJhY2tPbmUpICYmIGlzU3RyaW5nKGN1cnJlbnQuZlswXSkgJiYgbGVhZGluZ0xpbmVicmVhay50ZXN0KGN1cnJlbnQuZlswXSkpIHtcbiAgXHRcdFx0XHRpdGVtc1tpIC0gMV0gPSBiYWNrT25lLnJlcGxhY2UodHJhaWxpbmdMaW5lYnJlYWssIFwiXFxuXCIpO1xuICBcdFx0XHRcdGN1cnJlbnQuZlswXSA9IGN1cnJlbnQuZlswXS5yZXBsYWNlKGxlYWRpbmdMaW5lYnJlYWssIFwiXCIpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlmIHRoZSBsYXN0IGl0ZW0gd2FzIGEgc2VjdGlvbiwgYW5kIGl0IGlzIGZvbGxvd2VkIGJ5IGEgbGluZWJyZWFrLCBhbmRcbiAgXHRcdC8vIGl0cyBsYXN0IGl0ZW0gaXMgYSBsaW5lYnJlYWsuLi5cbiAgXHRcdGlmIChpc1N0cmluZyhjdXJyZW50KSAmJiBpc1NlY3Rpb24oYmFja09uZSkpIHtcbiAgXHRcdFx0bGFzdFNlY3Rpb25JdGVtID0gbGFzdEl0ZW0oYmFja09uZS5mKTtcblxuICBcdFx0XHRpZiAoaXNTdHJpbmcobGFzdFNlY3Rpb25JdGVtKSAmJiB0cmFpbGluZ0xpbmVicmVhay50ZXN0KGxhc3RTZWN0aW9uSXRlbSkgJiYgbGVhZGluZ0xpbmVicmVhay50ZXN0KGN1cnJlbnQpKSB7XG4gIFx0XHRcdFx0YmFja09uZS5mW2JhY2tPbmUuZi5sZW5ndGggLSAxXSA9IGxhc3RTZWN0aW9uSXRlbS5yZXBsYWNlKHRyYWlsaW5nTGluZWJyZWFrLCBcIlxcblwiKTtcbiAgXHRcdFx0XHRpdGVtc1tpXSA9IGN1cnJlbnQucmVwbGFjZShsZWFkaW5nTGluZWJyZWFrLCBcIlwiKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBpdGVtcztcbiAgfTtcblxuICBmdW5jdGlvbiBpc1N0cmluZyhpdGVtKSB7XG4gIFx0cmV0dXJuIHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDb21tZW50KGl0ZW0pIHtcbiAgXHRyZXR1cm4gaXRlbS50ID09PSBDT01NRU5UIHx8IGl0ZW0udCA9PT0gREVMSU1DSEFOR0U7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NlY3Rpb24oaXRlbSkge1xuICBcdHJldHVybiAoaXRlbS50ID09PSBTRUNUSU9OIHx8IGl0ZW0udCA9PT0gSU5WRVJURUQpICYmIGl0ZW0uZjtcbiAgfVxuXG4gIHZhciB0cmltV2hpdGVzcGFjZSA9IGZ1bmN0aW9uIChpdGVtcywgbGVhZGluZ1BhdHRlcm4sIHRyYWlsaW5nUGF0dGVybikge1xuICBcdHZhciBpdGVtO1xuXG4gIFx0aWYgKGxlYWRpbmdQYXR0ZXJuKSB7XG4gIFx0XHRpdGVtID0gaXRlbXNbMF07XG4gIFx0XHRpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0aXRlbSA9IGl0ZW0ucmVwbGFjZShsZWFkaW5nUGF0dGVybiwgXCJcIik7XG5cbiAgXHRcdFx0aWYgKCFpdGVtKSB7XG4gIFx0XHRcdFx0aXRlbXMuc2hpZnQoKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRpdGVtc1swXSA9IGl0ZW07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAodHJhaWxpbmdQYXR0ZXJuKSB7XG4gIFx0XHRpdGVtID0gbGFzdEl0ZW0oaXRlbXMpO1xuICBcdFx0aWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdGl0ZW0gPSBpdGVtLnJlcGxhY2UodHJhaWxpbmdQYXR0ZXJuLCBcIlwiKTtcblxuICBcdFx0XHRpZiAoIWl0ZW0pIHtcbiAgXHRcdFx0XHRpdGVtcy5wb3AoKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSA9IGl0ZW07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIHV0aWxzX2NsZWFudXAgPSBjbGVhbnVwO1xuICB2YXIgY29udGlndW91c1doaXRlc3BhY2UgPSAvWyBcXHRcXGZcXHJcXG5dKy9nO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudHMgPSAvXig/OnByZXxzY3JpcHR8c3R5bGV8dGV4dGFyZWEpJC9pO1xuICB2YXIgdXRpbHNfY2xlYW51cF9fbGVhZGluZ1doaXRlc3BhY2UgPSAvXlsgXFx0XFxmXFxyXFxuXSsvO1xuICB2YXIgdHJhaWxpbmdXaGl0ZXNwYWNlID0gL1sgXFx0XFxmXFxyXFxuXSskLztcbiAgdmFyIGxlYWRpbmdOZXdMaW5lID0gL14oPzpcXHJcXG58XFxyfFxcbikvO1xuICB2YXIgdHJhaWxpbmdOZXdMaW5lID0gLyg/OlxcclxcbnxcXHJ8XFxuKSQvO1xuICBmdW5jdGlvbiBjbGVhbnVwKGl0ZW1zLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlLCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2UpIHtcbiAgXHR2YXIgaSwgaXRlbSwgcHJldmlvdXNJdGVtLCBuZXh0SXRlbSwgcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCBrZXk7XG5cbiAgXHQvLyBGaXJzdCBwYXNzIC0gcmVtb3ZlIHN0YW5kYWxvbmVzIGFuZCBjb21tZW50cyBldGNcbiAgXHRzdHJpcFN0YW5kYWxvbmVzKGl0ZW1zKTtcblxuICBcdGkgPSBpdGVtcy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aXRlbSA9IGl0ZW1zW2ldO1xuXG4gIFx0XHQvLyBSZW1vdmUgZGVsaW1pdGVyIGNoYW5nZXMsIHVuc2FmZSBlbGVtZW50cyBldGNcbiAgXHRcdGlmIChpdGVtLmV4Y2x1ZGUpIHtcbiAgXHRcdFx0aXRlbXMuc3BsaWNlKGksIDEpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBSZW1vdmUgY29tbWVudHMsIHVubGVzcyB3ZSB3YW50IHRvIGtlZXAgdGhlbVxuICBcdFx0ZWxzZSBpZiAoc3RyaXBDb21tZW50cyAmJiBpdGVtLnQgPT09IENPTU1FTlQpIHtcbiAgXHRcdFx0aXRlbXMuc3BsaWNlKGksIDEpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIElmIG5lY2Vzc2FyeSwgcmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgXHR0cmltV2hpdGVzcGFjZShpdGVtcywgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2UgPyB1dGlsc19jbGVhbnVwX19sZWFkaW5nV2hpdGVzcGFjZSA6IG51bGwsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZSA/IHRyYWlsaW5nV2hpdGVzcGFjZSA6IG51bGwpO1xuXG4gIFx0aSA9IGl0ZW1zLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpdGVtID0gaXRlbXNbaV07XG5cbiAgXHRcdC8vIFJlY3Vyc2VcbiAgXHRcdGlmIChpdGVtLmYpIHtcbiAgXHRcdFx0dmFyIGlzUHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudCA9IGl0ZW0udCA9PT0gRUxFTUVOVCAmJiBwcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50cy50ZXN0KGl0ZW0uZSk7XG4gIFx0XHRcdHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gcHJlc2VydmVXaGl0ZXNwYWNlIHx8IGlzUHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudDtcblxuICBcdFx0XHRpZiAoIXByZXNlcnZlV2hpdGVzcGFjZSAmJiBpc1ByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnQpIHtcbiAgXHRcdFx0XHR0cmltV2hpdGVzcGFjZShpdGVtLmYsIGxlYWRpbmdOZXdMaW5lLCB0cmFpbGluZ05ld0xpbmUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCFwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCkge1xuICBcdFx0XHRcdHByZXZpb3VzSXRlbSA9IGl0ZW1zW2kgLSAxXTtcbiAgXHRcdFx0XHRuZXh0SXRlbSA9IGl0ZW1zW2kgKyAxXTtcblxuICBcdFx0XHRcdC8vIGlmIHRoZSBwcmV2aW91cyBpdGVtIHdhcyBhIHRleHQgaXRlbSB3aXRoIHRyYWlsaW5nIHdoaXRlc3BhY2UsXG4gIFx0XHRcdFx0Ly8gcmVtb3ZlIGxlYWRpbmcgd2hpdGVzcGFjZSBpbnNpZGUgdGhlIGZyYWdtZW50XG4gIFx0XHRcdFx0aWYgKCFwcmV2aW91c0l0ZW0gfHwgdHlwZW9mIHByZXZpb3VzSXRlbSA9PT0gXCJzdHJpbmdcIiAmJiB0cmFpbGluZ1doaXRlc3BhY2UudGVzdChwcmV2aW91c0l0ZW0pKSB7XG4gIFx0XHRcdFx0XHRyZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyBhbmQgdmljZSB2ZXJzYVxuICBcdFx0XHRcdGlmICghbmV4dEl0ZW0gfHwgdHlwZW9mIG5leHRJdGVtID09PSBcInN0cmluZ1wiICYmIHV0aWxzX2NsZWFudXBfX2xlYWRpbmdXaGl0ZXNwYWNlLnRlc3QobmV4dEl0ZW0pKSB7XG4gIFx0XHRcdFx0XHRyZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCA9IHRydWU7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y2xlYW51cChpdGVtLmYsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFNwbGl0IGlmLWVsc2UgYmxvY2tzIGludG8gdHdvIChhbiBpZiwgYW5kIGFuIHVubGVzcylcbiAgXHRcdGlmIChpdGVtLmwpIHtcbiAgXHRcdFx0Y2xlYW51cChpdGVtLmwuZiwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCk7XG5cbiAgXHRcdFx0aXRlbXMuc3BsaWNlKGkgKyAxLCAwLCBpdGVtLmwpO1xuICBcdFx0XHRkZWxldGUgaXRlbS5sOyAvLyBUT0RPIHdvdWxkIGJlIG5pY2UgaWYgdGhlcmUgd2FzIGEgd2F5IGFyb3VuZCB0aGlzXG4gIFx0XHR9XG5cbiAgXHRcdC8vIENsZWFuIHVwIGVsZW1lbnQgYXR0cmlidXRlc1xuICBcdFx0aWYgKGl0ZW0uYSkge1xuICBcdFx0XHRmb3IgKGtleSBpbiBpdGVtLmEpIHtcbiAgXHRcdFx0XHRpZiAoaXRlbS5hLmhhc093blByb3BlcnR5KGtleSkgJiYgdHlwZW9mIGl0ZW0uYVtrZXldICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdFx0XHRjbGVhbnVwKGl0ZW0uYVtrZXldLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gQ2xlYW4gdXAgY29uZGl0aW9uYWwgYXR0cmlidXRlc1xuICBcdFx0aWYgKGl0ZW0ubSkge1xuICBcdFx0XHRjbGVhbnVwKGl0ZW0ubSwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIENsZWFuIHVwIGV2ZW50IGhhbmRsZXJzXG4gIFx0XHRpZiAoaXRlbS52KSB7XG4gIFx0XHRcdGZvciAoa2V5IGluIGl0ZW0udikge1xuICBcdFx0XHRcdGlmIChpdGVtLnYuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBcdFx0XHRcdFx0Ly8gY2xlYW4gdXAgbmFtZXNcbiAgXHRcdFx0XHRcdGlmIChpc0FycmF5KGl0ZW0udltrZXldLm4pKSB7XG4gIFx0XHRcdFx0XHRcdGNsZWFudXAoaXRlbS52W2tleV0ubiwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCk7XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdC8vIGNsZWFuIHVwIHBhcmFtc1xuICBcdFx0XHRcdFx0aWYgKGlzQXJyYXkoaXRlbS52W2tleV0uZCkpIHtcbiAgXHRcdFx0XHRcdFx0Y2xlYW51cChpdGVtLnZba2V5XS5kLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50KTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBmaW5hbCBwYXNzIC0gZnVzZSB0ZXh0IG5vZGVzIHRvZ2V0aGVyXG4gIFx0aSA9IGl0ZW1zLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAodHlwZW9mIGl0ZW1zW2ldID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdGlmICh0eXBlb2YgaXRlbXNbaSArIDFdID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdFx0aXRlbXNbaV0gPSBpdGVtc1tpXSArIGl0ZW1zW2kgKyAxXTtcbiAgXHRcdFx0XHRpdGVtcy5zcGxpY2UoaSArIDEsIDEpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCFwcmVzZXJ2ZVdoaXRlc3BhY2UpIHtcbiAgXHRcdFx0XHRpdGVtc1tpXSA9IGl0ZW1zW2ldLnJlcGxhY2UoY29udGlndW91c1doaXRlc3BhY2UsIFwiIFwiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChpdGVtc1tpXSA9PT0gXCJcIikge1xuICBcdFx0XHRcdGl0ZW1zLnNwbGljZShpLCAxKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBlbGVtZW50X3JlYWRDbG9zaW5nVGFnID0gcmVhZENsb3NpbmdUYWc7XG4gIHZhciBjbG9zaW5nVGFnUGF0dGVybiA9IC9eKFthLXpBLVpdezEsfTo/W2EtekEtWjAtOVxcLV0qKVxccypcXD4vO1xuICBmdW5jdGlvbiByZWFkQ2xvc2luZ1RhZyhwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIHRhZztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFyZSB3ZSBsb29raW5nIGF0IGEgY2xvc2luZyB0YWc/XG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI8L1wiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKHRhZyA9IHBhcnNlci5tYXRjaFBhdHRlcm4oY2xvc2luZ1RhZ1BhdHRlcm4pKSB7XG4gIFx0XHRpZiAocGFyc2VyLmluc2lkZSAmJiB0YWcgIT09IHBhcnNlci5pbnNpZGUpIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogQ0xPU0lOR19UQUcsXG4gIFx0XHRcdGU6IHRhZ1xuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHQvLyBXZSBoYXZlIGFuIGlsbGVnYWwgY2xvc2luZyB0YWcsIHJlcG9ydCBpdFxuICBcdHBhcnNlci5wb3MgLT0gMjtcbiAgXHRwYXJzZXIuZXJyb3IoXCJJbGxlZ2FsIGNsb3NpbmcgdGFnXCIpO1xuICB9XG5cbiAgdmFyIGdldExvd2VzdEluZGV4ID0gZnVuY3Rpb24gKGhheXN0YWNrLCBuZWVkbGVzKSB7XG4gIFx0dmFyIGksIGluZGV4LCBsb3dlc3Q7XG5cbiAgXHRpID0gbmVlZGxlcy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aW5kZXggPSBoYXlzdGFjay5pbmRleE9mKG5lZWRsZXNbaV0pO1xuXG4gIFx0XHQvLyBzaG9ydCBjaXJjdWl0XG4gIFx0XHRpZiAoIWluZGV4KSB7XG4gIFx0XHRcdHJldHVybiAwO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdGNvbnRpbnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWxvd2VzdCB8fCBpbmRleCA8IGxvd2VzdCkge1xuICBcdFx0XHRsb3dlc3QgPSBpbmRleDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbG93ZXN0IHx8IC0xO1xuICB9O1xuXG4gIHZhciBlbGVtZW50X3JlYWRBdHRyaWJ1dGUgPSByZWFkQXR0cmlidXRlO1xuXG4gIHZhciBhdHRyaWJ1dGVOYW1lUGF0dGVybiA9IC9eW15cXHNcIic+XFwvPV0rLyxcbiAgICAgIHVucXVvdGVkQXR0cmlidXRlVmFsdWVUZXh0UGF0dGVybiA9IC9eW15cXHNcIic9PD5gXSsvO1xuICBmdW5jdGlvbiByZWFkQXR0cmlidXRlKHBhcnNlcikge1xuICBcdHZhciBhdHRyLCBuYW1lLCB2YWx1ZTtcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGF0dHJpYnV0ZU5hbWVQYXR0ZXJuKTtcbiAgXHRpZiAoIW5hbWUpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGF0dHIgPSB7IG5hbWU6IG5hbWUgfTtcblxuICBcdHZhbHVlID0gcmVhZEF0dHJpYnV0ZVZhbHVlKHBhcnNlcik7XG4gIFx0aWYgKHZhbHVlICE9IG51bGwpIHtcbiAgXHRcdC8vIG5vdCBudWxsL3VuZGVmaW5lZFxuICBcdFx0YXR0ci52YWx1ZSA9IHZhbHVlO1xuICBcdH1cblxuICBcdHJldHVybiBhdHRyO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEF0dHJpYnV0ZVZhbHVlKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgdmFsdWVTdGFydCwgc3RhcnREZXB0aCwgdmFsdWU7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBuZXh0IGNoYXJhY3RlciBtdXN0IGJlIGA9YCwgYC9gLCBgPmAgb3Igd2hpdGVzcGFjZVxuICBcdGlmICghL1s9XFwvPlxcc10vLnRlc3QocGFyc2VyLm5leHRDaGFyKCkpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBgPWAsIGAvYCwgYD5gIG9yIHdoaXRlc3BhY2VcIik7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI9XCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHR2YWx1ZVN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRzdGFydERlcHRoID0gcGFyc2VyLnNlY3Rpb25EZXB0aDtcblxuICBcdHZhbHVlID0gcmVhZFF1b3RlZEF0dHJpYnV0ZVZhbHVlKHBhcnNlciwgXCInXCIpIHx8IHJlYWRRdW90ZWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIsIFwiXFxcIlwiKSB8fCByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIpO1xuXG4gIFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCB2YWxpZCBhdHRyaWJ1dGUgdmFsdWVcIik7XG4gIFx0fVxuXG4gIFx0aWYgKHBhcnNlci5zZWN0aW9uRGVwdGggIT09IHN0YXJ0RGVwdGgpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSB2YWx1ZVN0YXJ0O1xuICBcdFx0cGFyc2VyLmVycm9yKFwiQW4gYXR0cmlidXRlIHZhbHVlIG11c3QgY29udGFpbiBhcyBtYW55IG9wZW5pbmcgc2VjdGlvbiB0YWdzIGFzIGNsb3Npbmcgc2VjdGlvbiB0YWdzXCIpO1xuICBcdH1cblxuICBcdGlmICghdmFsdWUubGVuZ3RoKSB7XG4gIFx0XHRyZXR1cm4gXCJcIjtcbiAgXHR9XG5cbiAgXHRpZiAodmFsdWUubGVuZ3RoID09PSAxICYmIHR5cGVvZiB2YWx1ZVswXSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0cmV0dXJuIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXModmFsdWVbMF0pO1xuICBcdH1cblxuICBcdHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlVG9rZW4ocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCB0ZXh0LCBoYXlzdGFjaywgbmVlZGxlcywgaW5kZXg7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHR0ZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybih1bnF1b3RlZEF0dHJpYnV0ZVZhbHVlVGV4dFBhdHRlcm4pO1xuXG4gIFx0aWYgKCF0ZXh0KSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRoYXlzdGFjayA9IHRleHQ7XG4gIFx0bmVlZGxlcyA9IHBhcnNlci50YWdzLm1hcChmdW5jdGlvbiAodCkge1xuICBcdFx0cmV0dXJuIHQub3BlbjtcbiAgXHR9KTsgLy8gVE9ETyByZWZhY3Rvci4uLiB3ZSBkbyB0aGlzIGluIHJlYWRUZXh0LmpzIGFzIHdlbGxcblxuICBcdGlmICgoaW5kZXggPSBnZXRMb3dlc3RJbmRleChoYXlzdGFjaywgbmVlZGxlcykpICE9PSAtMSkge1xuICBcdFx0dGV4dCA9IHRleHQuc3Vic3RyKDAsIGluZGV4KTtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydCArIHRleHQubGVuZ3RoO1xuICBcdH1cblxuICBcdHJldHVybiB0ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFVucXVvdGVkQXR0cmlidXRlVmFsdWUocGFyc2VyKSB7XG4gIFx0dmFyIHRva2VucywgdG9rZW47XG5cbiAgXHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSB0cnVlO1xuXG4gIFx0dG9rZW5zID0gW107XG5cbiAgXHR0b2tlbiA9IGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlKHBhcnNlcikgfHwgcmVhZFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbihwYXJzZXIpO1xuICBcdHdoaWxlICh0b2tlbiAhPT0gbnVsbCkge1xuICBcdFx0dG9rZW5zLnB1c2godG9rZW4pO1xuICBcdFx0dG9rZW4gPSBjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZShwYXJzZXIpIHx8IHJlYWRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlVG9rZW4ocGFyc2VyKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXRva2Vucy5sZW5ndGgpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IGZhbHNlO1xuICBcdHJldHVybiB0b2tlbnM7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkUXVvdGVkQXR0cmlidXRlVmFsdWUocGFyc2VyLCBxdW90ZU1hcmspIHtcbiAgXHR2YXIgc3RhcnQsIHRva2VucywgdG9rZW47XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhxdW90ZU1hcmspKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSBxdW90ZU1hcms7XG5cbiAgXHR0b2tlbnMgPSBbXTtcblxuICBcdHRva2VuID0gY29udmVydGVyc19yZWFkTXVzdGFjaGUocGFyc2VyKSB8fCByZWFkUXVvdGVkU3RyaW5nVG9rZW4ocGFyc2VyLCBxdW90ZU1hcmspO1xuICBcdHdoaWxlICh0b2tlbiAhPT0gbnVsbCkge1xuICBcdFx0dG9rZW5zLnB1c2godG9rZW4pO1xuICBcdFx0dG9rZW4gPSBjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZShwYXJzZXIpIHx8IHJlYWRRdW90ZWRTdHJpbmdUb2tlbihwYXJzZXIsIHF1b3RlTWFyayk7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcocXVvdGVNYXJrKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmluQXR0cmlidXRlID0gZmFsc2U7XG5cbiAgXHRyZXR1cm4gdG9rZW5zO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFF1b3RlZFN0cmluZ1Rva2VuKHBhcnNlciwgcXVvdGVNYXJrKSB7XG4gIFx0dmFyIHN0YXJ0LCBpbmRleCwgaGF5c3RhY2ssIG5lZWRsZXM7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG4gIFx0aGF5c3RhY2sgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cbiAgXHRuZWVkbGVzID0gcGFyc2VyLnRhZ3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRyZXR1cm4gdC5vcGVuO1xuICBcdH0pOyAvLyBUT0RPIHJlZmFjdG9yLi4uIHdlIGRvIHRoaXMgaW4gcmVhZFRleHQuanMgYXMgd2VsbFxuICBcdG5lZWRsZXMucHVzaChxdW90ZU1hcmspO1xuXG4gIFx0aW5kZXggPSBnZXRMb3dlc3RJbmRleChoYXlzdGFjaywgbmVlZGxlcyk7XG5cbiAgXHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJRdW90ZWQgYXR0cmlidXRlIHZhbHVlIG11c3QgaGF2ZSBhIGNsb3NpbmcgcXVvdGVcIik7XG4gIFx0fVxuXG4gIFx0aWYgKCFpbmRleCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnBvcyArPSBpbmRleDtcbiAgXHRyZXR1cm4gaGF5c3RhY2suc3Vic3RyKDAsIGluZGV4KTtcbiAgfVxuXG4gIHZhciBKc29uUGFyc2VyLCBzcGVjaWFscywgc3BlY2lhbHNQYXR0ZXJuLCBwYXJzZUpTT05fX251bWJlclBhdHRlcm4sIHBsYWNlaG9sZGVyUGF0dGVybiwgcGxhY2Vob2xkZXJBdFN0YXJ0UGF0dGVybiwgb25seVdoaXRlc3BhY2U7XG5cbiAgc3BlY2lhbHMgPSB7XG4gIFx0XCJ0cnVlXCI6IHRydWUsXG4gIFx0XCJmYWxzZVwiOiBmYWxzZSxcbiAgXHR1bmRlZmluZWQ6IHVuZGVmaW5lZCxcbiAgXHRcIm51bGxcIjogbnVsbFxuICB9O1xuXG4gIHNwZWNpYWxzUGF0dGVybiA9IG5ldyBSZWdFeHAoXCJeKD86XCIgKyBPYmplY3Qua2V5cyhzcGVjaWFscykuam9pbihcInxcIikgKyBcIilcIik7XG4gIHBhcnNlSlNPTl9fbnVtYmVyUGF0dGVybiA9IC9eKD86WystXT8pKD86KD86KD86MHxbMS05XVxcZCopP1xcLlxcZCspfCg/Oig/OjB8WzEtOV1cXGQqKVxcLil8KD86MHxbMS05XVxcZCopKSg/OltlRV1bKy1dP1xcZCspPy87XG4gIHBsYWNlaG9sZGVyUGF0dGVybiA9IC9cXCRcXHsoW15cXH1dKylcXH0vZztcbiAgcGxhY2Vob2xkZXJBdFN0YXJ0UGF0dGVybiA9IC9eXFwkXFx7KFteXFx9XSspXFx9LztcbiAgb25seVdoaXRlc3BhY2UgPSAvXlxccyokLztcblxuICBKc29uUGFyc2VyID0gcGFyc2VfUGFyc2VyLmV4dGVuZCh7XG4gIFx0aW5pdDogZnVuY3Rpb24gKHN0ciwgb3B0aW9ucykge1xuICBcdFx0dGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcbiAgXHRcdHRoaXMuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0fSxcblxuICBcdHBvc3RQcm9jZXNzOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gIFx0XHRpZiAocmVzdWx0Lmxlbmd0aCAhPT0gMSB8fCAhb25seVdoaXRlc3BhY2UudGVzdCh0aGlzLmxlZnRvdmVyKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHsgdmFsdWU6IHJlc3VsdFswXS52IH07XG4gIFx0fSxcblxuICBcdGNvbnZlcnRlcnM6IFtmdW5jdGlvbiBnZXRQbGFjZWhvbGRlcihwYXJzZXIpIHtcbiAgXHRcdHZhciBwbGFjZWhvbGRlcjtcblxuICBcdFx0aWYgKCFwYXJzZXIudmFsdWVzKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRwbGFjZWhvbGRlciA9IHBhcnNlci5tYXRjaFBhdHRlcm4ocGxhY2Vob2xkZXJBdFN0YXJ0UGF0dGVybik7XG5cbiAgXHRcdGlmIChwbGFjZWhvbGRlciAmJiBwYXJzZXIudmFsdWVzLmhhc093blByb3BlcnR5KHBsYWNlaG9sZGVyKSkge1xuICBcdFx0XHRyZXR1cm4geyB2OiBwYXJzZXIudmFsdWVzW3BsYWNlaG9sZGVyXSB9O1xuICBcdFx0fVxuICBcdH0sIGZ1bmN0aW9uIGdldFNwZWNpYWwocGFyc2VyKSB7XG4gIFx0XHR2YXIgc3BlY2lhbDtcblxuICBcdFx0aWYgKHNwZWNpYWwgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHNwZWNpYWxzUGF0dGVybikpIHtcbiAgXHRcdFx0cmV0dXJuIHsgdjogc3BlY2lhbHNbc3BlY2lhbF0gfTtcbiAgXHRcdH1cbiAgXHR9LCBmdW5jdGlvbiBnZXROdW1iZXIocGFyc2VyKSB7XG4gIFx0XHR2YXIgbnVtYmVyO1xuXG4gIFx0XHRpZiAobnVtYmVyID0gcGFyc2VyLm1hdGNoUGF0dGVybihwYXJzZUpTT05fX251bWJlclBhdHRlcm4pKSB7XG4gIFx0XHRcdHJldHVybiB7IHY6ICtudW1iZXIgfTtcbiAgXHRcdH1cbiAgXHR9LCBmdW5jdGlvbiBnZXRTdHJpbmcocGFyc2VyKSB7XG4gIFx0XHR2YXIgc3RyaW5nTGl0ZXJhbCA9IHJlYWRTdHJpbmdMaXRlcmFsKHBhcnNlciksXG4gIFx0XHQgICAgdmFsdWVzO1xuXG4gIFx0XHRpZiAoc3RyaW5nTGl0ZXJhbCAmJiAodmFsdWVzID0gcGFyc2VyLnZhbHVlcykpIHtcbiAgXHRcdFx0cmV0dXJuIHtcbiAgXHRcdFx0XHR2OiBzdHJpbmdMaXRlcmFsLnYucmVwbGFjZShwbGFjZWhvbGRlclBhdHRlcm4sIGZ1bmN0aW9uIChtYXRjaCwgJDEpIHtcbiAgXHRcdFx0XHRcdHJldHVybiAkMSBpbiB2YWx1ZXMgPyB2YWx1ZXNbJDFdIDogJDE7XG4gIFx0XHRcdFx0fSlcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHN0cmluZ0xpdGVyYWw7XG4gIFx0fSwgZnVuY3Rpb24gZ2V0T2JqZWN0KHBhcnNlcikge1xuICBcdFx0dmFyIHJlc3VsdCwgcGFpcjtcblxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJ7XCIpKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXN1bHQgPSB7fTtcblxuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwifVwiKSkge1xuICBcdFx0XHRyZXR1cm4geyB2OiByZXN1bHQgfTtcbiAgXHRcdH1cblxuICBcdFx0d2hpbGUgKHBhaXIgPSBnZXRLZXlWYWx1ZVBhaXIocGFyc2VyKSkge1xuICBcdFx0XHRyZXN1bHRbcGFpci5rZXldID0gcGFpci52YWx1ZTtcblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIn1cIikpIHtcbiAgXHRcdFx0XHRyZXR1cm4geyB2OiByZXN1bHQgfTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiLFwiKSkge1xuICBcdFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH0sIGZ1bmN0aW9uIGdldEFycmF5KHBhcnNlcikge1xuICBcdFx0dmFyIHJlc3VsdCwgdmFsdWVUb2tlbjtcblxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJbXCIpKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXN1bHQgPSBbXTtcblxuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiXVwiKSkge1xuICBcdFx0XHRyZXR1cm4geyB2OiByZXN1bHQgfTtcbiAgXHRcdH1cblxuICBcdFx0d2hpbGUgKHZhbHVlVG9rZW4gPSBwYXJzZXIucmVhZCgpKSB7XG4gIFx0XHRcdHJlc3VsdC5wdXNoKHZhbHVlVG9rZW4udik7XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJdXCIpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHsgdjogcmVzdWx0IH07XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIixcIikpIHtcbiAgXHRcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fV1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gZ2V0S2V5VmFsdWVQYWlyKHBhcnNlcikge1xuICBcdHZhciBrZXksIHZhbHVlVG9rZW4sIHBhaXI7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRrZXkgPSBzaGFyZWRfcmVhZEtleShwYXJzZXIpO1xuXG4gIFx0aWYgKCFrZXkpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhaXIgPSB7IGtleToga2V5IH07XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI6XCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0dmFsdWVUb2tlbiA9IHBhcnNlci5yZWFkKCk7XG4gIFx0aWYgKCF2YWx1ZVRva2VuKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYWlyLnZhbHVlID0gdmFsdWVUb2tlbi52O1xuXG4gIFx0cmV0dXJuIHBhaXI7XG4gIH1cblxuICB2YXIgcGFyc2VKU09OID0gZnVuY3Rpb24gKHN0ciwgdmFsdWVzKSB7XG4gIFx0dmFyIHBhcnNlciA9IG5ldyBKc29uUGFyc2VyKHN0ciwge1xuICBcdFx0dmFsdWVzOiB2YWx1ZXNcbiAgXHR9KTtcblxuICBcdHJldHVybiBwYXJzZXIucmVzdWx0O1xuICB9O1xuXG4gIC8vIFRPRE8gY2xlYW4gdGhpcyB1cCwgaXQncyBzaG9ja2luZ1xuICB2YXIgZWxlbWVudF9wcm9jZXNzRGlyZWN0aXZlID0gcHJvY2Vzc0RpcmVjdGl2ZTtcbiAgdmFyIG1ldGhvZENhbGxQYXR0ZXJuID0gL14oW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKVxcKC8sXG4gICAgICBtZXRob2RDYWxsRXhjZXNzUGF0dGVybiA9IC9cXClcXHMqJC8sXG4gICAgICBFeHByZXNzaW9uUGFyc2VyO1xuXG4gIEV4cHJlc3Npb25QYXJzZXIgPSBwYXJzZV9QYXJzZXIuZXh0ZW5kKHtcbiAgXHRjb252ZXJ0ZXJzOiBbY29udmVydGVyc19yZWFkRXhwcmVzc2lvbl1cbiAgfSk7XG4gIGZ1bmN0aW9uIHByb2Nlc3NEaXJlY3RpdmUodG9rZW5zLCBwYXJlbnRQYXJzZXIpIHtcbiAgXHR2YXIgcmVzdWx0LCBtYXRjaCwgcGFyc2VyLCBhcmdzLCB0b2tlbiwgY29sb25JbmRleCwgZGlyZWN0aXZlTmFtZSwgZGlyZWN0aXZlQXJncywgcGFyc2VkO1xuXG4gIFx0aWYgKHR5cGVvZiB0b2tlbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGlmIChtYXRjaCA9IG1ldGhvZENhbGxQYXR0ZXJuLmV4ZWModG9rZW5zKSkge1xuICBcdFx0XHR2YXIgZW5kID0gdG9rZW5zLmxhc3RJbmRleE9mKFwiKVwiKTtcblxuICBcdFx0XHQvLyBjaGVjayBmb3IgaW52YWxpZCBtZXRob2QgY2FsbHNcbiAgXHRcdFx0aWYgKCFtZXRob2RDYWxsRXhjZXNzUGF0dGVybi50ZXN0KHRva2VucykpIHtcbiAgXHRcdFx0XHRwYXJlbnRQYXJzZXIuZXJyb3IoXCJJbnZhbGlkIGlucHV0IGFmdGVyIG1ldGhvZCBjYWxsIGV4cHJlc3Npb24gJ1wiICsgdG9rZW5zLnNsaWNlKGVuZCArIDEpICsgXCInXCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmVzdWx0ID0geyBtOiBtYXRjaFsxXSB9O1xuICBcdFx0XHRhcmdzID0gXCJbXCIgKyB0b2tlbnMuc2xpY2UocmVzdWx0Lm0ubGVuZ3RoICsgMSwgZW5kKSArIFwiXVwiO1xuXG4gIFx0XHRcdHBhcnNlciA9IG5ldyBFeHByZXNzaW9uUGFyc2VyKGFyZ3MpO1xuICBcdFx0XHRyZXN1bHQuYSA9IHV0aWxzX2ZsYXR0ZW5FeHByZXNzaW9uKHBhcnNlci5yZXN1bHRbMF0pO1xuXG4gIFx0XHRcdHJldHVybiByZXN1bHQ7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0b2tlbnMuaW5kZXhPZihcIjpcIikgPT09IC0xKSB7XG4gIFx0XHRcdHJldHVybiB0b2tlbnMudHJpbSgpO1xuICBcdFx0fVxuXG4gIFx0XHR0b2tlbnMgPSBbdG9rZW5zXTtcbiAgXHR9XG5cbiAgXHRyZXN1bHQgPSB7fTtcblxuICBcdGRpcmVjdGl2ZU5hbWUgPSBbXTtcbiAgXHRkaXJlY3RpdmVBcmdzID0gW107XG5cbiAgXHRpZiAodG9rZW5zKSB7XG4gIFx0XHR3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICBcdFx0XHR0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuXG4gIFx0XHRcdGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHRjb2xvbkluZGV4ID0gdG9rZW4uaW5kZXhPZihcIjpcIik7XG5cbiAgXHRcdFx0XHRpZiAoY29sb25JbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0XHRcdGRpcmVjdGl2ZU5hbWUucHVzaCh0b2tlbik7XG4gIFx0XHRcdFx0fSBlbHNlIHtcblxuICBcdFx0XHRcdFx0Ly8gaXMgdGhlIGNvbG9uIHRoZSBmaXJzdCBjaGFyYWN0ZXI/XG4gIFx0XHRcdFx0XHRpZiAoY29sb25JbmRleCkge1xuICBcdFx0XHRcdFx0XHQvLyBub1xuICBcdFx0XHRcdFx0XHRkaXJlY3RpdmVOYW1lLnB1c2godG9rZW4uc3Vic3RyKDAsIGNvbG9uSW5kZXgpKTtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgYW55dGhpbmcgYWZ0ZXIgdGhlIGNvbG9uIGluIHRoaXMgdG9rZW4sIHRyZWF0XG4gIFx0XHRcdFx0XHQvLyBpdCBhcyB0aGUgZmlyc3QgdG9rZW4gb2YgdGhlIGRpcmVjdGl2ZUFyZ3MgZnJhZ21lbnRcbiAgXHRcdFx0XHRcdGlmICh0b2tlbi5sZW5ndGggPiBjb2xvbkluZGV4ICsgMSkge1xuICBcdFx0XHRcdFx0XHRkaXJlY3RpdmVBcmdzWzBdID0gdG9rZW4uc3Vic3RyaW5nKGNvbG9uSW5kZXggKyAxKTtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGRpcmVjdGl2ZU5hbWUucHVzaCh0b2tlbik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0ZGlyZWN0aXZlQXJncyA9IGRpcmVjdGl2ZUFyZ3MuY29uY2F0KHRva2Vucyk7XG4gIFx0fVxuXG4gIFx0aWYgKCFkaXJlY3RpdmVOYW1lLmxlbmd0aCkge1xuICBcdFx0cmVzdWx0ID0gXCJcIjtcbiAgXHR9IGVsc2UgaWYgKGRpcmVjdGl2ZUFyZ3MubGVuZ3RoIHx8IHR5cGVvZiBkaXJlY3RpdmVOYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRyZXN1bHQgPSB7XG4gIFx0XHRcdC8vIFRPRE8gaXMgdGhpcyByZWFsbHkgbmVjZXNzYXJ5PyBqdXN0IHVzZSB0aGUgYXJyYXlcbiAgXHRcdFx0bjogZGlyZWN0aXZlTmFtZS5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRpcmVjdGl2ZU5hbWVbMF0gPT09IFwic3RyaW5nXCIgPyBkaXJlY3RpdmVOYW1lWzBdIDogZGlyZWN0aXZlTmFtZVxuICBcdFx0fTtcblxuICBcdFx0aWYgKGRpcmVjdGl2ZUFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBkaXJlY3RpdmVBcmdzWzBdID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdHBhcnNlZCA9IHBhcnNlSlNPTihcIltcIiArIGRpcmVjdGl2ZUFyZ3NbMF0gKyBcIl1cIik7XG4gIFx0XHRcdHJlc3VsdC5hID0gcGFyc2VkID8gcGFyc2VkLnZhbHVlIDogZGlyZWN0aXZlQXJnc1swXS50cmltKCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXN1bHQuZCA9IGRpcmVjdGl2ZUFyZ3M7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJlc3VsdCA9IGRpcmVjdGl2ZU5hbWU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciB0YWdOYW1lUGF0dGVybiA9IC9eW2EtekEtWl17MSx9Oj9bYS16QS1aMC05XFwtXSovLFxuICAgICAgdmFsaWRUYWdOYW1lRm9sbG93ZXIgPSAvXltcXHNcXG5cXC8+XS8sXG4gICAgICBvblBhdHRlcm4gPSAvXm9uLyxcbiAgICAgIHByb3h5RXZlbnRQYXR0ZXJuID0gL15vbi0oW2EtekEtWlxcXFwqXFxcXC4kX11bYS16QS1aXFxcXCpcXFxcLiRfMC05XFwtXSspJC8sXG4gICAgICByZXNlcnZlZEV2ZW50TmFtZXMgPSAvXig/OmNoYW5nZXxyZXNldHx0ZWFyZG93bnx1cGRhdGV8Y29uc3RydWN0fGNvbmZpZ3xpbml0fHJlbmRlcnx1bnJlbmRlcnxkZXRhY2h8aW5zZXJ0KSQvLFxuICAgICAgZGlyZWN0aXZlcyA9IHsgXCJpbnRyby1vdXRyb1wiOiBcInQwXCIsIGludHJvOiBcInQxXCIsIG91dHJvOiBcInQyXCIsIGRlY29yYXRvcjogXCJvXCIgfSxcbiAgICAgIGV4Y2x1ZGUgPSB7IGV4Y2x1ZGU6IHRydWUgfSxcbiAgICAgIGRpc2FsbG93ZWRDb250ZW50cztcblxuICAvLyBiYXNlZCBvbiBodHRwOi8vZGV2ZWxvcGVycy53aGF0d2cub3JnL3N5bnRheC5odG1sI3N5bnRheC10YWctb21pc3Npb25cbiAgZGlzYWxsb3dlZENvbnRlbnRzID0ge1xuICBcdGxpOiBbXCJsaVwiXSxcbiAgXHRkdDogW1wiZHRcIiwgXCJkZFwiXSxcbiAgXHRkZDogW1wiZHRcIiwgXCJkZFwiXSxcbiAgXHRwOiBcImFkZHJlc3MgYXJ0aWNsZSBhc2lkZSBibG9ja3F1b3RlIGRpdiBkbCBmaWVsZHNldCBmb290ZXIgZm9ybSBoMSBoMiBoMyBoNCBoNSBoNiBoZWFkZXIgaGdyb3VwIGhyIG1haW4gbWVudSBuYXYgb2wgcCBwcmUgc2VjdGlvbiB0YWJsZSB1bFwiLnNwbGl0KFwiIFwiKSxcbiAgXHRydDogW1wicnRcIiwgXCJycFwiXSxcbiAgXHRycDogW1wicnRcIiwgXCJycFwiXSxcbiAgXHRvcHRncm91cDogW1wib3B0Z3JvdXBcIl0sXG4gIFx0b3B0aW9uOiBbXCJvcHRpb25cIiwgXCJvcHRncm91cFwiXSxcbiAgXHR0aGVhZDogW1widGJvZHlcIiwgXCJ0Zm9vdFwiXSxcbiAgXHR0Ym9keTogW1widGJvZHlcIiwgXCJ0Zm9vdFwiXSxcbiAgXHR0Zm9vdDogW1widGJvZHlcIl0sXG4gIFx0dHI6IFtcInRyXCIsIFwidGJvZHlcIl0sXG4gIFx0dGQ6IFtcInRkXCIsIFwidGhcIiwgXCJ0clwiXSxcbiAgXHR0aDogW1widGRcIiwgXCJ0aFwiLCBcInRyXCJdXG4gIH07XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZEVsZW1lbnQgPSByZWFkRWxlbWVudDtcblxuICBmdW5jdGlvbiByZWFkRWxlbWVudChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGVsZW1lbnQsIGRpcmVjdGl2ZU5hbWUsIG1hdGNoLCBhZGRQcm94eUV2ZW50LCBhdHRyaWJ1dGUsIGRpcmVjdGl2ZSwgc2VsZkNsb3NpbmcsIGNoaWxkcmVuLCBwYXJ0aWFscywgaGFzUGFydGlhbHMsIGNoaWxkLCBjbG9zZWQsIHBvcywgcmVtYWluaW5nLCBjbG9zaW5nVGFnO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKHBhcnNlci5pbnNpZGUgfHwgcGFyc2VyLmluQXR0cmlidXRlKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIjxcIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGlmIHRoaXMgaXMgYSBjbG9zaW5nIHRhZywgYWJvcnQgc3RyYWlnaHQgYXdheVxuICBcdGlmIChwYXJzZXIubmV4dENoYXIoKSA9PT0gXCIvXCIpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGVsZW1lbnQgPSB7fTtcbiAgXHRpZiAocGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zKSB7XG4gIFx0XHRlbGVtZW50LnAgPSBwYXJzZXIuZ2V0TGluZVBvcyhzdGFydCk7XG4gIFx0fVxuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIiFcIikpIHtcbiAgXHRcdGVsZW1lbnQudCA9IERPQ1RZUEU7XG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4oL15kb2N0eXBlL2kpKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIERPQ1RZUEUgZGVjbGFyYXRpb25cIik7XG4gIFx0XHR9XG5cbiAgXHRcdGVsZW1lbnQuYSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oL14oLis/KT4vKTtcbiAgXHRcdHJldHVybiBlbGVtZW50O1xuICBcdH1cblxuICBcdGVsZW1lbnQudCA9IEVMRU1FTlQ7XG5cbiAgXHQvLyBlbGVtZW50IG5hbWVcbiAgXHRlbGVtZW50LmUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHRhZ05hbWVQYXR0ZXJuKTtcbiAgXHRpZiAoIWVsZW1lbnQuZSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gbmV4dCBjaGFyYWN0ZXIgbXVzdCBiZSB3aGl0ZXNwYWNlLCBjbG9zaW5nIHNvbGlkdXMgb3IgJz4nXG4gIFx0aWYgKCF2YWxpZFRhZ05hbWVGb2xsb3dlci50ZXN0KHBhcnNlci5uZXh0Q2hhcigpKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiSWxsZWdhbCB0YWcgbmFtZVwiKTtcbiAgXHR9XG5cbiAgXHRhZGRQcm94eUV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGRpcmVjdGl2ZSkge1xuICBcdFx0dmFyIGRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmUubiB8fCBkaXJlY3RpdmU7XG5cbiAgXHRcdGlmIChyZXNlcnZlZEV2ZW50TmFtZXMudGVzdChkaXJlY3RpdmVOYW1lKSkge1xuICBcdFx0XHRwYXJzZXIucG9zIC09IGRpcmVjdGl2ZU5hbWUubGVuZ3RoO1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoXCJDYW5ub3QgdXNlIHJlc2VydmVkIGV2ZW50IG5hbWVzIChjaGFuZ2UsIHJlc2V0LCB0ZWFyZG93biwgdXBkYXRlLCBjb25zdHJ1Y3QsIGNvbmZpZywgaW5pdCwgcmVuZGVyLCB1bnJlbmRlciwgZGV0YWNoLCBpbnNlcnQpXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRlbGVtZW50LnZbbmFtZV0gPSBkaXJlY3RpdmU7XG4gIFx0fTtcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIGRpcmVjdGl2ZXMgYW5kIGF0dHJpYnV0ZXNcbiAgXHR3aGlsZSAoYXR0cmlidXRlID0gY29udmVydGVyc19yZWFkTXVzdGFjaGUocGFyc2VyKSB8fCBlbGVtZW50X3JlYWRBdHRyaWJ1dGUocGFyc2VyKSkge1xuICBcdFx0Ly8gcmVndWxhciBhdHRyaWJ1dGVzXG4gIFx0XHRpZiAoYXR0cmlidXRlLm5hbWUpIHtcbiAgXHRcdFx0Ly8gaW50cm8sIG91dHJvLCBkZWNvcmF0b3JcbiAgXHRcdFx0aWYgKGRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmVzW2F0dHJpYnV0ZS5uYW1lXSkge1xuICBcdFx0XHRcdGVsZW1lbnRbZGlyZWN0aXZlTmFtZV0gPSBlbGVtZW50X3Byb2Nlc3NEaXJlY3RpdmUoYXR0cmlidXRlLnZhbHVlLCBwYXJzZXIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gb24tY2xpY2sgZXRjXG4gIFx0XHRcdGVsc2UgaWYgKG1hdGNoID0gcHJveHlFdmVudFBhdHRlcm4uZXhlYyhhdHRyaWJ1dGUubmFtZSkpIHtcbiAgXHRcdFx0XHRpZiAoIWVsZW1lbnQudikgZWxlbWVudC52ID0ge307XG4gIFx0XHRcdFx0ZGlyZWN0aXZlID0gZWxlbWVudF9wcm9jZXNzRGlyZWN0aXZlKGF0dHJpYnV0ZS52YWx1ZSwgcGFyc2VyKTtcbiAgXHRcdFx0XHRhZGRQcm94eUV2ZW50KG1hdGNoWzFdLCBkaXJlY3RpdmUpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGlmICghcGFyc2VyLnNhbml0aXplRXZlbnRBdHRyaWJ1dGVzIHx8ICFvblBhdHRlcm4udGVzdChhdHRyaWJ1dGUubmFtZSkpIHtcbiAgXHRcdFx0XHRcdGlmICghZWxlbWVudC5hKSBlbGVtZW50LmEgPSB7fTtcbiAgXHRcdFx0XHRcdGVsZW1lbnQuYVthdHRyaWJ1dGUubmFtZV0gPSBhdHRyaWJ1dGUudmFsdWUgfHwgKGF0dHJpYnV0ZS52YWx1ZSA9PT0gXCJcIiA/IFwiXCIgOiAwKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8ge3sjaWYgZm9vfX1jbGFzcz0nZm9vJ3t7L2lmfX1cbiAgXHRcdGVsc2Uge1xuICBcdFx0XHRpZiAoIWVsZW1lbnQubSkgZWxlbWVudC5tID0gW107XG4gIFx0XHRcdGVsZW1lbnQubS5wdXNoKGF0dHJpYnV0ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHR9XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBjbG9zaW5nIHNvbGlkdXNcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBzZWxmLWNsb3Npbmcgc29saWR1cz9cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiL1wiKSkge1xuICBcdFx0c2VsZkNsb3NpbmcgPSB0cnVlO1xuICBcdH1cblxuICBcdC8vIGNsb3NpbmcgYW5nbGUgYnJhY2tldFxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPlwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0dmFyIGxvd2VyQ2FzZU5hbWUgPSBlbGVtZW50LmUudG9Mb3dlckNhc2UoKTtcbiAgXHR2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gcGFyc2VyLnByZXNlcnZlV2hpdGVzcGFjZTtcblxuICBcdGlmICghc2VsZkNsb3NpbmcgJiYgIXZvaWRFbGVtZW50TmFtZXMudGVzdChlbGVtZW50LmUpKSB7XG4gIFx0XHRwYXJzZXIuZWxlbWVudFN0YWNrLnB1c2gobG93ZXJDYXNlTmFtZSk7XG5cbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSAtIGlmIHdlIG9wZW4gYSBzY3JpcHQgZWxlbWVudCwgZnVydGhlciB0YWdzIHNob3VsZFxuICBcdFx0Ly8gYmUgaWdub3JlZCB1bmxlc3MgdGhleSdyZSBhIGNsb3Npbmcgc2NyaXB0IGVsZW1lbnRcbiAgXHRcdGlmIChsb3dlckNhc2VOYW1lID09PSBcInNjcmlwdFwiIHx8IGxvd2VyQ2FzZU5hbWUgPT09IFwic3R5bGVcIikge1xuICBcdFx0XHRwYXJzZXIuaW5zaWRlID0gbG93ZXJDYXNlTmFtZTtcbiAgXHRcdH1cblxuICBcdFx0Y2hpbGRyZW4gPSBbXTtcbiAgXHRcdHBhcnRpYWxzID0gY3JlYXRlKG51bGwpO1xuXG4gIFx0XHRkbyB7XG4gIFx0XHRcdHBvcyA9IHBhcnNlci5wb3M7XG4gIFx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblxuICBcdFx0XHQvLyBpZiBmb3IgZXhhbXBsZSB3ZSdyZSBpbiBhbiA8bGk+IGVsZW1lbnQsIGFuZCB3ZSBzZWUgYW5vdGhlclxuICBcdFx0XHQvLyA8bGk+IHRhZywgY2xvc2UgdGhlIGZpcnN0IHNvIHRoZXkgYmVjb21lIHNpYmxpbmdzXG4gIFx0XHRcdGlmICghY2FuQ29udGFpbihsb3dlckNhc2VOYW1lLCByZW1haW5pbmcpKSB7XG4gIFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGNsb3NpbmcgdGFnXG4gIFx0XHRcdGVsc2UgaWYgKGNsb3NpbmdUYWcgPSBlbGVtZW50X3JlYWRDbG9zaW5nVGFnKHBhcnNlcikpIHtcbiAgXHRcdFx0XHRjbG9zZWQgPSB0cnVlO1xuXG4gIFx0XHRcdFx0dmFyIGNsb3NpbmdUYWdOYW1lID0gY2xvc2luZ1RhZy5lLnRvTG93ZXJDYXNlKCk7XG5cbiAgXHRcdFx0XHQvLyBpZiB0aGlzICppc24ndCogdGhlIGNsb3NpbmcgdGFnIGZvciB0aGUgY3VycmVudCBlbGVtZW50Li4uXG4gIFx0XHRcdFx0aWYgKGNsb3NpbmdUYWdOYW1lICE9PSBsb3dlckNhc2VOYW1lKSB7XG4gIFx0XHRcdFx0XHQvLyByZXdpbmQgcGFyc2VyXG4gIFx0XHRcdFx0XHRwYXJzZXIucG9zID0gcG9zO1xuXG4gIFx0XHRcdFx0XHQvLyBpZiBpdCBkb2Vzbid0IGNsb3NlIGEgcGFyZW50IHRhZywgZXJyb3JcbiAgXHRcdFx0XHRcdGlmICghIH5wYXJzZXIuZWxlbWVudFN0YWNrLmluZGV4T2YoY2xvc2luZ1RhZ05hbWUpKSB7XG4gIFx0XHRcdFx0XHRcdHZhciBlcnJvck1lc3NhZ2UgPSBcIlVuZXhwZWN0ZWQgY2xvc2luZyB0YWdcIjtcblxuICBcdFx0XHRcdFx0XHQvLyBhZGQgYWRkaXRpb25hbCBoZWxwIGZvciB2b2lkIGVsZW1lbnRzLCBzaW5jZSBjb21wb25lbnQgbmFtZXNcbiAgXHRcdFx0XHRcdFx0Ly8gbWlnaHQgY2xhc2ggd2l0aCB0aGVtXG4gIFx0XHRcdFx0XHRcdGlmICh2b2lkRWxlbWVudE5hbWVzLnRlc3QoY2xvc2luZ1RhZ05hbWUpKSB7XG4gIFx0XHRcdFx0XHRcdFx0ZXJyb3JNZXNzYWdlICs9IFwiICg8XCIgKyBjbG9zaW5nVGFnTmFtZSArIFwiPiBpcyBhIHZvaWQgZWxlbWVudCAtIGl0IGNhbm5vdCBjb250YWluIGNoaWxkcmVuKVwiO1xuICBcdFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKGVycm9yTWVzc2FnZSk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gaW1wbGljaXQgY2xvc2UgYnkgY2xvc2luZyBzZWN0aW9uIHRhZy4gVE9ETyBjbGVhbiB0aGlzIHVwXG4gIFx0XHRcdGVsc2UgaWYgKGNoaWxkID0gc2VjdGlvbl9yZWFkQ2xvc2luZyhwYXJzZXIsIHsgb3BlbjogcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1swXSwgY2xvc2U6IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMV0gfSkpIHtcbiAgXHRcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0XHRcdHBhcnNlci5wb3MgPSBwb3M7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0aWYgKGNoaWxkID0gcGFyc2VyLnJlYWQoUEFSVElBTF9SRUFERVJTKSkge1xuICBcdFx0XHRcdFx0aWYgKHBhcnRpYWxzW2NoaWxkLm5dKSB7XG4gIFx0XHRcdFx0XHRcdHBhcnNlci5wb3MgPSBwb3M7XG4gIFx0XHRcdFx0XHRcdHBhcnNlci5lcnJvcihcIkR1cGxpY2F0ZSBwYXJ0aWFsIGRlZmluaXRpb25cIik7XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdHV0aWxzX2NsZWFudXAoY2hpbGQuZiwgcGFyc2VyLnN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgIXByZXNlcnZlV2hpdGVzcGFjZSwgIXByZXNlcnZlV2hpdGVzcGFjZSk7XG5cbiAgXHRcdFx0XHRcdHBhcnRpYWxzW2NoaWxkLm5dID0gY2hpbGQuZjtcbiAgXHRcdFx0XHRcdGhhc1BhcnRpYWxzID0gdHJ1ZTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0aWYgKGNoaWxkID0gcGFyc2VyLnJlYWQoUkVBREVSUykpIHtcbiAgXHRcdFx0XHRcdFx0Y2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gIFx0XHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSB3aGlsZSAoIWNsb3NlZCk7XG5cbiAgXHRcdGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgXHRcdFx0ZWxlbWVudC5mID0gY2hpbGRyZW47XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChoYXNQYXJ0aWFscykge1xuICBcdFx0XHRlbGVtZW50LnAgPSBwYXJ0aWFscztcbiAgXHRcdH1cblxuICBcdFx0cGFyc2VyLmVsZW1lbnRTdGFjay5wb3AoKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuaW5zaWRlID0gbnVsbDtcblxuICBcdGlmIChwYXJzZXIuc2FuaXRpemVFbGVtZW50cyAmJiBwYXJzZXIuc2FuaXRpemVFbGVtZW50cy5pbmRleE9mKGxvd2VyQ2FzZU5hbWUpICE9PSAtMSkge1xuICBcdFx0cmV0dXJuIGV4Y2x1ZGU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5Db250YWluKG5hbWUsIHJlbWFpbmluZykge1xuICBcdHZhciBtYXRjaCwgZGlzYWxsb3dlZDtcblxuICBcdG1hdGNoID0gL148KFthLXpBLVpdW2EtekEtWjAtOV0qKS8uZXhlYyhyZW1haW5pbmcpO1xuICBcdGRpc2FsbG93ZWQgPSBkaXNhbGxvd2VkQ29udGVudHNbbmFtZV07XG5cbiAgXHRpZiAoIW1hdGNoIHx8ICFkaXNhbGxvd2VkKSB7XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gISB+ZGlzYWxsb3dlZC5pbmRleE9mKG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkpO1xuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZFRleHQgPSByZWFkVGV4dDtcbiAgZnVuY3Rpb24gcmVhZFRleHQocGFyc2VyKSB7XG4gIFx0dmFyIGluZGV4LCByZW1haW5pbmcsIGRpc2FsbG93ZWQsIGJhcnJpZXI7XG5cbiAgXHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cbiAgXHRiYXJyaWVyID0gcGFyc2VyLmluc2lkZSA/IFwiPC9cIiArIHBhcnNlci5pbnNpZGUgOiBcIjxcIjtcblxuICBcdGlmIChwYXJzZXIuaW5zaWRlICYmICFwYXJzZXIuaW50ZXJwb2xhdGVbcGFyc2VyLmluc2lkZV0pIHtcbiAgXHRcdGluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YoYmFycmllcik7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGRpc2FsbG93ZWQgPSBwYXJzZXIudGFncy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0cmV0dXJuIHQub3BlbjtcbiAgXHRcdH0pO1xuICBcdFx0ZGlzYWxsb3dlZCA9IGRpc2FsbG93ZWQuY29uY2F0KHBhcnNlci50YWdzLm1hcChmdW5jdGlvbiAodCkge1xuICBcdFx0XHRyZXR1cm4gXCJcXFxcXCIgKyB0Lm9wZW47XG4gIFx0XHR9KSk7XG5cbiAgXHRcdC8vIGh0dHA6Ly9kZXZlbG9wZXJzLndoYXR3Zy5vcmcvc3ludGF4Lmh0bWwjc3ludGF4LWF0dHJpYnV0ZXNcbiAgXHRcdGlmIChwYXJzZXIuaW5BdHRyaWJ1dGUgPT09IHRydWUpIHtcbiAgXHRcdFx0Ly8gd2UncmUgaW5zaWRlIGFuIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZVxuICBcdFx0XHRkaXNhbGxvd2VkLnB1c2goXCJcXFwiXCIsIFwiJ1wiLCBcIj1cIiwgXCI8XCIsIFwiPlwiLCBcImBcIik7XG4gIFx0XHR9IGVsc2UgaWYgKHBhcnNlci5pbkF0dHJpYnV0ZSkge1xuICBcdFx0XHQvLyBxdW90ZWQgYXR0cmlidXRlIHZhbHVlXG4gIFx0XHRcdGRpc2FsbG93ZWQucHVzaChwYXJzZXIuaW5BdHRyaWJ1dGUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZGlzYWxsb3dlZC5wdXNoKGJhcnJpZXIpO1xuICBcdFx0fVxuXG4gIFx0XHRpbmRleCA9IGdldExvd2VzdEluZGV4KHJlbWFpbmluZywgZGlzYWxsb3dlZCk7XG4gIFx0fVxuXG4gIFx0aWYgKCFpbmRleCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0aW5kZXggPSByZW1haW5pbmcubGVuZ3RoO1xuICBcdH1cblxuICBcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG5cbiAgXHRyZXR1cm4gcGFyc2VyLmluc2lkZSA/IHJlbWFpbmluZy5zdWJzdHIoMCwgaW5kZXgpIDogZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyhyZW1haW5pbmcuc3Vic3RyKDAsIGluZGV4KSk7XG4gIH1cblxuICB2YXIgdXRpbHNfZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICB2YXIgdXRpbHNfZXNjYXBlUmVnRXhwX19wYXR0ZXJuID0gL1stL1xcXFxeJCorPy4oKXxbXFxde31dL2c7XG4gIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHIpIHtcbiAgXHRyZXR1cm4gc3RyLnJlcGxhY2UodXRpbHNfZXNjYXBlUmVnRXhwX19wYXR0ZXJuLCBcIlxcXFwkJlwiKTtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRQYXJ0aWFsRGVmaW5pdGlvbkNvbW1lbnQgPSByZWFkUGFydGlhbERlZmluaXRpb25Db21tZW50O1xuXG4gIHZhciBzdGFydFBhdHRlcm4gPSAvXjwhLS1cXHMqLyxcbiAgICAgIG5hbWVQYXR0ZXJuID0gL3MqPlxccyooW2EtekEtWl8kXVstYS16QS1aXyQwLTldKilcXHMqLyxcbiAgICAgIGZpbmlzaFBhdHRlcm4gPSAvXFxzKi0tPi8sXG4gICAgICBjaGlsZDtcblxuICBmdW5jdGlvbiByZWFkUGFydGlhbERlZmluaXRpb25Db21tZW50KHBhcnNlcikge1xuICBcdHZhciBmaXJzdFBvcyA9IHBhcnNlci5wb3MsXG4gIFx0ICAgIG9wZW4gPSBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzBdLFxuICBcdCAgICBjbG9zZSA9IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMV0sXG4gIFx0ICAgIGNvbnRlbnQgPSB1bmRlZmluZWQsXG4gIFx0ICAgIGNsb3NlZCA9IHVuZGVmaW5lZDtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoUGF0dGVybihzdGFydFBhdHRlcm4pIHx8ICFwYXJzZXIubWF0Y2hTdHJpbmcob3BlbikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBmaXJzdFBvcztcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHZhciBuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybihuYW1lUGF0dGVybik7XG5cbiAgXHR3YXJuT25jZUlmRGVidWcoXCJJbmxpbmUgcGFydGlhbCBjb21tZW50cyBhcmUgZGVwcmVjYXRlZC5cXG5Vc2UgdGhpcy4uLlxcbiAge3sjcGFydGlhbCBcIiArIG5hbWUgKyBcIn19IC4uLiB7ey9wYXJ0aWFsfX1cXG5cXG4uLi5pbnN0ZWFkIG9mIHRoaXM6XFxuICA8IS0tIHt7PlwiICsgbmFtZSArIFwifX0gLS0+IC4uLiA8IS0tIHt7L1wiICsgbmFtZSArIFwifX0gLS0+J1wiKTtcblxuICBcdC8vIG1ha2Ugc3VyZSB0aGUgcmVzdCBvZiB0aGUgY29tbWVudCBpcyBpbiB0aGUgY29ycmVjdCBwbGFjZVxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKGNsb3NlKSB8fCAhcGFyc2VyLm1hdGNoUGF0dGVybihmaW5pc2hQYXR0ZXJuKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IGZpcnN0UG9zO1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Y29udGVudCA9IFtdO1xuXG4gIFx0dmFyIGVuZFBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXjwhLS1cXFxccypcIiArIHV0aWxzX2VzY2FwZVJlZ0V4cChvcGVuKSArIFwiXFxcXHMqXFxcXC9cXFxccypcIiArIG5hbWUgKyBcIlxcXFxzKlwiICsgdXRpbHNfZXNjYXBlUmVnRXhwKGNsb3NlKSArIFwiXFxcXHMqLS0+XCIpO1xuXG4gIFx0ZG8ge1xuICBcdFx0aWYgKHBhcnNlci5tYXRjaFBhdHRlcm4oZW5kUGF0dGVybikpIHtcbiAgXHRcdFx0Y2xvc2VkID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNoaWxkID0gcGFyc2VyLnJlYWQoUkVBREVSUyk7XG4gIFx0XHRcdGlmICghY2hpbGQpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJleHBlY3RlZCBjbG9zaW5nIGNvbW1lbnQgKCc8IS0tIFwiICsgb3BlbiArIFwiL1wiICsgbmFtZSArIFwiXCIgKyBjbG9zZSArIFwiIC0tPicpXCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y29udGVudC5wdXNoKGNoaWxkKTtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlICghY2xvc2VkKTtcblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBJTkxJTkVfUEFSVElBTCxcbiAgXHRcdGY6IGNvbnRlbnQsXG4gIFx0XHRuOiBuYW1lXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRQYXJ0aWFsRGVmaW5pdGlvblNlY3Rpb24gPSByZWFkUGFydGlhbERlZmluaXRpb25TZWN0aW9uO1xuICB2YXIgcGFydGlhbERlZmluaXRpb25TZWN0aW9uUGF0dGVybiA9IC9eI1xccypwYXJ0aWFsXFxzKy87XG4gIGZ1bmN0aW9uIHJlYWRQYXJ0aWFsRGVmaW5pdGlvblNlY3Rpb24ocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBuYW1lLCBjb250ZW50LCBjaGlsZCwgY2xvc2VkO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0dmFyIGRlbGltaXRlcnMgPSBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoZGVsaW1pdGVyc1swXSkpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoUGF0dGVybihwYXJ0aWFsRGVmaW5pdGlvblNlY3Rpb25QYXR0ZXJuKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0bmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oL15bYS16QS1aXyRdW2EtekEtWl8kMC05XFwtXSovKTtcblxuICBcdGlmICghbmFtZSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiZXhwZWN0ZWQgbGVnYWwgcGFydGlhbCBuYW1lXCIpO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKGRlbGltaXRlcnNbMV0pKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyBkZWxpbWl0ZXJzWzFdICsgXCInXCIpO1xuICBcdH1cblxuICBcdGNvbnRlbnQgPSBbXTtcblxuICBcdGRvIHtcbiAgXHRcdC8vIFRPRE8gY2xlYW4gdGhpcyB1cFxuICBcdFx0aWYgKGNoaWxkID0gc2VjdGlvbl9yZWFkQ2xvc2luZyhwYXJzZXIsIHsgb3BlbjogcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1swXSwgY2xvc2U6IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMV0gfSkpIHtcbiAgXHRcdFx0aWYgKCFjaGlsZC5yID09PSBcInBhcnRpYWxcIikge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIFwiICsgZGVsaW1pdGVyc1swXSArIFwiL3BhcnRpYWxcIiArIGRlbGltaXRlcnNbMV0pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y2xvc2VkID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNoaWxkID0gcGFyc2VyLnJlYWQoUkVBREVSUyk7XG5cbiAgXHRcdFx0aWYgKCFjaGlsZCkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIFwiICsgZGVsaW1pdGVyc1swXSArIFwiL3BhcnRpYWxcIiArIGRlbGltaXRlcnNbMV0pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Y29udGVudC5wdXNoKGNoaWxkKTtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlICghY2xvc2VkKTtcblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBJTkxJTkVfUEFSVElBTCxcbiAgXHRcdG46IG5hbWUsXG4gIFx0XHRmOiBjb250ZW50XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRUZW1wbGF0ZSA9IHJlYWRUZW1wbGF0ZTtcbiAgZnVuY3Rpb24gcmVhZFRlbXBsYXRlKHBhcnNlcikge1xuICBcdHZhciBmcmFnbWVudCA9IFtdO1xuICBcdHZhciBwYXJ0aWFscyA9IGNyZWF0ZShudWxsKTtcbiAgXHR2YXIgaGFzUGFydGlhbHMgPSBmYWxzZTtcblxuICBcdHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBwYXJzZXIucHJlc2VydmVXaGl0ZXNwYWNlO1xuXG4gIFx0d2hpbGUgKHBhcnNlci5wb3MgPCBwYXJzZXIuc3RyLmxlbmd0aCkge1xuICBcdFx0dmFyIHBvcyA9IHBhcnNlci5wb3MsXG4gIFx0XHQgICAgaXRlbSA9IHVuZGVmaW5lZCxcbiAgXHRcdCAgICBwYXJ0aWFsID0gdW5kZWZpbmVkO1xuXG4gIFx0XHRpZiAocGFydGlhbCA9IHBhcnNlci5yZWFkKFBBUlRJQUxfUkVBREVSUykpIHtcbiAgXHRcdFx0aWYgKHBhcnRpYWxzW3BhcnRpYWwubl0pIHtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gcG9zO1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcIkR1cGxpY2F0ZWQgcGFydGlhbCBkZWZpbml0aW9uXCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dXRpbHNfY2xlYW51cChwYXJ0aWFsLmYsIHBhcnNlci5zdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsICFwcmVzZXJ2ZVdoaXRlc3BhY2UsICFwcmVzZXJ2ZVdoaXRlc3BhY2UpO1xuXG4gIFx0XHRcdHBhcnRpYWxzW3BhcnRpYWwubl0gPSBwYXJ0aWFsLmY7XG4gIFx0XHRcdGhhc1BhcnRpYWxzID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSBpZiAoaXRlbSA9IHBhcnNlci5yZWFkKFJFQURFUlMpKSB7XG4gIFx0XHRcdGZyYWdtZW50LnB1c2goaXRlbSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoXCJVbmV4cGVjdGVkIHRlbXBsYXRlIGNvbnRlbnRcIik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0dmFyIHJlc3VsdCA9IHtcbiAgXHRcdHY6IFRFTVBMQVRFX1ZFUlNJT04sXG4gIFx0XHR0OiBmcmFnbWVudFxuICBcdH07XG5cbiAgXHRpZiAoaGFzUGFydGlhbHMpIHtcbiAgXHRcdHJlc3VsdC5wID0gcGFydGlhbHM7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBfcGFyc2UgPSBwYXJzZTtcblxuICB2YXIgU1RBTkRBUkRfUkVBREVSUyA9IFttdXN0YWNoZV9yZWFkUGFydGlhbCwgbXVzdGFjaGVfcmVhZFVuZXNjYXBlZCwgbXVzdGFjaGVfcmVhZFNlY3Rpb24sIG11c3RhY2hlX3JlYWRZaWVsZGVyLCBtdXN0YWNoZV9yZWFkSW50ZXJwb2xhdG9yLCByZWFkTXVzdGFjaGVDb21tZW50XTtcbiAgdmFyIFRSSVBMRV9SRUFERVJTID0gW211c3RhY2hlX3JlYWRUcmlwbGVdO1xuICB2YXIgU1RBVElDX1JFQURFUlMgPSBbbXVzdGFjaGVfcmVhZFVuZXNjYXBlZCwgbXVzdGFjaGVfcmVhZFNlY3Rpb24sIG11c3RhY2hlX3JlYWRJbnRlcnBvbGF0b3JdOyAvLyBUT0RPIGRvZXMgaXQgbWFrZSBzZW5zZSB0byBoYXZlIGEgc3RhdGljIHNlY3Rpb24/XG5cbiAgdmFyIFN0YW5kYXJkUGFyc2VyID0gdW5kZWZpbmVkO1xuICBmdW5jdGlvbiBwYXJzZSh0ZW1wbGF0ZSwgb3B0aW9ucykge1xuICBcdHJldHVybiBuZXcgU3RhbmRhcmRQYXJzZXIodGVtcGxhdGUsIG9wdGlvbnMgfHwge30pLnJlc3VsdDtcbiAgfVxuXG4gIHZhciBSRUFERVJTID0gW2NvbnZlcnRlcnNfcmVhZE11c3RhY2hlLCBjb252ZXJ0ZXJzX3JlYWRIdG1sQ29tbWVudCwgY29udmVydGVyc19yZWFkRWxlbWVudCwgY29udmVydGVyc19yZWFkVGV4dF07XG4gIHZhciBQQVJUSUFMX1JFQURFUlMgPSBbY29udmVydGVyc19yZWFkUGFydGlhbERlZmluaXRpb25Db21tZW50LCBjb252ZXJ0ZXJzX3JlYWRQYXJ0aWFsRGVmaW5pdGlvblNlY3Rpb25dO1xuXG4gIFN0YW5kYXJkUGFyc2VyID0gcGFyc2VfUGFyc2VyLmV4dGVuZCh7XG4gIFx0aW5pdDogZnVuY3Rpb24gKHN0ciwgb3B0aW9ucykge1xuICBcdFx0dmFyIHRyaXBsZURlbGltaXRlcnMgPSBvcHRpb25zLnRyaXBsZURlbGltaXRlcnMgfHwgW1wie3t7XCIsIFwifX19XCJdLFxuICBcdFx0ICAgIHN0YXRpY0RlbGltaXRlcnMgPSBvcHRpb25zLnN0YXRpY0RlbGltaXRlcnMgfHwgW1wiW1tcIiwgXCJdXVwiXSxcbiAgXHRcdCAgICBzdGF0aWNUcmlwbGVEZWxpbWl0ZXJzID0gb3B0aW9ucy5zdGF0aWNUcmlwbGVEZWxpbWl0ZXJzIHx8IFtcIltbW1wiLCBcIl1dXVwiXTtcblxuICBcdFx0dGhpcy5zdGFuZGFyZERlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnMgfHwgW1wie3tcIiwgXCJ9fVwiXTtcblxuICBcdFx0dGhpcy50YWdzID0gW3sgaXNTdGF0aWM6IGZhbHNlLCBpc1RyaXBsZTogZmFsc2UsIG9wZW46IHRoaXMuc3RhbmRhcmREZWxpbWl0ZXJzWzBdLCBjbG9zZTogdGhpcy5zdGFuZGFyZERlbGltaXRlcnNbMV0sIHJlYWRlcnM6IFNUQU5EQVJEX1JFQURFUlMgfSwgeyBpc1N0YXRpYzogZmFsc2UsIGlzVHJpcGxlOiB0cnVlLCBvcGVuOiB0cmlwbGVEZWxpbWl0ZXJzWzBdLCBjbG9zZTogdHJpcGxlRGVsaW1pdGVyc1sxXSwgcmVhZGVyczogVFJJUExFX1JFQURFUlMgfSwgeyBpc1N0YXRpYzogdHJ1ZSwgaXNUcmlwbGU6IGZhbHNlLCBvcGVuOiBzdGF0aWNEZWxpbWl0ZXJzWzBdLCBjbG9zZTogc3RhdGljRGVsaW1pdGVyc1sxXSwgcmVhZGVyczogU1RBVElDX1JFQURFUlMgfSwgeyBpc1N0YXRpYzogdHJ1ZSwgaXNUcmlwbGU6IHRydWUsIG9wZW46IHN0YXRpY1RyaXBsZURlbGltaXRlcnNbMF0sIGNsb3NlOiBzdGF0aWNUcmlwbGVEZWxpbWl0ZXJzWzFdLCByZWFkZXJzOiBUUklQTEVfUkVBREVSUyB9XTtcblxuICBcdFx0dGhpcy5zb3J0TXVzdGFjaGVUYWdzKCk7XG5cbiAgXHRcdHRoaXMuc2VjdGlvbkRlcHRoID0gMDtcbiAgXHRcdHRoaXMuZWxlbWVudFN0YWNrID0gW107XG5cbiAgXHRcdHRoaXMuaW50ZXJwb2xhdGUgPSB7XG4gIFx0XHRcdHNjcmlwdDogIW9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgb3B0aW9ucy5pbnRlcnBvbGF0ZS5zY3JpcHQgIT09IGZhbHNlLFxuICBcdFx0XHRzdHlsZTogIW9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgb3B0aW9ucy5pbnRlcnBvbGF0ZS5zdHlsZSAhPT0gZmFsc2VcbiAgXHRcdH07XG5cbiAgXHRcdGlmIChvcHRpb25zLnNhbml0aXplID09PSB0cnVlKSB7XG4gIFx0XHRcdG9wdGlvbnMuc2FuaXRpemUgPSB7XG4gIFx0XHRcdFx0Ly8gYmxhY2tsaXN0IGZyb20gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtY2FqYS9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2NhamEvbGFuZy9odG1sL2h0bWw0LWVsZW1lbnRzLXdoaXRlbGlzdC5qc29uXG4gIFx0XHRcdFx0ZWxlbWVudHM6IFwiYXBwbGV0IGJhc2UgYmFzZWZvbnQgYm9keSBmcmFtZSBmcmFtZXNldCBoZWFkIGh0bWwgaXNpbmRleCBsaW5rIG1ldGEgbm9mcmFtZXMgbm9zY3JpcHQgb2JqZWN0IHBhcmFtIHNjcmlwdCBzdHlsZSB0aXRsZVwiLnNwbGl0KFwiIFwiKSxcbiAgXHRcdFx0XHRldmVudEF0dHJpYnV0ZXM6IHRydWVcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5zdHJpcENvbW1lbnRzID0gb3B0aW9ucy5zdHJpcENvbW1lbnRzICE9PSBmYWxzZTtcbiAgXHRcdHRoaXMucHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2U7XG4gIFx0XHR0aGlzLnNhbml0aXplRWxlbWVudHMgPSBvcHRpb25zLnNhbml0aXplICYmIG9wdGlvbnMuc2FuaXRpemUuZWxlbWVudHM7XG4gIFx0XHR0aGlzLnNhbml0aXplRXZlbnRBdHRyaWJ1dGVzID0gb3B0aW9ucy5zYW5pdGl6ZSAmJiBvcHRpb25zLnNhbml0aXplLmV2ZW50QXR0cmlidXRlcztcbiAgXHRcdHRoaXMuaW5jbHVkZUxpbmVQb3NpdGlvbnMgPSBvcHRpb25zLmluY2x1ZGVMaW5lUG9zaXRpb25zO1xuICBcdH0sXG5cbiAgXHRwb3N0UHJvY2VzczogZnVuY3Rpb24gKHJlc3VsdCkge1xuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gZW1wdHkgc3RyaW5nXG4gIFx0XHRpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgXHRcdFx0cmV0dXJuIHsgdDogW10sIHY6IFRFTVBMQVRFX1ZFUlNJT04gfTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuc2VjdGlvbkRlcHRoID4gMCkge1xuICBcdFx0XHR0aGlzLmVycm9yKFwiQSBzZWN0aW9uIHdhcyBsZWZ0IG9wZW5cIik7XG4gIFx0XHR9XG5cbiAgXHRcdHV0aWxzX2NsZWFudXAocmVzdWx0WzBdLnQsIHRoaXMuc3RyaXBDb21tZW50cywgdGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2UsICF0aGlzLnByZXNlcnZlV2hpdGVzcGFjZSwgIXRoaXMucHJlc2VydmVXaGl0ZXNwYWNlKTtcblxuICBcdFx0cmV0dXJuIHJlc3VsdFswXTtcbiAgXHR9LFxuXG4gIFx0Y29udmVydGVyczogW2NvbnZlcnRlcnNfcmVhZFRlbXBsYXRlXSxcblxuICBcdHNvcnRNdXN0YWNoZVRhZ3M6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFNvcnQgaW4gb3JkZXIgb2YgZGVzY2VuZGluZyBvcGVuaW5nIGRlbGltaXRlciBsZW5ndGggKGxvbmdlciBmaXJzdCksXG4gIFx0XHQvLyB0byBwcm90ZWN0IGFnYWluc3Qgb3BlbmluZyBkZWxpbWl0ZXJzIGJlaW5nIHN1YnN0cmluZ3Mgb2YgZWFjaCBvdGhlclxuICBcdFx0dGhpcy50YWdzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgXHRcdFx0cmV0dXJuIGIub3Blbi5sZW5ndGggLSBhLm9wZW4ubGVuZ3RoO1xuICBcdFx0fSk7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgcGFyc2VPcHRpb25zID0gW1wicHJlc2VydmVXaGl0ZXNwYWNlXCIsIFwic2FuaXRpemVcIiwgXCJzdHJpcENvbW1lbnRzXCIsIFwiZGVsaW1pdGVyc1wiLCBcInRyaXBsZURlbGltaXRlcnNcIiwgXCJpbnRlcnBvbGF0ZVwiXTtcblxuICB2YXIgcGFyc2VyID0ge1xuICBcdGZyb21JZDogZnJvbUlkLCBpc0hhc2hlZElkOiBpc0hhc2hlZElkLCBpc1BhcnNlZDogaXNQYXJzZWQsIGdldFBhcnNlT3B0aW9uczogZ2V0UGFyc2VPcHRpb25zLCBjcmVhdGVIZWxwZXI6IHRlbXBsYXRlX3BhcnNlcl9fY3JlYXRlSGVscGVyLFxuICBcdHBhcnNlOiBkb1BhcnNlXG4gIH07XG5cbiAgZnVuY3Rpb24gdGVtcGxhdGVfcGFyc2VyX19jcmVhdGVIZWxwZXIocGFyc2VPcHRpb25zKSB7XG4gIFx0dmFyIGhlbHBlciA9IGNyZWF0ZShwYXJzZXIpO1xuICBcdGhlbHBlci5wYXJzZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgb3B0aW9ucykge1xuICBcdFx0cmV0dXJuIGRvUGFyc2UodGVtcGxhdGUsIG9wdGlvbnMgfHwgcGFyc2VPcHRpb25zKTtcbiAgXHR9O1xuICBcdHJldHVybiBoZWxwZXI7XG4gIH1cblxuICBmdW5jdGlvbiBkb1BhcnNlKHRlbXBsYXRlLCBwYXJzZU9wdGlvbnMpIHtcbiAgXHRpZiAoIV9wYXJzZSkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBSYWN0aXZlLnBhcnNlIC0gY2Fubm90IHBhcnNlIHRlbXBsYXRlLiBFaXRoZXIgcHJlcGFyc2Ugb3IgdXNlIHRoZSB2ZXJzaW9uIHRoYXQgaW5jbHVkZXMgdGhlIHBhcnNlclwiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gX3BhcnNlKHRlbXBsYXRlLCBwYXJzZU9wdGlvbnMgfHwgdGhpcy5vcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21JZChpZCwgb3B0aW9ucykge1xuICBcdHZhciB0ZW1wbGF0ZTtcblxuICBcdGlmICghaXNDbGllbnQpIHtcbiAgXHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9UaHJvdykge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmV0cmlldmUgdGVtcGxhdGUgI1wiICsgaWQgKyBcIiBhcyBSYWN0aXZlIGlzIG5vdCBydW5uaW5nIGluIGEgYnJvd3Nlci5cIik7XG4gIFx0fVxuXG4gIFx0aWYgKGlzSGFzaGVkSWQoaWQpKSB7XG4gIFx0XHRpZCA9IGlkLnN1YnN0cmluZygxKTtcbiAgXHR9XG5cbiAgXHRpZiAoISh0ZW1wbGF0ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSkpIHtcbiAgXHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9UaHJvdykge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCB0ZW1wbGF0ZSBlbGVtZW50IHdpdGggaWQgI1wiICsgaWQpO1xuICBcdH1cblxuICBcdGlmICh0ZW1wbGF0ZS50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09IFwiU0NSSVBUXCIpIHtcbiAgXHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9UaHJvdykge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUZW1wbGF0ZSBlbGVtZW50IHdpdGggaWQgI1wiICsgaWQgKyBcIiwgbXVzdCBiZSBhIDxzY3JpcHQ+IGVsZW1lbnRcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIFwidGV4dENvbnRlbnRcIiBpbiB0ZW1wbGF0ZSA/IHRlbXBsYXRlLnRleHRDb250ZW50IDogdGVtcGxhdGUuaW5uZXJIVE1MO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNIYXNoZWRJZChpZCkge1xuICBcdHJldHVybiBpZCAmJiBpZFswXSA9PT0gXCIjXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhcnNlZCh0ZW1wbGF0ZSkge1xuICBcdHJldHVybiAhKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXJzZU9wdGlvbnMocmFjdGl2ZSkge1xuICBcdC8vIENvdWxkIGJlIFJhY3RpdmUgb3IgYSBDb21wb25lbnRcbiAgXHRpZiAocmFjdGl2ZS5kZWZhdWx0cykge1xuICBcdFx0cmFjdGl2ZSA9IHJhY3RpdmUuZGVmYXVsdHM7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHBhcnNlT3B0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gIFx0XHR2YWxba2V5XSA9IHJhY3RpdmVba2V5XTtcbiAgXHRcdHJldHVybiB2YWw7XG4gIFx0fSwge30pO1xuICB9XG5cbiAgdmFyIHRlbXBsYXRlX3BhcnNlciA9IHBhcnNlcjtcblxuICB2YXIgdGVtcGxhdGVDb25maWd1cmF0b3IgPSB7XG4gIFx0bmFtZTogXCJ0ZW1wbGF0ZVwiLFxuXG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoUGFyZW50LCBwcm90bywgb3B0aW9ucykge1xuICBcdFx0dmFyIHRlbXBsYXRlO1xuXG4gIFx0XHQvLyBvbmx5IGFzc2lnbiBpZiBleGlzdHNcbiAgXHRcdGlmIChcInRlbXBsYXRlXCIgaW4gb3B0aW9ucykge1xuICBcdFx0XHR0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdFx0cHJvdG8udGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRwcm90by50ZW1wbGF0ZSA9IHBhcnNlSWZTdHJpbmcodGVtcGxhdGUsIHByb3RvKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiBpbml0KFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucykge1xuICBcdFx0dmFyIHRlbXBsYXRlLCBmbjtcblxuICBcdFx0Ly8gVE9ETyBiZWNhdXNlIG9mIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHdlIG1pZ2h0IGp1c3QgYmUgYWJsZSB0byB1c2VcbiAgXHRcdC8vIHJhY3RpdmUudGVtcGxhdGUsIGFuZCBub3QgYm90aGVyIHBhc3NpbmcgdGhyb3VnaCB0aGUgUGFyZW50IG9iamVjdC5cbiAgXHRcdC8vIEF0IHByZXNlbnQgdGhhdCBicmVha3MgdGhlIHRlc3QgbW9ja3MnIGV4cGVjdGF0aW9uc1xuICBcdFx0dGVtcGxhdGUgPSBcInRlbXBsYXRlXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMudGVtcGxhdGUgOiBQYXJlbnQucHJvdG90eXBlLnRlbXBsYXRlO1xuXG4gIFx0XHRpZiAodHlwZW9mIHRlbXBsYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0Zm4gPSB0ZW1wbGF0ZTtcbiAgXHRcdFx0dGVtcGxhdGUgPSBnZXREeW5hbWljVGVtcGxhdGUocmFjdGl2ZSwgZm4pO1xuXG4gIFx0XHRcdHJhY3RpdmUuX2NvbmZpZy50ZW1wbGF0ZSA9IHtcbiAgXHRcdFx0XHRmbjogZm4sXG4gIFx0XHRcdFx0cmVzdWx0OiB0ZW1wbGF0ZVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHR0ZW1wbGF0ZSA9IHBhcnNlSWZTdHJpbmcodGVtcGxhdGUsIHJhY3RpdmUpO1xuXG4gIFx0XHQvLyBUT0RPIHRoZSBuYW1pbmcgb2YgdGhpcyBpcyBjb25mdXNpbmcgLSByYWN0aXZlLnRlbXBsYXRlIHJlZmVycyB0byBbLi4uXSxcbiAgXHRcdC8vIGJ1dCBDb21wb25lbnQucHJvdG90eXBlLnRlbXBsYXRlIHJlZmVycyB0byB7djoxLHQ6W10scDpbXX0uLi5cbiAgXHRcdC8vIGl0J3MgdW5uZWNlc3NhcnksIGJlY2F1c2UgdGhlIGRldmVsb3BlciBuZXZlciBuZWVkcyB0byBhY2Nlc3NcbiAgXHRcdC8vIHJhY3RpdmUudGVtcGxhdGVcbiAgXHRcdHJhY3RpdmUudGVtcGxhdGUgPSB0ZW1wbGF0ZS50O1xuXG4gIFx0XHRpZiAodGVtcGxhdGUucCkge1xuICBcdFx0XHRleHRlbmRQYXJ0aWFscyhyYWN0aXZlLnBhcnRpYWxzLCB0ZW1wbGF0ZS5wKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVzZXQ6IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG4gIFx0XHR2YXIgcmVzdWx0ID0gcmVzZXRWYWx1ZShyYWN0aXZlKSxcbiAgXHRcdCAgICBwYXJzZWQ7XG5cbiAgXHRcdGlmIChyZXN1bHQpIHtcbiAgXHRcdFx0cGFyc2VkID0gcGFyc2VJZlN0cmluZyhyZXN1bHQsIHJhY3RpdmUpO1xuXG4gIFx0XHRcdHJhY3RpdmUudGVtcGxhdGUgPSBwYXJzZWQudDtcbiAgXHRcdFx0ZXh0ZW5kUGFydGlhbHMocmFjdGl2ZS5wYXJ0aWFscywgcGFyc2VkLnAsIHRydWUpO1xuXG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiByZXNldFZhbHVlKHJhY3RpdmUpIHtcbiAgXHR2YXIgaW5pdGlhbCA9IHJhY3RpdmUuX2NvbmZpZy50ZW1wbGF0ZSxcbiAgXHQgICAgcmVzdWx0O1xuXG4gIFx0Ly8gSWYgdGhpcyBpc24ndCBhIGR5bmFtaWMgdGVtcGxhdGUsIHRoZXJlJ3Mgbm90aGluZyB0byBkb1xuICBcdGlmICghaW5pdGlhbCB8fCAhaW5pdGlhbC5mbikge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHJlc3VsdCA9IGdldER5bmFtaWNUZW1wbGF0ZShyYWN0aXZlLCBpbml0aWFsLmZuKTtcblxuICBcdC8vIFRPRE8gZGVlcCBlcXVhbGl0eSBjaGVjayB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlLXJlbmRlcmluZ1xuICBcdC8vIGluIHRoZSBjYXNlIG9mIGFscmVhZHktcGFyc2VkIHRlbXBsYXRlc1xuICBcdGlmIChyZXN1bHQgIT09IGluaXRpYWwucmVzdWx0KSB7XG4gIFx0XHRpbml0aWFsLnJlc3VsdCA9IHJlc3VsdDtcbiAgXHRcdHJlc3VsdCA9IHBhcnNlSWZTdHJpbmcocmVzdWx0LCByYWN0aXZlKTtcbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RHluYW1pY1RlbXBsYXRlKHJhY3RpdmUsIGZuKSB7XG4gIFx0dmFyIGhlbHBlciA9IHRlbXBsYXRlX3RlbXBsYXRlX19jcmVhdGVIZWxwZXIodGVtcGxhdGVfcGFyc2VyLmdldFBhcnNlT3B0aW9ucyhyYWN0aXZlKSk7XG4gIFx0cmV0dXJuIGZuLmNhbGwocmFjdGl2ZSwgaGVscGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlbXBsYXRlX3RlbXBsYXRlX19jcmVhdGVIZWxwZXIocGFyc2VPcHRpb25zKSB7XG4gIFx0dmFyIGhlbHBlciA9IGNyZWF0ZSh0ZW1wbGF0ZV9wYXJzZXIpO1xuICBcdGhlbHBlci5wYXJzZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgb3B0aW9ucykge1xuICBcdFx0cmV0dXJuIHRlbXBsYXRlX3BhcnNlci5wYXJzZSh0ZW1wbGF0ZSwgb3B0aW9ucyB8fCBwYXJzZU9wdGlvbnMpO1xuICBcdH07XG4gIFx0cmV0dXJuIGhlbHBlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSWZTdHJpbmcodGVtcGxhdGUsIHJhY3RpdmUpIHtcbiAgXHRpZiAodHlwZW9mIHRlbXBsYXRlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHQvLyBJRCBvZiBhbiBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHRlbXBsYXRlP1xuICBcdFx0aWYgKHRlbXBsYXRlWzBdID09PSBcIiNcIikge1xuICBcdFx0XHR0ZW1wbGF0ZSA9IHRlbXBsYXRlX3BhcnNlci5mcm9tSWQodGVtcGxhdGUpO1xuICBcdFx0fVxuXG4gIFx0XHR0ZW1wbGF0ZSA9IF9wYXJzZSh0ZW1wbGF0ZSwgdGVtcGxhdGVfcGFyc2VyLmdldFBhcnNlT3B0aW9ucyhyYWN0aXZlKSk7XG4gIFx0fVxuXG4gIFx0Ly8gQ2hlY2sgdGhhdCB0aGUgdGVtcGxhdGUgZXZlbiBleGlzdHNcbiAgXHRlbHNlIGlmICh0ZW1wbGF0ZSA9PSB1bmRlZmluZWQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIlRoZSB0ZW1wbGF0ZSBjYW5ub3QgYmUgXCIgKyB0ZW1wbGF0ZSArIFwiLlwiKTtcbiAgXHR9XG5cbiAgXHQvLyBDaGVjayB0aGUgcGFyc2VkIHRlbXBsYXRlIGhhcyBhIHZlcnNpb24gYXQgYWxsXG4gIFx0ZWxzZSBpZiAodHlwZW9mIHRlbXBsYXRlLnYgIT09IFwibnVtYmVyXCIpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIlRoZSB0ZW1wbGF0ZSBwYXJzZXIgd2FzIHBhc3NlZCBhIG5vbi1zdHJpbmcgdGVtcGxhdGUsIGJ1dCB0aGUgdGVtcGxhdGUgZG9lc24ndCBoYXZlIGEgdmVyc2lvbi4gIE1ha2Ugc3VyZSB5b3UncmUgcGFzc2luZyBpbiB0aGUgdGVtcGxhdGUgeW91IHRoaW5rIHlvdSBhcmUuXCIpO1xuICBcdH1cblxuICBcdC8vIENoZWNrIHdlJ3JlIHVzaW5nIHRoZSBjb3JyZWN0IHZlcnNpb25cbiAgXHRlbHNlIGlmICh0ZW1wbGF0ZS52ICE9PSBURU1QTEFURV9WRVJTSU9OKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIHRlbXBsYXRlIHZlcnNpb24gKGV4cGVjdGVkIFwiICsgVEVNUExBVEVfVkVSU0lPTiArIFwiLCBnb3QgXCIgKyB0ZW1wbGF0ZS52ICsgXCIpIFBsZWFzZSBlbnN1cmUgeW91IGFyZSB1c2luZyB0aGUgbGF0ZXN0IHZlcnNpb24gb2YgUmFjdGl2ZS5qcyBpbiB5b3VyIGJ1aWxkIHByb2Nlc3MgYXMgd2VsbCBhcyBpbiB5b3VyIGFwcFwiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGVtcGxhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmRQYXJ0aWFscyhleGlzdGluZ1BhcnRpYWxzLCBuZXdQYXJ0aWFscywgb3ZlcndyaXRlKSB7XG4gIFx0aWYgKCFuZXdQYXJ0aWFscykgcmV0dXJuO1xuXG4gIFx0Ly8gVE9ETyB0aGVyZSdzIGFuIGFtYmlndWl0eSBoZXJlIC0gd2UgbmVlZCB0byBvdmVyd3JpdGUgaW4gdGhlIGByZXNldCgpYFxuICBcdC8vIGNhc2UsIGJ1dCBub3QgaW5pdGlhbGx5Li4uXG5cbiAgXHRmb3IgKHZhciBrZXkgaW4gbmV3UGFydGlhbHMpIHtcbiAgXHRcdGlmIChvdmVyd3JpdGUgfHwgIWV4aXN0aW5nUGFydGlhbHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBcdFx0XHRleGlzdGluZ1BhcnRpYWxzW2tleV0gPSBuZXdQYXJ0aWFsc1trZXldO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciB0ZW1wbGF0ZV90ZW1wbGF0ZSA9IHRlbXBsYXRlQ29uZmlndXJhdG9yO1xuXG4gIHZhciBjb25maWdfcmVnaXN0cmllc19fcmVnaXN0cnlOYW1lcywgUmVnaXN0cnksIHJlZ2lzdHJpZXM7XG5cbiAgY29uZmlnX3JlZ2lzdHJpZXNfX3JlZ2lzdHJ5TmFtZXMgPSBbXCJhZGFwdG9yc1wiLCBcImNvbXBvbmVudHNcIiwgXCJjb21wdXRlZFwiLCBcImRlY29yYXRvcnNcIiwgXCJlYXNpbmdcIiwgXCJldmVudHNcIiwgXCJpbnRlcnBvbGF0b3JzXCIsIFwicGFydGlhbHNcIiwgXCJ0cmFuc2l0aW9uc1wiXTtcblxuICBSZWdpc3RyeSA9IGZ1bmN0aW9uIChuYW1lLCB1c2VEZWZhdWx0cykge1xuICBcdHRoaXMubmFtZSA9IG5hbWU7XG4gIFx0dGhpcy51c2VEZWZhdWx0cyA9IHVzZURlZmF1bHRzO1xuICB9O1xuXG4gIFJlZ2lzdHJ5LnByb3RvdHlwZSA9IHtcbiAgXHRjb25zdHJ1Y3RvcjogUmVnaXN0cnksXG5cbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIChQYXJlbnQsIHByb3RvLCBvcHRpb25zKSB7XG4gIFx0XHR0aGlzLmNvbmZpZ3VyZSh0aGlzLnVzZURlZmF1bHRzID8gUGFyZW50LmRlZmF1bHRzIDogUGFyZW50LCB0aGlzLnVzZURlZmF1bHRzID8gcHJvdG8gOiBwcm90by5jb25zdHJ1Y3Rvciwgb3B0aW9ucyk7XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIFx0Y29uZmlndXJlOiBmdW5jdGlvbiAoUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgXHRcdHZhciBuYW1lID0gdGhpcy5uYW1lLFxuICBcdFx0ICAgIG9wdGlvbiA9IG9wdGlvbnNbbmFtZV0sXG4gIFx0XHQgICAgcmVnaXN0cnk7XG5cbiAgXHRcdHJlZ2lzdHJ5ID0gY3JlYXRlKFBhcmVudFtuYW1lXSk7XG5cbiAgXHRcdGZvciAodmFyIGtleSBpbiBvcHRpb24pIHtcbiAgXHRcdFx0cmVnaXN0cnlba2V5XSA9IG9wdGlvbltrZXldO1xuICBcdFx0fVxuXG4gIFx0XHR0YXJnZXRbbmFtZV0gPSByZWdpc3RyeTtcbiAgXHR9LFxuXG4gIFx0cmVzZXQ6IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG4gIFx0XHR2YXIgcmVnaXN0cnkgPSByYWN0aXZlW3RoaXMubmFtZV07XG4gIFx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICBcdFx0T2JqZWN0LmtleXMocmVnaXN0cnkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBcdFx0XHR2YXIgaXRlbSA9IHJlZ2lzdHJ5W2tleV07XG4gIFx0XHRcdGlmIChpdGVtLl9mbikge1xuICBcdFx0XHRcdGlmIChpdGVtLl9mbi5pc093bmVyKSB7XG4gIFx0XHRcdFx0XHRyZWdpc3RyeVtrZXldID0gaXRlbS5fZm47XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGRlbGV0ZSByZWdpc3RyeVtrZXldO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0XHRyZXR1cm4gY2hhbmdlZDtcbiAgXHR9XG4gIH07XG5cbiAgcmVnaXN0cmllcyA9IGNvbmZpZ19yZWdpc3RyaWVzX19yZWdpc3RyeU5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICBcdHJldHVybiBuZXcgUmVnaXN0cnkobmFtZSwgbmFtZSA9PT0gXCJjb21wdXRlZFwiKTtcbiAgfSk7XG5cbiAgdmFyIGNvbmZpZ19yZWdpc3RyaWVzID0gcmVnaXN0cmllcztcblxuICAvKnRoaXMuY29uZmlndXJlKFxuICBcdHRoaXMudXNlRGVmYXVsdHMgPyBQYXJlbnQuZGVmYXVsdHMgOiBQYXJlbnQsXG4gIFx0cmFjdGl2ZSxcbiAgXHRvcHRpb25zICk7Ki9cblxuICB2YXIgd3JhcFByb3RvdHlwZSA9IHdyYXA7XG5cbiAgZnVuY3Rpb24gd3JhcChwYXJlbnQsIG5hbWUsIG1ldGhvZCkge1xuICBcdGlmICghL19zdXBlci8udGVzdChtZXRob2QpKSB7XG4gIFx0XHRyZXR1cm4gbWV0aG9kO1xuICBcdH1cblxuICBcdHZhciB3cmFwcGVyID0gZnVuY3Rpb24gd3JhcFN1cGVyKCkge1xuICBcdFx0dmFyIHN1cGVyTWV0aG9kID0gZ2V0U3VwZXJNZXRob2Qod3JhcHBlci5fcGFyZW50LCBuYW1lKSxcbiAgXHRcdCAgICBoYXNTdXBlciA9IChcIl9zdXBlclwiIGluIHRoaXMpLFxuICBcdFx0ICAgIG9sZFN1cGVyID0gdGhpcy5fc3VwZXIsXG4gIFx0XHQgICAgcmVzdWx0O1xuXG4gIFx0XHR0aGlzLl9zdXBlciA9IHN1cGVyTWV0aG9kO1xuXG4gIFx0XHRyZXN1bHQgPSBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBcdFx0aWYgKGhhc1N1cGVyKSB7XG4gIFx0XHRcdHRoaXMuX3N1cGVyID0gb2xkU3VwZXI7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRkZWxldGUgdGhpcy5fc3VwZXI7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fTtcblxuICBcdHdyYXBwZXIuX3BhcmVudCA9IHBhcmVudDtcbiAgXHR3cmFwcGVyLl9tZXRob2QgPSBtZXRob2Q7XG5cbiAgXHRyZXR1cm4gd3JhcHBlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFN1cGVyTWV0aG9kKHBhcmVudCwgbmFtZSkge1xuICBcdHZhciB2YWx1ZSwgbWV0aG9kO1xuXG4gIFx0aWYgKG5hbWUgaW4gcGFyZW50KSB7XG4gIFx0XHR2YWx1ZSA9IHBhcmVudFtuYW1lXTtcblxuICBcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdG1ldGhvZCA9IHZhbHVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bWV0aG9kID0gZnVuY3Rpb24gcmV0dXJuVmFsdWUoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuICBcdFx0XHR9O1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRtZXRob2QgPSBub29wO1xuICBcdH1cblxuICBcdHJldHVybiBtZXRob2Q7XG4gIH1cblxuICB2YXIgY29uZmlnX2RlcHJlY2F0ZSA9IGRlcHJlY2F0ZTtcbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShkZXByZWNhdGVkLCBjb3JyZWN0LCBpc0Vycm9yKSB7XG4gIFx0cmV0dXJuIFwib3B0aW9ucy5cIiArIGRlcHJlY2F0ZWQgKyBcIiBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBvcHRpb25zLlwiICsgY29ycmVjdCArIFwiLlwiICsgKGlzRXJyb3IgPyBcIiBZb3UgY2Fubm90IHNwZWNpZnkgYm90aCBvcHRpb25zLCBwbGVhc2UgdXNlIG9wdGlvbnMuXCIgKyBjb3JyZWN0ICsgXCIuXCIgOiBcIlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZU9wdGlvbihvcHRpb25zLCBkZXByZWNhdGVkT3B0aW9uLCBjb3JyZWN0KSB7XG4gIFx0aWYgKGRlcHJlY2F0ZWRPcHRpb24gaW4gb3B0aW9ucykge1xuICBcdFx0aWYgKCEoY29ycmVjdCBpbiBvcHRpb25zKSkge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyhnZXRNZXNzYWdlKGRlcHJlY2F0ZWRPcHRpb24sIGNvcnJlY3QpKTtcbiAgXHRcdFx0b3B0aW9uc1tjb3JyZWN0XSA9IG9wdGlvbnNbZGVwcmVjYXRlZE9wdGlvbl07XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoZ2V0TWVzc2FnZShkZXByZWNhdGVkT3B0aW9uLCBjb3JyZWN0LCB0cnVlKSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZShvcHRpb25zKSB7XG4gIFx0ZGVwcmVjYXRlT3B0aW9uKG9wdGlvbnMsIFwiYmVmb3JlSW5pdFwiLCBcIm9uY29uc3RydWN0XCIpO1xuICBcdGRlcHJlY2F0ZU9wdGlvbihvcHRpb25zLCBcImluaXRcIiwgXCJvbnJlbmRlclwiKTtcbiAgXHRkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgXCJjb21wbGV0ZVwiLCBcIm9uY29tcGxldGVcIik7XG4gIFx0ZGVwcmVjYXRlT3B0aW9uKG9wdGlvbnMsIFwiZXZlbnREZWZpbml0aW9uc1wiLCBcImV2ZW50c1wiKTtcblxuICBcdC8vIFVzaW5nIGV4dGVuZCB3aXRoIENvbXBvbmVudCBpbnN0ZWFkIG9mIG9wdGlvbnMsXG4gIFx0Ly8gbGlrZSBIdW1hbi5leHRlbmQoIFNwaWRlciApIG1lYW5zIGFkYXB0b3JzIGFzIGEgcmVnaXN0cnlcbiAgXHQvLyBnZXRzIGNvcGllZCB0byBvcHRpb25zLiBTbyB3ZSBoYXZlIHRvIGNoZWNrIGlmIGFjdHVhbGx5IGFuIGFycmF5XG4gIFx0aWYgKGlzQXJyYXkob3B0aW9ucy5hZGFwdG9ycykpIHtcbiAgXHRcdGRlcHJlY2F0ZU9wdGlvbihvcHRpb25zLCBcImFkYXB0b3JzXCIsIFwiYWRhcHRcIik7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGNvbmZpZywgb3JkZXIsIGRlZmF1bHRLZXlzLCBjdXN0b20sIGlzQmxhY2tsaXN0ZWQsIGlzU3RhbmRhcmRLZXk7XG5cbiAgY3VzdG9tID0ge1xuICBcdGFkYXB0OiBjdXN0b21fYWRhcHQsXG4gIFx0Y3NzOiBjc3NfY3NzLFxuICBcdGRhdGE6IGN1c3RvbV9kYXRhLFxuICBcdHRlbXBsYXRlOiB0ZW1wbGF0ZV90ZW1wbGF0ZVxuICB9O1xuXG4gIGRlZmF1bHRLZXlzID0gT2JqZWN0LmtleXMoY29uZmlnX2RlZmF1bHRzKTtcblxuICBpc1N0YW5kYXJkS2V5ID0gbWFrZU9iaihkZWZhdWx0S2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICBcdHJldHVybiAhY3VzdG9tW2tleV07XG4gIH0pKTtcblxuICAvLyBibGFja2xpc3RlZCBrZXlzIHRoYXQgd2UgZG9uJ3QgZG91YmxlIGV4dGVuZFxuICBpc0JsYWNrbGlzdGVkID0gbWFrZU9iaihkZWZhdWx0S2V5cy5jb25jYXQoY29uZmlnX3JlZ2lzdHJpZXMubWFwKGZ1bmN0aW9uIChyKSB7XG4gIFx0cmV0dXJuIHIubmFtZTtcbiAgfSkpKTtcblxuICBvcmRlciA9IFtdLmNvbmNhdChkZWZhdWx0S2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICBcdHJldHVybiAhY29uZmlnX3JlZ2lzdHJpZXNba2V5XSAmJiAhY3VzdG9tW2tleV07XG4gIH0pLCBjb25maWdfcmVnaXN0cmllcywgY3VzdG9tLmRhdGEsIGN1c3RvbS50ZW1wbGF0ZSwgY3VzdG9tLmNzcyk7XG5cbiAgY29uZmlnID0ge1xuICBcdGV4dGVuZDogZnVuY3Rpb24gKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdHJldHVybiBjb25maWd1cmUoXCJleHRlbmRcIiwgUGFyZW50LCBwcm90bywgb3B0aW9ucyk7XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uIChQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMpIHtcbiAgXHRcdHJldHVybiBjb25maWd1cmUoXCJpbml0XCIsIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyk7XG4gIFx0fSxcblxuICBcdHJlc2V0OiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0cmV0dXJuIG9yZGVyLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICBcdFx0XHRyZXR1cm4gYy5yZXNldCAmJiBjLnJlc2V0KHJhY3RpdmUpO1xuICBcdFx0fSkubWFwKGZ1bmN0aW9uIChjKSB7XG4gIFx0XHRcdHJldHVybiBjLm5hbWU7XG4gIFx0XHR9KTtcbiAgXHR9LFxuXG4gIFx0Ly8gdGhpcyBkZWZpbmVzIHRoZSBvcmRlci4gVE9ETyB0aGlzIGlzbid0IHVzZWQgYW55d2hlcmUgaW4gdGhlIGNvZGViYXNlLFxuICBcdC8vIG9ubHkgaW4gdGhlIHRlc3Qgc3VpdGUgLSBzaG91bGQgZ2V0IHJpZCBvZiBpdFxuICBcdG9yZGVyOiBvcmRlciB9O1xuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZShtZXRob2QsIFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gIFx0Y29uZmlnX2RlcHJlY2F0ZShvcHRpb25zKTtcblxuICBcdGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gIFx0XHRpZiAoaXNTdGFuZGFyZEtleS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdHZhciB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcblxuICBcdFx0XHQvLyB3YXJuIHRoZSBkZXZlbG9wZXIgaWYgdGhleSBwYXNzZWQgYSBmdW5jdGlvbiBhbmQgaWdub3JlIGl0cyB2YWx1ZVxuXG4gIFx0XHRcdC8vIE5PVEU6IHdlIGFsbG93IHNvbWUgZnVuY3Rpb25zIG9uIFwiZWxcIiBiZWNhdXNlIHdlIGR1Y2sgdHlwZSBlbGVtZW50IGxpc3RzXG4gIFx0XHRcdC8vIGFuZCBzb21lIGxpYnJhcmllcyBvciBlZidlZC11cCB2aXJ0dWFsIGJyb3dzZXJzIChwaGFudG9tSlMpIHJldHVybiBhXG4gIFx0XHRcdC8vIGZ1bmN0aW9uIG9iamVjdCBhcyB0aGUgcmVzdWx0IG9mIHF1ZXJ5U2VsZWN0b3IgbWV0aG9kc1xuICBcdFx0XHRpZiAoa2V5ICE9PSBcImVsXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHR3YXJuSWZEZWJ1ZyhcIlwiICsga2V5ICsgXCIgaXMgYSBSYWN0aXZlIG9wdGlvbiB0aGF0IGRvZXMgbm90IGV4cGVjdCBhIGZ1bmN0aW9uIGFuZCB3aWxsIGJlIGlnbm9yZWRcIiwgbWV0aG9kID09PSBcImluaXRcIiA/IHRhcmdldCA6IG51bGwpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHRhcmdldFtrZXldID0gdmFsdWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRjb25maWdfcmVnaXN0cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWdpc3RyeSkge1xuICBcdFx0cmVnaXN0cnlbbWV0aG9kXShQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyk7XG4gIFx0fSk7XG5cbiAgXHRjdXN0b21fYWRhcHRbbWV0aG9kXShQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyk7XG4gIFx0dGVtcGxhdGVfdGVtcGxhdGVbbWV0aG9kXShQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyk7XG4gIFx0Y3NzX2Nzc1ttZXRob2RdKFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKTtcblxuICBcdGV4dGVuZE90aGVyTWV0aG9kcyhQYXJlbnQucHJvdG90eXBlLCB0YXJnZXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kT3RoZXJNZXRob2RzKHBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gIFx0Zm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgXHRcdGlmICghaXNCbGFja2xpc3RlZFtrZXldICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBcdFx0XHR2YXIgbWVtYmVyID0gb3B0aW9uc1trZXldO1xuXG4gIFx0XHRcdC8vIGlmIHRoaXMgaXMgYSBtZXRob2QgdGhhdCBvdmVyd3JpdGVzIGEgbWV0aG9kLCB3cmFwIGl0OlxuICBcdFx0XHRpZiAodHlwZW9mIG1lbWJlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdFx0bWVtYmVyID0gd3JhcFByb3RvdHlwZShwYXJlbnQsIGtleSwgbWVtYmVyKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRhcmdldFtrZXldID0gbWVtYmVyO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VPYmooYXJyYXkpIHtcbiAgXHR2YXIgb2JqID0ge307XG4gIFx0YXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICBcdFx0cmV0dXJuIG9ialt4XSA9IHRydWU7XG4gIFx0fSk7XG4gIFx0cmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciBjb25maWdfY29uZmlnID0gY29uZmlnO1xuXG4gIHZhciBwcm90b3R5cGVfYnViYmxlID0gRnJhZ21lbnQkYnViYmxlO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGJ1YmJsZSgpIHtcbiAgXHR0aGlzLmRpcnR5VmFsdWUgPSB0aGlzLmRpcnR5QXJncyA9IHRydWU7XG5cbiAgXHRpZiAodGhpcy5ib3VuZCAmJiB0eXBlb2YgdGhpcy5vd25lci5idWJibGUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0dGhpcy5vd25lci5idWJibGUoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX2RldGFjaCA9IEZyYWdtZW50JGRldGFjaDtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRkZXRhY2goKSB7XG4gIFx0dmFyIGRvY0ZyYWc7XG5cbiAgXHRpZiAodGhpcy5pdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgXHRcdHJldHVybiB0aGlzLml0ZW1zWzBdLmRldGFjaCgpO1xuICBcdH1cblxuICBcdGRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgXHR0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdHZhciBub2RlID0gaXRlbS5kZXRhY2goKTtcblxuICBcdFx0Ly8gVE9ETyBUaGUgaWYgey4uLn0gd2Fzbid0IHByZXZpb3VzbHkgcmVxdWlyZWQgLSBpdCBpcyBub3csIGJlY2F1c2Ugd2UncmVcbiAgXHRcdC8vIGZvcmNpYmx5IGRldGFjaGluZyBldmVyeXRoaW5nIHRvIHJlb3JkZXIgc2VjdGlvbnMgYWZ0ZXIgYW4gdXBkYXRlLiBUaGF0J3NcbiAgXHRcdC8vIGEgbm9uLWlkZWFsIGJydXRlIGZvcmNlIGFwcHJvYWNoLCBpbXBsZW1lbnRlZCB0byBnZXQgYWxsIHRoZSB0ZXN0cyB0byBwYXNzXG4gIFx0XHQvLyAtIGFzIHNvb24gYXMgaXQncyByZXBsYWNlZCB3aXRoIHNvbWV0aGluZyBtb3JlIGVsZWdhbnQsIHRoaXMgc2hvdWxkXG4gIFx0XHQvLyByZXZlcnQgdG8gYGRvY0ZyYWcuYXBwZW5kQ2hpbGQoIGl0ZW0uZGV0YWNoKCkgKWBcbiAgXHRcdGlmIChub2RlKSB7XG4gIFx0XHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gZG9jRnJhZztcbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfZmluZCA9IEZyYWdtZW50JGZpbmQ7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZmluZChzZWxlY3Rvcikge1xuICBcdHZhciBpLCBsZW4sIGl0ZW0sIHF1ZXJ5UmVzdWx0O1xuXG4gIFx0aWYgKHRoaXMuaXRlbXMpIHtcbiAgXHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuXG4gIFx0XHRcdGlmIChpdGVtLmZpbmQgJiYgKHF1ZXJ5UmVzdWx0ID0gaXRlbS5maW5kKHNlbGVjdG9yKSkpIHtcbiAgXHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9maW5kQWxsID0gRnJhZ21lbnQkZmluZEFsbDtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaW5kQWxsKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdHZhciBpLCBsZW4sIGl0ZW07XG5cbiAgXHRpZiAodGhpcy5pdGVtcykge1xuICBcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbaV07XG5cbiAgXHRcdFx0aWYgKGl0ZW0uZmluZEFsbCkge1xuICBcdFx0XHRcdGl0ZW0uZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyA9IEZyYWdtZW50JGZpbmRBbGxDb21wb25lbnRzO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdHZhciBpLCBsZW4sIGl0ZW07XG5cbiAgXHRpZiAodGhpcy5pdGVtcykge1xuICBcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbaV07XG5cbiAgXHRcdFx0aWYgKGl0ZW0uZmluZEFsbENvbXBvbmVudHMpIHtcbiAgXHRcdFx0XHRpdGVtLmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gcXVlcnk7XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQgPSBGcmFnbWVudCRmaW5kQ29tcG9uZW50O1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRDb21wb25lbnQoc2VsZWN0b3IpIHtcbiAgXHR2YXIgbGVuLCBpLCBpdGVtLCBxdWVyeVJlc3VsdDtcblxuICBcdGlmICh0aGlzLml0ZW1zKSB7XG4gIFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1tpXTtcblxuICBcdFx0XHRpZiAoaXRlbS5maW5kQ29tcG9uZW50ICYmIChxdWVyeVJlc3VsdCA9IGl0ZW0uZmluZENvbXBvbmVudChzZWxlY3RvcikpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmluZE5leHROb2RlID0gRnJhZ21lbnQkZmluZE5leHROb2RlO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGZpbmROZXh0Tm9kZShpdGVtKSB7XG4gIFx0dmFyIGluZGV4ID0gaXRlbS5pbmRleCxcbiAgXHQgICAgbm9kZTtcblxuICBcdGlmICh0aGlzLml0ZW1zW2luZGV4ICsgMV0pIHtcbiAgXHRcdG5vZGUgPSB0aGlzLml0ZW1zW2luZGV4ICsgMV0uZmlyc3ROb2RlKCk7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgdGhpcyBpcyB0aGUgcm9vdCBmcmFnbWVudCwgYW5kIHRoZXJlIGFyZSBubyBtb3JlIGl0ZW1zLFxuICBcdC8vIGl0IG1lYW5zIHdlJ3JlIGF0IHRoZSBlbmQuLi5cbiAgXHRlbHNlIGlmICh0aGlzLm93bmVyID09PSB0aGlzLnJvb3QpIHtcbiAgXHRcdGlmICghdGhpcy5vd25lci5jb21wb25lbnQpIHtcbiAgXHRcdFx0Ly8gVE9ETyBidXQgc29tZXRoaW5nIGVsc2UgY291bGQgaGF2ZSBiZWVuIGFwcGVuZGVkIHRvXG4gIFx0XHRcdC8vIHRoaXMucm9vdC5lbCwgbm8/XG4gIFx0XHRcdG5vZGUgPSBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHQvLyAuLi51bmxlc3MgdGhpcyBpcyBhIGNvbXBvbmVudFxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdG5vZGUgPSB0aGlzLm93bmVyLmNvbXBvbmVudC5maW5kTmV4dE5vZGUoKTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0bm9kZSA9IHRoaXMub3duZXIuZmluZE5leHROb2RlKHRoaXMpO1xuICBcdH1cblxuICBcdHJldHVybiBub2RlO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maXJzdE5vZGUgPSBGcmFnbWVudCRmaXJzdE5vZGU7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZmlyc3ROb2RlKCkge1xuICBcdGlmICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXNbMF0pIHtcbiAgXHRcdHJldHVybiB0aGlzLml0ZW1zWzBdLmZpcnN0Tm9kZSgpO1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNoYXJlZF9wcm9jZXNzSXRlbXMgPSBwcm9jZXNzSXRlbXM7XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0l0ZW1zKGl0ZW1zLCB2YWx1ZXMsIGd1aWQsIGNvdW50ZXIpIHtcbiAgXHRjb3VudGVyID0gY291bnRlciB8fCAwO1xuXG4gIFx0cmV0dXJuIGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0dmFyIHBsYWNlaG9sZGVySWQsIHdyYXBwZWQsIHZhbHVlO1xuXG4gIFx0XHRpZiAoaXRlbS50ZXh0KSB7XG4gIFx0XHRcdHJldHVybiBpdGVtLnRleHQ7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChpdGVtLmZyYWdtZW50cykge1xuICBcdFx0XHRyZXR1cm4gaXRlbS5mcmFnbWVudHMubWFwKGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICBcdFx0XHRcdHJldHVybiBwcm9jZXNzSXRlbXMoZnJhZ21lbnQuaXRlbXMsIHZhbHVlcywgZ3VpZCwgY291bnRlcik7XG4gIFx0XHRcdH0pLmpvaW4oXCJcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHBsYWNlaG9sZGVySWQgPSBndWlkICsgXCItXCIgKyBjb3VudGVyKys7XG5cbiAgXHRcdGlmIChpdGVtLmtleXBhdGggJiYgKHdyYXBwZWQgPSBpdGVtLnJvb3Qudmlld21vZGVsLndyYXBwZWRbaXRlbS5rZXlwYXRoLnN0cl0pKSB7XG4gIFx0XHRcdHZhbHVlID0gd3JhcHBlZC52YWx1ZTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHZhbHVlID0gaXRlbS5nZXRWYWx1ZSgpO1xuICBcdFx0fVxuXG4gIFx0XHR2YWx1ZXNbcGxhY2Vob2xkZXJJZF0gPSB2YWx1ZTtcblxuICBcdFx0cmV0dXJuIFwiJHtcIiArIHBsYWNlaG9sZGVySWQgKyBcIn1cIjtcbiAgXHR9KS5qb2luKFwiXCIpO1xuICB9XG5cbiAgdmFyIGdldEFyZ3NMaXN0ID0gRnJhZ21lbnQkZ2V0QXJnc0xpc3Q7XG4gIGZ1bmN0aW9uIEZyYWdtZW50JGdldEFyZ3NMaXN0KCkge1xuICBcdHZhciB2YWx1ZXMsIHNvdXJjZSwgcGFyc2VkLCByZXN1bHQ7XG5cbiAgXHRpZiAodGhpcy5kaXJ0eUFyZ3MpIHtcbiAgXHRcdHNvdXJjZSA9IHNoYXJlZF9wcm9jZXNzSXRlbXModGhpcy5pdGVtcywgdmFsdWVzID0ge30sIHRoaXMucm9vdC5fZ3VpZCk7XG4gIFx0XHRwYXJzZWQgPSBwYXJzZUpTT04oXCJbXCIgKyBzb3VyY2UgKyBcIl1cIiwgdmFsdWVzKTtcblxuICBcdFx0aWYgKCFwYXJzZWQpIHtcbiAgXHRcdFx0cmVzdWx0ID0gW3RoaXMudG9TdHJpbmcoKV07XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXN1bHQgPSBwYXJzZWQudmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuYXJnc0xpc3QgPSByZXN1bHQ7XG4gIFx0XHR0aGlzLmRpcnR5QXJncyA9IGZhbHNlO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLmFyZ3NMaXN0O1xuICB9XG5cbiAgdmFyIGdldE5vZGUgPSBGcmFnbWVudCRnZXROb2RlO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGdldE5vZGUoKSB7XG4gIFx0dmFyIGZyYWdtZW50ID0gdGhpcztcblxuICBcdGRvIHtcbiAgXHRcdGlmIChmcmFnbWVudC5wRWxlbWVudCkge1xuICBcdFx0XHRyZXR1cm4gZnJhZ21lbnQucEVsZW1lbnQubm9kZTtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlIChmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudCk7XG5cbiAgXHRyZXR1cm4gdGhpcy5yb290LmRldGFjaGVkIHx8IHRoaXMucm9vdC5lbDtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZ2V0VmFsdWUgPSBGcmFnbWVudCRnZXRWYWx1ZTtcbiAgZnVuY3Rpb24gRnJhZ21lbnQkZ2V0VmFsdWUoKSB7XG4gIFx0dmFyIHZhbHVlcywgc291cmNlLCBwYXJzZWQsIHJlc3VsdDtcblxuICBcdGlmICh0aGlzLmRpcnR5VmFsdWUpIHtcbiAgXHRcdHNvdXJjZSA9IHNoYXJlZF9wcm9jZXNzSXRlbXModGhpcy5pdGVtcywgdmFsdWVzID0ge30sIHRoaXMucm9vdC5fZ3VpZCk7XG4gIFx0XHRwYXJzZWQgPSBwYXJzZUpTT04oc291cmNlLCB2YWx1ZXMpO1xuXG4gIFx0XHRpZiAoIXBhcnNlZCkge1xuICBcdFx0XHRyZXN1bHQgPSB0aGlzLnRvU3RyaW5nKCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXN1bHQgPSBwYXJzZWQudmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudmFsdWUgPSByZXN1bHQ7XG4gIFx0XHR0aGlzLmRpcnR5VmFsdWUgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIHZhciBzaGFyZWRfZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICBcdHJldHVybiBkZXRhY2hOb2RlKHRoaXMubm9kZSk7XG4gIH07XG5cbiAgdmFyIFRleHQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMudHlwZSA9IFRFWFQ7XG4gIFx0dGhpcy50ZXh0ID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgfTtcblxuICBUZXh0LnByb3RvdHlwZSA9IHtcbiAgXHRkZXRhY2g6IHNoYXJlZF9kZXRhY2gsXG5cbiAgXHRmaXJzdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLm5vZGUpIHtcbiAgXHRcdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50ZXh0KTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uIChlc2NhcGUpIHtcbiAgXHRcdHJldHVybiBlc2NhcGUgPyBlc2NhcGVIdG1sKHRoaXMudGV4dCkgOiB0aGlzLnRleHQ7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0aWYgKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuZGV0YWNoKCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBpdGVtc19UZXh0ID0gVGV4dDtcblxuICB2YXIgc2hhcmVkX3VuYmluZCA9IHNoYXJlZF91bmJpbmRfX3VuYmluZDtcblxuICBmdW5jdGlvbiBzaGFyZWRfdW5iaW5kX191bmJpbmQoKSB7XG4gIFx0aWYgKHRoaXMucmVnaXN0ZXJlZCkge1xuICBcdFx0Ly8gdGhpcyB3YXMgcmVnaXN0ZXJlZCBhcyBhIGRlcGVuZGFudFxuICBcdFx0dGhpcy5yb290LnZpZXdtb2RlbC51bnJlZ2lzdGVyKHRoaXMua2V5cGF0aCwgdGhpcyk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMucmVzb2x2ZXIpIHtcbiAgXHRcdHRoaXMucmVzb2x2ZXIudW5iaW5kKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIE11c3RhY2hlX2dldFZhbHVlID0gTXVzdGFjaGUkZ2V0VmFsdWU7XG5cbiAgZnVuY3Rpb24gTXVzdGFjaGUkZ2V0VmFsdWUoKSB7XG4gIFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICB2YXIgUmVmZXJlbmNlUmVzb2x2ZXIgPSBmdW5jdGlvbiAob3duZXIsIHJlZiwgY2FsbGJhY2spIHtcbiAgXHR2YXIga2V5cGF0aDtcblxuICBcdHRoaXMucmVmID0gcmVmO1xuICBcdHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcblxuICBcdHRoaXMucm9vdCA9IG93bmVyLnJvb3Q7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IG93bmVyLnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBcdGtleXBhdGggPSBzaGFyZWRfcmVzb2x2ZVJlZihvd25lci5yb290LCByZWYsIG93bmVyLnBhcmVudEZyYWdtZW50KTtcbiAgXHRpZiAoa2V5cGF0aCAhPSB1bmRlZmluZWQpIHtcbiAgXHRcdHRoaXMucmVzb2x2ZShrZXlwYXRoKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVW5yZXNvbHZlZCh0aGlzKTtcbiAgXHR9XG4gIH07XG5cbiAgUmVmZXJlbmNlUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdHJlc29sdmU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoICYmICFrZXlwYXRoKSB7XG4gIFx0XHRcdC8vIGl0IHdhcyByZXNvbHZlZCwgYW5kIG5vdyBpdCdzIG5vdC4gQ2FuIGhhcHBlbiBpZiBlLmcuIGBiYXJgIGluXG4gIFx0XHRcdC8vIGB7e2Zvb1tiYXJdfX1gIGJlY29tZXMgdW5kZWZpbmVkXG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFVucmVzb2x2ZWQodGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMucmVzb2x2ZWQgPSB0cnVlO1xuXG4gIFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdFx0dGhpcy5jYWxsYmFjayhrZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnJlc29sdmUoZ2V0S2V5cGF0aCh0aGlzLnJlZikpO1xuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHR2YXIga2V5cGF0aDtcblxuICBcdFx0aWYgKHRoaXMua2V5cGF0aCAhPSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0a2V5cGF0aCA9IHRoaXMua2V5cGF0aC5yZXBsYWNlKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0XHQvLyB3YXMgYSBuZXcga2V5cGF0aCBjcmVhdGVkP1xuICBcdFx0XHRpZiAoa2V5cGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0Ly8gcmVzb2x2ZSBpdFxuICBcdFx0XHRcdHRoaXMucmVzb2x2ZShrZXlwYXRoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5yZXNvbHZlZCkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5yZW1vdmVVbnJlc29sdmVkKHRoaXMpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgUmVzb2x2ZXJzX1JlZmVyZW5jZVJlc29sdmVyID0gUmVmZXJlbmNlUmVzb2x2ZXI7XG5cbiAgdmFyIFNwZWNpYWxSZXNvbHZlciA9IGZ1bmN0aW9uIChvd25lciwgcmVmLCBjYWxsYmFjaykge1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvd25lci5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLnJlZiA9IHJlZjtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHR0aGlzLnJlYmluZCgpO1xuICB9O1xuXG4gIHZhciBwcm9wcyA9IHtcbiAgXHRcIkBrZXlwYXRoXCI6IHsgcHJlZml4OiBcImNcIiwgcHJvcDogW1wiY29udGV4dFwiXSB9LFxuICBcdFwiQGluZGV4XCI6IHsgcHJlZml4OiBcImlcIiwgcHJvcDogW1wiaW5kZXhcIl0gfSxcbiAgXHRcIkBrZXlcIjogeyBwcmVmaXg6IFwia1wiLCBwcm9wOiBbXCJrZXlcIiwgXCJpbmRleFwiXSB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0UHJvcCh0YXJnZXQsIHByb3ApIHtcbiAgXHR2YXIgdmFsdWU7XG4gIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wLnByb3AubGVuZ3RoOyBpKyspIHtcbiAgXHRcdGlmICgodmFsdWUgPSB0YXJnZXRbcHJvcC5wcm9wW2ldXSkgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgU3BlY2lhbFJlc29sdmVyLnByb3RvdHlwZSA9IHtcbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciByZWYgPSB0aGlzLnJlZixcbiAgXHRcdCAgICBmcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQsXG4gIFx0XHQgICAgcHJvcCA9IHByb3BzW3JlZl0sXG4gIFx0XHQgICAgdmFsdWU7XG5cbiAgXHRcdGlmICghcHJvcCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHNwZWNpYWwgcmVmZXJlbmNlIFxcXCJcIiArIHJlZiArIFwiXFxcIiAtIHZhbGlkIHJlZmVyZW5jZXMgYXJlIEBpbmRleCwgQGtleSBhbmQgQGtleXBhdGhcIik7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGhhdmUgd2UgYWxyZWFkeSBmb3VuZCB0aGUgbmVhcmVzdCBwYXJlbnQ/XG4gIFx0XHRpZiAodGhpcy5jYWNoZWQpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuY2FsbGJhY2soZ2V0S2V5cGF0aChcIkBcIiArIHByb3AucHJlZml4ICsgZ2V0UHJvcCh0aGlzLmNhY2hlZCwgcHJvcCkpKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIGZvciBpbmRpY2VzLCB3aGljaCBtYXkgY3Jvc3MgY29tcG9uZW50IGJvdW5kYXJpZXNcbiAgXHRcdGlmIChwcm9wLnByb3AuaW5kZXhPZihcImluZGV4XCIpICE9PSAtMSB8fCBwcm9wLnByb3AuaW5kZXhPZihcImtleVwiKSAhPT0gLTEpIHtcbiAgXHRcdFx0d2hpbGUgKGZyYWdtZW50KSB7XG4gIFx0XHRcdFx0aWYgKGZyYWdtZW50Lm93bmVyLmN1cnJlbnRTdWJ0eXBlID09PSBTRUNUSU9OX0VBQ0ggJiYgKHZhbHVlID0gZ2V0UHJvcChmcmFnbWVudCwgcHJvcCkpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRcdHRoaXMuY2FjaGVkID0gZnJhZ21lbnQ7XG5cbiAgXHRcdFx0XHRcdGZyYWdtZW50LnJlZ2lzdGVySW5kZXhSZWYodGhpcyk7XG5cbiAgXHRcdFx0XHRcdHJldHVybiB0aGlzLmNhbGxiYWNrKGdldEtleXBhdGgoXCJAXCIgKyBwcm9wLnByZWZpeCArIHZhbHVlKSk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gd2F0Y2ggZm9yIGNvbXBvbmVudCBib3VuZGFyaWVzXG4gIFx0XHRcdFx0aWYgKCFmcmFnbWVudC5wYXJlbnQgJiYgZnJhZ21lbnQub3duZXIgJiYgZnJhZ21lbnQub3duZXIuY29tcG9uZW50ICYmIGZyYWdtZW50Lm93bmVyLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCAmJiAhZnJhZ21lbnQub3duZXIuY29tcG9uZW50Lmluc3RhbmNlLmlzb2xhdGVkKSB7XG4gIFx0XHRcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50Lm93bmVyLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3aGlsZSAoZnJhZ21lbnQpIHtcbiAgXHRcdFx0XHRpZiAoKHZhbHVlID0gZ2V0UHJvcChmcmFnbWVudCwgcHJvcCkpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRcdHJldHVybiB0aGlzLmNhbGxiYWNrKGdldEtleXBhdGgoXCJAXCIgKyBwcm9wLnByZWZpeCArIHZhbHVlLnN0cikpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuY2FjaGVkKSB7XG4gIFx0XHRcdHRoaXMuY2FjaGVkLnVucmVnaXN0ZXJJbmRleFJlZih0aGlzKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIFJlc29sdmVyc19TcGVjaWFsUmVzb2x2ZXIgPSBTcGVjaWFsUmVzb2x2ZXI7XG5cbiAgdmFyIEluZGV4UmVzb2x2ZXIgPSBmdW5jdGlvbiAob3duZXIsIHJlZiwgY2FsbGJhY2spIHtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gb3duZXIucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5yZWYgPSByZWY7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIFx0cmVmLnJlZi5mcmFnbWVudC5yZWdpc3RlckluZGV4UmVmKHRoaXMpO1xuXG4gIFx0dGhpcy5yZWJpbmQoKTtcbiAgfTtcblxuICBJbmRleFJlc29sdmVyLnByb3RvdHlwZSA9IHtcbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBpbmRleCxcbiAgXHRcdCAgICByZWYgPSB0aGlzLnJlZi5yZWY7XG5cbiAgXHRcdGlmIChyZWYucmVmLnQgPT09IFwia1wiKSB7XG4gIFx0XHRcdGluZGV4ID0gXCJrXCIgKyByZWYuZnJhZ21lbnQua2V5O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0aW5kZXggPSBcImlcIiArIHJlZi5mcmFnbWVudC5pbmRleDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5jYWxsYmFjayhnZXRLZXlwYXRoKFwiQFwiICsgaW5kZXgpKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnJlZi5yZWYuZnJhZ21lbnQudW5yZWdpc3RlckluZGV4UmVmKHRoaXMpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgUmVzb2x2ZXJzX0luZGV4UmVzb2x2ZXIgPSBJbmRleFJlc29sdmVyO1xuXG4gIHZhciBSZXNvbHZlcnNfZmluZEluZGV4UmVmcyA9IGZpbmRJbmRleFJlZnM7XG5cbiAgZnVuY3Rpb24gZmluZEluZGV4UmVmcyhmcmFnbWVudCwgcmVmTmFtZSkge1xuICBcdHZhciByZXN1bHQgPSB7fSxcbiAgXHQgICAgcmVmcyxcbiAgXHQgICAgZnJhZ1JlZnMsXG4gIFx0ICAgIHJlZixcbiAgXHQgICAgaSxcbiAgXHQgICAgb3duZXIsXG4gIFx0ICAgIGhpdCA9IGZhbHNlO1xuXG4gIFx0aWYgKCFyZWZOYW1lKSB7XG4gIFx0XHRyZXN1bHQucmVmcyA9IHJlZnMgPSB7fTtcbiAgXHR9XG5cbiAgXHR3aGlsZSAoZnJhZ21lbnQpIHtcbiAgXHRcdGlmICgob3duZXIgPSBmcmFnbWVudC5vd25lcikgJiYgKGZyYWdSZWZzID0gb3duZXIuaW5kZXhSZWZzKSkge1xuXG4gIFx0XHRcdC8vIHdlJ3JlIGxvb2tpbmcgZm9yIGEgcGFydGljdWxhciByZWYsIGFuZCBpdCdzIGhlcmVcbiAgXHRcdFx0aWYgKHJlZk5hbWUgJiYgKHJlZiA9IG93bmVyLmdldEluZGV4UmVmKHJlZk5hbWUpKSkge1xuICBcdFx0XHRcdHJlc3VsdC5yZWYgPSB7XG4gIFx0XHRcdFx0XHRmcmFnbWVudDogZnJhZ21lbnQsXG4gIFx0XHRcdFx0XHRyZWY6IHJlZlxuICBcdFx0XHRcdH07XG4gIFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIHdlJ3JlIGNvbGxlY3RpbmcgcmVmcyB1cC10cmVlXG4gIFx0XHRcdGVsc2UgaWYgKCFyZWZOYW1lKSB7XG4gIFx0XHRcdFx0Zm9yIChpIGluIGZyYWdSZWZzKSB7XG4gIFx0XHRcdFx0XHRyZWYgPSBmcmFnUmVmc1tpXTtcblxuICBcdFx0XHRcdFx0Ly8gZG9uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIHJlZnMgLSB0aGV5IHNob3VsZCBzaGFkb3cgcGFyZW50c1xuICBcdFx0XHRcdFx0aWYgKCFyZWZzW3JlZi5uXSkge1xuICBcdFx0XHRcdFx0XHRoaXQgPSB0cnVlO1xuICBcdFx0XHRcdFx0XHRyZWZzW3JlZi5uXSA9IHtcbiAgXHRcdFx0XHRcdFx0XHRmcmFnbWVudDogZnJhZ21lbnQsXG4gIFx0XHRcdFx0XHRcdFx0cmVmOiByZWZcbiAgXHRcdFx0XHRcdFx0fTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gd2F0Y2ggZm9yIGNvbXBvbmVudCBib3VuZGFyaWVzXG4gIFx0XHRpZiAoIWZyYWdtZW50LnBhcmVudCAmJiBmcmFnbWVudC5vd25lciAmJiBmcmFnbWVudC5vd25lci5jb21wb25lbnQgJiYgZnJhZ21lbnQub3duZXIuY29tcG9uZW50LnBhcmVudEZyYWdtZW50ICYmICFmcmFnbWVudC5vd25lci5jb21wb25lbnQuaW5zdGFuY2UuaXNvbGF0ZWQpIHtcbiAgXHRcdFx0cmVzdWx0LmNvbXBvbmVudEJvdW5kYXJ5ID0gdHJ1ZTtcbiAgXHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5vd25lci5jb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoIWhpdCkge1xuICBcdFx0cmV0dXJuIHVuZGVmaW5lZDtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9XG4gIH1cblxuICBmaW5kSW5kZXhSZWZzLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKGluZGljZXMpIHtcbiAgXHR2YXIgcmVmcyA9IHt9LFxuICBcdCAgICBrLFxuICBcdCAgICByZWY7XG5cbiAgXHRmb3IgKGsgaW4gaW5kaWNlcy5yZWZzKSB7XG4gIFx0XHRyZWYgPSBpbmRpY2VzLnJlZnNba107XG4gIFx0XHRyZWZzW3JlZi5yZWYubl0gPSByZWYucmVmLnQgPT09IFwia1wiID8gcmVmLmZyYWdtZW50LmtleSA6IHJlZi5mcmFnbWVudC5pbmRleDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVmcztcbiAgfTtcblxuICB2YXIgUmVzb2x2ZXJzX2NyZWF0ZVJlZmVyZW5jZVJlc29sdmVyID0gY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXI7XG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKG93bmVyLCByZWYsIGNhbGxiYWNrKSB7XG4gIFx0dmFyIGluZGV4UmVmO1xuXG4gIFx0aWYgKHJlZi5jaGFyQXQoMCkgPT09IFwiQFwiKSB7XG4gIFx0XHRyZXR1cm4gbmV3IFJlc29sdmVyc19TcGVjaWFsUmVzb2x2ZXIob3duZXIsIHJlZiwgY2FsbGJhY2spO1xuICBcdH1cblxuICBcdGlmIChpbmRleFJlZiA9IFJlc29sdmVyc19maW5kSW5kZXhSZWZzKG93bmVyLnBhcmVudEZyYWdtZW50LCByZWYpKSB7XG4gIFx0XHRyZXR1cm4gbmV3IFJlc29sdmVyc19JbmRleFJlc29sdmVyKG93bmVyLCBpbmRleFJlZiwgY2FsbGJhY2spO1xuICBcdH1cblxuICBcdHJldHVybiBuZXcgUmVzb2x2ZXJzX1JlZmVyZW5jZVJlc29sdmVyKG93bmVyLCByZWYsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBzaGFyZWRfZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nID0gZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nO1xuICB2YXIgY2FjaGUgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nKHN0ciwgaSkge1xuICBcdHZhciBmbiwgYXJncztcblxuICBcdGlmIChjYWNoZVtzdHJdKSB7XG4gIFx0XHRyZXR1cm4gY2FjaGVbc3RyXTtcbiAgXHR9XG5cbiAgXHRhcmdzID0gW107XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0YXJnc1tpXSA9IFwiX1wiICsgaTtcbiAgXHR9XG5cbiAgXHRmbiA9IG5ldyBGdW5jdGlvbihhcmdzLmpvaW4oXCIsXCIpLCBcInJldHVybihcIiArIHN0ciArIFwiKVwiKTtcblxuICBcdGNhY2hlW3N0cl0gPSBmbjtcbiAgXHRyZXR1cm4gZm47XG4gIH1cblxuICB2YXIgRXhwcmVzc2lvblJlc29sdmVyLFxuICAgICAgUmVzb2x2ZXJzX0V4cHJlc3Npb25SZXNvbHZlcl9fYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuXG4gIEV4cHJlc3Npb25SZXNvbHZlciA9IGZ1bmN0aW9uIChvd25lciwgcGFyZW50RnJhZ21lbnQsIGV4cHJlc3Npb24sIGNhbGxiYWNrKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciByYWN0aXZlO1xuXG4gIFx0cmFjdGl2ZSA9IG93bmVyLnJvb3Q7XG5cbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIFx0dGhpcy5vd25lciA9IG93bmVyO1xuICBcdHRoaXMuc3RyID0gZXhwcmVzc2lvbi5zO1xuICBcdHRoaXMua2V5cGF0aHMgPSBbXTtcblxuICBcdC8vIENyZWF0ZSByZXNvbHZlcnMgZm9yIGVhY2ggcmVmZXJlbmNlXG4gIFx0dGhpcy5wZW5kaW5nID0gZXhwcmVzc2lvbi5yLmxlbmd0aDtcbiAgXHR0aGlzLnJlZlJlc29sdmVycyA9IGV4cHJlc3Npb24uci5tYXAoZnVuY3Rpb24gKHJlZiwgaSkge1xuICBcdFx0cmV0dXJuIFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlcihfdGhpcywgcmVmLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRfdGhpcy5yZXNvbHZlKGksIGtleXBhdGgpO1xuICBcdFx0fSk7XG4gIFx0fSk7XG5cbiAgXHR0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgXHR0aGlzLmJ1YmJsZSgpO1xuICB9O1xuXG4gIEV4cHJlc3Npb25SZXNvbHZlci5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMucmVhZHkpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnVuaXF1ZVN0cmluZyA9IGdldFVuaXF1ZVN0cmluZyh0aGlzLnN0ciwgdGhpcy5rZXlwYXRocyk7XG4gIFx0XHR0aGlzLmtleXBhdGggPSBjcmVhdGVFeHByZXNzaW9uS2V5cGF0aCh0aGlzLnVuaXF1ZVN0cmluZyk7XG5cbiAgXHRcdHRoaXMuY3JlYXRlRXZhbHVhdG9yKCk7XG4gIFx0XHR0aGlzLmNhbGxiYWNrKHRoaXMua2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHJlc29sdmVyO1xuXG4gIFx0XHR3aGlsZSAocmVzb2x2ZXIgPSB0aGlzLnJlZlJlc29sdmVycy5wb3AoKSkge1xuICBcdFx0XHRyZXNvbHZlci51bmJpbmQoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVzb2x2ZTogZnVuY3Rpb24gKGluZGV4LCBrZXlwYXRoKSB7XG4gIFx0XHR0aGlzLmtleXBhdGhzW2luZGV4XSA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLmJ1YmJsZSgpO1xuICBcdH0sXG5cbiAgXHRjcmVhdGVFdmFsdWF0b3I6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciBjb21wdXRhdGlvbiwgdmFsdWVHZXR0ZXJzLCBzaWduYXR1cmUsIGtleXBhdGgsIGZuO1xuXG4gIFx0XHRrZXlwYXRoID0gdGhpcy5rZXlwYXRoO1xuICBcdFx0Y29tcHV0YXRpb24gPSB0aGlzLnJvb3Qudmlld21vZGVsLmNvbXB1dGF0aW9uc1trZXlwYXRoLnN0cl07XG5cbiAgXHRcdC8vIG9ubHkgaWYgaXQgZG9lc24ndCBleGlzdCB5ZXQhXG4gIFx0XHRpZiAoIWNvbXB1dGF0aW9uKSB7XG4gIFx0XHRcdGZuID0gc2hhcmVkX2dldEZ1bmN0aW9uRnJvbVN0cmluZyh0aGlzLnN0ciwgdGhpcy5yZWZSZXNvbHZlcnMubGVuZ3RoKTtcblxuICBcdFx0XHR2YWx1ZUdldHRlcnMgPSB0aGlzLmtleXBhdGhzLm1hcChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRcdHZhciB2YWx1ZTtcblxuICBcdFx0XHRcdGlmIChrZXlwYXRoID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuICBcdFx0XHRcdFx0fTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyAnc3BlY2lhbCcga2V5cGF0aHMgZW5jb2RlIGEgdmFsdWVcbiAgXHRcdFx0XHRpZiAoa2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdFx0XHRcdHZhbHVlID0ga2V5cGF0aC52YWx1ZTtcbiAgXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcbiAgXHRcdFx0XHRcdH07XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdHZhciB2YWx1ZSA9IF90aGlzLnJvb3Qudmlld21vZGVsLmdldChrZXlwYXRoLCB7IG5vVW53cmFwOiB0cnVlLCBmdWxsUm9vdEdldDogdHJ1ZSB9KTtcbiAgXHRcdFx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRcdFx0XHR2YWx1ZSA9IHdyYXBGdW5jdGlvbih2YWx1ZSwgX3RoaXMucm9vdCk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0XHRcdFx0fTtcbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0c2lnbmF0dXJlID0ge1xuICBcdFx0XHRcdGRlcHM6IHRoaXMua2V5cGF0aHMuZmlsdGVyKGlzVmFsaWREZXBlbmRlbmN5KSxcbiAgXHRcdFx0XHRnZXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdHZhciBhcmdzID0gdmFsdWVHZXR0ZXJzLm1hcChjYWxsKTtcbiAgXHRcdFx0XHRcdHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0Y29tcHV0YXRpb24gPSB0aGlzLnJvb3Qudmlld21vZGVsLmNvbXB1dGUoa2V5cGF0aCwgc2lnbmF0dXJlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwubWFyayhrZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0Ly8gVE9ETyBvbmx5IGJ1YmJsZSBvbmNlLCBubyBtYXR0ZXIgaG93IG1hbnkgcmVmZXJlbmNlcyBhcmUgYWZmZWN0ZWQgYnkgdGhlIHJlYmluZFxuICBcdFx0dGhpcy5yZWZSZXNvbHZlcnMuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICBcdFx0XHRyZXR1cm4gci5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIFJlc29sdmVyc19FeHByZXNzaW9uUmVzb2x2ZXIgPSBFeHByZXNzaW9uUmVzb2x2ZXI7XG5cbiAgZnVuY3Rpb24gY2FsbCh2YWx1ZSkge1xuICBcdHJldHVybiB2YWx1ZS5jYWxsKCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRVbmlxdWVTdHJpbmcoc3RyLCBrZXlwYXRocykge1xuICBcdC8vIGdldCBzdHJpbmcgdGhhdCBpcyB1bmlxdWUgdG8gdGhpcyBleHByZXNzaW9uXG4gIFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9fKFswLTldKykvZywgZnVuY3Rpb24gKG1hdGNoLCAkMSkge1xuICBcdFx0dmFyIGtleXBhdGgsIHZhbHVlO1xuXG4gIFx0XHQvLyBtYWtlIHN1cmUgd2UncmUgbm90IHJlcGxhY2luZyBhIG5vbi1rZXlwYXRoIF9bMC05XVxuICBcdFx0aWYgKCskMSA+PSBrZXlwYXRocy5sZW5ndGgpIHtcbiAgXHRcdFx0cmV0dXJuIFwiX1wiICsgJDE7XG4gIFx0XHR9XG5cbiAgXHRcdGtleXBhdGggPSBrZXlwYXRoc1skMV07XG5cbiAgXHRcdGlmIChrZXlwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChrZXlwYXRoLmlzU3BlY2lhbCkge1xuICBcdFx0XHR2YWx1ZSA9IGtleXBhdGgudmFsdWU7XG4gIFx0XHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgPyB2YWx1ZSA6IFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIjtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGtleXBhdGguc3RyO1xuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRXhwcmVzc2lvbktleXBhdGgodW5pcXVlU3RyaW5nKSB7XG4gIFx0Ly8gU2FuaXRpemUgYnkgcmVtb3ZpbmcgYW55IHBlcmlvZHMgb3Igc3F1YXJlIGJyYWNrZXRzLiBPdGhlcndpc2VcbiAgXHQvLyB3ZSBjYW4ndCBzcGxpdCB0aGUga2V5cGF0aCBpbnRvIGtleXMhXG4gIFx0Ly8gUmVtb3ZlIGFzdGVyaXNrcyB0b28sIHNpbmNlIHRoZXkgbWVzcyB3aXRoIHBhdHRlcm4gb2JzZXJ2ZXJzXG4gIFx0cmV0dXJuIGdldEtleXBhdGgoXCIke1wiICsgdW5pcXVlU3RyaW5nLnJlcGxhY2UoL1tcXC5cXFtcXF1dL2csIFwiLVwiKS5yZXBsYWNlKC9cXCovLCBcIiNNVUwjXCIpICsgXCJ9XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNWYWxpZERlcGVuZGVuY3koa2V5cGF0aCkge1xuICBcdHJldHVybiBrZXlwYXRoICE9PSB1bmRlZmluZWQgJiYga2V5cGF0aFswXSAhPT0gXCJAXCI7XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwRnVuY3Rpb24oZm4sIHJhY3RpdmUpIHtcbiAgXHR2YXIgd3JhcHBlZCwgcHJvcCwga2V5O1xuXG4gIFx0aWYgKGZuLl9fcmFjdGl2ZV9ub3dyYXApIHtcbiAgXHRcdHJldHVybiBmbjtcbiAgXHR9XG5cbiAgXHRwcm9wID0gXCJfX3JhY3RpdmVfXCIgKyByYWN0aXZlLl9ndWlkO1xuICBcdHdyYXBwZWQgPSBmbltwcm9wXTtcblxuICBcdGlmICh3cmFwcGVkKSB7XG4gIFx0XHRyZXR1cm4gd3JhcHBlZDtcbiAgXHR9IGVsc2UgaWYgKC90aGlzLy50ZXN0KGZuLnRvU3RyaW5nKCkpKSB7XG4gIFx0XHRkZWZpbmVQcm9wZXJ0eShmbiwgcHJvcCwge1xuICBcdFx0XHR2YWx1ZTogUmVzb2x2ZXJzX0V4cHJlc3Npb25SZXNvbHZlcl9fYmluZC5jYWxsKGZuLCByYWN0aXZlKSxcbiAgXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG4gIFx0XHR9KTtcblxuICBcdFx0Ly8gQWRkIHByb3BlcnRpZXMvbWV0aG9kcyB0byB3cmFwcGVkIGZ1bmN0aW9uXG4gIFx0XHRmb3IgKGtleSBpbiBmbikge1xuICBcdFx0XHRpZiAoZm4uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBcdFx0XHRcdGZuW3Byb3BdW2tleV0gPSBmbltrZXldO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJhY3RpdmUuX2JvdW5kRnVuY3Rpb25zLnB1c2goe1xuICBcdFx0XHRmbjogZm4sXG4gIFx0XHRcdHByb3A6IHByb3BcbiAgXHRcdH0pO1xuXG4gIFx0XHRyZXR1cm4gZm5bcHJvcF07XG4gIFx0fVxuXG4gIFx0ZGVmaW5lUHJvcGVydHkoZm4sIFwiX19yYWN0aXZlX25vd3JhcFwiLCB7XG4gIFx0XHR2YWx1ZTogZm5cbiAgXHR9KTtcblxuICBcdHJldHVybiBmbi5fX3JhY3RpdmVfbm93cmFwO1xuICB9XG5cbiAgdmFyIE1lbWJlclJlc29sdmVyID0gZnVuY3Rpb24gKHRlbXBsYXRlLCByZXNvbHZlciwgcGFyZW50RnJhZ21lbnQpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dGhpcy5yZXNvbHZlciA9IHJlc29sdmVyO1xuICBcdHRoaXMucm9vdCA9IHJlc29sdmVyLnJvb3Q7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMudmlld21vZGVsID0gcmVzb2x2ZXIucm9vdC52aWV3bW9kZWw7XG5cbiAgXHRpZiAodHlwZW9mIHRlbXBsYXRlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHR0aGlzLnZhbHVlID0gdGVtcGxhdGU7XG4gIFx0fVxuXG4gIFx0Ly8gU2ltcGxlIHJlZmVyZW5jZT9cbiAgXHRlbHNlIGlmICh0ZW1wbGF0ZS50ID09PSBSRUZFUkVOQ0UpIHtcbiAgXHRcdHRoaXMucmVmUmVzb2x2ZXIgPSBSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIodGhpcywgdGVtcGxhdGUubiwgZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0X3RoaXMucmVzb2x2ZShrZXlwYXRoKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdC8vIE90aGVyd2lzZSB3ZSBoYXZlIGFuIGV4cHJlc3Npb24gaW4gaXRzIG93biByaWdodFxuICBcdGVsc2Uge1xuICBcdFx0bmV3IFJlc29sdmVyc19FeHByZXNzaW9uUmVzb2x2ZXIocmVzb2x2ZXIsIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZSwgZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0X3RoaXMucmVzb2x2ZShrZXlwYXRoKTtcbiAgXHRcdH0pO1xuICBcdH1cbiAgfTtcblxuICBNZW1iZXJSZXNvbHZlci5wcm90b3R5cGUgPSB7XG4gIFx0cmVzb2x2ZTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGlmICh0aGlzLmtleXBhdGgpIHtcbiAgXHRcdFx0dGhpcy52aWV3bW9kZWwudW5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdFx0dGhpcy52YWx1ZSA9IHRoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdFx0dGhpcy5iaW5kKCk7XG5cbiAgXHRcdHRoaXMucmVzb2x2ZXIuYnViYmxlKCk7XG4gIFx0fSxcblxuICBcdGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMudmlld21vZGVsLnJlZ2lzdGVyKHRoaXMua2V5cGF0aCwgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdGlmICh0aGlzLnJlZlJlc29sdmVyKSB7XG4gIFx0XHRcdHRoaXMucmVmUmVzb2x2ZXIucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG4gIFx0XHR0aGlzLnJlc29sdmVyLmJ1YmJsZSgpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmtleXBhdGgpIHtcbiAgXHRcdFx0dGhpcy52aWV3bW9kZWwudW5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5yZWZSZXNvbHZlcikge1xuICBcdFx0XHR0aGlzLnJlZlJlc29sdmVyLnVuYmluZCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLnJlZlJlc29sdmVyKSB7XG4gIFx0XHRcdHRoaXMucmVmUmVzb2x2ZXIuZm9yY2VSZXNvbHV0aW9uKCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfTWVtYmVyUmVzb2x2ZXIgPSBNZW1iZXJSZXNvbHZlcjtcblxuICB2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24gKG11c3RhY2hlLCB0ZW1wbGF0ZSwgY2FsbGJhY2spIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHJhY3RpdmUsIHJlZiwga2V5cGF0aCwgcGFyZW50RnJhZ21lbnQ7XG5cbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQgPSBtdXN0YWNoZS5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlID0gbXVzdGFjaGUucm9vdDtcbiAgXHR0aGlzLm11c3RhY2hlID0gbXVzdGFjaGU7XG5cbiAgXHR0aGlzLnJlZiA9IHJlZiA9IHRlbXBsYXRlLnI7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIFx0dGhpcy51bnJlc29sdmVkID0gW107XG5cbiAgXHQvLyBGaW5kIGJhc2Uga2V5cGF0aFxuICBcdGlmIChrZXlwYXRoID0gc2hhcmVkX3Jlc29sdmVSZWYocmFjdGl2ZSwgcmVmLCBwYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdHRoaXMuYmFzZSA9IGtleXBhdGg7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHRoaXMuYmFzZVJlc29sdmVyID0gbmV3IFJlc29sdmVyc19SZWZlcmVuY2VSZXNvbHZlcih0aGlzLCByZWYsIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdF90aGlzLmJhc2UgPSBrZXlwYXRoO1xuICBcdFx0XHRfdGhpcy5iYXNlUmVzb2x2ZXIgPSBudWxsO1xuICBcdFx0XHRfdGhpcy5idWJibGUoKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdC8vIEZpbmQgdmFsdWVzIGZvciBtZW1iZXJzLCBvciBtYXJrIHRoZW0gYXMgdW5yZXNvbHZlZFxuICBcdHRoaXMubWVtYmVycyA9IHRlbXBsYXRlLm0ubWFwKGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICBcdFx0cmV0dXJuIG5ldyBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfTWVtYmVyUmVzb2x2ZXIodGVtcGxhdGUsIF90aGlzLCBwYXJlbnRGcmFnbWVudCk7XG4gIFx0fSk7XG5cbiAgXHR0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgXHR0aGlzLmJ1YmJsZSgpOyAvLyB0cmlnZ2VyIGluaXRpYWwgcmVzb2x1dGlvbiBpZiBwb3NzaWJsZVxuICB9O1xuXG4gIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlci5wcm90b3R5cGUgPSB7XG4gIFx0Z2V0S2V5cGF0aDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHZhbHVlcyA9IHRoaXMubWVtYmVycy5tYXAoUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9fZ2V0VmFsdWUpO1xuXG4gIFx0XHRpZiAoIXZhbHVlcy5ldmVyeShpc0RlZmluZWQpIHx8IHRoaXMuYmFzZVJlc29sdmVyKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5iYXNlLmpvaW4odmFsdWVzLmpvaW4oXCIuXCIpKTtcbiAgXHR9LFxuXG4gIFx0YnViYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMucmVhZHkgfHwgdGhpcy5iYXNlUmVzb2x2ZXIpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmNhbGxiYWNrKHRoaXMuZ2V0S2V5cGF0aCgpKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHR2YXIgY2hhbmdlZDtcblxuICBcdFx0aWYgKHRoaXMuYmFzZSkge1xuICBcdFx0XHR2YXIgbmV3QmFzZSA9IHRoaXMuYmFzZS5yZXBsYWNlKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0XHRpZiAobmV3QmFzZSAmJiBuZXdCYXNlICE9PSB0aGlzLmJhc2UpIHtcbiAgXHRcdFx0XHR0aGlzLmJhc2UgPSBuZXdCYXNlO1xuICBcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMubWVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChtZW1iZXJzKSB7XG4gIFx0XHRcdGlmIChtZW1iZXJzLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSkge1xuICBcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKGNoYW5nZWQpIHtcbiAgXHRcdFx0dGhpcy5idWJibGUoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5iYXNlUmVzb2x2ZXIpIHtcbiAgXHRcdFx0dGhpcy5iYXNlID0gZ2V0S2V5cGF0aCh0aGlzLnJlZik7XG5cbiAgXHRcdFx0dGhpcy5iYXNlUmVzb2x2ZXIudW5iaW5kKCk7XG4gIFx0XHRcdHRoaXMuYmFzZVJlc29sdmVyID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5tZW1iZXJzLmZvckVhY2goZm9yY2VSZXNvbHV0aW9uKTtcbiAgXHRcdHRoaXMuYnViYmxlKCk7XG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfX2dldFZhbHVlKG1lbWJlcikge1xuICBcdHJldHVybiBtZW1iZXIudmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgXHRyZXR1cm4gdmFsdWUgIT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9yY2VSZXNvbHV0aW9uKG1lbWJlcikge1xuICBcdG1lbWJlci5mb3JjZVJlc29sdXRpb24oKTtcbiAgfVxuXG4gIHZhciBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyID0gUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyO1xuXG4gIHZhciBNdXN0YWNoZV9pbml0aWFsaXNlID0gTXVzdGFjaGUkaW5pdDtcbiAgZnVuY3Rpb24gTXVzdGFjaGUkaW5pdChtdXN0YWNoZSwgb3B0aW9ucykge1xuXG4gIFx0dmFyIHJlZiwgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlO1xuXG4gIFx0cGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuICBcdHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblxuICBcdG11c3RhY2hlLnJvb3QgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuICBcdG11c3RhY2hlLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG4gIFx0bXVzdGFjaGUucEVsZW1lbnQgPSBwYXJlbnRGcmFnbWVudC5wRWxlbWVudDtcblxuICBcdG11c3RhY2hlLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgXHRtdXN0YWNoZS5pbmRleCA9IG9wdGlvbnMuaW5kZXggfHwgMDtcbiAgXHRtdXN0YWNoZS5pc1N0YXRpYyA9IG9wdGlvbnMudGVtcGxhdGUucztcblxuICBcdG11c3RhY2hlLnR5cGUgPSBvcHRpb25zLnRlbXBsYXRlLnQ7XG5cbiAgXHRtdXN0YWNoZS5yZWdpc3RlcmVkID0gZmFsc2U7XG5cbiAgXHQvLyBpZiB0aGlzIGlzIGEgc2ltcGxlIG11c3RhY2hlLCB3aXRoIGEgcmVmZXJlbmNlLCB3ZSBqdXN0IG5lZWQgdG8gcmVzb2x2ZVxuICBcdC8vIHRoZSByZWZlcmVuY2UgdG8gYSBrZXlwYXRoXG4gIFx0aWYgKHJlZiA9IHRlbXBsYXRlLnIpIHtcbiAgXHRcdG11c3RhY2hlLnJlc29sdmVyID0gUmVzb2x2ZXJzX2NyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKG11c3RhY2hlLCByZWYsIHJlc29sdmUpO1xuICBcdH1cblxuICBcdC8vIGlmIGl0J3MgYW4gZXhwcmVzc2lvbiwgd2UgaGF2ZSBhIGJpdCBtb3JlIHdvcmsgdG8gZG9cbiAgXHRpZiAob3B0aW9ucy50ZW1wbGF0ZS54KSB7XG4gIFx0XHRtdXN0YWNoZS5yZXNvbHZlciA9IG5ldyBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyKG11c3RhY2hlLCBwYXJlbnRGcmFnbWVudCwgb3B0aW9ucy50ZW1wbGF0ZS54LCByZXNvbHZlQW5kUmViaW5kQ2hpbGRyZW4pO1xuICBcdH1cblxuICBcdGlmIChvcHRpb25zLnRlbXBsYXRlLnJ4KSB7XG4gIFx0XHRtdXN0YWNoZS5yZXNvbHZlciA9IG5ldyBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyKG11c3RhY2hlLCBvcHRpb25zLnRlbXBsYXRlLnJ4LCByZXNvbHZlQW5kUmViaW5kQ2hpbGRyZW4pO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIGludmVydGVkIHNlY3Rpb25zXG4gIFx0aWYgKG11c3RhY2hlLnRlbXBsYXRlLm4gPT09IFNFQ1RJT05fVU5MRVNTICYmICFtdXN0YWNoZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKSB7XG4gIFx0XHRtdXN0YWNoZS5zZXRWYWx1ZSh1bmRlZmluZWQpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIHJlc29sdmUoa2V5cGF0aCkge1xuICBcdFx0bXVzdGFjaGUucmVzb2x2ZShrZXlwYXRoKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiByZXNvbHZlQW5kUmViaW5kQ2hpbGRyZW4obmV3S2V5cGF0aCkge1xuICBcdFx0dmFyIG9sZEtleXBhdGggPSBtdXN0YWNoZS5rZXlwYXRoO1xuXG4gIFx0XHRpZiAobmV3S2V5cGF0aCAhPSBvbGRLZXlwYXRoKSB7XG4gIFx0XHRcdG11c3RhY2hlLnJlc29sdmUobmV3S2V5cGF0aCk7XG5cbiAgXHRcdFx0aWYgKG9sZEtleXBhdGggIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdG11c3RhY2hlLmZyYWdtZW50cyAmJiBtdXN0YWNoZS5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICBcdFx0XHRcdFx0Zi5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHRcdFx0fSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgTXVzdGFjaGVfcmVzb2x2ZSA9IE11c3RhY2hlJHJlc29sdmU7XG5cbiAgZnVuY3Rpb24gTXVzdGFjaGUkcmVzb2x2ZShrZXlwYXRoKSB7XG4gIFx0dmFyIHdhc1Jlc29sdmVkLCB2YWx1ZSwgdHdvd2F5QmluZGluZztcblxuICBcdC8vICdTcGVjaWFsJyBrZXlwYXRocywgZS5nLiBAZm9vIG9yIEA3LCBlbmNvZGUgYSB2YWx1ZVxuICBcdGlmIChrZXlwYXRoICYmIGtleXBhdGguaXNTcGVjaWFsKSB7XG4gIFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdFx0dGhpcy5zZXRWYWx1ZShrZXlwYXRoLnZhbHVlKTtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBJZiB3ZSByZXNvbHZlZCBwcmV2aW91c2x5LCB3ZSBuZWVkIHRvIHVucmVnaXN0ZXJcbiAgXHRpZiAodGhpcy5yZWdpc3RlcmVkKSB7XG4gIFx0XHQvLyB1bmRlZmluZWQgb3IgbnVsbFxuICBcdFx0dGhpcy5yb290LnZpZXdtb2RlbC51bnJlZ2lzdGVyKHRoaXMua2V5cGF0aCwgdGhpcyk7XG4gIFx0XHR0aGlzLnJlZ2lzdGVyZWQgPSBmYWxzZTtcblxuICBcdFx0d2FzUmVzb2x2ZWQgPSB0cnVlO1xuICBcdH1cblxuICBcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cbiAgXHQvLyBJZiB0aGUgbmV3IGtleXBhdGggZXhpc3RzLCB3ZSBuZWVkIHRvIHJlZ2lzdGVyXG4gIFx0Ly8gd2l0aCB0aGUgdmlld21vZGVsXG4gIFx0aWYgKGtleXBhdGggIT0gdW5kZWZpbmVkKSB7XG4gIFx0XHQvLyB1bmRlZmluZWQgb3IgbnVsbFxuICBcdFx0dmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldChrZXlwYXRoKTtcbiAgXHRcdHRoaXMucm9vdC52aWV3bW9kZWwucmVnaXN0ZXIoa2V5cGF0aCwgdGhpcyk7XG5cbiAgXHRcdHRoaXMucmVnaXN0ZXJlZCA9IHRydWU7XG4gIFx0fVxuXG4gIFx0Ly8gRWl0aGVyIHdheSB3ZSBuZWVkIHRvIHF1ZXVlIHVwIGEgcmVuZGVyIChgdmFsdWVgXG4gIFx0Ly8gd2lsbCBiZSBgdW5kZWZpbmVkYCBpZiB0aGVyZSdzIG5vIGtleXBhdGgpXG4gIFx0dGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG5cbiAgXHQvLyBUd28td2F5IGJpbmRpbmdzIG5lZWQgdG8gcG9pbnQgdG8gdGhlaXIgbmV3IHRhcmdldCBrZXlwYXRoXG4gIFx0aWYgKHdhc1Jlc29sdmVkICYmICh0d293YXlCaW5kaW5nID0gdGhpcy50d293YXlCaW5kaW5nKSkge1xuICBcdFx0dHdvd2F5QmluZGluZy5yZWJvdW5kKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIE11c3RhY2hlX3JlYmluZCA9IE11c3RhY2hlJHJlYmluZDtcblxuICBmdW5jdGlvbiBNdXN0YWNoZSRyZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdC8vIENoaWxkcmVuIGZpcnN0XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnRzKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gIFx0XHRcdHJldHVybiBmLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdC8vIEV4cHJlc3Npb24gbXVzdGFjaGU/XG4gIFx0aWYgKHRoaXMucmVzb2x2ZXIpIHtcbiAgXHRcdHRoaXMucmVzb2x2ZXIucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBNdXN0YWNoZSA9IHtcbiAgXHRnZXRWYWx1ZTogTXVzdGFjaGVfZ2V0VmFsdWUsXG4gIFx0aW5pdDogTXVzdGFjaGVfaW5pdGlhbGlzZSxcbiAgXHRyZXNvbHZlOiBNdXN0YWNoZV9yZXNvbHZlLFxuICBcdHJlYmluZDogTXVzdGFjaGVfcmViaW5kXG4gIH07XG5cbiAgdmFyIEludGVycG9sYXRvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy50eXBlID0gSU5URVJQT0xBVE9SO1xuICBcdE11c3RhY2hlLmluaXQodGhpcywgb3B0aW9ucyk7XG4gIH07XG5cbiAgSW50ZXJwb2xhdG9yLnByb3RvdHlwZSA9IHtcbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMubm9kZS5kYXRhID0gdGhpcy52YWx1ZSA9PSB1bmRlZmluZWQgPyBcIlwiIDogdGhpcy52YWx1ZTtcbiAgXHR9LFxuICBcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG4gIFx0cmViaW5kOiBNdXN0YWNoZS5yZWJpbmQsXG4gIFx0ZGV0YWNoOiBzaGFyZWRfZGV0YWNoLFxuXG4gIFx0dW5iaW5kOiBzaGFyZWRfdW5iaW5kLFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMubm9kZSkge1xuICBcdFx0XHR0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzYWZlVG9TdHJpbmdWYWx1ZSh0aGlzLnZhbHVlKSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0aWYgKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdFx0ZGV0YWNoTm9kZSh0aGlzLm5vZGUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG5cbiAgXHQvLyBURU1QXG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0dmFyIHdyYXBwZXI7XG5cbiAgXHRcdC8vIFRPRE8gaXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGFwcHJvYWNoIHRoaXM/XG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoICYmICh3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkW3RoaXMua2V5cGF0aC5zdHJdKSkge1xuICBcdFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghaXNFcXVhbCh2YWx1ZSwgdGhpcy52YWx1ZSkpIHtcbiAgXHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICBcdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXG4gIFx0XHRcdGlmICh0aGlzLm5vZGUpIHtcbiAgXHRcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGZpcnN0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uIChlc2NhcGUpIHtcbiAgXHRcdHZhciBzdHJpbmcgPSBcIlwiICsgc2FmZVRvU3RyaW5nVmFsdWUodGhpcy52YWx1ZSk7XG4gIFx0XHRyZXR1cm4gZXNjYXBlID8gZXNjYXBlSHRtbChzdHJpbmcpIDogc3RyaW5nO1xuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfSW50ZXJwb2xhdG9yID0gSW50ZXJwb2xhdG9yO1xuXG4gIHZhciBTZWN0aW9uX3Byb3RvdHlwZV9idWJibGUgPSBTZWN0aW9uJGJ1YmJsZTtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGJ1YmJsZSgpIHtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuICB9XG5cbiAgdmFyIFNlY3Rpb25fcHJvdG90eXBlX2RldGFjaCA9IFNlY3Rpb24kZGV0YWNoO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZGV0YWNoKCkge1xuICBcdHZhciBkb2NGcmFnO1xuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA9PT0gMSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnRzWzBdLmRldGFjaCgpO1xuICBcdH1cblxuICBcdGRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgXHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHRkb2NGcmFnLmFwcGVuZENoaWxkKGl0ZW0uZGV0YWNoKCkpO1xuICBcdH0pO1xuXG4gIFx0cmV0dXJuIGRvY0ZyYWc7XG4gIH1cblxuICB2YXIgZmluZCA9IFNlY3Rpb24kZmluZDtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGZpbmQoc2VsZWN0b3IpIHtcbiAgXHR2YXIgaSwgbGVuLCBxdWVyeVJlc3VsdDtcblxuICBcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdGlmIChxdWVyeVJlc3VsdCA9IHRoaXMuZnJhZ21lbnRzW2ldLmZpbmQoc2VsZWN0b3IpKSB7XG4gIFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBmaW5kQWxsID0gU2VjdGlvbiRmaW5kQWxsO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmluZEFsbChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHR2YXIgaSwgbGVuO1xuXG4gIFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0dGhpcy5mcmFnbWVudHNbaV0uZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBmaW5kQWxsQ29tcG9uZW50cyA9IFNlY3Rpb24kZmluZEFsbENvbXBvbmVudHM7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRmaW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHR2YXIgaSwgbGVuO1xuXG4gIFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0dGhpcy5mcmFnbWVudHNbaV0uZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9XG4gIH1cblxuICB2YXIgZmluZENvbXBvbmVudCA9IFNlY3Rpb24kZmluZENvbXBvbmVudDtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGZpbmRDb21wb25lbnQoc2VsZWN0b3IpIHtcbiAgXHR2YXIgaSwgbGVuLCBxdWVyeVJlc3VsdDtcblxuICBcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdGlmIChxdWVyeVJlc3VsdCA9IHRoaXMuZnJhZ21lbnRzW2ldLmZpbmRDb21wb25lbnQoc2VsZWN0b3IpKSB7XG4gIFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBmaW5kTmV4dE5vZGUgPSBTZWN0aW9uJGZpbmROZXh0Tm9kZTtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGZpbmROZXh0Tm9kZShmcmFnbWVudCkge1xuICBcdGlmICh0aGlzLmZyYWdtZW50c1tmcmFnbWVudC5pbmRleCArIDFdKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudHNbZnJhZ21lbnQuaW5kZXggKyAxXS5maXJzdE5vZGUoKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIH1cblxuICB2YXIgZmlyc3ROb2RlID0gU2VjdGlvbiRmaXJzdE5vZGU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRmaXJzdE5vZGUoKSB7XG4gIFx0dmFyIGxlbiwgaSwgbm9kZTtcblxuICBcdGlmIChsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRpZiAobm9kZSA9IHRoaXMuZnJhZ21lbnRzW2ldLmZpcnN0Tm9kZSgpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIG5vZGU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIH1cblxuICB2YXIgc2h1ZmZsZSA9IFNlY3Rpb24kc2h1ZmZsZTtcblxuICBmdW5jdGlvbiBTZWN0aW9uJHNodWZmbGUobmV3SW5kaWNlcykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgcGFyZW50RnJhZ21lbnQsIGZpcnN0Q2hhbmdlLCBpLCBuZXdMZW5ndGgsIHJlYm91bmRGcmFnbWVudHMsIGZyYWdtZW50T3B0aW9ucywgZnJhZ21lbnQ7XG5cbiAgXHQvLyBzaG9ydCBjaXJjdWl0IGFueSBkb3VibGUtdXBkYXRlcywgYW5kIGVuc3VyZSB0aGF0IHRoaXMgaXNuJ3QgYXBwbGllZCB0b1xuICBcdC8vIG5vbi1saXN0IHNlY3Rpb25zXG4gIFx0aWYgKHRoaXMuc2h1ZmZsaW5nIHx8IHRoaXMudW5ib3VuZCB8fCB0aGlzLmN1cnJlbnRTdWJ0eXBlICE9PSBTRUNUSU9OX0VBQ0gpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHR0aGlzLnNodWZmbGluZyA9IHRydWU7XG4gIFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBfdGhpcy5zaHVmZmxpbmcgPSBmYWxzZTtcbiAgXHR9KTtcblxuICBcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudDtcblxuICBcdHJlYm91bmRGcmFnbWVudHMgPSBbXTtcblxuICBcdC8vIFRPRE86IG5lZWQgdG8gdXBkYXRlIHRoaXNcbiAgXHQvLyBmaXJzdCwgcmViaW5kIGV4aXN0aW5nIGZyYWdtZW50c1xuICBcdG5ld0luZGljZXMuZm9yRWFjaChmdW5jdGlvbiAobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gIFx0XHR2YXIgZnJhZ21lbnQsIGJ5LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoLCBkZXBzO1xuXG4gIFx0XHRpZiAobmV3SW5kZXggPT09IG9sZEluZGV4KSB7XG4gIFx0XHRcdHJlYm91bmRGcmFnbWVudHNbbmV3SW5kZXhdID0gX3RoaXMuZnJhZ21lbnRzW29sZEluZGV4XTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRmcmFnbWVudCA9IF90aGlzLmZyYWdtZW50c1tvbGRJbmRleF07XG5cbiAgXHRcdGlmIChmaXJzdENoYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdGZpcnN0Q2hhbmdlID0gb2xkSW5kZXg7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGRvZXMgdGhpcyBmcmFnbWVudCBuZWVkIHRvIGJlIHRvcm4gZG93bj9cbiAgXHRcdGlmIChuZXdJbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0X3RoaXMuZnJhZ21lbnRzVG9VbnJlbmRlci5wdXNoKGZyYWdtZW50KTtcbiAgXHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gT3RoZXJ3aXNlLCBpdCBuZWVkcyB0byBiZSByZWJvdW5kIHRvIGEgbmV3IGluZGV4XG4gIFx0XHRieSA9IG5ld0luZGV4IC0gb2xkSW5kZXg7XG4gIFx0XHRvbGRLZXlwYXRoID0gX3RoaXMua2V5cGF0aC5qb2luKG9sZEluZGV4KTtcbiAgXHRcdG5ld0tleXBhdGggPSBfdGhpcy5rZXlwYXRoLmpvaW4obmV3SW5kZXgpO1xuXG4gIFx0XHRmcmFnbWVudC5pbmRleCA9IG5ld0luZGV4O1xuXG4gIFx0XHQvLyBub3RpZnkgYW55IHJlZ2lzdGVyZWQgaW5kZXggcmVmcyBkaXJlY3RseVxuICBcdFx0aWYgKGRlcHMgPSBmcmFnbWVudC5yZWdpc3RlcmVkSW5kZXhSZWZzKSB7XG4gIFx0XHRcdGRlcHMuZm9yRWFjaChzaHVmZmxlX19ibGluZFJlYmluZCk7XG4gIFx0XHR9XG5cbiAgXHRcdGZyYWdtZW50LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdHJlYm91bmRGcmFnbWVudHNbbmV3SW5kZXhdID0gZnJhZ21lbnQ7XG4gIFx0fSk7XG5cbiAgXHRuZXdMZW5ndGggPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLmtleXBhdGgpLmxlbmd0aDtcblxuICBcdC8vIElmIG5vdGhpbmcgY2hhbmdlZCB3aXRoIHRoZSBleGlzdGluZyBmcmFnbWVudHMsIHRoZW4gd2Ugc3RhcnQgYWRkaW5nXG4gIFx0Ly8gbmV3IGZyYWdtZW50cyBhdCB0aGUgZW5kLi4uXG4gIFx0aWYgKGZpcnN0Q2hhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdC8vIC4uLnVubGVzcyB0aGVyZSBhcmUgbm8gbmV3IGZyYWdtZW50cyB0byBhZGRcbiAgXHRcdGlmICh0aGlzLmxlbmd0aCA9PT0gbmV3TGVuZ3RoKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Zmlyc3RDaGFuZ2UgPSB0aGlzLmxlbmd0aDtcbiAgXHR9XG5cbiAgXHR0aGlzLmxlbmd0aCA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA9IG5ld0xlbmd0aDtcblxuICBcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdH1cblxuICBcdC8vIFByZXBhcmUgbmV3IGZyYWdtZW50IG9wdGlvbnNcbiAgXHRmcmFnbWVudE9wdGlvbnMgPSB7XG4gIFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZS5mLFxuICBcdFx0cm9vdDogdGhpcy5yb290LFxuICBcdFx0b3duZXI6IHRoaXNcbiAgXHR9O1xuXG4gIFx0Ly8gQWRkIGFzIG1hbnkgbmV3IGZyYWdtZW50cyBhcyB3ZSBuZWVkIHRvLCBvciBhZGQgYmFjayBleGlzdGluZ1xuICBcdC8vIChkZXRhY2hlZCkgZnJhZ21lbnRzXG4gIFx0Zm9yIChpID0gZmlyc3RDaGFuZ2U7IGkgPCBuZXdMZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0ZnJhZ21lbnQgPSByZWJvdW5kRnJhZ21lbnRzW2ldO1xuXG4gIFx0XHRpZiAoIWZyYWdtZW50KSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUucHVzaChpKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5mcmFnbWVudHNbaV0gPSBmcmFnbWVudDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBzaHVmZmxlX19ibGluZFJlYmluZChkZXApIHtcbiAgXHQvLyB0aGUga2V5cGF0aCBkb2Vzbid0IGFjdHVhbGx5IG1hdHRlciBoZXJlIGFzIGl0IHdvbid0IGhhdmUgY2hhbmdlZFxuICBcdGRlcC5yZWJpbmQoXCJcIiwgXCJcIik7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3JlYmluZCA9IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0TXVzdGFjaGUucmViaW5kLmNhbGwodGhpcywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIH07XG5cbiAgdmFyIFNlY3Rpb25fcHJvdG90eXBlX3JlbmRlciA9IFNlY3Rpb24kcmVuZGVyO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kcmVuZGVyKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR0aGlzLmRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgXHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gIFx0XHRyZXR1cm4gX3RoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZChmLnJlbmRlcigpKTtcbiAgXHR9KTtcblxuICBcdHRoaXMucmVuZGVyZWRGcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cy5zbGljZSgpO1xuICBcdHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIgPSBbXTtcblxuICBcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdHJldHVybiB0aGlzLmRvY0ZyYWc7XG4gIH1cblxuICB2YXIgc2V0VmFsdWUgPSBTZWN0aW9uJHNldFZhbHVlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kc2V0VmFsdWUodmFsdWUpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHdyYXBwZXIsIGZyYWdtZW50T3B0aW9ucztcblxuICBcdGlmICh0aGlzLnVwZGF0aW5nKSB7XG4gIFx0XHQvLyBJZiBhIGNoaWxkIG9mIHRoaXMgc2VjdGlvbiBjYXVzZXMgYSByZS1ldmFsdWF0aW9uIC0gZm9yIGV4YW1wbGUsIGFuXG4gIFx0XHQvLyBleHByZXNzaW9uIHJlZmVycyB0byBhIGZ1bmN0aW9uIHRoYXQgbXV0YXRlcyB0aGUgYXJyYXkgdGhhdCB0aGlzXG4gIFx0XHQvLyBzZWN0aW9uIGRlcGVuZHMgb24gLSB3ZSdsbCBlbmQgdXAgd2l0aCBhIGRvdWJsZSByZW5kZXJpbmcgYnVnIChzZWVcbiAgXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMvNzQ4KS4gVGhpcyBwcmV2ZW50cyBpdC5cbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblxuICBcdC8vIHdpdGggc2VjdGlvbnMsIHdlIG5lZWQgdG8gZ2V0IHRoZSBmYWtlIHZhbHVlIGlmIHdlIGhhdmUgYSB3cmFwcGVkIG9iamVjdFxuICBcdGlmICh0aGlzLmtleXBhdGggJiYgKHdyYXBwZXIgPSB0aGlzLnJvb3Qudmlld21vZGVsLndyYXBwZWRbdGhpcy5rZXlwYXRoLnN0cl0pKSB7XG4gIFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG4gIFx0fVxuXG4gIFx0Ly8gSWYgYW55IGZyYWdtZW50cyBhcmUgYXdhaXRpbmcgY3JlYXRpb24gYWZ0ZXIgYSBzcGxpY2UsXG4gIFx0Ly8gdGhpcyBpcyB0aGUgcGxhY2UgdG8gZG8gaXRcbiAgXHRpZiAodGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5sZW5ndGgpIHtcbiAgXHRcdGZyYWdtZW50T3B0aW9ucyA9IHtcbiAgXHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUuZiB8fCBbXSxcbiAgXHRcdFx0cm9vdDogdGhpcy5yb290LFxuICBcdFx0XHRwRWxlbWVudDogdGhpcy5wRWxlbWVudCxcbiAgXHRcdFx0b3duZXI6IHRoaXNcbiAgXHRcdH07XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgXHRcdFx0dmFyIGZyYWdtZW50O1xuXG4gIFx0XHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gX3RoaXMua2V5cGF0aC5qb2luKGluZGV4KTtcbiAgXHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gaW5kZXg7XG5cbiAgXHRcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudChmcmFnbWVudE9wdGlvbnMpO1xuICBcdFx0XHRfdGhpcy5mcmFnbWVudHNUb1JlbmRlci5wdXNoKF90aGlzLmZyYWdtZW50c1tpbmRleF0gPSBmcmFnbWVudCk7XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5sZW5ndGggPSAwO1xuICBcdH0gZWxzZSBpZiAocmVldmFsdWF0ZVNlY3Rpb24odGhpcywgdmFsdWUpKSB7XG4gIFx0XHR0aGlzLmJ1YmJsZSgpO1xuXG4gIFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgXHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjaGFuZ2VDdXJyZW50U3VidHlwZShzZWN0aW9uLCB2YWx1ZSwgb2JqKSB7XG4gIFx0aWYgKHZhbHVlID09PSBTRUNUSU9OX0VBQ0gpIHtcbiAgXHRcdC8vIG1ha2Ugc3VyZSByZWYgdHlwZSBpcyB1cCB0byBkYXRlIGZvciBrZXkgb3IgdmFsdWUgaW5kaWNlc1xuICBcdFx0aWYgKHNlY3Rpb24uaW5kZXhSZWZzICYmIHNlY3Rpb24uaW5kZXhSZWZzWzBdKSB7XG4gIFx0XHRcdHZhciByZWYgPSBzZWN0aW9uLmluZGV4UmVmc1swXTtcblxuICBcdFx0XHQvLyB3aGVuIHN3aXRjaGluZyBmbGF2b3JzLCBtYWtlIHN1cmUgdGhlIHNlY3Rpb24gZ2V0cyB1cGRhdGVkXG4gIFx0XHRcdGlmIChvYmogJiYgcmVmLnQgPT09IFwiaVwiIHx8ICFvYmogJiYgcmVmLnQgPT09IFwia1wiKSB7XG4gIFx0XHRcdFx0Ly8gaWYgc3dpdGNoaW5nIGZyb20gb2JqZWN0IHRvIGxpc3QsIHVuYmluZCBhbGwgb2YgdGhlIG9sZCBmcmFnbWVudHNcbiAgXHRcdFx0XHRpZiAoIW9iaikge1xuICBcdFx0XHRcdFx0c2VjdGlvbi5sZW5ndGggPSAwO1xuICBcdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyID0gc2VjdGlvbi5mcmFnbWVudHMuc2xpY2UoMCk7XG4gIFx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICBcdFx0XHRcdFx0XHRyZXR1cm4gZi51bmJpbmQoKTtcbiAgXHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJlZi50ID0gb2JqID8gXCJrXCIgOiBcImlcIjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRzZWN0aW9uLmN1cnJlbnRTdWJ0eXBlID0gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiByZWV2YWx1YXRlU2VjdGlvbihzZWN0aW9uLCB2YWx1ZSkge1xuICBcdHZhciBmcmFnbWVudE9wdGlvbnMgPSB7XG4gIFx0XHR0ZW1wbGF0ZTogc2VjdGlvbi50ZW1wbGF0ZS5mIHx8IFtdLFxuICBcdFx0cm9vdDogc2VjdGlvbi5yb290LFxuICBcdFx0cEVsZW1lbnQ6IHNlY3Rpb24ucGFyZW50RnJhZ21lbnQucEVsZW1lbnQsXG4gIFx0XHRvd25lcjogc2VjdGlvblxuICBcdH07XG5cbiAgXHRzZWN0aW9uLmhhc0NvbnRleHQgPSB0cnVlO1xuXG4gIFx0Ly8gSWYgd2UgYWxyZWFkeSBrbm93IHRoZSBzZWN0aW9uIHR5cGUsIGdyZWF0XG4gIFx0Ly8gVE9ETyBjYW4gdGhpcyBiZSBvcHRpbWlzZWQ/IGkuZS4gcGljayBhbiByZWV2YWx1YXRlU2VjdGlvbiBmdW5jdGlvbiBkdXJpbmcgaW5pdFxuICBcdC8vIGFuZCBhdm9pZCBkb2luZyB0aGlzIGVhY2ggdGltZT9cbiAgXHRpZiAoc2VjdGlvbi5zdWJ0eXBlKSB7XG4gIFx0XHRzd2l0Y2ggKHNlY3Rpb24uc3VidHlwZSkge1xuICBcdFx0XHRjYXNlIFNFQ1RJT05fSUY6XG4gIFx0XHRcdFx0c2VjdGlvbi5oYXNDb250ZXh0ID0gZmFsc2U7XG4gIFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZhbHNlLCBmcmFnbWVudE9wdGlvbnMpO1xuXG4gIFx0XHRcdGNhc2UgU0VDVElPTl9VTkxFU1M6XG4gIFx0XHRcdFx0c2VjdGlvbi5oYXNDb250ZXh0ID0gZmFsc2U7XG4gIFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIHRydWUsIGZyYWdtZW50T3B0aW9ucyk7XG5cbiAgXHRcdFx0Y2FzZSBTRUNUSU9OX1dJVEg6XG4gIFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbihzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMpO1xuXG4gIFx0XHRcdGNhc2UgU0VDVElPTl9JRl9XSVRIOlxuICBcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxDb250ZXh0U2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0XHRjYXNlIFNFQ1RJT05fRUFDSDpcbiAgXHRcdFx0XHRpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gIFx0XHRcdFx0XHRjaGFuZ2VDdXJyZW50U3VidHlwZShzZWN0aW9uLCBzZWN0aW9uLnN1YnR5cGUsIHRydWUpO1xuICBcdFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVMaXN0T2JqZWN0U2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyBGYWxsdGhyb3VnaCAtIGlmIGl0J3MgYSBjb25kaXRpb25hbCBvciBhbiBhcnJheSB3ZSBuZWVkIHRvIGNvbnRpbnVlXG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gd29yayBvdXQgd2hhdCBzb3J0IG9mIHNlY3Rpb24gd2UncmUgZGVhbGluZyB3aXRoXG4gIFx0c2VjdGlvbi5vcmRlcmVkID0gISFpc0FycmF5TGlrZSh2YWx1ZSk7XG5cbiAgXHQvLyBPcmRlcmVkIGxpc3Qgc2VjdGlvblxuICBcdGlmIChzZWN0aW9uLm9yZGVyZWQpIHtcbiAgXHRcdGNoYW5nZUN1cnJlbnRTdWJ0eXBlKHNlY3Rpb24sIFNFQ1RJT05fRUFDSCwgZmFsc2UpO1xuICBcdFx0cmV0dXJuIHJlZXZhbHVhdGVMaXN0U2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zKTtcbiAgXHR9XG5cbiAgXHQvLyBVbm9yZGVyZWQgbGlzdCwgb3IgY29udGV4dFxuICBcdGlmIChpc09iamVjdCh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdC8vIEluZGV4IHJlZmVyZW5jZSBpbmRpY2F0ZXMgc2VjdGlvbiBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIGxpc3RcbiAgXHRcdGlmIChzZWN0aW9uLnRlbXBsYXRlLmkpIHtcbiAgXHRcdFx0Y2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgU0VDVElPTl9FQUNILCB0cnVlKTtcbiAgXHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVMaXN0T2JqZWN0U2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gT3RoZXJ3aXNlLCBvYmplY3QgcHJvdmlkZXMgY29udGV4dCBmb3IgY29udGVudHNcbiAgXHRcdGNoYW5nZUN1cnJlbnRTdWJ0eXBlKHNlY3Rpb24sIFNFQ1RJT05fV0lUSCwgZmFsc2UpO1xuICBcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbihzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMpO1xuICBcdH1cblxuICBcdC8vIENvbmRpdGlvbmFsIHNlY3Rpb25cbiAgXHRjaGFuZ2VDdXJyZW50U3VidHlwZShzZWN0aW9uLCBTRUNUSU9OX0lGLCBmYWxzZSk7XG4gIFx0c2VjdGlvbi5oYXNDb250ZXh0ID0gZmFsc2U7XG4gIFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZhbHNlLCBmcmFnbWVudE9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZUxpc3RTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpIHtcbiAgXHR2YXIgaSwgbGVuZ3RoLCBmcmFnbWVudDtcblxuICBcdGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICBcdGlmIChsZW5ndGggPT09IHNlY3Rpb24ubGVuZ3RoKSB7XG4gIFx0XHQvLyBOb3RoaW5nIHRvIGRvXG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgdGhlIGFycmF5IGlzIHNob3J0ZXIgdGhhbiBpdCB3YXMgcHJldmlvdXNseSwgcmVtb3ZlIGl0ZW1zXG4gIFx0aWYgKGxlbmd0aCA8IHNlY3Rpb24ubGVuZ3RoKSB7XG4gIFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UobGVuZ3RoLCBzZWN0aW9uLmxlbmd0aCAtIGxlbmd0aCk7XG4gIFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdH1cblxuICBcdC8vIG90aGVyd2lzZS4uLlxuICBcdGVsc2Uge1xuICBcdFx0aWYgKGxlbmd0aCA+IHNlY3Rpb24ubGVuZ3RoKSB7XG4gIFx0XHRcdC8vIGFkZCBhbnkgbmV3IG9uZXNcbiAgXHRcdFx0Zm9yIChpID0gc2VjdGlvbi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0XHRcdC8vIGFwcGVuZCBsaXN0IGl0ZW0gdG8gY29udGV4dCBzdGFja1xuICBcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gc2VjdGlvbi5rZXlwYXRoLmpvaW4oaSk7XG4gIFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gaTtcblxuICBcdFx0XHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoZnJhZ21lbnRPcHRpb25zKTtcbiAgXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goc2VjdGlvbi5mcmFnbWVudHNbaV0gPSBmcmFnbWVudCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRzZWN0aW9uLmxlbmd0aCA9IGxlbmd0aDtcbiAgXHRyZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVMaXN0T2JqZWN0U2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zKSB7XG4gIFx0dmFyIGlkLCBpLCBoYXNLZXksIGZyYWdtZW50LCBjaGFuZ2VkLCBkZXBzO1xuXG4gIFx0aGFzS2V5ID0gc2VjdGlvbi5oYXNLZXkgfHwgKHNlY3Rpb24uaGFzS2V5ID0ge30pO1xuXG4gIFx0Ly8gcmVtb3ZlIGFueSBmcmFnbWVudHMgdGhhdCBzaG91bGQgbm8gbG9uZ2VyIGV4aXN0XG4gIFx0aSA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRmcmFnbWVudCA9IHNlY3Rpb24uZnJhZ21lbnRzW2ldO1xuXG4gIFx0XHRpZiAoIShmcmFnbWVudC5rZXkgaW4gdmFsdWUpKSB7XG4gIFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXG4gIFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIucHVzaChmcmFnbWVudCk7XG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZShpLCAxKTtcblxuICBcdFx0XHRoYXNLZXlbZnJhZ21lbnQua2V5XSA9IGZhbHNlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIG5vdGlmeSBhbnkgZGVwZW5kZW50cyBhYm91dCBjaGFuZ2VkIGluZGljZXNcbiAgXHRpID0gc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGZyYWdtZW50ID0gc2VjdGlvbi5mcmFnbWVudHNbaV07XG5cbiAgXHRcdGlmIChmcmFnbWVudC5pbmRleCAhPT0gaSkge1xuICBcdFx0XHRmcmFnbWVudC5pbmRleCA9IGk7XG4gIFx0XHRcdGlmIChkZXBzID0gZnJhZ21lbnQucmVnaXN0ZXJlZEluZGV4UmVmcykge1xuICBcdFx0XHRcdGRlcHMuZm9yRWFjaChzZXRWYWx1ZV9fYmxpbmRSZWJpbmQpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gYWRkIGFueSB0aGF0IGhhdmVuJ3QgYmVlbiBjcmVhdGVkIHlldFxuICBcdGkgPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0Zm9yIChpZCBpbiB2YWx1ZSkge1xuICBcdFx0aWYgKCFoYXNLZXlbaWRdKSB7XG4gIFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXG4gIFx0XHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gc2VjdGlvbi5rZXlwYXRoLmpvaW4oaWQpO1xuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMua2V5ID0gaWQ7XG4gIFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IGkrKztcblxuICBcdFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KGZyYWdtZW50T3B0aW9ucyk7XG5cbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKGZyYWdtZW50KTtcbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHMucHVzaChmcmFnbWVudCk7XG4gIFx0XHRcdGhhc0tleVtpZF0gPSB0cnVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHNlY3Rpb24ubGVuZ3RoID0gc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoO1xuICBcdHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZUNvbmRpdGlvbmFsQ29udGV4dFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucykge1xuICBcdGlmICh2YWx1ZSkge1xuICBcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbihzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gcmVtb3ZlU2VjdGlvbkZyYWdtZW50cyhzZWN0aW9uKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zKSB7XG4gIFx0dmFyIGZyYWdtZW50O1xuXG4gIFx0Ly8gLi4udGhlbiBpZiBpdCBpc24ndCByZW5kZXJlZCwgcmVuZGVyIGl0LCBhZGRpbmcgc2VjdGlvbi5rZXlwYXRoIHRvIHRoZSBjb250ZXh0IHN0YWNrXG4gIFx0Ly8gKGlmIGl0IGlzIGFscmVhZHkgcmVuZGVyZWQsIHRoZW4gYW55IGNoaWxkcmVuIGRlcGVuZGVudCBvbiB0aGUgY29udGV4dCBzdGFja1xuICBcdC8vIHdpbGwgdXBkYXRlIHRoZW1zZWx2ZXMgd2l0aG91dCBhbnkgcHJvbXB0aW5nKVxuICBcdGlmICghc2VjdGlvbi5sZW5ndGgpIHtcbiAgXHRcdC8vIGFwcGVuZCB0aGlzIHNlY3Rpb24gdG8gdGhlIGNvbnRleHQgc3RhY2tcbiAgXHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gc2VjdGlvbi5rZXlwYXRoO1xuICBcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gMDtcblxuICBcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudChmcmFnbWVudE9wdGlvbnMpO1xuXG4gIFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goc2VjdGlvbi5mcmFnbWVudHNbMF0gPSBmcmFnbWVudCk7XG4gIFx0XHRzZWN0aW9uLmxlbmd0aCA9IDE7XG5cbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGludmVydGVkLCBmcmFnbWVudE9wdGlvbnMpIHtcbiAgXHR2YXIgZG9SZW5kZXIsIGVtcHR5QXJyYXksIGVtcHR5T2JqZWN0LCBmcmFnbWVudCwgbmFtZTtcblxuICBcdGVtcHR5QXJyYXkgPSBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwO1xuICBcdGVtcHR5T2JqZWN0ID0gZmFsc2U7XG4gIFx0aWYgKCFpc0FycmF5TGlrZSh2YWx1ZSkgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gIFx0XHRlbXB0eU9iamVjdCA9IHRydWU7XG4gIFx0XHRmb3IgKG5hbWUgaW4gdmFsdWUpIHtcbiAgXHRcdFx0ZW1wdHlPYmplY3QgPSBmYWxzZTtcbiAgXHRcdFx0YnJlYWs7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKGludmVydGVkKSB7XG4gIFx0XHRkb1JlbmRlciA9IGVtcHR5QXJyYXkgfHwgZW1wdHlPYmplY3QgfHwgIXZhbHVlO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRkb1JlbmRlciA9IHZhbHVlICYmICFlbXB0eUFycmF5ICYmICFlbXB0eU9iamVjdDtcbiAgXHR9XG5cbiAgXHRpZiAoZG9SZW5kZXIpIHtcbiAgXHRcdGlmICghc2VjdGlvbi5sZW5ndGgpIHtcbiAgXHRcdFx0Ly8gbm8gY2hhbmdlIHRvIGNvbnRleHQgc3RhY2tcbiAgXHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gMDtcblxuICBcdFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaChzZWN0aW9uLmZyYWdtZW50c1swXSA9IGZyYWdtZW50KTtcbiAgXHRcdFx0c2VjdGlvbi5sZW5ndGggPSAxO1xuXG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoc2VjdGlvbi5sZW5ndGggPiAxKSB7XG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSgxKTtcbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcblxuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIHJlbW92ZVNlY3Rpb25GcmFnbWVudHMoc2VjdGlvbik7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlU2VjdGlvbkZyYWdtZW50cyhzZWN0aW9uKSB7XG4gIFx0aWYgKHNlY3Rpb24ubGVuZ3RoKSB7XG4gIFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoMCwgc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoKS5maWx0ZXIoaXNSZW5kZXJlZCk7XG4gIFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdFx0c2VjdGlvbi5sZW5ndGggPSBzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLmxlbmd0aCA9IDA7XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBpc1JlbmRlcmVkKGZyYWdtZW50KSB7XG4gIFx0cmV0dXJuIGZyYWdtZW50LnJlbmRlcmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0VmFsdWVfX2JsaW5kUmViaW5kKGRlcCkge1xuICBcdC8vIHRoZSBrZXlwYXRoIGRvZXNuJ3QgYWN0dWFsbHkgbWF0dGVyIGhlcmUgYXMgaXQgd29uJ3QgaGF2ZSBjaGFuZ2VkXG4gIFx0ZGVwLnJlYmluZChcIlwiLCBcIlwiKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdG9TdHJpbmcgPSBTZWN0aW9uJHRvU3RyaW5nO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kdG9TdHJpbmcoZXNjYXBlKSB7XG4gIFx0dmFyIHN0ciwgaSwgbGVuO1xuXG4gIFx0c3RyID0gXCJcIjtcblxuICBcdGkgPSAwO1xuICBcdGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRzdHIgKz0gdGhpcy5mcmFnbWVudHNbaV0udG9TdHJpbmcoZXNjYXBlKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV91bmJpbmQgPSBTZWN0aW9uJHVuYmluZDtcbiAgZnVuY3Rpb24gU2VjdGlvbiR1bmJpbmQoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHR0aGlzLmZyYWdtZW50c1RvUmVuZGVyLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgXHRcdHJldHVybiByZW1vdmVGcm9tQXJyYXkoX3RoaXMuZnJhZ21lbnRzLCBmKTtcbiAgXHR9KTtcbiAgXHR0aGlzLmZyYWdtZW50c1RvUmVuZGVyID0gW107XG4gIFx0c2hhcmVkX3VuYmluZC5jYWxsKHRoaXMpO1xuXG4gIFx0dGhpcy5sZW5ndGggPSAwO1xuICBcdHRoaXMudW5ib3VuZCA9IHRydWU7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3VucmVuZGVyID0gU2VjdGlvbiR1bnJlbmRlcjtcblxuICBmdW5jdGlvbiBTZWN0aW9uJHVucmVuZGVyKHNob3VsZERlc3Ryb3kpIHtcbiAgXHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKHNob3VsZERlc3Ryb3kgPyB1bnJlbmRlckFuZERlc3Ryb3kgOiBwcm90b3R5cGVfdW5yZW5kZXJfX3VucmVuZGVyKTtcbiAgXHR0aGlzLnJlbmRlcmVkRnJhZ21lbnRzID0gW107XG4gIFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5yZW5kZXJBbmREZXN0cm95KGZyYWdtZW50KSB7XG4gIFx0ZnJhZ21lbnQudW5yZW5kZXIodHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm90b3R5cGVfdW5yZW5kZXJfX3VucmVuZGVyKGZyYWdtZW50KSB7XG4gIFx0ZnJhZ21lbnQudW5yZW5kZXIoZmFsc2UpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV91cGRhdGUgPSBTZWN0aW9uJHVwZGF0ZTtcblxuICBmdW5jdGlvbiBTZWN0aW9uJHVwZGF0ZSgpIHtcbiAgXHR2YXIgZnJhZ21lbnQsIHJlbmRlckluZGV4LCByZW5kZXJlZEZyYWdtZW50cywgYW5jaG9yLCB0YXJnZXQsIGksIGxlbjtcblxuICBcdC8vIGB0aGlzLnJlbmRlcmVkRnJhZ21lbnRzYCBpcyBpbiB0aGUgb3JkZXIgb2YgdGhlIHByZXZpb3VzIHJlbmRlci5cbiAgXHQvLyBJZiBmcmFnbWVudHMgaGF2ZSBzaHVmZmxlZCBhYm91dCwgdGhpcyBhbGxvd3MgdXMgdG8gcXVpY2tseVxuICBcdC8vIHJlaW5zZXJ0IHRoZW0gaW4gdGhlIGNvcnJlY3QgcGxhY2VcbiAgXHRyZW5kZXJlZEZyYWdtZW50cyA9IHRoaXMucmVuZGVyZWRGcmFnbWVudHM7XG5cbiAgXHQvLyBSZW1vdmUgZnJhZ21lbnRzIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZCBmb3IgZGVzdHJ1Y3Rpb25cbiAgXHR3aGlsZSAoZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50c1RvVW5yZW5kZXIucG9wKCkpIHtcbiAgXHRcdGZyYWdtZW50LnVucmVuZGVyKHRydWUpO1xuICBcdFx0cmVuZGVyZWRGcmFnbWVudHMuc3BsaWNlKHJlbmRlcmVkRnJhZ21lbnRzLmluZGV4T2YoZnJhZ21lbnQpLCAxKTtcbiAgXHR9XG5cbiAgXHQvLyBSZW5kZXIgbmV3IGZyYWdtZW50cyAoYnV0IGRvbid0IGluc2VydCB0aGVtIHlldClcbiAgXHR3aGlsZSAoZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50c1RvUmVuZGVyLnNoaWZ0KCkpIHtcbiAgXHRcdGZyYWdtZW50LnJlbmRlcigpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHR0YXJnZXQgPSB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKTtcbiAgXHR9XG5cbiAgXHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzW2ldO1xuICBcdFx0cmVuZGVySW5kZXggPSByZW5kZXJlZEZyYWdtZW50cy5pbmRleE9mKGZyYWdtZW50LCBpKTsgLy8gc2VhcmNoIGZyb20gY3VycmVudCBpbmRleCAtIGl0J3MgZ3VhcmFudGVlZCB0byBiZSB0aGUgc2FtZSBvciBoaWdoZXJcblxuICBcdFx0aWYgKHJlbmRlckluZGV4ID09PSBpKSB7XG4gIFx0XHRcdC8vIGFscmVhZHkgaW4gdGhlIHJpZ2h0IHBsYWNlLiBpbnNlcnQgYWNjdW11bGF0ZWQgbm9kZXMgKGlmIGFueSkgYW5kIGNhcnJ5IG9uXG4gIFx0XHRcdGlmICh0aGlzLmRvY0ZyYWcuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRhbmNob3IgPSBmcmFnbWVudC5maXJzdE5vZGUoKTtcbiAgXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuZG9jRnJhZywgYW5jaG9yKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNvbnRpbnVlO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQoZnJhZ21lbnQuZGV0YWNoKCkpO1xuXG4gIFx0XHQvLyB1cGRhdGUgcmVuZGVyZWRGcmFnbWVudHNcbiAgXHRcdGlmIChyZW5kZXJJbmRleCAhPT0gLTEpIHtcbiAgXHRcdFx0cmVuZGVyZWRGcmFnbWVudHMuc3BsaWNlKHJlbmRlckluZGV4LCAxKTtcbiAgXHRcdH1cbiAgXHRcdHJlbmRlcmVkRnJhZ21lbnRzLnNwbGljZShpLCAwLCBmcmFnbWVudCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMucmVuZGVyZWQgJiYgdGhpcy5kb2NGcmFnLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gIFx0XHRhbmNob3IgPSB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUodGhpcy5kb2NGcmFnLCBhbmNob3IpO1xuICBcdH1cblxuICBcdC8vIFNhdmUgdGhlIHJlbmRlcmluZyBvcmRlciBmb3IgbmV4dCB0aW1lXG4gIFx0dGhpcy5yZW5kZXJlZEZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzLnNsaWNlKCk7XG4gIH1cblxuICB2YXIgU2VjdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy50eXBlID0gU0VDVElPTjtcbiAgXHR0aGlzLnN1YnR5cGUgPSB0aGlzLmN1cnJlbnRTdWJ0eXBlID0gb3B0aW9ucy50ZW1wbGF0ZS5uO1xuICBcdHRoaXMuaW52ZXJ0ZWQgPSB0aGlzLnN1YnR5cGUgPT09IFNFQ1RJT05fVU5MRVNTO1xuXG4gIFx0dGhpcy5wRWxlbWVudCA9IG9wdGlvbnMucEVsZW1lbnQ7XG5cbiAgXHR0aGlzLmZyYWdtZW50cyA9IFtdO1xuICBcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUgPSBbXTtcbiAgXHR0aGlzLmZyYWdtZW50c1RvUmVuZGVyID0gW107XG4gIFx0dGhpcy5mcmFnbWVudHNUb1VucmVuZGVyID0gW107XG5cbiAgXHRpZiAob3B0aW9ucy50ZW1wbGF0ZS5pKSB7XG4gIFx0XHR0aGlzLmluZGV4UmVmcyA9IG9wdGlvbnMudGVtcGxhdGUuaS5zcGxpdChcIixcIikubWFwKGZ1bmN0aW9uIChrLCBpKSB7XG4gIFx0XHRcdHJldHVybiB7IG46IGssIHQ6IGkgPT09IDAgPyBcImtcIiA6IFwiaVwiIH07XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHR0aGlzLnJlbmRlcmVkRnJhZ21lbnRzID0gW107XG5cbiAgXHR0aGlzLmxlbmd0aCA9IDA7IC8vIG51bWJlciBvZiB0aW1lcyB0aGlzIHNlY3Rpb24gaXMgcmVuZGVyZWRcblxuICBcdE11c3RhY2hlLmluaXQodGhpcywgb3B0aW9ucyk7XG4gIH07XG5cbiAgU2VjdGlvbi5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBTZWN0aW9uX3Byb3RvdHlwZV9idWJibGUsXG4gIFx0ZGV0YWNoOiBTZWN0aW9uX3Byb3RvdHlwZV9kZXRhY2gsXG4gIFx0ZmluZDogZmluZCxcbiAgXHRmaW5kQWxsOiBmaW5kQWxsLFxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBmaW5kQWxsQ29tcG9uZW50cyxcbiAgXHRmaW5kQ29tcG9uZW50OiBmaW5kQ29tcG9uZW50LFxuICBcdGZpbmROZXh0Tm9kZTogZmluZE5leHROb2RlLFxuICBcdGZpcnN0Tm9kZTogZmlyc3ROb2RlLFxuICBcdGdldEluZGV4UmVmOiBmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0aWYgKHRoaXMuaW5kZXhSZWZzKSB7XG4gIFx0XHRcdHZhciBpID0gdGhpcy5pbmRleFJlZnMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0dmFyIHJlZiA9IHRoaXMuaW5kZXhSZWZzW2ldO1xuICBcdFx0XHRcdGlmIChyZWYubiA9PT0gbmFtZSkge1xuICBcdFx0XHRcdFx0cmV0dXJuIHJlZjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuICBcdGdldFZhbHVlOiBNdXN0YWNoZS5nZXRWYWx1ZSxcbiAgXHRzaHVmZmxlOiBzaHVmZmxlLFxuICBcdHJlYmluZDogcHJvdG90eXBlX3JlYmluZCxcbiAgXHRyZW5kZXI6IFNlY3Rpb25fcHJvdG90eXBlX3JlbmRlcixcbiAgXHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuICBcdHNldFZhbHVlOiBzZXRWYWx1ZSxcbiAgXHR0b1N0cmluZzogcHJvdG90eXBlX3RvU3RyaW5nLFxuICBcdHVuYmluZDogcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1bnJlbmRlcjogcHJvdG90eXBlX3VucmVuZGVyLFxuICBcdHVwZGF0ZTogcHJvdG90eXBlX3VwZGF0ZVxuICB9O1xuXG4gIHZhciBfU2VjdGlvbiA9IFNlY3Rpb247XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfZGV0YWNoID0gVHJpcGxlJGRldGFjaDtcblxuICBmdW5jdGlvbiBUcmlwbGUkZGV0YWNoKCkge1xuICBcdHZhciBsZW4sIGk7XG5cbiAgXHRpZiAodGhpcy5kb2NGcmFnKSB7XG4gIFx0XHRsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlc1tpXSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLmRvY0ZyYWc7XG4gIFx0fVxuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfZmluZCA9IFRyaXBsZSRmaW5kO1xuICBmdW5jdGlvbiBUcmlwbGUkZmluZChzZWxlY3Rvcikge1xuICBcdHZhciBpLCBsZW4sIG5vZGUsIHF1ZXJ5UmVzdWx0O1xuXG4gIFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRub2RlID0gdGhpcy5ub2Rlc1tpXTtcblxuICBcdFx0aWYgKG5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChtYXRjaGVzKG5vZGUsIHNlbGVjdG9yKSkge1xuICBcdFx0XHRyZXR1cm4gbm9kZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHF1ZXJ5UmVzdWx0ID0gbm9kZS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSkge1xuICBcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV9maW5kQWxsID0gVHJpcGxlJGZpbmRBbGw7XG4gIGZ1bmN0aW9uIFRyaXBsZSRmaW5kQWxsKHNlbGVjdG9yLCBxdWVyeVJlc3VsdCkge1xuICBcdHZhciBpLCBsZW4sIG5vZGUsIHF1ZXJ5QWxsUmVzdWx0LCBudW1Ob2RlcywgajtcblxuICBcdGxlbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0bm9kZSA9IHRoaXMubm9kZXNbaV07XG5cbiAgXHRcdGlmIChub2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gIFx0XHRcdGNvbnRpbnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobWF0Y2hlcyhub2RlLCBzZWxlY3RvcikpIHtcbiAgXHRcdFx0cXVlcnlSZXN1bHQucHVzaChub2RlKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHF1ZXJ5QWxsUmVzdWx0ID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkge1xuICBcdFx0XHRudW1Ob2RlcyA9IHF1ZXJ5QWxsUmVzdWx0Lmxlbmd0aDtcbiAgXHRcdFx0Zm9yIChqID0gMDsgaiA8IG51bU5vZGVzOyBqICs9IDEpIHtcbiAgXHRcdFx0XHRxdWVyeVJlc3VsdC5wdXNoKHF1ZXJ5QWxsUmVzdWx0W2pdKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX2ZpcnN0Tm9kZSA9IFRyaXBsZSRmaXJzdE5vZGU7XG5cbiAgZnVuY3Rpb24gVHJpcGxlJGZpcnN0Tm9kZSgpIHtcbiAgXHRpZiAodGhpcy5yZW5kZXJlZCAmJiB0aGlzLm5vZGVzWzBdKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5ub2Rlc1swXTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIH1cblxuICB2YXIgZWxlbWVudENhY2hlID0ge30sXG4gICAgICBpZUJ1ZyxcbiAgICAgIGllQmxhY2tsaXN0O1xuXG4gIHRyeSB7XG4gIFx0Y3JlYXRlRWxlbWVudChcInRhYmxlXCIpLmlubmVySFRNTCA9IFwiZm9vXCI7XG4gIH0gY2F0Y2ggKGVycikge1xuICBcdGllQnVnID0gdHJ1ZTtcblxuICBcdGllQmxhY2tsaXN0ID0ge1xuICBcdFx0VEFCTEU6IFtcIjx0YWJsZSBjbGFzcz1cXFwieFxcXCI+XCIsIFwiPC90YWJsZT5cIl0sXG4gIFx0XHRUSEVBRDogW1wiPHRhYmxlPjx0aGVhZCBjbGFzcz1cXFwieFxcXCI+XCIsIFwiPC90aGVhZD48L3RhYmxlPlwiXSxcbiAgXHRcdFRCT0RZOiBbXCI8dGFibGU+PHRib2R5IGNsYXNzPVxcXCJ4XFxcIj5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCJdLFxuICBcdFx0VFI6IFtcIjx0YWJsZT48dHIgY2xhc3M9XFxcInhcXFwiPlwiLCBcIjwvdHI+PC90YWJsZT5cIl0sXG4gIFx0XHRTRUxFQ1Q6IFtcIjxzZWxlY3QgY2xhc3M9XFxcInhcXFwiPlwiLCBcIjwvc2VsZWN0PlwiXVxuICBcdH07XG4gIH1cblxuICB2YXIgaW5zZXJ0SHRtbCA9IGZ1bmN0aW9uIChodG1sLCBub2RlLCBkb2NGcmFnKSB7XG4gIFx0dmFyIGNvbnRhaW5lcixcbiAgXHQgICAgbm9kZXMgPSBbXSxcbiAgXHQgICAgd3JhcHBlcixcbiAgXHQgICAgc2VsZWN0ZWRPcHRpb24sXG4gIFx0ICAgIGNoaWxkLFxuICBcdCAgICBpO1xuXG4gIFx0Ly8gcmVuZGVyIDAgYW5kIGZhbHNlXG4gIFx0aWYgKGh0bWwgIT0gbnVsbCAmJiBodG1sICE9PSBcIlwiKSB7XG4gIFx0XHRpZiAoaWVCdWcgJiYgKHdyYXBwZXIgPSBpZUJsYWNrbGlzdFtub2RlLnRhZ05hbWVdKSkge1xuICBcdFx0XHRjb250YWluZXIgPSBlbGVtZW50KFwiRElWXCIpO1xuICBcdFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gd3JhcHBlclswXSArIGh0bWwgKyB3cmFwcGVyWzFdO1xuICBcdFx0XHRjb250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihcIi54XCIpO1xuXG4gIFx0XHRcdGlmIChjb250YWluZXIudGFnTmFtZSA9PT0gXCJTRUxFQ1RcIikge1xuICBcdFx0XHRcdHNlbGVjdGVkT3B0aW9uID0gY29udGFpbmVyLm9wdGlvbnNbY29udGFpbmVyLnNlbGVjdGVkSW5kZXhdO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2UgaWYgKG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLnN2Zykge1xuICBcdFx0XHRjb250YWluZXIgPSBlbGVtZW50KFwiRElWXCIpO1xuICBcdFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gXCI8c3ZnIGNsYXNzPVxcXCJ4XFxcIj5cIiArIGh0bWwgKyBcIjwvc3ZnPlwiO1xuICBcdFx0XHRjb250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihcIi54XCIpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y29udGFpbmVyID0gZWxlbWVudChub2RlLnRhZ05hbWUpO1xuICBcdFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcblxuICBcdFx0XHRpZiAoY29udGFpbmVyLnRhZ05hbWUgPT09IFwiU0VMRUNUXCIpIHtcbiAgXHRcdFx0XHRzZWxlY3RlZE9wdGlvbiA9IGNvbnRhaW5lci5vcHRpb25zW2NvbnRhaW5lci5zZWxlY3RlZEluZGV4XTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR3aGlsZSAoY2hpbGQgPSBjb250YWluZXIuZmlyc3RDaGlsZCkge1xuICBcdFx0XHRub2Rlcy5wdXNoKGNoaWxkKTtcbiAgXHRcdFx0ZG9jRnJhZy5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFRoaXMgaXMgcmVhbGx5IGFubm95aW5nLiBFeHRyYWN0aW5nIDxvcHRpb24+IG5vZGVzIGZyb20gdGhlXG4gIFx0XHQvLyB0ZW1wb3JhcnkgY29udGFpbmVyIDxzZWxlY3Q+IGNhdXNlcyB0aGUgcmVtYWluaW5nIG9uZXMgdG9cbiAgXHRcdC8vIGJlY29tZSBzZWxlY3RlZC4gU28gbm93IHdlIGhhdmUgdG8gZGVzZWxlY3QgdGhlbS4gSUU4LCB5b3VcbiAgXHRcdC8vIGFtYXplIG1lLiBZb3UgcmVhbGx5IGRvXG4gIFx0XHQvLyAuLi5hbmQgbm93IENocm9tZSB0b29cbiAgXHRcdGlmIChub2RlLnRhZ05hbWUgPT09IFwiU0VMRUNUXCIpIHtcbiAgXHRcdFx0aSA9IG5vZGVzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGlmIChub2Rlc1tpXSAhPT0gc2VsZWN0ZWRPcHRpb24pIHtcbiAgXHRcdFx0XHRcdG5vZGVzW2ldLnNlbGVjdGVkID0gZmFsc2U7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG5vZGVzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGVsZW1lbnQodGFnTmFtZSkge1xuICBcdHJldHVybiBlbGVtZW50Q2FjaGVbdGFnTmFtZV0gfHwgKGVsZW1lbnRDYWNoZVt0YWdOYW1lXSA9IGNyZWF0ZUVsZW1lbnQodGFnTmFtZSkpO1xuICB9XG5cbiAgdmFyIGhlbHBlcnNfdXBkYXRlU2VsZWN0ID0gdXBkYXRlU2VsZWN0O1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdChwYXJlbnRFbGVtZW50KSB7XG4gIFx0dmFyIHNlbGVjdGVkT3B0aW9ucywgb3B0aW9uLCB2YWx1ZTtcblxuICBcdGlmICghcGFyZW50RWxlbWVudCB8fCBwYXJlbnRFbGVtZW50Lm5hbWUgIT09IFwic2VsZWN0XCIgfHwgIXBhcmVudEVsZW1lbnQuYmluZGluZykge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHNlbGVjdGVkT3B0aW9ucyA9IHRvQXJyYXkocGFyZW50RWxlbWVudC5ub2RlLm9wdGlvbnMpLmZpbHRlcihpc1NlbGVjdGVkKTtcblxuICBcdC8vIElmIG9uZSBvZiB0aGVtIGhhZCBhIGBzZWxlY3RlZGAgYXR0cmlidXRlLCB3ZSBuZWVkIHRvIHN5bmNcbiAgXHQvLyB0aGUgbW9kZWwgdG8gdGhlIHZpZXdcbiAgXHRpZiAocGFyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSkge1xuICBcdFx0dmFsdWUgPSBzZWxlY3RlZE9wdGlvbnMubWFwKGZ1bmN0aW9uIChvKSB7XG4gIFx0XHRcdHJldHVybiBvLnZhbHVlO1xuICBcdFx0fSk7XG4gIFx0fSBlbHNlIGlmIChvcHRpb24gPSBzZWxlY3RlZE9wdGlvbnNbMF0pIHtcbiAgXHRcdHZhbHVlID0gb3B0aW9uLnZhbHVlO1xuICBcdH1cblxuICBcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRwYXJlbnRFbGVtZW50LmJpbmRpbmcuc2V0VmFsdWUodmFsdWUpO1xuICBcdH1cblxuICBcdHBhcmVudEVsZW1lbnQuYnViYmxlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NlbGVjdGVkKG9wdGlvbikge1xuICBcdHJldHVybiBvcHRpb24uc2VsZWN0ZWQ7XG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV9yZW5kZXIgPSBUcmlwbGUkcmVuZGVyO1xuICBmdW5jdGlvbiBUcmlwbGUkcmVuZGVyKCkge1xuICBcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gcmVuZGVyIGFuIGl0ZW0gdGhhdCB3YXMgYWxyZWFkeSByZW5kZXJlZFwiKTtcbiAgXHR9XG5cbiAgXHR0aGlzLmRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIFx0dGhpcy5ub2RlcyA9IGluc2VydEh0bWwodGhpcy52YWx1ZSwgdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCksIHRoaXMuZG9jRnJhZyk7XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSB3ZSdyZSBpbnNlcnRpbmcgdGhlIGNvbnRlbnRzIG9mIGEgPHNlbGVjdD5cbiAgXHRoZWxwZXJzX3VwZGF0ZVNlbGVjdCh0aGlzLnBFbGVtZW50KTtcblxuICBcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdHJldHVybiB0aGlzLmRvY0ZyYWc7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3NldFZhbHVlID0gVHJpcGxlJHNldFZhbHVlO1xuICBmdW5jdGlvbiBUcmlwbGUkc2V0VmFsdWUodmFsdWUpIHtcbiAgXHR2YXIgd3JhcHBlcjtcblxuICBcdC8vIFRPRE8gaXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGFwcHJvYWNoIHRoaXM/XG4gIFx0aWYgKHdyYXBwZXIgPSB0aGlzLnJvb3Qudmlld21vZGVsLndyYXBwZWRbdGhpcy5rZXlwYXRoLnN0cl0pIHtcbiAgXHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcbiAgXHR9XG5cbiAgXHRpZiAodmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cbiAgXHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfdG9TdHJpbmcgPSBUcmlwbGUkdG9TdHJpbmc7XG4gIGZ1bmN0aW9uIFRyaXBsZSR0b1N0cmluZygpIHtcbiAgXHRyZXR1cm4gdGhpcy52YWx1ZSAhPSB1bmRlZmluZWQgPyBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKFwiXCIgKyB0aGlzLnZhbHVlKSA6IFwiXCI7XG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV91bnJlbmRlciA9IFRyaXBsZSR1bnJlbmRlcjtcbiAgZnVuY3Rpb24gVHJpcGxlJHVucmVuZGVyKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRpZiAodGhpcy5yZW5kZXJlZCAmJiBzaG91bGREZXN0cm95KSB7XG4gIFx0XHR0aGlzLm5vZGVzLmZvckVhY2goZGV0YWNoTm9kZSk7XG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0Ly8gVE9ETyB1cGRhdGUgbGl2ZSBxdWVyaWVzXG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV91cGRhdGUgPSBUcmlwbGUkdXBkYXRlO1xuICBmdW5jdGlvbiBUcmlwbGUkdXBkYXRlKCkge1xuICBcdHZhciBub2RlLCBwYXJlbnROb2RlO1xuXG4gIFx0aWYgKCF0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gUmVtb3ZlIGV4aXN0aW5nIG5vZGVzXG4gIFx0d2hpbGUgKHRoaXMubm9kZXMgJiYgdGhpcy5ub2Rlcy5sZW5ndGgpIHtcbiAgXHRcdG5vZGUgPSB0aGlzLm5vZGVzLnBvcCgpO1xuICBcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICBcdH1cblxuICBcdC8vIEluc2VydCBuZXcgbm9kZXNcbiAgXHRwYXJlbnROb2RlID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG5cbiAgXHR0aGlzLm5vZGVzID0gaW5zZXJ0SHRtbCh0aGlzLnZhbHVlLCBwYXJlbnROb2RlLCB0aGlzLmRvY0ZyYWcpO1xuICBcdHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuZG9jRnJhZywgdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcykpO1xuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gd2UncmUgaW5zZXJ0aW5nIHRoZSBjb250ZW50cyBvZiBhIDxzZWxlY3Q+XG4gIFx0aGVscGVyc191cGRhdGVTZWxlY3QodGhpcy5wRWxlbWVudCk7XG4gIH1cblxuICB2YXIgVHJpcGxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBUUklQTEU7XG4gIFx0TXVzdGFjaGUuaW5pdCh0aGlzLCBvcHRpb25zKTtcbiAgfTtcblxuICBUcmlwbGUucHJvdG90eXBlID0ge1xuICBcdGRldGFjaDogVHJpcGxlX3Byb3RvdHlwZV9kZXRhY2gsXG4gIFx0ZmluZDogVHJpcGxlX3Byb3RvdHlwZV9maW5kLFxuICBcdGZpbmRBbGw6IFRyaXBsZV9wcm90b3R5cGVfZmluZEFsbCxcbiAgXHRmaXJzdE5vZGU6IFRyaXBsZV9wcm90b3R5cGVfZmlyc3ROb2RlLFxuICBcdGdldFZhbHVlOiBNdXN0YWNoZS5nZXRWYWx1ZSxcbiAgXHRyZWJpbmQ6IE11c3RhY2hlLnJlYmluZCxcbiAgXHRyZW5kZXI6IFRyaXBsZV9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG4gIFx0c2V0VmFsdWU6IHByb3RvdHlwZV9zZXRWYWx1ZSxcbiAgXHR0b1N0cmluZzogVHJpcGxlX3Byb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IHNoYXJlZF91bmJpbmQsXG4gIFx0dW5yZW5kZXI6IFRyaXBsZV9wcm90b3R5cGVfdW5yZW5kZXIsXG4gIFx0dXBkYXRlOiBUcmlwbGVfcHJvdG90eXBlX3VwZGF0ZVxuICB9O1xuXG4gIHZhciBfVHJpcGxlID0gVHJpcGxlO1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9idWJibGUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcbiAgfTtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZGV0YWNoID0gRWxlbWVudCRkZXRhY2g7XG5cbiAgZnVuY3Rpb24gRWxlbWVudCRkZXRhY2goKSB7XG4gIFx0dmFyIG5vZGUgPSB0aGlzLm5vZGUsXG4gIFx0ICAgIHBhcmVudE5vZGU7XG5cbiAgXHRpZiAobm9kZSkge1xuICBcdFx0Ly8gbmVlZCB0byBjaGVjayBmb3IgcGFyZW50IG5vZGUgLSBET00gbWF5IGhhdmUgYmVlbiBhbHRlcmVkXG4gIFx0XHQvLyBieSBzb21ldGhpbmcgb3RoZXIgdGhhbiBSYWN0aXZlISBlLmcuIGpRdWVyeSBVSS4uLlxuICBcdFx0aWYgKHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGUpIHtcbiAgXHRcdFx0cGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG5vZGU7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2ZpbmQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRpZiAoIXRoaXMubm9kZSkge1xuICBcdFx0Ly8gdGhpcyBlbGVtZW50IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldFxuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKG1hdGNoZXModGhpcy5ub2RlLCBzZWxlY3RvcikpIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5mcmFnbWVudC5maW5kKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKHNlbGVjdG9yKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2ZpbmRBbGwgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0Ly8gQWRkIHRoaXMgbm9kZSB0byB0aGUgcXVlcnksIGlmIGFwcGxpY2FibGUsIGFuZCByZWdpc3RlciB0aGVcbiAgXHQvLyBxdWVyeSBvbiB0aGlzIGVsZW1lbnRcbiAgXHRpZiAocXVlcnkuX3Rlc3QodGhpcywgdHJ1ZSkgJiYgcXVlcnkubGl2ZSkge1xuICBcdFx0KHRoaXMubGl2ZVF1ZXJpZXMgfHwgKHRoaXMubGl2ZVF1ZXJpZXMgPSBbXSkpLnB1c2gocXVlcnkpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoc2VsZWN0b3IpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZmluZE5leHROb2RlID0gRWxlbWVudCRmaW5kTmV4dE5vZGU7XG5cbiAgZnVuY3Rpb24gRWxlbWVudCRmaW5kTmV4dE5vZGUoKSB7XG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZmlyc3ROb2RlID0gRWxlbWVudCRmaXJzdE5vZGU7XG5cbiAgZnVuY3Rpb24gRWxlbWVudCRmaXJzdE5vZGUoKSB7XG4gIFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgfVxuXG4gIHZhciBnZXRBdHRyaWJ1dGUgPSBFbGVtZW50JGdldEF0dHJpYnV0ZTtcblxuICBmdW5jdGlvbiBFbGVtZW50JGdldEF0dHJpYnV0ZShuYW1lKSB7XG4gIFx0aWYgKCF0aGlzLmF0dHJpYnV0ZXMgfHwgIXRoaXMuYXR0cmlidXRlc1tuYW1lXSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0udmFsdWU7XG4gIH1cblxuICB2YXIgdHJ1dGh5ID0gL150cnVlfG9ufHllc3wxJC9pO1xuICB2YXIgcHJvY2Vzc0JpbmRpbmdBdHRyaWJ1dGVzX19pc051bWVyaWMgPSAvXlswLTldKyQvO1xuXG4gIHZhciBwcm9jZXNzQmluZGluZ0F0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgdGVtcGxhdGUpIHtcbiAgXHR2YXIgdmFsLCBhdHRycywgYXR0cmlidXRlcztcblxuICBcdGF0dHJpYnV0ZXMgPSB0ZW1wbGF0ZS5hIHx8IHt9O1xuICBcdGF0dHJzID0ge307XG5cbiAgXHQvLyBhdHRyaWJ1dGVzIHRoYXQgYXJlIHByZXNlbnQgYnV0IGRvbid0IGhhdmUgYSB2YWx1ZSAoPSlcbiAgXHQvLyB3aWxsIGJlIHNldCB0byB0aGUgbnVtYmVyIDAsIHdoaWNoIHdlIGNvbmRpZGVyIHRvIGJlIHRydWVcbiAgXHQvLyB0aGUgc3RyaW5nICcwJywgaG93ZXZlciBpcyBmYWxzZVxuXG4gIFx0dmFsID0gYXR0cmlidXRlcy50d293YXk7XG4gIFx0aWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRhdHRycy50d293YXkgPSB2YWwgPT09IDAgfHwgdHJ1dGh5LnRlc3QodmFsKTtcbiAgXHR9XG5cbiAgXHR2YWwgPSBhdHRyaWJ1dGVzLmxhenk7XG4gIFx0aWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHQvLyBjaGVjayBmb3IgdGltZW91dCB2YWx1ZVxuICBcdFx0aWYgKHZhbCAhPT0gMCAmJiBwcm9jZXNzQmluZGluZ0F0dHJpYnV0ZXNfX2lzTnVtZXJpYy50ZXN0KHZhbCkpIHtcbiAgXHRcdFx0YXR0cnMubGF6eSA9IHBhcnNlSW50KHZhbCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRhdHRycy5sYXp5ID0gdmFsID09PSAwIHx8IHRydXRoeS50ZXN0KHZhbCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGF0dHJzO1xuICB9O1xuXG4gIHZhciBBdHRyaWJ1dGVfcHJvdG90eXBlX2J1YmJsZSA9IEF0dHJpYnV0ZSRidWJibGU7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSRidWJibGUoKSB7XG4gIFx0dmFyIHZhbHVlID0gdGhpcy51c2VQcm9wZXJ0eSB8fCAhdGhpcy5yZW5kZXJlZCA/IHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKSA6IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKTtcblxuICBcdC8vIFRPRE8gdGhpcyBjYW4gcmVnaXN0ZXIgdGhlIGF0dHJpYnV0ZSBtdWx0aXBsZSB0aW1lcyAoc2VlIHJlbmRlciB0ZXN0XG4gIFx0Ly8gJ0F0dHJpYnV0ZSB3aXRoIG5lc3RlZCBtdXN0YWNoZXMnKVxuICBcdGlmICghaXNFcXVhbCh2YWx1ZSwgdGhpcy52YWx1ZSkpIHtcblxuICBcdFx0Ly8gTmVlZCB0byBjbGVhciBvbGQgaWQgZnJvbSByYWN0aXZlLm5vZGVzXG4gIFx0XHRpZiAodGhpcy5uYW1lID09PSBcImlkXCIgJiYgdGhpcy52YWx1ZSkge1xuICBcdFx0XHRkZWxldGUgdGhpcy5yb290Lm5vZGVzW3RoaXMudmFsdWVdO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdGlmICh0aGlzLm5hbWUgPT09IFwidmFsdWVcIiAmJiB0aGlzLm5vZGUpIHtcbiAgXHRcdFx0Ly8gV2UgbmVlZCB0byBzdG9yZSB0aGUgdmFsdWUgb24gdGhlIERPTSBsaWtlIHRoaXMgc28gd2VcbiAgXHRcdFx0Ly8gY2FuIHJldHJpZXZlIGl0IGxhdGVyIHdpdGhvdXQgaXQgYmVpbmcgY29lcmNlZCB0byBhIHN0cmluZ1xuICBcdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgc3ZnQ2FtZWxDYXNlRWxlbWVudHMsIHN2Z0NhbWVsQ2FzZUF0dHJpYnV0ZXMsIGNyZWF0ZU1hcCwgbWFwO1xuICBzdmdDYW1lbENhc2VFbGVtZW50cyA9IFwiYWx0R2x5cGggYWx0R2x5cGhEZWYgYWx0R2x5cGhJdGVtIGFuaW1hdGVDb2xvciBhbmltYXRlTW90aW9uIGFuaW1hdGVUcmFuc2Zvcm0gY2xpcFBhdGggZmVCbGVuZCBmZUNvbG9yTWF0cml4IGZlQ29tcG9uZW50VHJhbnNmZXIgZmVDb21wb3NpdGUgZmVDb252b2x2ZU1hdHJpeCBmZURpZmZ1c2VMaWdodGluZyBmZURpc3BsYWNlbWVudE1hcCBmZURpc3RhbnRMaWdodCBmZUZsb29kIGZlRnVuY0EgZmVGdW5jQiBmZUZ1bmNHIGZlRnVuY1IgZmVHYXVzc2lhbkJsdXIgZmVJbWFnZSBmZU1lcmdlIGZlTWVyZ2VOb2RlIGZlTW9ycGhvbG9neSBmZU9mZnNldCBmZVBvaW50TGlnaHQgZmVTcGVjdWxhckxpZ2h0aW5nIGZlU3BvdExpZ2h0IGZlVGlsZSBmZVR1cmJ1bGVuY2UgZm9yZWlnbk9iamVjdCBnbHlwaFJlZiBsaW5lYXJHcmFkaWVudCByYWRpYWxHcmFkaWVudCB0ZXh0UGF0aCB2a2VyblwiLnNwbGl0KFwiIFwiKTtcbiAgc3ZnQ2FtZWxDYXNlQXR0cmlidXRlcyA9IFwiYXR0cmlidXRlTmFtZSBhdHRyaWJ1dGVUeXBlIGJhc2VGcmVxdWVuY3kgYmFzZVByb2ZpbGUgY2FsY01vZGUgY2xpcFBhdGhVbml0cyBjb250ZW50U2NyaXB0VHlwZSBjb250ZW50U3R5bGVUeXBlIGRpZmZ1c2VDb25zdGFudCBlZGdlTW9kZSBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkIGZpbHRlclJlcyBmaWx0ZXJVbml0cyBnbHlwaFJlZiBncmFkaWVudFRyYW5zZm9ybSBncmFkaWVudFVuaXRzIGtlcm5lbE1hdHJpeCBrZXJuZWxVbml0TGVuZ3RoIGtleVBvaW50cyBrZXlTcGxpbmVzIGtleVRpbWVzIGxlbmd0aEFkanVzdCBsaW1pdGluZ0NvbmVBbmdsZSBtYXJrZXJIZWlnaHQgbWFya2VyVW5pdHMgbWFya2VyV2lkdGggbWFza0NvbnRlbnRVbml0cyBtYXNrVW5pdHMgbnVtT2N0YXZlcyBwYXRoTGVuZ3RoIHBhdHRlcm5Db250ZW50VW5pdHMgcGF0dGVyblRyYW5zZm9ybSBwYXR0ZXJuVW5pdHMgcG9pbnRzQXRYIHBvaW50c0F0WSBwb2ludHNBdFogcHJlc2VydmVBbHBoYSBwcmVzZXJ2ZUFzcGVjdFJhdGlvIHByaW1pdGl2ZVVuaXRzIHJlZlggcmVmWSByZXBlYXRDb3VudCByZXBlYXREdXIgcmVxdWlyZWRFeHRlbnNpb25zIHJlcXVpcmVkRmVhdHVyZXMgc3BlY3VsYXJDb25zdGFudCBzcGVjdWxhckV4cG9uZW50IHNwcmVhZE1ldGhvZCBzdGFydE9mZnNldCBzdGREZXZpYXRpb24gc3RpdGNoVGlsZXMgc3VyZmFjZVNjYWxlIHN5c3RlbUxhbmd1YWdlIHRhYmxlVmFsdWVzIHRhcmdldFggdGFyZ2V0WSB0ZXh0TGVuZ3RoIHZpZXdCb3ggdmlld1RhcmdldCB4Q2hhbm5lbFNlbGVjdG9yIHlDaGFubmVsU2VsZWN0b3Igem9vbUFuZFBhblwiLnNwbGl0KFwiIFwiKTtcblxuICBjcmVhdGVNYXAgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgXHR2YXIgbWFwID0ge30sXG4gIFx0ICAgIGkgPSBpdGVtcy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0bWFwW2l0ZW1zW2ldLnRvTG93ZXJDYXNlKCldID0gaXRlbXNbaV07XG4gIFx0fVxuICBcdHJldHVybiBtYXA7XG4gIH07XG5cbiAgbWFwID0gY3JlYXRlTWFwKHN2Z0NhbWVsQ2FzZUVsZW1lbnRzLmNvbmNhdChzdmdDYW1lbENhc2VBdHRyaWJ1dGVzKSk7XG5cbiAgdmFyIGVuZm9yY2VDYXNlID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lKSB7XG4gIFx0dmFyIGxvd2VyQ2FzZUVsZW1lbnROYW1lID0gZWxlbWVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgXHRyZXR1cm4gbWFwW2xvd2VyQ2FzZUVsZW1lbnROYW1lXSB8fCBsb3dlckNhc2VFbGVtZW50TmFtZTtcbiAgfTtcblxuICB2YXIgZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIG5hbWUpIHtcbiAgXHR2YXIgY29sb25JbmRleCwgbmFtZXNwYWNlUHJlZml4O1xuXG4gIFx0Ly8gYXJlIHdlIGRlYWxpbmcgd2l0aCBhIG5hbWVzcGFjZWQgYXR0cmlidXRlLCBlLmcuIHhsaW5rOmhyZWY/XG4gIFx0Y29sb25JbmRleCA9IG5hbWUuaW5kZXhPZihcIjpcIik7XG4gIFx0aWYgKGNvbG9uSW5kZXggIT09IC0xKSB7XG5cbiAgXHRcdC8vIGxvb2tzIGxpa2Ugd2UgYXJlLCB5ZXMuLi5cbiAgXHRcdG5hbWVzcGFjZVByZWZpeCA9IG5hbWUuc3Vic3RyKDAsIGNvbG9uSW5kZXgpO1xuXG4gIFx0XHQvLyAuLi51bmxlc3MgaXQncyBhIG5hbWVzcGFjZSAqZGVjbGFyYXRpb24qLCB3aGljaCB3ZSBpZ25vcmUgKG9uIHRoZSBhc3N1bXB0aW9uXG4gIFx0XHQvLyB0aGF0IG9ubHkgdmFsaWQgbmFtZXNwYWNlcyB3aWxsIGJlIHVzZWQpXG4gIFx0XHRpZiAobmFtZXNwYWNlUHJlZml4ICE9PSBcInhtbG5zXCIpIHtcbiAgXHRcdFx0bmFtZSA9IG5hbWUuc3Vic3RyaW5nKGNvbG9uSW5kZXggKyAxKTtcblxuICBcdFx0XHRhdHRyaWJ1dGUubmFtZSA9IGVuZm9yY2VDYXNlKG5hbWUpO1xuICBcdFx0XHRhdHRyaWJ1dGUubmFtZXNwYWNlID0gbmFtZXNwYWNlc1tuYW1lc3BhY2VQcmVmaXgudG9Mb3dlckNhc2UoKV07XG4gIFx0XHRcdGF0dHJpYnV0ZS5uYW1lc3BhY2VQcmVmaXggPSBuYW1lc3BhY2VQcmVmaXg7XG5cbiAgXHRcdFx0aWYgKCFhdHRyaWJ1dGUubmFtZXNwYWNlKSB7XG4gIFx0XHRcdFx0dGhyb3cgXCJVbmtub3duIG5hbWVzcGFjZSAoXFxcIlwiICsgbmFtZXNwYWNlUHJlZml4ICsgXCJcXFwiKVwiO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIFNWRyBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Ugc2Vuc2l0aXZlXG4gIFx0YXR0cmlidXRlLm5hbWUgPSBhdHRyaWJ1dGUuZWxlbWVudC5uYW1lc3BhY2UgIT09IG5hbWVzcGFjZXMuaHRtbCA/IGVuZm9yY2VDYXNlKG5hbWUpIDogbmFtZTtcbiAgfTtcblxuICB2YXIgaGVscGVyc19nZXRJbnRlcnBvbGF0b3IgPSBnZXRJbnRlcnBvbGF0b3I7XG4gIGZ1bmN0aW9uIGdldEludGVycG9sYXRvcihhdHRyaWJ1dGUpIHtcbiAgXHR2YXIgaXRlbXMgPSBhdHRyaWJ1dGUuZnJhZ21lbnQuaXRlbXM7XG5cbiAgXHRpZiAoaXRlbXMubGVuZ3RoICE9PSAxKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKGl0ZW1zWzBdLnR5cGUgPT09IElOVEVSUE9MQVRPUikge1xuICBcdFx0cmV0dXJuIGl0ZW1zWzBdO1xuICBcdH1cbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfaW5pdCA9IEF0dHJpYnV0ZSRpbml0O1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkaW5pdChvcHRpb25zKSB7XG4gIFx0dGhpcy50eXBlID0gQVRUUklCVVRFO1xuICBcdHRoaXMuZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcbiAgXHR0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3Q7XG5cbiAgXHRkZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlKHRoaXMsIG9wdGlvbnMubmFtZSk7XG4gIFx0dGhpcy5pc0Jvb2xlYW4gPSBib29sZWFuQXR0cmlidXRlcy50ZXN0KHRoaXMubmFtZSk7XG5cbiAgXHQvLyBpZiBpdCdzIGFuIGVtcHR5IGF0dHJpYnV0ZSwgb3IganVzdCBhIHN0cmFpZ2h0IGtleS12YWx1ZSBwYWlyLCB3aXRoIG5vXG4gIFx0Ly8gbXVzdGFjaGUgc2hlbmFuaWdhbnMsIHNldCB0aGUgYXR0cmlidXRlIGFjY29yZGluZ2x5IGFuZCBnbyBob21lXG4gIFx0aWYgKCFvcHRpb25zLnZhbHVlIHx8IHR5cGVvZiBvcHRpb25zLnZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHR0aGlzLnZhbHVlID0gdGhpcy5pc0Jvb2xlYW4gPyB0cnVlIDogb3B0aW9ucy52YWx1ZSB8fCBcIlwiO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIG90aGVyd2lzZSB3ZSBuZWVkIHRvIGRvIHNvbWUgd29ya1xuXG4gIFx0Ly8gc2hhcmUgcGFyZW50RnJhZ21lbnQgd2l0aCBwYXJlbnQgZWxlbWVudFxuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0dGVtcGxhdGU6IG9wdGlvbnMudmFsdWUsXG4gIFx0XHRyb290OiB0aGlzLnJvb3QsXG4gIFx0XHRvd25lcjogdGhpc1xuICBcdH0pO1xuXG4gIFx0Ly8gVE9ETyBjYW4gd2UgdXNlIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKSBpbiBzb21lIGNhc2VzPyBJdCdzIHF1aWNrZXJcbiAgXHR0aGlzLnZhbHVlID0gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXG4gIFx0Ly8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhpcyBhdHRyaWJ1dGUncyBpbnRlcnBvbGF0b3IsIGlmIGl0cyBmcmFnbWVudFxuICBcdC8vIHRha2VzIHRoZSBmb3JtIGB7e2Zvb319YC4gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIHR3by13YXkgYmluZGluZyBhbmRcbiAgXHQvLyBmb3IgY29ycmVjdGx5IHJlbmRlcmluZyBIVE1MIGxhdGVyXG4gIFx0dGhpcy5pbnRlcnBvbGF0b3IgPSBoZWxwZXJzX2dldEludGVycG9sYXRvcih0aGlzKTtcbiAgXHR0aGlzLmlzQmluZGFibGUgPSAhIXRoaXMuaW50ZXJwb2xhdG9yICYmICF0aGlzLmludGVycG9sYXRvci5pc1N0YXRpYztcblxuICBcdC8vIG1hcmsgYXMgcmVhZHlcbiAgXHR0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBBdHRyaWJ1dGVfcHJvdG90eXBlX3JlYmluZCA9IEF0dHJpYnV0ZSRyZWJpbmQ7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBBdHRyaWJ1dGVfcHJvdG90eXBlX3JlbmRlciA9IEF0dHJpYnV0ZSRyZW5kZXI7XG4gIHZhciBwcm9wZXJ0eU5hbWVzID0ge1xuICBcdFwiYWNjZXB0LWNoYXJzZXRcIjogXCJhY2NlcHRDaGFyc2V0XCIsXG4gIFx0YWNjZXNza2V5OiBcImFjY2Vzc0tleVwiLFxuICBcdGJnY29sb3I6IFwiYmdDb2xvclwiLFxuICBcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIixcbiAgXHRjb2RlYmFzZTogXCJjb2RlQmFzZVwiLFxuICBcdGNvbHNwYW46IFwiY29sU3BhblwiLFxuICBcdGNvbnRlbnRlZGl0YWJsZTogXCJjb250ZW50RWRpdGFibGVcIixcbiAgXHRkYXRldGltZTogXCJkYXRlVGltZVwiLFxuICBcdGRpcm5hbWU6IFwiZGlyTmFtZVwiLFxuICBcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuICBcdFwiaHR0cC1lcXVpdlwiOiBcImh0dHBFcXVpdlwiLFxuICBcdGlzbWFwOiBcImlzTWFwXCIsXG4gIFx0bWF4bGVuZ3RoOiBcIm1heExlbmd0aFwiLFxuICBcdG5vdmFsaWRhdGU6IFwibm9WYWxpZGF0ZVwiLFxuICBcdHB1YmRhdGU6IFwicHViRGF0ZVwiLFxuICBcdHJlYWRvbmx5OiBcInJlYWRPbmx5XCIsXG4gIFx0cm93c3BhbjogXCJyb3dTcGFuXCIsXG4gIFx0dGFiaW5kZXg6IFwidGFiSW5kZXhcIixcbiAgXHR1c2VtYXA6IFwidXNlTWFwXCJcbiAgfTtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJHJlbmRlcihub2RlKSB7XG4gIFx0dmFyIHByb3BlcnR5TmFtZTtcblxuICBcdHRoaXMubm9kZSA9IG5vZGU7XG5cbiAgXHQvLyBzaG91bGQgd2UgdXNlIGRpcmVjdCBwcm9wZXJ0eSBhY2Nlc3MsIG9yIHNldEF0dHJpYnV0ZT9cbiAgXHRpZiAoIW5vZGUubmFtZXNwYWNlVVJJIHx8IG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLmh0bWwpIHtcbiAgXHRcdHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZXNbdGhpcy5uYW1lXSB8fCB0aGlzLm5hbWU7XG5cbiAgXHRcdGlmIChub2RlW3Byb3BlcnR5TmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gaXMgYXR0cmlidXRlIGEgYm9vbGVhbiBhdHRyaWJ1dGUgb3IgJ3ZhbHVlJz8gSWYgc28gd2UncmUgYmV0dGVyIG9mZiBkb2luZyBlLmcuXG4gIFx0XHQvLyBub2RlLnNlbGVjdGVkID0gdHJ1ZSByYXRoZXIgdGhhbiBub2RlLnNldEF0dHJpYnV0ZSggJ3NlbGVjdGVkJywgJycgKVxuICBcdFx0aWYgKHRoaXMuaXNCb29sZWFuIHx8IHRoaXMuaXNUd293YXkpIHtcbiAgXHRcdFx0dGhpcy51c2VQcm9wZXJ0eSA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChwcm9wZXJ0eU5hbWUgPT09IFwidmFsdWVcIikge1xuICBcdFx0XHRub2RlLl9yYWN0aXZlLnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHR0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgdmFyIEF0dHJpYnV0ZV9wcm90b3R5cGVfdG9TdHJpbmcgPSBBdHRyaWJ1dGUkdG9TdHJpbmc7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHRvU3RyaW5nKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICBcdHZhciBuYW1lc3BhY2VQcmVmaXggPSBfcmVmLm5hbWVzcGFjZVByZWZpeDtcbiAgXHR2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICBcdHZhciBpbnRlcnBvbGF0b3IgPSBfcmVmLmludGVycG9sYXRvcjtcbiAgXHR2YXIgZnJhZ21lbnQgPSBfcmVmLmZyYWdtZW50O1xuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gc2VsZWN0IGFuZCB0ZXh0YXJlYSB2YWx1ZXMgKHNob3VsZCBub3QgYmUgc3RyaW5naWZpZWQpXG4gIFx0aWYgKG5hbWUgPT09IFwidmFsdWVcIiAmJiAodGhpcy5lbGVtZW50Lm5hbWUgPT09IFwic2VsZWN0XCIgfHwgdGhpcy5lbGVtZW50Lm5hbWUgPT09IFwidGV4dGFyZWFcIikpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSBjb250ZW50IGVkaXRhYmxlXG4gIFx0aWYgKG5hbWUgPT09IFwidmFsdWVcIiAmJiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSByYWRpbyBuYW1lc1xuICBcdGlmIChuYW1lID09PSBcIm5hbWVcIiAmJiB0aGlzLmVsZW1lbnQubmFtZSA9PT0gXCJpbnB1dFwiICYmIGludGVycG9sYXRvcikge1xuICBcdFx0cmV0dXJuIFwibmFtZT17e1wiICsgKGludGVycG9sYXRvci5rZXlwYXRoLnN0ciB8fCBpbnRlcnBvbGF0b3IucmVmKSArIFwifX1cIjtcbiAgXHR9XG5cbiAgXHQvLyBCb29sZWFuIGF0dHJpYnV0ZXNcbiAgXHRpZiAodGhpcy5pc0Jvb2xlYW4pIHtcbiAgXHRcdHJldHVybiB2YWx1ZSA/IG5hbWUgOiBcIlwiO1xuICBcdH1cblxuICBcdGlmIChmcmFnbWVudCkge1xuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gdGhpcyBjYXRjaGVzIHVuZGVmaW5lZC9udWxsIHZhbHVlcyAoIzEyMTEpXG4gIFx0XHRpZiAoZnJhZ21lbnQuaXRlbXMubGVuZ3RoID09PSAxICYmIGZyYWdtZW50Lml0ZW1zWzBdLnZhbHVlID09IG51bGwpIHtcbiAgXHRcdFx0cmV0dXJuIFwiXCI7XG4gIFx0XHR9XG5cbiAgXHRcdHZhbHVlID0gZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgXHR9XG5cbiAgXHRpZiAobmFtZXNwYWNlUHJlZml4KSB7XG4gIFx0XHRuYW1lID0gbmFtZXNwYWNlUHJlZml4ICsgXCI6XCIgKyBuYW1lO1xuICBcdH1cblxuICBcdHJldHVybiB2YWx1ZSA/IG5hbWUgKyBcIj1cXFwiXCIgKyBBdHRyaWJ1dGVfcHJvdG90eXBlX3RvU3RyaW5nX19lc2NhcGUodmFsdWUpICsgXCJcXFwiXCIgOiBuYW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlX3Byb3RvdHlwZV90b1N0cmluZ19fZXNjYXBlKHZhbHVlKSB7XG4gIFx0cmV0dXJuIHZhbHVlLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKS5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKS5yZXBsYWNlKC8nL2csIFwiJiMzOTtcIik7XG4gIH1cblxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV91bmJpbmQgPSBBdHRyaWJ1dGUkdW5iaW5kO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1bmJpbmQoKSB7XG4gIFx0Ly8gaWdub3JlIG5vbi1keW5hbWljIGF0dHJpYnV0ZXNcbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5uYW1lID09PSBcImlkXCIpIHtcbiAgXHRcdGRlbGV0ZSB0aGlzLnJvb3Qubm9kZXNbdGhpcy52YWx1ZV07XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZVNlbGVjdFZhbHVlID0gQXR0cmlidXRlJHVwZGF0ZVNlbGVjdDtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlU2VsZWN0KCkge1xuICBcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsXG4gIFx0ICAgIG9wdGlvbnMsXG4gIFx0ICAgIG9wdGlvbixcbiAgXHQgICAgb3B0aW9uVmFsdWUsXG4gIFx0ICAgIGk7XG5cbiAgXHRpZiAoIXRoaXMubG9ja2VkKSB7XG4gIFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcblxuICBcdFx0b3B0aW9ucyA9IHRoaXMubm9kZS5vcHRpb25zO1xuICBcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbaV07XG4gIFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlOyAvLyBvcHRpb25zIGluc2VydGVkIHZpYSBhIHRyaXBsZSBkb24ndCBoYXZlIF9yYWN0aXZlXG5cbiAgXHRcdFx0aWYgKG9wdGlvblZhbHVlID09IHZhbHVlKSB7XG4gIFx0XHRcdFx0Ly8gZG91YmxlIGVxdWFscyBhcyB3ZSBtYXkgYmUgY29tcGFyaW5nIG51bWJlcnMgd2l0aCBzdHJpbmdzXG4gIFx0XHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIGlmIHdlJ3JlIHN0aWxsIGhlcmUsIGl0IG1lYW5zIHRoZSBuZXcgdmFsdWUgZGlkbid0IG1hdGNoIGFueSBvZiB0aGUgb3B0aW9ucy4uLlxuICBcdC8vIFRPRE8gZmlndXJlIG91dCB3aGF0IHRvIGRvIGluIHRoaXMgc2l0dWF0aW9uXG4gIH1cblxuICB2YXIgdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSA9IEF0dHJpYnV0ZSR1cGRhdGVNdWx0aXBsZVNlbGVjdDtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZU11bHRpcGxlU2VsZWN0KCkge1xuICBcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsXG4gIFx0ICAgIG9wdGlvbnMsXG4gIFx0ICAgIGksXG4gIFx0ICAgIG9wdGlvbixcbiAgXHQgICAgb3B0aW9uVmFsdWU7XG5cbiAgXHRpZiAoIWlzQXJyYXkodmFsdWUpKSB7XG4gIFx0XHR2YWx1ZSA9IFt2YWx1ZV07XG4gIFx0fVxuXG4gIFx0b3B0aW9ucyA9IHRoaXMubm9kZS5vcHRpb25zO1xuICBcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdG9wdGlvbiA9IG9wdGlvbnNbaV07XG4gIFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTsgLy8gb3B0aW9ucyBpbnNlcnRlZCB2aWEgYSB0cmlwbGUgZG9uJ3QgaGF2ZSBfcmFjdGl2ZVxuICBcdFx0b3B0aW9uLnNlbGVjdGVkID0gYXJyYXlDb250YWlucyh2YWx1ZSwgb3B0aW9uVmFsdWUpO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVSYWRpb05hbWUgPSBBdHRyaWJ1dGUkdXBkYXRlUmFkaW9OYW1lO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVSYWRpb05hbWUoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcblxuICBcdG5vZGUuY2hlY2tlZCA9IHZhbHVlID09IG5vZGUuX3JhY3RpdmUudmFsdWU7XG4gIH1cblxuICB2YXIgdXBkYXRlUmFkaW9WYWx1ZSA9IEF0dHJpYnV0ZSR1cGRhdGVSYWRpb1ZhbHVlO1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlUmFkaW9WYWx1ZSgpIHtcbiAgXHR2YXIgd2FzQ2hlY2tlZCxcbiAgXHQgICAgbm9kZSA9IHRoaXMubm9kZSxcbiAgXHQgICAgYmluZGluZyxcbiAgXHQgICAgYmluZGluZ3MsXG4gIFx0ICAgIGk7XG5cbiAgXHR3YXNDaGVja2VkID0gbm9kZS5jaGVja2VkO1xuXG4gIFx0bm9kZS52YWx1ZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgXHRub2RlLmNoZWNrZWQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPT09IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpO1xuXG4gIFx0Ly8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSAtIGlmIHRoZSBpbnB1dCB3YXMgY2hlY2tlZCwgYW5kIHRoZSB2YWx1ZVxuICBcdC8vIGNoYW5nZWQgc28gdGhhdCBpdCdzIG5vIGxvbmdlciBjaGVja2VkLCB0aGUgdHdvd2F5IGJpbmRpbmcgaXNcbiAgXHQvLyBtb3N0IGxpa2VseSBvdXQgb2YgZGF0ZS4gVG8gZml4IGl0IHdlIGhhdmUgdG8ganVtcCB0aHJvdWdoIHNvbWVcbiAgXHQvLyBob29wcy4uLiB0aGlzIGlzIGEgbGl0dGxlIGtsdWRneSBidXQgaXQgd29ya3NcbiAgXHRpZiAod2FzQ2hlY2tlZCAmJiAhbm9kZS5jaGVja2VkICYmIHRoaXMuZWxlbWVudC5iaW5kaW5nKSB7XG4gIFx0XHRiaW5kaW5ncyA9IHRoaXMuZWxlbWVudC5iaW5kaW5nLnNpYmxpbmdzO1xuXG4gIFx0XHRpZiAoaSA9IGJpbmRpbmdzLmxlbmd0aCkge1xuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzW2ldO1xuXG4gIFx0XHRcdFx0aWYgKCFiaW5kaW5nLmVsZW1lbnQubm9kZSkge1xuICBcdFx0XHRcdFx0Ly8gdGhpcyBpcyB0aGUgaW5pdGlhbCByZW5kZXIsIHNpYmxpbmdzIGFyZSBzdGlsbCByZW5kZXJpbmchXG4gIFx0XHRcdFx0XHQvLyB3ZSdsbCBjb21lIGJhY2sgbGF0ZXIuLi5cbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoYmluZGluZy5lbGVtZW50Lm5vZGUuY2hlY2tlZCkge1xuICBcdFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkUmFjdGl2ZShiaW5kaW5nLnJvb3QpO1xuICBcdFx0XHRcdFx0cmV0dXJuIGJpbmRpbmcuaGFuZGxlQ2hhbmdlKCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoYmluZGluZy5rZXlwYXRoLCB1bmRlZmluZWQpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVDaGVja2JveE5hbWUgPSBBdHRyaWJ1dGUkdXBkYXRlQ2hlY2tib3hOYW1lO1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ2hlY2tib3hOYW1lKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBlbGVtZW50ID0gX3JlZi5lbGVtZW50O1xuICBcdHZhciBub2RlID0gX3JlZi5ub2RlO1xuICBcdHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7dmFyIGJpbmRpbmcgPSBlbGVtZW50LmJpbmRpbmc7dmFyIHZhbHVlQXR0cmlidXRlO3ZhciBpO1xuXG4gIFx0dmFsdWVBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0aWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICBcdFx0YmluZGluZy5pc0NoZWNrZWQgPSBub2RlLmNoZWNrZWQgPSB2YWx1ZSA9PSB2YWx1ZUF0dHJpYnV0ZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0aSA9IHZhbHVlLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0aWYgKHZhbHVlQXR0cmlidXRlID09IHZhbHVlW2ldKSB7XG4gIFx0XHRcdFx0YmluZGluZy5pc0NoZWNrZWQgPSBub2RlLmNoZWNrZWQgPSB0cnVlO1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0YmluZGluZy5pc0NoZWNrZWQgPSBub2RlLmNoZWNrZWQgPSBmYWxzZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlQ2xhc3NOYW1lID0gQXR0cmlidXRlJHVwZGF0ZUNsYXNzTmFtZTtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUNsYXNzTmFtZSgpIHtcbiAgXHR0aGlzLm5vZGUuY2xhc3NOYW1lID0gc2FmZVRvU3RyaW5nVmFsdWUodGhpcy52YWx1ZSk7XG4gIH1cblxuICB2YXIgdXBkYXRlSWRBdHRyaWJ1dGUgPSBBdHRyaWJ1dGUkdXBkYXRlSWRBdHRyaWJ1dGU7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUlkQXR0cmlidXRlKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBub2RlID0gX3JlZi5ub2RlO1xuICBcdHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG5cbiAgXHR0aGlzLnJvb3Qubm9kZXNbdmFsdWVdID0gbm9kZTtcbiAgXHRub2RlLmlkID0gdmFsdWU7XG4gIH1cblxuICB2YXIgdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZSA9IEF0dHJpYnV0ZSR1cGRhdGVJRVN0eWxlQXR0cmlidXRlO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVJRVN0eWxlQXR0cmlidXRlKCkge1xuICBcdHZhciBub2RlLCB2YWx1ZTtcblxuICBcdG5vZGUgPSB0aGlzLm5vZGU7XG4gIFx0dmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gIFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdHZhbHVlID0gXCJcIjtcbiAgXHR9XG5cbiAgXHRub2RlLnN0eWxlLnNldEF0dHJpYnV0ZShcImNzc1RleHRcIiwgdmFsdWUpO1xuICB9XG5cbiAgdmFyIHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlID0gQXR0cmlidXRlJHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZSgpIHtcbiAgXHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gIFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdHZhbHVlID0gXCJcIjtcbiAgXHR9XG5cbiAgXHRpZiAoIXRoaXMubG9ja2VkKSB7XG4gIFx0XHR0aGlzLm5vZGUuaW5uZXJIVE1MID0gdmFsdWU7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZVZhbHVlID0gQXR0cmlidXRlJHVwZGF0ZVZhbHVlO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVWYWx1ZSgpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgbm9kZSA9IF9yZWYubm9kZTtcbiAgXHR2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuXG4gIFx0Ly8gc3RvcmUgYWN0dWFsIHZhbHVlLCBzbyBpdCBkb2Vzbid0IGdldCBjb2VyY2VkIHRvIGEgc3RyaW5nXG4gIFx0bm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0Ly8gd2l0aCB0d28td2F5IGJpbmRpbmcsIG9ubHkgdXBkYXRlIGlmIHRoZSBjaGFuZ2Ugd2Fzbid0IGluaXRpYXRlZCBieSB0aGUgdXNlclxuICBcdC8vIG90aGVyd2lzZSB0aGUgY3Vyc29yIHdpbGwgb2Z0ZW4gYmUgc2VudCB0byB0aGUgd3JvbmcgcGxhY2VcbiAgXHRpZiAoIXRoaXMubG9ja2VkKSB7XG4gIFx0XHRub2RlLnZhbHVlID0gdmFsdWUgPT0gdW5kZWZpbmVkID8gXCJcIiA6IHZhbHVlO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVCb29sZWFuID0gQXR0cmlidXRlJHVwZGF0ZUJvb2xlYW5BdHRyaWJ1dGU7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUJvb2xlYW5BdHRyaWJ1dGUoKSB7XG4gIFx0Ly8gd2l0aCB0d28td2F5IGJpbmRpbmcsIG9ubHkgdXBkYXRlIGlmIHRoZSBjaGFuZ2Ugd2Fzbid0IGluaXRpYXRlZCBieSB0aGUgdXNlclxuICBcdC8vIG90aGVyd2lzZSB0aGUgY3Vyc29yIHdpbGwgb2Z0ZW4gYmUgc2VudCB0byB0aGUgd3JvbmcgcGxhY2VcbiAgXHRpZiAoIXRoaXMubG9ja2VkKSB7XG4gIFx0XHR0aGlzLm5vZGVbdGhpcy5wcm9wZXJ0eU5hbWVdID0gdGhpcy52YWx1ZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlRXZlcnl0aGluZ0Vsc2UgPSBBdHRyaWJ1dGUkdXBkYXRlRXZlcnl0aGluZ0Vsc2U7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBub2RlID0gX3JlZi5ub2RlO1xuICBcdHZhciBuYW1lc3BhY2UgPSBfcmVmLm5hbWVzcGFjZTtcbiAgXHR2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgXHR2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICBcdHZhciBmcmFnbWVudCA9IF9yZWYuZnJhZ21lbnQ7XG5cbiAgXHRpZiAobmFtZXNwYWNlKSB7XG4gIFx0XHRub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbmFtZSwgKGZyYWdtZW50IHx8IHZhbHVlKS50b1N0cmluZygpKTtcbiAgXHR9IGVsc2UgaWYgKCF0aGlzLmlzQm9vbGVhbikge1xuICBcdFx0aWYgKHZhbHVlID09IG51bGwpIHtcbiAgXHRcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAoZnJhZ21lbnQgfHwgdmFsdWUpLnRvU3RyaW5nKCkpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyAtIHRydXRoeSBiZWNvbWVzICcnLCBmYWxzeSBtZWFucyAncmVtb3ZlIGF0dHJpYnV0ZSdcbiAgXHRlbHNlIHtcbiAgXHRcdGlmICh2YWx1ZSkge1xuICBcdFx0XHRub2RlLnNldEF0dHJpYnV0ZShuYW1lLCBcIlwiKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIC8vIFRoZXJlIGFyZSBhIGZldyBzcGVjaWFsIGNhc2VzIHdoZW4gaXQgY29tZXMgdG8gdXBkYXRpbmcgYXR0cmlidXRlcy4gRm9yIHRoaXMgcmVhc29uLFxuICAvLyB0aGUgcHJvdG90eXBlIC51cGRhdGUoKSBtZXRob2QgcG9pbnRzIHRvIHRoaXMgbWV0aG9kLCB3aGljaCB3YWl0cyB1bnRpbCB0aGVcbiAgLy8gYXR0cmlidXRlIGhhcyBmaW5pc2hlZCBpbml0aWFsaXNpbmcsIHRoZW4gcmVwbGFjZXMgdGhlIHByb3RvdHlwZSBtZXRob2Qgd2l0aCBhIG1vcmVcbiAgLy8gc3VpdGFibGUgb25lLiBUaGF0IHdheSwgd2Ugc2F2ZSBvdXJzZWx2ZXMgZG9pbmcgYSBidW5jaCBvZiB0ZXN0cyBvbiBlYWNoIGNhbGxcbiAgdmFyIEF0dHJpYnV0ZV9wcm90b3R5cGVfdXBkYXRlID0gQXR0cmlidXRlJHVwZGF0ZTtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZSgpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgXHR2YXIgZWxlbWVudCA9IF9yZWYuZWxlbWVudDtcbiAgXHR2YXIgbm9kZSA9IF9yZWYubm9kZTt2YXIgdHlwZTt2YXIgdXBkYXRlTWV0aG9kO1xuXG4gIFx0aWYgKG5hbWUgPT09IFwiaWRcIikge1xuICBcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlSWRBdHRyaWJ1dGU7XG4gIFx0fSBlbHNlIGlmIChuYW1lID09PSBcInZhbHVlXCIpIHtcbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIHNlbGVjdHNcbiAgXHRcdGlmIChlbGVtZW50Lm5hbWUgPT09IFwic2VsZWN0XCIgJiYgbmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gIFx0XHRcdHVwZGF0ZU1ldGhvZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikgPyB1cGRhdGVNdWx0aXBsZVNlbGVjdFZhbHVlIDogdXBkYXRlU2VsZWN0VmFsdWU7XG4gIFx0XHR9IGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gXCJ0ZXh0YXJlYVwiKSB7XG4gIFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBjb250ZW50ZWRpdGFibGVcbiAgXHRcdGVsc2UgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpICE9IG51bGwpIHtcbiAgXHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIDxpbnB1dD5cbiAgXHRcdGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gXCJpbnB1dFwiKSB7XG4gIFx0XHRcdHR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG5cbiAgXHRcdFx0Ly8gdHlwZT0nZmlsZScgdmFsdWU9J3t7ZmlsZUxpc3R9fSc+XG4gIFx0XHRcdGlmICh0eXBlID09PSBcImZpbGVcIikge1xuICBcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IG5vb3A7IC8vIHJlYWQtb25seVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gdHlwZT0ncmFkaW8nIG5hbWU9J3t7dHdvd2F5fX0nXG4gIFx0XHRcdGVsc2UgaWYgKHR5cGUgPT09IFwicmFkaW9cIiAmJiBlbGVtZW50LmJpbmRpbmcgJiYgZWxlbWVudC5iaW5kaW5nLm5hbWUgPT09IFwibmFtZVwiKSB7XG4gIFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlUmFkaW9WYWx1ZTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVWYWx1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIHNwZWNpYWwgY2FzZSAtIDxpbnB1dCB0eXBlPSdyYWRpbycgbmFtZT0ne3t0d293YXl9fScgdmFsdWU9J2Zvbyc+XG4gIFx0ZWxzZSBpZiAodGhpcy5pc1R3b3dheSAmJiBuYW1lID09PSBcIm5hbWVcIikge1xuICBcdFx0aWYgKG5vZGUudHlwZSA9PT0gXCJyYWRpb1wiKSB7XG4gIFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVJhZGlvTmFtZTtcbiAgXHRcdH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgXHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQ2hlY2tib3hOYW1lO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIHNwZWNpYWwgY2FzZSAtIHN0eWxlIGF0dHJpYnV0ZXMgaW4gSW50ZXJuZXQgRXhwbG9kZXJcbiAgXHRlbHNlIGlmIChuYW1lID09PSBcInN0eWxlXCIgJiYgbm9kZS5zdHlsZS5zZXRBdHRyaWJ1dGUpIHtcbiAgXHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGU7XG4gIFx0fVxuXG4gIFx0Ly8gc3BlY2lhbCBjYXNlIC0gY2xhc3MgbmFtZXMuIElFIGZ1Y2tzIHRoaW5ncyB1cCwgYWdhaW5cbiAgXHRlbHNlIGlmIChuYW1lID09PSBcImNsYXNzXCIgJiYgKCFub2RlLm5hbWVzcGFjZVVSSSB8fCBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5odG1sKSkge1xuICBcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQ2xhc3NOYW1lO1xuICBcdH0gZWxzZSBpZiAodGhpcy51c2VQcm9wZXJ0eSkge1xuICBcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQm9vbGVhbjtcbiAgXHR9XG5cbiAgXHRpZiAoIXVwZGF0ZU1ldGhvZCkge1xuICBcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlRXZlcnl0aGluZ0Vsc2U7XG4gIFx0fVxuXG4gIFx0dGhpcy51cGRhdGUgPSB1cGRhdGVNZXRob2Q7XG4gIFx0dGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHZhciBBdHRyaWJ1dGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfTtcblxuICBBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogQXR0cmlidXRlX3Byb3RvdHlwZV9idWJibGUsXG4gIFx0aW5pdDogcHJvdG90eXBlX2luaXQsXG4gIFx0cmViaW5kOiBBdHRyaWJ1dGVfcHJvdG90eXBlX3JlYmluZCxcbiAgXHRyZW5kZXI6IEF0dHJpYnV0ZV9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHRvU3RyaW5nOiBBdHRyaWJ1dGVfcHJvdG90eXBlX3RvU3RyaW5nLFxuICBcdHVuYmluZDogQXR0cmlidXRlX3Byb3RvdHlwZV91bmJpbmQsXG4gIFx0dXBkYXRlOiBBdHRyaWJ1dGVfcHJvdG90eXBlX3VwZGF0ZVxuICB9O1xuXG4gIHZhciBfQXR0cmlidXRlID0gQXR0cmlidXRlO1xuXG4gIHZhciBjcmVhdGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgXHR2YXIgbmFtZSxcbiAgXHQgICAgYXR0cmlidXRlLFxuICBcdCAgICByZXN1bHQgPSBbXTtcblxuICBcdGZvciAobmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gIFx0XHQvLyBza2lwIGJpbmRpbmcgYXR0cmlidXRlc1xuICBcdFx0aWYgKG5hbWUgPT09IFwidHdvd2F5XCIgfHwgbmFtZSA9PT0gXCJsYXp5XCIpIHtcbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gIFx0XHRcdGF0dHJpYnV0ZSA9IG5ldyBfQXR0cmlidXRlKHtcbiAgXHRcdFx0XHRlbGVtZW50OiBlbGVtZW50LFxuICBcdFx0XHRcdG5hbWU6IG5hbWUsXG4gIFx0XHRcdFx0dmFsdWU6IGF0dHJpYnV0ZXNbbmFtZV0sXG4gIFx0XHRcdFx0cm9vdDogZWxlbWVudC5yb290XG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHJlc3VsdFtuYW1lXSA9IGF0dHJpYnV0ZTtcblxuICBcdFx0XHRpZiAobmFtZSAhPT0gXCJ2YWx1ZVwiKSB7XG4gIFx0XHRcdFx0cmVzdWx0LnB1c2goYXR0cmlidXRlKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIHZhbHVlIGF0dHJpYnV0ZSBnb2VzIGxhc3QuIFRoaXMgaXMgYmVjYXVzZSBpdFxuICBcdC8vIG1heSBnZXQgY2xhbXBlZCBvbiByZW5kZXIgb3RoZXJ3aXNlLCBlLmcuIGluXG4gIFx0Ly8gYDxpbnB1dCB0eXBlPSdyYW5nZScgdmFsdWU9Jzk5OScgbWluPScwJyBtYXg9JzEwMDAnPmBcbiAgXHQvLyBzaW5jZSBkZWZhdWx0IG1heCBpcyAxMDBcbiAgXHRpZiAoYXR0cmlidXRlID0gcmVzdWx0LnZhbHVlKSB7XG4gIFx0XHRyZXN1bHQucHVzaChhdHRyaWJ1dGUpO1xuICBcdH1cblxuICBcdHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIF9Db25kaXRpb25hbEF0dHJpYnV0ZV9fZGl2O1xuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgXHRfQ29uZGl0aW9uYWxBdHRyaWJ1dGVfX2RpdiA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIH1cblxuICB2YXIgQ29uZGl0aW9uYWxBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgdGVtcGxhdGUpIHtcbiAgXHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IGVsZW1lbnQucm9vdDtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcblxuICBcdHRoaXMuYXR0cmlidXRlcyA9IFtdO1xuXG4gIFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdHJvb3Q6IGVsZW1lbnQucm9vdCxcbiAgXHRcdG93bmVyOiB0aGlzLFxuICBcdFx0dGVtcGxhdGU6IFt0ZW1wbGF0ZV1cbiAgXHR9KTtcbiAgfTtcblxuICBDb25kaXRpb25hbEF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5ub2RlKSB7XG4gIFx0XHRcdHRoaXMudXBkYXRlKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZWxlbWVudC5idWJibGUoKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgXHRcdHRoaXMubm9kZSA9IG5vZGU7XG4gIFx0XHR0aGlzLmlzU3ZnID0gbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuc3ZnO1xuXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fSxcblxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIHN0ciwgYXR0cnM7XG5cbiAgXHRcdHN0ciA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgXHRcdGF0dHJzID0gcGFyc2VBdHRyaWJ1dGVzKHN0ciwgdGhpcy5pc1N2Zyk7XG5cbiAgXHRcdC8vIGFueSBhdHRyaWJ1dGVzIHRoYXQgcHJldmlvdXNseSBleGlzdGVkIGJ1dCBubyBsb25nZXIgZG9cbiAgXHRcdC8vIG11c3QgYmUgcmVtb3ZlZFxuICBcdFx0dGhpcy5hdHRyaWJ1dGVzLmZpbHRlcihmdW5jdGlvbiAoYSkge1xuICBcdFx0XHRyZXR1cm4gbm90SW4oYXR0cnMsIGEpO1xuICBcdFx0fSkuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICBcdFx0XHRfdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShhLm5hbWUpO1xuICBcdFx0fSk7XG5cbiAgXHRcdGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgXHRcdFx0X3RoaXMubm9kZS5zZXRBdHRyaWJ1dGUoYS5uYW1lLCBhLnZhbHVlKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBfQ29uZGl0aW9uYWxBdHRyaWJ1dGUgPSBDb25kaXRpb25hbEF0dHJpYnV0ZTtcblxuICBmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoc3RyLCBpc1N2Zykge1xuICBcdHZhciB0YWcgPSBpc1N2ZyA/IFwic3ZnXCIgOiBcImRpdlwiO1xuICBcdF9Db25kaXRpb25hbEF0dHJpYnV0ZV9fZGl2LmlubmVySFRNTCA9IFwiPFwiICsgdGFnICsgXCIgXCIgKyBzdHIgKyBcIj48L1wiICsgdGFnICsgXCI+XCI7XG5cbiAgXHRyZXR1cm4gdG9BcnJheShfQ29uZGl0aW9uYWxBdHRyaWJ1dGVfX2Rpdi5jaGlsZE5vZGVzWzBdLmF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90SW4oaGF5c3RhY2ssIG5lZWRsZSkge1xuICBcdHZhciBpID0gaGF5c3RhY2subGVuZ3RoO1xuXG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKGhheXN0YWNrW2ldLm5hbWUgPT09IG5lZWRsZS5uYW1lKSB7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBjcmVhdGVDb25kaXRpb25hbEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBcdGlmICghYXR0cmlidXRlcykge1xuICBcdFx0cmV0dXJuIFtdO1xuICBcdH1cblxuICBcdHJldHVybiBhdHRyaWJ1dGVzLm1hcChmdW5jdGlvbiAoYSkge1xuICBcdFx0cmV0dXJuIG5ldyBfQ29uZGl0aW9uYWxBdHRyaWJ1dGUoZWxlbWVudCwgYSk7XG4gIFx0fSk7XG4gIH07XG5cbiAgdmFyIEJpbmRpbmcgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBcdHZhciBpbnRlcnBvbGF0b3IsIGtleXBhdGgsIHZhbHVlLCBwYXJlbnRGb3JtO1xuXG4gIFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgXHR0aGlzLnJvb3QgPSBlbGVtZW50LnJvb3Q7XG4gIFx0dGhpcy5hdHRyaWJ1dGUgPSBlbGVtZW50LmF0dHJpYnV0ZXNbdGhpcy5uYW1lIHx8IFwidmFsdWVcIl07XG5cbiAgXHRpbnRlcnBvbGF0b3IgPSB0aGlzLmF0dHJpYnV0ZS5pbnRlcnBvbGF0b3I7XG4gIFx0aW50ZXJwb2xhdG9yLnR3b3dheUJpbmRpbmcgPSB0aGlzO1xuXG4gIFx0aWYgKGtleXBhdGggPSBpbnRlcnBvbGF0b3Iua2V5cGF0aCkge1xuICBcdFx0aWYgKGtleXBhdGguc3RyLnNsaWNlKC0xKSA9PT0gXCJ9XCIpIHtcbiAgXHRcdFx0d2Fybk9uY2VJZkRlYnVnKFwiVHdvLXdheSBiaW5kaW5nIGRvZXMgbm90IHdvcmsgd2l0aCBleHByZXNzaW9ucyAoYCVzYCBvbiA8JXM+KVwiLCBpbnRlcnBvbGF0b3IucmVzb2x2ZXIudW5pcXVlU3RyaW5nLCBlbGVtZW50Lm5hbWUsIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChrZXlwYXRoLmlzU3BlY2lhbCkge1xuICBcdFx0XHR3YXJuT25jZUlmRGVidWcoXCJUd28td2F5IGJpbmRpbmcgZG9lcyBub3Qgd29yayB3aXRoICVzXCIsIGludGVycG9sYXRvci5yZXNvbHZlci5yZWYsIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIEEgbXVzdGFjaGUgbWF5IGJlICphbWJpZ3VvdXMqLiBMZXQncyBzYXkgd2Ugd2VyZSBnaXZlblxuICBcdFx0Ly8gYHZhbHVlPVwie3tiYXJ9fVwiYC4gSWYgdGhlIGNvbnRleHQgd2FzIGBmb29gLCBhbmQgYGZvby5iYXJgXG4gIFx0XHQvLyAqd2Fzbid0KiBgdW5kZWZpbmVkYCwgdGhlIGtleXBhdGggd291bGQgYmUgYGZvby5iYXJgLlxuICBcdFx0Ly8gVGhlbiwgYW55IHVzZXIgaW5wdXQgd291bGQgcmVzdWx0IGluIGBmb28uYmFyYCBiZWluZyB1cGRhdGVkLlxuICBcdFx0Ly9cbiAgXHRcdC8vIElmLCBob3dldmVyLCBgZm9vLmJhcmAgKndhcyogdW5kZWZpbmVkLCBhbmQgc28gd2FzIGBiYXJgLCB3ZSB3b3VsZCBiZVxuICBcdFx0Ly8gbGVmdCB3aXRoIGFuIHVucmVzb2x2ZWQgcGFydGlhbCBrZXlwYXRoIC0gc28gd2UgYXJlIGZvcmNlZCB0byBtYWtlIGFuXG4gIFx0XHQvLyBhc3N1bXB0aW9uLiBUaGF0IGFzc3VtcHRpb24gaXMgdGhhdCB0aGUgaW5wdXQgaW4gcXVlc3Rpb24gc2hvdWxkXG4gIFx0XHQvLyBiZSBmb3JjZWQgdG8gcmVzb2x2ZSB0byBgYmFyYCwgYW5kIGFueSB1c2VyIGlucHV0IHdvdWxkIGFmZmVjdCBgYmFyYFxuICBcdFx0Ly8gYW5kIG5vdCBgZm9vLmJhcmAuXG4gIFx0XHQvL1xuICBcdFx0Ly8gRGlkIHRoYXQgbWFrZSBhbnkgc2Vuc2U/IE5vPyBPaC4gU29ycnkuIFdlbGwgdGhlIG1vcmFsIG9mIHRoZSBzdG9yeSBpc1xuICBcdFx0Ly8gYmUgZXhwbGljaXQgd2hlbiB1c2luZyB0d28td2F5IGRhdGEtYmluZGluZyBhYm91dCB3aGF0IGtleXBhdGggeW91J3JlXG4gIFx0XHQvLyB1cGRhdGluZy4gVXNpbmcgaXQgaW4gbGlzdHMgaXMgcHJvYmFibHkgYSByZWNpcGUgZm9yIGNvbmZ1c2lvbi4uLlxuICBcdFx0dmFyIHJlZiA9IGludGVycG9sYXRvci50ZW1wbGF0ZS5yID8gXCInXCIgKyBpbnRlcnBvbGF0b3IudGVtcGxhdGUuciArIFwiJyByZWZlcmVuY2VcIiA6IFwiZXhwcmVzc2lvblwiO1xuICBcdFx0d2FybklmRGVidWcoXCJUaGUgJXMgYmVpbmcgdXNlZCBmb3IgdHdvLXdheSBiaW5kaW5nIGlzIGFtYmlndW91cywgYW5kIG1heSBjYXVzZSB1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnNpZGVyIGluaXRpYWxpc2luZyB5b3VyIGRhdGEgdG8gZWxpbWluYXRlIHRoZSBhbWJpZ3VpdHlcIiwgcmVmLCB7IHJhY3RpdmU6IHRoaXMucm9vdCB9KTtcbiAgXHRcdGludGVycG9sYXRvci5yZXNvbHZlci5mb3JjZVJlc29sdXRpb24oKTtcbiAgXHRcdGtleXBhdGggPSBpbnRlcnBvbGF0b3Iua2V5cGF0aDtcbiAgXHR9XG5cbiAgXHR0aGlzLmF0dHJpYnV0ZS5pc1R3b3dheSA9IHRydWU7XG4gIFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblxuICBcdC8vIGluaXRpYWxpc2UgdmFsdWUsIGlmIGl0J3MgdW5kZWZpbmVkXG4gIFx0dmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuZ2V0SW5pdGlhbFZhbHVlKSB7XG4gIFx0XHR2YWx1ZSA9IHRoaXMuZ2V0SW5pdGlhbFZhbHVlKCk7XG5cbiAgXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAocGFyZW50Rm9ybSA9IGZpbmRQYXJlbnRGb3JtKGVsZW1lbnQpKSB7XG4gIFx0XHR0aGlzLnJlc2V0VmFsdWUgPSB2YWx1ZTtcbiAgXHRcdHBhcmVudEZvcm0uZm9ybUJpbmRpbmdzLnB1c2godGhpcyk7XG4gIFx0fVxuICB9O1xuXG4gIEJpbmRpbmcucHJvdG90eXBlID0ge1xuICBcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcy5yb290KTtcbiAgXHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG4gIFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCh0aGlzLmtleXBhdGgsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gX3RoaXMuYXR0cmlidXRlLmxvY2tlZCA9IGZhbHNlO1xuICBcdFx0fSk7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHR9LFxuXG4gIFx0cmVib3VuZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGJpbmRpbmdzLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoO1xuXG4gIFx0XHRvbGRLZXlwYXRoID0gdGhpcy5rZXlwYXRoO1xuICBcdFx0bmV3S2V5cGF0aCA9IHRoaXMuYXR0cmlidXRlLmludGVycG9sYXRvci5rZXlwYXRoO1xuXG4gIFx0XHQvLyBUaGUgYXR0cmlidXRlIHRoaXMgYmluZGluZyBpcyBsaW5rZWQgdG8gaGFzIGFscmVhZHkgZG9uZSB0aGUgd29ya1xuICBcdFx0aWYgKG9sZEtleXBhdGggPT09IG5ld0tleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tvbGRLZXlwYXRoLnN0cl0sIHRoaXMpO1xuXG4gIFx0XHR0aGlzLmtleXBhdGggPSBuZXdLZXlwYXRoO1xuXG4gIFx0XHRiaW5kaW5ncyA9IHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbbmV3S2V5cGF0aC5zdHJdIHx8ICh0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzW25ld0tleXBhdGguc3RyXSA9IFtdKTtcbiAgXHRcdGJpbmRpbmdzLnB1c2godGhpcyk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge31cbiAgfTtcblxuICBCaW5kaW5nLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG4gIFx0dmFyIFBhcmVudCA9IHRoaXMsXG4gIFx0ICAgIFNwZWNpYWxpc2VkQmluZGluZztcblxuICBcdFNwZWNpYWxpc2VkQmluZGluZyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIFx0XHRCaW5kaW5nLmNhbGwodGhpcywgZWxlbWVudCk7XG5cbiAgXHRcdGlmICh0aGlzLmluaXQpIHtcbiAgXHRcdFx0dGhpcy5pbml0KCk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdFNwZWNpYWxpc2VkQmluZGluZy5wcm90b3R5cGUgPSBjcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG4gIFx0dXRpbHNfb2JqZWN0X19leHRlbmQoU3BlY2lhbGlzZWRCaW5kaW5nLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG5cbiAgXHRTcGVjaWFsaXNlZEJpbmRpbmcuZXh0ZW5kID0gQmluZGluZy5leHRlbmQ7XG5cbiAgXHRyZXR1cm4gU3BlY2lhbGlzZWRCaW5kaW5nO1xuICB9O1xuXG4gIHZhciBCaW5kaW5nX0JpbmRpbmcgPSBCaW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGZpbmRQYXJlbnRGb3JtKGVsZW1lbnQpIHtcbiAgXHR3aGlsZSAoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50KSB7XG4gIFx0XHRpZiAoZWxlbWVudC5uYW1lID09PSBcImZvcm1cIikge1xuICBcdFx0XHRyZXR1cm4gZWxlbWVudDtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICAvLyB0aGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBlbGVtZW50IGlzIHVuYm91bmQuXG4gIC8vIFNwZWNpYWxpc2VkIGJpbmRpbmdzIGNhbiBvdmVycmlkZSBpdFxuXG4gIC8vIFRoaXMgaXMgdGhlIGhhbmRsZXIgZm9yIERPTSBldmVudHMgdGhhdCB3b3VsZCBsZWFkIHRvIGEgY2hhbmdlIGluIHRoZSBtb2RlbFxuICAvLyAoaS5lLiBjaGFuZ2UsIHNvbWV0aW1lcywgaW5wdXQsIGFuZCBvY2Nhc2lvbmFsbHkgY2xpY2sgYW5kIGtleXVwKVxuICB2YXIgaGFuZGxlRG9tRXZlbnQgPSBoYW5kbGVDaGFuZ2U7XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKCkge1xuICBcdHRoaXMuX3JhY3RpdmUuYmluZGluZy5oYW5kbGVDaGFuZ2UoKTtcbiAgfVxuXG4gIHZhciBHZW5lcmljQmluZGluZztcblxuICBHZW5lcmljQmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIFwiXCI7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUudmFsdWU7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZSxcbiAgXHRcdCAgICBsYXp5LFxuICBcdFx0ICAgIHRpbWVvdXQgPSBmYWxzZTtcbiAgXHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXG4gIFx0XHQvLyBhbnkgbGF6eSBzZXR0aW5nIGZvciB0aGlzIGVsZW1lbnQgb3ZlcnJpZGVzIHRoZSByb290XG4gIFx0XHQvLyBpZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0J3MgYSB0aW1lb3V0XG4gIFx0XHRsYXp5ID0gdGhpcy5yb290Lmxhenk7XG4gIFx0XHRpZiAodGhpcy5lbGVtZW50LmxhenkgPT09IHRydWUpIHtcbiAgXHRcdFx0bGF6eSA9IHRydWU7XG4gIFx0XHR9IGVsc2UgaWYgKHRoaXMuZWxlbWVudC5sYXp5ID09PSBmYWxzZSkge1xuICBcdFx0XHRsYXp5ID0gZmFsc2U7XG4gIFx0XHR9IGVsc2UgaWYgKGlzX19pc051bWVyaWModGhpcy5lbGVtZW50LmxhenkpKSB7XG4gIFx0XHRcdGxhenkgPSBmYWxzZTtcbiAgXHRcdFx0dGltZW91dCA9ICt0aGlzLmVsZW1lbnQubGF6eTtcbiAgXHRcdH0gZWxzZSBpZiAoaXNfX2lzTnVtZXJpYyhsYXp5IHx8IFwiXCIpKSB7XG4gIFx0XHRcdHRpbWVvdXQgPSArbGF6eTtcbiAgXHRcdFx0bGF6eSA9IGZhbHNlO1xuXG4gIFx0XHRcdC8vIG1ha2Ugc3VyZSB0aGUgdGltZW91dCBpcyBhdmFpbGFibGUgdG8gdGhlIGhhbmRsZXJcbiAgXHRcdFx0dGhpcy5lbGVtZW50LmxhenkgPSB0aW1lb3V0O1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmhhbmRsZXIgPSB0aW1lb3V0ID8gaGFuZGxlRGVsYXkgOiBoYW5kbGVEb21FdmVudDtcblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdGlmICghbGF6eSkge1xuICBcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLmhhbmRsZXIsIGZhbHNlKTtcblxuICBcdFx0XHRpZiAobm9kZS5hdHRhY2hFdmVudCkge1xuICBcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMuaGFuZGxlciwgZmFsc2UpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgaGFuZGxlQmx1ciwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcbiAgXHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcblxuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLmhhbmRsZXIsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMuaGFuZGxlciwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBoYW5kbGVCbHVyLCBmYWxzZSk7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19HZW5lcmljQmluZGluZyA9IEdlbmVyaWNCaW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUJsdXIoKSB7XG4gIFx0dmFyIHZhbHVlO1xuXG4gIFx0aGFuZGxlRG9tRXZlbnQuY2FsbCh0aGlzKTtcblxuICBcdHZhbHVlID0gdGhpcy5fcmFjdGl2ZS5yb290LnZpZXdtb2RlbC5nZXQodGhpcy5fcmFjdGl2ZS5iaW5kaW5nLmtleXBhdGgpO1xuICBcdHRoaXMudmFsdWUgPSB2YWx1ZSA9PSB1bmRlZmluZWQgPyBcIlwiIDogdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVEZWxheSgpIHtcbiAgXHR2YXIgYmluZGluZyA9IHRoaXMuX3JhY3RpdmUuYmluZGluZyxcbiAgXHQgICAgZWwgPSB0aGlzO1xuXG4gIFx0aWYgKCEhYmluZGluZy5fdGltZW91dCkgY2xlYXJUaW1lb3V0KGJpbmRpbmcuX3RpbWVvdXQpO1xuXG4gIFx0YmluZGluZy5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKGJpbmRpbmcucmVuZGVyZWQpIGhhbmRsZURvbUV2ZW50LmNhbGwoZWwpO1xuICBcdFx0YmluZGluZy5fdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgXHR9LCBiaW5kaW5nLmVsZW1lbnQubGF6eSk7XG4gIH1cblxuICB2YXIgQ29udGVudEVkaXRhYmxlQmluZGluZyA9IEJpbmRpbmdfR2VuZXJpY0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQuZnJhZ21lbnQgPyB0aGlzLmVsZW1lbnQuZnJhZ21lbnQudG9TdHJpbmcoKSA6IFwiXCI7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuaW5uZXJIVE1MO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfQ29udGVudEVkaXRhYmxlQmluZGluZyA9IENvbnRlbnRFZGl0YWJsZUJpbmRpbmc7XG5cbiAgdmFyIHNoYXJlZF9nZXRTaWJsaW5ncyA9IGdldFNpYmxpbmdzO1xuICB2YXIgc2V0cyA9IHt9O1xuICBmdW5jdGlvbiBnZXRTaWJsaW5ncyhpZCwgZ3JvdXAsIGtleXBhdGgpIHtcbiAgXHR2YXIgaGFzaCA9IGlkICsgZ3JvdXAgKyBrZXlwYXRoO1xuICBcdHJldHVybiBzZXRzW2hhc2hdIHx8IChzZXRzW2hhc2hdID0gW10pO1xuICB9XG5cbiAgdmFyIFJhZGlvQmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdG5hbWU6IFwiY2hlY2tlZFwiLFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5zaWJsaW5ncyA9IHNoYXJlZF9nZXRTaWJsaW5ncyh0aGlzLnJvb3QuX2d1aWQsIFwicmFkaW9cIiwgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcIm5hbWVcIikpO1xuICBcdFx0dGhpcy5zaWJsaW5ncy5wdXNoKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuXG4gIFx0XHRpZiAobm9kZS5hdHRhY2hFdmVudCkge1xuICBcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMucm9vdCk7XG5cbiAgXHRcdHRoaXMuc2libGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoYmluZGluZykge1xuICBcdFx0XHRiaW5kaW5nLnJvb3Qudmlld21vZGVsLnNldChiaW5kaW5nLmtleXBhdGgsIGJpbmRpbmcuZ2V0VmFsdWUoKSk7XG4gIFx0XHR9KTtcblxuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodGhpcy5zaWJsaW5ncywgdGhpcyk7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19SYWRpb0JpbmRpbmcgPSBSYWRpb0JpbmRpbmc7XG5cbiAgdmFyIFJhZGlvTmFtZUJpbmRpbmcgPSBCaW5kaW5nX0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRuYW1lOiBcIm5hbWVcIixcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuc2libGluZ3MgPSBzaGFyZWRfZ2V0U2libGluZ3ModGhpcy5yb290Ll9ndWlkLCBcInJhZGlvbmFtZVwiLCB0aGlzLmtleXBhdGguc3RyKTtcbiAgXHRcdHRoaXMuc2libGluZ3MucHVzaCh0aGlzKTtcblxuICBcdFx0dGhpcy5yYWRpb05hbWUgPSB0cnVlOyAvLyBzbyB0aGF0IHJhY3RpdmUudXBkYXRlTW9kZWwoKSBrbm93cyB3aGF0IHRvIGRvIHdpdGggdGhpc1xuICBcdH0sXG5cbiAgXHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiKSkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUubmFtZSA9IFwie3tcIiArIHRoaXMua2V5cGF0aC5zdHIgKyBcIn19XCI7XG4gIFx0XHRub2RlLmNoZWNrZWQgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLmtleXBhdGgpID09IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdGlmIChub2RlLmF0dGFjaEV2ZW50KSB7XG4gIFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuICBcdFx0cmV0dXJuIG5vZGUuX3JhY3RpdmUgPyBub2RlLl9yYWN0aXZlLnZhbHVlIDogbm9kZS52YWx1ZTtcbiAgXHR9LFxuXG4gIFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBJZiB0aGlzIDxpbnB1dD4gaXMgdGhlIG9uZSB0aGF0J3MgY2hlY2tlZCwgdGhlbiB0aGUgdmFsdWUgb2YgaXRzXG4gIFx0XHQvLyBgbmFtZWAga2V5cGF0aCBnZXRzIHNldCB0byBpdHMgdmFsdWVcbiAgXHRcdGlmICh0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkKSB7XG4gIFx0XHRcdEJpbmRpbmdfQmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwodGhpcyk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlYm91bmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHR2YXIgbm9kZTtcblxuICBcdFx0QmluZGluZ19CaW5kaW5nLnByb3RvdHlwZS5yZWJvdW5kLmNhbGwodGhpcywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG5cbiAgXHRcdGlmIChub2RlID0gdGhpcy5lbGVtZW50Lm5vZGUpIHtcbiAgXHRcdFx0bm9kZS5uYW1lID0gXCJ7e1wiICsgdGhpcy5rZXlwYXRoLnN0ciArIFwifX1cIjtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodGhpcy5zaWJsaW5ncywgdGhpcyk7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19SYWRpb05hbWVCaW5kaW5nID0gUmFkaW9OYW1lQmluZGluZztcblxuICB2YXIgQ2hlY2tib3hOYW1lQmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdG5hbWU6IFwibmFtZVwiLFxuXG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgb25jZSBwZXIgZ3JvdXAgKG9mIGlucHV0cyB0aGF0XG4gIFx0XHQvLyBzaGFyZSBhIG5hbWUpLCBiZWNhdXNlIGl0IG9ubHkgZ2V0cyBjYWxsZWQgaWYgdGhlcmVcbiAgXHRcdC8vIGlzbid0IGFuIGluaXRpYWwgdmFsdWUuIEJ5IHRoZSBzYW1lIHRva2VuLCB3ZSBjYW4gbWFrZVxuICBcdFx0Ly8gYSBub3RlIG9mIHRoYXQgZmFjdCB0aGF0IHRoZXJlIHdhcyBubyBpbml0aWFsIHZhbHVlLFxuICBcdFx0Ly8gYW5kIHBvcHVsYXRlIGl0IHVzaW5nIGFueSBgY2hlY2tlZGAgYXR0cmlidXRlcyB0aGF0XG4gIFx0XHQvLyBleGlzdCAod2hpY2ggdXNlcnMgc2hvdWxkIGF2b2lkLCBidXQgd2hpY2ggd2Ugc2hvdWxkXG4gIFx0XHQvLyBzdXBwb3J0IGFueXdheSB0byBhdm9pZCBicmVha2luZyBleHBlY3RhdGlvbnMpXG4gIFx0XHR0aGlzLm5vSW5pdGlhbFZhbHVlID0gdHJ1ZTtcbiAgXHRcdHJldHVybiBbXTtcbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGV4aXN0aW5nVmFsdWUsIGJpbmRpbmdWYWx1ZTtcblxuICBcdFx0dGhpcy5jaGVja2JveE5hbWUgPSB0cnVlOyAvLyBzbyB0aGF0IHJhY3RpdmUudXBkYXRlTW9kZWwoKSBrbm93cyB3aGF0IHRvIGRvIHdpdGggdGhpc1xuXG4gIFx0XHQvLyBFYWNoIGlucHV0IGhhcyBhIHJlZmVyZW5jZSB0byBhbiBhcnJheSBjb250YWluaW5nIGl0IGFuZCBpdHNcbiAgXHRcdC8vIHNpYmxpbmdzLCBhcyB0d28td2F5IGJpbmRpbmcgZGVwZW5kcyBvbiBiZWluZyBhYmxlIHRvIGFzY2VydGFpblxuICBcdFx0Ly8gdGhlIHN0YXR1cyBvZiBhbGwgaW5wdXRzIHdpdGhpbiB0aGUgZ3JvdXBcbiAgXHRcdHRoaXMuc2libGluZ3MgPSBzaGFyZWRfZ2V0U2libGluZ3ModGhpcy5yb290Ll9ndWlkLCBcImNoZWNrYm94ZXNcIiwgdGhpcy5rZXlwYXRoLnN0cik7XG4gIFx0XHR0aGlzLnNpYmxpbmdzLnB1c2godGhpcyk7XG5cbiAgXHRcdGlmICh0aGlzLm5vSW5pdGlhbFZhbHVlKSB7XG4gIFx0XHRcdHRoaXMuc2libGluZ3Mubm9Jbml0aWFsVmFsdWUgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBJZiBubyBpbml0aWFsIHZhbHVlIHdhcyBzZXQsIGFuZCB0aGlzIGlucHV0IGlzIGNoZWNrZWQsIHdlXG4gIFx0XHQvLyB1cGRhdGUgdGhlIG1vZGVsXG4gIFx0XHRpZiAodGhpcy5zaWJsaW5ncy5ub0luaXRpYWxWYWx1ZSAmJiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiKSkge1xuICBcdFx0XHRleGlzdGluZ1ZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQodGhpcy5rZXlwYXRoKTtcbiAgXHRcdFx0YmluZGluZ1ZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0XHRcdGV4aXN0aW5nVmFsdWUucHVzaChiaW5kaW5nVmFsdWUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLnNpYmxpbmdzLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlLFxuICBcdFx0ICAgIGV4aXN0aW5nVmFsdWUsXG4gIFx0XHQgICAgYmluZGluZ1ZhbHVlO1xuXG4gIFx0XHRleGlzdGluZ1ZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQodGhpcy5rZXlwYXRoKTtcbiAgXHRcdGJpbmRpbmdWYWx1ZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblxuICBcdFx0aWYgKGlzQXJyYXkoZXhpc3RpbmdWYWx1ZSkpIHtcbiAgXHRcdFx0dGhpcy5pc0NoZWNrZWQgPSBhcnJheUNvbnRhaW5zKGV4aXN0aW5nVmFsdWUsIGJpbmRpbmdWYWx1ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IGV4aXN0aW5nVmFsdWUgPT0gYmluZGluZ1ZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHRub2RlLm5hbWUgPSBcInt7XCIgKyB0aGlzLmtleXBhdGguc3RyICsgXCJ9fVwiO1xuICBcdFx0bm9kZS5jaGVja2VkID0gdGhpcy5pc0NoZWNrZWQ7XG5cbiAgXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuXG4gIFx0XHQvLyBpbiBjYXNlIG9mIElFIGVtZXJnZW5jeSwgYmluZCB0byBjbGljayBldmVudCBhcyB3ZWxsXG4gIFx0XHRpZiAobm9kZS5hdHRhY2hFdmVudCkge1xuICBcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRjaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgd2FzQ2hlY2tlZCA9ICEhdGhpcy5pc0NoZWNrZWQ7XG4gIFx0XHR0aGlzLmlzQ2hlY2tlZCA9IHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG4gIFx0XHRyZXR1cm4gdGhpcy5pc0NoZWNrZWQgPT09IHdhc0NoZWNrZWQ7XG4gIFx0fSxcblxuICBcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5pc0NoZWNrZWQgPSB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuICBcdFx0QmluZGluZ19CaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UuY2FsbCh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLnNpYmxpbmdzLmZpbHRlcihpc0NoZWNrZWQpLm1hcChCaW5kaW5nX0NoZWNrYm94TmFtZUJpbmRpbmdfX2dldFZhbHVlKTtcbiAgXHR9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGlzQ2hlY2tlZChiaW5kaW5nKSB7XG4gIFx0cmV0dXJuIGJpbmRpbmcuaXNDaGVja2VkO1xuICB9XG5cbiAgZnVuY3Rpb24gQmluZGluZ19DaGVja2JveE5hbWVCaW5kaW5nX19nZXRWYWx1ZShiaW5kaW5nKSB7XG4gIFx0cmV0dXJuIGJpbmRpbmcuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgfVxuXG4gIHZhciBCaW5kaW5nX0NoZWNrYm94TmFtZUJpbmRpbmcgPSBDaGVja2JveE5hbWVCaW5kaW5nO1xuXG4gIHZhciBDaGVja2JveEJpbmRpbmcgPSBCaW5kaW5nX0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRuYW1lOiBcImNoZWNrZWRcIixcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdGlmIChub2RlLmF0dGFjaEV2ZW50KSB7XG4gIFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX0NoZWNrYm94QmluZGluZyA9IENoZWNrYm94QmluZGluZztcblxuICB2YXIgU2VsZWN0QmluZGluZyA9IEJpbmRpbmdfQmluZGluZy5leHRlbmQoe1xuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQub3B0aW9ucyxcbiAgXHRcdCAgICBsZW4sXG4gIFx0XHQgICAgaSxcbiAgXHRcdCAgICB2YWx1ZSxcbiAgXHRcdCAgICBvcHRpb25XYXNTZWxlY3RlZDtcblxuICBcdFx0aWYgKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aSA9IGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuXG4gIFx0XHRpZiAoIWxlbikge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHRha2UgdGhlIGZpbmFsIHNlbGVjdGVkIG9wdGlvbi4uLlxuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpZiAob3B0aW9uc1tpXS5nZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKSkge1xuICBcdFx0XHRcdHZhbHVlID0gb3B0aW9uc1tpXS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgXHRcdFx0XHRvcHRpb25XYXNTZWxlY3RlZCA9IHRydWU7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gb3IgdGhlIGZpcnN0IG5vbi1kaXNhYmxlZCBvcHRpb24sIGlmIG5vbmUgYXJlIHNlbGVjdGVkXG4gIFx0XHRpZiAoIW9wdGlvbldhc1NlbGVjdGVkKSB7XG4gIFx0XHRcdHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgXHRcdFx0XHRpZiAoIW9wdGlvbnNbaV0uZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikpIHtcbiAgXHRcdFx0XHRcdHZhbHVlID0gb3B0aW9uc1tpXS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgXHRcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBUaGlzIGlzIGFuIG9wdGltaXNhdGlvbiAoYWthIGhhY2spIHRoYXQgYWxsb3dzIHVzIHRvIGZvcmdvIHNvbWVcbiAgXHRcdC8vIG90aGVyIG1vcmUgZXhwZW5zaXZlIHdvcmtcbiAgXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMuZWxlbWVudC5hdHRyaWJ1dGVzLnZhbHVlLnZhbHVlID0gdmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB2YWx1ZTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdC8vIFRPRE8gdGhpcyBtZXRob2QgaXMgYW4gYW5vbWFseS4uLiBpcyBpdCBuZWNlc3Nhcnk/XG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQodGhpcy5rZXlwYXRoLCB2YWx1ZSk7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgb3B0aW9ucywgaSwgbGVuLCBvcHRpb24sIG9wdGlvblZhbHVlO1xuXG4gIFx0XHRvcHRpb25zID0gdGhpcy5lbGVtZW50Lm5vZGUub3B0aW9ucztcbiAgXHRcdGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuXG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0b3B0aW9uID0gb3B0aW9uc1tpXTtcblxuICBcdFx0XHRpZiAob3B0aW9uc1tpXS5zZWxlY3RlZCkge1xuICBcdFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlO1xuICBcdFx0XHRcdHJldHVybiBvcHRpb25WYWx1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRmb3JjZVVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHJldHVybiBfdGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG4gIFx0XHRcdH0pO1xuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCh0aGlzLmtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX1NlbGVjdEJpbmRpbmcgPSBTZWxlY3RCaW5kaW5nO1xuXG4gIHZhciBNdWx0aXBsZVNlbGVjdEJpbmRpbmcgPSBCaW5kaW5nX1NlbGVjdEJpbmRpbmcuZXh0ZW5kKHtcbiAgXHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQub3B0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKG9wdGlvbikge1xuICBcdFx0XHRyZXR1cm4gb3B0aW9uLmdldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIpO1xuICBcdFx0fSkubWFwKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgXHRcdFx0cmV0dXJuIG9wdGlvbi5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgXHRcdH0pO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB2YWx1ZUZyb21Nb2RlbDtcblxuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuXG4gIFx0XHR2YWx1ZUZyb21Nb2RlbCA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KHRoaXMua2V5cGF0aCk7XG5cbiAgXHRcdGlmICh2YWx1ZUZyb21Nb2RlbCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdC8vIGdldCB2YWx1ZSBmcm9tIERPTSwgaWYgcG9zc2libGVcbiAgXHRcdFx0dGhpcy5oYW5kbGVDaGFuZ2UoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIlRPRE8gbm90IGltcGxlbWVudGVkIHlldFwiKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBzZWxlY3RlZFZhbHVlcywgb3B0aW9ucywgaSwgbGVuLCBvcHRpb24sIG9wdGlvblZhbHVlO1xuXG4gIFx0XHRzZWxlY3RlZFZhbHVlcyA9IFtdO1xuICBcdFx0b3B0aW9ucyA9IHRoaXMuZWxlbWVudC5ub2RlLm9wdGlvbnM7XG4gIFx0XHRsZW4gPSBvcHRpb25zLmxlbmd0aDtcblxuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbaV07XG5cbiAgXHRcdFx0aWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICBcdFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlO1xuICBcdFx0XHRcdHNlbGVjdGVkVmFsdWVzLnB1c2gob3B0aW9uVmFsdWUpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBzZWxlY3RlZFZhbHVlcztcbiAgXHR9LFxuXG4gIFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgYXR0cmlidXRlLCBwcmV2aW91c1ZhbHVlLCB2YWx1ZTtcblxuICBcdFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGU7XG4gIFx0XHRwcmV2aW91c1ZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuXG4gIFx0XHR2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICBcdFx0aWYgKHByZXZpb3VzVmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhYXJyYXlDb250ZW50c01hdGNoKHZhbHVlLCBwcmV2aW91c1ZhbHVlKSkge1xuICBcdFx0XHRCaW5kaW5nX1NlbGVjdEJpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZS5jYWxsKHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcztcbiAgXHR9LFxuXG4gIFx0Zm9yY2VVcGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICBcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gdHJ1ZTtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gX3RoaXMuYXR0cmlidXRlLmxvY2tlZCA9IGZhbHNlO1xuICBcdFx0XHR9KTtcbiAgXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQodGhpcy5rZXlwYXRoLCB2YWx1ZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVwZGF0ZU1vZGVsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUudmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhdGhpcy5hdHRyaWJ1dGUudmFsdWUubGVuZ3RoKSB7XG4gIFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KHRoaXMua2V5cGF0aCwgdGhpcy5pbml0aWFsVmFsdWUpO1xuICBcdFx0fVxuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfTXVsdGlwbGVTZWxlY3RCaW5kaW5nID0gTXVsdGlwbGVTZWxlY3RCaW5kaW5nO1xuXG4gIHZhciBGaWxlTGlzdEJpbmRpbmcgPSBCaW5kaW5nX0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5maWxlcztcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX0ZpbGVMaXN0QmluZGluZyA9IEZpbGVMaXN0QmluZGluZztcblxuICB2YXIgTnVtZXJpY0JpbmRpbmcgPSBCaW5kaW5nX0dlbmVyaWNCaW5kaW5nLmV4dGVuZCh7XG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLmVsZW1lbnQubm9kZS52YWx1ZSk7XG4gIFx0XHRyZXR1cm4gaXNOYU4odmFsdWUpID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgaW5pdF9jcmVhdGVUd293YXlCaW5kaW5nID0gY3JlYXRlVHdvd2F5QmluZGluZztcblxuICBmdW5jdGlvbiBjcmVhdGVUd293YXlCaW5kaW5nKGVsZW1lbnQpIHtcbiAgXHR2YXIgYXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcyxcbiAgXHQgICAgdHlwZSxcbiAgXHQgICAgQmluZGluZyxcbiAgXHQgICAgYmluZE5hbWUsXG4gIFx0ICAgIGJpbmRDaGVja2VkLFxuICBcdCAgICBiaW5kaW5nO1xuXG4gIFx0Ly8gaWYgdGhpcyBpcyBhIGxhdGUgYmluZGluZywgYW5kIHRoZXJlJ3MgYWxyZWFkeSBvbmUsIGl0XG4gIFx0Ly8gbmVlZHMgdG8gYmUgdG9ybiBkb3duXG4gIFx0aWYgKGVsZW1lbnQuYmluZGluZykge1xuICBcdFx0ZWxlbWVudC5iaW5kaW5nLnRlYXJkb3duKCk7XG4gIFx0XHRlbGVtZW50LmJpbmRpbmcgPSBudWxsO1xuICBcdH1cblxuICBcdC8vIGNvbnRlbnRlZGl0YWJsZVxuICBcdGlmIChcbiAgXHQvLyBpZiB0aGUgY29udGVudGVkaXRhYmxlIGF0dHJpYnV0ZSBpcyB0cnVlIG9yIGlzIGJpbmRhYmxlIGFuZCBtYXkgdGh1cyBiZWNvbWUgdHJ1ZVxuICBcdChlbGVtZW50LmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSB8fCAhIWF0dHJpYnV0ZXMuY29udGVudGVkaXRhYmxlICYmIGlzQmluZGFibGUoYXR0cmlidXRlcy5jb250ZW50ZWRpdGFibGUpKSAmJiBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMudmFsdWUpKSB7XG4gIFx0XHRCaW5kaW5nID0gQmluZGluZ19Db250ZW50RWRpdGFibGVCaW5kaW5nO1xuICBcdH1cblxuICBcdC8vIDxpbnB1dD5cbiAgXHRlbHNlIGlmIChlbGVtZW50Lm5hbWUgPT09IFwiaW5wdXRcIikge1xuICBcdFx0dHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcblxuICBcdFx0aWYgKHR5cGUgPT09IFwicmFkaW9cIiB8fCB0eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgXHRcdFx0YmluZE5hbWUgPSBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMubmFtZSk7XG4gIFx0XHRcdGJpbmRDaGVja2VkID0gaXNCaW5kYWJsZShhdHRyaWJ1dGVzLmNoZWNrZWQpO1xuXG4gIFx0XHRcdC8vIHdlIGNhbiBlaXRoZXIgYmluZCB0aGUgbmFtZSBhdHRyaWJ1dGUsIG9yIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSAtIG5vdCBib3RoXG4gIFx0XHRcdGlmIChiaW5kTmFtZSAmJiBiaW5kQ2hlY2tlZCkge1xuICBcdFx0XHRcdHdhcm5JZkRlYnVnKFwiQSByYWRpbyBpbnB1dCBjYW4gaGF2ZSB0d28td2F5IGJpbmRpbmcgb24gaXRzIG5hbWUgYXR0cmlidXRlLCBvciBpdHMgY2hlY2tlZCBhdHRyaWJ1dGUgLSBub3QgYm90aFwiLCB7IHJhY3RpdmU6IGVsZW1lbnQucm9vdCB9KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChiaW5kTmFtZSkge1xuICBcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSBcInJhZGlvXCIgPyBCaW5kaW5nX1JhZGlvTmFtZUJpbmRpbmcgOiBCaW5kaW5nX0NoZWNrYm94TmFtZUJpbmRpbmc7XG4gIFx0XHRcdH0gZWxzZSBpZiAoYmluZENoZWNrZWQpIHtcbiAgXHRcdFx0XHRCaW5kaW5nID0gdHlwZSA9PT0gXCJyYWRpb1wiID8gQmluZGluZ19SYWRpb0JpbmRpbmcgOiBCaW5kaW5nX0NoZWNrYm94QmluZGluZztcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIGlmICh0eXBlID09PSBcImZpbGVcIiAmJiBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMudmFsdWUpKSB7XG4gIFx0XHRcdEJpbmRpbmcgPSBCaW5kaW5nX0ZpbGVMaXN0QmluZGluZztcbiAgXHRcdH0gZWxzZSBpZiAoaXNCaW5kYWJsZShhdHRyaWJ1dGVzLnZhbHVlKSkge1xuICBcdFx0XHRCaW5kaW5nID0gdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInJhbmdlXCIgPyBOdW1lcmljQmluZGluZyA6IEJpbmRpbmdfR2VuZXJpY0JpbmRpbmc7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gPHNlbGVjdD5cbiAgXHRlbHNlIGlmIChlbGVtZW50Lm5hbWUgPT09IFwic2VsZWN0XCIgJiYgaXNCaW5kYWJsZShhdHRyaWJ1dGVzLnZhbHVlKSkge1xuICBcdFx0QmluZGluZyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikgPyBCaW5kaW5nX011bHRpcGxlU2VsZWN0QmluZGluZyA6IEJpbmRpbmdfU2VsZWN0QmluZGluZztcbiAgXHR9XG5cbiAgXHQvLyA8dGV4dGFyZWE+XG4gIFx0ZWxzZSBpZiAoZWxlbWVudC5uYW1lID09PSBcInRleHRhcmVhXCIgJiYgaXNCaW5kYWJsZShhdHRyaWJ1dGVzLnZhbHVlKSkge1xuICBcdFx0QmluZGluZyA9IEJpbmRpbmdfR2VuZXJpY0JpbmRpbmc7XG4gIFx0fVxuXG4gIFx0aWYgKEJpbmRpbmcgJiYgKGJpbmRpbmcgPSBuZXcgQmluZGluZyhlbGVtZW50KSkgJiYgYmluZGluZy5rZXlwYXRoKSB7XG4gIFx0XHRyZXR1cm4gYmluZGluZztcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBpc0JpbmRhYmxlKGF0dHJpYnV0ZSkge1xuICBcdHJldHVybiBhdHRyaWJ1dGUgJiYgYXR0cmlidXRlLmlzQmluZGFibGU7XG4gIH1cblxuICAvLyBhbmQgdGhpcyBlbGVtZW50IGFsc28gaGFzIGEgdmFsdWUgYXR0cmlidXRlIHRvIGJpbmRcblxuICB2YXIgRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9idWJibGUgPSBFdmVudEhhbmRsZXIkYnViYmxlO1xuXG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRidWJibGUoKSB7XG4gIFx0dmFyIGhhc0FjdGlvbiA9IHRoaXMuZ2V0QWN0aW9uKCk7XG5cbiAgXHRpZiAoaGFzQWN0aW9uICYmICF0aGlzLmhhc0xpc3RlbmVyKSB7XG4gIFx0XHR0aGlzLmxpc3RlbigpO1xuICBcdH0gZWxzZSBpZiAoIWhhc0FjdGlvbiAmJiB0aGlzLmhhc0xpc3RlbmVyKSB7XG4gIFx0XHR0aGlzLnVucmVuZGVyKCk7XG4gIFx0fVxuICB9XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBtYXkgYmUgb3ZlcndyaXR0ZW4sIGlmIHRoZSBldmVudCBkaXJlY3RpdmVcbiAgLy8gaW5jbHVkZXMgcGFyYW1ldGVyc1xuICB2YXIgRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9maXJlID0gRXZlbnRIYW5kbGVyJGZpcmU7XG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRmaXJlKGV2ZW50KSB7XG4gIFx0c2hhcmVkX2ZpcmVFdmVudCh0aGlzLnJvb3QsIHRoaXMuZ2V0QWN0aW9uKCksIHsgZXZlbnQ6IGV2ZW50IH0pO1xuICB9XG5cbiAgdmFyIGdldEFjdGlvbiA9IEV2ZW50SGFuZGxlciRnZXRBY3Rpb247XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGdldEFjdGlvbigpIHtcbiAgXHRyZXR1cm4gdGhpcy5hY3Rpb24udG9TdHJpbmcoKS50cmltKCk7XG4gIH1cblxuICB2YXIgRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9pbml0ID0gRXZlbnRIYW5kbGVyJGluaXQ7XG5cbiAgdmFyIGV2ZW50UGF0dGVybiA9IC9eZXZlbnQoPzpcXC4oLispKT8vO1xuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkaW5pdChlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgYWN0aW9uLCByZWZzLCByYWN0aXZlO1xuXG4gIFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgXHR0aGlzLnJvb3QgPSBlbGVtZW50LnJvb3Q7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5uYW1lID0gbmFtZTtcblxuICBcdGlmIChuYW1lLmluZGV4T2YoXCIqXCIpICE9PSAtMSkge1xuICBcdFx0ZmF0YWwoXCJPbmx5IGNvbXBvbmVudCBwcm94eS1ldmVudHMgbWF5IGNvbnRhaW4gXFxcIipcXFwiIHdpbGRjYXJkcywgPCVzIG9uLSVzPVxcXCIuLi5cXFwiLz4gaXMgbm90IHZhbGlkXCIsIGVsZW1lbnQubmFtZSwgbmFtZSk7XG4gIFx0XHR0aGlzLmludmFsaWQgPSB0cnVlO1xuICBcdH1cblxuICBcdGlmICh0ZW1wbGF0ZS5tKSB7XG4gIFx0XHRyZWZzID0gdGVtcGxhdGUuYS5yO1xuXG4gIFx0XHQvLyBUaGlzIGlzIGEgbWV0aG9kIGNhbGxcbiAgXHRcdHRoaXMubWV0aG9kID0gdGVtcGxhdGUubTtcbiAgXHRcdHRoaXMua2V5cGF0aHMgPSBbXTtcbiAgXHRcdHRoaXMuZm4gPSBzaGFyZWRfZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nKHRlbXBsYXRlLmEucywgcmVmcy5sZW5ndGgpO1xuXG4gIFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHRcdHJhY3RpdmUgPSB0aGlzLnJvb3Q7XG5cbiAgXHRcdC8vIENyZWF0ZSByZXNvbHZlcnMgZm9yIGVhY2ggcmVmZXJlbmNlXG4gIFx0XHR0aGlzLnJlZlJlc29sdmVycyA9IFtdO1xuICBcdFx0cmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYsIGkpIHtcbiAgXHRcdFx0dmFyIG1hdGNoID0gdW5kZWZpbmVkO1xuXG4gIFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIHRoZSBgZXZlbnRgIG9iamVjdFxuICBcdFx0XHRpZiAobWF0Y2ggPSBldmVudFBhdHRlcm4uZXhlYyhyZWYpKSB7XG4gIFx0XHRcdFx0X3RoaXMua2V5cGF0aHNbaV0gPSB7XG4gIFx0XHRcdFx0XHRldmVudE9iamVjdDogdHJ1ZSxcbiAgXHRcdFx0XHRcdHJlZmluZW1lbnRzOiBtYXRjaFsxXSA/IG1hdGNoWzFdLnNwbGl0KFwiLlwiKSA6IFtdXG4gIFx0XHRcdFx0fTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRfdGhpcy5yZWZSZXNvbHZlcnMucHVzaChSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoX3RoaXMsIHJlZiwgZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0XHRcdHJldHVybiBfdGhpcy5yZXNvbHZlKGksIGtleXBhdGgpO1xuICBcdFx0XHRcdH0pKTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMuZmlyZSA9IGZpcmVNZXRob2RDYWxsO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBHZXQgYWN0aW9uICgnZm9vJyBpbiAnb24tY2xpY2s9J2ZvbycpXG4gIFx0XHRhY3Rpb24gPSB0ZW1wbGF0ZS5uIHx8IHRlbXBsYXRlO1xuICBcdFx0aWYgKHR5cGVvZiBhY3Rpb24gIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0YWN0aW9uID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHRcdHRlbXBsYXRlOiBhY3Rpb24sXG4gIFx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuICBcdFx0XHRcdG93bmVyOiB0aGlzXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmFjdGlvbiA9IGFjdGlvbjtcblxuICBcdFx0Ly8gR2V0IHBhcmFtZXRlcnNcbiAgXHRcdGlmICh0ZW1wbGF0ZS5kKSB7XG4gIFx0XHRcdHRoaXMuZHluYW1pY1BhcmFtcyA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZCxcbiAgXHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG4gIFx0XHRcdFx0b3duZXI6IHRoaXMuZWxlbWVudFxuICBcdFx0XHR9KTtcblxuICBcdFx0XHR0aGlzLmZpcmUgPSBmaXJlRXZlbnRXaXRoRHluYW1pY1BhcmFtcztcbiAgXHRcdH0gZWxzZSBpZiAodGVtcGxhdGUuYSkge1xuICBcdFx0XHR0aGlzLnBhcmFtcyA9IHRlbXBsYXRlLmE7XG4gIFx0XHRcdHRoaXMuZmlyZSA9IGZpcmVFdmVudFdpdGhQYXJhbXM7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZmlyZU1ldGhvZENhbGwoZXZlbnQpIHtcbiAgXHR2YXIgcmFjdGl2ZSwgdmFsdWVzLCBhcmdzO1xuXG4gIFx0cmFjdGl2ZSA9IHRoaXMucm9vdDtcblxuICBcdGlmICh0eXBlb2YgcmFjdGl2ZVt0aGlzLm1ldGhvZF0gIT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGNhbGwgYSBub24tZXhpc3RlbnQgbWV0aG9kIChcXFwiXCIgKyB0aGlzLm1ldGhvZCArIFwiXFxcIilcIik7XG4gIFx0fVxuXG4gIFx0dmFsdWVzID0gdGhpcy5rZXlwYXRocy5tYXAoZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHZhciB2YWx1ZSwgbGVuLCBpO1xuXG4gIFx0XHRpZiAoa2V5cGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdC8vIG5vdCB5ZXQgcmVzb2x2ZWRcbiAgXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gVE9ETyB0aGUgcmVmaW5lbWVudHMgc3R1ZmYgd291bGQgYmUgYmV0dGVyIGhhbmRsZWQgYXQgcGFyc2UgdGltZVxuICBcdFx0aWYgKGtleXBhdGguZXZlbnRPYmplY3QpIHtcbiAgXHRcdFx0dmFsdWUgPSBldmVudDtcblxuICBcdFx0XHRpZiAobGVuID0ga2V5cGF0aC5yZWZpbmVtZW50cy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVba2V5cGF0aC5yZWZpbmVtZW50c1tpXV07XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR2YWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLmdldChrZXlwYXRoKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHZhbHVlO1xuICBcdH0pO1xuXG4gIFx0c2hhcmVkX2V2ZW50U3RhY2suZW5xdWV1ZShyYWN0aXZlLCBldmVudCk7XG5cbiAgXHRhcmdzID0gdGhpcy5mbi5hcHBseShudWxsLCB2YWx1ZXMpO1xuICBcdHJhY3RpdmVbdGhpcy5tZXRob2RdLmFwcGx5KHJhY3RpdmUsIGFyZ3MpO1xuXG4gIFx0c2hhcmVkX2V2ZW50U3RhY2suZGVxdWV1ZShyYWN0aXZlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVFdmVudFdpdGhQYXJhbXMoZXZlbnQpIHtcbiAgXHRzaGFyZWRfZmlyZUV2ZW50KHRoaXMucm9vdCwgdGhpcy5nZXRBY3Rpb24oKSwgeyBldmVudDogZXZlbnQsIGFyZ3M6IHRoaXMucGFyYW1zIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUV2ZW50V2l0aER5bmFtaWNQYXJhbXMoZXZlbnQpIHtcbiAgXHR2YXIgYXJncyA9IHRoaXMuZHluYW1pY1BhcmFtcy5nZXRBcmdzTGlzdCgpO1xuXG4gIFx0Ly8gbmVlZCB0byBzdHJpcCBbXSBmcm9tIGVuZHMgaWYgYSBzdHJpbmchXG4gIFx0aWYgKHR5cGVvZiBhcmdzID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRhcmdzID0gYXJncy5zdWJzdHIoMSwgYXJncy5sZW5ndGggLSAyKTtcbiAgXHR9XG5cbiAgXHRzaGFyZWRfZmlyZUV2ZW50KHRoaXMucm9vdCwgdGhpcy5nZXRBY3Rpb24oKSwgeyBldmVudDogZXZlbnQsIGFyZ3M6IGFyZ3MgfSk7XG4gIH1cblxuICB2YXIgc2hhcmVkX2dlbmVyaWNIYW5kbGVyID0gZ2VuZXJpY0hhbmRsZXI7XG4gIGZ1bmN0aW9uIGdlbmVyaWNIYW5kbGVyKGV2ZW50KSB7XG4gIFx0dmFyIHN0b3JhZ2UsXG4gIFx0ICAgIGhhbmRsZXIsXG4gIFx0ICAgIGluZGljZXMsXG4gIFx0ICAgIGluZGV4ID0ge307XG5cbiAgXHRzdG9yYWdlID0gdGhpcy5fcmFjdGl2ZTtcbiAgXHRoYW5kbGVyID0gc3RvcmFnZS5ldmVudHNbZXZlbnQudHlwZV07XG5cbiAgXHRpZiAoaW5kaWNlcyA9IFJlc29sdmVyc19maW5kSW5kZXhSZWZzKGhhbmRsZXIuZWxlbWVudC5wYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdGluZGV4ID0gUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMucmVzb2x2ZShpbmRpY2VzKTtcbiAgXHR9XG5cbiAgXHRoYW5kbGVyLmZpcmUoe1xuICBcdFx0bm9kZTogdGhpcyxcbiAgXHRcdG9yaWdpbmFsOiBldmVudCxcbiAgXHRcdGluZGV4OiBpbmRleCxcbiAgXHRcdGtleXBhdGg6IHN0b3JhZ2Uua2V5cGF0aC5zdHIsXG4gIFx0XHRjb250ZXh0OiBzdG9yYWdlLnJvb3Qudmlld21vZGVsLmdldChzdG9yYWdlLmtleXBhdGgpXG4gIFx0fSk7XG4gIH1cblxuICB2YXIgbGlzdGVuID0gRXZlbnRIYW5kbGVyJGxpc3RlbjtcblxuICB2YXIgY3VzdG9tSGFuZGxlcnMgPSB7fSxcbiAgICAgIHRvdWNoRXZlbnRzID0ge1xuICBcdHRvdWNoc3RhcnQ6IHRydWUsXG4gIFx0dG91Y2htb3ZlOiB0cnVlLFxuICBcdHRvdWNoZW5kOiB0cnVlLFxuICBcdHRvdWNoY2FuY2VsOiB0cnVlLFxuICBcdC8vbm90IHczYywgYnV0IHN1cHBvcnRlZCBpbiBzb21lIGJyb3dzZXJzXG4gIFx0dG91Y2hsZWF2ZTogdHJ1ZVxuICB9O1xuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkbGlzdGVuKCkge1xuICBcdHZhciBkZWZpbml0aW9uLFxuICBcdCAgICBuYW1lID0gdGhpcy5uYW1lO1xuXG4gIFx0aWYgKHRoaXMuaW52YWxpZCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmIChkZWZpbml0aW9uID0gZmluZEluVmlld0hpZXJhcmNoeShcImV2ZW50c1wiLCB0aGlzLnJvb3QsIG5hbWUpKSB7XG4gIFx0XHR0aGlzLmN1c3RvbSA9IGRlZmluaXRpb24odGhpcy5ub2RlLCBnZXRDdXN0b21IYW5kbGVyKG5hbWUpKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gTG9va3MgbGlrZSB3ZSdyZSBkZWFsaW5nIHdpdGggYSBzdGFuZGFyZCBET00gZXZlbnQuLi4gYnV0IGxldCdzIGNoZWNrXG4gIFx0XHRpZiAoIShcIm9uXCIgKyBuYW1lIGluIHRoaXMubm9kZSkgJiYgISh3aW5kb3cgJiYgXCJvblwiICsgbmFtZSBpbiB3aW5kb3cpICYmICFpc0pzZG9tKSB7XG5cbiAgXHRcdFx0Ly8gb2theSB0byB1c2UgdG91Y2ggZXZlbnRzIGlmIHRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlbVxuICBcdFx0XHRpZiAoIXRvdWNoRXZlbnRzW25hbWVdKSB7XG4gIFx0XHRcdFx0d2Fybk9uY2VJZkRlYnVnKG1pc3NpbmdQbHVnaW4obmFtZSwgXCJldmVudFwiKSwgeyBub2RlOiB0aGlzLm5vZGUgfSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIHNoYXJlZF9nZW5lcmljSGFuZGxlciwgZmFsc2UpO1xuICBcdH1cblxuICBcdHRoaXMuaGFzTGlzdGVuZXIgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VzdG9tSGFuZGxlcihuYW1lKSB7XG4gIFx0aWYgKCFjdXN0b21IYW5kbGVyc1tuYW1lXSkge1xuICBcdFx0Y3VzdG9tSGFuZGxlcnNbbmFtZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgXHRcdFx0dmFyIHN0b3JhZ2UgPSBldmVudC5ub2RlLl9yYWN0aXZlO1xuXG4gIFx0XHRcdGV2ZW50LmluZGV4ID0gc3RvcmFnZS5pbmRleDtcbiAgXHRcdFx0ZXZlbnQua2V5cGF0aCA9IHN0b3JhZ2Uua2V5cGF0aC5zdHI7XG4gIFx0XHRcdGV2ZW50LmNvbnRleHQgPSBzdG9yYWdlLnJvb3Qudmlld21vZGVsLmdldChzdG9yYWdlLmtleXBhdGgpO1xuXG4gIFx0XHRcdHN0b3JhZ2UuZXZlbnRzW25hbWVdLmZpcmUoZXZlbnQpO1xuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gY3VzdG9tSGFuZGxlcnNbbmFtZV07XG4gIH1cblxuICB2YXIgRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9yZWJpbmQgPSBFdmVudEhhbmRsZXIkcmViaW5kO1xuXG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRyZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdHZhciBmcmFnbWVudDtcbiAgXHRpZiAodGhpcy5tZXRob2QpIHtcbiAgXHRcdGZyYWdtZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudEZyYWdtZW50O1xuICBcdFx0dGhpcy5yZWZSZXNvbHZlcnMuZm9yRWFjaChyZWJpbmQpO1xuXG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiB0aGlzLmFjdGlvbiAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0cmViaW5kKHRoaXMuYWN0aW9uKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5keW5hbWljUGFyYW1zKSB7XG4gIFx0XHRyZWJpbmQodGhpcy5keW5hbWljUGFyYW1zKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiByZWJpbmQodGhpbmcpIHtcbiAgXHRcdHRoaW5nICYmIHRoaW5nLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9yZW5kZXIgPSBFdmVudEhhbmRsZXIkcmVuZGVyO1xuXG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRyZW5kZXIoKSB7XG4gIFx0dGhpcy5ub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG4gIFx0Ly8gc3RvcmUgdGhpcyBvbiB0aGUgbm9kZSBpdHNlbGYsIHNvIGl0IGNhbiBiZSByZXRyaWV2ZWQgYnkgYVxuICBcdC8vIHVuaXZlcnNhbCBoYW5kbGVyXG4gIFx0dGhpcy5ub2RlLl9yYWN0aXZlLmV2ZW50c1t0aGlzLm5hbWVdID0gdGhpcztcblxuICBcdGlmICh0aGlzLm1ldGhvZCB8fCB0aGlzLmdldEFjdGlvbigpKSB7XG4gIFx0XHR0aGlzLmxpc3RlbigpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfcmVzb2x2ZSA9IEV2ZW50SGFuZGxlciRyZXNvbHZlO1xuXG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRyZXNvbHZlKGluZGV4LCBrZXlwYXRoKSB7XG4gIFx0dGhpcy5rZXlwYXRoc1tpbmRleF0gPSBrZXlwYXRoO1xuICB9XG5cbiAgdmFyIEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfdW5iaW5kID0gRXZlbnRIYW5kbGVyJHVuYmluZDtcbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHVuYmluZCgpIHtcbiAgXHRpZiAodGhpcy5tZXRob2QpIHtcbiAgXHRcdHRoaXMucmVmUmVzb2x2ZXJzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBUZWFyIGRvd24gZHluYW1pYyBuYW1lXG4gIFx0aWYgKHR5cGVvZiB0aGlzLmFjdGlvbiAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0dGhpcy5hY3Rpb24udW5iaW5kKCk7XG4gIFx0fVxuXG4gIFx0Ly8gVGVhciBkb3duIGR5bmFtaWMgcGFyYW1ldGVyc1xuICBcdGlmICh0aGlzLmR5bmFtaWNQYXJhbXMpIHtcbiAgXHRcdHRoaXMuZHluYW1pY1BhcmFtcy51bmJpbmQoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV91bnJlbmRlciA9IEV2ZW50SGFuZGxlciR1bnJlbmRlcjtcbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHVucmVuZGVyKCkge1xuXG4gIFx0aWYgKHRoaXMuY3VzdG9tKSB7XG4gIFx0XHR0aGlzLmN1c3RvbS50ZWFyZG93bigpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLm5hbWUsIHNoYXJlZF9nZW5lcmljSGFuZGxlciwgZmFsc2UpO1xuICBcdH1cblxuICBcdHRoaXMuaGFzTGlzdGVuZXIgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSwgdGVtcGxhdGUpIHtcbiAgXHR0aGlzLmluaXQoZWxlbWVudCwgbmFtZSwgdGVtcGxhdGUpO1xuICB9O1xuXG4gIEV2ZW50SGFuZGxlci5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2J1YmJsZSxcbiAgXHRmaXJlOiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2ZpcmUsXG4gIFx0Z2V0QWN0aW9uOiBnZXRBY3Rpb24sXG4gIFx0aW5pdDogRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9pbml0LFxuICBcdGxpc3RlbjogbGlzdGVuLFxuICBcdHJlYmluZDogRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV9yZWJpbmQsXG4gIFx0cmVuZGVyOiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3JlbmRlcixcbiAgXHRyZXNvbHZlOiBwcm90b3R5cGVfcmVzb2x2ZSxcbiAgXHR1bmJpbmQ6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfdW5iaW5kLFxuICBcdHVucmVuZGVyOiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3VucmVuZGVyXG4gIH07XG5cbiAgdmFyIF9FdmVudEhhbmRsZXIgPSBFdmVudEhhbmRsZXI7XG5cbiAgdmFyIGNyZWF0ZUV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiAoZWxlbWVudCwgdGVtcGxhdGUpIHtcbiAgXHR2YXIgaSxcbiAgXHQgICAgbmFtZSxcbiAgXHQgICAgbmFtZXMsXG4gIFx0ICAgIGhhbmRsZXIsXG4gIFx0ICAgIHJlc3VsdCA9IFtdO1xuXG4gIFx0Zm9yIChuYW1lIGluIHRlbXBsYXRlKSB7XG4gIFx0XHRpZiAodGVtcGxhdGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgXHRcdFx0bmFtZXMgPSBuYW1lLnNwbGl0KFwiLVwiKTtcbiAgXHRcdFx0aSA9IG5hbWVzLmxlbmd0aDtcblxuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0aGFuZGxlciA9IG5ldyBfRXZlbnRIYW5kbGVyKGVsZW1lbnQsIG5hbWVzW2ldLCB0ZW1wbGF0ZVtuYW1lXSk7XG4gIFx0XHRcdFx0cmVzdWx0LnB1c2goaGFuZGxlcik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBEZWNvcmF0b3IgPSBmdW5jdGlvbiAoZWxlbWVudCwgdGVtcGxhdGUpIHtcbiAgXHR2YXIgc2VsZiA9IHRoaXMsXG4gIFx0ICAgIHJhY3RpdmUsXG4gIFx0ICAgIG5hbWUsXG4gIFx0ICAgIGZyYWdtZW50O1xuXG4gIFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlID0gZWxlbWVudC5yb290O1xuXG4gIFx0bmFtZSA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG5cbiAgXHRpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogbmFtZSxcbiAgXHRcdFx0cm9vdDogcmFjdGl2ZSxcbiAgXHRcdFx0b3duZXI6IGVsZW1lbnRcbiAgXHRcdH0pO1xuXG4gIFx0XHRuYW1lID0gZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgXHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXG4gIFx0XHRpZiAobmFtZSA9PT0gXCJcIikge1xuICBcdFx0XHQvLyBlbXB0eSBzdHJpbmcgb2theSwganVzdCBubyBkZWNvcmF0b3JcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICh0ZW1wbGF0ZS5hKSB7XG4gIFx0XHR0aGlzLnBhcmFtcyA9IHRlbXBsYXRlLmE7XG4gIFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS5kKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZCxcbiAgXHRcdFx0cm9vdDogcmFjdGl2ZSxcbiAgXHRcdFx0b3duZXI6IGVsZW1lbnRcbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLnBhcmFtcyA9IHRoaXMuZnJhZ21lbnQuZ2V0QXJnc0xpc3QoKTtcblxuICBcdFx0dGhpcy5mcmFnbWVudC5idWJibGUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHRoaXMuZGlydHlBcmdzID0gdGhpcy5kaXJ0eVZhbHVlID0gdHJ1ZTtcbiAgXHRcdFx0c2VsZi5wYXJhbXMgPSB0aGlzLmdldEFyZ3NMaXN0KCk7XG5cbiAgXHRcdFx0aWYgKHNlbGYucmVhZHkpIHtcbiAgXHRcdFx0XHRzZWxmLnVwZGF0ZSgpO1xuICBcdFx0XHR9XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHRoaXMuZm4gPSBmaW5kSW5WaWV3SGllcmFyY2h5KFwiZGVjb3JhdG9yc1wiLCByYWN0aXZlLCBuYW1lKTtcblxuICBcdGlmICghdGhpcy5mbikge1xuICBcdFx0ZmF0YWwobWlzc2luZ1BsdWdpbihuYW1lLCBcImRlY29yYXRvclwiKSk7XG4gIFx0fVxuICB9O1xuXG4gIERlY29yYXRvci5wcm90b3R5cGUgPSB7XG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUsIHJlc3VsdCwgYXJncztcblxuICBcdFx0bm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRpZiAodGhpcy5wYXJhbXMpIHtcbiAgXHRcdFx0YXJncyA9IFtub2RlXS5jb25jYXQodGhpcy5wYXJhbXMpO1xuICBcdFx0XHRyZXN1bHQgPSB0aGlzLmZuLmFwcGx5KHRoaXMucm9vdCwgYXJncyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXN1bHQgPSB0aGlzLmZuLmNhbGwodGhpcy5yb290LCBub2RlKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFyZXN1bHQgfHwgIXJlc3VsdC50ZWFyZG93bikge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJEZWNvcmF0b3IgZGVmaW5pdGlvbiBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2l0aCBhIHRlYXJkb3duIG1ldGhvZFwiKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gVE9ETyBkb2VzIHRoaXMgbWFrZSBzZW5zZT9cbiAgXHRcdHRoaXMuYWN0dWFsID0gcmVzdWx0O1xuICBcdFx0dGhpcy5yZWFkeSA9IHRydWU7XG4gIFx0fSxcblxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuYWN0dWFsLnVwZGF0ZSkge1xuICBcdFx0XHR0aGlzLmFjdHVhbC51cGRhdGUuYXBwbHkodGhpcy5yb290LCB0aGlzLnBhcmFtcyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLmFjdHVhbC50ZWFyZG93bih0cnVlKTtcbiAgXHRcdFx0dGhpcy5pbml0KCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR0ZWFyZG93bjogZnVuY3Rpb24gKHVwZGF0aW5nKSB7XG4gIFx0XHR0aGlzLnRvcm5kb3duID0gdHJ1ZTtcbiAgXHRcdGlmICh0aGlzLnJlYWR5KSB7XG4gIFx0XHRcdHRoaXMuYWN0dWFsLnRlYXJkb3duKCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdXBkYXRpbmcgJiYgdGhpcy5mcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgX0RlY29yYXRvciA9IERlY29yYXRvcjtcblxuICBmdW5jdGlvbiBzZWxlY3RfX2J1YmJsZSgpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0aWYgKCF0aGlzLmRpcnR5KSB7XG4gIFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0c3luYyhfdGhpcyk7XG4gIFx0XHRcdF90aGlzLmRpcnR5ID0gZmFsc2U7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpOyAvLyBkZWZhdWx0IGJlaGF2aW91clxuICB9XG5cbiAgZnVuY3Rpb24gc3luYyhzZWxlY3RFbGVtZW50KSB7XG4gIFx0dmFyIHNlbGVjdE5vZGUsIHNlbGVjdFZhbHVlLCBpc011bHRpcGxlLCBvcHRpb25zLCBvcHRpb25XYXNTZWxlY3RlZDtcblxuICBcdHNlbGVjdE5vZGUgPSBzZWxlY3RFbGVtZW50Lm5vZGU7XG5cbiAgXHRpZiAoIXNlbGVjdE5vZGUpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRvcHRpb25zID0gdG9BcnJheShzZWxlY3ROb2RlLm9wdGlvbnMpO1xuXG4gIFx0c2VsZWN0VmFsdWUgPSBzZWxlY3RFbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdGlzTXVsdGlwbGUgPSBzZWxlY3RFbGVtZW50LmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpO1xuXG4gIFx0Ly8gSWYgdGhlIDxzZWxlY3Q+IGhhcyBhIHNwZWNpZmllZCB2YWx1ZSwgdGhhdCBzaG91bGQgb3ZlcnJpZGVcbiAgXHQvLyB0aGVzZSBvcHRpb25zXG4gIFx0aWYgKHNlbGVjdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdG9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobykge1xuICBcdFx0XHR2YXIgb3B0aW9uVmFsdWUsIHNob3VsZFNlbGVjdDtcblxuICBcdFx0XHRvcHRpb25WYWx1ZSA9IG8uX3JhY3RpdmUgPyBvLl9yYWN0aXZlLnZhbHVlIDogby52YWx1ZTtcbiAgXHRcdFx0c2hvdWxkU2VsZWN0ID0gaXNNdWx0aXBsZSA/IHZhbHVlQ29udGFpbnMoc2VsZWN0VmFsdWUsIG9wdGlvblZhbHVlKSA6IHNlbGVjdFZhbHVlID09IG9wdGlvblZhbHVlO1xuXG4gIFx0XHRcdGlmIChzaG91bGRTZWxlY3QpIHtcbiAgXHRcdFx0XHRvcHRpb25XYXNTZWxlY3RlZCA9IHRydWU7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRvLnNlbGVjdGVkID0gc2hvdWxkU2VsZWN0O1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmICghb3B0aW9uV2FzU2VsZWN0ZWQpIHtcbiAgXHRcdFx0aWYgKG9wdGlvbnNbMF0pIHtcbiAgXHRcdFx0XHRvcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChzZWxlY3RFbGVtZW50LmJpbmRpbmcpIHtcbiAgXHRcdFx0XHRzZWxlY3RFbGVtZW50LmJpbmRpbmcuZm9yY2VVcGRhdGUoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIE90aGVyd2lzZSB0aGUgdmFsdWUgc2hvdWxkIGJlIGluaXRpYWxpc2VkIGFjY29yZGluZyB0byB3aGljaFxuICBcdC8vIDxvcHRpb24+IGVsZW1lbnQgaXMgc2VsZWN0ZWQsIGlmIHR3b3dheSBiaW5kaW5nIGlzIGluIGVmZmVjdFxuICBcdGVsc2UgaWYgKHNlbGVjdEVsZW1lbnQuYmluZGluZykge1xuICBcdFx0c2VsZWN0RWxlbWVudC5iaW5kaW5nLmZvcmNlVXBkYXRlKCk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsdWVDb250YWlucyhzZWxlY3RWYWx1ZSwgb3B0aW9uVmFsdWUpIHtcbiAgXHR2YXIgaSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoc2VsZWN0VmFsdWVbaV0gPT0gb3B0aW9uVmFsdWUpIHtcbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gc3BlY2lhbF9vcHRpb25fX2luaXQob3B0aW9uLCB0ZW1wbGF0ZSkge1xuICBcdG9wdGlvbi5zZWxlY3QgPSBmaW5kUGFyZW50U2VsZWN0KG9wdGlvbi5wYXJlbnQpO1xuXG4gIFx0Ly8gd2UgbWlnaHQgYmUgaW5zaWRlIGEgPGRhdGFsaXN0PiBlbGVtZW50XG4gIFx0aWYgKCFvcHRpb24uc2VsZWN0KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0b3B0aW9uLnNlbGVjdC5vcHRpb25zLnB1c2gob3B0aW9uKTtcblxuICBcdC8vIElmIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgaXMgbWlzc2luZywgdXNlIHRoZSBlbGVtZW50J3MgY29udGVudFxuICBcdGlmICghdGVtcGxhdGUuYSkge1xuICBcdFx0dGVtcGxhdGUuYSA9IHt9O1xuICBcdH1cblxuICBcdC8vIC4uLmFzIGxvbmcgYXMgaXQgaXNuJ3QgZGlzYWJsZWRcbiAgXHRpZiAodGVtcGxhdGUuYS52YWx1ZSA9PT0gdW5kZWZpbmVkICYmICF0ZW1wbGF0ZS5hLmhhc093blByb3BlcnR5KFwiZGlzYWJsZWRcIikpIHtcbiAgXHRcdHRlbXBsYXRlLmEudmFsdWUgPSB0ZW1wbGF0ZS5mO1xuICBcdH1cblxuICBcdC8vIElmIHRoZXJlIGlzIGEgYHNlbGVjdGVkYCBhdHRyaWJ1dGUsIGJ1dCB0aGUgPHNlbGVjdD5cbiAgXHQvLyBhbHJlYWR5IGhhcyBhIHZhbHVlLCBkZWxldGUgaXRcbiAgXHRpZiAoXCJzZWxlY3RlZFwiIGluIHRlbXBsYXRlLmEgJiYgb3B0aW9uLnNlbGVjdC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRkZWxldGUgdGVtcGxhdGUuYS5zZWxlY3RlZDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBzcGVjaWFsX29wdGlvbl9fdW5iaW5kKG9wdGlvbikge1xuICBcdGlmIChvcHRpb24uc2VsZWN0KSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkob3B0aW9uLnNlbGVjdC5vcHRpb25zLCBvcHRpb24pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRQYXJlbnRTZWxlY3QoZWxlbWVudCkge1xuICBcdGlmICghZWxlbWVudCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGRvIHtcbiAgXHRcdGlmIChlbGVtZW50Lm5hbWUgPT09IFwic2VsZWN0XCIpIHtcbiAgXHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50KTtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9pbml0ID0gRWxlbWVudCRpbml0O1xuICBmdW5jdGlvbiBFbGVtZW50JGluaXQob3B0aW9ucykge1xuICBcdHZhciBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGUsIHJhY3RpdmUsIGJpbmRpbmcsIGJpbmRpbmdzLCB0d293YXksIGJpbmRpbmdBdHRycztcblxuICBcdHRoaXMudHlwZSA9IEVMRU1FTlQ7XG5cbiAgXHQvLyBzdHVmZiB3ZSdsbCBuZWVkIGxhdGVyXG4gIFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcbiAgXHR0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXG4gIFx0dGhpcy5wYXJlbnQgPSBvcHRpb25zLnBFbGVtZW50IHx8IHBhcmVudEZyYWdtZW50LnBFbGVtZW50O1xuXG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZSA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG4gIFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG4gIFx0dGhpcy5rZXkgPSBvcHRpb25zLmtleTtcblxuICBcdHRoaXMubmFtZSA9IGVuZm9yY2VDYXNlKHRlbXBsYXRlLmUpO1xuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gPG9wdGlvbj4gZWxlbWVudHNcbiAgXHRpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiKSB7XG4gIFx0XHRzcGVjaWFsX29wdGlvbl9faW5pdCh0aGlzLCB0ZW1wbGF0ZSk7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gPHNlbGVjdD4gZWxlbWVudHNcbiAgXHRpZiAodGhpcy5uYW1lID09PSBcInNlbGVjdFwiKSB7XG4gIFx0XHR0aGlzLm9wdGlvbnMgPSBbXTtcbiAgXHRcdHRoaXMuYnViYmxlID0gc2VsZWN0X19idWJibGU7IC8vIFRPRE8gdGhpcyBpcyBhIGtsdWRnZVxuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIDxmb3JtPiBlbGVtZW50c1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwiZm9ybVwiKSB7XG4gIFx0XHR0aGlzLmZvcm1CaW5kaW5ncyA9IFtdO1xuICBcdH1cblxuICBcdC8vIGhhbmRsZSBiaW5kaW5nIGF0dHJpYnV0ZXMgZmlyc3QgKHR3b3dheSwgbGF6eSlcbiAgXHRiaW5kaW5nQXR0cnMgPSBwcm9jZXNzQmluZGluZ0F0dHJpYnV0ZXModGhpcywgdGVtcGxhdGUpO1xuXG4gIFx0Ly8gY3JlYXRlIGF0dHJpYnV0ZXNcbiAgXHR0aGlzLmF0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVzKHRoaXMsIHRlbXBsYXRlLmEpO1xuICBcdHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzID0gY3JlYXRlQ29uZGl0aW9uYWxBdHRyaWJ1dGVzKHRoaXMsIHRlbXBsYXRlLm0pO1xuXG4gIFx0Ly8gYXBwZW5kIGNoaWxkcmVuLCBpZiB0aGVyZSBhcmUgYW55XG4gIFx0aWYgKHRlbXBsYXRlLmYpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5mLFxuICBcdFx0XHRyb290OiByYWN0aXZlLFxuICBcdFx0XHRvd25lcjogdGhpcyxcbiAgXHRcdFx0cEVsZW1lbnQ6IHRoaXMsXG4gIFx0XHRcdGNzc0lkczogbnVsbFxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Ly8gdGhlIGVsZW1lbnQgc2V0dGluZyBzaG91bGQgb3ZlcnJpZGUgdGhlIHJhY3RpdmUgc2V0dGluZ1xuICBcdHR3b3dheSA9IHJhY3RpdmUudHdvd2F5O1xuICBcdGlmIChiaW5kaW5nQXR0cnMudHdvd2F5ID09PSBmYWxzZSkgdHdvd2F5ID0gZmFsc2U7ZWxzZSBpZiAoYmluZGluZ0F0dHJzLnR3b3dheSA9PT0gdHJ1ZSkgdHdvd2F5ID0gdHJ1ZTtcblxuICBcdHRoaXMudHdvd2F5ID0gdHdvd2F5O1xuICBcdHRoaXMubGF6eSA9IGJpbmRpbmdBdHRycy5sYXp5O1xuXG4gIFx0Ly8gY3JlYXRlIHR3b3dheSBiaW5kaW5nXG4gIFx0aWYgKHR3b3dheSAmJiAoYmluZGluZyA9IGluaXRfY3JlYXRlVHdvd2F5QmluZGluZyh0aGlzLCB0ZW1wbGF0ZS5hKSkpIHtcbiAgXHRcdHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XG5cbiAgXHRcdC8vIHJlZ2lzdGVyIHRoaXMgd2l0aCB0aGUgcm9vdCwgc28gdGhhdCB3ZSBjYW4gZG8gcmFjdGl2ZS51cGRhdGVNb2RlbCgpXG4gIFx0XHRiaW5kaW5ncyA9IHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbYmluZGluZy5rZXlwYXRoLnN0cl0gfHwgKHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbYmluZGluZy5rZXlwYXRoLnN0cl0gPSBbXSk7XG4gIFx0XHRiaW5kaW5ncy5wdXNoKGJpbmRpbmcpO1xuICBcdH1cblxuICBcdC8vIGNyZWF0ZSBldmVudCBwcm94aWVzXG4gIFx0aWYgKHRlbXBsYXRlLnYpIHtcbiAgXHRcdHRoaXMuZXZlbnRIYW5kbGVycyA9IGNyZWF0ZUV2ZW50SGFuZGxlcnModGhpcywgdGVtcGxhdGUudik7XG4gIFx0fVxuXG4gIFx0Ly8gY3JlYXRlIGRlY29yYXRvclxuICBcdGlmICh0ZW1wbGF0ZS5vKSB7XG4gIFx0XHR0aGlzLmRlY29yYXRvciA9IG5ldyBfRGVjb3JhdG9yKHRoaXMsIHRlbXBsYXRlLm8pO1xuICBcdH1cblxuICBcdC8vIGNyZWF0ZSB0cmFuc2l0aW9uc1xuICBcdHRoaXMuaW50cm8gPSB0ZW1wbGF0ZS50MCB8fCB0ZW1wbGF0ZS50MTtcbiAgXHR0aGlzLm91dHJvID0gdGVtcGxhdGUudDAgfHwgdGVtcGxhdGUudDI7XG4gIH1cblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfcmViaW5kID0gRWxlbWVudCRyZWJpbmQ7XG4gIGZ1bmN0aW9uIEVsZW1lbnQkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHR2YXIgaSwgc3RvcmFnZSwgbGl2ZVF1ZXJpZXMsIHJhY3RpdmU7XG5cbiAgXHRpZiAodGhpcy5hdHRyaWJ1dGVzKSB7XG4gIFx0XHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaChyZWJpbmQpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcykge1xuICBcdFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMuZm9yRWFjaChyZWJpbmQpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmV2ZW50SGFuZGxlcnMpIHtcbiAgXHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKHJlYmluZCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZGVjb3JhdG9yKSB7XG4gIFx0XHRyZWJpbmQodGhpcy5kZWNvcmF0b3IpO1xuICBcdH1cblxuICBcdC8vIHJlYmluZCBjaGlsZHJlblxuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRyZWJpbmQodGhpcy5mcmFnbWVudCk7XG4gIFx0fVxuXG4gIFx0Ly8gVXBkYXRlIGxpdmUgcXVlcmllcywgaWYgbmVjZXNzYXJ5XG4gIFx0aWYgKGxpdmVRdWVyaWVzID0gdGhpcy5saXZlUXVlcmllcykge1xuICBcdFx0cmFjdGl2ZSA9IHRoaXMucm9vdDtcblxuICBcdFx0aSA9IGxpdmVRdWVyaWVzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0bGl2ZVF1ZXJpZXNbaV0uX21ha2VEaXJ0eSgpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICh0aGlzLm5vZGUgJiYgKHN0b3JhZ2UgPSB0aGlzLm5vZGUuX3JhY3RpdmUpKSB7XG5cbiAgXHRcdC8vIGFkanVzdCBrZXlwYXRoIGlmIG5lZWRlZFxuICBcdFx0YXNzaWduTmV3S2V5cGF0aChzdG9yYWdlLCBcImtleXBhdGhcIiwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gcmViaW5kKHRoaW5nKSB7XG4gIFx0XHR0aGluZy5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gc3BlY2lhbF9pbWdfX3JlbmRlcihpbWcpIHtcbiAgXHR2YXIgbG9hZEhhbmRsZXI7XG5cbiAgXHQvLyBpZiB0aGlzIGlzIGFuIDxpbWc+LCBhbmQgd2UncmUgaW4gYSBjcmFwIGJyb3dzZXIsIHdlIG1heSBuZWVkIHRvIHByZXZlbnQgaXRcbiAgXHQvLyBmcm9tIG92ZXJyaWRpbmcgd2lkdGggYW5kIGhlaWdodCB3aGVuIGl0IGxvYWRzIHRoZSBzcmNcbiAgXHRpZiAoaW1nLmF0dHJpYnV0ZXMud2lkdGggfHwgaW1nLmF0dHJpYnV0ZXMuaGVpZ2h0KSB7XG4gIFx0XHRpbWcubm9kZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsb2FkSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dmFyIHdpZHRoID0gaW1nLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpLFxuICBcdFx0XHQgICAgaGVpZ2h0ID0gaW1nLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKTtcblxuICBcdFx0XHRpZiAod2lkdGggIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdGltZy5ub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChoZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdGltZy5ub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aW1nLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgbG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgXHRcdH0sIGZhbHNlKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtX19yZW5kZXIoZWxlbWVudCkge1xuICBcdGVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRcIiwgaGFuZGxlUmVzZXQsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1fX3VucmVuZGVyKGVsZW1lbnQpIHtcbiAgXHRlbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2V0XCIsIGhhbmRsZVJlc2V0LCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVSZXNldCgpIHtcbiAgXHR2YXIgZWxlbWVudCA9IHRoaXMuX3JhY3RpdmUucHJveHk7XG5cbiAgXHRnbG9iYWxfcnVubG9vcC5zdGFydCgpO1xuICBcdGVsZW1lbnQuZm9ybUJpbmRpbmdzLmZvckVhY2godXBkYXRlTW9kZWwpO1xuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTW9kZWwoYmluZGluZykge1xuICBcdGJpbmRpbmcucm9vdC52aWV3bW9kZWwuc2V0KGJpbmRpbmcua2V5cGF0aCwgYmluZGluZy5yZXNldFZhbHVlKTtcbiAgfVxuXG4gIHZhciBUcmFuc2l0aW9uX3Byb3RvdHlwZV9pbml0ID0gVHJhbnNpdGlvbiRpbml0O1xuICBmdW5jdGlvbiBUcmFuc2l0aW9uJGluaXQoZWxlbWVudCwgdGVtcGxhdGUsIGlzSW50cm8pIHtcbiAgXHR2YXIgcmFjdGl2ZSwgbmFtZSwgZnJhZ21lbnQ7XG5cbiAgXHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmUgPSBlbGVtZW50LnJvb3Q7XG4gIFx0dGhpcy5pc0ludHJvID0gaXNJbnRybztcblxuICBcdG5hbWUgPSB0ZW1wbGF0ZS5uIHx8IHRlbXBsYXRlO1xuXG4gIFx0aWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IG5hbWUsXG4gIFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiBlbGVtZW50XG4gIFx0XHR9KTtcblxuICBcdFx0bmFtZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblxuICBcdFx0aWYgKG5hbWUgPT09IFwiXCIpIHtcbiAgXHRcdFx0Ly8gZW1wdHkgc3RyaW5nIG9rYXksIGp1c3Qgbm8gdHJhbnNpdGlvblxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0dGhpcy5uYW1lID0gbmFtZTtcblxuICBcdGlmICh0ZW1wbGF0ZS5hKSB7XG4gIFx0XHR0aGlzLnBhcmFtcyA9IHRlbXBsYXRlLmE7XG4gIFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS5kKSB7XG4gIFx0XHQvLyBUT0RPIGlzIHRoZXJlIGEgd2F5IHRvIGludGVycHJldCBkeW5hbWljIGFyZ3VtZW50cyB3aXRob3V0IGFsbCB0aGVcbiAgXHRcdC8vICdkZXBlbmRlbmN5IHRocmFzaGluZyc/XG4gIFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmQsXG4gIFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiBlbGVtZW50XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5wYXJhbXMgPSBmcmFnbWVudC5nZXRBcmdzTGlzdCgpO1xuICBcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fVxuXG4gIFx0dGhpcy5fZm4gPSBmaW5kSW5WaWV3SGllcmFyY2h5KFwidHJhbnNpdGlvbnNcIiwgcmFjdGl2ZSwgbmFtZSk7XG5cbiAgXHRpZiAoIXRoaXMuX2ZuKSB7XG4gIFx0XHR3YXJuT25jZUlmRGVidWcobWlzc2luZ1BsdWdpbihuYW1lLCBcInRyYW5zaXRpb25cIiksIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdH1cbiAgfVxuXG4gIHZhciBjYW1lbENhc2UgPSBmdW5jdGlvbiAoaHlwaGVuYXRlZFN0cikge1xuICBcdHJldHVybiBoeXBoZW5hdGVkU3RyLnJlcGxhY2UoLy0oW2EtekEtWl0pL2csIGZ1bmN0aW9uIChtYXRjaCwgJDEpIHtcbiAgXHRcdHJldHVybiAkMS50b1VwcGVyQ2FzZSgpO1xuICBcdH0pO1xuICB9O1xuXG4gIHZhciBoZWxwZXJzX3ByZWZpeF9fcHJlZml4LCBwcmVmaXhDYWNoZSwgaGVscGVyc19wcmVmaXhfX3Rlc3RTdHlsZTtcblxuICBpZiAoIWlzQ2xpZW50KSB7XG4gIFx0aGVscGVyc19wcmVmaXhfX3ByZWZpeCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gIFx0cHJlZml4Q2FjaGUgPSB7fTtcbiAgXHRoZWxwZXJzX3ByZWZpeF9fdGVzdFN0eWxlID0gY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZTtcblxuICBcdGhlbHBlcnNfcHJlZml4X19wcmVmaXggPSBmdW5jdGlvbiAocHJvcCkge1xuICBcdFx0dmFyIGksIHZlbmRvciwgY2FwcGVkO1xuXG4gIFx0XHRwcm9wID0gY2FtZWxDYXNlKHByb3ApO1xuXG4gIFx0XHRpZiAoIXByZWZpeENhY2hlW3Byb3BdKSB7XG4gIFx0XHRcdGlmIChoZWxwZXJzX3ByZWZpeF9fdGVzdFN0eWxlW3Byb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRwcmVmaXhDYWNoZVtwcm9wXSA9IHByb3A7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0Ly8gdGVzdCB2ZW5kb3JzLi4uXG4gIFx0XHRcdFx0Y2FwcGVkID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc3Vic3RyaW5nKDEpO1xuXG4gIFx0XHRcdFx0aSA9IHZlbmRvcnMubGVuZ3RoO1xuICBcdFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRcdHZlbmRvciA9IHZlbmRvcnNbaV07XG4gIFx0XHRcdFx0XHRpZiAoaGVscGVyc19wcmVmaXhfX3Rlc3RTdHlsZVt2ZW5kb3IgKyBjYXBwZWRdICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRcdFx0cHJlZml4Q2FjaGVbcHJvcF0gPSB2ZW5kb3IgKyBjYXBwZWQ7XG4gIFx0XHRcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gcHJlZml4Q2FjaGVbcHJvcF07XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBoZWxwZXJzX3ByZWZpeCA9IGhlbHBlcnNfcHJlZml4X19wcmVmaXg7XG5cbiAgdmFyIGdldFN0eWxlLCBwcm90b3R5cGVfZ2V0U3R5bGVfX2dldENvbXB1dGVkU3R5bGU7XG5cbiAgaWYgKCFpc0NsaWVudCkge1xuICBcdGdldFN0eWxlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHRwcm90b3R5cGVfZ2V0U3R5bGVfX2dldENvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSB8fCBsZWdhY3kuZ2V0Q29tcHV0ZWRTdHlsZTtcblxuICBcdGdldFN0eWxlID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gIFx0XHR2YXIgY29tcHV0ZWRTdHlsZSwgc3R5bGVzLCBpLCBwcm9wLCB2YWx1ZTtcblxuICBcdFx0Y29tcHV0ZWRTdHlsZSA9IHByb3RvdHlwZV9nZXRTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLm5vZGUpO1xuXG4gIFx0XHRpZiAodHlwZW9mIHByb3BzID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdHZhbHVlID0gY29tcHV0ZWRTdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wcyldO1xuICBcdFx0XHRpZiAodmFsdWUgPT09IFwiMHB4XCIpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IDA7XG4gIFx0XHRcdH1cbiAgXHRcdFx0cmV0dXJuIHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIWlzQXJyYXkocHJvcHMpKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlRyYW5zaXRpb24kZ2V0U3R5bGUgbXVzdCBiZSBwYXNzZWQgYSBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIENTUyBwcm9wZXJ0aWVzXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRzdHlsZXMgPSB7fTtcblxuICBcdFx0aSA9IHByb3BzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0cHJvcCA9IHByb3BzW2ldO1xuICBcdFx0XHR2YWx1ZSA9IGNvbXB1dGVkU3R5bGVbaGVscGVyc19wcmVmaXgocHJvcCldO1xuICBcdFx0XHRpZiAodmFsdWUgPT09IFwiMHB4XCIpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IDA7XG4gIFx0XHRcdH1cbiAgXHRcdFx0c3R5bGVzW3Byb3BdID0gdmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBzdHlsZXM7XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZ2V0U3R5bGUgPSBnZXRTdHlsZTtcblxuICB2YXIgc2V0U3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUsIHZhbHVlKSB7XG4gIFx0dmFyIHByb3A7XG5cbiAgXHRpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHR0aGlzLm5vZGUuc3R5bGVbaGVscGVyc19wcmVmaXgoc3R5bGUpXSA9IHZhbHVlO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRmb3IgKHByb3AgaW4gc3R5bGUpIHtcbiAgXHRcdFx0aWYgKHN0eWxlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gIFx0XHRcdFx0dGhpcy5ub2RlLnN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXSA9IHN0eWxlW3Byb3BdO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIFRpY2tlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dmFyIGVhc2luZztcblxuICBcdHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuICBcdHRoaXMuc3RlcCA9IG9wdGlvbnMuc3RlcDtcbiAgXHR0aGlzLmNvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcblxuICBcdC8vIGVhc2luZ1xuICBcdGlmICh0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGVhc2luZyA9IG9wdGlvbnMucm9vdC5lYXNpbmdbb3B0aW9ucy5lYXNpbmddO1xuXG4gIFx0XHRpZiAoIWVhc2luZykge1xuICBcdFx0XHR3YXJuT25jZUlmRGVidWcobWlzc2luZ1BsdWdpbihvcHRpb25zLmVhc2luZywgXCJlYXNpbmdcIikpO1xuICBcdFx0XHRlYXNpbmcgPSBsaW5lYXI7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGVhc2luZyA9IGxpbmVhcjtcbiAgXHR9XG5cbiAgXHR0aGlzLmVhc2luZyA9IGVhc2luZztcblxuICBcdHRoaXMuc3RhcnQgPSB1dGlsc19nZXRUaW1lKCk7XG4gIFx0dGhpcy5lbmQgPSB0aGlzLnN0YXJ0ICsgdGhpcy5kdXJhdGlvbjtcblxuICBcdHRoaXMucnVubmluZyA9IHRydWU7XG4gIFx0c2hhcmVkX2FuaW1hdGlvbnMuYWRkKHRoaXMpO1xuICB9O1xuXG4gIFRpY2tlci5wcm90b3R5cGUgPSB7XG4gIFx0dGljazogZnVuY3Rpb24gKG5vdykge1xuICBcdFx0dmFyIGVsYXBzZWQsIGVhc2VkO1xuXG4gIFx0XHRpZiAoIXRoaXMucnVubmluZykge1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChub3cgPiB0aGlzLmVuZCkge1xuICBcdFx0XHRpZiAodGhpcy5zdGVwKSB7XG4gIFx0XHRcdFx0dGhpcy5zdGVwKDEpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHRoaXMuY29tcGxldGUpIHtcbiAgXHRcdFx0XHR0aGlzLmNvbXBsZXRlKDEpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHRlbGFwc2VkID0gbm93IC0gdGhpcy5zdGFydDtcbiAgXHRcdGVhc2VkID0gdGhpcy5lYXNpbmcoZWxhcHNlZCAvIHRoaXMuZHVyYXRpb24pO1xuXG4gIFx0XHRpZiAodGhpcy5zdGVwKSB7XG4gIFx0XHRcdHRoaXMuc3RlcChlYXNlZCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH0sXG5cbiAgXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5hYm9ydCkge1xuICBcdFx0XHR0aGlzLmFib3J0KCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuICBcdH1cbiAgfTtcblxuICB2YXIgc2hhcmVkX1RpY2tlciA9IFRpY2tlcjtcbiAgZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgXHRyZXR1cm4gdDtcbiAgfVxuXG4gIHZhciB1bnByZWZpeFBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXi0oPzpcIiArIHZlbmRvcnMuam9pbihcInxcIikgKyBcIiktXCIpO1xuXG4gIHZhciB1bnByZWZpeCA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gIFx0cmV0dXJuIHByb3AucmVwbGFjZSh1bnByZWZpeFBhdHRlcm4sIFwiXCIpO1xuICB9O1xuXG4gIHZhciB2ZW5kb3JQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHZlbmRvcnMuam9pbihcInxcIikgKyBcIikoW0EtWl0pXCIpO1xuXG4gIHZhciBoeXBoZW5hdGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIFx0dmFyIGh5cGhlbmF0ZWQ7XG5cbiAgXHRpZiAoIXN0cikge1xuICBcdFx0cmV0dXJuIFwiXCI7IC8vIGVkZ2UgY2FzZVxuICBcdH1cblxuICBcdGlmICh2ZW5kb3JQYXR0ZXJuLnRlc3Qoc3RyKSkge1xuICBcdFx0c3RyID0gXCItXCIgKyBzdHI7XG4gIFx0fVxuXG4gIFx0aHlwaGVuYXRlZCA9IHN0ci5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgXHRcdHJldHVybiBcIi1cIiArIG1hdGNoLnRvTG93ZXJDYXNlKCk7XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gaHlwaGVuYXRlZDtcbiAgfTtcblxuICB2YXIgY3JlYXRlVHJhbnNpdGlvbnMsXG4gICAgICBhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnNfX3Rlc3RTdHlsZSxcbiAgICAgIFRSQU5TSVRJT04sXG4gICAgICBUUkFOU0lUSU9ORU5ELFxuICAgICAgQ1NTX1RSQU5TSVRJT05TX0VOQUJMRUQsXG4gICAgICBUUkFOU0lUSU9OX0RVUkFUSU9OLFxuICAgICAgVFJBTlNJVElPTl9QUk9QRVJUWSxcbiAgICAgIFRSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OLFxuICAgICAgY2FuVXNlQ3NzVHJhbnNpdGlvbnMgPSB7fSxcbiAgICAgIGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zID0ge307XG5cbiAgaWYgKCFpc0NsaWVudCkge1xuICBcdGNyZWF0ZVRyYW5zaXRpb25zID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHRhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnNfX3Rlc3RTdHlsZSA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGU7XG5cbiAgXHQvLyBkZXRlcm1pbmUgc29tZSBmYWN0cyBhYm91dCBvdXIgZW52aXJvbm1lbnRcbiAgXHQoZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9uc19fdGVzdFN0eWxlLnRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRUUkFOU0lUSU9OID0gXCJ0cmFuc2l0aW9uXCI7XG4gIFx0XHRcdFRSQU5TSVRJT05FTkQgPSBcInRyYW5zaXRpb25lbmRcIjtcbiAgXHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSB0cnVlO1xuICBcdFx0fSBlbHNlIGlmIChhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnNfX3Rlc3RTdHlsZS53ZWJraXRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0VFJBTlNJVElPTiA9IFwid2Via2l0VHJhbnNpdGlvblwiO1xuICBcdFx0XHRUUkFOU0lUSU9ORU5EID0gXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCI7XG4gIFx0XHRcdENTU19UUkFOU0lUSU9OU19FTkFCTEVEID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdENTU19UUkFOU0lUSU9OU19FTkFCTEVEID0gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fSkoKTtcblxuICBcdGlmIChUUkFOU0lUSU9OKSB7XG4gIFx0XHRUUkFOU0lUSU9OX0RVUkFUSU9OID0gVFJBTlNJVElPTiArIFwiRHVyYXRpb25cIjtcbiAgXHRcdFRSQU5TSVRJT05fUFJPUEVSVFkgPSBUUkFOU0lUSU9OICsgXCJQcm9wZXJ0eVwiO1xuICBcdFx0VFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT04gPSBUUkFOU0lUSU9OICsgXCJUaW1pbmdGdW5jdGlvblwiO1xuICBcdH1cblxuICBcdGNyZWF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24gKHQsIHRvLCBvcHRpb25zLCBjaGFuZ2VkUHJvcGVydGllcywgcmVzb2x2ZSkge1xuXG4gIFx0XHQvLyBXYWl0IGEgYmVhdCAob3RoZXJ3aXNlIHRoZSB0YXJnZXQgc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBpbW1lZGlhdGVseSlcbiAgXHRcdC8vIFRPRE8gdXNlIGEgZmFzdGRvbS1zdHlsZSBtZWNoYW5pc20/XG4gIFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblxuICBcdFx0XHR2YXIgaGFzaFByZWZpeCwganNUcmFuc2l0aW9uc0NvbXBsZXRlLCBjc3NUcmFuc2l0aW9uc0NvbXBsZXRlLCBjaGVja0NvbXBsZXRlLCB0cmFuc2l0aW9uRW5kSGFuZGxlcjtcblxuICBcdFx0XHRjaGVja0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdGlmIChqc1RyYW5zaXRpb25zQ29tcGxldGUgJiYgY3NzVHJhbnNpdGlvbnNDb21wbGV0ZSkge1xuICBcdFx0XHRcdFx0Ly8gd2lsbCBjaGFuZ2VzIHRvIGV2ZW50cyBhbmQgZmlyZSBoYXZlIGFuIHVuZXhwZWN0ZWQgY29uc2VxdWVuY2UgaGVyZT9cbiAgXHRcdFx0XHRcdHQucm9vdC5maXJlKHQubmFtZSArIFwiOmVuZFwiLCB0Lm5vZGUsIHQuaXNJbnRybyk7XG4gIFx0XHRcdFx0XHRyZXNvbHZlKCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9O1xuXG4gIFx0XHRcdC8vIHRoaXMgaXMgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIGVsZW1lbnRzIGNhbiB1c2UgQ1NTIHRvIGFuaW1hdGVcbiAgXHRcdFx0Ly8gd2hpY2ggcHJvcGVydGllc1xuICBcdFx0XHRoYXNoUHJlZml4ID0gKHQubm9kZS5uYW1lc3BhY2VVUkkgfHwgXCJcIikgKyB0Lm5vZGUudGFnTmFtZTtcblxuICBcdFx0XHR0Lm5vZGUuc3R5bGVbVFJBTlNJVElPTl9QUk9QRVJUWV0gPSBjaGFuZ2VkUHJvcGVydGllcy5tYXAoaGVscGVyc19wcmVmaXgpLm1hcChoeXBoZW5hdGUpLmpvaW4oXCIsXCIpO1xuICBcdFx0XHR0Lm5vZGUuc3R5bGVbVFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT05dID0gaHlwaGVuYXRlKG9wdGlvbnMuZWFzaW5nIHx8IFwibGluZWFyXCIpO1xuICBcdFx0XHR0Lm5vZGUuc3R5bGVbVFJBTlNJVElPTl9EVVJBVElPTl0gPSBvcHRpb25zLmR1cmF0aW9uIC8gMTAwMCArIFwic1wiO1xuXG4gIFx0XHRcdHRyYW5zaXRpb25FbmRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIFx0XHRcdFx0dmFyIGluZGV4O1xuXG4gIFx0XHRcdFx0aW5kZXggPSBjaGFuZ2VkUHJvcGVydGllcy5pbmRleE9mKGNhbWVsQ2FzZSh1bnByZWZpeChldmVudC5wcm9wZXJ0eU5hbWUpKSk7XG4gIFx0XHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0XHQvLyBzdGlsbCB0cmFuc2l0aW9uaW5nLi4uXG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0dC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlKTtcblxuICBcdFx0XHRcdGNzc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuICBcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcbiAgXHRcdFx0fTtcblxuICBcdFx0XHR0Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UpO1xuXG4gIFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHZhciBpID0gY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoLFxuICBcdFx0XHRcdCAgICBoYXNoLFxuICBcdFx0XHRcdCAgICBvcmlnaW5hbFZhbHVlLFxuICBcdFx0XHRcdCAgICBpbmRleCxcbiAgXHRcdFx0XHQgICAgcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMgPSBbXSxcbiAgXHRcdFx0XHQgICAgcHJvcCxcbiAgXHRcdFx0XHQgICAgc3VmZml4O1xuXG4gIFx0XHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdFx0cHJvcCA9IGNoYW5nZWRQcm9wZXJ0aWVzW2ldO1xuICBcdFx0XHRcdFx0aGFzaCA9IGhhc2hQcmVmaXggKyBwcm9wO1xuXG4gIFx0XHRcdFx0XHRpZiAoQ1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgJiYgIWNhbm5vdFVzZUNzc1RyYW5zaXRpb25zW2hhc2hdKSB7XG4gIFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wKV0gPSB0b1twcm9wXTtcblxuICBcdFx0XHRcdFx0XHQvLyBJZiB3ZSdyZSBub3Qgc3VyZSBpZiBDU1MgdHJhbnNpdGlvbnMgYXJlIHN1cHBvcnRlZCBmb3JcbiAgXHRcdFx0XHRcdFx0Ly8gdGhpcyB0YWcvcHJvcGVydHkgY29tYm8sIGZpbmQgb3V0IG5vd1xuICBcdFx0XHRcdFx0XHRpZiAoIWNhblVzZUNzc1RyYW5zaXRpb25zW2hhc2hdKSB7XG4gIFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxWYWx1ZSA9IHQuZ2V0U3R5bGUocHJvcCk7XG5cbiAgXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGlzIHByb3BlcnR5IGlzIHRyYW5zaXRpb25hYmxlIGluIHRoaXMgYnJvd3NlcixcbiAgXHRcdFx0XHRcdFx0XHQvLyB0aGUgY3VycmVudCBzdHlsZSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIHRoZSB0YXJnZXQgc3R5bGVcbiAgXHRcdFx0XHRcdFx0XHRjYW5Vc2VDc3NUcmFuc2l0aW9uc1toYXNoXSA9IHQuZ2V0U3R5bGUocHJvcCkgIT0gdG9bcHJvcF07XG4gIFx0XHRcdFx0XHRcdFx0Y2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0gPSAhY2FuVXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF07XG5cbiAgXHRcdFx0XHRcdFx0XHQvLyBSZXNldCwgaWYgd2UncmUgZ29pbmcgdG8gdXNlIHRpbWVycyBhZnRlciBhbGxcbiAgXHRcdFx0XHRcdFx0XHRpZiAoY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0pIHtcbiAgXHRcdFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wKV0gPSBvcmlnaW5hbFZhbHVlO1xuICBcdFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRpZiAoIUNTU19UUkFOU0lUSU9OU19FTkFCTEVEIHx8IGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zW2hhc2hdKSB7XG4gIFx0XHRcdFx0XHRcdC8vIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIHRpbWVyLWJhc2VkIHN0dWZmXG4gIFx0XHRcdFx0XHRcdGlmIChvcmlnaW5hbFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRcdFx0XHRvcmlnaW5hbFZhbHVlID0gdC5nZXRTdHlsZShwcm9wKTtcbiAgXHRcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRcdC8vIG5lZWQgdG8gcmVtb3ZlIHRoaXMgZnJvbSBjaGFuZ2VkUHJvcGVydGllcywgb3RoZXJ3aXNlIHRyYW5zaXRpb25FbmRIYW5kbGVyXG4gIFx0XHRcdFx0XHRcdC8vIHdpbGwgZ2V0IGNvbmZ1c2VkXG4gIFx0XHRcdFx0XHRcdGluZGV4ID0gY2hhbmdlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKTtcbiAgXHRcdFx0XHRcdFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0XHRcdFx0XHRcdHdhcm5JZkRlYnVnKFwiU29tZXRoaW5nIHZlcnkgc3RyYW5nZSBoYXBwZW5lZCB3aXRoIHRyYW5zaXRpb25zLiBQbGVhc2UgcmFpc2UgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3VlcyAtIHRoYW5rcyFcIiwgeyBub2RlOiB0Lm5vZGUgfSk7XG4gIFx0XHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRcdC8vIFRPRE8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBwcm9wZXJ0eSBpcyBhbmltYXRhYmxlIGF0IGFsbFxuXG4gIFx0XHRcdFx0XHRcdHN1ZmZpeCA9IC9bXlxcZF0qJC8uZXhlYyh0b1twcm9wXSlbMF07XG5cbiAgXHRcdFx0XHRcdFx0Ly8gLi4udGhlbiBraWNrIG9mZiBhIHRpbWVyLWJhc2VkIHRyYW5zaXRpb25cbiAgXHRcdFx0XHRcdFx0cHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMucHVzaCh7XG4gIFx0XHRcdFx0XHRcdFx0bmFtZTogaGVscGVyc19wcmVmaXgocHJvcCksXG4gIFx0XHRcdFx0XHRcdFx0aW50ZXJwb2xhdG9yOiBzaGFyZWRfaW50ZXJwb2xhdGUocGFyc2VGbG9hdChvcmlnaW5hbFZhbHVlKSwgcGFyc2VGbG9hdCh0b1twcm9wXSkpLFxuICBcdFx0XHRcdFx0XHRcdHN1ZmZpeDogc3VmZml4XG4gIFx0XHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIGphdmFzY3JpcHQgdHJhbnNpdGlvbnNcbiAgXHRcdFx0XHRpZiAocHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0XHRuZXcgc2hhcmVkX1RpY2tlcih7XG4gIFx0XHRcdFx0XHRcdHJvb3Q6IHQucm9vdCxcbiAgXHRcdFx0XHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gIFx0XHRcdFx0XHRcdGVhc2luZzogY2FtZWxDYXNlKG9wdGlvbnMuZWFzaW5nIHx8IFwiXCIpLFxuICBcdFx0XHRcdFx0XHRzdGVwOiBmdW5jdGlvbiAocG9zKSB7XG4gIFx0XHRcdFx0XHRcdFx0dmFyIHByb3AsIGk7XG5cbiAgXHRcdFx0XHRcdFx0XHRpID0gcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMubGVuZ3RoO1xuICBcdFx0XHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRcdFx0XHRcdHByb3AgPSBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kc1tpXTtcbiAgXHRcdFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVtwcm9wLm5hbWVdID0gcHJvcC5pbnRlcnBvbGF0b3IocG9zKSArIHByb3Auc3VmZml4O1xuICBcdFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFx0fSxcbiAgXHRcdFx0XHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdFx0XHRqc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuICBcdFx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGpzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKCFjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uRW5kSGFuZGxlciwgYW5kIGRlYWwgd2l0aFxuICBcdFx0XHRcdFx0Ly8gdGhlIGZhY3QgdGhhdCBpdCB3aWxsIG5ldmVyIGZpcmVcbiAgXHRcdFx0XHRcdHQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBmYWxzZSk7XG4gIFx0XHRcdFx0XHRjc3NUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0sIDApO1xuICBcdFx0fSwgb3B0aW9ucy5kZWxheSB8fCAwKTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9ucyA9IGNyZWF0ZVRyYW5zaXRpb25zO1xuXG4gIHZhciBoaWRkZW4sIHZlbmRvciwgYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX3ByZWZpeCwgYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX2ksIHZpc2liaWxpdHk7XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBcdGhpZGRlbiA9IFwiaGlkZGVuXCI7XG5cbiAgXHR2aXNpYmlsaXR5ID0ge307XG5cbiAgXHRpZiAoaGlkZGVuIGluIGRvY3VtZW50KSB7XG4gIFx0XHRhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9fcHJlZml4ID0gXCJcIjtcbiAgXHR9IGVsc2Uge1xuICBcdFx0YW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX2kgPSB2ZW5kb3JzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9faS0tKSB7XG4gIFx0XHRcdHZlbmRvciA9IHZlbmRvcnNbYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX2ldO1xuICBcdFx0XHRoaWRkZW4gPSB2ZW5kb3IgKyBcIkhpZGRlblwiO1xuXG4gIFx0XHRcdGlmIChoaWRkZW4gaW4gZG9jdW1lbnQpIHtcbiAgXHRcdFx0XHRhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9fcHJlZml4ID0gdmVuZG9yO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19wcmVmaXggIT09IHVuZGVmaW5lZCkge1xuICBcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9fcHJlZml4ICsgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uQ2hhbmdlKTtcblxuICBcdFx0Ly8gaW5pdGlhbGlzZVxuICBcdFx0b25DaGFuZ2UoKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gZ2FoLCB3ZSdyZSBpbiBhbiBvbGQgYnJvd3NlclxuICBcdFx0aWYgKFwib25mb2N1c291dFwiIGluIGRvY3VtZW50KSB7XG4gIFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBvbkhpZGUpO1xuICBcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBvblNob3cpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBvbkhpZGUpO1xuICBcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgb25IaWRlKTtcblxuICBcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VzaG93XCIsIG9uU2hvdyk7XG4gIFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgb25TaG93KTtcbiAgXHRcdH1cblxuICBcdFx0dmlzaWJpbGl0eS5oaWRkZW4gPSBmYWxzZTsgLy8gdW50aWwgcHJvdmVuIG90aGVyd2lzZS4gTm90IGlkZWFsIGJ1dCBoZXlcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgXHR2aXNpYmlsaXR5LmhpZGRlbiA9IGRvY3VtZW50W2hpZGRlbl07XG4gIH1cblxuICBmdW5jdGlvbiBvbkhpZGUoKSB7XG4gIFx0dmlzaWJpbGl0eS5oaWRkZW4gPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TaG93KCkge1xuICBcdHZpc2liaWxpdHkuaGlkZGVuID0gZmFsc2U7XG4gIH1cblxuICB2YXIgYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHkgPSB2aXNpYmlsaXR5O1xuXG4gIHZhciBhbmltYXRlU3R5bGUsIF9hbmltYXRlU3R5bGVfX2dldENvbXB1dGVkU3R5bGUsIHJlc29sdmVkO1xuXG4gIGlmICghaXNDbGllbnQpIHtcbiAgXHRhbmltYXRlU3R5bGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdF9hbmltYXRlU3R5bGVfX2dldENvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSB8fCBsZWdhY3kuZ2V0Q29tcHV0ZWRTdHlsZTtcblxuICBcdGFuaW1hdGVTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciB0bztcblxuICBcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwidC5hbmltYXRlU3R5bGUoKSByZXR1cm5zIGEgcHJvbWlzZSAtIHVzZSAudGhlbigpIGluc3RlYWQgb2YgcGFzc2luZyBhIGNhbGxiYWNrXCIpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBwYWdlIGlzbid0IHZpc2libGUuIERvbid0IGFuaW1hdGUgYW55dGhpbmcsIGJlY2F1c2VcbiAgXHRcdC8vIHRoYXQgd2F5IHlvdSdsbCBuZXZlciBnZXQgQ1NTIHRyYW5zaXRpb25lbmQgZXZlbnRzXG4gIFx0XHRpZiAoYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHkuaGlkZGVuKSB7XG4gIFx0XHRcdHRoaXMuc2V0U3R5bGUoc3R5bGUsIHZhbHVlKTtcbiAgXHRcdFx0cmV0dXJuIHJlc29sdmVkIHx8IChyZXNvbHZlZCA9IHV0aWxzX1Byb21pc2UucmVzb2x2ZSgpKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHR0byA9IHt9O1xuICBcdFx0XHR0b1tzdHlsZV0gPSB2YWx1ZTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRvID0gc3R5bGU7XG5cbiAgXHRcdFx0Ly8gc2h1ZmZsZSBhcmd1bWVudHNcbiAgXHRcdFx0b3B0aW9ucyA9IHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBBcyBvZiAwLjMuOSwgdHJhbnNpdGlvbiBhdXRob3JzIHNob3VsZCBzdXBwbHkgYW4gYG9wdGlvbmAgb2JqZWN0IHdpdGhcbiAgXHRcdC8vIGBkdXJhdGlvbmAgYW5kIGBlYXNpbmdgIHByb3BlcnRpZXMgKGFuZCBvcHRpb25hbCBgZGVsYXlgKSwgcGx1cyBhXG4gIFx0XHQvLyBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGFmdGVyIHRoZSBhbmltYXRpb24gY29tcGxldGVzXG5cbiAgXHRcdC8vIFRPRE8gcmVtb3ZlIHRoaXMgY2hlY2sgaW4gYSBmdXR1cmUgdmVyc2lvblxuICBcdFx0aWYgKCFvcHRpb25zKSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhcIlRoZSBcXFwiJXNcXFwiIHRyYW5zaXRpb24gZG9lcyBub3Qgc3VwcGx5IGFuIG9wdGlvbnMgb2JqZWN0IHRvIGB0LmFuaW1hdGVTdHlsZSgpYC4gVGhpcyB3aWxsIGJyZWFrIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgUmFjdGl2ZS4gRm9yIG1vcmUgaW5mbyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3Vlcy8zNDBcIiwgdGhpcy5uYW1lKTtcbiAgXHRcdFx0b3B0aW9ucyA9IHRoaXM7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBwcm9taXNlID0gbmV3IHV0aWxzX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgXHRcdFx0dmFyIHByb3BlcnR5TmFtZXMsIGNoYW5nZWRQcm9wZXJ0aWVzLCBjb21wdXRlZFN0eWxlLCBjdXJyZW50LCBmcm9tLCBpLCBwcm9wO1xuXG4gIFx0XHRcdC8vIEVkZ2UgY2FzZSAtIGlmIGR1cmF0aW9uIGlzIHplcm8sIHNldCBzdHlsZSBzeW5jaHJvbm91c2x5IGFuZCBjb21wbGV0ZVxuICBcdFx0XHRpZiAoIW9wdGlvbnMuZHVyYXRpb24pIHtcbiAgXHRcdFx0XHRfdGhpcy5zZXRTdHlsZSh0byk7XG4gIFx0XHRcdFx0cmVzb2x2ZSgpO1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIEdldCBhIGxpc3Qgb2YgdGhlIHByb3BlcnRpZXMgd2UncmUgYW5pbWF0aW5nXG4gIFx0XHRcdHByb3BlcnR5TmFtZXMgPSBPYmplY3Qua2V5cyh0byk7XG4gIFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzID0gW107XG5cbiAgXHRcdFx0Ly8gU3RvcmUgdGhlIGN1cnJlbnQgc3R5bGVzXG4gIFx0XHRcdGNvbXB1dGVkU3R5bGUgPSBfYW5pbWF0ZVN0eWxlX19nZXRDb21wdXRlZFN0eWxlKF90aGlzLm5vZGUpO1xuXG4gIFx0XHRcdGZyb20gPSB7fTtcbiAgXHRcdFx0aSA9IHByb3BlcnR5TmFtZXMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0cHJvcCA9IHByb3BlcnR5TmFtZXNbaV07XG4gIFx0XHRcdFx0Y3VycmVudCA9IGNvbXB1dGVkU3R5bGVbaGVscGVyc19wcmVmaXgocHJvcCldO1xuXG4gIFx0XHRcdFx0aWYgKGN1cnJlbnQgPT09IFwiMHB4XCIpIHtcbiAgXHRcdFx0XHRcdGN1cnJlbnQgPSAwO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIHdlIG5lZWQgdG8ga25vdyBpZiB3ZSdyZSBhY3R1YWxseSBjaGFuZ2luZyBhbnl0aGluZ1xuICBcdFx0XHRcdGlmIChjdXJyZW50ICE9IHRvW3Byb3BdKSB7XG4gIFx0XHRcdFx0XHQvLyB1c2UgIT0gaW5zdGVhZCBvZiAhPT0sIHNvIHdlIGNhbiBjb21wYXJlIHN0cmluZ3Mgd2l0aCBudW1iZXJzXG4gIFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5wdXNoKHByb3ApO1xuXG4gIFx0XHRcdFx0XHQvLyBtYWtlIHRoZSBjb21wdXRlZCBzdHlsZSBleHBsaWNpdCwgc28gd2UgY2FuIGFuaW1hdGUgd2hlcmVcbiAgXHRcdFx0XHRcdC8vIGUuZy4gaGVpZ2h0PSdhdXRvJ1xuICBcdFx0XHRcdFx0X3RoaXMubm9kZS5zdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wKV0gPSBjdXJyZW50O1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIElmIHdlJ3JlIG5vdCBhY3R1YWxseSBjaGFuZ2luZyBhbnl0aGluZywgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnRcbiAgXHRcdFx0Ly8gd2lsbCBuZXZlciBmaXJlISBTbyB3ZSBjb21wbGV0ZSBlYXJseVxuICBcdFx0XHRpZiAoIWNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICBcdFx0XHRcdHJlc29sdmUoKTtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHRhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnMoX3RoaXMsIHRvLCBvcHRpb25zLCBjaGFuZ2VkUHJvcGVydGllcywgcmVzb2x2ZSk7XG4gIFx0XHR9KTtcblxuICBcdFx0cmV0dXJuIHByb21pc2U7XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBfYW5pbWF0ZVN0eWxlID0gYW5pbWF0ZVN0eWxlO1xuXG4gIHZhciBwcm9jZXNzUGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcywgZGVmYXVsdHMpIHtcbiAgXHRpZiAodHlwZW9mIHBhcmFtcyA9PT0gXCJudW1iZXJcIikge1xuICBcdFx0cGFyYW1zID0geyBkdXJhdGlvbjogcGFyYW1zIH07XG4gIFx0fSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRpZiAocGFyYW1zID09PSBcInNsb3dcIikge1xuICBcdFx0XHRwYXJhbXMgPSB7IGR1cmF0aW9uOiA2MDAgfTtcbiAgXHRcdH0gZWxzZSBpZiAocGFyYW1zID09PSBcImZhc3RcIikge1xuICBcdFx0XHRwYXJhbXMgPSB7IGR1cmF0aW9uOiAyMDAgfTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHBhcmFtcyA9IHsgZHVyYXRpb246IDQwMCB9O1xuICBcdFx0fVxuICBcdH0gZWxzZSBpZiAoIXBhcmFtcykge1xuICBcdFx0cGFyYW1zID0ge307XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGZpbGxHYXBzKHt9LCBwYXJhbXMsIGRlZmF1bHRzKTtcbiAgfTtcblxuICB2YXIgcHJvdG90eXBlX3N0YXJ0ID0gVHJhbnNpdGlvbiRzdGFydDtcblxuICBmdW5jdGlvbiBUcmFuc2l0aW9uJHN0YXJ0KCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgbm9kZSwgb3JpZ2luYWxTdHlsZSwgY29tcGxldGVkO1xuXG4gIFx0bm9kZSA9IHRoaXMubm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuICBcdG9yaWdpbmFsU3R5bGUgPSBub2RlLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuXG4gIFx0Ly8gY3JlYXRlIHQuY29tcGxldGUoKSAtIHdlIGRvbid0IHdhbnQgdGhpcyBvbiB0aGUgcHJvdG90eXBlLFxuICBcdC8vIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBgdGhpc2Agc2lsbGluZXNzIHdoZW4gcGFzc2luZyBpdCBhc1xuICBcdC8vIGFuIGFyZ3VtZW50XG4gIFx0dGhpcy5jb21wbGV0ZSA9IGZ1bmN0aW9uIChub1Jlc2V0KSB7XG4gIFx0XHRpZiAoY29tcGxldGVkKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFub1Jlc2V0ICYmIF90aGlzLmlzSW50cm8pIHtcbiAgXHRcdFx0cmVzZXRTdHlsZShub2RlLCBvcmlnaW5hbFN0eWxlKTtcbiAgXHRcdH1cblxuICBcdFx0bm9kZS5fcmFjdGl2ZS50cmFuc2l0aW9uID0gbnVsbDtcbiAgXHRcdF90aGlzLl9tYW5hZ2VyLnJlbW92ZShfdGhpcyk7XG5cbiAgXHRcdGNvbXBsZXRlZCA9IHRydWU7XG4gIFx0fTtcblxuICBcdC8vIElmIHRoZSB0cmFuc2l0aW9uIGZ1bmN0aW9uIGRvZXNuJ3QgZXhpc3QsIGFib3J0XG4gIFx0aWYgKCF0aGlzLl9mbikge1xuICBcdFx0dGhpcy5jb21wbGV0ZSgpO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHRoaXMuX2ZuLmFwcGx5KHRoaXMucm9vdCwgW3RoaXNdLmNvbmNhdCh0aGlzLnBhcmFtcykpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRTdHlsZShub2RlLCBzdHlsZSkge1xuICBcdGlmIChzdHlsZSkge1xuICBcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBzdHlsZSk7XG4gIFx0fSBlbHNlIHtcblxuICBcdFx0Ly8gTmV4dCBsaW5lIGlzIG5lY2Vzc2FyeSwgdG8gcmVtb3ZlIGVtcHR5IHN0eWxlIGF0dHJpYnV0ZSFcbiAgXHRcdC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTY3NTUzXG4gIFx0XHRub2RlLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICBcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChvd25lciwgdGVtcGxhdGUsIGlzSW50cm8pIHtcbiAgXHR0aGlzLmluaXQob3duZXIsIHRlbXBsYXRlLCBpc0ludHJvKTtcbiAgfTtcblxuICBUcmFuc2l0aW9uLnByb3RvdHlwZSA9IHtcbiAgXHRpbml0OiBUcmFuc2l0aW9uX3Byb3RvdHlwZV9pbml0LFxuICBcdHN0YXJ0OiBwcm90b3R5cGVfc3RhcnQsXG4gIFx0Z2V0U3R5bGU6IHByb3RvdHlwZV9nZXRTdHlsZSxcbiAgXHRzZXRTdHlsZTogc2V0U3R5bGUsXG4gIFx0YW5pbWF0ZVN0eWxlOiBfYW5pbWF0ZVN0eWxlLFxuICBcdHByb2Nlc3NQYXJhbXM6IHByb2Nlc3NQYXJhbXNcbiAgfTtcblxuICB2YXIgX1RyYW5zaXRpb24gPSBUcmFuc2l0aW9uO1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9yZW5kZXIgPSBFbGVtZW50JHJlbmRlcjtcblxuICB2YXIgdXBkYXRlQ3NzLCB1cGRhdGVTY3JpcHQ7XG5cbiAgdXBkYXRlQ3NzID0gZnVuY3Rpb24gKCkge1xuICBcdHZhciBub2RlID0gdGhpcy5ub2RlLFxuICBcdCAgICBjb250ZW50ID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyhmYWxzZSk7XG5cbiAgXHQvLyBJRTggaGFzIG5vIHN0eWxlU2hlZXQgdW5sZXNzIHRoZXJlJ3MgYSB0eXBlIHRleHQvY3NzXG4gIFx0aWYgKHdpbmRvdyAmJiB3aW5kb3cuYXBwZWFyc1RvQmVJRUxlc3NFcXVhbDgpIHtcbiAgXHRcdG5vZGUudHlwZSA9IFwidGV4dC9jc3NcIjtcbiAgXHR9XG5cbiAgXHRpZiAobm9kZS5zdHlsZVNoZWV0KSB7XG4gIFx0XHRub2RlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNvbnRlbnQ7XG4gIFx0fSBlbHNlIHtcblxuICBcdFx0d2hpbGUgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gIFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgXHRcdH1cblxuICBcdFx0bm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb250ZW50KSk7XG4gIFx0fVxuICB9O1xuXG4gIHVwZGF0ZVNjcmlwdCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRpZiAoIXRoaXMubm9kZS50eXBlIHx8IHRoaXMubm9kZS50eXBlID09PSBcInRleHQvamF2YXNjcmlwdFwiKSB7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcIlNjcmlwdCB0YWcgd2FzIHVwZGF0ZWQuIFRoaXMgZG9lcyBub3QgY2F1c2UgdGhlIGNvZGUgdG8gYmUgcmUtZXZhbHVhdGVkIVwiLCB7IHJhY3RpdmU6IHRoaXMucm9vdCB9KTtcbiAgXHRcdC8vIEFzIGl0IGhhcHBlbnMsIHdlIEFSRSBpbiBhIHBvc2l0aW9uIHRvIHJlLWV2YWx1YXRlIHRoZSBjb2RlIGlmIHdlIHdhbnRlZFxuICBcdFx0Ly8gdG8gLSB3ZSBjb3VsZCBldmFsKCkgaXQsIG9yIGluc2VydCBpdCBpbnRvIGEgZnJlc2ggKHRlbXBvcmFyeSkgc2NyaXB0IHRhZy5cbiAgXHRcdC8vIEJ1dCB0aGlzIHdvdWxkIGJlIGEgdGVycmlibGUgaWRlYSB3aXRoIHVucHJlZGljdGFibGUgcmVzdWx0cywgc28gbGV0J3Mgbm90LlxuICBcdH1cblxuICBcdHRoaXMubm9kZS50ZXh0ID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyhmYWxzZSk7XG4gIH07XG4gIGZ1bmN0aW9uIEVsZW1lbnQkcmVuZGVyKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgcm9vdCA9IHRoaXMucm9vdCxcbiAgXHQgICAgbmFtZXNwYWNlLFxuICBcdCAgICBub2RlLFxuICBcdCAgICB0cmFuc2l0aW9uO1xuXG4gIFx0bmFtZXNwYWNlID0gZ2V0TmFtZXNwYWNlKHRoaXMpO1xuICBcdG5vZGUgPSB0aGlzLm5vZGUgPSBjcmVhdGVFbGVtZW50KHRoaXMubmFtZSwgbmFtZXNwYWNlKTtcblxuICBcdC8vIElzIHRoaXMgYSB0b3AtbGV2ZWwgbm9kZSBvZiBhIGNvbXBvbmVudD8gSWYgc28sIHdlIG1heSBuZWVkIHRvIGFkZFxuICBcdC8vIGEgZGF0YS1yYWN0aXZlLWNzcyBhdHRyaWJ1dGUsIGZvciBDU1MgZW5jYXBzdWxhdGlvblxuICBcdGlmICh0aGlzLnBhcmVudEZyYWdtZW50LmNzc0lkcykge1xuICBcdFx0dGhpcy5ub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtcmFjdGl2ZS1jc3NcIiwgdGhpcy5wYXJlbnRGcmFnbWVudC5jc3NJZHMubWFwKGZ1bmN0aW9uICh4KSB7XG4gIFx0XHRcdHJldHVybiBcIntcIiArIHggKyBcIn1cIjtcbiAgXHRcdH0pLmpvaW4oXCIgXCIpKTtcbiAgXHR9XG5cbiAgXHQvLyBBZGQgX3JhY3RpdmUgcHJvcGVydHkgdG8gdGhlIG5vZGUgLSB3ZSB1c2UgdGhpcyBvYmplY3QgdG8gc3RvcmUgc3R1ZmZcbiAgXHQvLyByZWxhdGVkIHRvIHByb3h5IGV2ZW50cywgdHdvLXdheSBiaW5kaW5ncyBldGNcbiAgXHRkZWZpbmVQcm9wZXJ0eSh0aGlzLm5vZGUsIFwiX3JhY3RpdmVcIiwge1xuICBcdFx0dmFsdWU6IHtcbiAgXHRcdFx0cHJveHk6IHRoaXMsXG4gIFx0XHRcdGtleXBhdGg6IGdldElubmVyQ29udGV4dCh0aGlzLnBhcmVudEZyYWdtZW50KSxcbiAgXHRcdFx0ZXZlbnRzOiBjcmVhdGUobnVsbCksXG4gIFx0XHRcdHJvb3Q6IHJvb3RcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdC8vIFJlbmRlciBhdHRyaWJ1dGVzXG4gIFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgXHRcdHJldHVybiBhLnJlbmRlcihub2RlKTtcbiAgXHR9KTtcbiAgXHR0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gIFx0XHRyZXR1cm4gYS5yZW5kZXIobm9kZSk7XG4gIFx0fSk7XG5cbiAgXHQvLyBSZW5kZXIgY2hpbGRyZW5cbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gPHNjcmlwdD4gZWxlbWVudFxuICBcdFx0aWYgKHRoaXMubmFtZSA9PT0gXCJzY3JpcHRcIikge1xuICBcdFx0XHR0aGlzLmJ1YmJsZSA9IHVwZGF0ZVNjcmlwdDtcbiAgXHRcdFx0dGhpcy5ub2RlLnRleHQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKGZhbHNlKTsgLy8gYnlwYXNzIHdhcm5pbmcgaW5pdGlhbGx5XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIgPSBub29wOyAvLyBUT0RPIHRoaXMgaXMgYSBrbHVkZ2VcbiAgXHRcdH1cblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gPHN0eWxlPiBlbGVtZW50XG4gIFx0XHRlbHNlIGlmICh0aGlzLm5hbWUgPT09IFwic3R5bGVcIikge1xuICBcdFx0XHR0aGlzLmJ1YmJsZSA9IHVwZGF0ZUNzcztcbiAgXHRcdFx0dGhpcy5idWJibGUoKTtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciA9IG5vb3A7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSAtIGNvbnRlbnRlZGl0YWJsZVxuICBcdFx0ZWxzZSBpZiAodGhpcy5iaW5kaW5nICYmIHRoaXMuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpKSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIgPSBub29wO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuZnJhZ21lbnQucmVuZGVyKCkpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIGRlYWwgd2l0aCB0d28td2F5IGJpbmRpbmdzXG4gIFx0aWYgKHRoaXMuYmluZGluZykge1xuICBcdFx0dGhpcy5iaW5kaW5nLnJlbmRlcigpO1xuICBcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLmJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XG4gIFx0fVxuXG4gIFx0Ly8gQWRkIHByb3h5IGV2ZW50IGhhbmRsZXJzXG4gIFx0aWYgKHRoaXMuZXZlbnRIYW5kbGVycykge1xuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGgpIHtcbiAgXHRcdFx0cmV0dXJuIGgucmVuZGVyKCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiKSB7XG4gIFx0XHRwcm9jZXNzT3B0aW9uKHRoaXMpO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZXNcbiAgXHRpZiAodGhpcy5uYW1lID09PSBcImltZ1wiKSB7XG4gIFx0XHQvLyBpZiB0aGlzIGlzIGFuIDxpbWc+LCBhbmQgd2UncmUgaW4gYSBjcmFwIGJyb3dzZXIsIHdlIG1heVxuICBcdFx0Ly8gbmVlZCB0byBwcmV2ZW50IGl0IGZyb20gb3ZlcnJpZGluZyB3aWR0aCBhbmQgaGVpZ2h0IHdoZW5cbiAgXHRcdC8vIGl0IGxvYWRzIHRoZSBzcmNcbiAgXHRcdHNwZWNpYWxfaW1nX19yZW5kZXIodGhpcyk7XG4gIFx0fSBlbHNlIGlmICh0aGlzLm5hbWUgPT09IFwiZm9ybVwiKSB7XG4gIFx0XHQvLyBmb3JtcyBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgdGhlaXIgYmluZGluZ3MsIGluIGNhc2Ugb2YgcmVzZXRcbiAgXHRcdGZvcm1fX3JlbmRlcih0aGlzKTtcbiAgXHR9IGVsc2UgaWYgKHRoaXMubmFtZSA9PT0gXCJpbnB1dFwiIHx8IHRoaXMubmFtZSA9PT0gXCJ0ZXh0YXJlYVwiKSB7XG4gIFx0XHQvLyBpbnB1dHMgYW5kIHRleHRhcmVhcyBzaG91bGQgc3RvcmUgdGhlaXIgaW5pdGlhbCB2YWx1ZSBhc1xuICBcdFx0Ly8gYGRlZmF1bHRWYWx1ZWAgaW4gY2FzZSBvZiByZXNldFxuICBcdFx0dGhpcy5ub2RlLmRlZmF1bHRWYWx1ZSA9IHRoaXMubm9kZS52YWx1ZTtcbiAgXHR9IGVsc2UgaWYgKHRoaXMubmFtZSA9PT0gXCJvcHRpb25cIikge1xuICBcdFx0Ly8gc2ltaWxhcmx5IGZvciBvcHRpb24gbm9kZXNcbiAgXHRcdHRoaXMubm9kZS5kZWZhdWx0U2VsZWN0ZWQgPSB0aGlzLm5vZGUuc2VsZWN0ZWQ7XG4gIFx0fVxuXG4gIFx0Ly8gYXBwbHkgZGVjb3JhdG9yKHMpXG4gIFx0aWYgKHRoaXMuZGVjb3JhdG9yICYmIHRoaXMuZGVjb3JhdG9yLmZuKSB7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRpZiAoIV90aGlzLmRlY29yYXRvci50b3JuZG93bikge1xuICBcdFx0XHRcdF90aGlzLmRlY29yYXRvci5pbml0KCk7XG4gIFx0XHRcdH1cbiAgXHRcdH0sIHRydWUpO1xuICBcdH1cblxuICBcdC8vIHRyaWdnZXIgaW50cm8gdHJhbnNpdGlvblxuICBcdGlmIChyb290LnRyYW5zaXRpb25zRW5hYmxlZCAmJiB0aGlzLmludHJvKSB7XG4gIFx0XHR0cmFuc2l0aW9uID0gbmV3IF9UcmFuc2l0aW9uKHRoaXMsIHRoaXMuaW50cm8sIHRydWUpO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AucmVnaXN0ZXJUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIHRyYW5zaXRpb24uc3RhcnQoKTtcbiAgXHRcdH0sIHRydWUpO1xuXG4gIFx0XHR0aGlzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICBcdH1cblxuICBcdGlmICh0aGlzLm5vZGUuYXV0b2ZvY3VzKSB7XG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UuIFNvbWUgYnJvd3NlcnMgKCpjb3VnaCogRmlyZWZpeCAqY291Z2gqKSBoYXZlIGEgcHJvYmxlbVxuICBcdFx0Ly8gd2l0aCBkeW5hbWljYWxseS1nZW5lcmF0ZWQgZWxlbWVudHMgaGF2aW5nIGF1dG9mb2N1cywgYW5kIHRoZXkgd29uJ3RcbiAgXHRcdC8vIGFsbG93IHlvdSB0byBwcm9ncmFtbWF0aWNhbGx5IGZvY3VzIHRoZSBlbGVtZW50IHVudGlsIGl0J3MgaW4gdGhlIERPTVxuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIF90aGlzLm5vZGUuZm9jdXMoKTtcbiAgXHRcdH0sIHRydWUpO1xuICBcdH1cblxuICBcdHVwZGF0ZUxpdmVRdWVyaWVzKHRoaXMpO1xuICBcdHJldHVybiB0aGlzLm5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROYW1lc3BhY2UoZWxlbWVudCkge1xuICBcdHZhciBuYW1lc3BhY2UsIHhtbG5zLCBwYXJlbnQ7XG5cbiAgXHQvLyBVc2Ugc3BlY2lmaWVkIG5hbWVzcGFjZS4uLlxuICBcdGlmICh4bWxucyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikpIHtcbiAgXHRcdG5hbWVzcGFjZSA9IHhtbG5zO1xuICBcdH1cblxuICBcdC8vIC4uLm9yIFNWRyBuYW1lc3BhY2UsIGlmIHRoaXMgaXMgYW4gPHN2Zz4gZWxlbWVudFxuICBcdGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gXCJzdmdcIikge1xuICBcdFx0bmFtZXNwYWNlID0gbmFtZXNwYWNlcy5zdmc7XG4gIFx0fSBlbHNlIGlmIChwYXJlbnQgPSBlbGVtZW50LnBhcmVudCkge1xuICBcdFx0Ly8gLi4ub3IgSFRNTCwgaWYgdGhlIHBhcmVudCBpcyBhIDxmb3JlaWduT2JqZWN0PlxuICBcdFx0aWYgKHBhcmVudC5uYW1lID09PSBcImZvcmVpZ25PYmplY3RcIikge1xuICBcdFx0XHRuYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmh0bWw7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIC4uLm9yIGluaGVyaXQgZnJvbSB0aGUgcGFyZW50IG5vZGVcbiAgXHRcdGVsc2Uge1xuICBcdFx0XHRuYW1lc3BhY2UgPSBwYXJlbnQubm9kZS5uYW1lc3BhY2VVUkk7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG5hbWVzcGFjZSA9IGVsZW1lbnQucm9vdC5lbC5uYW1lc3BhY2VVUkk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG5hbWVzcGFjZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NPcHRpb24ob3B0aW9uKSB7XG4gIFx0dmFyIG9wdGlvblZhbHVlLCBzZWxlY3RWYWx1ZSwgaTtcblxuICBcdGlmICghb3B0aW9uLnNlbGVjdCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHNlbGVjdFZhbHVlID0gb3B0aW9uLnNlbGVjdC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgXHRpZiAoc2VsZWN0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdG9wdGlvblZhbHVlID0gb3B0aW9uLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0aWYgKG9wdGlvbi5zZWxlY3Qubm9kZS5tdWx0aXBsZSAmJiBpc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICBcdFx0aSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0aWYgKG9wdGlvblZhbHVlID09IHNlbGVjdFZhbHVlW2ldKSB7XG4gIFx0XHRcdFx0b3B0aW9uLm5vZGUuc2VsZWN0ZWQgPSB0cnVlO1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG9wdGlvbi5ub2RlLnNlbGVjdGVkID0gb3B0aW9uVmFsdWUgPT0gc2VsZWN0VmFsdWU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGl2ZVF1ZXJpZXMoZWxlbWVudCkge1xuICBcdHZhciBpbnN0YW5jZSwgbGl2ZVF1ZXJpZXMsIGksIHNlbGVjdG9yLCBxdWVyeTtcblxuICBcdC8vIERvZXMgdGhpcyBuZWVkIHRvIGJlIGFkZGVkIHRvIGFueSBsaXZlIHF1ZXJpZXM/XG4gIFx0aW5zdGFuY2UgPSBlbGVtZW50LnJvb3Q7XG5cbiAgXHRkbyB7XG4gIFx0XHRsaXZlUXVlcmllcyA9IGluc3RhbmNlLl9saXZlUXVlcmllcztcblxuICBcdFx0aSA9IGxpdmVRdWVyaWVzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0c2VsZWN0b3IgPSBsaXZlUXVlcmllc1tpXTtcbiAgXHRcdFx0cXVlcnkgPSBsaXZlUXVlcmllc1tcIl9cIiArIHNlbGVjdG9yXTtcblxuICBcdFx0XHRpZiAocXVlcnkuX3Rlc3QoZWxlbWVudCkpIHtcbiAgXHRcdFx0XHQvLyBrZWVwIHJlZ2lzdGVyIG9mIGFwcGxpY2FibGUgc2VsZWN0b3JzLCBmb3Igd2hlbiB3ZSB0ZWFyZG93blxuICBcdFx0XHRcdChlbGVtZW50LmxpdmVRdWVyaWVzIHx8IChlbGVtZW50LmxpdmVRdWVyaWVzID0gW10pKS5wdXNoKHF1ZXJ5KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0gd2hpbGUgKGluc3RhbmNlID0gaW5zdGFuY2UucGFyZW50KTtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV90b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgc3RyLCBlc2NhcGU7XG5cbiAgXHRpZiAodGhpcy50ZW1wbGF0ZS55KSB7XG4gIFx0XHQvLyBET0NUWVBFIGRlY2xhcmF0aW9uXG4gIFx0XHRyZXR1cm4gXCI8IURPQ1RZUEVcIiArIHRoaXMudGVtcGxhdGUuZGQgKyBcIj5cIjtcbiAgXHR9XG5cbiAgXHRzdHIgPSBcIjxcIiArIHRoaXMudGVtcGxhdGUuZTtcblxuICBcdHN0ciArPSB0aGlzLmF0dHJpYnV0ZXMubWFwKHN0cmluZ2lmeUF0dHJpYnV0ZSkuam9pbihcIlwiKSArIHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzLm1hcChzdHJpbmdpZnlBdHRyaWJ1dGUpLmpvaW4oXCJcIik7XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSBzZWxlY3RlZCBvcHRpb25zXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJvcHRpb25cIiAmJiBvcHRpb25Jc1NlbGVjdGVkKHRoaXMpKSB7XG4gIFx0XHRzdHIgKz0gXCIgc2VsZWN0ZWRcIjtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSB0d28td2F5IHJhZGlvIG5hbWUgYmluZGluZ3NcbiAgXHRpZiAodGhpcy5uYW1lID09PSBcImlucHV0XCIgJiYgaW5wdXRJc0NoZWNrZWRSYWRpbyh0aGlzKSkge1xuICBcdFx0c3RyICs9IFwiIGNoZWNrZWRcIjtcbiAgXHR9XG5cbiAgXHRzdHIgKz0gXCI+XCI7XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSB0ZXh0YXJlYVxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwidGV4dGFyZWFcIiAmJiB0aGlzLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdHN0ciArPSBlc2NhcGVIdG1sKHRoaXMuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikpO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIGNvbnRlbnRlZGl0YWJsZVxuICBcdGVsc2UgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdHN0ciArPSB0aGlzLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIHx8IFwiXCI7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdGVzY2FwZSA9IHRoaXMubmFtZSAhPT0gXCJzY3JpcHRcIiAmJiB0aGlzLm5hbWUgIT09IFwic3R5bGVcIjtcbiAgXHRcdHN0ciArPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKGVzY2FwZSk7XG4gIFx0fVxuXG4gIFx0Ly8gYWRkIGEgY2xvc2luZyB0YWcgaWYgdGhpcyBpc24ndCBhIHZvaWQgZWxlbWVudFxuICBcdGlmICghdm9pZEVsZW1lbnROYW1lcy50ZXN0KHRoaXMudGVtcGxhdGUuZSkpIHtcbiAgXHRcdHN0ciArPSBcIjwvXCIgKyB0aGlzLnRlbXBsYXRlLmUgKyBcIj5cIjtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3RyO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG9wdGlvbklzU2VsZWN0ZWQoZWxlbWVudCkge1xuICBcdHZhciBvcHRpb25WYWx1ZSwgc2VsZWN0VmFsdWUsIGk7XG5cbiAgXHRvcHRpb25WYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRpZiAob3B0aW9uVmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhZWxlbWVudC5zZWxlY3QpIHtcbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG5cbiAgXHRzZWxlY3RWYWx1ZSA9IGVsZW1lbnQuc2VsZWN0LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0aWYgKHNlbGVjdFZhbHVlID09IG9wdGlvblZhbHVlKSB7XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG5cbiAgXHRpZiAoZWxlbWVudC5zZWxlY3QuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikgJiYgaXNBcnJheShzZWxlY3RWYWx1ZSkpIHtcbiAgXHRcdGkgPSBzZWxlY3RWYWx1ZS5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGlmIChzZWxlY3RWYWx1ZVtpXSA9PSBvcHRpb25WYWx1ZSkge1xuICBcdFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gaW5wdXRJc0NoZWNrZWRSYWRpbyhlbGVtZW50KSB7XG4gIFx0dmFyIGF0dHJpYnV0ZXMsIHR5cGVBdHRyaWJ1dGUsIHZhbHVlQXR0cmlidXRlLCBuYW1lQXR0cmlidXRlO1xuXG4gIFx0YXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcztcblxuICBcdHR5cGVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnR5cGU7XG4gIFx0dmFsdWVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnZhbHVlO1xuICBcdG5hbWVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLm5hbWU7XG5cbiAgXHRpZiAoIXR5cGVBdHRyaWJ1dGUgfHwgdHlwZUF0dHJpYnV0ZS52YWx1ZSAhPT0gXCJyYWRpb1wiIHx8ICF2YWx1ZUF0dHJpYnV0ZSB8fCAhbmFtZUF0dHJpYnV0ZS5pbnRlcnBvbGF0b3IpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAodmFsdWVBdHRyaWJ1dGUudmFsdWUgPT09IG5hbWVBdHRyaWJ1dGUuaW50ZXJwb2xhdG9yLnZhbHVlKSB7XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gIFx0dmFyIHN0ciA9IGF0dHJpYnV0ZS50b1N0cmluZygpO1xuICBcdHJldHVybiBzdHIgPyBcIiBcIiArIHN0ciA6IFwiXCI7XG4gIH1cblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfdW5iaW5kID0gRWxlbWVudCR1bmJpbmQ7XG4gIGZ1bmN0aW9uIEVsZW1lbnQkdW5iaW5kKCkge1xuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmJpbmRpbmcpIHtcbiAgXHRcdHRoaXMuYmluZGluZy51bmJpbmQoKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5ldmVudEhhbmRsZXJzKSB7XG4gIFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIDxvcHRpb24+XG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJvcHRpb25cIikge1xuICBcdFx0c3BlY2lhbF9vcHRpb25fX3VuYmluZCh0aGlzKTtcbiAgXHR9XG5cbiAgXHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV91bnJlbmRlciA9IEVsZW1lbnQkdW5yZW5kZXI7XG5cbiAgZnVuY3Rpb24gRWxlbWVudCR1bnJlbmRlcihzaG91bGREZXN0cm95KSB7XG4gIFx0dmFyIGJpbmRpbmcsIGJpbmRpbmdzLCB0cmFuc2l0aW9uO1xuXG4gIFx0aWYgKHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb24pIHtcbiAgXHRcdHRyYW5zaXRpb24uY29tcGxldGUoKTtcbiAgXHR9XG5cbiAgXHQvLyBEZXRhY2ggYXMgc29vbiBhcyB3ZSBjYW5cbiAgXHRpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiKSB7XG4gIFx0XHQvLyA8b3B0aW9uPiBlbGVtZW50cyBkZXRhY2ggaW1tZWRpYXRlbHksIHNvIHRoYXRcbiAgXHRcdC8vIHRoZWlyIHBhcmVudCA8c2VsZWN0PiBlbGVtZW50IHN5bmNzIGNvcnJlY3RseSwgYW5kXG4gIFx0XHQvLyBzaW5jZSBvcHRpb24gZWxlbWVudHMgY2FuJ3QgaGF2ZSB0cmFuc2l0aW9ucyBhbnl3YXlcbiAgXHRcdHRoaXMuZGV0YWNoKCk7XG4gIFx0fSBlbHNlIGlmIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5kZXRhY2hXaGVuUmVhZHkodGhpcyk7XG4gIFx0fVxuXG4gIFx0Ly8gQ2hpbGRyZW4gZmlyc3QuIHRoYXQgd2F5LCBhbnkgdHJhbnNpdGlvbnMgb24gY2hpbGQgZWxlbWVudHMgd2lsbCBiZVxuICBcdC8vIGhhbmRsZWQgYnkgdGhlIGN1cnJlbnQgdHJhbnNpdGlvbk1hbmFnZXJcbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlcihmYWxzZSk7XG4gIFx0fVxuXG4gIFx0aWYgKGJpbmRpbmcgPSB0aGlzLmJpbmRpbmcpIHtcbiAgXHRcdHRoaXMuYmluZGluZy51bnJlbmRlcigpO1xuXG4gIFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuYmluZGluZyA9IG51bGw7XG4gIFx0XHRiaW5kaW5ncyA9IHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbYmluZGluZy5rZXlwYXRoLnN0cl07XG4gIFx0XHRiaW5kaW5ncy5zcGxpY2UoYmluZGluZ3MuaW5kZXhPZihiaW5kaW5nKSwgMSk7XG4gIFx0fVxuXG4gIFx0Ly8gUmVtb3ZlIGV2ZW50IGhhbmRsZXJzXG4gIFx0aWYgKHRoaXMuZXZlbnRIYW5kbGVycykge1xuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5yZW5kZXIpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmRlY29yYXRvcikge1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AucmVnaXN0ZXJEZWNvcmF0b3IodGhpcy5kZWNvcmF0b3IpO1xuICBcdH1cblxuICBcdC8vIHRyaWdnZXIgb3V0cm8gdHJhbnNpdGlvbiBpZiBuZWNlc3NhcnlcbiAgXHRpZiAodGhpcy5yb290LnRyYW5zaXRpb25zRW5hYmxlZCAmJiB0aGlzLm91dHJvKSB7XG4gIFx0XHR0cmFuc2l0aW9uID0gbmV3IF9UcmFuc2l0aW9uKHRoaXMsIHRoaXMub3V0cm8sIGZhbHNlKTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnJlZ2lzdGVyVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiB0cmFuc2l0aW9uLnN0YXJ0KCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHQvLyBSZW1vdmUgdGhpcyBub2RlIGZyb20gYW55IGxpdmUgcXVlcmllc1xuICBcdGlmICh0aGlzLmxpdmVRdWVyaWVzKSB7XG4gIFx0XHRyZW1vdmVGcm9tTGl2ZVF1ZXJpZXModGhpcyk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJmb3JtXCIpIHtcbiAgXHRcdGZvcm1fX3VucmVuZGVyKHRoaXMpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUZyb21MaXZlUXVlcmllcyhlbGVtZW50KSB7XG4gIFx0dmFyIHF1ZXJ5LCBzZWxlY3RvciwgaTtcblxuICBcdGkgPSBlbGVtZW50LmxpdmVRdWVyaWVzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRxdWVyeSA9IGVsZW1lbnQubGl2ZVF1ZXJpZXNbaV07XG4gIFx0XHRzZWxlY3RvciA9IHF1ZXJ5LnNlbGVjdG9yO1xuXG4gIFx0XHRxdWVyeS5fcmVtb3ZlKGVsZW1lbnQubm9kZSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEVsZW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfTtcblxuICBFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IEVsZW1lbnRfcHJvdG90eXBlX2J1YmJsZSxcbiAgXHRkZXRhY2g6IEVsZW1lbnRfcHJvdG90eXBlX2RldGFjaCxcbiAgXHRmaW5kOiBFbGVtZW50X3Byb3RvdHlwZV9maW5kLFxuICBcdGZpbmRBbGw6IEVsZW1lbnRfcHJvdG90eXBlX2ZpbmRBbGwsXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IEVsZW1lbnRfcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzLFxuICBcdGZpbmRDb21wb25lbnQ6IEVsZW1lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQsXG4gIFx0ZmluZE5leHROb2RlOiBFbGVtZW50X3Byb3RvdHlwZV9maW5kTmV4dE5vZGUsXG4gIFx0Zmlyc3ROb2RlOiBFbGVtZW50X3Byb3RvdHlwZV9maXJzdE5vZGUsXG4gIFx0Z2V0QXR0cmlidXRlOiBnZXRBdHRyaWJ1dGUsXG4gIFx0aW5pdDogRWxlbWVudF9wcm90b3R5cGVfaW5pdCxcbiAgXHRyZWJpbmQ6IEVsZW1lbnRfcHJvdG90eXBlX3JlYmluZCxcbiAgXHRyZW5kZXI6IEVsZW1lbnRfcHJvdG90eXBlX3JlbmRlcixcbiAgXHR0b1N0cmluZzogRWxlbWVudF9wcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBFbGVtZW50X3Byb3RvdHlwZV91bmJpbmQsXG4gIFx0dW5yZW5kZXI6IEVsZW1lbnRfcHJvdG90eXBlX3VucmVuZGVyXG4gIH07XG5cbiAgdmFyIF9FbGVtZW50ID0gRWxlbWVudDtcblxuICB2YXIgZGVJbmRlbnRfX2VtcHR5ID0gL15cXHMqJC8sXG4gICAgICBkZUluZGVudF9fbGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccyovO1xuXG4gIHZhciBkZUluZGVudCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgXHR2YXIgbGluZXMsIGZpcnN0TGluZSwgbGFzdExpbmUsIG1pbkluZGVudDtcblxuICBcdGxpbmVzID0gc3RyLnNwbGl0KFwiXFxuXCIpO1xuXG4gIFx0Ly8gcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IGxpbmUsIGlmIHRoZXkgb25seSBjb250YWluIHdoaXRlc3BhY2VcbiAgXHRmaXJzdExpbmUgPSBsaW5lc1swXTtcbiAgXHRpZiAoZmlyc3RMaW5lICE9PSB1bmRlZmluZWQgJiYgZGVJbmRlbnRfX2VtcHR5LnRlc3QoZmlyc3RMaW5lKSkge1xuICBcdFx0bGluZXMuc2hpZnQoKTtcbiAgXHR9XG5cbiAgXHRsYXN0TGluZSA9IGxhc3RJdGVtKGxpbmVzKTtcbiAgXHRpZiAobGFzdExpbmUgIT09IHVuZGVmaW5lZCAmJiBkZUluZGVudF9fZW1wdHkudGVzdChsYXN0TGluZSkpIHtcbiAgXHRcdGxpbmVzLnBvcCgpO1xuICBcdH1cblxuICBcdG1pbkluZGVudCA9IGxpbmVzLnJlZHVjZShyZWR1Y2VyLCBudWxsKTtcblxuICBcdGlmIChtaW5JbmRlbnQpIHtcbiAgXHRcdHN0ciA9IGxpbmVzLm1hcChmdW5jdGlvbiAobGluZSkge1xuICBcdFx0XHRyZXR1cm4gbGluZS5yZXBsYWNlKG1pbkluZGVudCwgXCJcIik7XG4gIFx0XHR9KS5qb2luKFwiXFxuXCIpO1xuICBcdH1cblxuICBcdHJldHVybiBzdHI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVkdWNlcihwcmV2aW91cywgbGluZSkge1xuICBcdHZhciBsaW5lSW5kZW50ID0gZGVJbmRlbnRfX2xlYWRpbmdXaGl0ZXNwYWNlLmV4ZWMobGluZSlbMF07XG5cbiAgXHRpZiAocHJldmlvdXMgPT09IG51bGwgfHwgbGluZUluZGVudC5sZW5ndGggPCBwcmV2aW91cy5sZW5ndGgpIHtcbiAgXHRcdHJldHVybiBsaW5lSW5kZW50O1xuICBcdH1cblxuICBcdHJldHVybiBwcmV2aW91cztcbiAgfVxuXG4gIHZhciBQYXJ0aWFsX2dldFBhcnRpYWxUZW1wbGF0ZSA9IGdldFBhcnRpYWxUZW1wbGF0ZTtcblxuICBmdW5jdGlvbiBnZXRQYXJ0aWFsVGVtcGxhdGUocmFjdGl2ZSwgbmFtZSwgcGFyZW50RnJhZ21lbnQpIHtcbiAgXHR2YXIgcGFydGlhbDtcblxuICBcdC8vIElmIHRoZSBwYXJ0aWFsIGluIGluc3RhbmNlIG9yIHZpZXcgaGVpcmFyY2h5IGluc3RhbmNlcywgZ3JlYXRcbiAgXHRpZiAocGFydGlhbCA9IGdldFBhcnRpYWxGcm9tUmVnaXN0cnkocmFjdGl2ZSwgbmFtZSwgcGFyZW50RnJhZ21lbnQgfHwge30pKSB7XG4gIFx0XHRyZXR1cm4gcGFydGlhbDtcbiAgXHR9XG5cbiAgXHQvLyBEb2VzIGl0IGV4aXN0IG9uIHRoZSBwYWdlIGFzIGEgc2NyaXB0IHRhZz9cbiAgXHRwYXJ0aWFsID0gdGVtcGxhdGVfcGFyc2VyLmZyb21JZChuYW1lLCB7IG5vVGhyb3c6IHRydWUgfSk7XG5cbiAgXHRpZiAocGFydGlhbCkge1xuICBcdFx0Ly8gaXMgdGhpcyBuZWNlc3Nhcnk/XG4gIFx0XHRwYXJ0aWFsID0gZGVJbmRlbnQocGFydGlhbCk7XG5cbiAgXHRcdC8vIHBhcnNlIGFuZCByZWdpc3RlciB0byB0aGlzIHJhY3RpdmUgaW5zdGFuY2VcbiAgXHRcdHZhciBwYXJzZWQgPSB0ZW1wbGF0ZV9wYXJzZXIucGFyc2UocGFydGlhbCwgdGVtcGxhdGVfcGFyc2VyLmdldFBhcnNlT3B0aW9ucyhyYWN0aXZlKSk7XG5cbiAgXHRcdC8vIHJlZ2lzdGVyIChhbmQgcmV0dXJuIG1haW4gcGFydGlhbCBpZiB0aGVyZSBhcmUgb3RoZXJzIGluIHRoZSB0ZW1wbGF0ZSlcbiAgXHRcdHJldHVybiByYWN0aXZlLnBhcnRpYWxzW25hbWVdID0gcGFyc2VkLnQ7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFydGlhbEZyb21SZWdpc3RyeShyYWN0aXZlLCBuYW1lLCBwYXJlbnRGcmFnbWVudCkge1xuICBcdHZhciBmbiA9IHVuZGVmaW5lZCxcbiAgXHQgICAgcGFydGlhbCA9IGZpbmRQYXJlbnRQYXJ0aWFsKG5hbWUsIHBhcmVudEZyYWdtZW50Lm93bmVyKTtcblxuICBcdC8vIGlmIHRoZXJlIHdhcyBhbiBpbnN0YW5jZSB1cC1oaWVyYXJjaHksIGNvb2xcbiAgXHRpZiAocGFydGlhbCkgcmV0dXJuIHBhcnRpYWw7XG5cbiAgXHQvLyBmaW5kIGZpcnN0IGluc3RhbmNlIGluIHRoZSByYWN0aXZlIG9yIHZpZXcgaGllcmFyY2h5IHRoYXQgaGFzIHRoaXMgcGFydGlhbFxuICBcdHZhciBpbnN0YW5jZSA9IGZpbmRJbnN0YW5jZShcInBhcnRpYWxzXCIsIHJhY3RpdmUsIG5hbWUpO1xuXG4gIFx0aWYgKCFpbnN0YW5jZSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHBhcnRpYWwgPSBpbnN0YW5jZS5wYXJ0aWFsc1tuYW1lXTtcblxuICBcdC8vIHBhcnRpYWwgaXMgYSBmdW5jdGlvbj9cbiAgXHRpZiAodHlwZW9mIHBhcnRpYWwgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0Zm4gPSBwYXJ0aWFsLmJpbmQoaW5zdGFuY2UpO1xuICBcdFx0Zm4uaXNPd25lciA9IGluc3RhbmNlLnBhcnRpYWxzLmhhc093blByb3BlcnR5KG5hbWUpO1xuICBcdFx0cGFydGlhbCA9IGZuLmNhbGwocmFjdGl2ZSwgdGVtcGxhdGVfcGFyc2VyKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnRpYWwgJiYgcGFydGlhbCAhPT0gXCJcIikge1xuICBcdFx0d2FybklmRGVidWcobm9SZWdpc3RyeUZ1bmN0aW9uUmV0dXJuLCBuYW1lLCBcInBhcnRpYWxcIiwgXCJwYXJ0aWFsXCIsIHsgcmFjdGl2ZTogcmFjdGl2ZSB9KTtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGlzIHdhcyBhZGRlZCBtYW51YWxseSB0byB0aGUgcmVnaXN0cnksXG4gIFx0Ly8gYnV0IGhhc24ndCBiZWVuIHBhcnNlZCwgcGFyc2UgaXQgbm93XG4gIFx0aWYgKCF0ZW1wbGF0ZV9wYXJzZXIuaXNQYXJzZWQocGFydGlhbCkpIHtcblxuICBcdFx0Ly8gdXNlIHRoZSBwYXJzZU9wdGlvbnMgb2YgdGhlIHJhY3RpdmUgaW5zdGFuY2Ugb24gd2hpY2ggaXQgd2FzIGZvdW5kXG4gIFx0XHR2YXIgcGFyc2VkID0gdGVtcGxhdGVfcGFyc2VyLnBhcnNlKHBhcnRpYWwsIHRlbXBsYXRlX3BhcnNlci5nZXRQYXJzZU9wdGlvbnMoaW5zdGFuY2UpKTtcblxuICBcdFx0Ly8gUGFydGlhbHMgY2Fubm90IGNvbnRhaW4gbmVzdGVkIHBhcnRpYWxzIVxuICBcdFx0Ly8gVE9ETyBhZGQgYSB0ZXN0IGZvciB0aGlzXG4gIFx0XHRpZiAocGFyc2VkLnApIHtcbiAgXHRcdFx0d2FybklmRGVidWcoXCJQYXJ0aWFscyAoe3s+JXN9fSkgY2Fubm90IGNvbnRhaW4gbmVzdGVkIGlubGluZSBwYXJ0aWFsc1wiLCBuYW1lLCB7IHJhY3RpdmU6IHJhY3RpdmUgfSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlmIGZuLCB1c2UgaW5zdGFuY2UgdG8gc3RvcmUgcmVzdWx0LCBvdGhlcndpc2UgbmVlZHMgdG8gZ29cbiAgXHRcdC8vIGluIHRoZSBjb3JyZWN0IHBvaW50IGluIHByb3RvdHlwZSBjaGFpbiBvbiBpbnN0YW5jZSBvciBjb25zdHJ1Y3RvclxuICBcdFx0dmFyIHRhcmdldCA9IGZuID8gaW5zdGFuY2UgOiBmaW5kT3duZXIoaW5zdGFuY2UsIG5hbWUpO1xuXG4gIFx0XHQvLyBtYXkgYmUgYSB0ZW1wbGF0ZSB3aXRoIHBhcnRpYWxzLCB3aGljaCBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgYW5kIG1haW4gdGVtcGxhdGUgZXh0cmFjdGVkXG4gIFx0XHR0YXJnZXQucGFydGlhbHNbbmFtZV0gPSBwYXJ0aWFsID0gcGFyc2VkLnQ7XG4gIFx0fVxuXG4gIFx0Ly8gc3RvcmUgZm9yIHJlc2V0XG4gIFx0aWYgKGZuKSB7XG4gIFx0XHRwYXJ0aWFsLl9mbiA9IGZuO1xuICBcdH1cblxuICBcdHJldHVybiBwYXJ0aWFsLnYgPyBwYXJ0aWFsLnQgOiBwYXJ0aWFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZE93bmVyKHJhY3RpdmUsIGtleSkge1xuICBcdHJldHVybiByYWN0aXZlLnBhcnRpYWxzLmhhc093blByb3BlcnR5KGtleSkgPyByYWN0aXZlIDogZmluZENvbnN0cnVjdG9yKHJhY3RpdmUuY29uc3RydWN0b3IsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQ29uc3RydWN0b3IoY29uc3RydWN0b3IsIGtleSkge1xuICBcdGlmICghY29uc3RydWN0b3IpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG4gIFx0cmV0dXJuIGNvbnN0cnVjdG9yLnBhcnRpYWxzLmhhc093blByb3BlcnR5KGtleSkgPyBjb25zdHJ1Y3RvciA6IGZpbmRDb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvci5fUGFyZW50LCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFBhcmVudFBhcnRpYWwobmFtZSwgcGFyZW50KSB7XG4gIFx0aWYgKHBhcmVudCkge1xuICBcdFx0aWYgKHBhcmVudC50ZW1wbGF0ZSAmJiBwYXJlbnQudGVtcGxhdGUucCAmJiBwYXJlbnQudGVtcGxhdGUucFtuYW1lXSkge1xuICBcdFx0XHRyZXR1cm4gcGFyZW50LnRlbXBsYXRlLnBbbmFtZV07XG4gIFx0XHR9IGVsc2UgaWYgKHBhcmVudC5wYXJlbnRGcmFnbWVudCAmJiBwYXJlbnQucGFyZW50RnJhZ21lbnQub3duZXIpIHtcbiAgXHRcdFx0cmV0dXJuIGZpbmRQYXJlbnRQYXJ0aWFsKG5hbWUsIHBhcmVudC5wYXJlbnRGcmFnbWVudC5vd25lcik7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIGFwcGx5SW5kZW50ID0gZnVuY3Rpb24gKHN0cmluZywgaW5kZW50KSB7XG4gIFx0dmFyIGluZGVudGVkO1xuXG4gIFx0aWYgKCFpbmRlbnQpIHtcbiAgXHRcdHJldHVybiBzdHJpbmc7XG4gIFx0fVxuXG4gIFx0aW5kZW50ZWQgPSBzdHJpbmcuc3BsaXQoXCJcXG5cIikubWFwKGZ1bmN0aW9uIChsaW5lLCBub3RGaXJzdExpbmUpIHtcbiAgXHRcdHJldHVybiBub3RGaXJzdExpbmUgPyBpbmRlbnQgKyBsaW5lIDogbGluZTtcbiAgXHR9KS5qb2luKFwiXFxuXCIpO1xuXG4gIFx0cmV0dXJuIGluZGVudGVkO1xuICB9O1xuXG4gIHZhciBtaXNzaW5nUGFydGlhbE1lc3NhZ2UgPSBcIkNvdWxkIG5vdCBmaW5kIHRlbXBsYXRlIGZvciBwYXJ0aWFsIFxcXCIlc1xcXCJcIjtcblxuICB2YXIgUGFydGlhbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dmFyIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZTtcblxuICBcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHR0aGlzLnJvb3QgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuICBcdHRoaXMudHlwZSA9IFBBUlRJQUw7XG4gIFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG4gIFx0dGhpcy5uYW1lID0gb3B0aW9ucy50ZW1wbGF0ZS5yO1xuICBcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcblxuICBcdHRoaXMuZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50VG9SZW5kZXIgPSB0aGlzLmZyYWdtZW50VG9VbnJlbmRlciA9IG51bGw7XG5cbiAgXHRNdXN0YWNoZS5pbml0KHRoaXMsIG9wdGlvbnMpO1xuXG4gIFx0Ly8gSWYgdGhpcyBkaWRuJ3QgcmVzb2x2ZSwgaXQgbW9zdCBsaWtlbHkgbWVhbnMgd2UgaGF2ZSBhIG5hbWVkIHBhcnRpYWxcbiAgXHQvLyAoaS5lLiBge3s+Zm9vfX1gIG1lYW5zICd1c2UgdGhlIGZvbyBwYXJ0aWFsJywgbm90ICd1c2UgdGhlIHBhcnRpYWxcbiAgXHQvLyB3aG9zZSBuYW1lIGlzIHRoZSB2YWx1ZSBvZiBgZm9vYCcpXG4gIFx0aWYgKCF0aGlzLmtleXBhdGgpIHtcbiAgXHRcdGlmICh0ZW1wbGF0ZSA9IFBhcnRpYWxfZ2V0UGFydGlhbFRlbXBsYXRlKHRoaXMucm9vdCwgdGhpcy5uYW1lLCBwYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdFx0c2hhcmVkX3VuYmluZC5jYWxsKHRoaXMpOyAvLyBwcmV2ZW50IGFueSBmdXJ0aGVyIGNoYW5nZXNcbiAgXHRcdFx0dGhpcy5pc05hbWVkID0gdHJ1ZTtcbiAgXHRcdFx0dGhpcy5zZXRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3YXJuT25jZUlmRGVidWcobWlzc2luZ1BhcnRpYWxNZXNzYWdlLCB0aGlzLm5hbWUpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICBQYXJ0aWFsLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG4gIFx0fSxcblxuICBcdGRldGFjaDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIFx0fSxcblxuICBcdGZpbmQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZChzZWxlY3Rvcik7XG4gIFx0fSxcblxuICBcdGZpbmRBbGw6IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9LFxuXG4gIFx0ZmluZENvbXBvbmVudDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KHNlbGVjdG9yKTtcbiAgXHR9LFxuXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fSxcblxuICBcdGZpcnN0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG4gIFx0fSxcblxuICBcdGZpbmROZXh0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRnZXRQYXJ0aWFsTmFtZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuaXNOYW1lZCAmJiB0aGlzLm5hbWUpIHJldHVybiB0aGlzLm5hbWU7ZWxzZSBpZiAodGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5uYW1lO2Vsc2UgcmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHQvLyBuYW1lZCBwYXJ0aWFscyBhcmVuJ3QgYm91bmQsIHNvIGRvbid0IHJlYmluZFxuICBcdFx0aWYgKCF0aGlzLmlzTmFtZWQpIHtcbiAgXHRcdFx0TXVzdGFjaGVfcmViaW5kLmNhbGwodGhpcywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgXHRcdHRoaXMudXBkYXRlKCk7XG5cbiAgXHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcbiAgXHR9LFxuXG4gIFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcblxuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdHZhciB0ZW1wbGF0ZTtcblxuICBcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPT09IHRoaXMudmFsdWUpIHtcbiAgXHRcdFx0Ly8gbm90aGluZyBoYXMgY2hhbmdlZCwgc28gbm8gd29yayB0byBiZSBkb25lXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGVtcGxhdGUgPSBQYXJ0aWFsX2dldFBhcnRpYWxUZW1wbGF0ZSh0aGlzLnJvb3QsIFwiXCIgKyB2YWx1ZSwgdGhpcy5wYXJlbnRGcmFnbWVudCk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHdlIG1heSBiZSBoZXJlIGlmIHdlIGhhdmUgYSBwYXJ0aWFsIGxpa2UgYHt7PmZvb319YCBhbmQgYGZvb2AgaXMgdGhlXG4gIFx0XHQvLyBuYW1lIG9mIGJvdGggYSBkYXRhIHByb3BlcnR5ICh3aG9zZSB2YWx1ZSBJU04nVCB0aGUgbmFtZSBvZiBhIHBhcnRpYWwpXG4gIFx0XHQvLyBhbmQgYSBwYXJ0aWFsLiBJbiB0aG9zZSBjYXNlcywgdGhpcyBiZWNvbWVzIGEgbmFtZWQgcGFydGlhbFxuICBcdFx0aWYgKCF0ZW1wbGF0ZSAmJiB0aGlzLm5hbWUgJiYgKHRlbXBsYXRlID0gUGFydGlhbF9nZXRQYXJ0aWFsVGVtcGxhdGUodGhpcy5yb290LCB0aGlzLm5hbWUsIHRoaXMucGFyZW50RnJhZ21lbnQpKSkge1xuICBcdFx0XHRzaGFyZWRfdW5iaW5kLmNhbGwodGhpcyk7XG4gIFx0XHRcdHRoaXMuaXNOYW1lZCA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGVtcGxhdGUpIHtcbiAgXHRcdFx0d2Fybk9uY2VJZkRlYnVnKG1pc3NpbmdQYXJ0aWFsTWVzc2FnZSwgdGhpcy5uYW1lLCB7IHJhY3RpdmU6IHRoaXMucm9vdCB9KTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0XHR0aGlzLnNldFRlbXBsYXRlKHRlbXBsYXRlIHx8IFtdKTtcblxuICBcdFx0dGhpcy5idWJibGUoKTtcblxuICBcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0c2V0VGVtcGxhdGU6IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHRcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0XHR0aGlzLmZyYWdtZW50VG9VbnJlbmRlciA9IHRoaXMuZnJhZ21lbnQ7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuICBcdFx0XHRyb290OiB0aGlzLnJvb3QsXG4gIFx0XHRcdG93bmVyOiB0aGlzLFxuICBcdFx0XHRwRWxlbWVudDogdGhpcy5wYXJlbnRGcmFnbWVudC5wRWxlbWVudFxuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnRUb1JlbmRlciA9IHRoaXMuZnJhZ21lbnQ7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAodG9TdHJpbmcpIHtcbiAgXHRcdHZhciBzdHJpbmcsIHByZXZpb3VzSXRlbSwgbGFzdExpbmUsIG1hdGNoO1xuXG4gIFx0XHRzdHJpbmcgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKHRvU3RyaW5nKTtcblxuICBcdFx0cHJldmlvdXNJdGVtID0gdGhpcy5wYXJlbnRGcmFnbWVudC5pdGVtc1t0aGlzLmluZGV4IC0gMV07XG5cbiAgXHRcdGlmICghcHJldmlvdXNJdGVtIHx8IHByZXZpb3VzSXRlbS50eXBlICE9PSBURVhUKSB7XG4gIFx0XHRcdHJldHVybiBzdHJpbmc7XG4gIFx0XHR9XG5cbiAgXHRcdGxhc3RMaW5lID0gcHJldmlvdXNJdGVtLnRleHQuc3BsaXQoXCJcXG5cIikucG9wKCk7XG5cbiAgXHRcdGlmIChtYXRjaCA9IC9eXFxzKyQvLmV4ZWMobGFzdExpbmUpKSB7XG4gIFx0XHRcdHJldHVybiBhcHBseUluZGVudChzdHJpbmcsIG1hdGNoWzBdKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHN0cmluZztcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMuaXNOYW1lZCkge1xuICBcdFx0XHQvLyBkeW5hbWljIHBhcnRpYWwgLSBuZWVkIHRvIHVuYmluZCBzZWxmXG4gIFx0XHRcdHNoYXJlZF91bmJpbmQuY2FsbCh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoc2hvdWxkRGVzdHJveSk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB0YXJnZXQsIGFuY2hvcjtcblxuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyKSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyLnVucmVuZGVyKHRydWUpO1xuICBcdFx0XHR0aGlzLmZyYWdtZW50VG9VbnJlbmRlciA9IG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLmZyYWdtZW50VG9SZW5kZXIpIHtcbiAgXHRcdFx0dGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKHRoaXMuZnJhZ21lbnRUb1JlbmRlci5yZW5kZXIoKSk7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnRUb1JlbmRlciA9IG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdHRhcmdldCA9IHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpO1xuICBcdFx0XHRhbmNob3IgPSB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLmRvY0ZyYWcsIGFuY2hvcik7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBfUGFydGlhbCA9IFBhcnRpYWw7XG5cbiAgLy8gZmluZHMgdGhlIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBpbiB0aGUgcmVnaXN0cnkgb3IgdmlldyBoaWVyYXJjaHkgcmVnaXN0cmllc1xuXG4gIHZhciBDb21wb25lbnRfZ2V0Q29tcG9uZW50ID0gZ2V0Q29tcG9uZW50O1xuICBmdW5jdGlvbiBnZXRDb21wb25lbnQocmFjdGl2ZSwgbmFtZSkge1xuXG4gIFx0dmFyIENvbXBvbmVudCxcbiAgXHQgICAgaW5zdGFuY2UgPSBmaW5kSW5zdGFuY2UoXCJjb21wb25lbnRzXCIsIHJhY3RpdmUsIG5hbWUpO1xuXG4gIFx0aWYgKGluc3RhbmNlKSB7XG4gIFx0XHRDb21wb25lbnQgPSBpbnN0YW5jZS5jb21wb25lbnRzW25hbWVdO1xuXG4gIFx0XHQvLyBiZXN0IHRlc3Qgd2UgaGF2ZSBmb3Igbm90IFJhY3RpdmUuZXh0ZW5kXG4gIFx0XHRpZiAoIUNvbXBvbmVudC5fUGFyZW50KSB7XG4gIFx0XHRcdC8vIGZ1bmN0aW9uIG9wdGlvbiwgZXhlY3V0ZSBhbmQgc3RvcmUgZm9yIHJlc2V0XG4gIFx0XHRcdHZhciBmbiA9IENvbXBvbmVudC5iaW5kKGluc3RhbmNlKTtcbiAgXHRcdFx0Zm4uaXNPd25lciA9IGluc3RhbmNlLmNvbXBvbmVudHMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIFx0XHRcdENvbXBvbmVudCA9IGZuKCk7XG5cbiAgXHRcdFx0aWYgKCFDb21wb25lbnQpIHtcbiAgXHRcdFx0XHR3YXJuSWZEZWJ1Zyhub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm4sIG5hbWUsIFwiY29tcG9uZW50XCIsIFwiY29tcG9uZW50XCIsIHsgcmFjdGl2ZTogcmFjdGl2ZSB9KTtcblxuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICh0eXBlb2YgQ29tcG9uZW50ID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdFx0Ly8gYWxsb3cgc3RyaW5nIGxvb2t1cFxuICBcdFx0XHRcdENvbXBvbmVudCA9IGdldENvbXBvbmVudChyYWN0aXZlLCBDb21wb25lbnQpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Q29tcG9uZW50Ll9mbiA9IGZuO1xuICBcdFx0XHRpbnN0YW5jZS5jb21wb25lbnRzW25hbWVdID0gQ29tcG9uZW50O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBDb21wb25lbnQ7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9kZXRhY2ggPSBDb21wb25lbnQkZGV0YWNoO1xuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9kZXRhY2hfX2RldGFjaEhvb2sgPSBuZXcgaG9va3NfSG9vayhcImRldGFjaFwiKTtcbiAgZnVuY3Rpb24gQ29tcG9uZW50JGRldGFjaCgpIHtcbiAgXHR2YXIgZGV0YWNoZWQgPSB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmRldGFjaCgpO1xuICBcdENvbXBvbmVudF9wcm90b3R5cGVfZGV0YWNoX19kZXRhY2hIb29rLmZpcmUodGhpcy5pbnN0YW5jZSk7XG4gIFx0cmV0dXJuIGRldGFjaGVkO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZmluZCA9IENvbXBvbmVudCRmaW5kO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kKHNlbGVjdG9yKSB7XG4gIFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZChzZWxlY3Rvcik7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kQWxsID0gQ29tcG9uZW50JGZpbmRBbGw7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JGZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMgPSBDb21wb25lbnQkZmluZEFsbENvbXBvbmVudHM7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JGZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdHF1ZXJ5Ll90ZXN0KHRoaXMsIHRydWUpO1xuXG4gIFx0aWYgKHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kQ29tcG9uZW50ID0gQ29tcG9uZW50JGZpbmRDb21wb25lbnQ7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JGZpbmRDb21wb25lbnQoc2VsZWN0b3IpIHtcbiAgXHRpZiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSB0aGlzLm5hbWUpIHtcbiAgXHRcdHJldHVybiB0aGlzLmluc3RhbmNlO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmluc3RhbmNlLmZyYWdtZW50KSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQ29tcG9uZW50KHNlbGVjdG9yKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSA9IENvbXBvbmVudCRmaW5kTmV4dE5vZGU7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JGZpbmROZXh0Tm9kZSgpIHtcbiAgXHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9maXJzdE5vZGUgPSBDb21wb25lbnQkZmlyc3ROb2RlO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRmaXJzdE5vZGUoKSB7XG4gIFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHByb2Nlc3NXcmFwcGVyID0gZnVuY3Rpb24gKHdyYXBwZXIsIGFycmF5LCBtZXRob2ROYW1lLCBuZXdJbmRpY2VzKSB7XG4gIFx0dmFyIHJvb3QgPSB3cmFwcGVyLnJvb3Q7XG4gIFx0dmFyIGtleXBhdGggPSB3cmFwcGVyLmtleXBhdGg7XG5cbiAgXHRpZiAoISFuZXdJbmRpY2VzKSB7XG4gIFx0XHRyb290LnZpZXdtb2RlbC5zbWFydFVwZGF0ZShrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcyk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIElmIHRoaXMgaXMgYSBzb3J0IG9yIHJldmVyc2UsIHdlIGp1c3QgZG8gcm9vdC5zZXQoKS4uLlxuICBcdFx0Ly8gVE9ETyB1c2UgbWVyZ2UgbG9naWM/XG4gIFx0XHRyb290LnZpZXdtb2RlbC5tYXJrKGtleXBhdGgpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgcGF0Y2hlZEFycmF5UHJvdG8gPSBbXSxcbiAgICAgIG11dGF0b3JNZXRob2RzID0gW1wicG9wXCIsIFwicHVzaFwiLCBcInJldmVyc2VcIiwgXCJzaGlmdFwiLCBcInNvcnRcIiwgXCJzcGxpY2VcIiwgXCJ1bnNoaWZ0XCJdLFxuICAgICAgdGVzdE9iaixcbiAgICAgIHBhdGNoQXJyYXlNZXRob2RzLFxuICAgICAgdW5wYXRjaEFycmF5TWV0aG9kcztcblxuICBtdXRhdG9yTWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gIFx0dmFyIG1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRcdGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBuZXdJbmRpY2VzLCByZXN1bHQsIHdyYXBwZXIsIGk7XG5cbiAgXHRcdG5ld0luZGljZXMgPSBzaGFyZWRfZ2V0TmV3SW5kaWNlcyh0aGlzLCBtZXRob2ROYW1lLCBhcmdzKTtcblxuICBcdFx0Ly8gYXBwbHkgdGhlIHVuZGVybHlpbmcgbWV0aG9kXG4gIFx0XHRyZXN1bHQgPSBBcnJheS5wcm90b3R5cGVbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBcdFx0Ly8gdHJpZ2dlciBjaGFuZ2VzXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCgpO1xuXG4gIFx0XHR0aGlzLl9yYWN0aXZlLnNldHRpbmcgPSB0cnVlO1xuICBcdFx0aSA9IHRoaXMuX3JhY3RpdmUud3JhcHBlcnMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHR3cmFwcGVyID0gdGhpcy5fcmFjdGl2ZS53cmFwcGVyc1tpXTtcblxuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRSYWN0aXZlKHdyYXBwZXIucm9vdCk7XG4gIFx0XHRcdHByb2Nlc3NXcmFwcGVyKHdyYXBwZXIsIHRoaXMsIG1ldGhvZE5hbWUsIG5ld0luZGljZXMpO1xuICBcdFx0fVxuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdFx0dGhpcy5fcmFjdGl2ZS5zZXR0aW5nID0gZmFsc2U7XG4gIFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdH07XG5cbiAgXHRkZWZpbmVQcm9wZXJ0eShwYXRjaGVkQXJyYXlQcm90bywgbWV0aG9kTmFtZSwge1xuICBcdFx0dmFsdWU6IG1ldGhvZFxuICBcdH0pO1xuICB9KTtcblxuICAvLyBjYW4gd2UgdXNlIHByb3RvdHlwZSBjaGFpbiBpbmplY3Rpb24/XG4gIC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2hvdy1lY21hc2NyaXB0LTUtc3RpbGwtZG9lcy1ub3QtYWxsb3ctdG8tc3ViY2xhc3MtYW4tYXJyYXkvI3dyYXBwZXJzX3Byb3RvdHlwZV9jaGFpbl9pbmplY3Rpb25cbiAgdGVzdE9iaiA9IHt9O1xuXG4gIGlmICh0ZXN0T2JqLl9fcHJvdG9fXykge1xuICBcdC8vIHllcywgd2UgY2FuXG4gIFx0cGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgXHRcdGFycmF5Ll9fcHJvdG9fXyA9IHBhdGNoZWRBcnJheVByb3RvO1xuICBcdH07XG5cbiAgXHR1bnBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIFx0XHRhcnJheS5fX3Byb3RvX18gPSBBcnJheS5wcm90b3R5cGU7XG4gIFx0fTtcbiAgfSBlbHNlIHtcbiAgXHQvLyBubywgd2UgY2FuJ3RcbiAgXHRwYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uIChhcnJheSkge1xuICBcdFx0dmFyIGksIG1ldGhvZE5hbWU7XG5cbiAgXHRcdGkgPSBtdXRhdG9yTWV0aG9kcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdG1ldGhvZE5hbWUgPSBtdXRhdG9yTWV0aG9kc1tpXTtcbiAgXHRcdFx0ZGVmaW5lUHJvcGVydHkoYXJyYXksIG1ldGhvZE5hbWUsIHtcbiAgXHRcdFx0XHR2YWx1ZTogcGF0Y2hlZEFycmF5UHJvdG9bbWV0aG9kTmFtZV0sXG4gIFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHR1bnBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIFx0XHR2YXIgaTtcblxuICBcdFx0aSA9IG11dGF0b3JNZXRob2RzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0ZGVsZXRlIGFycmF5W211dGF0b3JNZXRob2RzW2ldXTtcbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgcGF0Y2hBcnJheU1ldGhvZHMudW5wYXRjaCA9IHVucGF0Y2hBcnJheU1ldGhvZHM7XG4gIHZhciBwYXRjaCA9IHBhdGNoQXJyYXlNZXRob2RzO1xuXG4gIHZhciBhcnJheUFkYXB0b3IsXG5cbiAgLy8gaGVscGVyc1xuICBBcnJheVdyYXBwZXIsIGFycmF5X2luZGV4X19lcnJvck1lc3NhZ2U7XG5cbiAgYXJyYXlBZGFwdG9yID0ge1xuICBcdGZpbHRlcjogZnVuY3Rpb24gKG9iamVjdCkge1xuICBcdFx0Ly8gd3JhcCB0aGUgYXJyYXkgaWYgYSkgYikgaXQncyBhbiBhcnJheSwgYW5kIGIpIGVpdGhlciBpdCBoYXNuJ3QgYmVlbiB3cmFwcGVkIGFscmVhZHksXG4gIFx0XHQvLyBvciB0aGUgYXJyYXkgZGlkbid0IHRyaWdnZXIgdGhlIGdldCgpIGl0c2VsZlxuICBcdFx0cmV0dXJuIGlzQXJyYXkob2JqZWN0KSAmJiAoIW9iamVjdC5fcmFjdGl2ZSB8fCAhb2JqZWN0Ll9yYWN0aXZlLnNldHRpbmcpO1xuICBcdH0sXG4gIFx0d3JhcDogZnVuY3Rpb24gKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKSB7XG4gIFx0XHRyZXR1cm4gbmV3IEFycmF5V3JhcHBlcihyYWN0aXZlLCBhcnJheSwga2V5cGF0aCk7XG4gIFx0fVxuICB9O1xuXG4gIEFycmF5V3JhcHBlciA9IGZ1bmN0aW9uIChyYWN0aXZlLCBhcnJheSwga2V5cGF0aCkge1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG4gIFx0dGhpcy52YWx1ZSA9IGFycmF5O1xuICBcdHRoaXMua2V5cGF0aCA9IGdldEtleXBhdGgoa2V5cGF0aCk7XG5cbiAgXHQvLyBpZiB0aGlzIGFycmF5IGhhc24ndCBhbHJlYWR5IGJlZW4gcmFjdGlmaWVkLCByYWN0aWZ5IGl0XG4gIFx0aWYgKCFhcnJheS5fcmFjdGl2ZSkge1xuXG4gIFx0XHQvLyBkZWZpbmUgYSBub24tZW51bWVyYWJsZSBfcmFjdGl2ZSBwcm9wZXJ0eSB0byBzdG9yZSB0aGUgd3JhcHBlcnNcbiAgXHRcdGRlZmluZVByb3BlcnR5KGFycmF5LCBcIl9yYWN0aXZlXCIsIHtcbiAgXHRcdFx0dmFsdWU6IHtcbiAgXHRcdFx0XHR3cmFwcGVyczogW10sXG4gIFx0XHRcdFx0aW5zdGFuY2VzOiBbXSxcbiAgXHRcdFx0XHRzZXR0aW5nOiBmYWxzZVxuICBcdFx0XHR9LFxuICBcdFx0XHRjb25maWd1cmFibGU6IHRydWVcbiAgXHRcdH0pO1xuXG4gIFx0XHRwYXRjaChhcnJheSk7XG4gIFx0fVxuXG4gIFx0Ly8gc3RvcmUgdGhlIHJhY3RpdmUgaW5zdGFuY2UsIHNvIHdlIGNhbiBoYW5kbGUgdHJhbnNpdGlvbnMgbGF0ZXJcbiAgXHRpZiAoIWFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1tyYWN0aXZlLl9ndWlkXSkge1xuICBcdFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzW3JhY3RpdmUuX2d1aWRdID0gMDtcbiAgXHRcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlcy5wdXNoKHJhY3RpdmUpO1xuICBcdH1cblxuICBcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1tyYWN0aXZlLl9ndWlkXSArPSAxO1xuICBcdGFycmF5Ll9yYWN0aXZlLndyYXBwZXJzLnB1c2godGhpcyk7XG4gIH07XG5cbiAgQXJyYXlXcmFwcGVyLnByb3RvdHlwZSA9IHtcbiAgXHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLnZhbHVlO1xuICBcdH0sXG4gIFx0dGVhcmRvd246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBhcnJheSwgc3RvcmFnZSwgd3JhcHBlcnMsIGluc3RhbmNlcywgaW5kZXg7XG5cbiAgXHRcdGFycmF5ID0gdGhpcy52YWx1ZTtcbiAgXHRcdHN0b3JhZ2UgPSBhcnJheS5fcmFjdGl2ZTtcbiAgXHRcdHdyYXBwZXJzID0gc3RvcmFnZS53cmFwcGVycztcbiAgXHRcdGluc3RhbmNlcyA9IHN0b3JhZ2UuaW5zdGFuY2VzO1xuXG4gIFx0XHQvLyBpZiB0ZWFyZG93bigpIHdhcyBpbnZva2VkIGJlY2F1c2Ugd2UncmUgY2xlYXJpbmcgdGhlIGNhY2hlIGFzIGEgcmVzdWx0IG9mXG4gIFx0XHQvLyBhIGNoYW5nZSB0aGF0IHRoZSBhcnJheSBpdHNlbGYgdHJpZ2dlcmVkLCB3ZSBjYW4gc2F2ZSBvdXJzZWx2ZXMgdGhlIHRlYXJkb3duXG4gIFx0XHQvLyBhbmQgaW1tZWRpYXRlIHNldHVwXG4gIFx0XHRpZiAoc3RvcmFnZS5zZXR0aW5nKSB7XG4gIFx0XHRcdHJldHVybiBmYWxzZTsgLy8gc28gdGhhdCB3ZSBkb24ndCByZW1vdmUgaXQgZnJvbSB0aGlzLnJvb3Qudmlld21vZGVsLndyYXBwZWRcbiAgXHRcdH1cblxuICBcdFx0aW5kZXggPSB3cmFwcGVycy5pbmRleE9mKHRoaXMpO1xuICBcdFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYXJyYXlfaW5kZXhfX2Vycm9yTWVzc2FnZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHdyYXBwZXJzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgXHRcdC8vIGlmIG5vdGhpbmcgZWxzZSBkZXBlbmRzIG9uIHRoaXMgYXJyYXksIHdlIGNhbiByZXZlcnQgaXQgdG8gaXRzXG4gIFx0XHQvLyBuYXR1cmFsIHN0YXRlXG4gIFx0XHRpZiAoIXdyYXBwZXJzLmxlbmd0aCkge1xuICBcdFx0XHRkZWxldGUgYXJyYXkuX3JhY3RpdmU7XG4gIFx0XHRcdHBhdGNoLnVucGF0Y2godGhpcy52YWx1ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHQvLyByZW1vdmUgcmFjdGl2ZSBpbnN0YW5jZSBpZiBwb3NzaWJsZVxuICBcdFx0XHRpbnN0YW5jZXNbdGhpcy5yb290Ll9ndWlkXSAtPSAxO1xuICBcdFx0XHRpZiAoIWluc3RhbmNlc1t0aGlzLnJvb3QuX2d1aWRdKSB7XG4gIFx0XHRcdFx0aW5kZXggPSBpbnN0YW5jZXMuaW5kZXhPZih0aGlzLnJvb3QpO1xuXG4gIFx0XHRcdFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGFycmF5X2luZGV4X19lcnJvck1lc3NhZ2UpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIGFycmF5X2luZGV4X19lcnJvck1lc3NhZ2UgPSBcIlNvbWV0aGluZyB3ZW50IHdyb25nIGluIGEgcmF0aGVyIGludGVyZXN0aW5nIHdheVwiO1xuICB2YXIgYXJyYXlfaW5kZXggPSBhcnJheUFkYXB0b3I7XG5cbiAgdmFyIG51bWVyaWMgPSAvXlxccypbMC05XStcXHMqJC87XG5cbiAgdmFyIGNyZWF0ZUJyYW5jaCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRyZXR1cm4gbnVtZXJpYy50ZXN0KGtleSkgPyBbXSA6IHt9O1xuICB9O1xuXG4gIHZhciBtYWdpY0FkYXB0b3IsIE1hZ2ljV3JhcHBlcjtcblxuICB0cnkge1xuICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJ0ZXN0XCIsIHsgdmFsdWU6IDAgfSk7XG5cbiAgXHRtYWdpY0FkYXB0b3IgPSB7XG4gIFx0XHRmaWx0ZXI6IGZ1bmN0aW9uIChvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUpIHtcbiAgXHRcdFx0dmFyIHBhcmVudFdyYXBwZXIsIHBhcmVudFZhbHVlO1xuXG4gIFx0XHRcdGlmICgha2V5cGF0aCkge1xuICBcdFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGtleXBhdGggPSBnZXRLZXlwYXRoKGtleXBhdGgpO1xuXG4gIFx0XHRcdC8vIElmIHRoZSBwYXJlbnQgdmFsdWUgaXMgYSB3cmFwcGVyLCBvdGhlciB0aGFuIGEgbWFnaWMgd3JhcHBlcixcbiAgXHRcdFx0Ly8gd2Ugc2hvdWxkbid0IHdyYXAgdGhpcyBwcm9wZXJ0eVxuICBcdFx0XHRpZiAoKHBhcmVudFdyYXBwZXIgPSByYWN0aXZlLnZpZXdtb2RlbC53cmFwcGVkW2tleXBhdGgucGFyZW50LnN0cl0pICYmICFwYXJlbnRXcmFwcGVyLm1hZ2ljKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cGFyZW50VmFsdWUgPSByYWN0aXZlLnZpZXdtb2RlbC5nZXQoa2V5cGF0aC5wYXJlbnQpO1xuXG4gIFx0XHRcdC8vIGlmIHBhcmVudFZhbHVlIGlzIGFuIGFycmF5IHRoYXQgZG9lc24ndCBpbmNsdWRlIHRoaXMgbWVtYmVyLFxuICBcdFx0XHQvLyB3ZSBzaG91bGQgcmV0dXJuIGZhbHNlIG90aGVyd2lzZSBsZW5ndGhzIHdpbGwgZ2V0IG1lc3NlZCB1cFxuICBcdFx0XHRpZiAoaXNBcnJheShwYXJlbnRWYWx1ZSkgJiYgL15bMC05XSskLy50ZXN0KGtleXBhdGgubGFzdEtleSkpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gcGFyZW50VmFsdWUgJiYgKHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcGFyZW50VmFsdWUgPT09IFwiZnVuY3Rpb25cIik7XG4gIFx0XHR9LFxuICBcdFx0d3JhcDogZnVuY3Rpb24gKHJhY3RpdmUsIHByb3BlcnR5LCBrZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBuZXcgTWFnaWNXcmFwcGVyKHJhY3RpdmUsIHByb3BlcnR5LCBrZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0TWFnaWNXcmFwcGVyID0gZnVuY3Rpb24gKHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoKSB7XG4gIFx0XHR2YXIgb2JqS2V5cGF0aCwgdGVtcGxhdGUsIHNpYmxpbmdzO1xuXG4gIFx0XHRrZXlwYXRoID0gZ2V0S2V5cGF0aChrZXlwYXRoKTtcblxuICBcdFx0dGhpcy5tYWdpYyA9IHRydWU7XG5cbiAgXHRcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG4gIFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0XHR0aGlzLnByb3AgPSBrZXlwYXRoLmxhc3RLZXk7XG5cbiAgXHRcdG9iaktleXBhdGggPSBrZXlwYXRoLnBhcmVudDtcbiAgXHRcdHRoaXMub2JqID0gb2JqS2V5cGF0aC5pc1Jvb3QgPyByYWN0aXZlLnZpZXdtb2RlbC5kYXRhIDogcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KG9iaktleXBhdGgpO1xuXG4gIFx0XHR0ZW1wbGF0ZSA9IHRoaXMub3JpZ2luYWxEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLm9iaiwgdGhpcy5wcm9wKTtcblxuICBcdFx0Ly8gSGFzIHRoaXMgcHJvcGVydHkgYWxyZWFkeSBiZWVuIHdyYXBwZWQ/XG4gIFx0XHRpZiAodGVtcGxhdGUgJiYgdGVtcGxhdGUuc2V0ICYmIChzaWJsaW5ncyA9IHRlbXBsYXRlLnNldC5fcmFjdGl2ZVdyYXBwZXJzKSkge1xuXG4gIFx0XHRcdC8vIFllcy4gUmVnaXN0ZXIgdGhpcyB3cmFwcGVyIHRvIHRoaXMgcHJvcGVydHksIGlmIGl0IGhhc24ndCBiZWVuIGFscmVhZHlcbiAgXHRcdFx0aWYgKHNpYmxpbmdzLmluZGV4T2YodGhpcykgPT09IC0xKSB7XG4gIFx0XHRcdFx0c2libGluZ3MucHVzaCh0aGlzKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybjsgLy8gYWxyZWFkeSB3cmFwcGVkXG4gIFx0XHR9XG5cbiAgXHRcdC8vIE5vLCBpdCBoYXNuJ3QgYmVlbiB3cmFwcGVkXG4gIFx0XHRjcmVhdGVBY2Nlc3NvcnModGhpcywgdmFsdWUsIHRlbXBsYXRlKTtcbiAgXHR9O1xuXG4gIFx0TWFnaWNXcmFwcGVyLnByb3RvdHlwZSA9IHtcbiAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHRcdH0sXG4gIFx0XHRyZXNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRcdGlmICh0aGlzLnVwZGF0aW5nKSB7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG4gIFx0XHRcdHRoaXMub2JqW3RoaXMucHJvcF0gPSB2YWx1ZTsgLy8gdHJpZ2dlciBzZXQoKSBhY2Nlc3NvclxuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRSYWN0aXZlKHRoaXMucmFjdGl2ZSk7XG4gIFx0XHRcdHRoaXMucmFjdGl2ZS52aWV3bW9kZWwubWFyayh0aGlzLmtleXBhdGgsIHsga2VlcEV4aXN0aW5nV3JhcHBlcjogdHJ1ZSB9KTtcbiAgXHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH0sXG4gIFx0XHRzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIFx0XHRcdGlmICh0aGlzLnVwZGF0aW5nKSB7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCF0aGlzLm9ialt0aGlzLnByb3BdKSB7XG4gIFx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG4gIFx0XHRcdFx0dGhpcy5vYmpbdGhpcy5wcm9wXSA9IGNyZWF0ZUJyYW5jaChrZXkpO1xuICBcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMub2JqW3RoaXMucHJvcF1ba2V5XSA9IHZhbHVlO1xuICBcdFx0fSxcbiAgXHRcdHRlYXJkb3duOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHZhciB0ZW1wbGF0ZSwgc2V0LCB2YWx1ZSwgd3JhcHBlcnMsIGluZGV4O1xuXG4gIFx0XHRcdC8vIElmIHRoaXMgbWV0aG9kIHdhcyBjYWxsZWQgYmVjYXVzZSB0aGUgY2FjaGUgd2FzIGJlaW5nIGNsZWFyZWQgYXMgYVxuICBcdFx0XHQvLyByZXN1bHQgb2YgYSBzZXQoKS91cGRhdGUoKSBjYWxsIG1hZGUgYnkgdGhpcyB3cmFwcGVyLCB3ZSByZXR1cm4gZmFsc2VcbiAgXHRcdFx0Ly8gc28gdGhhdCBpdCBkb2Vzbid0IGdldCB0b3JuIGRvd25cbiAgXHRcdFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0ZW1wbGF0ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcy5vYmosIHRoaXMucHJvcCk7XG4gIFx0XHRcdHNldCA9IHRlbXBsYXRlICYmIHRlbXBsYXRlLnNldDtcblxuICBcdFx0XHRpZiAoIXNldCkge1xuICBcdFx0XHRcdC8vIG1vc3QgbGlrZWx5LCB0aGlzIHdhcyBhbiBhcnJheSBtZW1iZXIgdGhhdCB3YXMgc3BsaWNlZCBvdXRcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHR3cmFwcGVycyA9IHNldC5fcmFjdGl2ZVdyYXBwZXJzO1xuXG4gIFx0XHRcdGluZGV4ID0gd3JhcHBlcnMuaW5kZXhPZih0aGlzKTtcbiAgXHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0XHRcdHdyYXBwZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBMYXN0IG9uZSBvdXQsIHR1cm4gb2ZmIHRoZSBsaWdodHNcbiAgXHRcdFx0aWYgKCF3cmFwcGVycy5sZW5ndGgpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IHRoaXMub2JqW3RoaXMucHJvcF07XG5cbiAgXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5vYmosIHRoaXMucHJvcCwgdGhpcy5vcmlnaW5hbERlc2NyaXB0b3IgfHwge1xuICBcdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG4gIFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuICBcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG4gIFx0XHRcdFx0fSk7XG5cbiAgXHRcdFx0XHR0aGlzLm9ialt0aGlzLnByb3BdID0gdmFsdWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgXHRtYWdpY0FkYXB0b3IgPSBmYWxzZTsgLy8gbm8gbWFnaWMgaW4gdGhpcyBicm93c2VyXG4gIH1cblxuICB2YXIgYWRhcHRvcnNfbWFnaWMgPSBtYWdpY0FkYXB0b3I7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQWNjZXNzb3JzKG9yaWdpbmFsV3JhcHBlciwgdmFsdWUsIHRlbXBsYXRlKSB7XG5cbiAgXHR2YXIgb2JqZWN0LCBwcm9wZXJ0eSwgb2xkR2V0LCBvbGRTZXQsIGdldCwgc2V0O1xuXG4gIFx0b2JqZWN0ID0gb3JpZ2luYWxXcmFwcGVyLm9iajtcbiAgXHRwcm9wZXJ0eSA9IG9yaWdpbmFsV3JhcHBlci5wcm9wO1xuXG4gIFx0Ly8gSXMgdGhpcyB0ZW1wbGF0ZSBjb25maWd1cmFibGU/XG4gIFx0aWYgKHRlbXBsYXRlICYmICF0ZW1wbGF0ZS5jb25maWd1cmFibGUpIHtcbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSAtIGFycmF5IGxlbmd0aFxuICBcdFx0aWYgKHByb3BlcnR5ID09PSBcImxlbmd0aFwiKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBtYWdpYyBtb2RlIHdpdGggcHJvcGVydHkgXFxcIlwiICsgcHJvcGVydHkgKyBcIlxcXCIgLSBvYmplY3QgaXMgbm90IGNvbmZpZ3VyYWJsZVwiKTtcbiAgXHR9XG5cbiAgXHQvLyBUaW1lIHRvIHdyYXAgdGhpcyBwcm9wZXJ0eVxuICBcdGlmICh0ZW1wbGF0ZSkge1xuICBcdFx0b2xkR2V0ID0gdGVtcGxhdGUuZ2V0O1xuICBcdFx0b2xkU2V0ID0gdGVtcGxhdGUuc2V0O1xuICBcdH1cblxuICBcdGdldCA9IG9sZEdldCB8fCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0fTtcblxuICBcdHNldCA9IGZ1bmN0aW9uICh2KSB7XG4gIFx0XHRpZiAob2xkU2V0KSB7XG4gIFx0XHRcdG9sZFNldCh2KTtcbiAgXHRcdH1cblxuICBcdFx0dmFsdWUgPSBvbGRHZXQgPyBvbGRHZXQoKSA6IHY7XG4gIFx0XHRzZXQuX3JhY3RpdmVXcmFwcGVycy5mb3JFYWNoKHVwZGF0ZVdyYXBwZXIpO1xuICBcdH07XG5cbiAgXHRmdW5jdGlvbiB1cGRhdGVXcmFwcGVyKHdyYXBwZXIpIHtcbiAgXHRcdHZhciBrZXlwYXRoLCByYWN0aXZlO1xuXG4gIFx0XHR3cmFwcGVyLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdGlmICh3cmFwcGVyLnVwZGF0aW5nKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0cmFjdGl2ZSA9IHdyYXBwZXIucmFjdGl2ZTtcbiAgXHRcdGtleXBhdGggPSB3cmFwcGVyLmtleXBhdGg7XG5cbiAgXHRcdHdyYXBwZXIudXBkYXRpbmcgPSB0cnVlO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQocmFjdGl2ZSk7XG5cbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLm1hcmsoa2V5cGF0aCk7XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdFx0d3JhcHBlci51cGRhdGluZyA9IGZhbHNlO1xuICBcdH1cblxuICBcdC8vIENyZWF0ZSBhbiBhcnJheSBvZiB3cmFwcGVycywgaW4gY2FzZSBvdGhlciBrZXlwYXRocy9yYWN0aXZlcyBkZXBlbmQgb24gdGhpcyBwcm9wZXJ0eS5cbiAgXHQvLyBIYW5kaWx5LCB3ZSBjYW4gc3RvcmUgdGhlbSBhcyBhIHByb3BlcnR5IG9mIHRoZSBzZXQgZnVuY3Rpb24uIFlheSBKYXZhU2NyaXB0LlxuICBcdHNldC5fcmFjdGl2ZVdyYXBwZXJzID0gW29yaWdpbmFsV3JhcHBlcl07XG4gIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHsgZ2V0OiBnZXQsIHNldDogc2V0LCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH1cblxuICB2YXIgbWFnaWNBcnJheUFkYXB0b3IsIE1hZ2ljQXJyYXlXcmFwcGVyO1xuXG4gIGlmIChhZGFwdG9yc19tYWdpYykge1xuICBcdG1hZ2ljQXJyYXlBZGFwdG9yID0ge1xuICBcdFx0ZmlsdGVyOiBmdW5jdGlvbiAob2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlKSB7XG4gIFx0XHRcdHJldHVybiBhZGFwdG9yc19tYWdpYy5maWx0ZXIob2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlKSAmJiBhcnJheV9pbmRleC5maWx0ZXIob2JqZWN0KTtcbiAgXHRcdH0sXG5cbiAgXHRcdHdyYXA6IGZ1bmN0aW9uIChyYWN0aXZlLCBhcnJheSwga2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gbmV3IE1hZ2ljQXJyYXlXcmFwcGVyKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0TWFnaWNBcnJheVdyYXBwZXIgPSBmdW5jdGlvbiAocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpIHtcbiAgXHRcdHRoaXMudmFsdWUgPSBhcnJheTtcblxuICBcdFx0dGhpcy5tYWdpYyA9IHRydWU7XG5cbiAgXHRcdHRoaXMubWFnaWNXcmFwcGVyID0gYWRhcHRvcnNfbWFnaWMud3JhcChyYWN0aXZlLCBhcnJheSwga2V5cGF0aCk7XG4gIFx0XHR0aGlzLmFycmF5V3JhcHBlciA9IGFycmF5X2luZGV4LndyYXAocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpO1xuICBcdH07XG5cbiAgXHRNYWdpY0FycmF5V3JhcHBlci5wcm90b3R5cGUgPSB7XG4gIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0XHR9LFxuICBcdFx0dGVhcmRvd246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dGhpcy5hcnJheVdyYXBwZXIudGVhcmRvd24oKTtcbiAgXHRcdFx0dGhpcy5tYWdpY1dyYXBwZXIudGVhcmRvd24oKTtcbiAgXHRcdH0sXG4gIFx0XHRyZXNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLm1hZ2ljV3JhcHBlci5yZXNldCh2YWx1ZSk7XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBtYWdpY0FycmF5ID0gbWFnaWNBcnJheUFkYXB0b3I7XG5cbiAgdmFyIHByb3RvdHlwZV9hZGFwdCA9IFZpZXdtb2RlbCRhZGFwdDtcblxuICB2YXIgcHJlZml4ZXJzID0ge307XG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRhZGFwdChrZXlwYXRoLCB2YWx1ZSkge1xuICBcdHZhciBsZW4sIGksIGFkYXB0b3IsIHdyYXBwZWQ7XG5cbiAgXHRpZiAoIXRoaXMuYWRhcHRvcnMpIHJldHVybjtcblxuICBcdC8vIERvIHdlIGhhdmUgYW4gYWRhcHRvciBmb3IgdGhpcyB2YWx1ZT9cbiAgXHRsZW4gPSB0aGlzLmFkYXB0b3JzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdGFkYXB0b3IgPSB0aGlzLmFkYXB0b3JzW2ldO1xuXG4gIFx0XHRpZiAoYWRhcHRvci5maWx0ZXIodmFsdWUsIGtleXBhdGgsIHRoaXMucmFjdGl2ZSkpIHtcbiAgXHRcdFx0d3JhcHBlZCA9IHRoaXMud3JhcHBlZFtrZXlwYXRoXSA9IGFkYXB0b3Iud3JhcCh0aGlzLnJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoLCBnZXRQcmVmaXhlcihrZXlwYXRoKSk7XG4gIFx0XHRcdHdyYXBwZWQudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWZpeEtleXBhdGgob2JqLCBwcmVmaXgpIHtcbiAgXHR2YXIgcHJlZml4ZWQgPSB7fSxcbiAgXHQgICAga2V5O1xuXG4gIFx0aWYgKCFwcmVmaXgpIHtcbiAgXHRcdHJldHVybiBvYmo7XG4gIFx0fVxuXG4gIFx0cHJlZml4ICs9IFwiLlwiO1xuXG4gIFx0Zm9yIChrZXkgaW4gb2JqKSB7XG4gIFx0XHRpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0cHJlZml4ZWRbcHJlZml4ICsga2V5XSA9IG9ialtrZXldO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBwcmVmaXhlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByZWZpeGVyKHJvb3RLZXlwYXRoKSB7XG4gIFx0dmFyIHJvb3REb3Q7XG5cbiAgXHRpZiAoIXByZWZpeGVyc1tyb290S2V5cGF0aF0pIHtcbiAgXHRcdHJvb3REb3QgPSByb290S2V5cGF0aCA/IHJvb3RLZXlwYXRoICsgXCIuXCIgOiBcIlwiO1xuXG4gIFx0XHRwcmVmaXhlcnNbcm9vdEtleXBhdGhdID0gZnVuY3Rpb24gKHJlbGF0aXZlS2V5cGF0aCwgdmFsdWUpIHtcbiAgXHRcdFx0dmFyIG9iajtcblxuICBcdFx0XHRpZiAodHlwZW9mIHJlbGF0aXZlS2V5cGF0aCA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRcdG9iaiA9IHt9O1xuICBcdFx0XHRcdG9ialtyb290RG90ICsgcmVsYXRpdmVLZXlwYXRoXSA9IHZhbHVlO1xuICBcdFx0XHRcdHJldHVybiBvYmo7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAodHlwZW9mIHJlbGF0aXZlS2V5cGF0aCA9PT0gXCJvYmplY3RcIikge1xuICBcdFx0XHRcdC8vICdyZWxhdGl2ZUtleXBhdGgnIGlzIGluIGZhY3QgYSBoYXNoLCBub3QgYSBrZXlwYXRoXG4gIFx0XHRcdFx0cmV0dXJuIHJvb3REb3QgPyBwcmVmaXhLZXlwYXRoKHJlbGF0aXZlS2V5cGF0aCwgcm9vdEtleXBhdGgpIDogcmVsYXRpdmVLZXlwYXRoO1xuICBcdFx0XHR9XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBwcmVmaXhlcnNbcm9vdEtleXBhdGhdO1xuICB9XG5cbiAgLy8gVEVNUFxuXG4gIHZhciBoZWxwZXJzX2dldFVwc3RyZWFtQ2hhbmdlcyA9IGdldFVwc3RyZWFtQ2hhbmdlcztcbiAgZnVuY3Rpb24gZ2V0VXBzdHJlYW1DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgXHR2YXIgdXBzdHJlYW1DaGFuZ2VzID0gW3Jvb3RLZXlwYXRoXSxcbiAgXHQgICAgaSxcbiAgXHQgICAga2V5cGF0aDtcblxuICBcdGkgPSBjaGFuZ2VzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRrZXlwYXRoID0gY2hhbmdlc1tpXS5wYXJlbnQ7XG5cbiAgXHRcdHdoaWxlIChrZXlwYXRoICYmICFrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0XHRpZiAoY2hhbmdlcy5pbmRleE9mKGtleXBhdGgpID09PSAtMSkge1xuICBcdFx0XHRcdGFkZFRvQXJyYXkodXBzdHJlYW1DaGFuZ2VzLCBrZXlwYXRoKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRrZXlwYXRoID0ga2V5cGF0aC5wYXJlbnQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHVwc3RyZWFtQ2hhbmdlcztcbiAgfVxuXG4gIHZhciBhcHBseUNoYW5nZXNfbm90aWZ5UGF0dGVybk9ic2VydmVycyA9IG5vdGlmeVBhdHRlcm5PYnNlcnZlcnM7XG5cbiAgZnVuY3Rpb24gbm90aWZ5UGF0dGVybk9ic2VydmVycyh2aWV3bW9kZWwsIGtleXBhdGgsIG9ubHlEaXJlY3QpIHtcbiAgXHR2YXIgcG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzO1xuXG4gIFx0dXBkYXRlTWF0Y2hpbmdQYXR0ZXJuT2JzZXJ2ZXJzKHZpZXdtb2RlbCwga2V5cGF0aCk7XG5cbiAgXHRpZiAob25seURpcmVjdCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyA9IGtleXBhdGgud2lsZGNhcmRNYXRjaGVzKCk7XG4gIFx0cG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKHVwc3RyZWFtUGF0dGVybikge1xuICBcdFx0Y2FzY2FkZSh2aWV3bW9kZWwsIHVwc3RyZWFtUGF0dGVybiwga2V5cGF0aCk7XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBjYXNjYWRlKHZpZXdtb2RlbCwgdXBzdHJlYW1QYXR0ZXJuLCBrZXlwYXRoKSB7XG4gIFx0dmFyIGdyb3VwLCBtYXAsIGFjdHVhbENoaWxkS2V5cGF0aDtcblxuICBcdC8vIFRPRE8gc2hvdWxkIGJlIG9uZSBvciB0aGUgb3RoZXJcbiAgXHR1cHN0cmVhbVBhdHRlcm4gPSB1cHN0cmVhbVBhdHRlcm4uc3RyIHx8IHVwc3RyZWFtUGF0dGVybjtcblxuICBcdGdyb3VwID0gdmlld21vZGVsLmRlcHNNYXAucGF0dGVybk9ic2VydmVycztcbiAgXHRtYXAgPSBncm91cCAmJiBncm91cFt1cHN0cmVhbVBhdHRlcm5dO1xuXG4gIFx0aWYgKCFtYXApIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRtYXAuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRLZXlwYXRoKSB7XG4gIFx0XHRhY3R1YWxDaGlsZEtleXBhdGggPSBrZXlwYXRoLmpvaW4oY2hpbGRLZXlwYXRoLmxhc3RLZXkpOyAvLyAnZm9vLmJhci5iYXonXG5cbiAgXHRcdHVwZGF0ZU1hdGNoaW5nUGF0dGVybk9ic2VydmVycyh2aWV3bW9kZWwsIGFjdHVhbENoaWxkS2V5cGF0aCk7XG4gIFx0XHRjYXNjYWRlKHZpZXdtb2RlbCwgY2hpbGRLZXlwYXRoLCBhY3R1YWxDaGlsZEtleXBhdGgpO1xuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTWF0Y2hpbmdQYXR0ZXJuT2JzZXJ2ZXJzKHZpZXdtb2RlbCwga2V5cGF0aCkge1xuICBcdHZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gIFx0XHRpZiAob2JzZXJ2ZXIucmVnZXgudGVzdChrZXlwYXRoLnN0cikpIHtcbiAgXHRcdFx0b2JzZXJ2ZXIudXBkYXRlKGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH0pO1xuICB9XG5cbiAgdmFyIGFwcGx5Q2hhbmdlcyA9IFZpZXdtb2RlbCRhcHBseUNoYW5nZXM7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJGFwcGx5Q2hhbmdlcygpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHNlbGYgPSB0aGlzLFxuICBcdCAgICBjaGFuZ2VzLFxuICBcdCAgICB1cHN0cmVhbUNoYW5nZXMsXG4gIFx0ICAgIGhhc2ggPSB7fSxcbiAgXHQgICAgYmluZGluZ3M7XG5cbiAgXHRjaGFuZ2VzID0gdGhpcy5jaGFuZ2VzO1xuXG4gIFx0aWYgKCFjaGFuZ2VzLmxlbmd0aCkge1xuICBcdFx0Ly8gVE9ETyB3ZSBlbmQgdXAgaGVyZSBvbiBpbml0aWFsIHJlbmRlci4gUGVyaGFwcyB3ZSBzaG91bGRuJ3Q/XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gaW52YWxpZGF0ZUNvbXB1dGF0aW9uKGNvbXB1dGF0aW9uKSB7XG4gIFx0XHR2YXIga2V5ID0gY29tcHV0YXRpb24ua2V5O1xuXG4gIFx0XHRpZiAoY29tcHV0YXRpb24udmlld21vZGVsID09PSBzZWxmKSB7XG4gIFx0XHRcdHNlbGYuY2xlYXJDYWNoZShrZXkuc3RyKTtcbiAgXHRcdFx0Y29tcHV0YXRpb24uaW52YWxpZGF0ZSgpO1xuXG4gIFx0XHRcdGNoYW5nZXMucHVzaChrZXkpO1xuICBcdFx0XHRjYXNjYWRlKGtleSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjb21wdXRhdGlvbi52aWV3bW9kZWwubWFyayhrZXkpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGZ1bmN0aW9uIGNhc2NhZGUoa2V5cGF0aCkge1xuICBcdFx0dmFyIG1hcCwgY29tcHV0YXRpb25zO1xuXG4gIFx0XHRpZiAoc2VsZi5ub0Nhc2NhZGUuaGFzT3duUHJvcGVydHkoa2V5cGF0aC5zdHIpKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGNvbXB1dGF0aW9ucyA9IHNlbGYuZGVwcy5jb21wdXRlZFtrZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0Y29tcHV0YXRpb25zLmZvckVhY2goaW52YWxpZGF0ZUNvbXB1dGF0aW9uKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG1hcCA9IHNlbGYuZGVwc01hcC5jb21wdXRlZFtrZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0bWFwLmZvckVhY2goY2FzY2FkZSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Y2hhbmdlcy5zbGljZSgpLmZvckVhY2goY2FzY2FkZSk7XG5cbiAgXHR1cHN0cmVhbUNoYW5nZXMgPSBoZWxwZXJzX2dldFVwc3RyZWFtQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgXHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFyIGNvbXB1dGF0aW9ucztcblxuICBcdFx0Ly8gbWFrZSBzdXJlIHdlIGhhdmVuJ3QgYWxyZWFkeSBiZWVuIGRvd24gdGhpcyBwYXJ0aWN1bGFyIGtleXBhdGggaW4gdGhpcyB0dXJuXG4gIFx0XHRpZiAoY2hhbmdlcy5pbmRleE9mKGtleXBhdGgpID09PSAtMSAmJiAoY29tcHV0YXRpb25zID0gc2VsZi5kZXBzLmNvbXB1dGVkW2tleXBhdGguc3RyXSkpIHtcbiAgXHRcdFx0Y29tcHV0YXRpb25zLmZvckVhY2goaW52YWxpZGF0ZUNvbXB1dGF0aW9uKTtcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdHRoaXMuY2hhbmdlcyA9IFtdO1xuXG4gIFx0Ly8gUGF0dGVybiBvYnNlcnZlcnMgYXJlIGEgd2VpcmQgc3BlY2lhbCBjYXNlXG4gIFx0aWYgKHRoaXMucGF0dGVybk9ic2VydmVycy5sZW5ndGgpIHtcbiAgXHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBhcHBseUNoYW5nZXNfbm90aWZ5UGF0dGVybk9ic2VydmVycyhfdGhpcywga2V5cGF0aCwgdHJ1ZSk7XG4gIFx0XHR9KTtcbiAgXHRcdGNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gYXBwbHlDaGFuZ2VzX25vdGlmeVBhdHRlcm5PYnNlcnZlcnMoX3RoaXMsIGtleXBhdGgpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZGVwcy5vYnNlcnZlcnMpIHtcbiAgXHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBub3RpZnlVcHN0cmVhbURlcGVuZGFudHMoX3RoaXMsIG51bGwsIGtleXBhdGgsIFwib2JzZXJ2ZXJzXCIpO1xuICBcdFx0fSk7XG4gIFx0XHRub3RpZnlBbGxEZXBlbmRhbnRzKHRoaXMsIGNoYW5nZXMsIFwib2JzZXJ2ZXJzXCIpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmRlcHNbXCJkZWZhdWx0XCJdKSB7XG4gIFx0XHRiaW5kaW5ncyA9IFtdO1xuICBcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIG5vdGlmeVVwc3RyZWFtRGVwZW5kYW50cyhfdGhpcywgYmluZGluZ3MsIGtleXBhdGgsIFwiZGVmYXVsdFwiKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRpZiAoYmluZGluZ3MubGVuZ3RoKSB7XG4gIFx0XHRcdG5vdGlmeUJpbmRpbmdzKHRoaXMsIGJpbmRpbmdzLCBjaGFuZ2VzKTtcbiAgXHRcdH1cblxuICBcdFx0bm90aWZ5QWxsRGVwZW5kYW50cyh0aGlzLCBjaGFuZ2VzLCBcImRlZmF1bHRcIik7XG4gIFx0fVxuXG4gIFx0Ly8gUmV0dXJuIGEgaGFzaCBvZiBrZXlwYXRocyB0byB1cGRhdGVkIHZhbHVlc1xuICBcdGNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0aGFzaFtrZXlwYXRoLnN0cl0gPSBfdGhpcy5nZXQoa2V5cGF0aCk7XG4gIFx0fSk7XG5cbiAgXHR0aGlzLmltcGxpY2l0Q2hhbmdlcyA9IHt9O1xuICBcdHRoaXMubm9DYXNjYWRlID0ge307XG5cbiAgXHRyZXR1cm4gaGFzaDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeVVwc3RyZWFtRGVwZW5kYW50cyh2aWV3bW9kZWwsIGJpbmRpbmdzLCBrZXlwYXRoLCBncm91cE5hbWUpIHtcbiAgXHR2YXIgZGVwZW5kYW50cywgdmFsdWU7XG5cbiAgXHRpZiAoZGVwZW5kYW50cyA9IGZpbmREZXBlbmRhbnRzKHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXBOYW1lKSkge1xuICBcdFx0dmFsdWUgPSB2aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0XHRkZXBlbmRhbnRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgXHRcdFx0Ly8gZG9uJ3QgXCJzZXRcIiB0aGUgcGFyZW50IHZhbHVlLCByZWZpbmUgaXRcbiAgXHRcdFx0Ly8gaS5lLiBub3QgZGF0YSA9IHZhbHVlLCBidXQgZGF0YVtmb29dID0gZm9vVmFsdWVcbiAgXHRcdFx0aWYgKGJpbmRpbmdzICYmIGQucmVmaW5lVmFsdWUpIHtcbiAgXHRcdFx0XHRiaW5kaW5ncy5wdXNoKGQpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGQuc2V0VmFsdWUodmFsdWUpO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlCaW5kaW5ncyh2aWV3bW9kZWwsIGJpbmRpbmdzLCBjaGFuZ2VzKSB7XG5cbiAgXHRiaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gIFx0XHR2YXIgdXNlU2V0ID0gZmFsc2UsXG4gIFx0XHQgICAgaSA9IDAsXG4gIFx0XHQgICAgbGVuZ3RoID0gY2hhbmdlcy5sZW5ndGgsXG4gIFx0XHQgICAgcmVmaW5lbWVudHMgPSBbXTtcblxuICBcdFx0d2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgXHRcdFx0dmFyIGtleXBhdGggPSBjaGFuZ2VzW2ldO1xuXG4gIFx0XHRcdGlmIChrZXlwYXRoID09PSBiaW5kaW5nLmtleXBhdGgpIHtcbiAgXHRcdFx0XHR1c2VTZXQgPSB0cnVlO1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGtleXBhdGguc2xpY2UoMCwgYmluZGluZy5rZXlwYXRoLmxlbmd0aCkgPT09IGJpbmRpbmcua2V5cGF0aCkge1xuICBcdFx0XHRcdHJlZmluZW1lbnRzLnB1c2goa2V5cGF0aCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpKys7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh1c2VTZXQpIHtcbiAgXHRcdFx0YmluZGluZy5zZXRWYWx1ZSh2aWV3bW9kZWwuZ2V0KGJpbmRpbmcua2V5cGF0aCkpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAocmVmaW5lbWVudHMubGVuZ3RoKSB7XG4gIFx0XHRcdGJpbmRpbmcucmVmaW5lVmFsdWUocmVmaW5lbWVudHMpO1xuICBcdFx0fVxuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5QWxsRGVwZW5kYW50cyh2aWV3bW9kZWwsIGtleXBhdGhzLCBncm91cE5hbWUpIHtcbiAgXHR2YXIgcXVldWUgPSBbXTtcblxuICBcdGFkZEtleXBhdGhzKGtleXBhdGhzKTtcbiAgXHRxdWV1ZS5mb3JFYWNoKGRpc3BhdGNoKTtcblxuICBcdGZ1bmN0aW9uIGFkZEtleXBhdGhzKGtleXBhdGhzKSB7XG4gIFx0XHRrZXlwYXRocy5mb3JFYWNoKGFkZEtleXBhdGgpO1xuICBcdFx0a2V5cGF0aHMuZm9yRWFjaChjYXNjYWRlKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBhZGRLZXlwYXRoKGtleXBhdGgpIHtcbiAgXHRcdHZhciBkZXBzID0gZmluZERlcGVuZGFudHModmlld21vZGVsLCBrZXlwYXRoLCBncm91cE5hbWUpO1xuXG4gIFx0XHRpZiAoZGVwcykge1xuICBcdFx0XHRxdWV1ZS5wdXNoKHtcbiAgXHRcdFx0XHRrZXlwYXRoOiBrZXlwYXRoLFxuICBcdFx0XHRcdGRlcHM6IGRlcHNcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gY2FzY2FkZShrZXlwYXRoKSB7XG4gIFx0XHR2YXIgY2hpbGREZXBzO1xuXG4gIFx0XHRpZiAoY2hpbGREZXBzID0gdmlld21vZGVsLmRlcHNNYXBbZ3JvdXBOYW1lXVtrZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0YWRkS2V5cGF0aHMoY2hpbGREZXBzKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBkaXNwYXRjaChzZXQpIHtcbiAgXHRcdHZhciB2YWx1ZSA9IHZpZXdtb2RlbC5nZXQoc2V0LmtleXBhdGgpO1xuICBcdFx0c2V0LmRlcHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHRyZXR1cm4gZC5zZXRWYWx1ZSh2YWx1ZSk7XG4gIFx0XHR9KTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kRGVwZW5kYW50cyh2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSkge1xuICBcdHZhciBncm91cCA9IHZpZXdtb2RlbC5kZXBzW2dyb3VwTmFtZV07XG4gIFx0cmV0dXJuIGdyb3VwID8gZ3JvdXBba2V5cGF0aC5zdHJdIDogbnVsbDtcbiAgfVxuXG4gIHZhciBjYXB0dXJlID0gVmlld21vZGVsJGNhcHR1cmU7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJGNhcHR1cmUoKSB7XG4gIFx0dGhpcy5jYXB0dXJlR3JvdXBzLnB1c2goW10pO1xuICB9XG5cbiAgdmFyIGNsZWFyQ2FjaGUgPSBWaWV3bW9kZWwkY2xlYXJDYWNoZTtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkY2xlYXJDYWNoZShrZXlwYXRoLCBrZWVwRXhpc3RpbmdXcmFwcGVyKSB7XG4gIFx0dmFyIGNhY2hlTWFwLCB3cmFwcGVyO1xuXG4gIFx0aWYgKCFrZWVwRXhpc3RpbmdXcmFwcGVyKSB7XG4gIFx0XHQvLyBJcyB0aGVyZSBhIHdyYXBwZWQgcHJvcGVydHkgYXQgdGhpcyBrZXlwYXRoP1xuICBcdFx0aWYgKHdyYXBwZXIgPSB0aGlzLndyYXBwZWRba2V5cGF0aF0pIHtcbiAgXHRcdFx0Ly8gRGlkIHdlIHVud3JhcCBpdD9cbiAgXHRcdFx0aWYgKHdyYXBwZXIudGVhcmRvd24oKSAhPT0gZmFsc2UpIHtcbiAgXHRcdFx0XHQvLyBJcyB0aGlzIHJpZ2h0P1xuICBcdFx0XHRcdC8vIFdoYXQncyB0aGUgbWVhbmluZyBvZiByZXR1cm5pbmcgZmFsc2UgZnJvbSB0ZWFyZG93bj9cbiAgXHRcdFx0XHQvLyBDb3VsZCB0aGVyZSBiZSBhIEdDIHJhbWlmaWNhdGlvbiBpZiB0aGlzIGlzIGEgXCJyZWFsXCIgcmFjdGl2ZS50ZWFyZG93bigpP1xuICBcdFx0XHRcdHRoaXMud3JhcHBlZFtrZXlwYXRoXSA9IG51bGw7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR0aGlzLmNhY2hlW2tleXBhdGhdID0gdW5kZWZpbmVkO1xuXG4gIFx0aWYgKGNhY2hlTWFwID0gdGhpcy5jYWNoZU1hcFtrZXlwYXRoXSkge1xuICBcdFx0d2hpbGUgKGNhY2hlTWFwLmxlbmd0aCkge1xuICBcdFx0XHR0aGlzLmNsZWFyQ2FjaGUoY2FjaGVNYXAucG9wKCkpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBVbnJlc29sdmVkRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChjb21wdXRhdGlvbiwgcmVmKSB7XG4gIFx0dGhpcy5jb21wdXRhdGlvbiA9IGNvbXB1dGF0aW9uO1xuICBcdHRoaXMudmlld21vZGVsID0gY29tcHV0YXRpb24udmlld21vZGVsO1xuICBcdHRoaXMucmVmID0gcmVmO1xuXG4gIFx0Ly8gVE9ETyB0aGlzIHNlZW1zIGxpa2UgYSByZWQgZmxhZyFcbiAgXHR0aGlzLnJvb3QgPSB0aGlzLnZpZXdtb2RlbC5yYWN0aXZlO1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSB0aGlzLnJvb3QuY29tcG9uZW50ICYmIHRoaXMucm9vdC5jb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG4gIH07XG5cbiAgVW5yZXNvbHZlZERlcGVuZGVuY3kucHJvdG90eXBlID0ge1xuICBcdHJlc29sdmU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR0aGlzLmNvbXB1dGF0aW9uLnNvZnREZXBzLnB1c2goa2V5cGF0aCk7XG4gIFx0XHR0aGlzLmNvbXB1dGF0aW9uLnVucmVzb2x2ZWREZXBzW2tleXBhdGguc3RyXSA9IG51bGw7XG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5yZWdpc3RlcihrZXlwYXRoLCB0aGlzLmNvbXB1dGF0aW9uLCBcImNvbXB1dGVkXCIpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgQ29tcHV0YXRpb25fVW5yZXNvbHZlZERlcGVuZGVuY3kgPSBVbnJlc29sdmVkRGVwZW5kZW5jeTtcblxuICB2YXIgQ29tcHV0YXRpb24gPSBmdW5jdGlvbiAoa2V5LCBzaWduYXR1cmUpIHtcbiAgXHR0aGlzLmtleSA9IGtleTtcblxuICBcdHRoaXMuZ2V0dGVyID0gc2lnbmF0dXJlLmdldHRlcjtcbiAgXHR0aGlzLnNldHRlciA9IHNpZ25hdHVyZS5zZXR0ZXI7XG5cbiAgXHR0aGlzLmhhcmREZXBzID0gc2lnbmF0dXJlLmRlcHMgfHwgW107XG4gIFx0dGhpcy5zb2Z0RGVwcyA9IFtdO1xuICBcdHRoaXMudW5yZXNvbHZlZERlcHMgPSB7fTtcblxuICBcdHRoaXMuZGVwVmFsdWVzID0ge307XG5cbiAgXHR0aGlzLl9kaXJ0eSA9IHRoaXMuX2ZpcnN0UnVuID0gdHJ1ZTtcbiAgfTtcblxuICBDb21wdXRhdGlvbi5wcm90b3R5cGUgPSB7XG4gIFx0Y29uc3RydWN0b3I6IENvbXB1dGF0aW9uLFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKHZpZXdtb2RlbCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIGluaXRpYWw7XG5cbiAgXHRcdHRoaXMudmlld21vZGVsID0gdmlld21vZGVsO1xuICBcdFx0dGhpcy5ieXBhc3MgPSB0cnVlO1xuXG4gIFx0XHRpbml0aWFsID0gdmlld21vZGVsLmdldCh0aGlzLmtleSk7XG4gIFx0XHR2aWV3bW9kZWwuY2xlYXJDYWNoZSh0aGlzLmtleS5zdHIpO1xuXG4gIFx0XHR0aGlzLmJ5cGFzcyA9IGZhbHNlO1xuXG4gIFx0XHRpZiAodGhpcy5zZXR0ZXIgJiYgaW5pdGlhbCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMuc2V0KGluaXRpYWwpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5oYXJkRGVwcykge1xuICBcdFx0XHR0aGlzLmhhcmREZXBzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgXHRcdFx0XHRyZXR1cm4gdmlld21vZGVsLnJlZ2lzdGVyKGQsIF90aGlzLCBcImNvbXB1dGVkXCIpO1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0aW52YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5fZGlydHkgPSB0cnVlO1xuICBcdH0sXG5cbiAgXHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciBuZXdEZXBzLFxuICBcdFx0ICAgIGRlcGVuZGVuY2llc0NoYW5nZWQsXG4gIFx0XHQgICAgZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgPSBmYWxzZTtcblxuICBcdFx0aWYgKHRoaXMuZ2V0dGluZykge1xuICBcdFx0XHQvLyBwcmV2ZW50IGRvdWJsZS1jb21wdXRhdGlvbiAoZS5nLiBjYXVzZWQgYnkgYXJyYXkgbXV0YXRpb24gaW5zaWRlIGNvbXB1dGF0aW9uKVxuICBcdFx0XHR2YXIgbXNnID0gXCJUaGUgXCIgKyB0aGlzLmtleS5zdHIgKyBcIiBjb21wdXRhdGlvbiBpbmRpcmVjdGx5IGNhbGxlZCBpdHNlbGYuIFRoaXMgcHJvYmFibHkgaW5kaWNhdGVzIGEgYnVnIGluIHRoZSBjb21wdXRhdGlvbi4gSXQgaXMgY29tbW9ubHkgY2F1c2VkIGJ5IGBhcnJheS5zb3J0KC4uLilgIC0gaWYgdGhhdCdzIHRoZSBjYXNlLCBjbG9uZSB0aGUgYXJyYXkgZmlyc3Qgd2l0aCBgYXJyYXkuc2xpY2UoKS5zb3J0KC4uLilgXCI7XG4gIFx0XHRcdHdhcm5PbmNlKG1zZyk7XG4gIFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmdldHRpbmcgPSB0cnVlO1xuXG4gIFx0XHRpZiAodGhpcy5fZGlydHkpIHtcbiAgXHRcdFx0Ly8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGlucHV0cyBoYXZlIGNoYW5nZWQsIGluIGNhc2UgdGhpcyBkZXBlbmRzIG9uXG4gIFx0XHRcdC8vIG90aGVyIGNvbXB1dGVkIHZhbHVlc1xuICBcdFx0XHRpZiAodGhpcy5fZmlyc3RSdW4gfHwgIXRoaXMuaGFyZERlcHMubGVuZ3RoICYmICF0aGlzLnNvZnREZXBzLmxlbmd0aCkge1xuICBcdFx0XHRcdGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRbdGhpcy5oYXJkRGVwcywgdGhpcy5zb2Z0RGVwc10uZm9yRWFjaChmdW5jdGlvbiAoZGVwcykge1xuICBcdFx0XHRcdFx0dmFyIGtleXBhdGgsIHZhbHVlLCBpO1xuXG4gIFx0XHRcdFx0XHRpZiAoZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQpIHtcbiAgXHRcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRpID0gZGVwcy5sZW5ndGg7XG4gIFx0XHRcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0XHRcdGtleXBhdGggPSBkZXBzW2ldO1xuICBcdFx0XHRcdFx0XHR2YWx1ZSA9IF90aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdFx0XHRcdFx0aWYgKCFpc0VxdWFsKHZhbHVlLCBfdGhpcy5kZXBWYWx1ZXNba2V5cGF0aC5zdHJdKSkge1xuICBcdFx0XHRcdFx0XHRcdF90aGlzLmRlcFZhbHVlc1trZXlwYXRoLnN0cl0gPSB2YWx1ZTtcbiAgXHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCA9IHRydWU7XG5cbiAgXHRcdFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCkge1xuICBcdFx0XHRcdHRoaXMudmlld21vZGVsLmNhcHR1cmUoKTtcblxuICBcdFx0XHRcdHRyeSB7XG4gIFx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5nZXR0ZXIoKTtcbiAgXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdFx0XHRcdHdhcm5JZkRlYnVnKFwiRmFpbGVkIHRvIGNvbXB1dGUgXFxcIiVzXFxcIlwiLCB0aGlzLmtleS5zdHIpO1xuICBcdFx0XHRcdFx0bG9nSWZEZWJ1ZyhlcnIuc3RhY2sgfHwgZXJyKTtcblxuICBcdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZvaWQgMDtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRuZXdEZXBzID0gdGhpcy52aWV3bW9kZWwucmVsZWFzZSgpO1xuICBcdFx0XHRcdGRlcGVuZGVuY2llc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZURlcGVuZGVuY2llcyhuZXdEZXBzKTtcblxuICBcdFx0XHRcdGlmIChkZXBlbmRlbmNpZXNDaGFuZ2VkKSB7XG4gIFx0XHRcdFx0XHRbdGhpcy5oYXJkRGVwcywgdGhpcy5zb2Z0RGVwc10uZm9yRWFjaChmdW5jdGlvbiAoZGVwcykge1xuICBcdFx0XHRcdFx0XHRkZXBzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0XHRcdFx0XHRfdGhpcy5kZXBWYWx1ZXNba2V5cGF0aC5zdHJdID0gX3RoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcbiAgXHRcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmdldHRpbmcgPSB0aGlzLl9maXJzdFJ1biA9IGZhbHNlO1xuICBcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0fSxcblxuICBcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRpZiAodGhpcy5zZXR0aW5nKSB7XG4gIFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXRoaXMuc2V0dGVyKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNvbXB1dGVkIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJzIGFyZSByZWFkLW9ubHkuIChUaGlzIG1heSBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSYWN0aXZlISlcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuc2V0dGVyKHZhbHVlKTtcbiAgXHR9LFxuXG4gIFx0dXBkYXRlRGVwZW5kZW5jaWVzOiBmdW5jdGlvbiAobmV3RGVwcykge1xuICBcdFx0dmFyIGksIG9sZERlcHMsIGtleXBhdGgsIGRlcGVuZGVuY2llc0NoYW5nZWQsIHVucmVzb2x2ZWQ7XG5cbiAgXHRcdG9sZERlcHMgPSB0aGlzLnNvZnREZXBzO1xuXG4gIFx0XHQvLyByZW1vdmUgZGVwZW5kZW5jaWVzIHRoYXQgYXJlIG5vIGxvbmdlciB1c2VkXG4gIFx0XHRpID0gb2xkRGVwcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGtleXBhdGggPSBvbGREZXBzW2ldO1xuXG4gIFx0XHRcdGlmIChuZXdEZXBzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xKSB7XG4gIFx0XHRcdFx0ZGVwZW5kZW5jaWVzQ2hhbmdlZCA9IHRydWU7XG4gIFx0XHRcdFx0dGhpcy52aWV3bW9kZWwudW5yZWdpc3RlcihrZXlwYXRoLCB0aGlzLCBcImNvbXB1dGVkXCIpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGNyZWF0ZSByZWZlcmVuY2VzIGZvciBhbnkgbmV3IGRlcGVuZGVuY2llc1xuICBcdFx0aSA9IG5ld0RlcHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRrZXlwYXRoID0gbmV3RGVwc1tpXTtcblxuICBcdFx0XHRpZiAob2xkRGVwcy5pbmRleE9mKGtleXBhdGgpID09PSAtMSAmJiAoIXRoaXMuaGFyZERlcHMgfHwgdGhpcy5oYXJkRGVwcy5pbmRleE9mKGtleXBhdGgpID09PSAtMSkpIHtcbiAgXHRcdFx0XHRkZXBlbmRlbmNpZXNDaGFuZ2VkID0gdHJ1ZTtcblxuICBcdFx0XHRcdC8vIGlmIHRoaXMga2V5cGF0aCBpcyBjdXJyZW50bHkgdW5yZXNvbHZlZCwgd2UgbmVlZCB0byBtYXJrXG4gIFx0XHRcdFx0Ly8gaXQgYXMgc3VjaC4gVE9ETyB0aGlzIGlzIGEgYml0IG11ZGR5Li4uXG4gIFx0XHRcdFx0aWYgKGlzVW5yZXNvbHZlZCh0aGlzLnZpZXdtb2RlbCwga2V5cGF0aCkgJiYgIXRoaXMudW5yZXNvbHZlZERlcHNba2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdFx0XHR1bnJlc29sdmVkID0gbmV3IENvbXB1dGF0aW9uX1VucmVzb2x2ZWREZXBlbmRlbmN5KHRoaXMsIGtleXBhdGguc3RyKTtcbiAgXHRcdFx0XHRcdG5ld0RlcHMuc3BsaWNlKGksIDEpO1xuXG4gIFx0XHRcdFx0XHR0aGlzLnVucmVzb2x2ZWREZXBzW2tleXBhdGguc3RyXSA9IHVucmVzb2x2ZWQ7XG4gIFx0XHRcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRVbnJlc29sdmVkKHVucmVzb2x2ZWQpO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5yZWdpc3RlcihrZXlwYXRoLCB0aGlzLCBcImNvbXB1dGVkXCIpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRpZiAoZGVwZW5kZW5jaWVzQ2hhbmdlZCkge1xuICBcdFx0XHR0aGlzLnNvZnREZXBzID0gbmV3RGVwcy5zbGljZSgpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZGVwZW5kZW5jaWVzQ2hhbmdlZDtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNVbnJlc29sdmVkKHZpZXdtb2RlbCwga2V5cGF0aCkge1xuICBcdHZhciBrZXkgPSBrZXlwYXRoLmZpcnN0S2V5O1xuXG4gIFx0cmV0dXJuICEoa2V5IGluIHZpZXdtb2RlbC5kYXRhKSAmJiAhKGtleSBpbiB2aWV3bW9kZWwuY29tcHV0YXRpb25zKSAmJiAhKGtleSBpbiB2aWV3bW9kZWwubWFwcGluZ3MpO1xuICB9XG5cbiAgdmFyIENvbXB1dGF0aW9uX0NvbXB1dGF0aW9uID0gQ29tcHV0YXRpb247XG5cbiAgdmFyIGNvbXB1dGUgPSBWaWV3bW9kZWwkY29tcHV0ZTtcbiAgZnVuY3Rpb24gVmlld21vZGVsJGNvbXB1dGUoa2V5LCBzaWduYXR1cmUpIHtcbiAgXHR2YXIgY29tcHV0YXRpb24gPSBuZXcgQ29tcHV0YXRpb25fQ29tcHV0YXRpb24oa2V5LCBzaWduYXR1cmUpO1xuXG4gIFx0aWYgKHRoaXMucmVhZHkpIHtcbiAgXHRcdGNvbXB1dGF0aW9uLmluaXQodGhpcyk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMuY29tcHV0YXRpb25zW2tleS5zdHJdID0gY29tcHV0YXRpb247XG4gIH1cblxuICB2YXIgRkFJTEVEX0xPT0tVUCA9IHsgRkFJTEVEX0xPT0tVUDogdHJ1ZSB9O1xuXG4gIHZhciB2aWV3bW9kZWxfcHJvdG90eXBlX2dldCA9IFZpZXdtb2RlbCRnZXQ7XG5cbiAgdmFyIHZpZXdtb2RlbF9wcm90b3R5cGVfZ2V0X19lbXB0eSA9IHt9O1xuICBmdW5jdGlvbiBWaWV3bW9kZWwkZ2V0KGtleXBhdGgsIG9wdGlvbnMpIHtcbiAgXHR2YXIgY2FjaGUgPSB0aGlzLmNhY2hlLFxuICBcdCAgICB2YWx1ZSxcbiAgXHQgICAgY29tcHV0YXRpb24sXG4gIFx0ICAgIHdyYXBwZWQsXG4gIFx0ICAgIGNhcHR1cmVHcm91cCxcbiAgXHQgICAga2V5cGF0aFN0ciA9IGtleXBhdGguc3RyLFxuICBcdCAgICBrZXk7XG5cbiAgXHRvcHRpb25zID0gb3B0aW9ucyB8fCB2aWV3bW9kZWxfcHJvdG90eXBlX2dldF9fZW1wdHk7XG5cbiAgXHQvLyBjYXB0dXJlIHRoZSBrZXlwYXRoLCBpZiB3ZSdyZSBpbnNpZGUgYSBjb21wdXRhdGlvblxuICBcdGlmIChvcHRpb25zLmNhcHR1cmUgJiYgKGNhcHR1cmVHcm91cCA9IGxhc3RJdGVtKHRoaXMuY2FwdHVyZUdyb3VwcykpKSB7XG4gIFx0XHRpZiAoISB+Y2FwdHVyZUdyb3VwLmluZGV4T2Yoa2V5cGF0aCkpIHtcbiAgXHRcdFx0Y2FwdHVyZUdyb3VwLnB1c2goa2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKGhhc093bi5jYWxsKHRoaXMubWFwcGluZ3MsIGtleXBhdGguZmlyc3RLZXkpKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5tYXBwaW5nc1trZXlwYXRoLmZpcnN0S2V5XS5nZXQoa2V5cGF0aCwgb3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0aWYgKGtleXBhdGguaXNTcGVjaWFsKSB7XG4gIFx0XHRyZXR1cm4ga2V5cGF0aC52YWx1ZTtcbiAgXHR9XG5cbiAgXHRpZiAoY2FjaGVba2V5cGF0aFN0cl0gPT09IHVuZGVmaW5lZCkge1xuXG4gIFx0XHQvLyBJcyB0aGlzIGEgY29tcHV0ZWQgcHJvcGVydHk/XG4gIFx0XHRpZiAoKGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRhdGlvbnNba2V5cGF0aFN0cl0pICYmICFjb21wdXRhdGlvbi5ieXBhc3MpIHtcbiAgXHRcdFx0dmFsdWUgPSBjb21wdXRhdGlvbi5nZXQoKTtcbiAgXHRcdFx0dGhpcy5hZGFwdChrZXlwYXRoU3RyLCB2YWx1ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIElzIHRoaXMgYSB3cmFwcGVkIHByb3BlcnR5P1xuICBcdFx0ZWxzZSBpZiAod3JhcHBlZCA9IHRoaXMud3JhcHBlZFtrZXlwYXRoU3RyXSkge1xuICBcdFx0XHR2YWx1ZSA9IHdyYXBwZWQudmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIElzIGl0IHRoZSByb290P1xuICBcdFx0ZWxzZSBpZiAoa2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdFx0dGhpcy5hZGFwdChcIlwiLCB0aGlzLmRhdGEpO1xuICBcdFx0XHR2YWx1ZSA9IHRoaXMuZGF0YTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gTm8/IFRoZW4gd2UgbmVlZCB0byByZXRyaWV2ZSB0aGUgdmFsdWUgb25lIGtleSBhdCBhIHRpbWVcbiAgXHRcdGVsc2Uge1xuICBcdFx0XHR2YWx1ZSA9IHJldHJpZXZlKHRoaXMsIGtleXBhdGgpO1xuICBcdFx0fVxuXG4gIFx0XHRjYWNoZVtrZXlwYXRoU3RyXSA9IHZhbHVlO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR2YWx1ZSA9IGNhY2hlW2tleXBhdGhTdHJdO1xuICBcdH1cblxuICBcdGlmICghb3B0aW9ucy5ub1Vud3JhcCAmJiAod3JhcHBlZCA9IHRoaXMud3JhcHBlZFtrZXlwYXRoU3RyXSkpIHtcbiAgXHRcdHZhbHVlID0gd3JhcHBlZC5nZXQoKTtcbiAgXHR9XG5cbiAgXHRpZiAoa2V5cGF0aC5pc1Jvb3QgJiYgb3B0aW9ucy5mdWxsUm9vdEdldCkge1xuICBcdFx0Zm9yIChrZXkgaW4gdGhpcy5tYXBwaW5ncykge1xuICBcdFx0XHR2YWx1ZVtrZXldID0gdGhpcy5tYXBwaW5nc1trZXldLmdldFZhbHVlKCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHZhbHVlID09PSBGQUlMRURfTE9PS1VQID8gdm9pZCAwIDogdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXRyaWV2ZSh2aWV3bW9kZWwsIGtleXBhdGgpIHtcblxuICBcdHZhciBwYXJlbnRWYWx1ZSwgY2FjaGVNYXAsIHZhbHVlLCB3cmFwcGVkO1xuXG4gIFx0cGFyZW50VmFsdWUgPSB2aWV3bW9kZWwuZ2V0KGtleXBhdGgucGFyZW50KTtcblxuICBcdGlmICh3cmFwcGVkID0gdmlld21vZGVsLndyYXBwZWRba2V5cGF0aC5wYXJlbnQuc3RyXSkge1xuICBcdFx0cGFyZW50VmFsdWUgPSB3cmFwcGVkLmdldCgpO1xuICBcdH1cblxuICBcdGlmIChwYXJlbnRWYWx1ZSA9PT0gbnVsbCB8fCBwYXJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gdXBkYXRlIGNhY2hlIG1hcFxuICBcdGlmICghKGNhY2hlTWFwID0gdmlld21vZGVsLmNhY2hlTWFwW2tleXBhdGgucGFyZW50LnN0cl0pKSB7XG4gIFx0XHR2aWV3bW9kZWwuY2FjaGVNYXBba2V5cGF0aC5wYXJlbnQuc3RyXSA9IFtrZXlwYXRoLnN0cl07XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGlmIChjYWNoZU1hcC5pbmRleE9mKGtleXBhdGguc3RyKSA9PT0gLTEpIHtcbiAgXHRcdFx0Y2FjaGVNYXAucHVzaChrZXlwYXRoLnN0cik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gSWYgdGhpcyBwcm9wZXJ0eSBkb2Vzbid0IGV4aXN0LCB3ZSByZXR1cm4gYSBzZW50aW5lbCB2YWx1ZVxuICBcdC8vIHNvIHRoYXQgd2Uga25vdyB0byBxdWVyeSBwYXJlbnQgc2NvcGUgKGlmIHN1Y2ggdGhlcmUgYmUpXG4gIFx0aWYgKHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhKGtleXBhdGgubGFzdEtleSBpbiBwYXJlbnRWYWx1ZSkpIHtcbiAgXHRcdHJldHVybiB2aWV3bW9kZWwuY2FjaGVba2V5cGF0aC5zdHJdID0gRkFJTEVEX0xPT0tVUDtcbiAgXHR9XG5cbiAgXHR2YWx1ZSA9IHBhcmVudFZhbHVlW2tleXBhdGgubGFzdEtleV07XG5cbiAgXHQvLyBEbyB3ZSBoYXZlIGFuIGFkYXB0b3IgZm9yIHRoaXMgdmFsdWU/XG4gIFx0dmlld21vZGVsLmFkYXB0KGtleXBhdGguc3RyLCB2YWx1ZSwgZmFsc2UpO1xuXG4gIFx0Ly8gVXBkYXRlIGNhY2hlXG4gIFx0dmlld21vZGVsLmNhY2hlW2tleXBhdGguc3RyXSA9IHZhbHVlO1xuICBcdHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHZhciB2aWV3bW9kZWxfcHJvdG90eXBlX2luaXQgPSBWaWV3bW9kZWwkaW5pdDtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkaW5pdCgpIHtcbiAgXHR2YXIga2V5O1xuXG4gIFx0Zm9yIChrZXkgaW4gdGhpcy5jb21wdXRhdGlvbnMpIHtcbiAgXHRcdHRoaXMuY29tcHV0YXRpb25zW2tleV0uaW5pdCh0aGlzKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX21hcCA9IFZpZXdtb2RlbCRtYXA7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJG1hcChrZXksIG9wdGlvbnMpIHtcbiAgXHR2YXIgbWFwcGluZyA9IHRoaXMubWFwcGluZ3Nba2V5LnN0cl0gPSBuZXcgTWFwcGluZyhrZXksIG9wdGlvbnMpO1xuICBcdG1hcHBpbmcuaW5pdFZpZXdtb2RlbCh0aGlzKTtcbiAgXHRyZXR1cm4gbWFwcGluZztcbiAgfVxuXG4gIHZhciBNYXBwaW5nID0gZnVuY3Rpb24gKGxvY2FsS2V5LCBvcHRpb25zKSB7XG4gIFx0dGhpcy5sb2NhbEtleSA9IGxvY2FsS2V5O1xuICBcdHRoaXMua2V5cGF0aCA9IG9wdGlvbnMua2V5cGF0aDtcbiAgXHR0aGlzLm9yaWdpbiA9IG9wdGlvbnMub3JpZ2luO1xuXG4gIFx0dGhpcy5kZXBzID0gW107XG4gIFx0dGhpcy51bnJlc29sdmVkID0gW107XG5cbiAgXHR0aGlzLnJlc29sdmVkID0gZmFsc2U7XG4gIH07XG5cbiAgTWFwcGluZy5wcm90b3R5cGUgPSB7XG4gIFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBUT0RPIHdhcm4sIGFzIHBlciAjMTY5Mj9cbiAgXHRcdHRoaXMua2V5cGF0aCA9IHRoaXMubG9jYWxLZXk7XG4gIFx0XHR0aGlzLnNldHVwKCk7XG4gIFx0fSxcblxuICBcdGdldDogZnVuY3Rpb24gKGtleXBhdGgsIG9wdGlvbnMpIHtcbiAgXHRcdGlmICghdGhpcy5yZXNvbHZlZCkge1xuICBcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXMub3JpZ2luLmdldCh0aGlzLm1hcChrZXlwYXRoKSwgb3B0aW9ucyk7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMua2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIHRoaXMub3JpZ2luLmdldCh0aGlzLmtleXBhdGgpO1xuICBcdH0sXG5cbiAgXHRpbml0Vmlld21vZGVsOiBmdW5jdGlvbiAodmlld21vZGVsKSB7XG4gIFx0XHR0aGlzLmxvY2FsID0gdmlld21vZGVsO1xuICBcdFx0dGhpcy5zZXR1cCgpO1xuICBcdH0sXG5cbiAgXHRtYXA6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRpZiAodHlwZW9mIHRoaXMua2V5cGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmxvY2FsS2V5O1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIGtleXBhdGgucmVwbGFjZSh0aGlzLmxvY2FsS2V5LCB0aGlzLmtleXBhdGgpO1xuICBcdH0sXG5cbiAgXHRyZWdpc3RlcjogZnVuY3Rpb24gKGtleXBhdGgsIGRlcGVuZGFudCwgZ3JvdXApIHtcbiAgXHRcdHRoaXMuZGVwcy5wdXNoKHsga2V5cGF0aDoga2V5cGF0aCwgZGVwOiBkZXBlbmRhbnQsIGdyb3VwOiBncm91cCB9KTtcblxuICBcdFx0aWYgKHRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0dGhpcy5vcmlnaW4ucmVnaXN0ZXIodGhpcy5tYXAoa2V5cGF0aCksIGRlcGVuZGFudCwgZ3JvdXApO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZXNvbHZlOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMua2V5cGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMudW5iaW5kKHRydWUpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdFx0dGhpcy5zZXR1cCgpO1xuICBcdH0sXG5cbiAgXHRzZXQ6IGZ1bmN0aW9uIChrZXlwYXRoLCB2YWx1ZSkge1xuICBcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdHRoaXMuZm9yY2VSZXNvbHV0aW9uKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMub3JpZ2luLnNldCh0aGlzLm1hcChrZXlwYXRoKSwgdmFsdWUpO1xuICBcdH0sXG5cbiAgXHRzZXR1cDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0aWYgKHRoaXMua2V5cGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5yZXNvbHZlZCA9IHRydWU7XG5cbiAgXHRcdC8vIGFjY3VtdWxhdGVkIGRlcGVuZGFudHMgY2FuIG5vdyBiZSByZWdpc3RlcmVkXG4gIFx0XHRpZiAodGhpcy5kZXBzLmxlbmd0aCkge1xuICBcdFx0XHR0aGlzLmRlcHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHRcdHZhciBrZXlwYXRoID0gX3RoaXMubWFwKGQua2V5cGF0aCk7XG4gIFx0XHRcdFx0X3RoaXMub3JpZ2luLnJlZ2lzdGVyKGtleXBhdGgsIGQuZGVwLCBkLmdyb3VwKTtcblxuICBcdFx0XHRcdC8vIFRPRE8gdGhpcyBpcyBhIGJpdCBvZiBhIHJlZCBmbGFnLi4uIGFsbCBkZXBzIHNob3VsZCBiZSB0aGUgc2FtZT9cbiAgXHRcdFx0XHRpZiAoZC5kZXAuc2V0VmFsdWUpIHtcbiAgXHRcdFx0XHRcdGQuZGVwLnNldFZhbHVlKF90aGlzLm9yaWdpbi5nZXQoa2V5cGF0aCkpO1xuICBcdFx0XHRcdH0gZWxzZSBpZiAoZC5kZXAuaW52YWxpZGF0ZSkge1xuICBcdFx0XHRcdFx0ZC5kZXAuaW52YWxpZGF0ZSgpO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkLiBQbGVhc2UgcmFpc2UgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3VlcyAtIHRoYW5rcyFcIik7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9KTtcblxuICBcdFx0XHR0aGlzLm9yaWdpbi5tYXJrKHRoaXMua2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdGlmICghdGhpcy5rZXlwYXRoKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIk1hcHBpbmcgZG9lcyBub3QgaGF2ZSBrZXlwYXRoLCBjYW5ub3Qgc2V0IHZhbHVlLiBQbGVhc2UgcmFpc2UgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3VlcyAtIHRoYW5rcyFcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMub3JpZ2luLnNldCh0aGlzLmtleXBhdGgsIHZhbHVlKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoa2VlcExvY2FsKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHRpZiAoIWtlZXBMb2NhbCkge1xuICBcdFx0XHRkZWxldGUgdGhpcy5sb2NhbC5tYXBwaW5nc1t0aGlzLmxvY2FsS2V5XTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5kZXBzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgXHRcdFx0X3RoaXMub3JpZ2luLnVucmVnaXN0ZXIoX3RoaXMubWFwKGQua2V5cGF0aCksIGQuZGVwLCBkLmdyb3VwKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRpZiAodGhpcy50cmFja2VyKSB7XG4gIFx0XHRcdHRoaXMub3JpZ2luLnVucmVnaXN0ZXIodGhpcy5rZXlwYXRoLCB0aGlzLnRyYWNrZXIpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlZ2lzdGVyOiBmdW5jdGlvbiAoa2V5cGF0aCwgZGVwZW5kYW50LCBncm91cCkge1xuICBcdFx0dmFyIGRlcHMsIGk7XG5cbiAgXHRcdGlmICghdGhpcy5yZXNvbHZlZCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGRlcHMgPSB0aGlzLmRlcHM7XG4gIFx0XHRpID0gZGVwcy5sZW5ndGg7XG5cbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0aWYgKGRlcHNbaV0uZGVwID09PSBkZXBlbmRhbnQpIHtcbiAgXHRcdFx0XHRkZXBzLnNwbGljZShpLCAxKTtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0dGhpcy5vcmlnaW4udW5yZWdpc3Rlcih0aGlzLm1hcChrZXlwYXRoKSwgZGVwZW5kYW50LCBncm91cCk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBtYXJrID0gVmlld21vZGVsJG1hcms7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJG1hcmsoa2V5cGF0aCwgb3B0aW9ucykge1xuICBcdHZhciBjb21wdXRhdGlvbixcbiAgXHQgICAga2V5cGF0aFN0ciA9IGtleXBhdGguc3RyO1xuXG4gIFx0Ly8gaW1wbGljaXQgY2hhbmdlcyAoaS5lLiBgZm9vLmxlbmd0aGAgb24gYHJhY3RpdmUucHVzaCgnZm9vJyw0MilgKVxuICBcdC8vIHNob3VsZCBub3QgYmUgcGlja2VkIHVwIGJ5IHBhdHRlcm4gb2JzZXJ2ZXJzXG4gIFx0aWYgKG9wdGlvbnMpIHtcbiAgXHRcdGlmIChvcHRpb25zLmltcGxpY2l0KSB7XG4gIFx0XHRcdHRoaXMuaW1wbGljaXRDaGFuZ2VzW2tleXBhdGhTdHJdID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHRcdGlmIChvcHRpb25zLm5vQ2FzY2FkZSkge1xuICBcdFx0XHR0aGlzLm5vQ2FzY2FkZVtrZXlwYXRoU3RyXSA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRhdGlvbnNba2V5cGF0aFN0cl0pIHtcbiAgXHRcdGNvbXB1dGF0aW9uLmludmFsaWRhdGUoKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5jaGFuZ2VzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xKSB7XG4gIFx0XHR0aGlzLmNoYW5nZXMucHVzaChrZXlwYXRoKTtcbiAgXHR9XG5cbiAgXHQvLyBwYXNzIG9uIGtlZXBFeGlzdGluZ1dyYXBwZXIsIGlmIHdlIGNhblxuICBcdHZhciBrZWVwRXhpc3RpbmdXcmFwcGVyID0gb3B0aW9ucyA/IG9wdGlvbnMua2VlcEV4aXN0aW5nV3JhcHBlciA6IGZhbHNlO1xuXG4gIFx0dGhpcy5jbGVhckNhY2hlKGtleXBhdGhTdHIsIGtlZXBFeGlzdGluZ1dyYXBwZXIpO1xuXG4gIFx0aWYgKHRoaXMucmVhZHkpIHtcbiAgXHRcdHRoaXMub25jaGFuZ2UoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgbWFwT2xkVG9OZXdJbmRleCA9IGZ1bmN0aW9uIChvbGRBcnJheSwgbmV3QXJyYXkpIHtcbiAgXHR2YXIgdXNlZEluZGljZXMsIGZpcnN0VW51c2VkSW5kZXgsIG5ld0luZGljZXMsIGNoYW5nZWQ7XG5cbiAgXHR1c2VkSW5kaWNlcyA9IHt9O1xuICBcdGZpcnN0VW51c2VkSW5kZXggPSAwO1xuXG4gIFx0bmV3SW5kaWNlcyA9IG9sZEFycmF5Lm1hcChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICBcdFx0dmFyIGluZGV4LCBzdGFydCwgbGVuO1xuXG4gIFx0XHRzdGFydCA9IGZpcnN0VW51c2VkSW5kZXg7XG4gIFx0XHRsZW4gPSBuZXdBcnJheS5sZW5ndGg7XG5cbiAgXHRcdGRvIHtcbiAgXHRcdFx0aW5kZXggPSBuZXdBcnJheS5pbmRleE9mKGl0ZW0sIHN0YXJ0KTtcblxuICBcdFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG4gIFx0XHRcdFx0cmV0dXJuIC0xO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0c3RhcnQgPSBpbmRleCArIDE7XG4gIFx0XHR9IHdoaWxlICh1c2VkSW5kaWNlc1tpbmRleF0gJiYgc3RhcnQgPCBsZW4pO1xuXG4gIFx0XHQvLyBrZWVwIHRyYWNrIG9mIHRoZSBmaXJzdCB1bnVzZWQgaW5kZXgsIHNvIHdlIGRvbid0IHNlYXJjaFxuICBcdFx0Ly8gdGhlIHdob2xlIG9mIG5ld0FycmF5IGZvciBlYWNoIGl0ZW0gaW4gb2xkQXJyYXkgdW5uZWNlc3NhcmlseVxuICBcdFx0aWYgKGluZGV4ID09PSBmaXJzdFVudXNlZEluZGV4KSB7XG4gIFx0XHRcdGZpcnN0VW51c2VkSW5kZXggKz0gMTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGluZGV4ICE9PSBpKSB7XG4gIFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHR1c2VkSW5kaWNlc1tpbmRleF0gPSB0cnVlO1xuICBcdFx0cmV0dXJuIGluZGV4O1xuICBcdH0pO1xuXG4gIFx0cmV0dXJuIG5ld0luZGljZXM7XG4gIH07XG5cbiAgdmFyIG1lcmdlID0gVmlld21vZGVsJG1lcmdlO1xuXG4gIHZhciBjb21wYXJhdG9ycyA9IHt9O1xuICBmdW5jdGlvbiBWaWV3bW9kZWwkbWVyZ2Uoa2V5cGF0aCwgY3VycmVudEFycmF5LCBhcnJheSwgb3B0aW9ucykge1xuICBcdHZhciBvbGRBcnJheSwgbmV3QXJyYXksIGNvbXBhcmF0b3IsIG5ld0luZGljZXM7XG5cbiAgXHR0aGlzLm1hcmsoa2V5cGF0aCk7XG5cbiAgXHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhcmUpIHtcblxuICBcdFx0Y29tcGFyYXRvciA9IGdldENvbXBhcmF0b3JGdW5jdGlvbihvcHRpb25zLmNvbXBhcmUpO1xuXG4gIFx0XHR0cnkge1xuICBcdFx0XHRvbGRBcnJheSA9IGN1cnJlbnRBcnJheS5tYXAoY29tcGFyYXRvcik7XG4gIFx0XHRcdG5ld0FycmF5ID0gYXJyYXkubWFwKGNvbXBhcmF0b3IpO1xuICBcdFx0fSBjYXRjaCAoZXJyKSB7XG4gIFx0XHRcdC8vIGZhbGxiYWNrIHRvIGFuIGlkZW50aXR5IGNoZWNrIC0gd29yc3QgY2FzZSBzY2VuYXJpbyB3ZSBoYXZlXG4gIFx0XHRcdC8vIHRvIGRvIG1vcmUgRE9NIG1hbmlwdWxhdGlvbiB0aGFuIHdlIHRob3VnaHQuLi5cbiAgXHRcdFx0d2FybklmRGVidWcoXCJtZXJnZSgpOiBcXFwiJXNcXFwiIGNvbXBhcmlzb24gZmFpbGVkLiBGYWxsaW5nIGJhY2sgdG8gaWRlbnRpdHkgY2hlY2tpbmdcIiwga2V5cGF0aCk7XG5cbiAgXHRcdFx0b2xkQXJyYXkgPSBjdXJyZW50QXJyYXk7XG4gIFx0XHRcdG5ld0FycmF5ID0gYXJyYXk7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5O1xuICBcdFx0bmV3QXJyYXkgPSBhcnJheTtcbiAgXHR9XG5cbiAgXHQvLyBmaW5kIG5ldyBpbmRpY2VzIGZvciBtZW1iZXJzIG9mIG9sZEFycmF5XG4gIFx0bmV3SW5kaWNlcyA9IG1hcE9sZFRvTmV3SW5kZXgob2xkQXJyYXksIG5ld0FycmF5KTtcblxuICBcdHRoaXMuc21hcnRVcGRhdGUoa2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMsIGN1cnJlbnRBcnJheS5sZW5ndGggIT09IGFycmF5Lmxlbmd0aCk7XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnkoaXRlbSkge1xuICBcdHJldHVybiBKU09OLnN0cmluZ2lmeShpdGVtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbXBhcmF0b3JGdW5jdGlvbihjb21wYXJhdG9yKSB7XG4gIFx0Ly8gSWYgYGNvbXBhcmVgIGlzIGB0cnVlYCwgd2UgdXNlIEpTT04uc3RyaW5naWZ5IHRvIGNvbXBhcmVcbiAgXHQvLyBvYmplY3RzIHRoYXQgYXJlIHRoZSBzYW1lIHNoYXBlLCBidXQgbm9uLWlkZW50aWNhbCAtIGkuZS5cbiAgXHQvLyB7IGZvbzogJ2JhcicgfSAhPT0geyBmb286ICdiYXInIH1cbiAgXHRpZiAoY29tcGFyYXRvciA9PT0gdHJ1ZSkge1xuICBcdFx0cmV0dXJuIHN0cmluZ2lmeTtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIGNvbXBhcmF0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGlmICghY29tcGFyYXRvcnNbY29tcGFyYXRvcl0pIHtcbiAgXHRcdFx0Y29tcGFyYXRvcnNbY29tcGFyYXRvcl0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0XHRcdHJldHVybiBpdGVtW2NvbXBhcmF0b3JdO1xuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gY29tcGFyYXRvcnNbY29tcGFyYXRvcl07XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiBjb21wYXJhdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdHJldHVybiBjb21wYXJhdG9yO1xuICBcdH1cblxuICBcdHRocm93IG5ldyBFcnJvcihcIlRoZSBgY29tcGFyZWAgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbiwgb3IgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGlkZW50aWZ5aW5nIGZpZWxkIChvciBgdHJ1ZWAgdG8gdXNlIEpTT04uc3RyaW5naWZ5KVwiKTtcbiAgfVxuXG4gIHZhciByZWdpc3RlciA9IFZpZXdtb2RlbCRyZWdpc3RlcjtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkcmVnaXN0ZXIoa2V5cGF0aCwgZGVwZW5kYW50KSB7XG4gIFx0dmFyIGdyb3VwID0gYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBcImRlZmF1bHRcIiA6IGFyZ3VtZW50c1syXTtcblxuICBcdHZhciBtYXBwaW5nLCBkZXBzQnlLZXlwYXRoLCBkZXBzO1xuXG4gIFx0aWYgKGRlcGVuZGFudC5pc1N0YXRpYykge1xuICBcdFx0cmV0dXJuOyAvLyBUT0RPIHdlIHNob3VsZCBuZXZlciBnZXQgaGVyZSBpZiBhIGRlcGVuZGFudCBpcyBzdGF0aWMuLi5cbiAgXHR9XG5cbiAgXHRpZiAobWFwcGluZyA9IHRoaXMubWFwcGluZ3Nba2V5cGF0aC5maXJzdEtleV0pIHtcbiAgXHRcdG1hcHBpbmcucmVnaXN0ZXIoa2V5cGF0aCwgZGVwZW5kYW50LCBncm91cCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGRlcHNCeUtleXBhdGggPSB0aGlzLmRlcHNbZ3JvdXBdIHx8ICh0aGlzLmRlcHNbZ3JvdXBdID0ge30pO1xuICBcdFx0ZGVwcyA9IGRlcHNCeUtleXBhdGhba2V5cGF0aC5zdHJdIHx8IChkZXBzQnlLZXlwYXRoW2tleXBhdGguc3RyXSA9IFtdKTtcblxuICBcdFx0ZGVwcy5wdXNoKGRlcGVuZGFudCk7XG5cbiAgXHRcdGlmICghdGhpcy5kZXBzTWFwW2dyb3VwXSkge1xuICBcdFx0XHR0aGlzLmRlcHNNYXBbZ3JvdXBdID0ge307XG4gIFx0XHR9XG5cbiAgXHRcdGlmICgha2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdFx0cmVnaXN0ZXJfX3VwZGF0ZURlcGVuZGFudHNNYXAodGhpcywga2V5cGF0aCwgZ3JvdXApO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyX191cGRhdGVEZXBlbmRhbnRzTWFwKHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXApIHtcbiAgXHR2YXIgbWFwLCBwYXJlbnQsIGtleXBhdGhTdHI7XG5cbiAgXHQvLyB1cGRhdGUgZGVwZW5kYW50cyBtYXBcbiAgXHR3aGlsZSAoIWtleXBhdGguaXNSb290KSB7XG4gIFx0XHRtYXAgPSB2aWV3bW9kZWwuZGVwc01hcFtncm91cF07XG4gIFx0XHRwYXJlbnQgPSBtYXBba2V5cGF0aC5wYXJlbnQuc3RyXSB8fCAobWFwW2tleXBhdGgucGFyZW50LnN0cl0gPSBbXSk7XG5cbiAgXHRcdGtleXBhdGhTdHIgPSBrZXlwYXRoLnN0cjtcblxuICBcdFx0Ly8gVE9ETyBmaW5kIGFuIGFsdGVybmF0aXZlIHRvIHRoaXMgbmFzdHkgYXBwcm9hY2hcbiAgXHRcdGlmIChwYXJlbnRbXCJfXCIgKyBrZXlwYXRoU3RyXSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHBhcmVudFtcIl9cIiArIGtleXBhdGhTdHJdID0gMDtcbiAgXHRcdFx0cGFyZW50LnB1c2goa2V5cGF0aCk7XG4gIFx0XHR9XG5cbiAgXHRcdHBhcmVudFtcIl9cIiArIGtleXBhdGhTdHJdICs9IDE7XG4gIFx0XHRrZXlwYXRoID0ga2V5cGF0aC5wYXJlbnQ7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHJlbGVhc2UgPSBWaWV3bW9kZWwkcmVsZWFzZTtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkcmVsZWFzZSgpIHtcbiAgXHRyZXR1cm4gdGhpcy5jYXB0dXJlR3JvdXBzLnBvcCgpO1xuICB9XG5cbiAgdmFyIHJlc2V0ID0gVmlld21vZGVsJHJlc2V0O1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRyZXNldChkYXRhKSB7XG4gIFx0dGhpcy5kYXRhID0gZGF0YTtcbiAgXHR0aGlzLmNsZWFyQ2FjaGUoXCJcIik7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3NldCA9IFZpZXdtb2RlbCRzZXQ7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJHNldChrZXlwYXRoLCB2YWx1ZSkge1xuICBcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1syXTtcblxuICBcdHZhciBtYXBwaW5nLCBjb21wdXRhdGlvbiwgd3JhcHBlciwga2VlcEV4aXN0aW5nV3JhcHBlcjtcblxuICBcdC8vIHVubGVzcyBkYXRhIGlzIGJlaW5nIHNldCBmb3IgZGF0YSB0cmFja2luZyBwdXJwb3Nlc1xuICBcdGlmICghb3B0aW9ucy5ub01hcHBpbmcpIHtcbiAgXHRcdC8vIElmIHRoaXMgZGF0YSBiZWxvbmdzIHRvIGEgZGlmZmVyZW50IHZpZXdtb2RlbCxcbiAgXHRcdC8vIHBhc3MgdGhlIGNoYW5nZSBhbG9uZ1xuICBcdFx0aWYgKG1hcHBpbmcgPSB0aGlzLm1hcHBpbmdzW2tleXBhdGguZmlyc3RLZXldKSB7XG4gIFx0XHRcdHJldHVybiBtYXBwaW5nLnNldChrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Y29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1trZXlwYXRoLnN0cl07XG4gIFx0aWYgKGNvbXB1dGF0aW9uKSB7XG4gIFx0XHRpZiAoY29tcHV0YXRpb24uc2V0dGluZykge1xuICBcdFx0XHQvLyBsZXQgdGhlIG90aGVyIGNvbXB1dGF0aW9uIHNldCgpIGhhbmRsZSB0aGluZ3MuLi5cbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdFx0Y29tcHV0YXRpb24uc2V0KHZhbHVlKTtcbiAgXHRcdHZhbHVlID0gY29tcHV0YXRpb24uZ2V0KCk7XG4gIFx0fVxuXG4gIFx0aWYgKGlzRXF1YWwodGhpcy5jYWNoZVtrZXlwYXRoLnN0cl0sIHZhbHVlKSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHdyYXBwZXIgPSB0aGlzLndyYXBwZWRba2V5cGF0aC5zdHJdO1xuXG4gIFx0Ly8gSWYgd2UgaGF2ZSBhIHdyYXBwZXIgd2l0aCBhIGByZXNldCgpYCBtZXRob2QsIHdlIHRyeSBhbmQgdXNlIGl0LiBJZiB0aGVcbiAgXHQvLyBgcmVzZXQoKWAgbWV0aG9kIHJldHVybnMgZmFsc2UsIHRoZSB3cmFwcGVyIHNob3VsZCBiZSB0b3JuIGRvd24sIGFuZFxuICBcdC8vIChtb3N0IGxpa2VseSkgYSBuZXcgb25lIHNob3VsZCBiZSBjcmVhdGVkIGxhdGVyXG4gIFx0aWYgKHdyYXBwZXIgJiYgd3JhcHBlci5yZXNldCkge1xuICBcdFx0a2VlcEV4aXN0aW5nV3JhcHBlciA9IHdyYXBwZXIucmVzZXQodmFsdWUpICE9PSBmYWxzZTtcblxuICBcdFx0aWYgKGtlZXBFeGlzdGluZ1dyYXBwZXIpIHtcbiAgXHRcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICghY29tcHV0YXRpb24gJiYgIWtlZXBFeGlzdGluZ1dyYXBwZXIpIHtcbiAgXHRcdHJlc29sdmVTZXQodGhpcywga2V5cGF0aCwgdmFsdWUpO1xuICBcdH1cblxuICBcdGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgXHRcdHRoaXMubWFyayhrZXlwYXRoKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gV2UncmUgc2V0dGluZyBhIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdGFyZ2V0IGtleXBhdGggKGkuZS5cbiAgXHRcdC8vIGNyZWF0aW5nIGEgZnJlc2ggYnJhbmNoKSAtIHdlIG5lZWQgdG8gY2xlYXIgdGhlIGNhY2hlLCBidXRcbiAgXHRcdC8vIG5vdCBtYXJrIGl0IGFzIGEgY2hhbmdlXG4gIFx0XHR0aGlzLmNsZWFyQ2FjaGUoa2V5cGF0aC5zdHIpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVTZXQodmlld21vZGVsLCBrZXlwYXRoLCB2YWx1ZSkge1xuICBcdHZhciB3cmFwcGVyLCBwYXJlbnRWYWx1ZSwgd3JhcHBlclNldCwgdmFsdWVTZXQ7XG5cbiAgXHR3cmFwcGVyU2V0ID0gZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHdyYXBwZXIuc2V0KSB7XG4gIFx0XHRcdHdyYXBwZXIuc2V0KGtleXBhdGgubGFzdEtleSwgdmFsdWUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyZW50VmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuICBcdFx0XHR2YWx1ZVNldCgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHR2YWx1ZVNldCA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghcGFyZW50VmFsdWUpIHtcbiAgXHRcdFx0cGFyZW50VmFsdWUgPSBjcmVhdGVCcmFuY2goa2V5cGF0aC5sYXN0S2V5KTtcbiAgXHRcdFx0dmlld21vZGVsLnNldChrZXlwYXRoLnBhcmVudCwgcGFyZW50VmFsdWUsIHsgc2lsZW50OiB0cnVlIH0pO1xuICBcdFx0fVxuICBcdFx0cGFyZW50VmFsdWVba2V5cGF0aC5sYXN0S2V5XSA9IHZhbHVlO1xuICBcdH07XG5cbiAgXHR3cmFwcGVyID0gdmlld21vZGVsLndyYXBwZWRba2V5cGF0aC5wYXJlbnQuc3RyXTtcblxuICBcdGlmICh3cmFwcGVyKSB7XG4gIFx0XHR3cmFwcGVyU2V0KCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHBhcmVudFZhbHVlID0gdmlld21vZGVsLmdldChrZXlwYXRoLnBhcmVudCk7XG5cbiAgXHRcdC8vIG1heSBoYXZlIGJlZW4gd3JhcHBlZCB2aWEgdGhlIGFib3ZlIC5nZXQoKVxuICBcdFx0Ly8gY2FsbCBvbiB2aWV3bW9kZWwgaWYgdGhpcyBpcyBmaXJzdCBhY2Nlc3MgdmlhIC5zZXQoKSFcbiAgXHRcdGlmICh3cmFwcGVyID0gdmlld21vZGVsLndyYXBwZWRba2V5cGF0aC5wYXJlbnQuc3RyXSkge1xuICBcdFx0XHR3cmFwcGVyU2V0KCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR2YWx1ZVNldCgpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBzbWFydFVwZGF0ZSA9IFZpZXdtb2RlbCRzbWFydFVwZGF0ZTtcblxuICB2YXIgaW1wbGljaXRPcHRpb24gPSB7IGltcGxpY2l0OiB0cnVlIH0sXG4gICAgICBub0Nhc2NhZGVPcHRpb24gPSB7IG5vQ2FzY2FkZTogdHJ1ZSB9O1xuICBmdW5jdGlvbiBWaWV3bW9kZWwkc21hcnRVcGRhdGUoa2V5cGF0aCwgYXJyYXksIG5ld0luZGljZXMpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIGRlcGVuZGFudHMsIG9sZExlbmd0aCwgaTtcblxuICBcdG9sZExlbmd0aCA9IG5ld0luZGljZXMubGVuZ3RoO1xuXG4gIFx0Ly8gSW5kaWNlcyB0aGF0IGFyZSBiZWluZyByZW1vdmVkIHNob3VsZCBiZSBtYXJrZWQgYXMgZGlydHlcbiAgXHRuZXdJbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKG5ld0luZGV4LCBvbGRJbmRleCkge1xuICBcdFx0aWYgKG5ld0luZGV4ID09PSAtMSkge1xuICBcdFx0XHRfdGhpcy5tYXJrKGtleXBhdGguam9pbihvbGRJbmRleCksIG5vQ2FzY2FkZU9wdGlvbik7XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHQvLyBVcGRhdGUgdGhlIG1vZGVsXG4gIFx0Ly8gVE9ETyBhbGxvdyBleGlzdGluZyBhcnJheSB0byBiZSB1cGRhdGVkIGluIHBsYWNlLCByYXRoZXIgdGhhbiByZXBsYWNlZD9cbiAgXHR0aGlzLnNldChrZXlwYXRoLCBhcnJheSwgeyBzaWxlbnQ6IHRydWUgfSk7XG5cbiAgXHRpZiAoZGVwZW5kYW50cyA9IHRoaXMuZGVwc1tcImRlZmF1bHRcIl1ba2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRkZXBlbmRhbnRzLmZpbHRlcihjYW5TaHVmZmxlKS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gIFx0XHRcdHJldHVybiBkLnNodWZmbGUobmV3SW5kaWNlcywgYXJyYXkpO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0aWYgKG9sZExlbmd0aCAhPT0gYXJyYXkubGVuZ3RoKSB7XG4gIFx0XHR0aGlzLm1hcmsoa2V5cGF0aC5qb2luKFwibGVuZ3RoXCIpLCBpbXBsaWNpdE9wdGlvbik7XG5cbiAgXHRcdGZvciAoaSA9IG5ld0luZGljZXMudG91Y2hlZEZyb207IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0XHR0aGlzLm1hcmsoa2V5cGF0aC5qb2luKGkpKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gZG9uJ3QgYWxsb3cgcmVtb3ZlZCBpbmRleGVzIGJleW9uZCBlbmQgb2YgbmV3IGFycmF5IHRvIHRyaWdnZXIgcmVjb21wdXRhdGlvbnNcbiAgXHRcdC8vIFRPRE8gaXMgdGhpcyBzdGlsbCBuZWNlc3NhcnksIG5vdyB0aGF0IGNvbXB1dGF0aW9ucyBhcmUgbGF6eT9cbiAgXHRcdGZvciAoaSA9IGFycmF5Lmxlbmd0aDsgaSA8IG9sZExlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdHRoaXMubWFyayhrZXlwYXRoLmpvaW4oaSksIG5vQ2FzY2FkZU9wdGlvbik7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gY2FuU2h1ZmZsZShkZXBlbmRhbnQpIHtcbiAgXHRyZXR1cm4gdHlwZW9mIGRlcGVuZGFudC5zaHVmZmxlID09PSBcImZ1bmN0aW9uXCI7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3RlYXJkb3duID0gVmlld21vZGVsJHRlYXJkb3duO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCR0ZWFyZG93bigpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3k7XG5cbiAgXHQvLyBDbGVhciBlbnRpcmUgY2FjaGUgLSB0aGlzIGhhcyB0aGUgZGVzaXJlZCBzaWRlLWVmZmVjdFxuICBcdC8vIG9mIHVud3JhcHBpbmcgYWRhcHRlZCB2YWx1ZXMgKGUuZy4gYXJyYXlzKVxuICBcdE9iamVjdC5rZXlzKHRoaXMuY2FjaGUpLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHJldHVybiBfdGhpcy5jbGVhckNhY2hlKGtleXBhdGgpO1xuICBcdH0pO1xuXG4gIFx0Ly8gVGVhcmRvd24gYW55IGZhaWxlZCBsb29rdXBzIC0gd2UgZG9uJ3QgbmVlZCB0aGVtIHRvIHJlc29sdmUgYW55IG1vcmVcbiAgXHR3aGlsZSAodW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSA9IHRoaXMudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzLnBvcCgpKSB7XG4gIFx0XHR1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5LnRlYXJkb3duKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVucmVnaXN0ZXIgPSBWaWV3bW9kZWwkdW5yZWdpc3RlcjtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkdW5yZWdpc3RlcihrZXlwYXRoLCBkZXBlbmRhbnQpIHtcbiAgXHR2YXIgZ3JvdXAgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IFwiZGVmYXVsdFwiIDogYXJndW1lbnRzWzJdO1xuXG4gIFx0dmFyIG1hcHBpbmcsIGRlcHMsIGluZGV4O1xuXG4gIFx0aWYgKGRlcGVuZGFudC5pc1N0YXRpYykge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmIChtYXBwaW5nID0gdGhpcy5tYXBwaW5nc1trZXlwYXRoLmZpcnN0S2V5XSkge1xuICBcdFx0cmV0dXJuIG1hcHBpbmcudW5yZWdpc3RlcihrZXlwYXRoLCBkZXBlbmRhbnQsIGdyb3VwKTtcbiAgXHR9XG5cbiAgXHRkZXBzID0gdGhpcy5kZXBzW2dyb3VwXVtrZXlwYXRoLnN0cl07XG4gIFx0aW5kZXggPSBkZXBzLmluZGV4T2YoZGVwZW5kYW50KTtcblxuICBcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byByZW1vdmUgYSBkZXBlbmRhbnQgdGhhdCB3YXMgbm8gbG9uZ2VyIHJlZ2lzdGVyZWQhIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4uIElmIHlvdSBhcmUgc2VlaW5nIHRoaXMgYnVnIGluIGRldmVsb3BtZW50IHBsZWFzZSByYWlzZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vUmFjdGl2ZUpTL1JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzXCIpO1xuICBcdH1cblxuICBcdGRlcHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICBcdGlmIChrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHVucmVnaXN0ZXJfX3VwZGF0ZURlcGVuZGFudHNNYXAodGhpcywga2V5cGF0aCwgZ3JvdXApO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5yZWdpc3Rlcl9fdXBkYXRlRGVwZW5kYW50c01hcCh2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwKSB7XG4gIFx0dmFyIG1hcCwgcGFyZW50O1xuXG4gIFx0Ly8gdXBkYXRlIGRlcGVuZGFudHMgbWFwXG4gIFx0d2hpbGUgKCFrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0bWFwID0gdmlld21vZGVsLmRlcHNNYXBbZ3JvdXBdO1xuICBcdFx0cGFyZW50ID0gbWFwW2tleXBhdGgucGFyZW50LnN0cl07XG5cbiAgXHRcdHBhcmVudFtcIl9cIiArIGtleXBhdGguc3RyXSAtPSAxO1xuXG4gIFx0XHRpZiAoIXBhcmVudFtcIl9cIiArIGtleXBhdGguc3RyXSkge1xuICBcdFx0XHQvLyByZW1vdmUgZnJvbSBwYXJlbnQgZGVwcyBtYXBcbiAgXHRcdFx0cmVtb3ZlRnJvbUFycmF5KHBhcmVudCwga2V5cGF0aCk7XG4gIFx0XHRcdHBhcmVudFtcIl9cIiArIGtleXBhdGguc3RyXSA9IHVuZGVmaW5lZDtcbiAgXHRcdH1cblxuICBcdFx0a2V5cGF0aCA9IGtleXBhdGgucGFyZW50O1xuICBcdH1cbiAgfVxuXG4gIHZhciBWaWV3bW9kZWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHZhciBhZGFwdCA9IG9wdGlvbnMuYWRhcHQ7XG4gIFx0dmFyIGRhdGEgPSBvcHRpb25zLmRhdGE7XG4gIFx0dmFyIHJhY3RpdmUgPSBvcHRpb25zLnJhY3RpdmU7XG4gIFx0dmFyIGNvbXB1dGVkID0gb3B0aW9ucy5jb21wdXRlZDtcbiAgXHR2YXIgbWFwcGluZ3MgPSBvcHRpb25zLm1hcHBpbmdzO1xuICBcdHZhciBrZXk7XG4gIFx0dmFyIG1hcHBpbmc7XG5cbiAgXHQvLyBUT0RPIGlzIGl0IHBvc3NpYmxlIHRvIHJlbW92ZSB0aGlzIHJlZmVyZW5jZT9cbiAgXHR0aGlzLnJhY3RpdmUgPSByYWN0aXZlO1xuXG4gIFx0dGhpcy5hZGFwdG9ycyA9IGFkYXB0O1xuICBcdHRoaXMub25jaGFuZ2UgPSBvcHRpb25zLm9uY2hhbmdlO1xuXG4gIFx0dGhpcy5jYWNoZSA9IHt9OyAvLyB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gdXNlIGhhc093blByb3BlcnR5LCBzbyBjYW4ndCBpbmhlcml0IGZyb20gbnVsbFxuICBcdHRoaXMuY2FjaGVNYXAgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHR0aGlzLmRlcHMgPSB7XG4gIFx0XHRjb21wdXRlZDogY3JlYXRlKG51bGwpLFxuICBcdFx0XCJkZWZhdWx0XCI6IGNyZWF0ZShudWxsKVxuICBcdH07XG4gIFx0dGhpcy5kZXBzTWFwID0ge1xuICBcdFx0Y29tcHV0ZWQ6IGNyZWF0ZShudWxsKSxcbiAgXHRcdFwiZGVmYXVsdFwiOiBjcmVhdGUobnVsbClcbiAgXHR9O1xuXG4gIFx0dGhpcy5wYXR0ZXJuT2JzZXJ2ZXJzID0gW107XG5cbiAgXHR0aGlzLnNwZWNpYWxzID0gY3JlYXRlKG51bGwpO1xuXG4gIFx0dGhpcy53cmFwcGVkID0gY3JlYXRlKG51bGwpO1xuICBcdHRoaXMuY29tcHV0YXRpb25zID0gY3JlYXRlKG51bGwpO1xuXG4gIFx0dGhpcy5jYXB0dXJlR3JvdXBzID0gW107XG4gIFx0dGhpcy51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMgPSBbXTtcblxuICBcdHRoaXMuY2hhbmdlcyA9IFtdO1xuICBcdHRoaXMuaW1wbGljaXRDaGFuZ2VzID0ge307XG4gIFx0dGhpcy5ub0Nhc2NhZGUgPSB7fTtcblxuICBcdHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgXHQvLyBzZXQgdXAgZXhwbGljaXQgbWFwcGluZ3NcbiAgXHR0aGlzLm1hcHBpbmdzID0gY3JlYXRlKG51bGwpO1xuICBcdGZvciAoa2V5IGluIG1hcHBpbmdzKSB7XG4gIFx0XHR0aGlzLm1hcChnZXRLZXlwYXRoKGtleSksIG1hcHBpbmdzW2tleV0pO1xuICBcdH1cblxuICBcdGlmIChkYXRhKSB7XG4gIFx0XHQvLyBpZiBkYXRhIGV4aXN0cyBsb2NhbGx5LCBidXQgaXMgbWlzc2luZyBvbiB0aGUgcGFyZW50LFxuICBcdFx0Ly8gd2UgdHJhbnNmZXIgb3duZXJzaGlwIHRvIHRoZSBwYXJlbnRcbiAgXHRcdGZvciAoa2V5IGluIGRhdGEpIHtcbiAgXHRcdFx0aWYgKChtYXBwaW5nID0gdGhpcy5tYXBwaW5nc1trZXldKSAmJiBtYXBwaW5nLmdldFZhbHVlKCkgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdG1hcHBpbmcuc2V0VmFsdWUoZGF0YVtrZXldKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdGZvciAoa2V5IGluIGNvbXB1dGVkKSB7XG4gIFx0XHRpZiAobWFwcGluZ3MgJiYga2V5IGluIG1hcHBpbmdzKSB7XG4gIFx0XHRcdGZhdGFsKFwiQ2Fubm90IG1hcCB0byBhIGNvbXB1dGVkIHByb3BlcnR5ICgnJXMnKVwiLCBrZXkpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmNvbXB1dGUoZ2V0S2V5cGF0aChrZXkpLCBjb21wdXRlZFtrZXldKTtcbiAgXHR9XG5cbiAgXHR0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgfTtcblxuICBWaWV3bW9kZWwucHJvdG90eXBlID0ge1xuICBcdGFkYXB0OiBwcm90b3R5cGVfYWRhcHQsXG4gIFx0YXBwbHlDaGFuZ2VzOiBhcHBseUNoYW5nZXMsXG4gIFx0Y2FwdHVyZTogY2FwdHVyZSxcbiAgXHRjbGVhckNhY2hlOiBjbGVhckNhY2hlLFxuICBcdGNvbXB1dGU6IGNvbXB1dGUsXG4gIFx0Z2V0OiB2aWV3bW9kZWxfcHJvdG90eXBlX2dldCxcbiAgXHRpbml0OiB2aWV3bW9kZWxfcHJvdG90eXBlX2luaXQsXG4gIFx0bWFwOiBwcm90b3R5cGVfbWFwLFxuICBcdG1hcms6IG1hcmssXG4gIFx0bWVyZ2U6IG1lcmdlLFxuICBcdHJlZ2lzdGVyOiByZWdpc3RlcixcbiAgXHRyZWxlYXNlOiByZWxlYXNlLFxuICBcdHJlc2V0OiByZXNldCxcbiAgXHRzZXQ6IHByb3RvdHlwZV9zZXQsXG4gIFx0c21hcnRVcGRhdGU6IHNtYXJ0VXBkYXRlLFxuICBcdHRlYXJkb3duOiBwcm90b3R5cGVfdGVhcmRvd24sXG4gIFx0dW5yZWdpc3RlcjogdW5yZWdpc3RlclxuICB9O1xuXG4gIHZhciB2aWV3bW9kZWxfVmlld21vZGVsID0gVmlld21vZGVsO1xuXG4gIGZ1bmN0aW9uIEhvb2tRdWV1ZShldmVudCkge1xuICBcdHRoaXMuaG9vayA9IG5ldyBob29rc19Ib29rKGV2ZW50KTtcbiAgXHR0aGlzLmluUHJvY2VzcyA9IHt9O1xuICBcdHRoaXMucXVldWUgPSB7fTtcbiAgfVxuXG4gIEhvb2tRdWV1ZS5wcm90b3R5cGUgPSB7XG5cbiAgXHRjb25zdHJ1Y3RvcjogSG9va1F1ZXVlLFxuXG4gIFx0YmVnaW46IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG4gIFx0XHR0aGlzLmluUHJvY2Vzc1tyYWN0aXZlLl9ndWlkXSA9IHRydWU7XG4gIFx0fSxcblxuICBcdGVuZDogZnVuY3Rpb24gKHJhY3RpdmUpIHtcblxuICBcdFx0dmFyIHBhcmVudCA9IHJhY3RpdmUucGFyZW50O1xuXG4gIFx0XHQvLyBJZiB0aGlzIGlzICppc24ndCogYSBjaGlsZCBvZiBhIGNvbXBvbmVudCB0aGF0J3MgaW4gcHJvY2VzcyxcbiAgXHRcdC8vIGl0IHNob3VsZCBjYWxsIG1ldGhvZHMgb3IgZmlyZSBhdCB0aGlzIHBvaW50XG4gIFx0XHRpZiAoIXBhcmVudCB8fCAhdGhpcy5pblByb2Nlc3NbcGFyZW50Ll9ndWlkXSkge1xuICBcdFx0XHRmaXJlKHRoaXMsIHJhY3RpdmUpO1xuICBcdFx0fVxuICBcdFx0Ly8gZWxzZXdpc2UsIGhhbmRvZmYgdG8gcGFyZW50IHRvIGZpcmUgd2hlbiByZWFkeVxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdGdldENoaWxkUXVldWUodGhpcy5xdWV1ZSwgcGFyZW50KS5wdXNoKHJhY3RpdmUpO1xuICBcdFx0fVxuXG4gIFx0XHRkZWxldGUgdGhpcy5pblByb2Nlc3NbcmFjdGl2ZS5fZ3VpZF07XG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldENoaWxkUXVldWUocXVldWUsIHJhY3RpdmUpIHtcbiAgXHRyZXR1cm4gcXVldWVbcmFjdGl2ZS5fZ3VpZF0gfHwgKHF1ZXVlW3JhY3RpdmUuX2d1aWRdID0gW10pO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZShob29rUXVldWUsIHJhY3RpdmUpIHtcblxuICBcdHZhciBjaGlsZFF1ZXVlID0gZ2V0Q2hpbGRRdWV1ZShob29rUXVldWUucXVldWUsIHJhY3RpdmUpO1xuXG4gIFx0aG9va1F1ZXVlLmhvb2suZmlyZShyYWN0aXZlKTtcblxuICBcdC8vIHF1ZXVlIGlzIFwibGl2ZVwiIGJlY2F1c2UgY29tcG9uZW50cyBjYW4gZW5kIHVwIGJlaW5nXG4gIFx0Ly8gYWRkZWQgd2hpbGUgaG9va3MgZmlyZSBvbiBwYXJlbnRzIHRoYXQgbW9kaWZ5IGRhdGEgdmFsdWVzLlxuICBcdHdoaWxlIChjaGlsZFF1ZXVlLmxlbmd0aCkge1xuICBcdFx0ZmlyZShob29rUXVldWUsIGNoaWxkUXVldWUuc2hpZnQoKSk7XG4gIFx0fVxuXG4gIFx0ZGVsZXRlIGhvb2tRdWV1ZS5xdWV1ZVtyYWN0aXZlLl9ndWlkXTtcbiAgfVxuXG4gIHZhciBob29rc19Ib29rUXVldWUgPSBIb29rUXVldWU7XG5cbiAgdmFyIGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzID0gZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzO1xuXG4gIHZhciBoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlc19fcGF0dGVybiA9IC9cXCRcXHsoW15cXH1dKylcXH0vZztcbiAgZnVuY3Rpb24gZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzKHJhY3RpdmUsIGNvbXB1dGVkKSB7XG4gIFx0dmFyIHNpZ25hdHVyZXMgPSB7fSxcbiAgXHQgICAga2V5O1xuXG4gIFx0Zm9yIChrZXkgaW4gY29tcHV0ZWQpIHtcbiAgXHRcdHNpZ25hdHVyZXNba2V5XSA9IGdldENvbXB1dGF0aW9uU2lnbmF0dXJlKHJhY3RpdmUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHNpZ25hdHVyZXM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb21wdXRhdGlvblNpZ25hdHVyZShyYWN0aXZlLCBrZXksIHNpZ25hdHVyZSkge1xuICBcdHZhciBnZXR0ZXIsIHNldHRlcjtcblxuICBcdGlmICh0eXBlb2Ygc2lnbmF0dXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdGdldHRlciA9IGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzX19iaW5kKHNpZ25hdHVyZSwgcmFjdGl2ZSk7XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiBzaWduYXR1cmUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGdldHRlciA9IGNyZWF0ZUZ1bmN0aW9uRnJvbVN0cmluZyhyYWN0aXZlLCBzaWduYXR1cmUpO1xuICBcdH1cblxuICBcdGlmICh0eXBlb2Ygc2lnbmF0dXJlID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRpZiAodHlwZW9mIHNpZ25hdHVyZS5nZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0Z2V0dGVyID0gY3JlYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKHJhY3RpdmUsIHNpZ25hdHVyZS5nZXQpO1xuICBcdFx0fSBlbHNlIGlmICh0eXBlb2Ygc2lnbmF0dXJlLmdldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdGdldHRlciA9IGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzX19iaW5kKHNpZ25hdHVyZS5nZXQsIHJhY3RpdmUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZmF0YWwoXCJgJXNgIGNvbXB1dGF0aW9uIG11c3QgaGF2ZSBhIGBnZXQoKWAgbWV0aG9kXCIsIGtleSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0eXBlb2Ygc2lnbmF0dXJlLnNldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdHNldHRlciA9IGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzX19iaW5kKHNpZ25hdHVyZS5zZXQsIHJhY3RpdmUpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB7IGdldHRlcjogZ2V0dGVyLCBzZXR0ZXI6IHNldHRlciB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKHJhY3RpdmUsIHN0cikge1xuICBcdHZhciBmdW5jdGlvbkJvZHksIGhhc1RoaXMsIGZuO1xuXG4gIFx0ZnVuY3Rpb25Cb2R5ID0gXCJyZXR1cm4gKFwiICsgc3RyLnJlcGxhY2UoaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX3BhdHRlcm4sIGZ1bmN0aW9uIChtYXRjaCwga2V5cGF0aCkge1xuICBcdFx0aGFzVGhpcyA9IHRydWU7XG4gIFx0XHRyZXR1cm4gXCJfX3JhY3RpdmUuZ2V0KFxcXCJcIiArIGtleXBhdGggKyBcIlxcXCIpXCI7XG4gIFx0fSkgKyBcIik7XCI7XG5cbiAgXHRpZiAoaGFzVGhpcykge1xuICBcdFx0ZnVuY3Rpb25Cb2R5ID0gXCJ2YXIgX19yYWN0aXZlID0gdGhpczsgXCIgKyBmdW5jdGlvbkJvZHk7XG4gIFx0fVxuXG4gIFx0Zm4gPSBuZXcgRnVuY3Rpb24oZnVuY3Rpb25Cb2R5KTtcbiAgXHRyZXR1cm4gaGFzVGhpcyA/IGZuLmJpbmQocmFjdGl2ZSkgOiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzX19iaW5kKGZuLCBjb250ZXh0KSB7XG4gIFx0cmV0dXJuIC90aGlzLy50ZXN0KGZuLnRvU3RyaW5nKCkpID8gZm4uYmluZChjb250ZXh0KSA6IGZuO1xuICB9XG5cbiAgdmFyIGNvbnN0cnVjdEhvb2sgPSBuZXcgaG9va3NfSG9vayhcImNvbnN0cnVjdFwiKTtcbiAgdmFyIGNvbmZpZ0hvb2sgPSBuZXcgaG9va3NfSG9vayhcImNvbmZpZ1wiKTtcbiAgdmFyIGluaXRIb29rID0gbmV3IGhvb2tzX0hvb2tRdWV1ZShcImluaXRcIik7XG4gIHZhciBpbml0aWFsaXNlX191aWQgPSAwO1xuXG4gIHZhciBpbml0aWFsaXNlX19yZWdpc3RyeU5hbWVzID0gW1wiYWRhcHRvcnNcIiwgXCJjb21wb25lbnRzXCIsIFwiZGVjb3JhdG9yc1wiLCBcImVhc2luZ1wiLCBcImV2ZW50c1wiLCBcImludGVycG9sYXRvcnNcIiwgXCJwYXJ0aWFsc1wiLCBcInRyYW5zaXRpb25zXCJdO1xuXG4gIHZhciBpbml0aWFsaXNlID0gaW5pdGlhbGlzZVJhY3RpdmVJbnN0YW5jZTtcblxuICBmdW5jdGlvbiBpbml0aWFsaXNlUmFjdGl2ZUluc3RhbmNlKHJhY3RpdmUpIHtcbiAgXHR2YXIgdXNlck9wdGlvbnMgPSBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuICBcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1syXTtcblxuICBcdHZhciBlbCwgdmlld21vZGVsO1xuXG4gIFx0aWYgKF9SYWN0aXZlLkRFQlVHKSB7XG4gIFx0XHR3ZWxjb21lKCk7XG4gIFx0fVxuXG4gIFx0aW5pdGlhbGlzZVByb3BlcnRpZXMocmFjdGl2ZSwgb3B0aW9ucyk7XG5cbiAgXHQvLyBUT0RPIHJlbW92ZSB0aGlzLCBldmVudHVhbGx5XG4gIFx0ZGVmaW5lUHJvcGVydHkocmFjdGl2ZSwgXCJkYXRhXCIsIHsgZ2V0OiBkZXByZWNhdGVSYWN0aXZlRGF0YSB9KTtcblxuICBcdC8vIFRPRE8gZG9uJ3QgYWxsb3cgYG9uY29uc3RydWN0YCB3aXRoIGBuZXcgUmFjdGl2ZSgpYCwgdGhlcmUncyBubyBuZWVkIGZvciBpdFxuICBcdGNvbnN0cnVjdEhvb2suZmlyZShyYWN0aXZlLCB1c2VyT3B0aW9ucyk7XG5cbiAgXHQvLyBBZGQgcmVnaXN0cmllc1xuICBcdGluaXRpYWxpc2VfX3JlZ2lzdHJ5TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0cmFjdGl2ZVtuYW1lXSA9IHV0aWxzX29iamVjdF9fZXh0ZW5kKGNyZWF0ZShyYWN0aXZlLmNvbnN0cnVjdG9yW25hbWVdIHx8IG51bGwpLCB1c2VyT3B0aW9uc1tuYW1lXSk7XG4gIFx0fSk7XG5cbiAgXHQvLyBDcmVhdGUgYSB2aWV3bW9kZWxcbiAgXHR2aWV3bW9kZWwgPSBuZXcgdmlld21vZGVsX1ZpZXdtb2RlbCh7XG4gIFx0XHRhZGFwdDogZ2V0QWRhcHRvcnMocmFjdGl2ZSwgcmFjdGl2ZS5hZGFwdCwgdXNlck9wdGlvbnMpLFxuICBcdFx0ZGF0YTogY3VzdG9tX2RhdGEuaW5pdChyYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCB1c2VyT3B0aW9ucyksXG4gIFx0XHRjb21wdXRlZDogaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXMocmFjdGl2ZSwgdXRpbHNfb2JqZWN0X19leHRlbmQoY3JlYXRlKHJhY3RpdmUuY29uc3RydWN0b3IucHJvdG90eXBlLmNvbXB1dGVkKSwgdXNlck9wdGlvbnMuY29tcHV0ZWQpKSxcbiAgXHRcdG1hcHBpbmdzOiBvcHRpb25zLm1hcHBpbmdzLFxuICBcdFx0cmFjdGl2ZTogcmFjdGl2ZSxcbiAgXHRcdG9uY2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiBnbG9iYWxfcnVubG9vcC5hZGRSYWN0aXZlKHJhY3RpdmUpO1xuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0cmFjdGl2ZS52aWV3bW9kZWwgPSB2aWV3bW9kZWw7XG5cbiAgXHQvLyBUaGlzIGNhbid0IGhhcHBlbiBlYXJsaWVyLCBiZWNhdXNlIGNvbXB1dGVkIHByb3BlcnRpZXMgbWF5IGNhbGwgYHJhY3RpdmUuZ2V0KClgLCBldGNcbiAgXHR2aWV3bW9kZWwuaW5pdCgpO1xuXG4gIFx0Ly8gaW5pdCBjb25maWcgZnJvbSBQYXJlbnQgYW5kIG9wdGlvbnNcbiAgXHRjb25maWdfY29uZmlnLmluaXQocmFjdGl2ZS5jb25zdHJ1Y3RvciwgcmFjdGl2ZSwgdXNlck9wdGlvbnMpO1xuXG4gIFx0Y29uZmlnSG9vay5maXJlKHJhY3RpdmUpO1xuICBcdGluaXRIb29rLmJlZ2luKHJhY3RpdmUpO1xuXG4gIFx0Ly8gLy8gSWYgdGhpcyBpcyBhIGNvbXBvbmVudCB3aXRoIGEgZnVuY3Rpb24gYGRhdGFgIHByb3BlcnR5LCBjYWxsIHRoZSBmdW5jdGlvblxuICBcdC8vIC8vIHdpdGggYHJhY3RpdmVgIGFzIGNvbnRleHQgKHVubGVzcyB0aGUgY2hpbGQgd2FzIGFsc28gYSBmdW5jdGlvbilcbiAgXHQvLyBpZiAoIHR5cGVvZiByYWN0aXZlLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5kYXRhID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB1c2VyT3B0aW9ucy5kYXRhICE9PSAnZnVuY3Rpb24nICkge1xuICBcdC8vIFx0dmlld21vZGVsLnJlc2V0KCByYWN0aXZlLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5kYXRhLmNhbGwoIHJhY3RpdmUgKSB8fCBmYXRhbCggJ2BkYXRhYCBmdW5jdGlvbnMgbXVzdCByZXR1cm4gYSBkYXRhIG9iamVjdCcgKSApO1xuICBcdC8vIH1cblxuICBcdC8vIFJlbmRlciB2aXJ0dWFsIERPTVxuICBcdGlmIChyYWN0aXZlLnRlbXBsYXRlKSB7XG4gIFx0XHR2YXIgY3NzSWRzID0gdW5kZWZpbmVkO1xuXG4gIFx0XHRpZiAob3B0aW9ucy5jc3NJZHMgfHwgcmFjdGl2ZS5jc3NJZCkge1xuICBcdFx0XHRjc3NJZHMgPSBvcHRpb25zLmNzc0lkcyA/IG9wdGlvbnMuY3NzSWRzLnNsaWNlKCkgOiBbXTtcblxuICBcdFx0XHRpZiAocmFjdGl2ZS5jc3NJZCkge1xuICBcdFx0XHRcdGNzc0lkcy5wdXNoKHJhY3RpdmUuY3NzSWQpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJhY3RpdmUuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiByYWN0aXZlLnRlbXBsYXRlLFxuICBcdFx0XHRyb290OiByYWN0aXZlLFxuICBcdFx0XHRvd25lcjogcmFjdGl2ZSwgLy8gc2F2ZXMgZG9pbmcgYGlmICggdGhpcy5wYXJlbnQgKSB7IC8qLi4uKi8gfWAgbGF0ZXIgb25cbiAgXHRcdFx0Y3NzSWRzOiBjc3NJZHNcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdGluaXRIb29rLmVuZChyYWN0aXZlKTtcblxuICBcdC8vIHJlbmRlciBhdXRvbWF0aWNhbGx5ICggaWYgYGVsYCBpcyBzcGVjaWZpZWQgKVxuICBcdGlmIChlbCA9IGdldEVsZW1lbnQocmFjdGl2ZS5lbCkpIHtcbiAgXHRcdHZhciBwcm9taXNlID0gcmFjdGl2ZS5yZW5kZXIoZWwsIHJhY3RpdmUuYXBwZW5kKTtcblxuICBcdFx0aWYgKF9SYWN0aXZlLkRFQlVHX1BST01JU0VTKSB7XG4gIFx0XHRcdHByb21pc2VbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gIFx0XHRcdFx0d2Fybk9uY2VJZkRlYnVnKFwiUHJvbWlzZSBkZWJ1Z2dpbmcgaXMgZW5hYmxlZCwgdG8gaGVscCBzb2x2ZSBlcnJvcnMgdGhhdCBoYXBwZW4gYXN5bmNocm9ub3VzbHkuIFNvbWUgYnJvd3NlcnMgd2lsbCBsb2cgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9ucywgaW4gd2hpY2ggY2FzZSB5b3UgY2FuIHNhZmVseSBkaXNhYmxlIHByb21pc2UgZGVidWdnaW5nOlxcbiAgUmFjdGl2ZS5ERUJVR19QUk9NSVNFUyA9IGZhbHNlO1wiKTtcbiAgXHRcdFx0XHR3YXJuSWZEZWJ1ZyhcIkFuIGVycm9yIGhhcHBlbmVkIGR1cmluZyByZW5kZXJpbmdcIiwgeyByYWN0aXZlOiByYWN0aXZlIH0pO1xuICBcdFx0XHRcdGVyci5zdGFjayAmJiBsb2dJZkRlYnVnKGVyci5zdGFjayk7XG5cbiAgXHRcdFx0XHR0aHJvdyBlcnI7XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFkYXB0b3JzKHJhY3RpdmUsIHByb3RvQWRhcHQsIHVzZXJPcHRpb25zKSB7XG4gIFx0dmFyIGFkYXB0LCBtYWdpYywgbW9kaWZ5QXJyYXlzO1xuXG4gIFx0cHJvdG9BZGFwdCA9IHByb3RvQWRhcHQubWFwKGxvb2t1cCk7XG4gIFx0YWRhcHQgPSBlbnN1cmVBcnJheSh1c2VyT3B0aW9ucy5hZGFwdCkubWFwKGxvb2t1cCk7XG5cbiAgXHRhZGFwdCA9IGluaXRpYWxpc2VfX2NvbWJpbmUocHJvdG9BZGFwdCwgYWRhcHQpO1xuXG4gIFx0bWFnaWMgPSBcIm1hZ2ljXCIgaW4gdXNlck9wdGlvbnMgPyB1c2VyT3B0aW9ucy5tYWdpYyA6IHJhY3RpdmUubWFnaWM7XG4gIFx0bW9kaWZ5QXJyYXlzID0gXCJtb2RpZnlBcnJheXNcIiBpbiB1c2VyT3B0aW9ucyA/IHVzZXJPcHRpb25zLm1vZGlmeUFycmF5cyA6IHJhY3RpdmUubW9kaWZ5QXJyYXlzO1xuXG4gIFx0aWYgKG1hZ2ljKSB7XG4gIFx0XHRpZiAoIWVudmlyb25tZW50X19tYWdpYykge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJHZXR0ZXJzIGFuZCBzZXR0ZXJzIChtYWdpYyBtb2RlKSBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChtb2RpZnlBcnJheXMpIHtcbiAgXHRcdFx0YWRhcHQucHVzaChtYWdpY0FycmF5KTtcbiAgXHRcdH1cblxuICBcdFx0YWRhcHQucHVzaChhZGFwdG9yc19tYWdpYyk7XG4gIFx0fVxuXG4gIFx0aWYgKG1vZGlmeUFycmF5cykge1xuICBcdFx0YWRhcHQucHVzaChhcnJheV9pbmRleCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGFkYXB0O1xuXG4gIFx0ZnVuY3Rpb24gbG9va3VwKGFkYXB0b3IpIHtcbiAgXHRcdGlmICh0eXBlb2YgYWRhcHRvciA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRhZGFwdG9yID0gZmluZEluVmlld0hpZXJhcmNoeShcImFkYXB0b3JzXCIsIHJhY3RpdmUsIGFkYXB0b3IpO1xuXG4gIFx0XHRcdGlmICghYWRhcHRvcikge1xuICBcdFx0XHRcdGZhdGFsKG1pc3NpbmdQbHVnaW4oYWRhcHRvciwgXCJhZGFwdG9yXCIpKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gYWRhcHRvcjtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXNlX19jb21iaW5lKGEsIGIpIHtcbiAgXHR2YXIgYyA9IGEuc2xpY2UoKSxcbiAgXHQgICAgaSA9IGIubGVuZ3RoO1xuXG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKCEgfmMuaW5kZXhPZihiW2ldKSkge1xuICBcdFx0XHRjLnB1c2goYltpXSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGM7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXNlUHJvcGVydGllcyhyYWN0aXZlLCBvcHRpb25zKSB7XG4gIFx0Ly8gR2VuZXJhdGUgYSB1bmlxdWUgaWRlbnRpZmllciwgZm9yIHBsYWNlcyB3aGVyZSB5b3UnZCB1c2UgYSB3ZWFrIG1hcCBpZiBpdFxuICBcdC8vIGV4aXN0ZWRcbiAgXHRyYWN0aXZlLl9ndWlkID0gXCJyLVwiICsgaW5pdGlhbGlzZV9fdWlkKys7XG5cbiAgXHQvLyBldmVudHNcbiAgXHRyYWN0aXZlLl9zdWJzID0gY3JlYXRlKG51bGwpO1xuXG4gIFx0Ly8gc3RvcmFnZSBmb3IgaXRlbSBjb25maWd1cmF0aW9uIGZyb20gaW5zdGFudGlhdGlvbiB0byByZXNldCxcbiAgXHQvLyBsaWtlIGR5bmFtaWMgZnVuY3Rpb25zIG9yIG9yaWdpbmFsIHZhbHVlc1xuICBcdHJhY3RpdmUuX2NvbmZpZyA9IHt9O1xuXG4gIFx0Ly8gdHdvLXdheSBiaW5kaW5nc1xuICBcdHJhY3RpdmUuX3R3b3dheUJpbmRpbmdzID0gY3JlYXRlKG51bGwpO1xuXG4gIFx0Ly8gYW5pbWF0aW9ucyAoc28gd2UgY2FuIHN0b3AgYW55IGluIHByb2dyZXNzIGF0IHRlYXJkb3duKVxuICBcdHJhY3RpdmUuX2FuaW1hdGlvbnMgPSBbXTtcblxuICBcdC8vIG5vZGVzIHJlZ2lzdHJ5XG4gIFx0cmFjdGl2ZS5ub2RlcyA9IHt9O1xuXG4gIFx0Ly8gbGl2ZSBxdWVyaWVzXG4gIFx0cmFjdGl2ZS5fbGl2ZVF1ZXJpZXMgPSBbXTtcbiAgXHRyYWN0aXZlLl9saXZlQ29tcG9uZW50UXVlcmllcyA9IFtdO1xuXG4gIFx0Ly8gYm91bmQgZGF0YSBmdW5jdGlvbnNcbiAgXHRyYWN0aXZlLl9ib3VuZEZ1bmN0aW9ucyA9IFtdO1xuXG4gIFx0Ly8gb2JzZXJ2ZXJzXG4gIFx0cmFjdGl2ZS5fb2JzZXJ2ZXJzID0gW107XG5cbiAgXHQvLyBwcm9wZXJ0aWVzIHNwZWNpZmljIHRvIGlubGluZSBjb21wb25lbnRzXG4gIFx0aWYgKG9wdGlvbnMuY29tcG9uZW50KSB7XG4gIFx0XHRyYWN0aXZlLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBcdFx0cmFjdGl2ZS5jb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciB8fCBudWxsO1xuICBcdFx0cmFjdGl2ZS5yb290ID0gcmFjdGl2ZS5wYXJlbnQucm9vdDtcblxuICBcdFx0cmFjdGl2ZS5jb21wb25lbnQgPSBvcHRpb25zLmNvbXBvbmVudDtcbiAgXHRcdG9wdGlvbnMuY29tcG9uZW50Lmluc3RhbmNlID0gcmFjdGl2ZTtcblxuICBcdFx0Ly8gZm9yIGhhY2thYmlsaXR5LCB0aGlzIGNvdWxkIGJlIGFuIG9wZW4gb3B0aW9uXG4gIFx0XHQvLyBmb3IgYW55IHJhY3RpdmUgaW5zdGFuY2UsIGJ1dCBmb3Igbm93LCBqdXN0XG4gIFx0XHQvLyBmb3IgY29tcG9uZW50cyBhbmQganVzdCBmb3IgcmFjdGl2ZS4uLlxuICBcdFx0cmFjdGl2ZS5faW5saW5lUGFydGlhbHMgPSBvcHRpb25zLmlubGluZVBhcnRpYWxzO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyYWN0aXZlLnJvb3QgPSByYWN0aXZlO1xuICBcdFx0cmFjdGl2ZS5wYXJlbnQgPSByYWN0aXZlLmNvbnRhaW5lciA9IG51bGw7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZGVwcmVjYXRlUmFjdGl2ZURhdGEoKSB7XG4gIFx0dGhyb3cgbmV3IEVycm9yKFwiVXNpbmcgYHJhY3RpdmUuZGF0YWAgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCAtIHlvdSBtdXN0IHVzZSB0aGUgYHJhY3RpdmUuZ2V0KClgIEFQSSBpbnN0ZWFkXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29tcGxleFBhcmFtZXRlcihjb21wb25lbnQsIHRlbXBsYXRlLCBjYWxsYmFjaykge1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgXHRcdHJvb3Q6IGNvbXBvbmVudC5yb290LFxuICBcdFx0b3duZXI6IHRoaXNcbiAgXHR9KTtcblxuICBcdHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICB2YXIgaW5pdGlhbGlzZV9Db21wbGV4UGFyYW1ldGVyID0gQ29tcGxleFBhcmFtZXRlcjtcblxuICBDb21wbGV4UGFyYW1ldGVyLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5kaXJ0eSkge1xuICBcdFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmNhbGxiYWNrKHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKSk7XG4gIFx0XHR0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBjcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIENvbXBvbmVudCwgYXR0cmlidXRlcywgeWllbGRUZW1wbGF0ZSwgcGFydGlhbHMpIHtcbiAgXHR2YXIgaW5zdGFuY2UsXG4gIFx0ICAgIHBhcmVudEZyYWdtZW50LFxuICBcdCAgICByYWN0aXZlLFxuICBcdCAgICBmcmFnbWVudCxcbiAgXHQgICAgY29udGFpbmVyLFxuICBcdCAgICBpbmxpbmVQYXJ0aWFscyA9IHt9LFxuICBcdCAgICBkYXRhID0ge30sXG4gIFx0ICAgIG1hcHBpbmdzID0ge30sXG4gIFx0ICAgIHJlYWR5LFxuICBcdCAgICByZXNvbHZlcnMgPSBbXTtcblxuICBcdHBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuICBcdHJhY3RpdmUgPSBjb21wb25lbnQucm9vdDtcblxuICBcdHBhcnRpYWxzID0gcGFydGlhbHMgfHwge307XG4gIFx0dXRpbHNfb2JqZWN0X19leHRlbmQoaW5saW5lUGFydGlhbHMsIHBhcnRpYWxzKTtcblxuICBcdC8vIE1ha2UgY29udGVudHMgYXZhaWxhYmxlIGFzIGEge3s+Y29udGVudH19IHBhcnRpYWxcbiAgXHRwYXJ0aWFscy5jb250ZW50ID0geWllbGRUZW1wbGF0ZSB8fCBbXTtcblxuICBcdC8vIHNldCBhIGRlZmF1bHQgcGFydGlhbCBmb3IgeWllbGRzIHdpdGggbm8gbmFtZVxuICBcdGlubGluZVBhcnRpYWxzW1wiXCJdID0gcGFydGlhbHMuY29udGVudDtcblxuICBcdGlmIChDb21wb25lbnQuZGVmYXVsdHMuZWwpIHtcbiAgXHRcdHdhcm5JZkRlYnVnKFwiVGhlIDwlcy8+IGNvbXBvbmVudCBoYXMgYSBkZWZhdWx0IGBlbGAgcHJvcGVydHk7IGl0IGhhcyBiZWVuIGRpc3JlZ2FyZGVkXCIsIGNvbXBvbmVudC5uYW1lKTtcbiAgXHR9XG5cbiAgXHQvLyBmaW5kIGNvbnRhaW5lclxuICBcdGZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG4gIFx0d2hpbGUgKGZyYWdtZW50KSB7XG4gIFx0XHRpZiAoZnJhZ21lbnQub3duZXIudHlwZSA9PT0gWUlFTERFUikge1xuICBcdFx0XHRjb250YWluZXIgPSBmcmFnbWVudC5vd25lci5jb250YWluZXI7XG4gIFx0XHRcdGJyZWFrO1xuICBcdFx0fVxuXG4gIFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudDtcbiAgXHR9XG5cbiAgXHQvLyBlYWNoIGF0dHJpYnV0ZSByZXByZXNlbnRzIGVpdGhlciBhKSBkYXRhIG9yIGIpIGEgbWFwcGluZ1xuICBcdGlmIChhdHRyaWJ1dGVzKSB7XG4gIFx0XHRPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5XSxcbiAgXHRcdFx0ICAgIHBhcnNlZCxcbiAgXHRcdFx0ICAgIHJlc29sdmVyO1xuXG4gIFx0XHRcdGlmICh0eXBlb2YgYXR0cmlidXRlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdFx0Ly8gaXQncyBzdGF0aWMgZGF0YVxuICBcdFx0XHRcdHBhcnNlZCA9IHBhcnNlSlNPTihhdHRyaWJ1dGUpO1xuICBcdFx0XHRcdGRhdGFba2V5XSA9IHBhcnNlZCA/IHBhcnNlZC52YWx1ZSA6IGF0dHJpYnV0ZTtcbiAgXHRcdFx0fSBlbHNlIGlmIChhdHRyaWJ1dGUgPT09IDApIHtcbiAgXHRcdFx0XHQvLyBpdCBoYWQgbm8gJz0nLCBzbyB3ZSdsbCBjYWxsIGl0IHRydWVcbiAgXHRcdFx0XHRkYXRhW2tleV0gPSB0cnVlO1xuICBcdFx0XHR9IGVsc2UgaWYgKGlzQXJyYXkoYXR0cmlidXRlKSkge1xuICBcdFx0XHRcdC8vIHRoaXMgcmVwcmVzZW50cyBkeW5hbWljIGRhdGFcbiAgXHRcdFx0XHRpZiAoaXNTaW5nbGVJbnRlcnBvbGF0b3IoYXR0cmlidXRlKSkge1xuICBcdFx0XHRcdFx0bWFwcGluZ3Nba2V5XSA9IHtcbiAgXHRcdFx0XHRcdFx0b3JpZ2luOiBjb21wb25lbnQucm9vdC52aWV3bW9kZWwsXG4gIFx0XHRcdFx0XHRcdGtleXBhdGg6IHVuZGVmaW5lZFxuICBcdFx0XHRcdFx0fTtcblxuICBcdFx0XHRcdFx0cmVzb2x2ZXIgPSBjcmVhdGVSZXNvbHZlcihjb21wb25lbnQsIGF0dHJpYnV0ZVswXSwgZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0XHRcdFx0aWYgKGtleXBhdGguaXNTcGVjaWFsKSB7XG4gIFx0XHRcdFx0XHRcdFx0aWYgKHJlYWR5KSB7XG4gIFx0XHRcdFx0XHRcdFx0XHRpbnN0YW5jZS5zZXQoa2V5LCBrZXlwYXRoLnZhbHVlKTsgLy8gVE9ETyB1c2Ugdmlld21vZGVsP1xuICBcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdFx0XHRkYXRhW2tleV0gPSBrZXlwYXRoLnZhbHVlO1xuXG4gIFx0XHRcdFx0XHRcdFx0XHQvLyBUT0RPIGVycnIuLi4uIHdvdWxkIGJlIGJldHRlciBpZiB3ZSBkaWRuJ3QgaGF2ZSB0byBkbyB0aGlzXG4gIFx0XHRcdFx0XHRcdFx0XHRkZWxldGUgbWFwcGluZ3Nba2V5XTtcbiAgXHRcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdFx0aWYgKHJlYWR5KSB7XG4gIFx0XHRcdFx0XHRcdFx0XHRpbnN0YW5jZS52aWV3bW9kZWwubWFwcGluZ3Nba2V5XS5yZXNvbHZlKGtleXBhdGgpO1xuICBcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdFx0XHQvLyByZXNvbHZlZCBpbW1lZGlhdGVseVxuICBcdFx0XHRcdFx0XHRcdFx0bWFwcGluZ3Nba2V5XS5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHRcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRyZXNvbHZlciA9IG5ldyBpbml0aWFsaXNlX0NvbXBsZXhQYXJhbWV0ZXIoY29tcG9uZW50LCBhdHRyaWJ1dGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0XHRcdFx0XHRpZiAocmVhZHkpIHtcbiAgXHRcdFx0XHRcdFx0XHRpbnN0YW5jZS5zZXQoa2V5LCB2YWx1ZSk7IC8vIFRPRE8gdXNlIHZpZXdtb2RlbD9cbiAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRkYXRhW2tleV0gPSB2YWx1ZTtcbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0cmVzb2x2ZXJzLnB1c2gocmVzb2x2ZXIpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImVybSB3dXRcIik7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdGluc3RhbmNlID0gY3JlYXRlKENvbXBvbmVudC5wcm90b3R5cGUpO1xuXG4gIFx0aW5pdGlhbGlzZShpbnN0YW5jZSwge1xuICBcdFx0ZWw6IG51bGwsXG4gIFx0XHRhcHBlbmQ6IHRydWUsXG4gIFx0XHRkYXRhOiBkYXRhLFxuICBcdFx0cGFydGlhbHM6IHBhcnRpYWxzLFxuICBcdFx0bWFnaWM6IHJhY3RpdmUubWFnaWMgfHwgQ29tcG9uZW50LmRlZmF1bHRzLm1hZ2ljLFxuICBcdFx0bW9kaWZ5QXJyYXlzOiByYWN0aXZlLm1vZGlmeUFycmF5cyxcbiAgXHRcdC8vIG5lZWQgdG8gaW5oZXJpdCBydW50aW1lIHBhcmVudCBhZGFwdG9yc1xuICBcdFx0YWRhcHQ6IHJhY3RpdmUuYWRhcHRcbiAgXHR9LCB7XG4gIFx0XHRwYXJlbnQ6IHJhY3RpdmUsXG4gIFx0XHRjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgXHRcdGNvbnRhaW5lcjogY29udGFpbmVyLFxuICBcdFx0bWFwcGluZ3M6IG1hcHBpbmdzLFxuICBcdFx0aW5saW5lUGFydGlhbHM6IGlubGluZVBhcnRpYWxzLFxuICBcdFx0Y3NzSWRzOiBwYXJlbnRGcmFnbWVudC5jc3NJZHNcbiAgXHR9KTtcblxuICBcdHJlYWR5ID0gdHJ1ZTtcbiAgXHRjb21wb25lbnQucmVzb2x2ZXJzID0gcmVzb2x2ZXJzO1xuXG4gIFx0cmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlc29sdmVyKGNvbXBvbmVudCwgdGVtcGxhdGUsIGNhbGxiYWNrKSB7XG4gIFx0dmFyIHJlc29sdmVyO1xuXG4gIFx0aWYgKHRlbXBsYXRlLnIpIHtcbiAgXHRcdHJlc29sdmVyID0gUmVzb2x2ZXJzX2NyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKGNvbXBvbmVudCwgdGVtcGxhdGUuciwgY2FsbGJhY2spO1xuICBcdH0gZWxzZSBpZiAodGVtcGxhdGUueCkge1xuICBcdFx0cmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXJzX0V4cHJlc3Npb25SZXNvbHZlcihjb21wb25lbnQsIGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCwgdGVtcGxhdGUueCwgY2FsbGJhY2spO1xuICBcdH0gZWxzZSBpZiAodGVtcGxhdGUucngpIHtcbiAgXHRcdHJlc29sdmVyID0gbmV3IFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIoY29tcG9uZW50LCB0ZW1wbGF0ZS5yeCwgY2FsbGJhY2spO1xuICBcdH1cblxuICBcdHJldHVybiByZXNvbHZlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2luZ2xlSW50ZXJwb2xhdG9yKHRlbXBsYXRlKSB7XG4gIFx0cmV0dXJuIHRlbXBsYXRlLmxlbmd0aCA9PT0gMSAmJiB0ZW1wbGF0ZVswXS50ID09PSBJTlRFUlBPTEFUT1I7XG4gIH1cblxuICAvLyBUT0RPIGhvdyBzaG91bGQgZXZlbnQgYXJndW1lbnRzIGJlIGhhbmRsZWQ/IGUuZy5cbiAgLy8gPHdpZGdldCBvbi1mb289J2JhcjoxLDIsMycvPlxuICAvLyBUaGUgZXZlbnQgJ2Jhcicgd2lsbCBiZSBmaXJlZCBvbiB0aGUgcGFyZW50IGluc3RhbmNlXG4gIC8vIHdoZW4gJ2ZvbycgZmlyZXMgb24gdGhlIGNoaWxkLCBidXQgdGhlIDEsMiwzIGFyZ3VtZW50c1xuICAvLyB3aWxsIGJlIGxvc3RcblxuICB2YXIgaW5pdGlhbGlzZV9wcm9wYWdhdGVFdmVudHMgPSBwcm9wYWdhdGVFdmVudHM7XG5cbiAgZnVuY3Rpb24gcHJvcGFnYXRlRXZlbnRzKGNvbXBvbmVudCwgZXZlbnRzRGVzY3JpcHRvcikge1xuICBcdHZhciBldmVudE5hbWU7XG5cbiAgXHRmb3IgKGV2ZW50TmFtZSBpbiBldmVudHNEZXNjcmlwdG9yKSB7XG4gIFx0XHRpZiAoZXZlbnRzRGVzY3JpcHRvci5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gIFx0XHRcdHByb3BhZ2F0ZUV2ZW50KGNvbXBvbmVudC5pbnN0YW5jZSwgY29tcG9uZW50LnJvb3QsIGV2ZW50TmFtZSwgZXZlbnRzRGVzY3JpcHRvcltldmVudE5hbWVdKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9wYWdhdGVFdmVudChjaGlsZEluc3RhbmNlLCBwYXJlbnRJbnN0YW5jZSwgZXZlbnROYW1lLCBwcm94eUV2ZW50TmFtZSkge1xuICBcdGlmICh0eXBlb2YgcHJveHlFdmVudE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGZhdGFsKFwiQ29tcG9uZW50cyBjdXJyZW50bHkgb25seSBzdXBwb3J0IHNpbXBsZSBldmVudHMgLSB5b3UgY2Fubm90IGluY2x1ZGUgYXJndW1lbnRzLiBTb3JyeSFcIik7XG4gIFx0fVxuXG4gIFx0Y2hpbGRJbnN0YW5jZS5vbihldmVudE5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBldmVudCwgYXJncztcblxuICBcdFx0Ly8gc2VtaS13ZWFrIHRlc3QsIGJ1dCB3aGF0IGVsc2U/IHRhZyB0aGUgZXZlbnQgb2JqIC5faXNFdmVudCA/XG4gIFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMF0gJiYgYXJndW1lbnRzWzBdLm5vZGUpIHtcbiAgXHRcdFx0ZXZlbnQgPSBBcnJheS5wcm90b3R5cGUuc2hpZnQuY2FsbChhcmd1bWVudHMpO1xuICBcdFx0fVxuXG4gIFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBcdFx0c2hhcmVkX2ZpcmVFdmVudChwYXJlbnRJbnN0YW5jZSwgcHJveHlFdmVudE5hbWUsIHsgZXZlbnQ6IGV2ZW50LCBhcmdzOiBhcmdzIH0pO1xuXG4gIFx0XHQvLyBjYW5jZWwgYnViYmxpbmdcbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9KTtcbiAgfVxuXG4gIHZhciBpbml0aWFsaXNlX3VwZGF0ZUxpdmVRdWVyaWVzID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICBcdHZhciBhbmNlc3RvciwgcXVlcnk7XG5cbiAgXHQvLyBJZiB0aGVyZSdzIGEgbGl2ZSBxdWVyeSBmb3IgdGhpcyBjb21wb25lbnQgdHlwZSwgYWRkIGl0XG4gIFx0YW5jZXN0b3IgPSBjb21wb25lbnQucm9vdDtcbiAgXHR3aGlsZSAoYW5jZXN0b3IpIHtcbiAgXHRcdGlmIChxdWVyeSA9IGFuY2VzdG9yLl9saXZlQ29tcG9uZW50UXVlcmllc1tcIl9cIiArIGNvbXBvbmVudC5uYW1lXSkge1xuICBcdFx0XHRxdWVyeS5wdXNoKGNvbXBvbmVudC5pbnN0YW5jZSk7XG4gIFx0XHR9XG5cbiAgXHRcdGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICBcdH1cbiAgfTtcblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9pbml0ID0gQ29tcG9uZW50JGluaXQ7XG4gIGZ1bmN0aW9uIENvbXBvbmVudCRpbml0KG9wdGlvbnMsIENvbXBvbmVudCkge1xuICBcdHZhciBwYXJlbnRGcmFnbWVudCwgcm9vdDtcblxuICBcdGlmICghQ29tcG9uZW50KSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb21wb25lbnQgXFxcIlwiICsgdGhpcy5uYW1lICsgXCJcXFwiIG5vdCBmb3VuZFwiKTtcbiAgXHR9XG5cbiAgXHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuICBcdHJvb3QgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuXG4gIFx0dGhpcy5yb290ID0gcm9vdDtcbiAgXHR0aGlzLnR5cGUgPSBDT01QT05FTlQ7XG4gIFx0dGhpcy5uYW1lID0gb3B0aW9ucy50ZW1wbGF0ZS5lO1xuICBcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuICBcdHRoaXMuaW5kZXhSZWZCaW5kaW5ncyA9IHt9O1xuICBcdHRoaXMueWllbGRlcnMgPSB7fTtcbiAgXHR0aGlzLnJlc29sdmVycyA9IFtdO1xuXG4gIFx0Y3JlYXRlSW5zdGFuY2UodGhpcywgQ29tcG9uZW50LCBvcHRpb25zLnRlbXBsYXRlLmEsIG9wdGlvbnMudGVtcGxhdGUuZiwgb3B0aW9ucy50ZW1wbGF0ZS5wKTtcbiAgXHRpbml0aWFsaXNlX3Byb3BhZ2F0ZUV2ZW50cyh0aGlzLCBvcHRpb25zLnRlbXBsYXRlLnYpO1xuXG4gIFx0Ly8gaW50cm8sIG91dHJvIGFuZCBkZWNvcmF0b3IgZGlyZWN0aXZlcyBoYXZlIG5vIGVmZmVjdFxuICBcdGlmIChvcHRpb25zLnRlbXBsYXRlLnQwIHx8IG9wdGlvbnMudGVtcGxhdGUudDEgfHwgb3B0aW9ucy50ZW1wbGF0ZS50MiB8fCBvcHRpb25zLnRlbXBsYXRlLm8pIHtcbiAgXHRcdHdhcm5JZkRlYnVnKFwiVGhlIFxcXCJpbnRyb1xcXCIsIFxcXCJvdXRyb1xcXCIgYW5kIFxcXCJkZWNvcmF0b3JcXFwiIGRpcmVjdGl2ZXMgaGF2ZSBubyBlZmZlY3Qgb24gY29tcG9uZW50c1wiLCB7IHJhY3RpdmU6IHRoaXMuaW5zdGFuY2UgfSk7XG4gIFx0fVxuXG4gIFx0aW5pdGlhbGlzZV91cGRhdGVMaXZlUXVlcmllcyh0aGlzKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX3JlYmluZCA9IENvbXBvbmVudCRyZWJpbmQ7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JHJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0dmFyIHF1ZXJ5O1xuXG4gIFx0dGhpcy5yZXNvbHZlcnMuZm9yRWFjaChyZWJpbmQpO1xuXG4gIFx0Zm9yICh2YXIgayBpbiB0aGlzLnlpZWxkZXJzKSB7XG4gIFx0XHRpZiAodGhpcy55aWVsZGVyc1trXVswXSkge1xuICBcdFx0XHRyZWJpbmQodGhpcy55aWVsZGVyc1trXVswXSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHF1ZXJ5ID0gdGhpcy5yb290Ll9saXZlQ29tcG9uZW50UXVlcmllc1tcIl9cIiArIHRoaXMubmFtZV0pIHtcbiAgXHRcdHF1ZXJ5Ll9tYWtlRGlydHkoKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiByZWJpbmQoeCkge1xuICBcdFx0eC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfcmVuZGVyID0gQ29tcG9uZW50JHJlbmRlcjtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkcmVuZGVyKCkge1xuICBcdHZhciBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2U7XG5cbiAgXHRpbnN0YW5jZS5yZW5kZXIodGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCkpO1xuXG4gIFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0cmV0dXJuIGluc3RhbmNlLmZyYWdtZW50LmRldGFjaCgpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfdG9TdHJpbmcgPSBDb21wb25lbnQkdG9TdHJpbmc7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JHRvU3RyaW5nKCkge1xuICBcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV91bmJpbmQgPSBDb21wb25lbnQkdW5iaW5kO1xuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX3VuYmluZF9fdGVhcmRvd25Ib29rID0gbmV3IGhvb2tzX0hvb2soXCJ0ZWFyZG93blwiKTtcbiAgZnVuY3Rpb24gQ29tcG9uZW50JHVuYmluZCgpIHtcbiAgXHR2YXIgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlO1xuXG4gIFx0dGhpcy5yZXNvbHZlcnMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuXG4gIFx0cmVtb3ZlRnJvbUxpdmVDb21wb25lbnRRdWVyaWVzKHRoaXMpO1xuXG4gIFx0aW5zdGFuY2UuX29ic2VydmVycy5mb3JFYWNoKGNhbmNlbCk7XG5cbiAgXHQvLyB0ZWFyZG93biB0aGUgaW5zdGFuY2VcbiAgXHRpbnN0YW5jZS5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHRpbnN0YW5jZS52aWV3bW9kZWwudGVhcmRvd24oKTtcblxuICBcdGlmIChpbnN0YW5jZS5mcmFnbWVudC5yZW5kZXJlZCAmJiBpbnN0YW5jZS5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18pIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheShpbnN0YW5jZS5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIGluc3RhbmNlKTtcbiAgXHR9XG5cbiAgXHRDb21wb25lbnRfcHJvdG90eXBlX3VuYmluZF9fdGVhcmRvd25Ib29rLmZpcmUoaW5zdGFuY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRnJvbUxpdmVDb21wb25lbnRRdWVyaWVzKGNvbXBvbmVudCkge1xuICBcdHZhciBpbnN0YW5jZSwgcXVlcnk7XG5cbiAgXHRpbnN0YW5jZSA9IGNvbXBvbmVudC5yb290O1xuXG4gIFx0ZG8ge1xuICBcdFx0aWYgKHF1ZXJ5ID0gaW5zdGFuY2UuX2xpdmVDb21wb25lbnRRdWVyaWVzW1wiX1wiICsgY29tcG9uZW50Lm5hbWVdKSB7XG4gIFx0XHRcdHF1ZXJ5Ll9yZW1vdmUoY29tcG9uZW50KTtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlIChpbnN0YW5jZSA9IGluc3RhbmNlLnBhcmVudCk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV91bnJlbmRlciA9IENvbXBvbmVudCR1bnJlbmRlcjtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkdW5yZW5kZXIoc2hvdWxkRGVzdHJveSkge1xuICBcdHRoaXMuc2hvdWxkRGVzdHJveSA9IHNob3VsZERlc3Ryb3k7XG4gIFx0dGhpcy5pbnN0YW5jZS51bnJlbmRlcigpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uIChvcHRpb25zLCBDb25zdHJ1Y3Rvcikge1xuICBcdHRoaXMuaW5pdChvcHRpb25zLCBDb25zdHJ1Y3Rvcik7XG4gIH07XG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZSA9IHtcbiAgXHRkZXRhY2g6IENvbXBvbmVudF9wcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IENvbXBvbmVudF9wcm90b3R5cGVfZmluZCxcbiAgXHRmaW5kQWxsOiBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRBbGwsXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IENvbXBvbmVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kQ29tcG9uZW50LFxuICBcdGZpbmROZXh0Tm9kZTogQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kTmV4dE5vZGUsXG4gIFx0Zmlyc3ROb2RlOiBDb21wb25lbnRfcHJvdG90eXBlX2ZpcnN0Tm9kZSxcbiAgXHRpbml0OiBDb21wb25lbnRfcHJvdG90eXBlX2luaXQsXG4gIFx0cmViaW5kOiBDb21wb25lbnRfcHJvdG90eXBlX3JlYmluZCxcbiAgXHRyZW5kZXI6IENvbXBvbmVudF9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHRvU3RyaW5nOiBDb21wb25lbnRfcHJvdG90eXBlX3RvU3RyaW5nLFxuICBcdHVuYmluZDogQ29tcG9uZW50X3Byb3RvdHlwZV91bmJpbmQsXG4gIFx0dW5yZW5kZXI6IENvbXBvbmVudF9wcm90b3R5cGVfdW5yZW5kZXJcbiAgfTtcblxuICB2YXIgX0NvbXBvbmVudCA9IENvbXBvbmVudDtcblxuICB2YXIgQ29tbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy50eXBlID0gQ09NTUVOVDtcbiAgXHR0aGlzLnZhbHVlID0gb3B0aW9ucy50ZW1wbGF0ZS5jO1xuICB9O1xuXG4gIENvbW1lbnQucHJvdG90eXBlID0ge1xuICBcdGRldGFjaDogc2hhcmVkX2RldGFjaCxcblxuICBcdGZpcnN0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMubm9kZSkge1xuICBcdFx0XHR0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRoaXMudmFsdWUpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIFwiPCEtLVwiICsgdGhpcy52YWx1ZSArIFwiLS0+XCI7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0aWYgKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdFx0dGhpcy5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIGl0ZW1zX0NvbW1lbnQgPSBDb21tZW50O1xuXG4gIHZhciBZaWVsZGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR2YXIgY29udGFpbmVyLCBjb21wb25lbnQ7XG5cbiAgXHR0aGlzLnR5cGUgPSBZSUVMREVSO1xuXG4gIFx0dGhpcy5jb250YWluZXIgPSBjb250YWluZXIgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50LnJvb3Q7XG4gIFx0dGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQgPSBjb250YWluZXIuY29tcG9uZW50O1xuXG4gIFx0dGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gIFx0dGhpcy5jb250YWluZXJGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblxuICBcdHZhciBuYW1lID0gdGhpcy5uYW1lID0gb3B0aW9ucy50ZW1wbGF0ZS5uIHx8IFwiXCI7XG5cbiAgXHR2YXIgdGVtcGxhdGUgPSBjb250YWluZXIuX2lubGluZVBhcnRpYWxzW25hbWVdO1xuXG4gIFx0aWYgKCF0ZW1wbGF0ZSkge1xuICBcdFx0d2FybklmRGVidWcoXCJDb3VsZCBub3QgZmluZCB0ZW1wbGF0ZSBmb3IgcGFydGlhbCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIsIHsgcmFjdGl2ZTogb3B0aW9ucy5yb290IH0pO1xuICBcdFx0dGVtcGxhdGUgPSBbXTtcbiAgXHR9XG5cbiAgXHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0b3duZXI6IHRoaXMsXG4gIFx0XHRyb290OiBjb250YWluZXIucGFyZW50LFxuICBcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuICBcdFx0cEVsZW1lbnQ6IHRoaXMuY29udGFpbmVyRnJhZ21lbnQucEVsZW1lbnRcbiAgXHR9KTtcblxuICBcdC8vIGV2ZW4gdGhvdWdoIG9ubHkgb25lIHlpZWxkZXIgaXMgYWxsb3dlZCwgd2UgbmVlZCB0byBoYXZlIGFuIGFycmF5IG9mIHRoZW1cbiAgXHQvLyBhcyBpdCdzIHBvc3NpYmxlIHRvIGNhdXNlIGEgeWllbGRlciB0byBiZSBjcmVhdGVkIGJlZm9yZSB0aGUgbGFzdCBvbmVcbiAgXHQvLyB3YXMgZGVzdHJveWVkIGluIHRoZSBzYW1lIHR1cm4gb2YgdGhlIHJ1bmxvb3BcbiAgXHRpZiAoIWlzQXJyYXkoY29tcG9uZW50LnlpZWxkZXJzW25hbWVdKSkge1xuICBcdFx0Y29tcG9uZW50LnlpZWxkZXJzW25hbWVdID0gW3RoaXNdO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRjb21wb25lbnQueWllbGRlcnNbbmFtZV0ucHVzaCh0aGlzKTtcbiAgXHR9XG5cbiAgXHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKGNvbXBvbmVudC55aWVsZGVyc1tuYW1lXS5sZW5ndGggPiAxKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkEgY29tcG9uZW50IHRlbXBsYXRlIGNhbiBvbmx5IGhhdmUgb25lIHt7eWllbGRcIiArIChuYW1lID8gXCIgXCIgKyBuYW1lIDogXCJcIikgKyBcIn19IGRlY2xhcmF0aW9uIGF0IGEgdGltZVwiKTtcbiAgXHRcdH1cbiAgXHR9KTtcbiAgfTtcblxuICBZaWVsZGVyLnByb3RvdHlwZSA9IHtcbiAgXHRkZXRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmRldGFjaCgpO1xuICBcdH0sXG5cbiAgXHRmaW5kOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoc2VsZWN0b3IpO1xuICBcdH0sXG5cbiAgXHRmaW5kQWxsOiBmdW5jdGlvbiAoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fSxcblxuICBcdGZpbmRDb21wb25lbnQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudChzZWxlY3Rvcik7XG4gIFx0fSxcblxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBmdW5jdGlvbiAoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdH0sXG5cbiAgXHRmaW5kTmV4dE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmNvbnRhaW5lckZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0Zmlyc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maXJzdE5vZGUoKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZShvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5yZW5kZXIoKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoc2hvdWxkRGVzdHJveSk7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodGhpcy5jb21wb25lbnQueWllbGRlcnNbdGhpcy5uYW1lXSwgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGl0ZW1zX1lpZWxkZXIgPSBZaWVsZGVyO1xuXG4gIHZhciBEb2N0eXBlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLmRlY2xhcmF0aW9uID0gb3B0aW9ucy50ZW1wbGF0ZS5hO1xuICB9O1xuXG4gIERvY3R5cGUucHJvdG90eXBlID0ge1xuICBcdGluaXQ6IG5vb3AsXG4gIFx0cmVuZGVyOiBub29wLFxuICBcdHVucmVuZGVyOiBub29wLFxuICBcdHRlYXJkb3duOiBub29wLFxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gXCI8IURPQ1RZUEVcIiArIHRoaXMuZGVjbGFyYXRpb24gKyBcIj5cIjtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGl0ZW1zX0RvY3R5cGUgPSBEb2N0eXBlO1xuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfaW5pdCA9IEZyYWdtZW50JGluaXQ7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkaW5pdChvcHRpb25zKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHRoaXMub3duZXIgPSBvcHRpb25zLm93bmVyOyAvLyBUaGUgaXRlbSB0aGF0IG93bnMgdGhpcyBmcmFnbWVudCAtIGFuIGVsZW1lbnQsIHNlY3Rpb24sIHBhcnRpYWwsIG9yIGF0dHJpYnV0ZVxuICBcdHRoaXMucGFyZW50ID0gdGhpcy5vd25lci5wYXJlbnRGcmFnbWVudDtcblxuICBcdC8vIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gIFx0dGhpcy5yb290ID0gb3B0aW9ucy5yb290O1xuICBcdHRoaXMucEVsZW1lbnQgPSBvcHRpb25zLnBFbGVtZW50O1xuICBcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcbiAgXHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgXHR0aGlzLmtleSA9IG9wdGlvbnMua2V5O1xuICBcdHRoaXMucmVnaXN0ZXJlZEluZGV4UmVmcyA9IFtdO1xuXG4gIFx0Ly8gZW5jYXBzdWxhdGVkIHN0eWxlcyBzaG91bGQgYmUgaW5oZXJpdGVkIHVudGlsIHRoZXkgZ2V0IGFwcGxpZWQgYnkgYW4gZWxlbWVudFxuICBcdHRoaXMuY3NzSWRzID0gXCJjc3NJZHNcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5jc3NJZHMgOiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmNzc0lkcyA6IG51bGw7XG5cbiAgXHR0aGlzLml0ZW1zID0gb3B0aW9ucy50ZW1wbGF0ZS5tYXAoZnVuY3Rpb24gKHRlbXBsYXRlLCBpKSB7XG4gIFx0XHRyZXR1cm4gY3JlYXRlSXRlbSh7XG4gIFx0XHRcdHBhcmVudEZyYWdtZW50OiBfdGhpcyxcbiAgXHRcdFx0cEVsZW1lbnQ6IG9wdGlvbnMucEVsZW1lbnQsXG4gIFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgXHRcdFx0aW5kZXg6IGlcbiAgXHRcdH0pO1xuICBcdH0pO1xuXG4gIFx0dGhpcy52YWx1ZSA9IHRoaXMuYXJnc0xpc3QgPSBudWxsO1xuICBcdHRoaXMuZGlydHlBcmdzID0gdGhpcy5kaXJ0eVZhbHVlID0gdHJ1ZTtcblxuICBcdHRoaXMuYm91bmQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSXRlbShvcHRpb25zKSB7XG4gIFx0aWYgKHR5cGVvZiBvcHRpb25zLnRlbXBsYXRlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRyZXR1cm4gbmV3IGl0ZW1zX1RleHQob3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0c3dpdGNoIChvcHRpb25zLnRlbXBsYXRlLnQpIHtcbiAgXHRcdGNhc2UgWUlFTERFUjpcbiAgXHRcdFx0cmV0dXJuIG5ldyBpdGVtc19ZaWVsZGVyKG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBJTlRFUlBPTEFUT1I6XG4gIFx0XHRcdHJldHVybiBuZXcgaXRlbXNfSW50ZXJwb2xhdG9yKG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBTRUNUSU9OOlxuICBcdFx0XHRyZXR1cm4gbmV3IF9TZWN0aW9uKG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBUUklQTEU6XG4gIFx0XHRcdHJldHVybiBuZXcgX1RyaXBsZShvcHRpb25zKTtcbiAgXHRcdGNhc2UgRUxFTUVOVDpcbiAgXHRcdFx0dmFyIGNvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICBcdFx0XHRpZiAoY29uc3RydWN0b3IgPSBDb21wb25lbnRfZ2V0Q29tcG9uZW50KG9wdGlvbnMucGFyZW50RnJhZ21lbnQucm9vdCwgb3B0aW9ucy50ZW1wbGF0ZS5lKSkge1xuICBcdFx0XHRcdHJldHVybiBuZXcgX0NvbXBvbmVudChvcHRpb25zLCBjb25zdHJ1Y3Rvcik7XG4gIFx0XHRcdH1cbiAgXHRcdFx0cmV0dXJuIG5ldyBfRWxlbWVudChvcHRpb25zKTtcbiAgXHRcdGNhc2UgUEFSVElBTDpcbiAgXHRcdFx0cmV0dXJuIG5ldyBfUGFydGlhbChvcHRpb25zKTtcbiAgXHRcdGNhc2UgQ09NTUVOVDpcbiAgXHRcdFx0cmV0dXJuIG5ldyBpdGVtc19Db21tZW50KG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBET0NUWVBFOlxuICBcdFx0XHRyZXR1cm4gbmV3IGl0ZW1zX0RvY3R5cGUob3B0aW9ucyk7XG5cbiAgXHRcdGRlZmF1bHQ6XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlNvbWV0aGluZyB2ZXJ5IHN0cmFuZ2UgaGFwcGVuZWQuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMuIFRoYW5rcyFcIik7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9yZWJpbmQgPSBGcmFnbWVudCRyZWJpbmQ7XG4gIGZ1bmN0aW9uIEZyYWdtZW50JHJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG5cbiAgXHQvLyBhc3NpZ24gbmV3IGNvbnRleHQga2V5cGF0aCBpZiBuZWVkZWRcbiAgXHRpZiAoIXRoaXMub3duZXIgfHwgdGhpcy5vd25lci5oYXNDb250ZXh0KSB7XG4gIFx0XHRhc3NpZ25OZXdLZXlwYXRoKHRoaXMsIFwiY29udGV4dFwiLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG5cbiAgXHR0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdGlmIChpdGVtLnJlYmluZCkge1xuICBcdFx0XHRpdGVtLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9KTtcbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfcmVuZGVyID0gRnJhZ21lbnQkcmVuZGVyO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JHJlbmRlcigpIHtcbiAgXHR2YXIgcmVzdWx0O1xuXG4gIFx0aWYgKHRoaXMuaXRlbXMubGVuZ3RoID09PSAxKSB7XG4gIFx0XHRyZXN1bHQgPSB0aGlzLml0ZW1zWzBdLnJlbmRlcigpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgXHRcdHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0XHRyZXN1bHQuYXBwZW5kQ2hpbGQoaXRlbS5yZW5kZXIoKSk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV90b1N0cmluZyA9IEZyYWdtZW50JHRvU3RyaW5nO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JHRvU3RyaW5nKGVzY2FwZSkge1xuICBcdGlmICghdGhpcy5pdGVtcykge1xuICBcdFx0cmV0dXJuIFwiXCI7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMuaXRlbXMubWFwKGVzY2FwZSA/IHRvRXNjYXBlZFN0cmluZyA6IEZyYWdtZW50X3Byb3RvdHlwZV90b1N0cmluZ19fdG9TdHJpbmcpLmpvaW4oXCJcIik7XG4gIH1cblxuICBmdW5jdGlvbiBGcmFnbWVudF9wcm90b3R5cGVfdG9TdHJpbmdfX3RvU3RyaW5nKGl0ZW0pIHtcbiAgXHRyZXR1cm4gaXRlbS50b1N0cmluZygpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9Fc2NhcGVkU3RyaW5nKGl0ZW0pIHtcbiAgXHRyZXR1cm4gaXRlbS50b1N0cmluZyh0cnVlKTtcbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfdW5iaW5kID0gRnJhZ21lbnQkdW5iaW5kO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JHVuYmluZCgpIHtcbiAgXHRpZiAoIXRoaXMuYm91bmQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHR0aGlzLml0ZW1zLmZvckVhY2godW5iaW5kSXRlbSk7XG4gIFx0dGhpcy5ib3VuZCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5iaW5kSXRlbShpdGVtKSB7XG4gIFx0aWYgKGl0ZW0udW5iaW5kKSB7XG4gIFx0XHRpdGVtLnVuYmluZCgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfdW5yZW5kZXIgPSBGcmFnbWVudCR1bnJlbmRlcjtcblxuICBmdW5jdGlvbiBGcmFnbWVudCR1bnJlbmRlcihzaG91bGREZXN0cm95KSB7XG4gIFx0aWYgKCF0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gdW5yZW5kZXIgYSBmcmFnbWVudCB0aGF0IHdhcyBub3QgcmVuZGVyZWRcIik7XG4gIFx0fVxuXG4gIFx0dGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7XG4gIFx0XHRyZXR1cm4gaS51bnJlbmRlcihzaG91bGREZXN0cm95KTtcbiAgXHR9KTtcbiAgXHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgRnJhZ21lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfTtcblxuICBGcmFnbWVudC5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBwcm90b3R5cGVfYnViYmxlLFxuICBcdGRldGFjaDogRnJhZ21lbnRfcHJvdG90eXBlX2RldGFjaCxcbiAgXHRmaW5kOiBGcmFnbWVudF9wcm90b3R5cGVfZmluZCxcbiAgXHRmaW5kQWxsOiBGcmFnbWVudF9wcm90b3R5cGVfZmluZEFsbCxcbiAgXHRmaW5kQWxsQ29tcG9uZW50czogRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzLFxuICBcdGZpbmRDb21wb25lbnQ6IEZyYWdtZW50X3Byb3RvdHlwZV9maW5kQ29tcG9uZW50LFxuICBcdGZpbmROZXh0Tm9kZTogcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSxcbiAgXHRmaXJzdE5vZGU6IHByb3RvdHlwZV9maXJzdE5vZGUsXG4gIFx0Z2V0QXJnc0xpc3Q6IGdldEFyZ3NMaXN0LFxuICBcdGdldE5vZGU6IGdldE5vZGUsXG4gIFx0Z2V0VmFsdWU6IHByb3RvdHlwZV9nZXRWYWx1ZSxcbiAgXHRpbml0OiBGcmFnbWVudF9wcm90b3R5cGVfaW5pdCxcbiAgXHRyZWJpbmQ6IEZyYWdtZW50X3Byb3RvdHlwZV9yZWJpbmQsXG4gIFx0cmVnaXN0ZXJJbmRleFJlZjogZnVuY3Rpb24gKGlkeCkge1xuICBcdFx0dmFyIGlkeHMgPSB0aGlzLnJlZ2lzdGVyZWRJbmRleFJlZnM7XG4gIFx0XHRpZiAoaWR4cy5pbmRleE9mKGlkeCkgPT09IC0xKSB7XG4gIFx0XHRcdGlkeHMucHVzaChpZHgpO1xuICBcdFx0fVxuICBcdH0sXG4gIFx0cmVuZGVyOiBGcmFnbWVudF9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHRvU3RyaW5nOiBGcmFnbWVudF9wcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBGcmFnbWVudF9wcm90b3R5cGVfdW5iaW5kLFxuICBcdHVucmVnaXN0ZXJJbmRleFJlZjogZnVuY3Rpb24gKGlkeCkge1xuICBcdFx0dmFyIGlkeHMgPSB0aGlzLnJlZ2lzdGVyZWRJbmRleFJlZnM7XG4gIFx0XHRpZHhzLnNwbGljZShpZHhzLmluZGV4T2YoaWR4KSwgMSk7XG4gIFx0fSxcbiAgXHR1bnJlbmRlcjogRnJhZ21lbnRfcHJvdG90eXBlX3VucmVuZGVyXG4gIH07XG5cbiAgdmFyIHZpcnR1YWxkb21fRnJhZ21lbnQgPSBGcmFnbWVudDtcblxuICB2YXIgcHJvdG90eXBlX3Jlc2V0ID0gUmFjdGl2ZSRyZXNldDtcbiAgdmFyIHNob3VsZFJlcmVuZGVyID0gW1widGVtcGxhdGVcIiwgXCJwYXJ0aWFsc1wiLCBcImNvbXBvbmVudHNcIiwgXCJkZWNvcmF0b3JzXCIsIFwiZXZlbnRzXCJdLFxuICAgICAgcmVzZXRIb29rID0gbmV3IGhvb2tzX0hvb2soXCJyZXNldFwiKTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRyZXNldChkYXRhKSB7XG4gIFx0dmFyIHByb21pc2UsIHdyYXBwZXIsIGNoYW5nZXMsIGksIHJlcmVuZGVyO1xuXG4gIFx0ZGF0YSA9IGRhdGEgfHwge307XG5cbiAgXHRpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNldCBtZXRob2QgdGFrZXMgZWl0aGVyIG5vIGFyZ3VtZW50cywgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmV3IGRhdGFcIik7XG4gIFx0fVxuXG4gIFx0Ly8gSWYgdGhlIHJvb3Qgb2JqZWN0IGlzIHdyYXBwZWQsIHRyeSBhbmQgdXNlIHRoZSB3cmFwcGVyJ3MgcmVzZXQgdmFsdWVcbiAgXHRpZiAoKHdyYXBwZXIgPSB0aGlzLnZpZXdtb2RlbC53cmFwcGVkW1wiXCJdKSAmJiB3cmFwcGVyLnJlc2V0KSB7XG4gIFx0XHRpZiAod3JhcHBlci5yZXNldChkYXRhKSA9PT0gZmFsc2UpIHtcbiAgXHRcdFx0Ly8gcmVzZXQgd2FzIHJlamVjdGVkLCB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhlIG9iamVjdFxuICBcdFx0XHR0aGlzLnZpZXdtb2RlbC5yZXNldChkYXRhKTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0dGhpcy52aWV3bW9kZWwucmVzZXQoZGF0YSk7XG4gIFx0fVxuXG4gIFx0Ly8gcmVzZXQgY29uZmlnIGl0ZW1zIGFuZCB0cmFjayBpZiBuZWVkIHRvIHJlcmVuZGVyXG4gIFx0Y2hhbmdlcyA9IGNvbmZpZ19jb25maWcucmVzZXQodGhpcyk7XG5cbiAgXHRpID0gY2hhbmdlcy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKHNob3VsZFJlcmVuZGVyLmluZGV4T2YoY2hhbmdlc1tpXSkgPiAtMSkge1xuICBcdFx0XHRyZXJlbmRlciA9IHRydWU7XG4gIFx0XHRcdGJyZWFrO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmIChyZXJlbmRlcikge1xuICBcdFx0dmFyIGNvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxuICBcdFx0dGhpcy52aWV3bW9kZWwubWFyayhyb290S2V5cGF0aCk7XG5cbiAgXHRcdC8vIElzIHRoaXMgaXMgYSBjb21wb25lbnQsIHdlIG5lZWQgdG8gc2V0IHRoZSBgc2hvdWxkRGVzdHJveWBcbiAgXHRcdC8vIGZsYWcsIG90aGVyd2lzZSBpdCB3aWxsIGFzc3VtZSBieSBkZWZhdWx0IHRoYXQgYSBwYXJlbnQgbm9kZVxuICBcdFx0Ly8gd2lsbCBiZSBkZXRhY2hlZCwgYW5kIHRoZXJlZm9yZSBpdCBkb2Vzbid0IG5lZWQgdG8gYm90aGVyXG4gIFx0XHQvLyBkZXRhY2hpbmcgaXRzIG93biBub2Rlc1xuICBcdFx0aWYgKGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50KSB7XG4gIFx0XHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy51bnJlbmRlcigpO1xuXG4gIFx0XHRpZiAoY29tcG9uZW50KSB7XG4gIFx0XHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIElmIHRoZSB0ZW1wbGF0ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvIGRlc3Ryb3kgdGhlIHBhcmFsbGVsIERPTVxuICBcdFx0Ly8gVE9ETyBpZiB3ZSdyZSBoZXJlLCBwcmVzdW1hYmx5IGl0IGRpZD9cbiAgXHRcdGlmICh0aGlzLmZyYWdtZW50LnRlbXBsYXRlICE9PSB0aGlzLnRlbXBsYXRlKSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cbiAgXHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZSxcbiAgXHRcdFx0XHRyb290OiB0aGlzLFxuICBcdFx0XHRcdG93bmVyOiB0aGlzXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHRwcm9taXNlID0gdGhpcy5yZW5kZXIodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKHJvb3RLZXlwYXRoKTtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdH1cblxuICBcdHJlc2V0SG9vay5maXJlKHRoaXMsIGRhdGEpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgcmVzZXRQYXJ0aWFsID0gZnVuY3Rpb24gKG5hbWUsIHBhcnRpYWwpIHtcbiAgXHR2YXIgcHJvbWlzZSxcbiAgXHQgICAgY29sbGVjdGlvbiA9IFtdO1xuXG4gIFx0ZnVuY3Rpb24gY29sbGVjdChzb3VyY2UsIGRlc3QsIHJhY3RpdmUpIHtcbiAgXHRcdC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgYW5kIGl0IGhhcyBpdHMgb3duIHBhcnRpYWwsIGJhaWxcbiAgXHRcdGlmIChyYWN0aXZlICYmIHJhY3RpdmUucGFydGlhbHNbbmFtZV0pIHJldHVybjtcblxuICBcdFx0c291cmNlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdFx0Ly8gcXVldWUgdG8gcmVyZW5kZXIgaWYgdGhlIGl0ZW0gaXMgYSBwYXJ0aWFsIGFuZCB0aGUgY3VycmVudCBuYW1lIG1hdGNoZXNcbiAgXHRcdFx0aWYgKGl0ZW0udHlwZSA9PT0gUEFSVElBTCAmJiBpdGVtLmdldFBhcnRpYWxOYW1lKCkgPT09IG5hbWUpIHtcbiAgXHRcdFx0XHRkZXN0LnB1c2goaXRlbSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBpZiBpdCBoYXMgYSBmcmFnbWVudCwgcHJvY2VzcyBpdHMgaXRlbXNcbiAgXHRcdFx0aWYgKGl0ZW0uZnJhZ21lbnQpIHtcbiAgXHRcdFx0XHRjb2xsZWN0KGl0ZW0uZnJhZ21lbnQuaXRlbXMsIGRlc3QsIHJhY3RpdmUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gb3IgaWYgaXQgaGFzIGZyYWdtZW50c1xuICBcdFx0XHRpZiAoaXNBcnJheShpdGVtLmZyYWdtZW50cykpIHtcbiAgXHRcdFx0XHRjb2xsZWN0KGl0ZW0uZnJhZ21lbnRzLCBkZXN0LCByYWN0aXZlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIG9yIGlmIGl0IGlzIGl0c2VsZiBhIGZyYWdtZW50LCBwcm9jZXNzIGl0cyBpdGVtc1xuICBcdFx0XHRlbHNlIGlmIChpc0FycmF5KGl0ZW0uaXRlbXMpKSB7XG4gIFx0XHRcdFx0Y29sbGVjdChpdGVtLml0ZW1zLCBkZXN0LCByYWN0aXZlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIG9yIGlmIGl0IGlzIGEgY29tcG9uZW50LCBzdGVwIGluIGFuZCBwcm9jZXNzIGl0cyBpdGVtc1xuICBcdFx0XHRlbHNlIGlmIChpdGVtLnR5cGUgPT09IENPTVBPTkVOVCAmJiBpdGVtLmluc3RhbmNlKSB7XG4gIFx0XHRcdFx0Y29sbGVjdChpdGVtLmluc3RhbmNlLmZyYWdtZW50Lml0ZW1zLCBkZXN0LCBpdGVtLmluc3RhbmNlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGlmIHRoZSBpdGVtIGlzIGFuIGVsZW1lbnQsIHByb2Nlc3MgaXRzIGF0dHJpYnV0ZXMgdG9vXG4gIFx0XHRcdGlmIChpdGVtLnR5cGUgPT09IEVMRU1FTlQpIHtcbiAgXHRcdFx0XHRpZiAoaXNBcnJheShpdGVtLmF0dHJpYnV0ZXMpKSB7XG4gIFx0XHRcdFx0XHRjb2xsZWN0KGl0ZW0uYXR0cmlidXRlcywgZGVzdCwgcmFjdGl2ZSk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKGlzQXJyYXkoaXRlbS5jb25kaXRpb25hbEF0dHJpYnV0ZXMpKSB7XG4gIFx0XHRcdFx0XHRjb2xsZWN0KGl0ZW0uY29uZGl0aW9uYWxBdHRyaWJ1dGVzLCBkZXN0LCByYWN0aXZlKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdGNvbGxlY3QodGhpcy5mcmFnbWVudC5pdGVtcywgY29sbGVjdGlvbik7XG4gIFx0dGhpcy5wYXJ0aWFsc1tuYW1lXSA9IHBhcnRpYWw7XG5cbiAgXHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG5cbiAgXHRjb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdGl0ZW0udmFsdWUgPSB1bmRlZmluZWQ7XG4gIFx0XHRpdGVtLnNldFZhbHVlKG5hbWUpO1xuICBcdH0pO1xuXG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICAvLyBUT0RPIHNob3VsZCByZXNldFRlbXBsYXRlIGJlIGFzeW5jaHJvbm91cz8gaS5lLiBzaG91bGQgaXQgYmUgYSBjYXNlXG4gIC8vIG9mIG91dHJvLCB1cGRhdGUgdGVtcGxhdGUsIGludHJvPyBJIHJlY2tvbiBwcm9iYWJseSBub3QsIHNpbmNlIHRoYXRcbiAgLy8gY291bGQgYmUgYWNoaWV2ZWQgd2l0aCB1bnJlbmRlci1yZXNldFRlbXBsYXRlLXJlbmRlci4gQWxzbywgaXQgc2hvdWxkXG4gIC8vIGNvbmNlcHR1YWxseSBiZSBzaW1pbGFyIHRvIHJlc2V0UGFydGlhbCwgd2hpY2ggY291bGRuJ3QgYmUgYXN5bmNcblxuICB2YXIgcmVzZXRUZW1wbGF0ZSA9IFJhY3RpdmUkcmVzZXRUZW1wbGF0ZTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRyZXNldFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gIFx0dmFyIHRyYW5zaXRpb25zRW5hYmxlZCwgY29tcG9uZW50O1xuXG4gIFx0dGVtcGxhdGVfdGVtcGxhdGUuaW5pdChudWxsLCB0aGlzLCB7IHRlbXBsYXRlOiB0ZW1wbGF0ZSB9KTtcblxuICBcdHRyYW5zaXRpb25zRW5hYmxlZCA9IHRoaXMudHJhbnNpdGlvbnNFbmFibGVkO1xuICBcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gZmFsc2U7XG5cbiAgXHQvLyBJcyB0aGlzIGlzIGEgY29tcG9uZW50LCB3ZSBuZWVkIHRvIHNldCB0aGUgYHNob3VsZERlc3Ryb3lgXG4gIFx0Ly8gZmxhZywgb3RoZXJ3aXNlIGl0IHdpbGwgYXNzdW1lIGJ5IGRlZmF1bHQgdGhhdCBhIHBhcmVudCBub2RlXG4gIFx0Ly8gd2lsbCBiZSBkZXRhY2hlZCwgYW5kIHRoZXJlZm9yZSBpdCBkb2Vzbid0IG5lZWQgdG8gYm90aGVyXG4gIFx0Ly8gZGV0YWNoaW5nIGl0cyBvd24gbm9kZXNcbiAgXHRpZiAoY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQpIHtcbiAgXHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHR0aGlzLnVucmVuZGVyKCk7XG5cbiAgXHRpZiAoY29tcG9uZW50KSB7XG4gIFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IGZhbHNlO1xuICBcdH1cblxuICBcdC8vIHJlbW92ZSBleGlzdGluZyBmcmFnbWVudCBhbmQgY3JlYXRlIG5ldyBvbmVcbiAgXHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZSxcbiAgXHRcdHJvb3Q6IHRoaXMsXG4gIFx0XHRvd25lcjogdGhpc1xuICBcdH0pO1xuXG4gIFx0dGhpcy5yZW5kZXIodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuXG4gIFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSB0cmFuc2l0aW9uc0VuYWJsZWQ7XG4gIH1cblxuICB2YXIgcmV2ZXJzZSA9IG1ha2VBcnJheU1ldGhvZChcInJldmVyc2VcIik7XG5cbiAgdmFyIFJhY3RpdmVfcHJvdG90eXBlX3NldCA9IFJhY3RpdmUkc2V0O1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkc2V0KGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0dmFyIG1hcCwgcHJvbWlzZTtcblxuICBcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcblxuICBcdC8vIFNldCBtdWx0aXBsZSBrZXlwYXRocyBpbiBvbmUgZ29cbiAgXHRpZiAoaXNPYmplY3Qoa2V5cGF0aCkpIHtcbiAgXHRcdG1hcCA9IGtleXBhdGg7XG5cbiAgXHRcdGZvciAoa2V5cGF0aCBpbiBtYXApIHtcbiAgXHRcdFx0aWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShrZXlwYXRoKSkge1xuICBcdFx0XHRcdHZhbHVlID0gbWFwW2tleXBhdGhdO1xuICBcdFx0XHRcdHNldCh0aGlzLCBrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBTZXQgYSBzaW5nbGUga2V5cGF0aFxuICBcdGVsc2Uge1xuICBcdFx0c2V0KHRoaXMsIGtleXBhdGgsIHZhbHVlKTtcbiAgXHR9XG5cbiAgXHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0KHJhY3RpdmUsIGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0a2V5cGF0aCA9IGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKTtcblxuICBcdGlmIChrZXlwYXRoLmlzUGF0dGVybikge1xuICBcdFx0Z2V0TWF0Y2hpbmdLZXlwYXRocyhyYWN0aXZlLCBrZXlwYXRoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnNldChrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0XHR9KTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmFjdGl2ZS52aWV3bW9kZWwuc2V0KGtleXBhdGgsIHZhbHVlKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgc2hpZnQgPSBtYWtlQXJyYXlNZXRob2QoXCJzaGlmdFwiKTtcblxuICB2YXIgcHJvdG90eXBlX3NvcnQgPSBtYWtlQXJyYXlNZXRob2QoXCJzb3J0XCIpO1xuXG4gIHZhciBzcGxpY2UgPSBtYWtlQXJyYXlNZXRob2QoXCJzcGxpY2VcIik7XG5cbiAgdmFyIHN1YnRyYWN0ID0gUmFjdGl2ZSRzdWJ0cmFjdDtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRzdWJ0cmFjdChrZXlwYXRoLCBkKSB7XG4gIFx0cmV0dXJuIHNoYXJlZF9hZGQodGhpcywga2V5cGF0aCwgZCA9PT0gdW5kZWZpbmVkID8gLTEgOiAtZCk7XG4gIH1cblxuICAvLyBUZWFyZG93bi4gVGhpcyBnb2VzIHRocm91Z2ggdGhlIHJvb3QgZnJhZ21lbnQgYW5kIGFsbCBpdHMgY2hpbGRyZW4sIHJlbW92aW5nIG9ic2VydmVyc1xuICAvLyBhbmQgZ2VuZXJhbGx5IGNsZWFuaW5nIHVwIGFmdGVyIGl0c2VsZlxuXG4gIHZhciBSYWN0aXZlX3Byb3RvdHlwZV90ZWFyZG93biA9IFJhY3RpdmUkdGVhcmRvd247XG5cbiAgdmFyIFJhY3RpdmVfcHJvdG90eXBlX3RlYXJkb3duX190ZWFyZG93bkhvb2sgPSBuZXcgaG9va3NfSG9vayhcInRlYXJkb3duXCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHRlYXJkb3duKCkge1xuICBcdHZhciBwcm9taXNlO1xuXG4gIFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR0aGlzLnZpZXdtb2RlbC50ZWFyZG93bigpO1xuXG4gIFx0dGhpcy5fb2JzZXJ2ZXJzLmZvckVhY2goY2FuY2VsKTtcblxuICBcdGlmICh0aGlzLmZyYWdtZW50LnJlbmRlcmVkICYmIHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIHRoaXMpO1xuICBcdH1cblxuICBcdHRoaXMuc2hvdWxkRGVzdHJveSA9IHRydWU7XG4gIFx0cHJvbWlzZSA9IHRoaXMuZnJhZ21lbnQucmVuZGVyZWQgPyB0aGlzLnVucmVuZGVyKCkgOiB1dGlsc19Qcm9taXNlLnJlc29sdmUoKTtcblxuICBcdFJhY3RpdmVfcHJvdG90eXBlX3RlYXJkb3duX190ZWFyZG93bkhvb2suZmlyZSh0aGlzKTtcblxuICBcdHRoaXMuX2JvdW5kRnVuY3Rpb25zLmZvckVhY2goZGVsZXRlRnVuY3Rpb25Db3B5KTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlRnVuY3Rpb25Db3B5KGJvdW5kKSB7XG4gIFx0ZGVsZXRlIGJvdW5kLmZuW2JvdW5kLnByb3BdO1xuICB9XG5cbiAgdmFyIHRvZ2dsZSA9IFJhY3RpdmUkdG9nZ2xlO1xuICBmdW5jdGlvbiBSYWN0aXZlJHRvZ2dsZShrZXlwYXRoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdGlmICh0eXBlb2Yga2V5cGF0aCAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihiYWRBcmd1bWVudHMpO1xuICBcdH1cblxuICBcdHZhciBjaGFuZ2VzID0gdW5kZWZpbmVkO1xuXG4gIFx0aWYgKC9cXCovLnRlc3Qoa2V5cGF0aCkpIHtcbiAgXHRcdGNoYW5nZXMgPSB7fTtcblxuICBcdFx0Z2V0TWF0Y2hpbmdLZXlwYXRocyh0aGlzLCBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSkpLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0Y2hhbmdlc1trZXlwYXRoLnN0cl0gPSAhX3RoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRyZXR1cm4gdGhpcy5zZXQoY2hhbmdlcyk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXMuc2V0KGtleXBhdGgsICF0aGlzLmdldChrZXlwYXRoKSk7XG4gIH1cblxuICB2YXIgdG9IVE1MID0gUmFjdGl2ZSR0b0hUTUw7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSR0b0hUTUwoKSB7XG4gIFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcodHJ1ZSk7XG4gIH1cblxuICB2YXIgUmFjdGl2ZV9wcm90b3R5cGVfdW5yZW5kZXIgPSBSYWN0aXZlJHVucmVuZGVyO1xuICB2YXIgdW5yZW5kZXJIb29rID0gbmV3IGhvb2tzX0hvb2soXCJ1bnJlbmRlclwiKTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSR1bnJlbmRlcigpIHtcbiAgXHR2YXIgcHJvbWlzZSwgc2hvdWxkRGVzdHJveTtcblxuICBcdGlmICghdGhpcy5mcmFnbWVudC5yZW5kZXJlZCkge1xuICBcdFx0d2FybklmRGVidWcoXCJyYWN0aXZlLnVucmVuZGVyKCkgd2FzIGNhbGxlZCBvbiBhIFJhY3RpdmUgaW5zdGFuY2UgdGhhdCB3YXMgbm90IHJlbmRlcmVkXCIpO1xuICBcdFx0cmV0dXJuIHV0aWxzX1Byb21pc2UucmVzb2x2ZSgpO1xuICBcdH1cblxuICBcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcblxuICBcdC8vIElmIHRoaXMgaXMgYSBjb21wb25lbnQsIGFuZCB0aGUgY29tcG9uZW50IGlzbid0IG1hcmtlZCBmb3IgZGVzdHJ1Y3Rpb24sXG4gIFx0Ly8gZG9uJ3QgZGV0YWNoIG5vZGVzIGZyb20gdGhlIERPTSB1bm5lY2Vzc2FyaWx5XG4gIFx0c2hvdWxkRGVzdHJveSA9ICF0aGlzLmNvbXBvbmVudCB8fCB0aGlzLmNvbXBvbmVudC5zaG91bGREZXN0cm95IHx8IHRoaXMuc2hvdWxkRGVzdHJveTtcblxuICBcdC8vIENhbmNlbCBhbnkgYW5pbWF0aW9ucyBpbiBwcm9ncmVzc1xuICBcdHdoaWxlICh0aGlzLl9hbmltYXRpb25zWzBdKSB7XG4gIFx0XHR0aGlzLl9hbmltYXRpb25zWzBdLnN0b3AoKTsgLy8gaXQgd2lsbCByZW1vdmUgaXRzZWxmIGZyb20gdGhlIGluZGV4XG4gIFx0fVxuXG4gIFx0dGhpcy5mcmFnbWVudC51bnJlbmRlcihzaG91bGREZXN0cm95KTtcblxuICBcdHJlbW92ZUZyb21BcnJheSh0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgdGhpcyk7XG5cbiAgXHR1bnJlbmRlckhvb2suZmlyZSh0aGlzKTtcblxuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgdmFyIHVuc2hpZnQgPSBtYWtlQXJyYXlNZXRob2QoXCJ1bnNoaWZ0XCIpO1xuXG4gIHZhciBSYWN0aXZlX3Byb3RvdHlwZV91cGRhdGUgPSBSYWN0aXZlJHVwZGF0ZTtcbiAgdmFyIHVwZGF0ZUhvb2sgPSBuZXcgaG9va3NfSG9vayhcInVwZGF0ZVwiKTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSR1cGRhdGUoa2V5cGF0aCkge1xuICBcdHZhciBwcm9taXNlO1xuXG4gIFx0a2V5cGF0aCA9IGdldEtleXBhdGgoa2V5cGF0aCkgfHwgcm9vdEtleXBhdGg7XG5cbiAgXHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG4gIFx0dGhpcy52aWV3bW9kZWwubWFyayhrZXlwYXRoKTtcbiAgXHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdHVwZGF0ZUhvb2suZmlyZSh0aGlzLCBrZXlwYXRoKTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV91cGRhdGVNb2RlbCA9IFJhY3RpdmUkdXBkYXRlTW9kZWw7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSR1cGRhdGVNb2RlbChrZXlwYXRoLCBjYXNjYWRlKSB7XG4gIFx0dmFyIHZhbHVlcywga2V5LCBiaW5kaW5ncztcblxuICBcdGlmICh0eXBlb2Yga2V5cGF0aCA9PT0gXCJzdHJpbmdcIiAmJiAhY2FzY2FkZSkge1xuICBcdFx0YmluZGluZ3MgPSB0aGlzLl90d293YXlCaW5kaW5nc1trZXlwYXRoXTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0YmluZGluZ3MgPSBbXTtcblxuICBcdFx0Zm9yIChrZXkgaW4gdGhpcy5fdHdvd2F5QmluZGluZ3MpIHtcbiAgXHRcdFx0aWYgKCFrZXlwYXRoIHx8IGdldEtleXBhdGgoa2V5KS5lcXVhbHNPclN0YXJ0c1dpdGgoa2V5cGF0aCkpIHtcbiAgXHRcdFx0XHQvLyBUT0RPIGlzIHRoaXMgcmlnaHQ/XG4gIFx0XHRcdFx0YmluZGluZ3MucHVzaC5hcHBseShiaW5kaW5ncywgdGhpcy5fdHdvd2F5QmluZGluZ3Nba2V5XSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR2YWx1ZXMgPSBjb25zb2xpZGF0ZSh0aGlzLCBiaW5kaW5ncyk7XG4gIFx0cmV0dXJuIHRoaXMuc2V0KHZhbHVlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zb2xpZGF0ZShyYWN0aXZlLCBiaW5kaW5ncykge1xuICBcdHZhciB2YWx1ZXMgPSB7fSxcbiAgXHQgICAgY2hlY2tib3hHcm91cHMgPSBbXTtcblxuICBcdGJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgXHRcdHZhciBvbGRWYWx1ZSwgbmV3VmFsdWU7XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIHJhZGlvIG5hbWUgYmluZGluZ3NcbiAgXHRcdGlmIChiLnJhZGlvTmFtZSAmJiAhYi5lbGVtZW50Lm5vZGUuY2hlY2tlZCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGNoZWNrYm94IG5hbWUgYmluZGluZ3MgY29tZSBpbiBncm91cHMsIHNvXG4gIFx0XHQvLyB3ZSB3YW50IHRvIGdldCB0aGUgdmFsdWUgb25jZSBhdCBtb3N0XG4gIFx0XHRpZiAoYi5jaGVja2JveE5hbWUpIHtcbiAgXHRcdFx0aWYgKCFjaGVja2JveEdyb3Vwc1tiLmtleXBhdGguc3RyXSAmJiAhYi5jaGFuZ2VkKCkpIHtcbiAgXHRcdFx0XHRjaGVja2JveEdyb3Vwcy5wdXNoKGIua2V5cGF0aCk7XG4gIFx0XHRcdFx0Y2hlY2tib3hHcm91cHNbYi5rZXlwYXRoLnN0cl0gPSBiO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRvbGRWYWx1ZSA9IGIuYXR0cmlidXRlLnZhbHVlO1xuICBcdFx0bmV3VmFsdWUgPSBiLmdldFZhbHVlKCk7XG5cbiAgXHRcdGlmIChhcnJheUNvbnRlbnRzTWF0Y2gob2xkVmFsdWUsIG5ld1ZhbHVlKSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghaXNFcXVhbChvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gIFx0XHRcdHZhbHVlc1tiLmtleXBhdGguc3RyXSA9IG5ld1ZhbHVlO1xuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0Ly8gSGFuZGxlIGdyb3VwcyBvZiBgPGlucHV0IHR5cGU9J2NoZWNrYm94JyBuYW1lPSd7e2Zvb319JyAuLi4+YFxuICBcdGlmIChjaGVja2JveEdyb3Vwcy5sZW5ndGgpIHtcbiAgXHRcdGNoZWNrYm94R3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0dmFyIGJpbmRpbmcsIG9sZFZhbHVlLCBuZXdWYWx1ZTtcblxuICBcdFx0XHRiaW5kaW5nID0gY2hlY2tib3hHcm91cHNba2V5cGF0aC5zdHJdOyAvLyBvbmUgdG8gcmVwcmVzZW50IHRoZSBlbnRpcmUgZ3JvdXBcbiAgXHRcdFx0b2xkVmFsdWUgPSBiaW5kaW5nLmF0dHJpYnV0ZS52YWx1ZTtcbiAgXHRcdFx0bmV3VmFsdWUgPSBiaW5kaW5nLmdldFZhbHVlKCk7XG5cbiAgXHRcdFx0aWYgKCFhcnJheUNvbnRlbnRzTWF0Y2gob2xkVmFsdWUsIG5ld1ZhbHVlKSkge1xuICBcdFx0XHRcdHZhbHVlc1trZXlwYXRoLnN0cl0gPSBuZXdWYWx1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSB7XG4gIFx0YWRkOiBwcm90b3R5cGVfYWRkLFxuICBcdGFuaW1hdGU6IHByb3RvdHlwZV9hbmltYXRlLFxuICBcdGRldGFjaDogcHJvdG90eXBlX2RldGFjaCxcbiAgXHRmaW5kOiBwcm90b3R5cGVfZmluZCxcbiAgXHRmaW5kQWxsOiBwcm90b3R5cGVfZmluZEFsbCxcbiAgXHRmaW5kQWxsQ29tcG9uZW50czogcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzLFxuICBcdGZpbmRDb21wb25lbnQ6IHByb3RvdHlwZV9maW5kQ29tcG9uZW50LFxuICBcdGZpbmRDb250YWluZXI6IGZpbmRDb250YWluZXIsXG4gIFx0ZmluZFBhcmVudDogZmluZFBhcmVudCxcbiAgXHRmaXJlOiBwcm90b3R5cGVfZmlyZSxcbiAgXHRnZXQ6IHByb3RvdHlwZV9nZXQsXG4gIFx0aW5zZXJ0OiBpbnNlcnQsXG4gIFx0bWVyZ2U6IHByb3RvdHlwZV9tZXJnZSxcbiAgXHRvYnNlcnZlOiBvYnNlcnZlLFxuICBcdG9ic2VydmVPbmNlOiBvYnNlcnZlT25jZSxcbiAgXHRvZmY6IG9mZixcbiAgXHRvbjogb24sXG4gIFx0b25jZTogb25jZSxcbiAgXHRwb3A6IHBvcCxcbiAgXHRwdXNoOiBwdXNoLFxuICBcdHJlbmRlcjogcHJvdG90eXBlX3JlbmRlcixcbiAgXHRyZXNldDogcHJvdG90eXBlX3Jlc2V0LFxuICBcdHJlc2V0UGFydGlhbDogcmVzZXRQYXJ0aWFsLFxuICBcdHJlc2V0VGVtcGxhdGU6IHJlc2V0VGVtcGxhdGUsXG4gIFx0cmV2ZXJzZTogcmV2ZXJzZSxcbiAgXHRzZXQ6IFJhY3RpdmVfcHJvdG90eXBlX3NldCxcbiAgXHRzaGlmdDogc2hpZnQsXG4gIFx0c29ydDogcHJvdG90eXBlX3NvcnQsXG4gIFx0c3BsaWNlOiBzcGxpY2UsXG4gIFx0c3VidHJhY3Q6IHN1YnRyYWN0LFxuICBcdHRlYXJkb3duOiBSYWN0aXZlX3Byb3RvdHlwZV90ZWFyZG93bixcbiAgXHR0b2dnbGU6IHRvZ2dsZSxcbiAgXHR0b0hUTUw6IHRvSFRNTCxcbiAgXHR0b0h0bWw6IHRvSFRNTCxcbiAgXHR1bnJlbmRlcjogUmFjdGl2ZV9wcm90b3R5cGVfdW5yZW5kZXIsXG4gIFx0dW5zaGlmdDogdW5zaGlmdCxcbiAgXHR1cGRhdGU6IFJhY3RpdmVfcHJvdG90eXBlX3VwZGF0ZSxcbiAgXHR1cGRhdGVNb2RlbDogcHJvdG90eXBlX3VwZGF0ZU1vZGVsXG4gIH07XG5cbiAgdmFyIHdyYXBNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kLCBzdXBlck1ldGhvZCwgZm9yY2UpIHtcblxuICBcdGlmIChmb3JjZSB8fCBuZWVkc1N1cGVyKG1ldGhvZCwgc3VwZXJNZXRob2QpKSB7XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgXHRcdFx0dmFyIGhhc1N1cGVyID0gKFwiX3N1cGVyXCIgaW4gdGhpcyksXG4gIFx0XHRcdCAgICBfc3VwZXIgPSB0aGlzLl9zdXBlcixcbiAgXHRcdFx0ICAgIHJlc3VsdDtcblxuICBcdFx0XHR0aGlzLl9zdXBlciA9IHN1cGVyTWV0aG9kO1xuXG4gIFx0XHRcdHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIFx0XHRcdGlmIChoYXNTdXBlcikge1xuICBcdFx0XHRcdHRoaXMuX3N1cGVyID0gX3N1cGVyO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHRcdH07XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiBtZXRob2Q7XG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIG5lZWRzU3VwZXIobWV0aG9kLCBzdXBlck1ldGhvZCkge1xuICBcdHJldHVybiB0eXBlb2Ygc3VwZXJNZXRob2QgPT09IFwiZnVuY3Rpb25cIiAmJiAvX3N1cGVyLy50ZXN0KG1ldGhvZCk7XG4gIH1cblxuICB2YXIgdW53cmFwRXh0ZW5kZWQgPSB1bndyYXA7XG5cbiAgZnVuY3Rpb24gdW53cmFwKENoaWxkKSB7XG4gIFx0dmFyIG9wdGlvbnMgPSB7fTtcblxuICBcdHdoaWxlIChDaGlsZCkge1xuICBcdFx0YWRkUmVnaXN0cmllcyhDaGlsZCwgb3B0aW9ucyk7XG4gIFx0XHRhZGRPdGhlck9wdGlvbnMoQ2hpbGQsIG9wdGlvbnMpO1xuXG4gIFx0XHRpZiAoQ2hpbGQuX1BhcmVudCAhPT0gX1JhY3RpdmUpIHtcbiAgXHRcdFx0Q2hpbGQgPSBDaGlsZC5fUGFyZW50O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Q2hpbGQgPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gb3B0aW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFJlZ2lzdHJpZXMoQ2hpbGQsIG9wdGlvbnMpIHtcbiAgXHRjb25maWdfcmVnaXN0cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gIFx0XHRhZGRSZWdpc3RyeShyLnVzZURlZmF1bHRzID8gQ2hpbGQucHJvdG90eXBlIDogQ2hpbGQsIG9wdGlvbnMsIHIubmFtZSk7XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRSZWdpc3RyeSh0YXJnZXQsIG9wdGlvbnMsIG5hbWUpIHtcbiAgXHR2YXIgcmVnaXN0cnksXG4gIFx0ICAgIGtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXRbbmFtZV0pO1xuXG4gIFx0aWYgKCFrZXlzLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmICghKHJlZ2lzdHJ5ID0gb3B0aW9uc1tuYW1lXSkpIHtcbiAgXHRcdHJlZ2lzdHJ5ID0gb3B0aW9uc1tuYW1lXSA9IHt9O1xuICBcdH1cblxuICBcdGtleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdHJldHVybiAhKGtleSBpbiByZWdpc3RyeSk7XG4gIFx0fSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHRyZXR1cm4gcmVnaXN0cnlba2V5XSA9IHRhcmdldFtuYW1lXVtrZXldO1xuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkT3RoZXJPcHRpb25zKENoaWxkLCBvcHRpb25zKSB7XG4gIFx0T2JqZWN0LmtleXMoQ2hpbGQucHJvdG90eXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdGlmIChrZXkgPT09IFwiY29tcHV0ZWRcIikge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHZhciB2YWx1ZSA9IENoaWxkLnByb3RvdHlwZVtrZXldO1xuXG4gIFx0XHRpZiAoIShrZXkgaW4gb3B0aW9ucykpIHtcbiAgXHRcdFx0b3B0aW9uc1trZXldID0gdmFsdWUuX21ldGhvZCA/IHZhbHVlLl9tZXRob2QgOiB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gaXMgaXQgYSB3cmFwcGVkIGZ1bmN0aW9uP1xuICBcdFx0ZWxzZSBpZiAodHlwZW9mIG9wdGlvbnNba2V5XSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmIG9wdGlvbnNba2V5XS5fbWV0aG9kKSB7XG5cbiAgXHRcdFx0dmFyIHJlc3VsdCA9IHVuZGVmaW5lZCxcbiAgXHRcdFx0ICAgIG5lZWRzU3VwZXIgPSB2YWx1ZS5fbWV0aG9kO1xuXG4gIFx0XHRcdGlmIChuZWVkc1N1cGVyKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5fbWV0aG9kO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gcmV3cmFwIGJvdW5kIGRpcmVjdGx5IHRvIHBhcmVudCBmblxuICBcdFx0XHRyZXN1bHQgPSB3cmFwTWV0aG9kKG9wdGlvbnNba2V5XS5fbWV0aG9kLCB2YWx1ZSk7XG5cbiAgXHRcdFx0aWYgKG5lZWRzU3VwZXIpIHtcbiAgXHRcdFx0XHRyZXN1bHQuX21ldGhvZCA9IHJlc3VsdDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdG9wdGlvbnNba2V5XSA9IHJlc3VsdDtcbiAgXHRcdH1cbiAgXHR9KTtcbiAgfVxuXG4gIHZhciBfZXh0ZW5kID0gX2V4dGVuZF9fZXh0ZW5kO1xuXG4gIGZ1bmN0aW9uIF9leHRlbmRfX2V4dGVuZCgpIHtcbiAgXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgb3B0aW9ucyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0b3B0aW9uc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHR9XG5cbiAgXHRpZiAoIW9wdGlvbnMubGVuZ3RoKSB7XG4gIFx0XHRyZXR1cm4gZXh0ZW5kT25lKHRoaXMpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gb3B0aW9ucy5yZWR1Y2UoZXh0ZW5kT25lLCB0aGlzKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmRPbmUoUGFyZW50KSB7XG4gIFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gIFx0dmFyIENoaWxkLCBwcm90bztcblxuICBcdC8vIGlmIHdlJ3JlIGV4dGVuZGluZyB3aXRoIGFub3RoZXIgUmFjdGl2ZSBpbnN0YW5jZS4uLlxuICBcdC8vXG4gIFx0Ly8gICB2YXIgSHVtYW4gPSBSYWN0aXZlLmV4dGVuZCguLi4pLCBTcGlkZXIgPSBSYWN0aXZlLmV4dGVuZCguLi4pO1xuICBcdC8vICAgdmFyIFNwaWRlcm1hbiA9IEh1bWFuLmV4dGVuZCggU3BpZGVyICk7XG4gIFx0Ly9cbiAgXHQvLyAuLi5pbmhlcml0IHByb3RvdHlwZSBtZXRob2RzIGFuZCBkZWZhdWx0IG9wdGlvbnMgYXMgd2VsbFxuICBcdGlmIChvcHRpb25zLnByb3RvdHlwZSBpbnN0YW5jZW9mIF9SYWN0aXZlKSB7XG4gIFx0XHRvcHRpb25zID0gdW53cmFwRXh0ZW5kZWQob3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0Q2hpbGQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIENoaWxkKSkgcmV0dXJuIG5ldyBDaGlsZChvcHRpb25zKTtcbiAgXHRcdGluaXRpYWxpc2UodGhpcywgb3B0aW9ucyk7XG4gIFx0fTtcblxuICBcdHByb3RvID0gY3JlYXRlKFBhcmVudC5wcm90b3R5cGUpO1xuICBcdHByb3RvLmNvbnN0cnVjdG9yID0gQ2hpbGQ7XG5cbiAgXHQvLyBTdGF0aWMgcHJvcGVydGllc1xuICBcdGRlZmluZVByb3BlcnRpZXMoQ2hpbGQsIHtcbiAgXHRcdC8vIGFsaWFzIHByb3RvdHlwZSBhcyBkZWZhdWx0c1xuICBcdFx0ZGVmYXVsdHM6IHsgdmFsdWU6IHByb3RvIH0sXG5cbiAgXHRcdC8vIGV4dGVuZGFibGVcbiAgXHRcdGV4dGVuZDogeyB2YWx1ZTogX2V4dGVuZF9fZXh0ZW5kLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0sXG5cbiAgXHRcdC8vIFBhcmVudCAtIGZvciBJRTgsIGNhbid0IHVzZSBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbiAgXHRcdF9QYXJlbnQ6IHsgdmFsdWU6IFBhcmVudCB9XG4gIFx0fSk7XG5cbiAgXHQvLyBleHRlbmQgY29uZmlndXJhdGlvblxuICBcdGNvbmZpZ19jb25maWcuZXh0ZW5kKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpO1xuXG4gIFx0Y3VzdG9tX2RhdGEuZXh0ZW5kKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpO1xuXG4gIFx0aWYgKG9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgXHRcdHByb3RvLmNvbXB1dGVkID0gdXRpbHNfb2JqZWN0X19leHRlbmQoY3JlYXRlKFBhcmVudC5wcm90b3R5cGUuY29tcHV0ZWQpLCBvcHRpb25zLmNvbXB1dGVkKTtcbiAgXHR9XG5cbiAgXHRDaGlsZC5wcm90b3R5cGUgPSBwcm90bztcblxuICBcdHJldHVybiBDaGlsZDtcbiAgfVxuXG4gIHZhciBnZXROb2RlSW5mbyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIFx0dmFyIGluZm8gPSB7fSxcbiAgXHQgICAgcHJpdixcbiAgXHQgICAgaW5kaWNlcztcblxuICBcdGlmICghbm9kZSB8fCAhKHByaXYgPSBub2RlLl9yYWN0aXZlKSkge1xuICBcdFx0cmV0dXJuIGluZm87XG4gIFx0fVxuXG4gIFx0aW5mby5yYWN0aXZlID0gcHJpdi5yb290O1xuICBcdGluZm8ua2V5cGF0aCA9IHByaXYua2V5cGF0aC5zdHI7XG4gIFx0aW5mby5pbmRleCA9IHt9O1xuXG4gIFx0Ly8gZmluZCBhbGwgaW5kZXggcmVmZXJlbmNlcyBhbmQgcmVzb2x2ZSB0aGVtXG4gIFx0aWYgKGluZGljZXMgPSBSZXNvbHZlcnNfZmluZEluZGV4UmVmcyhwcml2LnByb3h5LnBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0aW5mby5pbmRleCA9IFJlc29sdmVyc19maW5kSW5kZXhSZWZzLnJlc29sdmUoaW5kaWNlcyk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGluZm87XG4gIH07XG5cbiAgdmFyIFJhY3RpdmUsIHByb3BlcnRpZXM7XG5cbiAgLy8gTWFpbiBSYWN0aXZlIHJlcXVpcmVkIG9iamVjdFxuICBSYWN0aXZlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFjdGl2ZSkpIHJldHVybiBuZXcgUmFjdGl2ZShvcHRpb25zKTtcbiAgXHRpbml0aWFsaXNlKHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIC8vIFJhY3RpdmUgcHJvcGVydGllc1xuICBwcm9wZXJ0aWVzID0ge1xuXG4gIFx0Ly8gZGVidWcgZmxhZ1xuICBcdERFQlVHOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdHJ1ZSB9LFxuICBcdERFQlVHX1BST01JU0VTOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdHJ1ZSB9LFxuXG4gIFx0Ly8gc3RhdGljIG1ldGhvZHM6XG4gIFx0ZXh0ZW5kOiB7IHZhbHVlOiBfZXh0ZW5kIH0sXG4gIFx0Z2V0Tm9kZUluZm86IHsgdmFsdWU6IGdldE5vZGVJbmZvIH0sXG4gIFx0cGFyc2U6IHsgdmFsdWU6IF9wYXJzZSB9LFxuXG4gIFx0Ly8gTmFtZXNwYWNlZCBjb25zdHJ1Y3RvcnNcbiAgXHRQcm9taXNlOiB7IHZhbHVlOiB1dGlsc19Qcm9taXNlIH0sXG5cbiAgXHQvLyBzdXBwb3J0XG4gIFx0c3ZnOiB7IHZhbHVlOiBzdmcgfSxcbiAgXHRtYWdpYzogeyB2YWx1ZTogZW52aXJvbm1lbnRfX21hZ2ljIH0sXG5cbiAgXHQvLyB2ZXJzaW9uXG4gIFx0VkVSU0lPTjogeyB2YWx1ZTogXCIwLjcuM1wiIH0sXG5cbiAgXHQvLyBQbHVnaW5zXG4gIFx0YWRhcHRvcnM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuICBcdGNvbXBvbmVudHM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuICBcdGRlY29yYXRvcnM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuICBcdGVhc2luZzogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHN0YXRpY19lYXNpbmcgfSxcbiAgXHRldmVudHM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuICBcdGludGVycG9sYXRvcnM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBzdGF0aWNfaW50ZXJwb2xhdG9ycyB9LFxuICBcdHBhcnRpYWxzOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcbiAgXHR0cmFuc2l0aW9uczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH1cbiAgfTtcblxuICAvLyBSYWN0aXZlIHByb3BlcnRpZXNcbiAgZGVmaW5lUHJvcGVydGllcyhSYWN0aXZlLCBwcm9wZXJ0aWVzKTtcblxuICBSYWN0aXZlLnByb3RvdHlwZSA9IHV0aWxzX29iamVjdF9fZXh0ZW5kKHByb3RvdHlwZSwgY29uZmlnX2RlZmF1bHRzKTtcblxuICBSYWN0aXZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJhY3RpdmU7XG5cbiAgLy8gYWxpYXMgcHJvdG90eXBlIGFzIGRlZmF1bHRzXG4gIFJhY3RpdmUuZGVmYXVsdHMgPSBSYWN0aXZlLnByb3RvdHlwZTtcblxuICAvLyBSYWN0aXZlLmpzIG1ha2VzIGxpYmVyYWwgdXNlIG9mIHRoaW5ncyBsaWtlIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLiBJblxuICAvLyBvbGRlciBicm93c2VycywgdGhlc2UgYXJlIG1hZGUgYXZhaWxhYmxlIHZpYSBhIHNoaW0gLSBoZXJlLCB3ZSBkbyBhIHF1aWNrXG4gIC8vIHByZS1mbGlnaHQgY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXQgZWl0aGVyIGEpIHdlJ3JlIG5vdCBpbiBhIHNoaXQgYnJvd3NlcixcbiAgLy8gb3IgYikgd2UncmUgdXNpbmcgYSBSYWN0aXZlLWxlZ2FjeS5qcyBidWlsZFxuICB2YXIgRlVOQ1RJT04gPSBcImZ1bmN0aW9uXCI7XG5cbiAgaWYgKHR5cGVvZiBEYXRlLm5vdyAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIFN0cmluZy5wcm90b3R5cGUudHJpbSAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIE9iamVjdC5rZXlzICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5tYXAgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZmlsdGVyICE9PSBGVU5DVElPTiB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gRlVOQ1RJT04pIHtcbiAgXHR0aHJvdyBuZXcgRXJyb3IoXCJJdCBsb29rcyBsaWtlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVzZSBSYWN0aXZlLmpzIGluIGFuIG9sZGVyIGJyb3dzZXIuIFlvdSdsbCBuZWVkIHRvIHVzZSBvbmUgb2YgdGhlICdsZWdhY3kgYnVpbGRzJyBpbiBvcmRlciB0byBjb250aW51ZSAtIHNlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9sZWdhY3ktYnVpbGRzIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiKTtcbiAgfVxuXG4gIHZhciBfUmFjdGl2ZSA9IFJhY3RpdmU7XG5cbiAgcmV0dXJuIF9SYWN0aXZlO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYWN0aXZlLmpzLm1hcFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmFjdGl2ZS9yYWN0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==');

},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(clearImmediate, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var setImmediate;\n\n    function addFromSetImmediateArguments(args) {\n        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);\n        return nextHandle++;\n    }\n\n    // This function accepts the same arguments as setImmediate, but\n    // returns a function that requires no arguments.\n    function partiallyApplied(handler) {\n        var args = [].slice.call(arguments, 1);\n        return function() {\n            if (typeof handler === "function") {\n                handler.apply(undefined, args);\n            } else {\n                (new Function("" + handler))();\n            }\n        };\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(partiallyApplied(runIfPresent, handle), 0);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    task();\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function installNextTickImplementation() {\n        setImmediate = function() {\n            var handle = addFromSetImmediateArguments(arguments);\n            process.nextTick(partiallyApplied(runIfPresent, handle));\n            return handle;\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        setImmediate = function() {\n            var handle = addFromSetImmediateArguments(arguments);\n            global.postMessage(messagePrefix + handle, "*");\n            return handle;\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        setImmediate = function() {\n            var handle = addFromSetImmediateArguments(arguments);\n            channel.port2.postMessage(handle);\n            return handle;\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        setImmediate = function() {\n            var handle = addFromSetImmediateArguments(arguments);\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n            return handle;\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        setImmediate = function() {\n            var handle = addFromSetImmediateArguments(arguments);\n            setTimeout(partiallyApplied(runIfPresent, handle), 0);\n            return handle;\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(new Function("return this")()));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1).clearImmediate, __webpack_require__(2)))\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NldEltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanM/MjliZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHNldEltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJncykge1xuICAgICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gcGFydGlhbGx5QXBwbGllZC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgc2V0SW1tZWRpYXRlLCBidXRcbiAgICAvLyByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXF1aXJlcyBubyBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gcGFydGlhbGx5QXBwbGllZChoYW5kbGVyKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKG5ldyBGdW5jdGlvbihcIlwiICsgaGFuZGxlcikpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChwYXJ0aWFsbHlBcHBsaWVkKHJ1bklmUHJlc2VudCwgaGFuZGxlKSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrKCk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2socGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHBhcnRpYWxseUFwcGxpZWQocnVuSWZQcmVzZW50LCBoYW5kbGUpLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufShuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpKSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zZXRJbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==')}]);