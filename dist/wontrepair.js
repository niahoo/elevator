!function(n){function g(t){if(e[t])return e[t].exports;var c=e[t]={exports:{},id:t,loaded:!1};return n[t].call(c.exports,c,c.exports,g),c.loaded=!0,c.exports}var e={};return g.m=n,g.c=e,g.p="",g(0)}([function(module,exports,__webpack_require__){eval("var graphics = __webpack_require__(4)\nvar elevator = __webpack_require__(3)\nvar Storey = __webpack_require__(5)\nvar CONF = __webpack_require__(1)\n\nconsole.log('WontRepair initializing')\n\nwindow.WontRepair = function(node) {\n	// initialize\n	var storeys = [new Storey(0), new Storey(1), new Storey(2)]\n	var elv = elevator.createElevator()\n	var renderer = graphics.createRenderer({\n		domnode:node,\n		elevator:elv,\n		storeys: storeys\n	})\n	window.elv = elv // DEBUG\n	setTimeout(function(){ elv.addWaypointUp(1) }, 1000)\n}\n\nconsole.log('WontRepair installed')\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvbWFpbi5qcz8xZTNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDOztBQUVBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ3JhcGhpY3MgPSByZXF1aXJlKCdncmFwaGljcycpXG52YXIgZWxldmF0b3IgPSByZXF1aXJlKCdlbGV2YXRvcicpXG52YXIgU3RvcmV5ID0gcmVxdWlyZSgnbW9kZWwvU3RvcmV5JylcbnZhciBDT05GID0gcmVxdWlyZSgnY29uZicpXG5cbmNvbnNvbGUubG9nKCdXb250UmVwYWlyIGluaXRpYWxpemluZycpXG5cbndpbmRvdy5Xb250UmVwYWlyID0gZnVuY3Rpb24obm9kZSkge1xuXHQvLyBpbml0aWFsaXplXG5cdHZhciBzdG9yZXlzID0gW25ldyBTdG9yZXkoMCksIG5ldyBTdG9yZXkoMSksIG5ldyBTdG9yZXkoMildXG5cdHZhciBlbHYgPSBlbGV2YXRvci5jcmVhdGVFbGV2YXRvcigpXG5cdHZhciByZW5kZXJlciA9IGdyYXBoaWNzLmNyZWF0ZVJlbmRlcmVyKHtcblx0XHRkb21ub2RlOm5vZGUsXG5cdFx0ZWxldmF0b3I6ZWx2LFxuXHRcdHN0b3JleXM6IHN0b3JleXNcblx0fSlcblx0d2luZG93LmVsdiA9IGVsdiAvLyBERUJVR1xuXHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IGVsdi5hZGRXYXlwb2ludFVwKDEpIH0sIDEwMDApXG59XG5cbmNvbnNvbGUubG9nKCdXb250UmVwYWlyIGluc3RhbGxlZCcpXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL2pzL21haW4uanNcbiAqKiBtb2R1bGUgaWQgPSAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("\nvar conf = {\n	storeyHeight: 100,\n	storeyWidth: 200,\n	storeySpacing: 12,\n	initialStoreyCount: 3,\n	initialElevatorPostion: 0, // it's a storey index\n	buildingX: 20,\n	buildingWallThickness: 5,\n	svgHeight: 1000,\n	svgWidth: 400,\n	elevatorHeight:70,\n	elevatorWidth:100,\n	storeyElevatorSpacing:10, // horizontal spacing,\n	storeyTravelDuration: {\n		down:500,\n		up:700\n	}\n}\n\nconf.elevatorX = conf.buildingX + conf.buildingWallThickness + conf.storeyWidth + conf.storeyElevatorSpacing\n\nmodule.exports = conf\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvY29uZi5qcz81MzhhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGNvbmYgPSB7XG5cdHN0b3JleUhlaWdodDogMTAwLFxuXHRzdG9yZXlXaWR0aDogMjAwLFxuXHRzdG9yZXlTcGFjaW5nOiAxMixcblx0aW5pdGlhbFN0b3JleUNvdW50OiAzLFxuXHRpbml0aWFsRWxldmF0b3JQb3N0aW9uOiAwLCAvLyBpdCdzIGEgc3RvcmV5IGluZGV4XG5cdGJ1aWxkaW5nWDogMjAsXG5cdGJ1aWxkaW5nV2FsbFRoaWNrbmVzczogNSxcblx0c3ZnSGVpZ2h0OiAxMDAwLFxuXHRzdmdXaWR0aDogNDAwLFxuXHRlbGV2YXRvckhlaWdodDo3MCxcblx0ZWxldmF0b3JXaWR0aDoxMDAsXG5cdHN0b3JleUVsZXZhdG9yU3BhY2luZzoxMCwgLy8gaG9yaXpvbnRhbCBzcGFjaW5nLFxuXHRzdG9yZXlUcmF2ZWxEdXJhdGlvbjoge1xuXHRcdGRvd246NTAwLFxuXHRcdHVwOjcwMFxuXHR9XG59XG5cbmNvbmYuZWxldmF0b3JYID0gY29uZi5idWlsZGluZ1ggKyBjb25mLmJ1aWxkaW5nV2FsbFRoaWNrbmVzcyArIGNvbmYuc3RvcmV5V2lkdGggKyBjb25mLnN0b3JleUVsZXZhdG9yU3BhY2luZ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmZcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9hcHAvanMvY29uZi5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**\n * @license\n * lodash 3.7.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern -d -o ./index.js`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '3.7.0';\n\n  /** Used to compose bitmasks for wrapper metadata. */\n  var BIND_FLAG = 1,\n      BIND_KEY_FLAG = 2,\n      CURRY_BOUND_FLAG = 4,\n      CURRY_FLAG = 8,\n      CURRY_RIGHT_FLAG = 16,\n      PARTIAL_FLAG = 32,\n      PARTIAL_RIGHT_FLAG = 64,\n      ARY_FLAG = 128,\n      REARG_FLAG = 256;\n\n  /** Used as default options for `_.trunc`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect when a function becomes hot. */\n  var HOT_COUNT = 150,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_DROP_WHILE_FLAG = 0,\n      LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2;\n\n  /** Used as the `TypeError` message for \"Functions\" methods. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      objectTag = '[object Object]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      weakMapTag = '[object WeakMap]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,\n      reUnescapedHtml = /[&<>\"'`]/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]+|([\"'])(?:(?!\\1)[^\\n\\\\]|\\\\.)*?)\\1\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\n\\\\]|\\\\.)*?)\\2)\\]/g;\n\n  /**\n   * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).\n   * In addition to special characters the forward slash is escaped to allow for\n   * easier `eval` use and `Function` compilation.\n   */\n  var reRegExpChars = /[.*+?^${}()|[\\]\\/\\\\]/g,\n      reHasRegExpChars = RegExp(reRegExpChars.source);\n\n  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */\n  var reComboMark = /[\\u0300-\\u036f\\ufe20-\\ufe23]/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /** Used to match [ES template delimiters](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-template-literal-lexical-components). */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect hexadecimal string values. */\n  var reHasHexPrefix = /^0[xX]/;\n\n  /** Used to detect host constructors (Safari > 5). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */\n  var reLatin1 = /[\\xc0-\\xd6\\xd8-\\xde\\xdf-\\xf6\\xf8-\\xff]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to match words to create compound words. */\n  var reWords = (function() {\n    var upper = '[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]',\n        lower = '[a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff]+';\n\n    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');\n  }());\n\n  /** Used to detect and test for whitespace. */\n  var whitespace = (\n    // Basic whitespace characters.\n    ' \\t\\x0b\\f\\xa0\\ufeff' +\n\n    // Line terminators.\n    '\\n\\r\\u2028\\u2029' +\n\n    // Unicode category \"Zs\" space separators.\n    '\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000'\n  );\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',\n    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document',\n    'isFinite', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    'window'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dateTag] = typedArrayTags[errorTag] =\n  typedArrayTags[funcTag] = typedArrayTags[mapTag] =\n  typedArrayTags[numberTag] = typedArrayTags[objectTag] =\n  typedArrayTags[regexpTag] = typedArrayTags[setTag] =\n  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =\n  cloneableTags[dateTag] = cloneableTags[float32Tag] =\n  cloneableTags[float64Tag] = cloneableTags[int8Tag] =\n  cloneableTags[int16Tag] = cloneableTags[int32Tag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[stringTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[mapTag] = cloneableTags[setTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used as an internal `_.debounce` options object by `_.throttle`. */\n  var debounceOptions = {\n    'leading': false,\n    'maxWait': 0,\n    'trailing': false\n  };\n\n  /** Used to map latin-1 supplementary letters to basic latin letters. */\n  var deburredLetters = {\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcC': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xeC': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '`': '&#96;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\",\n    '&#96;': '`'\n  };\n\n  /** Used to determine if values are of the language type `Object`. */\n  var objectTypes = {\n    'function': true,\n    'object': true\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Detect free variable `exports`. */\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = objectTypes[typeof self] && self && self.Object && self;\n\n  /** Detect free variable `window`. */\n  var freeWindow = objectTypes[typeof window] && window && window.Object && window;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /**\n   * Used as a reference to the global object.\n   *\n   * The `this` value is used if it is the global object to avoid Greasemonkey's\n   * restricted `window` object, otherwise the `window` object is used.\n   */\n  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The base implementation of `compareAscending` which compares values and\n   * sorts them in ascending order without guaranteeing a stable sort.\n   *\n   * @private\n   * @param {*} value The value to compare to `other`.\n   * @param {*} other The value to compare to `value`.\n   * @returns {number} Returns the sort order indicator for `value`.\n   */\n  function baseCompareAscending(value, other) {\n    if (value !== other) {\n      var valIsReflexive = value === value,\n          othIsReflexive = other === other;\n\n      if (value > other || !valIsReflexive || (value === undefined && othIsReflexive)) {\n        return 1;\n      }\n      if (value < other || !othIsReflexive || (other === undefined && valIsReflexive)) {\n        return -1;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for callback shorthands and `this` binding.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromRight) {\n    var length = array.length,\n        index = fromRight ? length : -1;\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without support for binary searches.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    if (value !== value) {\n      return indexOfNaN(array, fromIndex);\n    }\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isFunction` without support for environments\n   * with incorrect `typeof` results.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n   */\n  function baseIsFunction(value) {\n    // Avoid a Chakra JIT bug in compatibility modes of IE 11.\n    // See https://github.com/jashkenas/underscore/issues/1621 for more details.\n    return typeof value == 'function' || false;\n  }\n\n  /**\n   * Converts `value` to a string if it is not one. An empty string is returned\n   * for `null` or `undefined` values.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n  function baseToString(value) {\n    if (typeof value == 'string') {\n      return value;\n    }\n    return value == null ? '' : (value + '');\n  }\n\n  /**\n   * Used by `_.max` and `_.min` as the default callback for string values.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the code unit of the first character of the string.\n   */\n  function charAtCallback(string) {\n    return string.charCodeAt(0);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimLeft` to get the index of the first character\n   * of `string` that is not found in `chars`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @param {string} chars The characters to find.\n   * @returns {number} Returns the index of the first character not found in `chars`.\n   */\n  function charsLeftIndex(string, chars) {\n    var index = -1,\n        length = string.length;\n\n    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimRight` to get the index of the last character\n   * of `string` that is not found in `chars`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @param {string} chars The characters to find.\n   * @returns {number} Returns the index of the last character not found in `chars`.\n   */\n  function charsRightIndex(string, chars) {\n    var index = string.length;\n\n    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.sortBy` to compare transformed elements of a collection and stable\n   * sort them in ascending order.\n   *\n   * @private\n   * @param {Object} object The object to compare to `other`.\n   * @param {Object} other The object to compare to `object`.\n   * @returns {number} Returns the sort order indicator for `object`.\n   */\n  function compareAscending(object, other) {\n    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);\n  }\n\n  /**\n   * Used by `_.sortByOrder` to compare multiple properties of each element\n   * in a collection and stable sort them in the following order:\n   *\n   * If `orders` is unspecified, sort in ascending order for all properties.\n   * Otherwise, for each property, sort in ascending order if its corresponding value in\n   * orders is true, and descending order if false.\n   *\n   * @private\n   * @param {Object} object The object to compare to `other`.\n   * @param {Object} other The object to compare to `object`.\n   * @param {boolean[]} orders The order to sort by for each property.\n   * @returns {number} Returns the sort order indicator for `object`.\n   */\n  function compareMultiple(object, other, orders) {\n    var index = -1,\n        objCriteria = object.criteria,\n        othCriteria = other.criteria,\n        length = objCriteria.length,\n        ordersLength = orders.length;\n\n    while (++index < length) {\n      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);\n      if (result) {\n        if (index >= ordersLength) {\n          return result;\n        }\n        return result * (orders[index] ? 1 : -1);\n      }\n    }\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to provide the same value for\n    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n    // for more details.\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.\n    return object.index - other.index;\n  }\n\n  /**\n   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  function deburrLetter(letter) {\n    return deburredLetters[letter];\n  }\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeHtmlChar(chr) {\n    return htmlEscapes[chr];\n  }\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled\n   * string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the index at which the first occurrence of `NaN` is found in `array`.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched `NaN`, else `-1`.\n   */\n  function indexOfNaN(array, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 0 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      var other = array[index];\n      if (other !== other) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Checks if `value` is object-like.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   */\n  function isObjectLike(value) {\n    return !!value && typeof value == 'object';\n  }\n\n  /**\n   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a\n   * character code is whitespace.\n   *\n   * @private\n   * @param {number} charCode The character code to inspect.\n   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.\n   */\n  function isSpace(charCode) {\n    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||\n      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = -1,\n        result = [];\n\n    while (++index < length) {\n      if (array[index] === placeholder) {\n        array[index] = PLACEHOLDER;\n        result[++resIndex] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * An implementation of `_.uniq` optimized for sorted arrays without support\n   * for callback shorthands and `this` binding.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} [iteratee] The function invoked per iteration.\n   * @returns {Array} Returns the new duplicate-value-free array.\n   */\n  function sortedUniq(array, iteratee) {\n    var seen,\n        index = -1,\n        length = array.length,\n        resIndex = -1,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index],\n          computed = iteratee ? iteratee(value, index, array) : value;\n\n      if (!index || seen !== computed) {\n        seen = computed;\n        result[++resIndex] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the first non-whitespace character.\n   */\n  function trimmedLeftIndex(string) {\n    var index = -1,\n        length = string.length;\n\n    while (++index < length && isSpace(string.charCodeAt(index))) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */\n  function trimmedRightIndex(string) {\n    var index = string.length;\n\n    while (index-- && isSpace(string.charCodeAt(index))) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  function unescapeHtmlChar(chr) {\n    return htmlUnescapes[chr];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the given `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @category Utility\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // using `context` to mock `Date#getTime` use in `_.now`\n   * var mock = _.runInContext({\n   *   'Date': function() {\n   *     return { 'getTime': getTimeMock };\n   *   }\n   * });\n   *\n   * // or creating a suped-up `defer` in Node.js\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  function runInContext(context) {\n    // Avoid issues with some ES3 environments that attempt to use values, named\n    // after built-in constructors like `Object`, for the creation of literals.\n    // ES5 clears this up by stating that literals must use built-in constructors.\n    // See https://es5.github.io/#x11.1.5 for more details.\n    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;\n\n    /** Native constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Number = context.Number,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for native method references. */\n    var arrayProto = Array.prototype,\n        objectProto = Object.prototype,\n        stringProto = String.prototype;\n\n    /** Used to detect DOM support. */\n    var document = (document = context.window) && document.document;\n\n    /** Used to resolve the decompiled source of functions. */\n    var fnToString = Function.prototype.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /**\n     * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n     * of values.\n     */\n    var objToString = objectProto.toString;\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = context._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      escapeRegExp(objToString)\n      .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Native method references. */\n    var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer,\n        bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,\n        ceil = Math.ceil,\n        clearTimeout = context.clearTimeout,\n        floor = Math.floor,\n        getOwnPropertySymbols = isNative(getOwnPropertySymbols = Object.getOwnPropertySymbols) && getOwnPropertySymbols,\n        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,\n        push = arrayProto.push,\n        preventExtensions = isNative(Object.preventExtensions = Object.preventExtensions) && preventExtensions,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        Set = isNative(Set = context.Set) && Set,\n        setTimeout = context.setTimeout,\n        splice = arrayProto.splice,\n        Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array,\n        WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;\n\n    /** Used to clone array buffers. */\n    var Float64Array = (function() {\n      // Safari 5 errors when using an array buffer to initialize a typed array\n      // where the array buffer's `byteLength` is not a multiple of the typed\n      // array's `BYTES_PER_ELEMENT`.\n      try {\n        var func = isNative(func = context.Float64Array) && func,\n            result = new func(new ArrayBuffer(10), 0, 1) && func;\n      } catch(e) {}\n      return result;\n    }());\n\n    /** Used as `baseAssign`. */\n    var nativeAssign = (function() {\n      // Avoid `Object.assign` in Firefox 34-37 which have an early implementation\n      // with a now defunct try/catch behavior. See https://bugzilla.mozilla.org/show_bug.cgi?id=1103344\n      // for more details.\n      //\n      // Use `Object.preventExtensions` on a plain object instead of simply using\n      // `Object('x')` because Chrome and IE fail to throw an error when attempting\n      // to assign values to readonly indexes of strings in strict mode.\n      var object = { '1': 0 },\n          func = preventExtensions && isNative(func = Object.assign) && func;\n\n      try { func(preventExtensions(object), 'xo'); } catch(e) {}\n      return !object[1] && func;\n    }());\n\n    /* Native method references for those with the same name as other `lodash` methods. */\n    var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,\n        nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,\n        nativeIsFinite = context.isFinite,\n        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = isNative(nativeNow = Date.now) && nativeNow,\n        nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random;\n\n    /** Used as references for `-Infinity` and `Infinity`. */\n    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,\n        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\n\n    /** Used as references for the maximum length and index of an array. */\n    var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,\n        MAX_ARRAY_INDEX =  MAX_ARRAY_LENGTH - 1,\n        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n    /** Used as the size, in bytes, of each `Float64Array` element. */\n    var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;\n\n    /**\n     * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n     * of an array-like value.\n     */\n    var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit chaining.\n     * Methods that operate on and return arrays, collections, and functions can\n     * be chained together. Methods that return a boolean or single value will\n     * automatically end the chain returning the unwrapped value. Explicit chaining\n     * may be enabled using `_.chain`. The execution of chained methods is lazy,\n     * that is, execution is deferred until `_#value` is implicitly or explicitly\n     * called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut\n     * fusion is an optimization that merges iteratees to avoid creating intermediate\n     * arrays and reduce the number of iteratee executions.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,\n     * `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,\n     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,\n     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,\n     * and `where`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,\n     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,\n     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defer`, `delay`,\n     * `difference`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `fill`,\n     * `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`, `forEach`,\n     * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,\n     * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,\n     * `keysIn`, `map`, `mapValues`, `matches`, `matchesProperty`, `memoize`,\n     * `merge`, `mixin`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,\n     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,\n     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `reverse`,\n     * `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`, `sortByOrder`, `splice`,\n     * `spread`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `tap`,\n     * `throttle`, `thru`, `times`, `toArray`, `toPlainObject`, `transform`,\n     * `union`, `uniq`, `unshift`, `unzip`, `values`, `valuesIn`, `where`,\n     * `without`, `wrap`, `xor`, `zip`, and `zipObject`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `clone`, `cloneDeep`, `deburr`,\n     * `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,\n     * `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`, `has`,\n     * `identity`, `includes`, `indexOf`, `inRange`, `isArguments`, `isArray`,\n     * `isBoolean`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isError`, `isFinite`\n     * `isFunction`, `isMatch`, `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`,\n     * `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `isTypedArray`,\n     * `join`, `kebabCase`, `last`, `lastIndexOf`, `max`, `min`, `noConflict`,\n     * `noop`, `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`,\n     * `reduce`, `reduceRight`, `repeat`, `result`, `runInContext`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`, `startsWith`,\n     * `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`, `unescape`,\n     * `uniqueId`, `value`, and `words`\n     *\n     * The wrapper method `sample` will return a wrapped value when `n` is provided,\n     * otherwise an unwrapped value is returned.\n     *\n     * @name _\n     * @constructor\n     * @category Chain\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // returns an unwrapped value\n     * wrapped.reduce(function(total, n) {\n     *   return total + n;\n     * });\n     * // => 6\n     *\n     * // returns a wrapped value\n     * var squares = wrapped.map(function(n) {\n     *   return n * n;\n     * });\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The function whose prototype all chaining wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.\n     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.\n     */\n    function LodashWrapper(value, chainAll, actions) {\n      this.__wrapped__ = value;\n      this.__actions__ = actions || [];\n      this.__chain__ = !!chainAll;\n    }\n\n    /**\n     * An object environment feature flags.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    var support = lodash.support = {};\n\n    (function(x) {\n      var Ctor = function() { this.x = x; },\n          object = { '0': x, 'length': x },\n          props = [];\n\n      Ctor.prototype = { 'valueOf': x, 'y': x };\n      for (var key in new Ctor) { props.push(key); }\n\n      /**\n       * Detect if functions can be decompiled by `Function#toString`\n       * (all but Firefox OS certified apps, older Opera mobile browsers, and\n       * the PlayStation 3; forced `false` for Windows 8 apps).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.funcDecomp = /\\bthis\\b/.test(function() { return this; });\n\n      /**\n       * Detect if `Function#name` is supported (all but IE).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.funcNames = typeof Function.name == 'string';\n\n      /**\n       * Detect if the DOM is supported.\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      try {\n        support.dom = document.createDocumentFragment().nodeType === 11;\n      } catch(e) {\n        support.dom = false;\n      }\n\n      /**\n       * Detect if `arguments` object indexes are non-enumerable.\n       *\n       * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object\n       * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat\n       * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`\n       * checks for indexes that exceed the number of function parameters and\n       * whose associated argument values are `0`.\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      try {\n        support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);\n      } catch(e) {\n        support.nonEnumArgs = true;\n      }\n    }(1, 0));\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB). Change the following template settings to use\n     * alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type string\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type Object\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type Function\n         */\n        '_': lodash\n      }\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = null;\n      this.__dir__ = 1;\n      this.__dropCount__ = 0;\n      this.__filtered__ = false;\n      this.__iteratees__ = null;\n      this.__takeCount__ = POSITIVE_INFINITY;\n      this.__views__ = null;\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var actions = this.__actions__,\n          iteratees = this.__iteratees__,\n          views = this.__views__,\n          result = new LazyWrapper(this.__wrapped__);\n\n      result.__actions__ = actions ? arrayCopy(actions) : null;\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = views ? arrayCopy(views) : null;\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value();\n      if (!isArray(array)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var dir = this.__dir__,\n          isRight = dir < 0,\n          view = getView(0, array.length, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          takeCount = nativeMin(length, this.__takeCount__),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees ? iteratees.length : 0,\n          resIndex = 0,\n          result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type;\n\n          if (type == LAZY_DROP_WHILE_FLAG) {\n            if (data.done && (isRight ? (index > data.index) : (index < data.index))) {\n              data.count = 0;\n              data.done = false;\n            }\n            data.index = index;\n            if (!data.done) {\n              var limit = data.limit;\n              if (!(data.done = limit > -1 ? (data.count++ >= limit) : !iteratee(value))) {\n                continue outer;\n              }\n            }\n          } else {\n            var computed = iteratee(value);\n            if (type == LAZY_MAP_FLAG) {\n              value = computed;\n            } else if (!computed) {\n              if (type == LAZY_FILTER_FLAG) {\n                continue outer;\n              } else {\n                break outer;\n              }\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a cache object to store key/value pairs.\n     *\n     * @private\n     * @static\n     * @name Cache\n     * @memberOf _.memoize\n     */\n    function MapCache() {\n      this.__data__ = {};\n    }\n\n    /**\n     * Removes `key` and its value from the cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf _.memoize.Cache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.\n     */\n    function mapDelete(key) {\n      return this.has(key) && delete this.__data__[key];\n    }\n\n    /**\n     * Gets the cached value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf _.memoize.Cache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the cached value.\n     */\n    function mapGet(key) {\n      return key == '__proto__' ? undefined : this.__data__[key];\n    }\n\n    /**\n     * Checks if a cached value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf _.memoize.Cache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapHas(key) {\n      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);\n    }\n\n    /**\n     * Sets `value` to `key` of the cache.\n     *\n     * @private\n     * @name set\n     * @memberOf _.memoize.Cache\n     * @param {string} key The key of the value to cache.\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache object.\n     */\n    function mapSet(key, value) {\n      if (key != '__proto__') {\n        this.__data__[key] = value;\n      }\n      return this;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates a cache object to store unique values.\n     *\n     * @private\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var length = values ? values.length : 0;\n\n      this.data = { 'hash': nativeCreate(null), 'set': new Set };\n      while (length--) {\n        this.push(values[length]);\n      }\n    }\n\n    /**\n     * Checks if `value` is in `cache` mimicking the return signature of\n     * `_.indexOf` by returning `0` if the value is found, else `-1`.\n     *\n     * @private\n     * @param {Object} cache The cache to search.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `0` if `value` is found, else `-1`.\n     */\n    function cacheIndexOf(cache, value) {\n      var data = cache.data,\n          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];\n\n      return result ? 0 : -1;\n    }\n\n    /**\n     * Adds `value` to the cache.\n     *\n     * @private\n     * @name push\n     * @memberOf SetCache\n     * @param {*} value The value to cache.\n     */\n    function cachePush(value) {\n      var data = this.data;\n      if (typeof value == 'string' || isObject(value)) {\n        data.set.add(value);\n      } else {\n        data.hash[value] = true;\n      }\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayCopy(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * A specialized version of `_.forEach` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayEach(array, iteratee) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        if (iteratee(array[index], index, array) === false) {\n          break;\n        }\n      }\n      return array;\n    }\n\n    /**\n     * A specialized version of `_.forEachRight` for arrays without support for\n     * callback shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayEachRight(array, iteratee) {\n      var length = array.length;\n\n      while (length--) {\n        if (iteratee(array[length], length, array) === false) {\n          break;\n        }\n      }\n      return array;\n    }\n\n    /**\n     * A specialized version of `_.every` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     */\n    function arrayEvery(array, predicate) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        if (!predicate(array[index], index, array)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * A specialized version of `_.filter` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function arrayFilter(array, predicate) {\n      var index = -1,\n          length = array.length,\n          resIndex = -1,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result[++resIndex] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.map` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function arrayMap(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = iteratee(array[index], index, array);\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.max` for arrays without support for iteratees.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     */\n    function arrayMax(array) {\n      var index = -1,\n          length = array.length,\n          result = NEGATIVE_INFINITY;\n\n      while (++index < length) {\n        var value = array[index];\n        if (value > result) {\n          result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.min` for arrays without support for iteratees.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     */\n    function arrayMin(array) {\n      var index = -1,\n          length = array.length,\n          result = POSITIVE_INFINITY;\n\n      while (++index < length) {\n        var value = array[index];\n        if (value < result) {\n          result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.reduce` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {boolean} [initFromArray] Specify using the first element of `array`\n     *  as the initial value.\n     * @returns {*} Returns the accumulated value.\n     */\n    function arrayReduce(array, iteratee, accumulator, initFromArray) {\n      var index = -1,\n          length = array.length;\n\n      if (initFromArray && length) {\n        accumulator = array[++index];\n      }\n      while (++index < length) {\n        accumulator = iteratee(accumulator, array[index], index, array);\n      }\n      return accumulator;\n    }\n\n    /**\n     * A specialized version of `_.reduceRight` for arrays without support for\n     * callback shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {boolean} [initFromArray] Specify using the last element of `array`\n     *  as the initial value.\n     * @returns {*} Returns the accumulated value.\n     */\n    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {\n      var length = array.length;\n      if (initFromArray && length) {\n        accumulator = array[--length];\n      }\n      while (length--) {\n        accumulator = iteratee(accumulator, array[length], length, array);\n      }\n      return accumulator;\n    }\n\n    /**\n     * A specialized version of `_.some` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function arraySome(array, predicate) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        if (predicate(array[index], index, array)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `_.sum` for arrays without support for iteratees.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     */\n    function arraySum(array) {\n      var length = array.length,\n          result = 0;\n\n      while (length--) {\n        result += +array[length] || 0;\n      }\n      return result;\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assign` use.\n     *\n     * @private\n     * @param {*} objectValue The destination object property value.\n     * @param {*} sourceValue The source object property value.\n     * @returns {*} Returns the value to assign to the destination object.\n     */\n    function assignDefaults(objectValue, sourceValue) {\n      return objectValue === undefined ? sourceValue : objectValue;\n    }\n\n    /**\n     * Used by `_.template` to customize its `_.assign` use.\n     *\n     * **Note:** This function is like `assignDefaults` except that it ignores\n     * inherited property values when checking if a property is `undefined`.\n     *\n     * @private\n     * @param {*} objectValue The destination object property value.\n     * @param {*} sourceValue The source object property value.\n     * @param {string} key The key associated with the object and source values.\n     * @param {Object} object The destination object.\n     * @returns {*} Returns the value to assign to the destination object.\n     */\n    function assignOwnDefaults(objectValue, sourceValue, key, object) {\n      return (objectValue === undefined || !hasOwnProperty.call(object, key))\n        ? sourceValue\n        : objectValue;\n    }\n\n    /**\n     * A specialized version of `_.assign` for customizing assigned values without\n     * support for argument juggling, multiple sources, and `this` binding `customizer`\n     * functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     */\n    function assignWith(object, source, customizer) {\n      var props = keys(source);\n      push.apply(props, getSymbols(source));\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index],\n            value = object[key],\n            result = customizer(value, source[key], key, object, source);\n\n        if ((result === result ? (result !== value) : (value === value)) ||\n            (value === undefined && !(key in object))) {\n          object[key] = result;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for argument juggling,\n     * multiple sources, and `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    var baseAssign = nativeAssign || function(object, source) {\n      return source == null\n        ? object\n        : baseCopy(source, getSymbols(source), baseCopy(source, keys(source), object));\n    };\n\n    /**\n     * The base implementation of `_.at` without support for string collections\n     * and individual key arguments.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {number[]|string[]} props The property names or indexes of elements to pick.\n     * @returns {Array} Returns the new array of picked elements.\n     */\n    function baseAt(collection, props) {\n      var index = -1,\n          length = collection.length,\n          isArr = isLength(length),\n          propsLength = props.length,\n          result = Array(propsLength);\n\n      while(++index < propsLength) {\n        var key = props[index];\n        if (isArr) {\n          result[index] = isIndex(key, length) ? collection[key] : undefined;\n        } else {\n          result[index] = collection[key];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property names to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @returns {Object} Returns `object`.\n     */\n    function baseCopy(source, props, object) {\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n        object[key] = source[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `_.callback` which supports specifying the\n     * number of arguments to provide to `func`.\n     *\n     * @private\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {number} [argCount] The number of arguments to provide to `func`.\n     * @returns {Function} Returns the callback.\n     */\n    function baseCallback(func, thisArg, argCount) {\n      var type = typeof func;\n      if (type == 'function') {\n        return thisArg === undefined\n          ? func\n          : bindCallback(func, thisArg, argCount);\n      }\n      if (func == null) {\n        return identity;\n      }\n      if (type == 'object') {\n        return baseMatches(func);\n      }\n      return thisArg === undefined\n        ? property(func)\n        : baseMatchesProperty(func, thisArg);\n    }\n\n    /**\n     * The base implementation of `_.clone` without support for argument juggling\n     * and `this` binding `customizer` functions.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @param {Function} [customizer] The function to customize cloning values.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The object `value` belongs to.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates clones with source counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {\n      var result;\n      if (customizer) {\n        result = object ? customizer(value, key, object) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return arrayCopy(value, result);\n        }\n      } else {\n        var tag = objToString.call(value),\n            isFunc = tag == funcTag;\n\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = initCloneObject(isFunc ? {} : value);\n          if (!isDeep) {\n            return baseAssign(result, value);\n          }\n        } else {\n          return cloneableTags[tag]\n            ? initCloneByTag(value, tag, isDeep)\n            : (object ? value : {});\n        }\n      }\n      // Check for circular references and return corresponding clone.\n      stackA || (stackA = []);\n      stackB || (stackB = []);\n\n      var length = stackA.length;\n      while (length--) {\n        if (stackA[length] == value) {\n          return stackB[length];\n        }\n      }\n      // Add the source value to the stack of traversed objects and associate it with its clone.\n      stackA.push(value);\n      stackB.push(result);\n\n      // Recursively populate clone (susceptible to call stack limits).\n      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {\n        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} prototype The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function Object() {}\n      return function(prototype) {\n        if (isObject(prototype)) {\n          Object.prototype = prototype;\n          var result = new Object;\n          Object.prototype = null;\n        }\n        return result || context.Object();\n      };\n    }());\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts an index\n     * of where to slice the arguments to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Object} args The arguments provide to `func`.\n     * @returns {number} Returns the timer id.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of `_.difference` which accepts a single array\n     * of values to exclude.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values) {\n      var length = array ? array.length : 0,\n          result = [];\n\n      if (!length) {\n        return result;\n      }\n      var index = -1,\n          indexOf = getIndexOf(),\n          isCommon = indexOf == baseIndexOf,\n          cache = (isCommon && values.length >= 200) ? createCache(values) : null,\n          valuesLength = values.length;\n\n      if (cache) {\n        indexOf = cacheIndexOf;\n        isCommon = false;\n        values = cache;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index];\n\n        if (isCommon && value === value) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === value) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (indexOf(values, value, 0) < 0) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object|string} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object|string} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = start == null ? 0 : (+start || 0);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : (+end || 0);\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : (end >>> 0);\n      start >>>= 0;\n\n      while (start < length) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,\n     * without support for callback shorthands and `this` binding, which iterates\n     * over `collection` using the provided `eachFunc`.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {Function} eachFunc The function to iterate over `collection`.\n     * @param {boolean} [retKey] Specify returning the key of the found element\n     *  instead of the element itself.\n     * @returns {*} Returns the found element or its key, else `undefined`.\n     */\n    function baseFind(collection, predicate, eachFunc, retKey) {\n      var result;\n      eachFunc(collection, function(value, key, collection) {\n        if (predicate(value, key, collection)) {\n          result = retKey ? key : value;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with added support for restricting\n     * flattening and specifying the start index.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {boolean} isDeep Specify a deep flatten.\n     * @param {boolean} isStrict Restrict flattening to arrays and `arguments` objects.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, isDeep, isStrict) {\n      var index = -1,\n          length = array.length,\n          resIndex = -1,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n\n        if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {\n          if (isDeep) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            value = baseFlatten(value, isDeep, isStrict);\n          }\n          var valIndex = -1,\n              valLength = value.length;\n\n          result.length += valLength;\n          while (++valIndex < valLength) {\n            result[++resIndex] = value[valIndex];\n          }\n        } else if (!isStrict) {\n          result[++resIndex] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForIn` and `baseForOwn` which iterates\n     * over `object` properties returned by `keysFunc` invoking `iteratee` for\n     * each property. Iteratee functions may exit iteration early by explicitly\n     * returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forIn` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForIn(object, iteratee) {\n      return baseFor(object, iteratee, keysIn);\n    }\n\n    /**\n     * The base implementation of `_.forOwn` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from those provided.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the new array of filtered property names.\n     */\n    function baseFunctions(object, props) {\n      var index = -1,\n          length = props.length,\n          resIndex = -1,\n          result = [];\n\n      while (++index < length) {\n        var key = props[index];\n        if (isFunction(object[key])) {\n          result[++resIndex] = key;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `get` without support for string paths\n     * and default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path of the property to get.\n     * @param {string} [pathKey] The key representation of path.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path, pathKey) {\n      if (object == null) {\n        return;\n      }\n      if (pathKey !== undefined && pathKey in toObject(object)) {\n        path = [pathKey];\n      }\n      var index = -1,\n          length = path.length;\n\n      while (object != null && ++index < length) {\n        var result = object = object[path[index]];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` without support for `this` binding\n     * `customizer` functions.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparing values.\n     * @param {boolean} [isLoose] Specify performing partial comparisons.\n     * @param {Array} [stackA] Tracks traversed `value` objects.\n     * @param {Array} [stackB] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {\n      // Exit early for identical values.\n      if (value === other) {\n        // Treat `+0` vs. `-0` as not equal.\n        return value !== 0 || (1 / value == 1 / other);\n      }\n      var valType = typeof value,\n          othType = typeof other;\n\n      // Exit early for unlike primitive values.\n      if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||\n          value == null || other == null) {\n        // Return `false` unless both values are `NaN`.\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparing objects.\n     * @param {boolean} [isLoose] Specify performing partial comparisons.\n     * @param {Array} [stackA=[]] Tracks traversed `value` objects.\n     * @param {Array} [stackB=[]] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = arrayTag,\n          othTag = arrayTag;\n\n      if (!objIsArr) {\n        objTag = objToString.call(object);\n        if (objTag == argsTag) {\n          objTag = objectTag;\n        } else if (objTag != objectTag) {\n          objIsArr = isTypedArray(object);\n        }\n      }\n      if (!othIsArr) {\n        othTag = objToString.call(other);\n        if (othTag == argsTag) {\n          othTag = objectTag;\n        } else if (othTag != objectTag) {\n          othIsArr = isTypedArray(other);\n        }\n      }\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && !(objIsArr || objIsObj)) {\n        return equalByTag(object, other, objTag);\n      }\n      if (!isLoose) {\n        var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (valWrapped || othWrapped) {\n          return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      // For more information on detecting circular references see https://es5.github.io/#JO.\n      stackA || (stackA = []);\n      stackB || (stackB = []);\n\n      var length = stackA.length;\n      while (length--) {\n        if (stackA[length] == object) {\n          return stackB[length] == other;\n        }\n      }\n      // Add `object` and `other` to the stack of traversed objects.\n      stackA.push(object);\n      stackB.push(other);\n\n      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);\n\n      stackA.pop();\n      stackB.pop();\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The source property names to match.\n     * @param {Array} values The source values to match.\n     * @param {Array} strictCompareFlags Strict comparison flags for source values.\n     * @param {Function} [customizer] The function to customize comparing objects.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, props, values, strictCompareFlags, customizer) {\n      var index = -1,\n          length = props.length,\n          noCustomizer = !customizer;\n\n      while (++index < length) {\n        if ((noCustomizer && strictCompareFlags[index])\n              ? values[index] !== object[props[index]]\n              : !(props[index] in object)\n            ) {\n          return false;\n        }\n      }\n      index = -1;\n      while (++index < length) {\n        var key = props[index],\n            objValue = object[key],\n            srcValue = values[index];\n\n        if (noCustomizer && strictCompareFlags[index]) {\n          var result = objValue !== undefined || (key in object);\n        } else {\n          result = customizer ? customizer(objValue, srcValue, key) : undefined;\n          if (result === undefined) {\n            result = baseIsEqual(srcValue, objValue, customizer, true);\n          }\n        }\n        if (!result) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for callback shorthands\n     * and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          length = getLength(collection),\n          result = isLength(length) ? Array(length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which does not clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new function.\n     */\n    function baseMatches(source) {\n      var props = keys(source),\n          length = props.length;\n\n      if (!length) {\n        return constant(true);\n      }\n      if (length == 1) {\n        var key = props[0],\n            value = source[key];\n\n        if (isStrictComparable(value)) {\n          return function(object) {\n            if (object == null) {\n              return false;\n            }\n            return object[key] === value && (value !== undefined || (key in toObject(object)));\n          };\n        }\n      }\n      var values = Array(length),\n          strictCompareFlags = Array(length);\n\n      while (length--) {\n        value = source[props[length]];\n        values[length] = value;\n        strictCompareFlags[length] = isStrictComparable(value);\n      }\n      return function(object) {\n        return object != null && baseIsMatch(toObject(object), props, values, strictCompareFlags);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which does not which does\n     * not clone `value`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} value The value to compare.\n     * @returns {Function} Returns the new function.\n     */\n    function baseMatchesProperty(path, value) {\n      var isArr = isArray(path),\n          isCommon = isKey(path) && isStrictComparable(value),\n          pathKey = (path + '');\n\n      path = toPath(path);\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        var key = pathKey;\n        object = toObject(object);\n        if ((isArr || !isCommon) && !(key in object)) {\n          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n          if (object == null) {\n            return false;\n          }\n          key = last(path);\n          object = toObject(object);\n        }\n        return object[key] === value\n          ? (value !== undefined || (key in object))\n          : baseIsEqual(value, object[key], null, true);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for argument juggling,\n     * multiple sources, and `this` binding `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} [customizer] The function to customize merging properties.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     * @returns {Object} Returns `object`.\n     */\n    function baseMerge(object, source, customizer, stackA, stackB) {\n      if (!isObject(object)) {\n        return object;\n      }\n      var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));\n      if (!isSrcArr) {\n        var props = keys(source);\n        push.apply(props, getSymbols(source));\n      }\n      arrayEach(props || source, function(srcValue, key) {\n        if (props) {\n          key = srcValue;\n          srcValue = source[key];\n        }\n        if (isObjectLike(srcValue)) {\n          stackA || (stackA = []);\n          stackB || (stackB = []);\n          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);\n        }\n        else {\n          var value = object[key],\n              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n              isCommon = result === undefined;\n\n          if (isCommon) {\n            result = srcValue;\n          }\n          if ((isSrcArr || result !== undefined) &&\n              (isCommon || (result === result ? (result !== value) : (value === value)))) {\n            object[key] = result;\n          }\n        }\n      });\n      return object;\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize merging properties.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\n      var length = stackA.length,\n          srcValue = source[key];\n\n      while (length--) {\n        if (stackA[length] == srcValue) {\n          object[key] = stackB[length];\n          return;\n        }\n      }\n      var value = object[key],\n          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n          isCommon = result === undefined;\n\n      if (isCommon) {\n        result = srcValue;\n        if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {\n          result = isArray(value)\n            ? value\n            : (getLength(value) ? arrayCopy(value) : []);\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          result = isArguments(value)\n            ? toPlainObject(value)\n            : (isPlainObject(value) ? value : {});\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      // Add the source value to the stack of traversed objects and associate\n      // it with its merged value.\n      stackA.push(srcValue);\n      stackB.push(result);\n\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\n      } else if (result === result ? (result !== value) : (value === value)) {\n        object[key] = result;\n      }\n    }\n\n    /**\n     * The base implementation of `_.property` without support for deep paths.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @returns {Function} Returns the new function.\n     */\n    function baseProperty(key) {\n      return function(object) {\n        return object == null ? undefined : object[key];\n      };\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new function.\n     */\n    function basePropertyDeep(path) {\n      var pathKey = (path + '');\n      path = toPath(path);\n      return function(object) {\n        return baseGet(object, path, pathKey);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * index arguments and capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = indexes.length;\n      while (length--) {\n        var index = parseFloat(indexes[length]);\n        if (index != previous && isIndex(index)) {\n          var previous = index;\n          splice.call(array, index, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for argument juggling\n     * and returning floating-point numbers.\n     *\n     * @private\n     * @param {number} min The minimum possible value.\n     * @param {number} max The maximum possible value.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(min, max) {\n      return min + floor(nativeRandom() * (max - min + 1));\n    }\n\n    /**\n     * The base implementation of `_.reduce` and `_.reduceRight` without support\n     * for callback shorthands and `this` binding, which iterates over `collection`\n     * using the provided `eachFunc`.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {*} accumulator The initial value.\n     * @param {boolean} initFromCollection Specify using the first or last element\n     *  of `collection` as the initial value.\n     * @param {Function} eachFunc The function to iterate over `collection`.\n     * @returns {*} Returns the accumulated value.\n     */\n    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {\n      eachFunc(collection, function(value, index, collection) {\n        accumulator = initFromCollection\n          ? (initFromCollection = false, value)\n          : iteratee(accumulator, value, index, collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop detection.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      start = start == null ? 0 : (+start || 0);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : (+end || 0);\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for callback shorthands\n     * and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortBy` which uses `comparer` to define\n     * the sort order of `array` and replaces criteria objects with their\n     * corresponding values.\n     *\n     * @private\n     * @param {Array} array The array to sort.\n     * @param {Function} comparer The function to define sort order.\n     * @returns {Array} Returns `array`.\n     */\n    function baseSortBy(array, comparer) {\n      var length = array.length;\n\n      array.sort(comparer);\n      while (length--) {\n        array[length] = array[length].value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.sortByOrder` without param guards.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {boolean[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseSortByOrder(collection, iteratees, orders) {\n      var callback = getCallback(),\n          index = -1;\n\n      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });\n\n      var result = baseMap(collection, function(value) {\n        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.sum` without support for callback shorthands\n     * and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {number} Returns the sum.\n     */\n    function baseSum(collection, iteratee) {\n      var result = 0;\n      baseEach(collection, function(value, index, collection) {\n        result += +iteratee(value, index, collection) || 0;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.uniq` without support for callback shorthands\n     * and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The function invoked per iteration.\n     * @returns {Array} Returns the new duplicate-value-free array.\n     */\n    function baseUniq(array, iteratee) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = array.length,\n          isCommon = indexOf == baseIndexOf,\n          isLarge = isCommon && length >= 200,\n          seen = isLarge ? createCache() : null,\n          result = [];\n\n      if (seen) {\n        indexOf = cacheIndexOf;\n        isCommon = false;\n      } else {\n        isLarge = false;\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value, index, array) : value;\n\n        if (isCommon && value === value) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (indexOf(seen, computed, 0) < 0) {\n          if (iteratee || isLarge) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.values` and `_.valuesIn` which creates an\n     * array of `object` property values corresponding to the property names\n     * of `props`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} props The property names to get values for.\n     * @returns {Object} Returns the array of property values.\n     */\n    function baseValues(object, props) {\n      var index = -1,\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = object[props[index]];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,\n     * and `_.takeWhile` without support for callback shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to peform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      var index = -1,\n          length = actions.length;\n\n      while (++index < length) {\n        var args = [result],\n            action = actions[index];\n\n        push.apply(args, action.args);\n        result = action.func.apply(action.thisArg, args);\n      }\n      return result;\n    }\n\n    /**\n     * Performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function binaryIndex(array, value, retHighest) {\n      var low = 0,\n          high = array ? array.length : low;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (retHighest ? (computed <= value) : (computed < value)) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return binaryIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * This function is like `binaryIndex` except that it invokes `iteratee` for\n     * `value` and each element of `array` to compute their sort ranking. The\n     * iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function binaryIndexBy(array, value, iteratee, retHighest) {\n      value = iteratee(value);\n\n      var low = 0,\n          high = array ? array.length : 0,\n          valIsNaN = value !== value,\n          valIsUndef = value === undefined;\n\n      while (low < high) {\n        var mid = floor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            isReflexive = computed === computed;\n\n        if (valIsNaN) {\n          var setLow = isReflexive || retHighest;\n        } else if (valIsUndef) {\n          setLow = isReflexive && (retHighest || computed !== undefined);\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * A specialized version of `baseCallback` which only supports `this` binding\n     * and specifying the number of arguments to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {number} [argCount] The number of arguments to provide to `func`.\n     * @returns {Function} Returns the callback.\n     */\n    function bindCallback(func, thisArg, argCount) {\n      if (typeof func != 'function') {\n        return identity;\n      }\n      if (thisArg === undefined) {\n        return func;\n      }\n      switch (argCount) {\n        case 1: return function(value) {\n          return func.call(thisArg, value);\n        };\n        case 3: return function(value, index, collection) {\n          return func.call(thisArg, value, index, collection);\n        };\n        case 4: return function(accumulator, value, index, collection) {\n          return func.call(thisArg, accumulator, value, index, collection);\n        };\n        case 5: return function(value, other, key, object, source) {\n          return func.call(thisArg, value, other, key, object, source);\n        };\n      }\n      return function() {\n        return func.apply(thisArg, arguments);\n      };\n    }\n\n    /**\n     * Creates a clone of the given array buffer.\n     *\n     * @private\n     * @param {ArrayBuffer} buffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function bufferClone(buffer) {\n      return bufferSlice.call(buffer, 0);\n    }\n    if (!bufferSlice) {\n      // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.\n      bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {\n        var byteLength = buffer.byteLength,\n            floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,\n            offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,\n            result = new ArrayBuffer(byteLength);\n\n        if (floatLength) {\n          var view = new Float64Array(result, 0, floatLength);\n          view.set(new Float64Array(buffer, 0, floatLength));\n        }\n        if (byteLength != offset) {\n          view = new Uint8Array(result, offset);\n          view.set(new Uint8Array(buffer, offset));\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array|Object} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders) {\n      var holdersLength = holders.length,\n          argsIndex = -1,\n          argsLength = nativeMax(args.length - holdersLength, 0),\n          leftIndex = -1,\n          leftLength = partials.length,\n          result = Array(argsLength + leftLength);\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        result[holders[argsIndex]] = args[argsIndex];\n      }\n      while (argsLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array|Object} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders) {\n      var holdersIndex = -1,\n          holdersLength = holders.length,\n          argsIndex = -1,\n          argsLength = nativeMax(args.length - holdersLength, 0),\n          rightIndex = -1,\n          rightLength = partials.length,\n          result = Array(argsLength + rightLength);\n\n      while (++argsIndex < argsLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var pad = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[pad + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        result[pad + holders[holdersIndex]] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * Creates a function that aggregates a collection, creating an accumulator\n     * object composed from the results of running each element in the collection\n     * through an iteratee.\n     *\n     * **Note:** This function is used to create `_.countBy`, `_.groupBy`, `_.indexBy`,\n     * and `_.partition`.\n     *\n     * @private\n     * @param {Function} setter The function to set keys and values of the accumulator object.\n     * @param {Function} [initializer] The function to initialize the accumulator object.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee, thisArg) {\n        var result = initializer ? initializer() : {};\n        iteratee = getCallback(iteratee, thisArg, 3);\n\n        if (isArray(collection)) {\n          var index = -1,\n              length = collection.length;\n\n          while (++index < length) {\n            var value = collection[index];\n            setter(result, value, iteratee(value, index, collection), collection);\n          }\n        } else {\n          baseEach(collection, function(value, key, collection) {\n            setter(result, value, iteratee(value, key, collection), collection);\n          });\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that assigns properties of source object(s) to a given\n     * destination object.\n     *\n     * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return restParam(function(object, sources) {\n        var index = -1,\n            length = object == null ? 0 : sources.length,\n            customizer = length > 2 && sources[length - 2],\n            guard = length > 2 && sources[2],\n            thisArg = length > 1 && sources[length - 1];\n\n        if (typeof customizer == 'function') {\n          customizer = bindCallback(customizer, thisArg, 5);\n          length -= 2;\n        } else {\n          customizer = typeof thisArg == 'function' ? thisArg : null;\n          length -= (customizer ? 1 : 0);\n        }\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? null : customizer;\n          length = 1;\n        }\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        var length = collection ? getLength(collection) : 0;\n        if (!isLength(length)) {\n          return eachFunc(collection, iteratee);\n        }\n        var index = fromRight ? length : -1,\n            iterable = toObject(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for `_.forIn` or `_.forInRight`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var iterable = toObject(object),\n            props = keysFunc(object),\n            length = props.length,\n            index = fromRight ? length : -1;\n\n        while ((fromRight ? index-- : ++index < length)) {\n          var key = props[index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` and invokes it with the `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to bind.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new bound function.\n     */\n    function createBindWrapper(func, thisArg) {\n      var Ctor = createCtorWrapper(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(thisArg, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `Set` cache object to optimize linear searches of large arrays.\n     *\n     * @private\n     * @param {Array} [values] The values to cache.\n     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.\n     */\n    var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {\n      return new SetCache(values);\n    };\n\n    /**\n     * Creates a function that produces compound words out of the words in a\n     * given string.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        var index = -1,\n            array = words(deburr(string)),\n            length = array.length,\n            result = '';\n\n        while (++index < length) {\n          result = callback(result, array[index], index);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtorWrapper(Ctor) {\n      return function() {\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, arguments);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a `_.curry` or `_.curryRight` function.\n     *\n     * @private\n     * @param {boolean} flag The curry bit flag.\n     * @returns {Function} Returns the new curry function.\n     */\n    function createCurry(flag) {\n      function curryFunc(func, arity, guard) {\n        if (guard && isIterateeCall(func, arity, guard)) {\n          arity = null;\n        }\n        var result = createWrapper(func, flag, null, null, null, null, null, arity);\n        result.placeholder = curryFunc.placeholder;\n        return result;\n      }\n      return curryFunc;\n    }\n\n    /**\n     * Creates a `_.max` or `_.min` function.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to get the extremum value from an array.\n     * @param {boolean} [isMin] Specify returning the minimum, instead of the maximum,\n     *  extremum value.\n     * @returns {Function} Returns the new extremum function.\n     */\n    function createExtremum(arrayFunc, isMin) {\n      return function(collection, iteratee, thisArg) {\n        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n          iteratee = null;\n        }\n        var func = getCallback(),\n            noIteratee = iteratee == null;\n\n        if (!(func === baseCallback && noIteratee)) {\n          noIteratee = false;\n          iteratee = func(iteratee, thisArg, 3);\n        }\n        if (noIteratee) {\n          var isArr = isArray(collection);\n          if (!isArr && isString(collection)) {\n            iteratee = charAtCallback;\n          } else {\n            return arrayFunc(isArr ? collection : toIterable(collection));\n          }\n        }\n        return extremumBy(collection, iteratee, isMin);\n      };\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(eachFunc, fromRight) {\n      return function(collection, predicate, thisArg) {\n        predicate = getCallback(predicate, thisArg, 3);\n        if (isArray(collection)) {\n          var index = baseFindIndex(collection, predicate, fromRight);\n          return index > -1 ? collection[index] : undefined;\n        }\n        return baseFind(collection, predicate, eachFunc);\n      }\n    }\n\n    /**\n     * Creates a `_.findIndex` or `_.findLastIndex` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFindIndex(fromRight) {\n      return function(array, predicate, thisArg) {\n        if (!(array && array.length)) {\n          return -1;\n        }\n        predicate = getCallback(predicate, thisArg, 3);\n        return baseFindIndex(array, predicate, fromRight);\n      };\n    }\n\n    /**\n     * Creates a `_.findKey` or `_.findLastKey` function.\n     *\n     * @private\n     * @param {Function} objectFunc The function to iterate over an object.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFindKey(objectFunc) {\n      return function(object, predicate, thisArg) {\n        predicate = getCallback(predicate, thisArg, 3);\n        return baseFind(object, predicate, objectFunc, true);\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return function() {\n        var length = arguments.length;\n        if (!length) {\n          return function() { return arguments[0]; };\n        }\n        var wrapper,\n            index = fromRight ? length : -1,\n            leftIndex = 0,\n            funcs = Array(length);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          var func = funcs[leftIndex++] = arguments[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          var funcName = wrapper ? '' : getFuncName(func);\n          wrapper = funcName == 'wrapper' ? new LodashWrapper([]) : wrapper;\n        }\n        index = wrapper ? -1 : length;\n        while (++index < length) {\n          func = funcs[index];\n          funcName = getFuncName(func);\n\n          var data = funcName == 'wrapper' ? getData(func) : null;\n          if (data && isLaziable(data[0])) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments;\n          if (wrapper && args.length == 1 && isArray(args[0])) {\n            return wrapper.plant(args[0]).value();\n          }\n          var index = 0,\n              result = funcs[index].apply(this, args);\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      };\n    }\n\n    /**\n     * Creates a function for `_.forEach` or `_.forEachRight`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over an array.\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @returns {Function} Returns the new each function.\n     */\n    function createForEach(arrayFunc, eachFunc) {\n      return function(collection, iteratee, thisArg) {\n        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n          ? arrayFunc(collection, iteratee)\n          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));\n      };\n    }\n\n    /**\n     * Creates a function for `_.forIn` or `_.forInRight`.\n     *\n     * @private\n     * @param {Function} objectFunc The function to iterate over an object.\n     * @returns {Function} Returns the new each function.\n     */\n    function createForIn(objectFunc) {\n      return function(object, iteratee, thisArg) {\n        if (typeof iteratee != 'function' || thisArg !== undefined) {\n          iteratee = bindCallback(iteratee, thisArg, 3);\n        }\n        return objectFunc(object, iteratee, keysIn);\n      };\n    }\n\n    /**\n     * Creates a function for `_.forOwn` or `_.forOwnRight`.\n     *\n     * @private\n     * @param {Function} objectFunc The function to iterate over an object.\n     * @returns {Function} Returns the new each function.\n     */\n    function createForOwn(objectFunc) {\n      return function(object, iteratee, thisArg) {\n        if (typeof iteratee != 'function' || thisArg !== undefined) {\n          iteratee = bindCallback(iteratee, thisArg, 3);\n        }\n        return objectFunc(object, iteratee);\n      };\n    }\n\n    /**\n     * Creates a function for `_.padLeft` or `_.padRight`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify padding from the right.\n     * @returns {Function} Returns the new pad function.\n     */\n    function createPadDir(fromRight) {\n      return function(string, length, chars) {\n        string = baseToString(string);\n        return string && ((fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string));\n      };\n    }\n\n    /**\n     * Creates a `_.partial` or `_.partialRight` function.\n     *\n     * @private\n     * @param {boolean} flag The partial bit flag.\n     * @returns {Function} Returns the new partial function.\n     */\n    function createPartial(flag) {\n      var partialFunc = restParam(function(func, partials) {\n        var holders = replaceHolders(partials, partialFunc.placeholder);\n        return createWrapper(func, flag, null, partials, holders);\n      });\n      return partialFunc;\n    }\n\n    /**\n     * Creates a function for `_.reduce` or `_.reduceRight`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over an array.\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @returns {Function} Returns the new each function.\n     */\n    function createReduce(arrayFunc, eachFunc) {\n      return function(collection, iteratee, accumulator, thisArg) {\n        var initFromArray = arguments.length < 3;\n        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n          ? arrayFunc(collection, iteratee, accumulator, initFromArray)\n          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` and invokes it with optional `this`\n     * binding of, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to reference.\n     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & ARY_FLAG,\n          isBind = bitmask & BIND_FLAG,\n          isBindKey = bitmask & BIND_KEY_FLAG,\n          isCurry = bitmask & CURRY_FLAG,\n          isCurryBound = bitmask & CURRY_BOUND_FLAG,\n          isCurryRight = bitmask & CURRY_RIGHT_FLAG;\n\n      var Ctor = !isBindKey && createCtorWrapper(func),\n          key = func;\n\n      function wrapper() {\n        // Avoid `arguments` object use disqualifying optimizations by\n        // converting it to an array before providing it to other functions.\n        var length = arguments.length,\n            index = length,\n            args = Array(length);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight);\n        }\n        if (isCurry || isCurryRight) {\n          var placeholder = wrapper.placeholder,\n              argsHolders = replaceHolders(args, placeholder);\n\n          length -= argsHolders.length;\n          if (length < arity) {\n            var newArgPos = argPos ? arrayCopy(argPos) : null,\n                newArity = nativeMax(arity - length, 0),\n                newsHolders = isCurry ? argsHolders : null,\n                newHoldersRight = isCurry ? null : argsHolders,\n                newPartials = isCurry ? args : null,\n                newPartialsRight = isCurry ? null : args;\n\n            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);\n            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);\n\n            if (!isCurryBound) {\n              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\n            }\n            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],\n                result = createHybridWrapper.apply(undefined, newData);\n\n            if (isLaziable(func)) {\n              setData(result, newData);\n            }\n            result.placeholder = placeholder;\n            return result;\n          }\n        }\n        var thisBinding = isBind ? thisArg : this;\n        if (isBindKey) {\n          func = thisBinding[key];\n        }\n        if (argPos) {\n          args = reorder(args, argPos);\n        }\n        if (isAry && ary < args.length) {\n          args.length = ary;\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? (Ctor || createCtorWrapper(func)) : func;\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates the padding required for `string` based on the given `length`.\n     * The `chars` string is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {string} string The string to create padding for.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the pad for `string`.\n     */\n    function createPadding(string, length, chars) {\n      var strLength = string.length;\n      length = +length;\n\n      if (strLength >= length || !nativeIsFinite(length)) {\n        return '';\n      }\n      var padLength = length - strLength;\n      chars = chars == null ? ' ' : (chars + '');\n      return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);\n    }\n\n    /**\n     * Creates a function that wraps `func` and invokes it with the optional `this`\n     * binding of `thisArg` and the `partials` prepended to those provided to\n     * the wrapper.\n     *\n     * @private\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to the new function.\n     * @returns {Function} Returns the new bound function.\n     */\n    function createPartialWrapper(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & BIND_FLAG,\n          Ctor = createCtorWrapper(func);\n\n      function wrapper() {\n        // Avoid `arguments` object use disqualifying optimizations by\n        // converting it to an array before providing it `func`.\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(argsLength + leftLength);\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.\n     *\n     * @private\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {Function} Returns the new index function.\n     */\n    function createSortedIndex(retHighest) {\n      return function(array, value, iteratee, thisArg) {\n        var func = getCallback(iteratee);\n        return (func === baseCallback && iteratee == null)\n          ? binaryIndex(array, value, retHighest)\n          : binaryIndexBy(array, value, func(iteratee, thisArg, 1), retHighest);\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to reference.\n     * @param {number} bitmask The bitmask of flags.\n     *  The bitmask may be composed of the following flags:\n     *     1 - `_.bind`\n     *     2 - `_.bindKey`\n     *     4 - `_.curry` or `_.curryRight` of a bound function\n     *     8 - `_.curry`\n     *    16 - `_.curryRight`\n     *    32 - `_.partial`\n     *    64 - `_.partialRight`\n     *   128 - `_.rearg`\n     *   256 - `_.ary`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);\n        partials = holders = null;\n      }\n      length -= (holders ? holders.length : 0);\n      if (bitmask & PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = null;\n      }\n      var data = isBindKey ? null : getData(func),\n          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];\n\n      if (data) {\n        mergeData(newData, data);\n        bitmask = newData[1];\n        arity = newData[9];\n      }\n      newData[9] = arity == null\n        ? (isBindKey ? 0 : func.length)\n        : (nativeMax(arity - length, 0) || 0);\n\n      if (bitmask == BIND_FLAG) {\n        var result = createBindWrapper(newData[0], newData[2]);\n      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {\n        result = createPartialWrapper.apply(undefined, newData);\n      } else {\n        result = createHybridWrapper.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setter(result, newData);\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparing arrays.\n     * @param {boolean} [isLoose] Specify performing partial comparisons.\n     * @param {Array} [stackA] Tracks traversed `value` objects.\n     * @param {Array} [stackB] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {\n      var index = -1,\n          arrLength = array.length,\n          othLength = other.length,\n          result = true;\n\n      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {\n        return false;\n      }\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (result && ++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        result = undefined;\n        if (customizer) {\n          result = isLoose\n            ? customizer(othValue, arrValue, index)\n            : customizer(arrValue, othValue, index);\n        }\n        if (result === undefined) {\n          // Recursively compare arrays (susceptible to call stack limits).\n          if (isLoose) {\n            var othIndex = othLength;\n            while (othIndex--) {\n              othValue = other[othIndex];\n              result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);\n              if (result) {\n                break;\n              }\n            }\n          } else {\n            result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);\n          }\n        }\n      }\n      return !!result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} value The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag) {\n      switch (tag) {\n        case boolTag:\n        case dateTag:\n          // Coerce dates and booleans to numbers, dates to milliseconds and booleans\n          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.\n          return +object == +other;\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case numberTag:\n          // Treat `NaN` vs. `NaN` as equal.\n          return (object != +object)\n            ? other != +other\n            // But, treat `-0` vs. `+0` as not equal.\n            : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings primitives and string\n          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.\n          return object == (other + '');\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparing values.\n     * @param {boolean} [isLoose] Specify performing partial comparisons.\n     * @param {Array} [stackA] Tracks traversed `value` objects.\n     * @param {Array} [stackB] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n      var objProps = keys(object),\n          objLength = objProps.length,\n          othProps = keys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isLoose) {\n        return false;\n      }\n      var skipCtor = isLoose,\n          index = -1;\n\n      while (++index < objLength) {\n        var key = objProps[index],\n            result = isLoose ? key in other : hasOwnProperty.call(other, key);\n\n        if (result) {\n          var objValue = object[key],\n              othValue = other[key];\n\n          result = undefined;\n          if (customizer) {\n            result = isLoose\n              ? customizer(othValue, objValue, key)\n              : customizer(objValue, othValue, key);\n          }\n          if (result === undefined) {\n            // Recursively compare objects (susceptible to call stack limits).\n            result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB);\n          }\n        }\n        if (!result) {\n          return false;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (!skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Gets the extremum value of `collection` invoking `iteratee` for each value\n     * in `collection` to generate the criterion by which the value is ranked.\n     * The `iteratee` is invoked with three arguments: (value, index, collection).\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {boolean} [isMin] Specify returning the minimum, instead of the\n     *  maximum, extremum value.\n     * @returns {*} Returns the extremum value.\n     */\n    function extremumBy(collection, iteratee, isMin) {\n      var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY,\n          computed = exValue,\n          result = computed;\n\n      baseEach(collection, function(value, index, collection) {\n        var current = iteratee(value, index, collection);\n        if ((isMin ? (current < computed) : (current > computed)) ||\n            (current === exValue && current === result)) {\n          computed = current;\n          result = value;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Gets the appropriate \"callback\" function. If the `_.callback` method is\n     * customized this function returns the custom method, otherwise it returns\n     * the `baseCallback` function. If arguments are provided the chosen function\n     * is invoked with them and its result is returned.\n     *\n     * @private\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getCallback(func, thisArg, argCount) {\n      var result = lodash.callback || callback;\n      result = result === callback ? baseCallback : result;\n      return argCount ? result(func, thisArg, argCount) : result;\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    var getFuncName = (function() {\n      if (!support.funcNames) {\n        return constant('');\n      }\n      if (constant.name == 'constant') {\n        return baseProperty('name');\n      }\n      return function(func) {\n        var result = func.name,\n            array = realNames[result],\n            length = array ? array.length : 0;\n\n        while (length--) {\n          var data = array[length],\n              otherFunc = data.func;\n\n          if (otherFunc == null || otherFunc == func) {\n            return data.name;\n          }\n        }\n        return result;\n      };\n    }());\n\n    /**\n     * Gets the appropriate \"indexOf\" function. If the `_.indexOf` method is\n     * customized this function returns the custom method, otherwise it returns\n     * the `baseIndexOf` function. If arguments are provided the chosen function\n     * is invoked with them and its result is returned.\n     *\n     * @private\n     * @returns {Function|number} Returns the chosen function or its result.\n     */\n    function getIndexOf(collection, target, fromIndex) {\n      var result = lodash.indexOf || indexOf;\n      result = result === indexOf ? baseIndexOf : result;\n      return collection ? result(collection, target, fromIndex) : result;\n    }\n\n    /**\n     * Gets the \"length\" property value of `object`.\n     *\n     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n     * in Safari on iOS 8.1 ARM64.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {*} Returns the \"length\" value.\n     */\n    var getLength = baseProperty('length');\n\n    /**\n     * Creates an array of the own symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = !getOwnPropertySymbols ? constant([]) : function(object) {\n      return getOwnPropertySymbols(toObject(object));\n    };\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} [transforms] The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms ? transforms.length : 0;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add array properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      var Ctor = object.constructor;\n      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {\n        Ctor = Object;\n      }\n      return new Ctor;\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return bufferClone(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          var buffer = object.buffer;\n          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          var result = new Ctor(object.source, reFlags.exec(object));\n          result.lastIndex = object.lastIndex;\n      }\n      return result;\n    }\n\n    /**\n     * Invokes the method at `path` on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function invokePath(object, path, args) {\n      if (object != null && !isKey(path, object)) {\n        path = toPath(path);\n        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n        path = last(path);\n      }\n      var func = object == null ? object : object[path];\n      return func == null ? undefined : func.apply(object, args);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      value = +value;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n      return value > -1 && value % 1 == 0 && value < length;\n    }\n\n    /**\n     * Checks if the provided arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number') {\n        var length = getLength(object),\n            prereq = isLength(length) && isIndex(index, length);\n      } else {\n        prereq = type == 'string' && index in object;\n      }\n      if (prereq) {\n        var other = object[index];\n        return value === value ? (value === other) : (other !== other);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      var type = typeof value;\n      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {\n        return true;\n      }\n      if (isArray(value)) {\n        return false;\n      }\n      var result = !reIsDeepProp.test(value);\n      return result || (object != null && value in toObject(object));\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func);\n      return !!funcName && func === lodash[funcName] && funcName in LazyWrapper.prototype;\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     */\n    function isLength(value) {\n      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers required to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`\n     * augment function arguments, making the order in which they are executed important,\n     * preventing the merging of metadata. However, we make an exception for a safe\n     * common case where curried functions have `_.ary` and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < ARY_FLAG;\n\n      var isCombo =\n        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||\n        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||\n        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = arrayCopy(value);\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * A specialized version of `_.pick` that picks `object` properties specified\n     * by `props`.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} props The property names to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function pickByArray(object, props) {\n      object = toObject(object);\n\n      var index = -1,\n          length = props.length,\n          result = {};\n\n      while (++index < length) {\n        var key = props[index];\n        if (key in object) {\n          result[key] = object[key];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.pick` that picks `object` properties `predicate`\n     * returns truthy for.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Object} Returns the new object.\n     */\n    function pickByCallback(object, predicate) {\n      var result = {};\n      baseForIn(object, function(value, key, object) {\n        if (predicate(value, key, object)) {\n          result[key] = value;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = arrayCopy(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity function\n     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = (function() {\n      var count = 0,\n          lastCalled = 0;\n\n      return function(key, value) {\n        var stamp = now(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return key;\n          }\n        } else {\n          count = 0;\n        }\n        return baseSetData(key, value);\n      };\n    }());\n\n    /**\n     * A fallback implementation of `_.isPlainObject` which checks if `value`\n     * is an object created by the `Object` constructor or has a `[[Prototype]]`\n     * of `null`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     */\n    function shimIsPlainObject(value) {\n      var Ctor,\n          support = lodash.support;\n\n      // Exit early for non `Object` objects.\n      if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||\n          (!hasOwnProperty.call(value, 'constructor') &&\n            (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {\n        return false;\n      }\n      // IE < 9 iterates inherited properties before own properties. If the first\n      // iterated property is an object's own property then there are no inherited\n      // enumerable properties.\n      var result;\n      // In most environments an object's own properties are iterated before\n      // its inherited properties. If the last iterated property is an object's\n      // own property then there are no inherited enumerable properties.\n      baseForIn(value, function(subValue, key) {\n        result = key;\n      });\n      return result === undefined || hasOwnProperty.call(value, result);\n    }\n\n    /**\n     * A fallback implementation of `Object.keys` which creates an array of the\n     * own enumerable property names of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function shimKeys(object) {\n      var props = keysIn(object),\n          propsLength = props.length,\n          length = propsLength && object.length,\n          support = lodash.support;\n\n      var allowIndexes = length && isLength(length) &&\n        (isArray(object) || (support.nonEnumArgs && isArguments(object)));\n\n      var index = -1,\n          result = [];\n\n      while (++index < propsLength) {\n        var key = props[index];\n        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to an array-like object if it is not one.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {Array|Object} Returns the array-like object.\n     */\n    function toIterable(value) {\n      if (value == null) {\n        return [];\n      }\n      if (!isLength(getLength(value))) {\n        return values(value);\n      }\n      return isObject(value) ? value : Object(value);\n    }\n\n    /**\n     * Converts `value` to an object if it is not one.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {Object} Returns the object.\n     */\n    function toObject(value) {\n      return isObject(value) ? value : Object(value);\n    }\n\n    /**\n     * Converts `value` to property path array if it is not one.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {Array} Returns the property path array.\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return value;\n      }\n      var result = [];\n      baseToString(value).replace(rePropName, function(match, number, quote, string) {\n        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      return wrapper instanceof LazyWrapper\n        ? wrapper.clone()\n        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `collection` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the new array containing chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if (guard ? isIterateeCall(array, size, guard) : size == null) {\n        size = 1;\n      } else {\n        size = nativeMax(+size || 1, 1);\n      }\n      var index = 0,\n          length = array ? array.length : 0,\n          resIndex = -1,\n          result = Array(ceil(length / size));\n\n      while (index < length) {\n        result[++resIndex] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array ? array.length : 0,\n          resIndex = -1,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[++resIndex] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array excluding all values of the provided arrays using\n     * `SameValueZero` for equality comparisons.\n     *\n     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n     * comparisons are like strict equality comparisons, e.g. `===`, except that\n     * `NaN` matches `NaN`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The arrays of values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.difference([1, 2, 3], [4, 2]);\n     * // => [1, 3]\n     */\n    var difference = restParam(function(array, values) {\n      return (isArray(array) || isArguments(array))\n        ? baseDifference(array, baseFlatten(values, false, true))\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n        n = 1;\n      }\n      return baseSlice(array, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n        n = 1;\n      }\n      n = length - (+n || 0);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * bound to `thisArg` and invoked with three arguments: (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that match the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRightWhile([1, 2, 3], function(n) {\n     *   return n > 1;\n     * });\n     * // => [1]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');\n     * // => ['barney', 'fred']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');\n     * // => ['barney']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.dropRightWhile(users, 'active'), 'user');\n     * // => ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate, thisArg) {\n      return (array && array.length)\n        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * bound to `thisArg` and invoked with three arguments: (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropWhile([1, 2, 3], function(n) {\n     *   return n < 3;\n     * });\n     * // => [3]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');\n     * // => ['fred', 'pebbles']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.dropWhile(users, 'active', false), 'user');\n     * // => ['pebbles']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.dropWhile(users, 'active'), 'user');\n     * // => ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate, thisArg) {\n      return (array && array.length)\n        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8], '*', 1, 2);\n     * // => [4, '*', 8]\n     */\n    function fill(array, value, start, end) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(chr) {\n     *   return chr.user == 'barney';\n     * });\n     * // => 0\n     *\n     * // using the `_.matches` callback shorthand\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.findIndex(users, 'active', false);\n     * // => 0\n     *\n     * // using the `_.property` callback shorthand\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    var findIndex = createFindIndex();\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(chr) {\n     *   return chr.user == 'pebbles';\n     * });\n     * // => 2\n     *\n     * // using the `_.matches` callback shorthand\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.findLastIndex(users, 'active', false);\n     * // => 2\n     *\n     * // using the `_.property` callback shorthand\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    var findLastIndex = createFindIndex(true);\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @alias head\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.first([1, 2, 3]);\n     * // => 1\n     *\n     * _.first([]);\n     * // => undefined\n     */\n    function first(array) {\n      return array ? array[0] : undefined;\n    }\n\n    /**\n     * Flattens a nested array. If `isDeep` is `true` the array is recursively\n     * flattened, otherwise it is only flattened a single level.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isDeep] Specify a deep flatten.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, 3, [4]]]);\n     * // => [1, 2, 3, [4]]\n     *\n     * // using `isDeep`\n     * _.flatten([1, [2, 3, [4]]], true);\n     * // => [1, 2, 3, 4]\n     */\n    function flatten(array, isDeep, guard) {\n      var length = array ? array.length : 0;\n      if (guard && isIterateeCall(array, isDeep, guard)) {\n        isDeep = false;\n      }\n      return length ? baseFlatten(array, isDeep) : [];\n    }\n\n    /**\n     * Recursively flattens a nested array.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to recursively flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, 3, [4]]]);\n     * // => [1, 2, 3, 4]\n     */\n    function flattenDeep(array) {\n      var length = array ? array.length : 0;\n      return length ? baseFlatten(array, true) : [];\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using `SameValueZero` for equality comparisons. If `fromIndex` is negative,\n     * it is used as the offset from the end of `array`. If `array` is sorted\n     * providing `true` for `fromIndex` performs a faster binary search.\n     *\n     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n     * comparisons are like strict equality comparisons, e.g. `===`, except that\n     * `NaN` matches `NaN`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {boolean|number} [fromIndex=0] The index to search from or `true`\n     *  to perform a binary search on a sorted array.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // using `fromIndex`\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     *\n     * // performing a binary search\n     * _.indexOf([1, 1, 2, 2], 2, true);\n     * // => 2\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return -1;\n      }\n      if (typeof fromIndex == 'number') {\n        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;\n      } else if (fromIndex) {\n        var index = binaryIndex(array, value),\n            other = array[index];\n\n        if (value === value ? (value === other) : (other !== other)) {\n          return index;\n        }\n        return -1;\n      }\n      return baseIndexOf(array, value, fromIndex || 0);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      return dropRight(array, 1);\n    }\n\n    /**\n     * Creates an array of unique values in all provided arrays using `SameValueZero`\n     * for equality comparisons.\n     *\n     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n     * comparisons are like strict equality comparisons, e.g. `===`, except that\n     * `NaN` matches `NaN`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of shared values.\n     * @example\n     * _.intersection([1, 2], [4, 2], [2, 1]);\n     * // => [2]\n     */\n    function intersection() {\n      var args = [],\n          argsIndex = -1,\n          argsLength = arguments.length,\n          caches = [],\n          indexOf = getIndexOf(),\n          isCommon = indexOf == baseIndexOf,\n          result = [];\n\n      while (++argsIndex < argsLength) {\n        var value = arguments[argsIndex];\n        if (isArray(value) || isArguments(value)) {\n          args.push(value);\n          caches.push((isCommon && value.length >= 120) ? createCache(argsIndex && value) : null);\n        }\n      }\n      argsLength = args.length;\n      if (argsLength < 2) {\n        return result;\n      }\n      var array = args[0],\n          index = -1,\n          length = array ? array.length : 0,\n          seen = caches[0];\n\n      outer:\n      while (++index < length) {\n        value = array[index];\n        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {\n          argsIndex = argsLength;\n          while (--argsIndex) {\n            var cache = caches[argsIndex];\n            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value, 0)) < 0) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(value);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array ? array.length : 0;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {boolean|number} [fromIndex=array.length-1] The index to search from\n     *  or `true` to perform a binary search on a sorted array.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // using `fromIndex`\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     *\n     * // performing a binary search\n     * _.lastIndexOf([1, 1, 2, 2], 2, true);\n     * // => 3\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (typeof fromIndex == 'number') {\n        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;\n      } else if (fromIndex) {\n        index = binaryIndex(array, value, true) - 1;\n        var other = array[index];\n        if (value === value ? (value === other) : (other !== other)) {\n          return index;\n        }\n        return -1;\n      }\n      if (value !== value) {\n        return indexOfNaN(array, index, true);\n      }\n      while (index--) {\n        if (array[index] === value) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Removes all provided values from `array` using `SameValueZero` for equality\n     * comparisons.\n     *\n     * **Notes:**\n     *  - Unlike `_.without`, this method mutates `array`\n     *  - [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n     *    comparisons are like strict equality comparisons, e.g. `===`, except\n     *    that `NaN` matches `NaN`\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3, 1, 2, 3];\n     *\n     * _.pull(array, 2, 3);\n     * console.log(array);\n     * // => [1, 1]\n     */\n    function pull() {\n      var args = arguments,\n          array = args[0];\n\n      if (!(array && array.length)) {\n        return array;\n      }\n      var index = 0,\n          indexOf = getIndexOf(),\n          length = args.length;\n\n      while (++index < length) {\n        var fromIndex = 0,\n            value = args[index];\n\n        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to the given indexes and returns\n     * an array of the removed elements. Indexes may be specified as an array of\n     * indexes or as individual arguments.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove,\n     *  specified as individual indexes or arrays of indexes.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [5, 10, 15, 20];\n     * var evens = _.pullAt(array, 1, 3);\n     *\n     * console.log(array);\n     * // => [5, 15]\n     *\n     * console.log(evens);\n     * // => [10, 20]\n     */\n    var pullAt = restParam(function(array, indexes) {\n      array || (array = []);\n      indexes = baseFlatten(indexes);\n\n      var result = baseAt(array, indexes);\n      basePullAt(array, indexes.sort(baseCompareAscending));\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is bound to\n     * `thisArg` and invoked with three arguments: (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate, thisArg) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getCallback(predicate, thisArg, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @alias tail\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.rest([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function rest(array) {\n      return drop(array, 1);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of `Array#slice` to support node\n     * lists in IE < 9 and to ensure dense arrays are returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value` should\n     * be inserted into `array` in order to maintain its sort order. If an iteratee\n     * function is provided it is invoked for `value` and each element of `array`\n     * to compute their sort ranking. The iteratee is bound to `thisArg` and\n     * invoked with one argument; (value).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     *\n     * _.sortedIndex([4, 4, 5, 5], 5);\n     * // => 2\n     *\n     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };\n     *\n     * // using an iteratee function\n     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {\n     *   return this.data[word];\n     * }, dict);\n     * // => 1\n     *\n     * // using the `_.property` callback shorthand\n     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');\n     * // => 1\n     */\n    var sortedIndex = createSortedIndex();\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 4, 5, 5], 5);\n     * // => 4\n     */\n    var sortedLastIndex = createSortedIndex(true);\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n        n = 1;\n      }\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n        n = 1;\n      }\n      n = length - (+n || 0);\n      return baseSlice(array, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`\n     * and invoked with three arguments: (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRightWhile([1, 2, 3], function(n) {\n     *   return n > 1;\n     * });\n     * // => [2, 3]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');\n     * // => ['pebbles']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');\n     * // => ['fred', 'pebbles']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.takeRightWhile(users, 'active'), 'user');\n     * // => []\n     */\n    function takeRightWhile(array, predicate, thisArg) {\n      return (array && array.length)\n        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is bound to\n     * `thisArg` and invoked with three arguments: (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeWhile([1, 2, 3], function(n) {\n     *   return n < 3;\n     * });\n     * // => [1, 2]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false},\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');\n     * // => ['barney']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.takeWhile(users, 'active', false), 'user');\n     * // => ['barney', 'fred']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.takeWhile(users, 'active'), 'user');\n     * // => []\n     */\n    function takeWhile(array, predicate, thisArg) {\n      return (array && array.length)\n        ? baseWhile(array, getCallback(predicate, thisArg, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, of the provided arrays using\n     * `SameValueZero` for equality comparisons.\n     *\n     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n     * comparisons are like strict equality comparisons, e.g. `===`, except that\n     * `NaN` matches `NaN`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([1, 2], [4, 2], [2, 1]);\n     * // => [1, 2, 4]\n     */\n    var union = restParam(function(arrays) {\n      return baseUniq(baseFlatten(arrays, false, true));\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using `SameValueZero` for\n     * equality comparisons, in which only the first occurence of each element\n     * is kept. Providing `true` for `isSorted` performs a faster search algorithm\n     * for sorted arrays. If an iteratee function is provided it is invoked for\n     * each element in the array to generate the criterion by which uniqueness\n     * is computed. The `iteratee` is bound to `thisArg` and invoked with three\n     * arguments: (value, index, array).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n     * comparisons are like strict equality comparisons, e.g. `===`, except that\n     * `NaN` matches `NaN`.\n     *\n     * @static\n     * @memberOf _\n     * @alias unique\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {boolean} [isSorted] Specify the array is sorted.\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the new duplicate-value-free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     *\n     * // using `isSorted`\n     * _.uniq([1, 1, 2], true);\n     * // => [1, 2]\n     *\n     * // using an iteratee function\n     * _.uniq([1, 2.5, 1.5, 2], function(n) {\n     *   return this.floor(n);\n     * }, Math);\n     * // => [1, 2.5]\n     *\n     * // using the `_.property` callback shorthand\n     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniq(array, isSorted, iteratee, thisArg) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (isSorted != null && typeof isSorted != 'boolean') {\n        thisArg = iteratee;\n        iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;\n        isSorted = false;\n      }\n      var func = getCallback();\n      if (!(func === baseCallback && iteratee == null)) {\n        iteratee = func(iteratee, thisArg, 3);\n      }\n      return (isSorted && getIndexOf() == baseIndexOf)\n        ? sortedUniq(array, iteratee)\n        : baseUniq(array, iteratee);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-`_.zip`\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['fred', 'barney'], [30, 40], [true, false]]\n     */\n    function unzip(array) {\n      var index = -1,\n          length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = arrayMap(array, baseProperty(index));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array excluding all provided values using `SameValueZero` for\n     * equality comparisons.\n     *\n     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n     * comparisons are like strict equality comparisons, e.g. `===`, except that\n     * `NaN` matches `NaN`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to filter.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.without([1, 2, 1, 3], 1, 2);\n     * // => [3]\n     */\n    var without = restParam(function(array, values) {\n      return (isArray(array) || isArguments(array))\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the provided arrays.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of values.\n     * @example\n     *\n     * _.xor([1, 2], [4, 2]);\n     * // => [1, 4]\n     */\n    function xor() {\n      var index = -1,\n          length = arguments.length;\n\n      while (++index < length) {\n        var array = arguments[index];\n        if (isArray(array) || isArguments(array)) {\n          var result = result\n            ? baseDifference(result, array).concat(baseDifference(array, result))\n            : array;\n        }\n      }\n      return result ? baseUniq(result) : [];\n    }\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the first\n     * elements of the given arrays, the second of which contains the second elements\n     * of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     */\n    var zip = restParam(unzip);\n\n    /**\n     * The inverse of `_.pairs`; this method returns an object composed from arrays\n     * of property names and values. Provide either a single two dimensional array,\n     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names\n     * and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @alias object\n     * @category Array\n     * @param {Array} props The property names.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject([['fred', 30], ['barney', 40]]);\n     * // => { 'fred': 30, 'barney': 40 }\n     *\n     * _.zipObject(['fred', 'barney'], [30, 40]);\n     * // => { 'fred': 30, 'barney': 40 }\n     */\n    function zipObject(props, values) {\n      var index = -1,\n          length = props ? props.length : 0,\n          result = {};\n\n      if (length && !values && !isArray(props[0])) {\n        values = [];\n      }\n      while (++index < length) {\n        var key = props[index];\n        if (values) {\n          result[key] = values[index];\n        } else if (key) {\n          result[key[0]] = key[1];\n        }\n      }\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object that wraps `value` with explicit method\n     * chaining enabled.\n     *\n     * @static\n     * @memberOf _\n     * @category Chain\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _.chain(users)\n     *   .sortBy('age')\n     *   .map(function(chr) {\n     *     return chr.user + ' is ' + chr.age;\n     *   })\n     *   .first()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor is\n     * bound to `thisArg` and invoked with one argument; (value). The purpose of\n     * this method is to \"tap into\" a method chain in order to perform operations\n     * on intermediate results within the chain.\n     *\n     * @static\n     * @memberOf _\n     * @category Chain\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @param {*} [thisArg] The `this` binding of `interceptor`.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor, thisArg) {\n      interceptor.call(thisArg, value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     *\n     * @static\n     * @memberOf _\n     * @category Chain\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @param {*} [thisArg] The `this` binding of `interceptor`.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor, thisArg) {\n      return interceptor.call(thisArg, value);\n    }\n\n    /**\n     * Enables explicit method chaining on the wrapper object.\n     *\n     * @name chain\n     * @memberOf _\n     * @category Chain\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // without explicit chaining\n     * _(users).first();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // with explicit chaining\n     * _(users).chain()\n     *   .first()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chained sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @category Chain\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapper = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapper = wrapper.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapper.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Creates a clone of the chained sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @category Chain\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapper = _(array).map(function(value) {\n     *   return Math.pow(value, 2);\n     * });\n     *\n     * var other = [3, 4];\n     * var otherWrapper = wrapper.plant(other);\n     *\n     * otherWrapper.value();\n     * // => [9, 16]\n     *\n     * wrapper.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * Reverses the wrapped array so the first element becomes the last, the\n     * second element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @category Chain\n     * @returns {Object} Returns the new reversed `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        if (this.__actions__.length) {\n          value = new LazyWrapper(this);\n        }\n        return new LodashWrapper(value.reverse(), this.__chain__);\n      }\n      return this.thru(function(value) {\n        return value.reverse();\n      });\n    }\n\n    /**\n     * Produces the result of coercing the unwrapped value to a string.\n     *\n     * @name toString\n     * @memberOf _\n     * @category Chain\n     * @returns {string} Returns the coerced string value.\n     * @example\n     *\n     * _([1, 2, 3]).toString();\n     * // => '1,2,3'\n     */\n    function wrapperToString() {\n      return (this.value() + '');\n    }\n\n    /**\n     * Executes the chained sequence to extract the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @alias run, toJSON, valueOf\n     * @category Chain\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements corresponding to the given keys, or indexes,\n     * of `collection`. Keys may be specified as individual arguments or as arrays\n     * of keys.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {...(number|number[]|string|string[])} [props] The property names\n     *  or indexes of elements to pick, specified individually or in arrays.\n     * @returns {Array} Returns the new array of picked elements.\n     * @example\n     *\n     * _.at(['a', 'b', 'c'], [0, 2]);\n     * // => ['a', 'c']\n     *\n     * _.at(['barney', 'fred', 'pebbles'], 0, 2);\n     * // => ['barney', 'pebbles']\n     */\n    var at = restParam(function(collection, props) {\n      var length = collection ? getLength(collection) : 0;\n      if (isLength(length)) {\n        collection = toIterable(collection);\n      }\n      return baseAt(collection, baseFlatten(props));\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through `iteratee`. The corresponding value\n     * of each key is the number of times the key was returned by `iteratee`.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(n) {\n     *   return Math.floor(n);\n     * });\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(n) {\n     *   return this.floor(n);\n     * }, Math);\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * The predicate is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias all\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': false },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.every(users, 'active', false);\n     * // => true\n     *\n     * // using the `_.property` callback shorthand\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, thisArg) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\n        predicate = null;\n      }\n      if (typeof predicate != 'function' || thisArg !== undefined) {\n        predicate = getCallback(predicate, thisArg, 3);\n      }\n      return func(collection, predicate);\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias select\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * _.filter([4, 5, 6], function(n) {\n     *   return n % 2 == 0;\n     * });\n     * // => [4, 6]\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');\n     * // => ['barney']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.filter(users, 'active', false), 'user');\n     * // => ['fred']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.filter(users, 'active'), 'user');\n     * // => ['barney']\n     */\n    function filter(collection, predicate, thisArg) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      predicate = getCallback(predicate, thisArg, 3);\n      return func(collection, predicate);\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias detect\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.result(_.find(users, function(chr) {\n     *   return chr.age < 40;\n     * }), 'user');\n     * // => 'barney'\n     *\n     * // using the `_.matches` callback shorthand\n     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');\n     * // => 'pebbles'\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.result(_.find(users, 'active', false), 'user');\n     * // => 'fred'\n     *\n     * // using the `_.property` callback shorthand\n     * _.result(_.find(users, 'active'), 'user');\n     * // => 'barney'\n     */\n    var find = createFind(baseEach);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(baseEachRight, true);\n\n    /**\n     * Performs a deep comparison between each element in `collection` and the\n     * source object, returning the first element that has equivalent property\n     * values.\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties. For comparing a single\n     * own or inherited property value see `_.matchesProperty`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Object} source The object of property values to match.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');\n     * // => 'barney'\n     *\n     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');\n     * // => 'fred'\n     */\n    function findWhere(collection, source) {\n      return find(collection, baseMatches(source));\n    }\n\n    /**\n     * Iterates over elements of `collection` invoking `iteratee` for each element.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection). Iteratee functions may exit iteration early\n     * by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\" property\n     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n     * may be used for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @alias each\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2]).forEach(function(n) {\n     *   console.log(n);\n     * }).value();\n     * // => logs each value from left to right and returns the array\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {\n     *   console.log(n, key);\n     * });\n     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)\n     */\n    var forEach = createForEach(arrayEach, baseEach);\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2]).forEachRight(function(n) {\n     *   console.log(n);\n     * }).value();\n     * // => logs each value from right to left and returns the array\n     */\n    var forEachRight = createForEach(arrayEachRight, baseEachRight);\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through `iteratee`. The corresponding value\n     * of each key is an array of the elements responsible for generating the key.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(n) {\n     *   return Math.floor(n);\n     * });\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(n) {\n     *   return this.floor(n);\n     * }, Math);\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * // using the `_.property` callback shorthand\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        result[key] = [value];\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection` using `SameValueZero` for equality\n     * comparisons. If `fromIndex` is negative, it is used as the offset from\n     * the end of `collection`.\n     *\n     * **Note:** [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)\n     * comparisons are like strict equality comparisons, e.g. `===`, except that\n     * `NaN` matches `NaN`.\n     *\n     * @static\n     * @memberOf _\n     * @alias contains, include\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {*} target The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.\n     * @returns {boolean} Returns `true` if a matching element is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');\n     * // => true\n     *\n     * _.includes('pebbles', 'eb');\n     * // => true\n     */\n    function includes(collection, target, fromIndex, guard) {\n      var length = collection ? getLength(collection) : 0;\n      if (!isLength(length)) {\n        collection = values(collection);\n        length = collection.length;\n      }\n      if (!length) {\n        return false;\n      }\n      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {\n        fromIndex = 0;\n      } else {\n        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);\n      }\n      return (typeof collection == 'string' || !isArray(collection) && isString(collection))\n        ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)\n        : (getIndexOf(collection, target, fromIndex) > -1);\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through `iteratee`. The corresponding value\n     * of each key is the last element responsible for generating the key. The\n     * iteratee function is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var keyData = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.indexBy(keyData, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(keyData, function(object) {\n     *   return String.fromCharCode(object.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(keyData, function(object) {\n     *   return this.fromCharCode(object.code);\n     * }, String);\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     */\n    var indexBy = createAggregator(function(result, value, key) {\n      result[key] = value;\n    });\n\n    /**\n     * Invokes the method at `path` on each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `methodName` is a function it is\n     * invoked for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invoke([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invoke = restParam(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          isProp = isKey(path),\n          length = getLength(collection),\n          result = isLength(length) ? Array(length) : [];\n\n      baseEach(collection, function(value) {\n        var func = isFunc ? path : (isProp && value != null && value[path]);\n        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` through\n     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * Many lodash methods are guarded to work as interatees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`, `drop`,\n     * `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`, `parseInt`,\n     * `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimLeft`,\n     * `trimRight`, `trunc`, `random`, `range`, `sample`, `some`, `uniq`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @alias collect\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function timesThree(n) {\n     *   return n * 3;\n     * }\n     *\n     * _.map([1, 2], timesThree);\n     * // => [3, 6]\n     *\n     * _.map({ 'a': 1, 'b': 2 }, timesThree);\n     * // => [3, 6] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // using the `_.property` callback shorthand\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee, thisArg) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      iteratee = getCallback(iteratee, thisArg, 3);\n      return func(collection, iteratee);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, while the second of which\n     * contains elements `predicate` returns falsey for. The predicate is bound\n     * to `thisArg` and invoked with three arguments: (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * _.partition([1, 2, 3], function(n) {\n     *   return n % 2;\n     * });\n     * // => [[1, 3], [2]]\n     *\n     * _.partition([1.2, 2.3, 3.4], function(n) {\n     *   return this.floor(n) % 2;\n     * }, Math);\n     * // => [[1.2, 3.4], [2.3]]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * var mapper = function(array) {\n     *   return _.pluck(array, 'user');\n     * };\n     *\n     * // using the `_.matches` callback shorthand\n     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);\n     * // => [['pebbles'], ['barney', 'fred']]\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.map(_.partition(users, 'active', false), mapper);\n     * // => [['barney', 'pebbles'], ['fred']]\n     *\n     * // using the `_.property` callback shorthand\n     * _.map(_.partition(users, 'active'), mapper);\n     * // => [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Gets the property value of `path` from all elements in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Array|string} path The path of the property to pluck.\n     * @returns {Array} Returns the property values.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.pluck(users, 'user');\n     * // => ['barney', 'fred']\n     *\n     * var userIndex = _.indexBy(users, 'user');\n     * _.pluck(userIndex, 'age');\n     * // => [36, 40] (iteration order is not guaranteed)\n     */\n    function pluck(collection, path) {\n      return map(collection, property(path));\n    }\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` through `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not provided the first element of `collection` is used as the initial\n     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as interatees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `includes`, `merge`, `sortByAll`, and `sortByOrder`\n     *\n     * @static\n     * @memberOf _\n     * @alias foldl, inject\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.reduce([1, 2], function(total, n) {\n     *   return total + n;\n     * });\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {\n     *   result[key] = n * 3;\n     *   return result;\n     * }, {});\n     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)\n     */\n    var reduce = createReduce(arrayReduce, baseEach);\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias foldr\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    var reduceRight =  createReduce(arrayReduceRight, baseEachRight);\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * _.reject([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 0;\n     * });\n     * // => [1, 3]\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');\n     * // => ['barney']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.reject(users, 'active', false), 'user');\n     * // => ['fred']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.reject(users, 'active'), 'user');\n     * // => ['barney']\n     */\n    function reject(collection, predicate, thisArg) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      predicate = getCallback(predicate, thisArg, 3);\n      return func(collection, function(value, index, collection) {\n        return !predicate(value, index, collection);\n      });\n    }\n\n    /**\n     * Gets a random element or `n` random elements from a collection.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to sample.\n     * @param {number} [n] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {*} Returns the random sample(s).\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     *\n     * _.sample([1, 2, 3, 4], 2);\n     * // => [3, 1]\n     */\n    function sample(collection, n, guard) {\n      if (guard ? isIterateeCall(collection, n, guard) : n == null) {\n        collection = toIterable(collection);\n        var length = collection.length;\n        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;\n      }\n      var result = shuffle(collection);\n      result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);\n      return result;\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      collection = toIterable(collection);\n\n      var index = -1,\n          length = collection.length,\n          result = Array(length);\n\n      while (++index < length) {\n        var rand = baseRandom(0, index);\n        if (index != rand) {\n          result[index] = result[rand];\n        }\n        result[rand] = collection[index];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the size of `collection`.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      var length = collection ? getLength(collection) : 0;\n      return isLength(length) ? length : keys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * The function returns as soon as it finds a passing value and does not iterate\n     * over the entire collection. The predicate is bound to `thisArg` and invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias any\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.some(users, 'active', false);\n     * // => true\n     *\n     * // using the `_.property` callback shorthand\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, thisArg) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\n        predicate = null;\n      }\n      if (typeof predicate != 'function' || thisArg !== undefined) {\n        predicate = getCallback(predicate, thisArg, 3);\n      }\n      return func(collection, predicate);\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection through `iteratee`. This method performs\n     * a stable sort, that is, it preserves the original sort order of equal elements.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * _.sortBy([1, 2, 3], function(n) {\n     *   return Math.sin(n);\n     * });\n     * // => [3, 1, 2]\n     *\n     * _.sortBy([1, 2, 3], function(n) {\n     *   return this.sin(n);\n     * }, Math);\n     * // => [3, 1, 2]\n     *\n     * var users = [\n     *   { 'user': 'fred' },\n     *   { 'user': 'pebbles' },\n     *   { 'user': 'barney' }\n     * ];\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.sortBy(users, 'user'), 'user');\n     * // => ['barney', 'fred', 'pebbles']\n     */\n    function sortBy(collection, iteratee, thisArg) {\n      if (collection == null) {\n        return [];\n      }\n      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n        iteratee = null;\n      }\n      var index = -1;\n      iteratee = getCallback(iteratee, thisArg, 3);\n\n      var result = baseMap(collection, function(value, key, collection) {\n        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };\n      });\n      return baseSortBy(result, compareAscending);\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it can sort by multiple iteratees\n     * or property names.\n     *\n     * If a property name is provided for an iteratee the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If an object is provided for an iteratee the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees\n     *  The iteratees to sort by, specified as individual values or arrays of values.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 42 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.map(_.sortByAll(users, ['user', 'age']), _.values);\n     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]\n     *\n     * _.map(_.sortByAll(users, 'user', function(chr) {\n     *   return Math.floor(chr.age / 10);\n     * }), _.values);\n     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n     */\n    var sortByAll = restParam(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var guard = iteratees[2];\n      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {\n        iteratees.length = 1;\n      }\n      return baseSortByOrder(collection, baseFlatten(iteratees), []);\n    });\n\n    /**\n     * This method is like `_.sortByAll` except that it allows specifying the\n     * sort orders of the iteratees to sort by. A truthy value in `orders` will\n     * sort the corresponding property name in ascending order while a falsey\n     * value will sort it in descending order.\n     *\n     * If a property name is provided for an iteratee the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If an object is provided for an iteratee the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {boolean[]} orders The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 42 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // sort by `user` in ascending order and by `age` in descending order\n     * _.map(_.sortByOrder(users, ['user', 'age'], [true, false]), _.values);\n     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n     */\n    function sortByOrder(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (guard && isIterateeCall(iteratees, orders, guard)) {\n        orders = null;\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseSortByOrder(collection, iteratees, orders);\n    }\n\n    /**\n     * Performs a deep comparison between each element in `collection` and the\n     * source object, returning an array of all elements that have equivalent\n     * property values.\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties. For comparing a single\n     * own or inherited property value see `_.matchesProperty`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Object} source The object of property values to match.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },\n     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');\n     * // => ['barney']\n     *\n     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');\n     * // => ['fred']\n     */\n    function where(collection, source) {\n      return filter(collection, baseMatches(source));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the number of milliseconds that have elapsed since the Unix epoch\n     * (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @category Date\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => logs the number of milliseconds it took for the deferred function to be invoked\n     */\n    var now = nativeNow || function() {\n      return new Date().getTime();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it is called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => logs 'done saving!' after the two async saves have completed\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        if (typeof n == 'function') {\n          var temp = n;\n          n = func;\n          func = temp;\n        } else {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n      }\n      n = nativeIsFinite(n = +n) ? n : 0;\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that accepts up to `n` arguments ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      if (guard && isIterateeCall(func, n, guard)) {\n        n = null;\n      }\n      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);\n      return createWrapper(func, ARY_FLAG, null, null, null, null, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it is called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery('#add').on('click', _.before(5, addContactToList));\n     * // => allows adding up to 4 contacts to the list\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        if (typeof n == 'function') {\n          var temp = n;\n          n = func;\n          func = temp;\n        } else {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n      }\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = null;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and prepends any additional `_.bind` arguments to those provided to the\n     * bound function.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind` this method does not set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var greet = function(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * };\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // using placeholders\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = restParam(function(func, thisArg, partials) {\n      var bitmask = BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, bind.placeholder);\n        bitmask |= PARTIAL_FLAG;\n      }\n      return createWrapper(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method. Method names may be specified as individual arguments or as arrays\n     * of method names. If no method names are provided all enumerable function\n     * properties, own and inherited, of `object` are bound.\n     *\n     * **Note:** This method does not set the \"length\" property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} [methodNames] The object method names to bind,\n     *  specified as individual method names or arrays of method names.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'onClick': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view);\n     * jQuery('#docs').on('click', view.onClick);\n     * // => logs 'clicked docs' when the element is clicked\n     */\n    var bindAll = restParam(function(object, methodNames) {\n      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);\n\n      var index = -1,\n          length = methodNames.length;\n\n      while (++index < length) {\n        var key = methodNames[index];\n        object[key] = createWrapper(object[key], BIND_FLAG, object);\n      }\n      return object;\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` and prepends\n     * any additional `_.bindKey` arguments to those provided to the bound function.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist.\n     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Object} object The object the method belongs to.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // using placeholders\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = restParam(function(object, key, partials) {\n      var bitmask = BIND_FLAG | BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, bindKey.placeholder);\n        bitmask |= PARTIAL_FLAG;\n      }\n      return createWrapper(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts one or more arguments of `func` that when\n     * called either invokes `func` returning its result, if all `func` arguments\n     * have been provided, or returns a function that accepts one or more of the\n     * remaining `func` arguments, and so on. The arity of `func` may be specified\n     * if `func.length` is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method does not set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // using placeholders\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    var curry = createCurry(CURRY_FLAG);\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method does not set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // using placeholders\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    var curryRight = createCurry(CURRY_RIGHT_FLAG);\n\n    /**\n     * Creates a function that delays invoking `func` until after `wait` milliseconds\n     * have elapsed since the last time it was invoked. The created function comes\n     * with a `cancel` method to cancel delayed invocations. Provide an options\n     * object to indicate that `func` should be invoked on the leading and/or\n     * trailing edge of the `wait` timeout. Subsequent calls to the debounced\n     * function return the result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n     * on the trailing edge of the timeout only if the the debounced function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=false] Specify invoking on the leading\n     *  edge of the timeout.\n     * @param {number} [options.maxWait] The maximum time `func` is allowed to be\n     *  delayed before it is invoked.\n     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n     *  edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // avoid costly calculations while the window size is in flux\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls\n     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // ensure `batchLog` is invoked once after 1 second of debounced calls\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', _.debounce(batchLog, 250, {\n     *   'maxWait': 1000\n     * }));\n     *\n     * // cancel a debounced call\n     * var todoChanges = _.debounce(batchLog, 1000);\n     * Object.observe(models.todo, todoChanges);\n     *\n     * Object.observe(models, function(changes) {\n     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {\n     *     todoChanges.cancel();\n     *   }\n     * }, ['delete']);\n     *\n     * // ...at some point `models.todo` is changed\n     * models.todo.completed = true;\n     *\n     * // ...before 1 second has passed `models.todo` is deleted\n     * // which cancels the debounced `todoChanges` call\n     * delete models.todo;\n     */\n    function debounce(func, wait, options) {\n      var args,\n          maxTimeoutId,\n          result,\n          stamp,\n          thisArg,\n          timeoutId,\n          trailingCall,\n          lastCalled = 0,\n          maxWait = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = wait < 0 ? 0 : (+wait || 0);\n      if (options === true) {\n        var leading = true;\n        trailing = false;\n      } else if (isObject(options)) {\n        leading = options.leading;\n        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n\n      function cancel() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        if (maxTimeoutId) {\n          clearTimeout(maxTimeoutId);\n        }\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n      }\n\n      function delayed() {\n        var remaining = wait - (now() - stamp);\n        if (remaining <= 0 || remaining > wait) {\n          if (maxTimeoutId) {\n            clearTimeout(maxTimeoutId);\n          }\n          var isCalled = trailingCall;\n          maxTimeoutId = timeoutId = trailingCall = undefined;\n          if (isCalled) {\n            lastCalled = now();\n            result = func.apply(thisArg, args);\n            if (!timeoutId && !maxTimeoutId) {\n              args = thisArg = null;\n            }\n          }\n        } else {\n          timeoutId = setTimeout(delayed, remaining);\n        }\n      }\n\n      function maxDelayed() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n        if (trailing || (maxWait !== wait)) {\n          lastCalled = now();\n          result = func.apply(thisArg, args);\n          if (!timeoutId && !maxTimeoutId) {\n            args = thisArg = null;\n          }\n        }\n      }\n\n      function debounced() {\n        args = arguments;\n        stamp = now();\n        thisArg = this;\n        trailingCall = trailing && (timeoutId || !leading);\n\n        if (maxWait === false) {\n          var leadingCall = leading && !timeoutId;\n        } else {\n          if (!maxTimeoutId && !leading) {\n            lastCalled = stamp;\n          }\n          var remaining = maxWait - (stamp - lastCalled),\n              isCalled = remaining <= 0 || remaining > maxWait;\n\n          if (isCalled) {\n            if (maxTimeoutId) {\n              maxTimeoutId = clearTimeout(maxTimeoutId);\n            }\n            lastCalled = stamp;\n            result = func.apply(thisArg, args);\n          }\n          else if (!maxTimeoutId) {\n            maxTimeoutId = setTimeout(maxDelayed, remaining);\n          }\n        }\n        if (isCalled && timeoutId) {\n          timeoutId = clearTimeout(timeoutId);\n        }\n        else if (!timeoutId && wait !== maxWait) {\n          timeoutId = setTimeout(delayed, wait);\n        }\n        if (leadingCall) {\n          isCalled = true;\n          result = func.apply(thisArg, args);\n        }\n        if (isCalled && !timeoutId && !maxTimeoutId) {\n          args = thisArg = null;\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // logs 'deferred' after one or more milliseconds\n     */\n    var defer = restParam(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => logs 'later' after one second\n     */\n    var delay = restParam(function(func, wait, args) {\n      return baseDelay(func, wait, args);\n    });\n\n    /**\n     * Creates a function that returns the result of invoking the provided\n     * functions with the `this` binding of the created function, where each\n     * successive invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {...Function} [funcs] Functions to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow(_.add, square);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the provided functions from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias backflow, compose\n     * @category Function\n     * @param {...Function} [funcs] Functions to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight(square, _.add);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is coerced to a string and used as the\n     * cache key. The `func` is invoked with the `this` binding of the memoized\n     * function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the [`Map`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-map-prototype-object)\n     * method interface of `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoizing function.\n     * @example\n     *\n     * var upperCase = _.memoize(function(string) {\n     *   return string.toUpperCase();\n     * });\n     *\n     * upperCase('fred');\n     * // => 'FRED'\n     *\n     * // modifying the result cache\n     * upperCase.cache.set('fred', 'BARNEY');\n     * upperCase('fred');\n     * // => 'BARNEY'\n     *\n     * // replacing `_.memoize.Cache`\n     * var object = { 'user': 'fred' };\n     * var other = { 'user': 'barney' };\n     * var identity = _.memoize(_.identity);\n     *\n     * identity(object);\n     * // => { 'user': 'fred' }\n     * identity(other);\n     * // => { 'user': 'fred' }\n     *\n     * _.memoize.Cache = WeakMap;\n     * var identity = _.memoize(_.identity);\n     *\n     * identity(object);\n     * // => { 'user': 'fred' }\n     * identity(other);\n     * // => { 'user': 'barney' }\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            cache = memoized.cache,\n            key = resolver ? resolver.apply(this, args) : args[0];\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        cache.set(key, result);\n        return result;\n      };\n      memoized.cache = new memoize.Cache;\n      return memoized;\n    }\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        return !predicate.apply(this, arguments);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first call. The `func` is invoked\n     * with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // `initialize` invokes `createApplication` once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with `partial` arguments prepended\n     * to those provided to the new function. This method is like `_.bind` except\n     * it does **not** alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method does not set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) {\n     *   return greeting + ' ' + name;\n     * };\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // using placeholders\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = createPartial(PARTIAL_FLAG);\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to those provided to the new function.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method does not set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) {\n     *   return greeting + ' ' + name;\n     * };\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // using placeholders\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified indexes where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes,\n     *  specified as individual indexes or arrays of indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, 2, 0, 1);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     *\n     * var map = _.rearg(_.map, [1, 0]);\n     * map(function(n) {\n     *   return n * 3;\n     * }, [1, 2, 3]);\n     * // => [3, 6, 9]\n     */\n    var rearg = restParam(function(func, indexes) {\n      return createWrapper(func, REARG_FLAG, null, null, null, baseFlatten(indexes));\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as an array.\n     *\n     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.restParam(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function restParam(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            rest = Array(length);\n\n        while (++index < length) {\n          rest[index] = args[start + index];\n        }\n        switch (start) {\n          case 0: return func.call(this, rest);\n          case 1: return func.call(this, args[0], rest);\n          case 2: return func.call(this, args[0], args[1], rest);\n        }\n        var otherArgs = Array(start + 1);\n        index = -1;\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = rest;\n        return func.apply(this, otherArgs);\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the created\n     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).\n     *\n     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * // with a Promise\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function(array) {\n        return func.apply(this, array);\n      };\n    }\n\n    /**\n     * Creates a function that only invokes `func` at most once per every `wait`\n     * milliseconds. The created function comes with a `cancel` method to cancel\n     * delayed invocations. Provide an options object to indicate that `func`\n     * should be invoked on the leading and/or trailing edge of the `wait` timeout.\n     * Subsequent calls to the throttled function return the result of the last\n     * `func` call.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n     * on the trailing edge of the timeout only if the the throttled function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=true] Specify invoking on the leading\n     *  edge of the timeout.\n     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n     *  edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // avoid excessively updating the position while scrolling\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes\n     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {\n     *   'trailing': false\n     * }));\n     *\n     * // cancel a trailing throttled call\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (options === false) {\n        leading = false;\n      } else if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      debounceOptions.leading = leading;\n      debounceOptions.maxWait = +wait;\n      debounceOptions.trailing = trailing;\n      return debounce(func, wait, debounceOptions);\n    }\n\n    /**\n     * Creates a function that provides `value` to the wrapper function as its\n     * first argument. Any additional arguments provided to the function are\n     * appended to those provided to the wrapper function. The wrapper is invoked\n     * with the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} wrapper The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      wrapper = wrapper == null ? identity : wrapper;\n      return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,\n     * otherwise they are assigned by reference. If `customizer` is provided it is\n     * invoked to produce the cloned values. If `customizer` returns `undefined`\n     * cloning is handled by the method instead. The `customizer` is bound to\n     * `thisArg` and invoked with two argument; (value [, index|key, object]).\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\n     * The enumerable properties of `arguments` objects and objects created by\n     * constructors other than `Object` are cloned to plain `Object` objects. An\n     * empty object is returned for uncloneable values such as functions, DOM nodes,\n     * Maps, Sets, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @param {Function} [customizer] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {*} Returns the cloned value.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * var shallow = _.clone(users);\n     * shallow[0] === users[0];\n     * // => true\n     *\n     * var deep = _.clone(users, true);\n     * deep[0] === users[0];\n     * // => false\n     *\n     * // using a customizer callback\n     * var el = _.clone(document.body, function(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * });\n     *\n     * el === document.body\n     * // => false\n     * el.nodeName\n     * // => BODY\n     * el.childNodes.length;\n     * // => 0\n     */\n    function clone(value, isDeep, customizer, thisArg) {\n      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {\n        isDeep = false;\n      }\n      else if (typeof isDeep == 'function') {\n        thisArg = customizer;\n        customizer = isDeep;\n        isDeep = false;\n      }\n      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);\n      return baseClone(value, isDeep, customizer);\n    }\n\n    /**\n     * Creates a deep clone of `value`. If `customizer` is provided it is invoked\n     * to produce the cloned values. If `customizer` returns `undefined` cloning\n     * is handled by the method instead. The `customizer` is bound to `thisArg`\n     * and invoked with two argument; (value [, index|key, object]).\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\n     * The enumerable properties of `arguments` objects and objects created by\n     * constructors other than `Object` are cloned to plain `Object` objects. An\n     * empty object is returned for uncloneable values such as functions, DOM nodes,\n     * Maps, Sets, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to deep clone.\n     * @param {Function} [customizer] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {*} Returns the deep cloned value.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * var deep = _.cloneDeep(users);\n     * deep[0] === users[0];\n     * // => false\n     *\n     * // using a customizer callback\n     * var el = _.cloneDeep(document.body, function(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * });\n     *\n     * el === document.body\n     * // => false\n     * el.nodeName\n     * // => BODY\n     * el.childNodes.length;\n     * // => 20\n     */\n    function cloneDeep(value, customizer, thisArg) {\n      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);\n      return baseClone(value, true, customizer);\n    }\n\n    /**\n     * Checks if `value` is classified as an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    function isArguments(value) {\n      var length = isObjectLike(value) ? value.length : undefined;\n      return isLength(length) && objToString.call(value) == argsTag;\n    }\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(function() { return arguments; }());\n     * // => false\n     */\n    var isArray = nativeIsArray || function(value) {\n      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n    };\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    function isDate(value) {\n      return isObjectLike(value) && objToString.call(value) == dateTag;\n    }\n\n    /**\n     * Checks if `value` is a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return !!value && value.nodeType === 1 && isObjectLike(value) &&\n        (objToString.call(value).indexOf('Element') > -1);\n    }\n    // Fallback for environments without DOM support.\n    if (!support.dom) {\n      isElement = function(value) {\n        return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);\n      };\n    }\n\n    /**\n     * Checks if `value` is empty. A value is considered empty unless it is an\n     * `arguments` object, array, string, or jQuery-like collection with a length\n     * greater than `0` or an object with own enumerable properties.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {Array|Object|string} value The value to inspect.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      var length = getLength(value);\n      if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||\n          (isObjectLike(value) && isFunction(value.splice)))) {\n        return !length;\n      }\n      return !keys(value).length;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent. If `customizer` is provided it is invoked to compare values.\n     * If `customizer` returns `undefined` comparisons are handled by the method\n     * instead. The `customizer` is bound to `thisArg` and invoked with three\n     * arguments: (value, other [, index|key]).\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties. Functions and DOM nodes\n     * are **not** supported. Provide a customizer function to extend support\n     * for comparing other values.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize value comparisons.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     * var other = { 'user': 'fred' };\n     *\n     * object == other;\n     * // => false\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * // using a customizer callback\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqual(array, other, function(value, other) {\n     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {\n     *     return true;\n     *   }\n     * });\n     * // => true\n     */\n    function isEqual(value, other, customizer, thisArg) {\n      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);\n      if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {\n        return value === other;\n      }\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on [`Number.isFinite`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite).\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(10);\n     * // => true\n     *\n     * _.isFinite('10');\n     * // => false\n     *\n     * _.isFinite(true);\n     * // => false\n     *\n     * _.isFinite(Object(10));\n     * // => false\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     */\n    var isFinite = nativeNumIsFinite || function(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    };\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in older versions of Chrome and Safari which return 'function' for regexes\n      // and Safari 8 equivalents which return 'object' for typed array constructors.\n      return objToString.call(value) == funcTag;\n    };\n\n    /**\n     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(1);\n     * // => false\n     */\n    function isObject(value) {\n      // Avoid a V8 JIT bug in Chrome 19-20.\n      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n      var type = typeof value;\n      return type == 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * Performs a deep comparison between `object` and `source` to determine if\n     * `object` contains equivalent property values. If `customizer` is provided\n     * it is invoked to compare values. If `customizer` returns `undefined`\n     * comparisons are handled by the method instead. The `customizer` is bound\n     * to `thisArg` and invoked with three arguments: (value, other, index|key).\n     *\n     * **Note:** This method supports comparing properties of arrays, booleans,\n     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions\n     * and DOM nodes are **not** supported. Provide a customizer function to extend\n     * support for comparing other values.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize value comparisons.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'user': 'fred', 'age': 40 };\n     *\n     * _.isMatch(object, { 'age': 40 });\n     * // => true\n     *\n     * _.isMatch(object, { 'age': 36 });\n     * // => false\n     *\n     * // using a customizer callback\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatch(object, source, function(value, other) {\n     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;\n     * });\n     * // => true\n     */\n    function isMatch(object, source, customizer, thisArg) {\n      var props = keys(source),\n          length = props.length;\n\n      if (!length) {\n        return true;\n      }\n      if (object == null) {\n        return false;\n      }\n      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);\n      object = toObject(object);\n      if (!customizer && length == 1) {\n        var key = props[0],\n            value = source[key];\n\n        if (isStrictComparable(value)) {\n          return value === object[key] && (value !== undefined || (key in object));\n        }\n      }\n      var values = Array(length),\n          strictCompareFlags = Array(length);\n\n      while (length--) {\n        value = values[length] = source[props[length]];\n        strictCompareFlags[length] = isStrictComparable(value);\n      }\n      return baseIsMatch(object, props, values, strictCompareFlags, customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)\n     * which returns `true` for `undefined` and other non-numeric values.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a native function.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (value == null) {\n        return false;\n      }\n      if (objToString.call(value) == funcTag) {\n        return reIsNative.test(fnToString.call(value));\n      }\n      return isObjectLike(value) && reIsHostCtor.test(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified\n     * as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isNumber(8.4);\n     * // => true\n     *\n     * _.isNumber(NaN);\n     * // => true\n     *\n     * _.isNumber('8.4');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * **Note:** This method assumes objects created by the `Object` constructor\n     * have no inherited enumerable properties.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {\n      if (!(value && objToString.call(value) == objectTag)) {\n        return false;\n      }\n      var valueOf = value.valueOf,\n          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);\n\n      return objProto\n        ? (value == objProto || getPrototypeOf(value) == objProto)\n        : shimIsPlainObject(value);\n    };\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    function isRegExp(value) {\n      return (isObjectLike(value) && objToString.call(value) == regexpTag) || false;\n    }\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    function isTypedArray(value) {\n      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\n    }\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * (function() {\n     *   return _.toArray(arguments).slice(1);\n     * }(1, 2, 3));\n     * // => [2, 3]\n     */\n    function toArray(value) {\n      var length = value ? getLength(value) : 0;\n      if (!isLength(length)) {\n        return values(value);\n      }\n      if (!length) {\n        return [];\n      }\n      return arrayCopy(value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable\n     * properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return baseCopy(value, keysIn(value));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object. Subsequent sources overwrite property assignments of previous sources.\n     * If `customizer` is provided it is invoked to produce the assigned values.\n     * The `customizer` is bound to `thisArg` and invoked with five arguments:\n     * (objectValue, sourceValue, key, object, source).\n     *\n     * **Note:** This method mutates `object` and is based on\n     * [`Object.assign`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign).\n     *\n     *\n     * @static\n     * @memberOf _\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });\n     * // => { 'user': 'fred', 'age': 40 }\n     *\n     * // using a customizer callback\n     * var defaults = _.partialRight(_.assign, function(value, other) {\n     *   return _.isUndefined(value) ? other : value;\n     * });\n     *\n     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n     * // => { 'user': 'barney', 'age': 36 }\n     */\n    var assign = createAssigner(function(object, source, customizer) {\n      return customizer\n        ? assignWith(object, source, customizer)\n        : baseAssign(object, source);\n    });\n\n    /**\n     * Creates an object that inherits from the given `prototype` object. If a\n     * `properties` object is provided its own enumerable properties are assigned\n     * to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties, guard) {\n      var result = baseCreate(prototype);\n      if (guard && isIterateeCall(prototype, properties, guard)) {\n        properties = null;\n      }\n      return properties ? baseAssign(result, properties) : result;\n    }\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object for all destination properties that resolve to `undefined`. Once a\n     * property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n     * // => { 'user': 'barney', 'age': 36 }\n     */\n    var defaults = restParam(function(args) {\n      var object = args[0];\n      if (object == null) {\n        return object;\n      }\n      args.push(assignDefaults);\n      return assign.apply(undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // using the `_.matches` callback shorthand\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.findKey(users, 'active', false);\n     * // => 'fred'\n     *\n     * // using the `_.property` callback shorthand\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    var findKey = createFindKey(baseForOwn);\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => returns `pebbles` assuming `_.findKey` returns `barney`\n     *\n     * // using the `_.matches` callback shorthand\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.findLastKey(users, 'active', false);\n     * // => 'fred'\n     *\n     * // using the `_.property` callback shorthand\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    var findLastKey = createFindKey(baseForOwnRight);\n\n    /**\n     * Iterates over own and inherited enumerable properties of an object invoking\n     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)\n     */\n    var forIn = createForIn(baseFor);\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'\n     */\n    var forInRight = createForIn(baseForRight);\n\n    /**\n     * Iterates over own enumerable properties of an object invoking `iteratee`\n     * for each property. The `iteratee` is bound to `thisArg` and invoked with\n     * three arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'a' and 'b' (iteration order is not guaranteed)\n     */\n    var forOwn = createForOwn(baseForOwn);\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'\n     */\n    var forOwnRight = createForOwn(baseForOwnRight);\n\n    /**\n     * Creates an array of function property names from all enumerable properties,\n     * own and inherited, of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @alias methods\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the new array of property names.\n     * @example\n     *\n     * _.functions(_);\n     * // => ['after', 'ary', 'assign', ...]\n     */\n    function functions(object) {\n      return baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the property value of `path` on `object`. If the resolved value is\n     * `undefined` the `defaultValue` is used in its place.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': { 'c': 3 } } };\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b.c');\n     * // => true\n     *\n     * _.has(object, ['a', 'b', 'c']);\n     * // => true\n     */\n    function has(object, path) {\n      if (object == null) {\n        return false;\n      }\n      var result = hasOwnProperty.call(object, path);\n      if (!result && !isKey(path)) {\n        path = toPath(path);\n        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n        path = last(path);\n        result = object != null && hasOwnProperty.call(object, path);\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite property\n     * assignments of previous values unless `multiValue` is `true`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {boolean} [multiValue] Allow multiple values per key.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     *\n     * // with `multiValue`\n     * _.invert(object, true);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function invert(object, multiValue, guard) {\n      if (guard && isIterateeCall(object, multiValue, guard)) {\n        multiValue = null;\n      }\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = {};\n\n      while (++index < length) {\n        var key = props[index],\n            value = object[key];\n\n        if (multiValue) {\n          if (hasOwnProperty.call(result, value)) {\n            result[value].push(key);\n          } else {\n            result[value] = [key];\n          }\n        }\n        else {\n          result[value] = key;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    var keys = !nativeKeys ? shimKeys : function(object) {\n      if (object) {\n        var Ctor = object.constructor,\n            length = object.length;\n      }\n      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n          (typeof object != 'function' && isLength(length))) {\n        return shimKeys(object);\n      }\n      return isObject(object) ? nativeKeys(object) : [];\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      if (object == null) {\n        return [];\n      }\n      if (!isObject(object)) {\n        object = Object(object);\n      }\n      var length = object.length;\n      length = (length && isLength(length) &&\n        (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;\n\n      var Ctor = object.constructor,\n          index = -1,\n          isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n          result = Array(length),\n          skipIndexes = length > 0;\n\n      while (++index < length) {\n        result[index] = (index + '');\n      }\n      for (var key in object) {\n        if (!(skipIndexes && isIndex(key, length)) &&\n            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated by\n     * running each own enumerable property of `object` through `iteratee`. The\n     * iteratee function is bound to `thisArg` and invoked with three arguments:\n     * (value, key, object).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the new mapped object.\n     * @example\n     *\n     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {\n     *   return n * 3;\n     * });\n     * // => { 'a': 3, 'b': 6 }\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // using the `_.property` callback shorthand\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee, thisArg) {\n      var result = {};\n      iteratee = getCallback(iteratee, thisArg, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        result[key] = iteratee(value, key, object);\n      });\n      return result;\n    }\n\n    /**\n     * Recursively merges own enumerable properties of the source object(s), that\n     * don't resolve to `undefined` into the destination object. Subsequent sources\n     * overwrite property assignments of previous sources. If `customizer` is\n     * provided it is invoked to produce the merged values of the destination and\n     * source properties. If `customizer` returns `undefined` merging is handled\n     * by the method instead. The `customizer` is bound to `thisArg` and invoked\n     * with five arguments: (objectValue, sourceValue, key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var users = {\n     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\n     * };\n     *\n     * var ages = {\n     *   'data': [{ 'age': 36 }, { 'age': 40 }]\n     * };\n     *\n     * _.merge(users, ages);\n     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\n     *\n     * // using a customizer callback\n     * var object = {\n     *   'fruits': ['apple'],\n     *   'vegetables': ['beet']\n     * };\n     *\n     * var other = {\n     *   'fruits': ['banana'],\n     *   'vegetables': ['carrot']\n     * };\n     *\n     * _.merge(object, other, function(a, b) {\n     *   if (_.isArray(a)) {\n     *     return a.concat(b);\n     *   }\n     * });\n     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\n     */\n    var merge = createAssigner(baseMerge);\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable properties of `object` that are not omitted.\n     * Property names may be specified as individual arguments or as arrays of\n     * property names. If `predicate` is provided it is invoked for each property\n     * of `object` omitting the properties `predicate` returns truthy for. The\n     * predicate is bound to `thisArg` and invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function|...(string|string[])} [predicate] The function invoked per\n     *  iteration or property names to omit, specified as individual property\n     *  names or arrays of property names.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'user': 'fred', 'age': 40 };\n     *\n     * _.omit(object, 'age');\n     * // => { 'user': 'fred' }\n     *\n     * _.omit(object, _.isNumber);\n     * // => { 'user': 'fred' }\n     */\n    var omit = restParam(function(object, props) {\n      if (object == null) {\n        return {};\n      }\n      if (typeof props[0] != 'function') {\n        var props = arrayMap(baseFlatten(props), String);\n        return pickByArray(object, baseDifference(keysIn(object), props));\n      }\n      var predicate = bindCallback(props[0], props[1], 3);\n      return pickByCallback(object, function(value, key, object) {\n        return !predicate(value, key, object);\n      });\n    });\n\n    /**\n     * Creates a two dimensional array of the key-value pairs for `object`,\n     * e.g. `[[key1, value1], [key2, value2]]`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the new array of key-value pairs.\n     * @example\n     *\n     * _.pairs({ 'barney': 36, 'fred': 40 });\n     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)\n     */\n    function pairs(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        var key = props[index];\n        result[index] = [key, object[key]];\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties. Property\n     * names may be specified as individual arguments or as arrays of property\n     * names. If `predicate` is provided it is invoked for each property of `object`\n     * picking the properties `predicate` returns truthy for. The predicate is\n     * bound to `thisArg` and invoked with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function|...(string|string[])} [predicate] The function invoked per\n     *  iteration or property names to pick, specified as individual property\n     *  names or arrays of property names.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'user': 'fred', 'age': 40 };\n     *\n     * _.pick(object, 'user');\n     * // => { 'user': 'fred' }\n     *\n     * _.pick(object, _.isString);\n     * // => { 'user': 'fred' }\n     */\n    var pick = restParam(function(object, props) {\n      if (object == null) {\n        return {};\n      }\n      return typeof props[0] == 'function'\n        ? pickByCallback(object, bindCallback(props[0], props[1], 3))\n        : pickByArray(object, baseFlatten(props));\n    });\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a function\n     * it is invoked with the `this` binding of its parent object and its result\n     * is returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a.b.c', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a.b.c', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      var result = object == null ? undefined : object[path];\n      if (result === undefined) {\n        if (object != null && !isKey(path, object)) {\n          path = toPath(path);\n          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n          result = object == null ? undefined : object[last(path)];\n        }\n        result = result === undefined ? defaultValue : result;\n      }\n      return isFunction(result) ? result.call(object) : result;\n    }\n\n    /**\n     * Sets the property value of `path` on `object`. If a portion of `path`\n     * does not exist it is created.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to augment.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, 'x[0].y.z', 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      if (object == null) {\n        return object;\n      }\n      var pathKey = (path + '');\n      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);\n\n      var index = -1,\n          length = path.length,\n          endIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = path[index];\n        if (isObject(nested)) {\n          if (index == endIndex) {\n            nested[key] = value;\n          } else if (nested[key] == null) {\n            nested[key] = isIndex(path[index + 1]) ? [] : {};\n          }\n        }\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own enumerable\n     * properties through `iteratee`, with each invocation potentially mutating\n     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked\n     * with four arguments: (accumulator, value, key, object). Iteratee functions\n     * may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Array|Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * });\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {\n     *   result[key] = n * 3;\n     * });\n     * // => { 'a': 3, 'b': 6 }\n     */\n    function transform(object, iteratee, accumulator, thisArg) {\n      var isArr = isArray(object) || isTypedArray(object);\n      iteratee = getCallback(iteratee, thisArg, 4);\n\n      if (accumulator == null) {\n        if (isArr || isObject(object)) {\n          var Ctor = object.constructor;\n          if (isArr) {\n            accumulator = isArray(object) ? new Ctor : [];\n          } else {\n            accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);\n          }\n        } else {\n          accumulator = {};\n        }\n      }\n      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Creates an array of the own enumerable property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property values\n     * of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Checks if `n` is between `start` and up to but not including, `end`. If\n     * `end` is not specified it is set to `start` with `start` then set to `0`.\n     *\n     * @static\n     * @memberOf _\n     * @category Number\n     * @param {number} n The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     */\n    function inRange(value, start, end) {\n      start = +start || 0;\n      if (typeof end === 'undefined') {\n        end = start;\n        start = 0;\n      } else {\n        end = +end || 0;\n      }\n      return value >= nativeMin(start, end) && value < nativeMax(start, end);\n    }\n\n    /**\n     * Produces a random number between `min` and `max` (inclusive). If only one\n     * argument is provided a number between `0` and the given number is returned.\n     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point\n     * number is returned instead of an integer.\n     *\n     * @static\n     * @memberOf _\n     * @category Number\n     * @param {number} [min=0] The minimum possible value.\n     * @param {number} [max=1] The maximum possible value.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(min, max, floating) {\n      if (floating && isIterateeCall(min, max, floating)) {\n        max = floating = null;\n      }\n      var noMin = min == null,\n          noMax = max == null;\n\n      if (floating == null) {\n        if (noMax && typeof min == 'boolean') {\n          floating = min;\n          min = 1;\n        }\n        else if (typeof max == 'boolean') {\n          floating = max;\n          noMax = true;\n        }\n      }\n      if (noMin && noMax) {\n        max = 1;\n        noMax = false;\n      }\n      min = +min || 0;\n      if (noMax) {\n        max = min;\n        min = 0;\n      } else {\n        max = +max || 0;\n      }\n      if (floating || min % 1 || max % 1) {\n        var rand = nativeRandom();\n        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);\n      }\n      return baseRandom(min, max);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__foo_bar__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);\n    });\n\n    /**\n     * Capitalizes the first character of `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('fred');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      string = baseToString(string);\n      return string && (string.charAt(0).toUpperCase() + string.slice(1));\n    }\n\n    /**\n     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('déjà vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = baseToString(string);\n      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to search.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search from.\n     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = baseToString(string);\n      target = (target + '');\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : nativeMin(position < 0 ? 0 : (+position || 0), length);\n\n      position -= target.length;\n      return position >= 0 && string.indexOf(target, position) == position;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and \"\\`\", in `string` to\n     * their corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional characters\n     * use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't require escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value.\n     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * Backticks are escaped because in Internet Explorer < 9, they can break out\n     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),\n     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and\n     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)\n     * for more details.\n     *\n     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)\n     * to reduce XSS vectors.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      // Reset `lastIndex` because in IE < 9 `String#replace` does not.\n      string = baseToString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"\\\", \"/\", \"^\", \"$\", \".\", \"|\", \"?\",\n     * \"*\", \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https:\\/\\/lodash\\.com\\/\\)'\n     */\n    function escapeRegExp(string) {\n      string = baseToString(string);\n      return (string && reHasRegExpChars.test(string))\n        ? string.replace(reRegExpChars, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__foo_bar__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Pads `string` on the left and right sides if it is shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = baseToString(string);\n      length = +length;\n\n      var strLength = string.length;\n      if (strLength >= length || !nativeIsFinite(length)) {\n        return string;\n      }\n      var mid = (length - strLength) / 2,\n          leftLength = floor(mid),\n          rightLength = ceil(mid);\n\n      chars = createPadding('', rightLength, chars);\n      return chars.slice(0, leftLength) + string + chars;\n    }\n\n    /**\n     * Pads `string` on the left side if it is shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padLeft('abc', 6);\n     * // => '   abc'\n     *\n     * _.padLeft('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padLeft('abc', 3);\n     * // => 'abc'\n     */\n    var padLeft = createPadDir();\n\n    /**\n     * Pads `string` on the right side if it is shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padRight('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padRight('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padRight('abc', 3);\n     * // => 'abc'\n     */\n    var padRight = createPadDir(true);\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,\n     * in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)\n     * of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard && isIterateeCall(string, radix, guard)) {\n        radix = 0;\n      }\n      return nativeParseInt(string, radix);\n    }\n    // Fallback for environments with pre-ES5 implementations.\n    if (nativeParseInt(whitespace + '08') != 8) {\n      parseInt = function(string, radix, guard) {\n        // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.\n        // Chrome fails to trim leading <BOM> whitespace characters.\n        // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.\n        if (guard ? isIterateeCall(string, radix, guard) : radix == null) {\n          radix = 0;\n        } else if (radix) {\n          radix = +radix;\n        }\n        string = trim(string);\n        return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));\n      };\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=0] The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n) {\n      var result = '';\n      string = baseToString(string);\n      n = +n;\n      if (n < 1 || !string || !nativeIsFinite(n)) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = floor(n / 2);\n        string += string;\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--foo-bar');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__foo_bar__');\n     * // => 'Foo Bar'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to search.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = baseToString(string);\n      position = position == null\n        ? 0\n        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);\n\n      return string.lastIndexOf(target, position) == position;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is provided it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options] The options object.\n     * @param {RegExp} [options.escape] The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\n     * @param {Object} [options.imports] An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.\n     * @param {string} [options.variable] The data object variable name.\n     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // using the \"interpolate\" delimiter to create a compiled template\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // using the HTML \"escape\" delimiter to escape data property values\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // using the \"evaluate\" delimiter to execute JavaScript and generate HTML\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the internal `print` function in \"evaluate\" delimiters\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // using the ES delimiter as an alternative to the default \"interpolate\" delimiter\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // using custom template delimiters\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // using backslashes to treat delimiters as plain text\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // using the `imports` option to import `jQuery` as `jq`\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the `sourceURL` option to specify a custom sourceURL for the template\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n     *\n     * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // using the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and a stack trace\n     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, otherOptions) {\n      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (otherOptions && isIterateeCall(string, options, otherOptions)) {\n        options = otherOptions = null;\n      }\n      string = baseToString(string);\n      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);\n\n      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      var sourceURL = '//# sourceURL=' +\n        ('sourceURL' in options\n          ? options.sourceURL\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products requires returning the `match`\n        // string in order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      var value = string;\n      string = baseToString(string);\n      if (!string) {\n        return string;\n      }\n      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);\n      }\n      chars = (chars + '');\n      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimLeft('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimLeft('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimLeft(string, chars, guard) {\n      var value = string;\n      string = baseToString(string);\n      if (!string) {\n        return string;\n      }\n      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n        return string.slice(trimmedLeftIndex(string));\n      }\n      return string.slice(charsLeftIndex(string, (chars + '')));\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimRight('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimRight('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimRight(string, chars, guard) {\n      var value = string;\n      string = baseToString(string);\n      if (!string) {\n        return string;\n      }\n      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n        return string.slice(0, trimmedRightIndex(string) + 1);\n      }\n      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);\n    }\n\n    /**\n     * Truncates `string` if it is longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object|number} [options] The options object or maximum string length.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.trunc('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.trunc('hi-diddly-ho there, neighborino', 24);\n     * // => 'hi-diddly-ho there, n...'\n     *\n     * _.trunc('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.trunc('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.trunc('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function trunc(string, options, guard) {\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = null;\n      }\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (options != null) {\n        if (isObject(options)) {\n          var separator = 'separator' in options ? options.separator : separator;\n          length = 'length' in options ? (+options.length || 0) : length;\n          omission = 'omission' in options ? baseToString(options.omission) : omission;\n        } else {\n          length = +options || 0;\n        }\n      }\n      string = baseToString(string);\n      if (length >= string.length) {\n        return string;\n      }\n      var end = length - omission.length;\n      if (end < 1) {\n        return omission;\n      }\n      var result = string.slice(0, end);\n      if (separator == null) {\n        return result + omission;\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              newEnd,\n              substring = string.slice(0, end);\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            newEnd = match.index;\n          }\n          result = result.slice(0, newEnd == null ? end : newEnd);\n        }\n      } else if (string.indexOf(separator, end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their\n     * corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional HTML\n     * entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = baseToString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      if (guard && isIterateeCall(string, pattern, guard)) {\n        pattern = null;\n      }\n      string = baseToString(string);\n      return string.match(pattern || reWords) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Function} func The function to attempt.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // avoid throwing errors for invalid selectors\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = restParam(function(func, args) {\n      try {\n        return func.apply(undefined, args);\n      } catch(e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and arguments of the created function. If `func` is a property name the\n     * created callback returns the property value for a given element. If `func`\n     * is an object the created callback returns `true` for elements that contain\n     * the equivalent object properties, otherwise it returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias iteratee\n     * @category Utility\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // wrap to create custom callback shorthands\n     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {\n     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);\n     *   if (!match) {\n     *     return callback(func, thisArg);\n     *   }\n     *   return function(object) {\n     *     return match[2] == 'gt'\n     *       ? object[match[1]] > match[3]\n     *       : object[match[1]] < match[3];\n     *   };\n     * });\n     *\n     * _.filter(users, 'age__gt36');\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     */\n    function callback(func, thisArg, guard) {\n      if (guard && isIterateeCall(func, thisArg, guard)) {\n        thisArg = null;\n      }\n      return baseCallback(func, thisArg);\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     * var getter = _.constant(object);\n     *\n     * getter() === object;\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * This method returns the first argument provided to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * _.identity(object) === object;\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function which performs a deep comparison between a given object\n     * and `source`, returning `true` if the given object has equivalent property\n     * values, else `false`.\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties. For comparing a single\n     * own or inherited property value see `_.matchesProperty`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, _.matches({ 'age': 40, 'active': false }));\n     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, true));\n    }\n\n    /**\n     * Creates a function which compares the property value of `path` on a given\n     * object to `value`.\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} value The value to compare.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * _.find(users, _.matchesProperty('user', 'fred'));\n     * // => { 'user': 'fred' }\n     */\n    function matchesProperty(path, value) {\n      return baseMatchesProperty(path, baseClone(value, true));\n    }\n\n    /**\n     * Creates a function which invokes the method at `path` on a given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Array|string} path The path of the method to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': { 'c': _.constant(2) } } },\n     *   { 'a': { 'b': { 'c': _.constant(1) } } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b.c'));\n     * // => [2, 1]\n     *\n     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');\n     * // => [1, 2]\n     */\n    var method = restParam(function(path, args) {\n      return function(object) {\n        return invokePath(object, path, args);\n      }\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function which invokes\n     * the method at a given path on `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = restParam(function(object, args) {\n      return function(path) {\n        return invokePath(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable function properties of a source object to the\n     * destination object. If `object` is a function then methods are added to\n     * its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.chain=true] Specify whether the functions added\n     *  are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * // use `_.runInContext` to avoid conflicts (esp. in Node.js)\n     * var _ = require('lodash').runInContext();\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      if (options == null) {\n        var isObj = isObject(source),\n            props = isObj && keys(source),\n            methodNames = props && props.length && baseFunctions(source, props);\n\n        if (!(methodNames ? methodNames.length : isObj)) {\n          methodNames = false;\n          options = source;\n          source = object;\n          object = this;\n        }\n      }\n      if (!methodNames) {\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = true,\n          index = -1,\n          isFunc = isFunction(object),\n          length = methodNames.length;\n\n      if (options === false) {\n        chain = false;\n      } else if (isObject(options) && 'chain' in options) {\n        chain = options.chain;\n      }\n      while (++index < length) {\n        var methodName = methodNames[index],\n            func = source[methodName];\n\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = (function(func) {\n            return function() {\n              var chainAll = this.__chain__;\n              if (chain || chainAll) {\n                var result = object(this.__wrapped__),\n                    actions = result.__actions__ = arrayCopy(this.__actions__);\n\n                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n                result.__chain__ = chainAll;\n                return result;\n              }\n              var args = [this.value()];\n              push.apply(args, arguments);\n              return func.apply(object, args);\n            };\n          }(func));\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      context._ = oldDash;\n      return this;\n    }\n\n    /**\n     * A no-operation function which returns `undefined` regardless of the\n     * arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * _.noop(object) === undefined;\n     * // => true\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function which returns the property value at `path` on a\n     * given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': { 'c': 2 } } },\n     *   { 'a': { 'b': { 'c': 1 } } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b.c'));\n     * // => [2, 1]\n     *\n     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function which returns\n     * the property value at a given path on `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return baseGet(object, toPath(path), path + '');\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. If `end` is not specified it is\n     * set to `start` with `start` then set to `0`. If `end` is less than `start`\n     * a zero-length range is created unless a negative `step` is specified.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the new array of numbers.\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    function range(start, end, step) {\n      if (step && isIterateeCall(start, end, step)) {\n        end = step = null;\n      }\n      start = +start || 0;\n      step = step == null ? 1 : (+step || 0);\n\n      if (end == null) {\n        end = start;\n        start = 0;\n      } else {\n        end = +end || 0;\n      }\n      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.\n      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.\n      var index = -1,\n          length = nativeMax(ceil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * Invokes the iteratee function `n` times, returning an array of the results\n     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with\n     * one argument; (index).\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));\n     * // => [3, 6, 4]\n     *\n     * _.times(3, function(n) {\n     *   mage.castSpell(n);\n     * });\n     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`\n     *\n     * _.times(3, function(n) {\n     *   this.cast(n);\n     * }, mage);\n     * // => also invokes `mage.castSpell(n)` three times\n     */\n    function times(n, iteratee, thisArg) {\n      n = floor(n);\n\n      // Exit early to avoid a JSC JIT bug in Safari 8\n      // where `Array(0)` is treated as `Array(1)`.\n      if (n < 1 || !nativeIsFinite(n)) {\n        return [];\n      }\n      var index = -1,\n          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));\n\n      iteratee = bindCallback(iteratee, thisArg, 1);\n      while (++index < n) {\n        if (index < MAX_ARRAY_LENGTH) {\n          result[index] = iteratee(index);\n        } else {\n          iteratee(index);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is provided the ID is appended to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {string} [prefix] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return baseToString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {number} augend The first number to add.\n     * @param {number} addend The second number to add.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    function add(augend, addend) {\n      return (+augend || 0) + (+addend || 0);\n    }\n\n    /**\n     * Gets the maximum value of `collection`. If `collection` is empty or falsey\n     * `-Infinity` is returned. If an iteratee function is provided it is invoked\n     * for each value in `collection` to generate the criterion by which the value\n     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three\n     * arguments: (value, index, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => -Infinity\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.max(users, function(chr) {\n     *   return chr.age;\n     * });\n     * // => { 'user': 'fred', 'age': 40 }\n     *\n     * // using the `_.property` callback shorthand\n     * _.max(users, 'age');\n     * // => { 'user': 'fred', 'age': 40 }\n     */\n    var max = createExtremum(arrayMax);\n\n    /**\n     * Gets the minimum value of `collection`. If `collection` is empty or falsey\n     * `Infinity` is returned. If an iteratee function is provided it is invoked\n     * for each value in `collection` to generate the criterion by which the value\n     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three\n     * arguments: (value, index, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => Infinity\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.min(users, function(chr) {\n     *   return chr.age;\n     * });\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // using the `_.property` callback shorthand\n     * _.min(users, 'age');\n     * // => { 'user': 'barney', 'age': 36 }\n     */\n    var min = createExtremum(arrayMin, true);\n\n    /**\n     * Gets the sum of the values in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 6]);\n     * // => 10\n     *\n     * _.sum({ 'a': 4, 'b': 6 });\n     * // => 10\n     *\n     * var objects = [\n     *   { 'n': 4 },\n     *   { 'n': 6 }\n     * ];\n     *\n     * _.sum(objects, function(object) {\n     *   return object.n;\n     * });\n     * // => 10\n     *\n     * // using the `_.property` callback shorthand\n     * _.sum(objects, 'n');\n     * // => 10\n     */\n    function sum(collection, iteratee, thisArg) {\n      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n        iteratee = null;\n      }\n      var func = getCallback(),\n          noIteratee = iteratee == null;\n\n      if (!(func === baseCallback && noIteratee)) {\n        noIteratee = false;\n        iteratee = func(iteratee, thisArg, 3);\n      }\n      return noIteratee\n        ? arraySum(isArray(collection) ? collection : toIterable(collection))\n        : baseSum(collection, iteratee);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    // Add functions to the `Map` cache.\n    MapCache.prototype['delete'] = mapDelete;\n    MapCache.prototype.get = mapGet;\n    MapCache.prototype.has = mapHas;\n    MapCache.prototype.set = mapSet;\n\n    // Add functions to the `Set` cache.\n    SetCache.prototype.push = cachePush;\n\n    // Assign cache to `_.memoize`.\n    memoize.Cache = MapCache;\n\n    // Add functions that return wrapped values when chaining.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.callback = callback;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.functions = functions;\n    lodash.groupBy = groupBy;\n    lodash.indexBy = indexBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.invert = invert;\n    lodash.invoke = invoke;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.omit = omit;\n    lodash.once = once;\n    lodash.pairs = pairs;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pluck = pluck;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.restParam = restParam;\n    lodash.set = set;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortByAll = sortByAll;\n    lodash.sortByOrder = sortByOrder;\n    lodash.spread = spread;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.times = times;\n    lodash.toArray = toArray;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.union = union;\n    lodash.uniq = uniq;\n    lodash.unzip = unzip;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.where = where;\n    lodash.without = without;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n\n    // Add aliases.\n    lodash.backflow = flowRight;\n    lodash.collect = map;\n    lodash.compose = flowRight;\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.extend = assign;\n    lodash.iteratee = callback;\n    lodash.methods = functions;\n    lodash.object = zipObject;\n    lodash.select = filter;\n    lodash.tail = rest;\n    lodash.unique = uniq;\n\n    // Add functions to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add functions that return unwrapped values when chaining.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.deburr = deburr;\n    lodash.endsWith = endsWith;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.findWhere = findWhere;\n    lodash.first = first;\n    lodash.get = get;\n    lodash.has = has;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isBoolean = isBoolean;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isMatch = isMatch;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isString = isString;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.max = max;\n    lodash.min = min;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padLeft = padLeft;\n    lodash.padRight = padRight;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.result = result;\n    lodash.runInContext = runInContext;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.sum = sum;\n    lodash.template = template;\n    lodash.trim = trim;\n    lodash.trimLeft = trimLeft;\n    lodash.trimRight = trimRight;\n    lodash.trunc = trunc;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.words = words;\n\n    // Add aliases.\n    lodash.all = every;\n    lodash.any = some;\n    lodash.contains = includes;\n    lodash.detect = find;\n    lodash.foldl = reduce;\n    lodash.foldr = reduceRight;\n    lodash.head = first;\n    lodash.include = includes;\n    lodash.inject = reduce;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!lodash.prototype[methodName]) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), false);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add functions capable of returning wrapped and unwrapped values when chaining.\n    lodash.sample = sample;\n\n    lodash.prototype.sample = function(n) {\n      if (!this.__chain__ && n == null) {\n        return sample(this.value());\n      }\n      return this.thru(function(value) {\n        return sample(value, n);\n      });\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type string\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['dropWhile', 'filter', 'map', 'takeWhile'], function(methodName, type) {\n      var isFilter = type != LAZY_MAP_FLAG,\n          isDropWhile = type == LAZY_DROP_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {\n        var filtered = this.__filtered__,\n            result = (filtered && isDropWhile) ? new LazyWrapper(this) : this.clone(),\n            iteratees = result.__iteratees__ || (result.__iteratees__ = []);\n\n        iteratees.push({\n          'done': false,\n          'count': 0,\n          'index': 0,\n          'iteratee': getCallback(iteratee, thisArg, 1),\n          'limit': -1,\n          'type': type\n        });\n\n        result.__filtered__ = filtered || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      var whileName = methodName + 'While';\n\n      LazyWrapper.prototype[methodName] = function(n) {\n        var filtered = this.__filtered__,\n            result = (filtered && !index) ? this.dropWhile() : this.clone();\n\n        n = n == null ? 1 : nativeMax(floor(n) || 0, 0);\n        if (filtered) {\n          if (index) {\n            result.__takeCount__ = nativeMin(result.__takeCount__, n);\n          } else {\n            last(result.__iteratees__).limit = n;\n          }\n        } else {\n          var views = result.__views__ || (result.__views__ = []);\n          views.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n\n      LazyWrapper.prototype[methodName + 'RightWhile'] = function(predicate, thisArg) {\n        return this.reverse()[whileName](predicate, thisArg).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.first` and `_.last`.\n    arrayEach(['first', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.\n    arrayEach(['initial', 'rest'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[dropName](1);\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.\n    arrayEach(['pluck', 'where'], function(methodName, index) {\n      var operationName = index ? 'filter' : 'map',\n          createCallback = index ? baseMatches : property;\n\n      LazyWrapper.prototype[methodName] = function(value) {\n        return this[operationName](createCallback(value));\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.reject = function(predicate, thisArg) {\n      predicate = getCallback(predicate, thisArg, 1);\n      return this.filter(function(value) {\n        return !predicate(value);\n      });\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = start == null ? 0 : (+start || 0);\n      var result = start < 0 ? this.takeRight(-start) : this.drop(start);\n\n      if (end !== undefined) {\n        end = (+end || 0);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.drop(0);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (!lodashFunc) {\n        return;\n      }\n      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),\n          retUnwrapped = /^(?:first|last)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments,\n            length = args.length,\n            chainAll = this.__chain__,\n            value = this.__wrapped__,\n            isHybrid = !!this.__actions__.length,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // avoid lazy use if the iteratee has a \"length\" value other than `1`\n          isLazy = useLazy = false;\n        }\n        var onlyLazy = isLazy && !isHybrid;\n        if (retUnwrapped && !chainAll) {\n          return onlyLazy\n            ? func.call(value)\n            : lodashFunc.call(lodash, this.value());\n        }\n        var interceptor = function(value) {\n          var otherArgs = [value];\n          push.apply(otherArgs, args);\n          return lodashFunc.apply(lodash, otherArgs);\n        };\n        if (useLazy) {\n          var wrapper = onlyLazy ? value : new LazyWrapper(this),\n              result = func.apply(wrapper, args);\n\n          if (!retUnwrapped && (isHybrid || result.__actions__)) {\n            var actions = result.__actions__ || (result.__actions__ = []);\n            actions.push({ 'func': thru, 'args': [interceptor], 'thisArg': lodash });\n          }\n          return new LodashWrapper(result, chainAll);\n        }\n        return this.thru(interceptor);\n      };\n    });\n\n    // Add `Array` and `String` methods to `lodash.prototype`.\n    arrayEach(['concat', 'join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {\n      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          return func.apply(this.value(), args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(value, args);\n        });\n      };\n    });\n\n    // Map minified function names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = lodashFunc.name,\n            names = realNames[key] || (realNames[key] = []);\n\n        names.push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybridWrapper(null, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': null }];\n\n    // Add functions to the lazy wrapper.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chaining functions to the `lodash` wrapper.\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toString = wrapperToString;\n    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add function aliases to the `lodash` wrapper.\n    lodash.prototype.collect = lodash.prototype.map;\n    lodash.prototype.head = lodash.prototype.first;\n    lodash.prototype.select = lodash.prototype.filter;\n    lodash.prototype.tail = lodash.prototype.rest;\n\n    return lodash;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers like r.js check for condition patterns like the following:\n  if (true) {\n    // Expose lodash to the global object when an AMD loader is present to avoid\n    // errors in cases where lodash is loaded by a script tag and not intended\n    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for\n    // more details.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n      return _;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.\n  else if (freeExports && freeModule) {\n    // Export for Node.js or RingoJS.\n    if (moduleExports) {\n      (freeModule.exports = _)._ = _;\n    }\n    // Export for Narwhal or Rhino -require.\n    else {\n      freeExports._ = _;\n    }\n  }\n  else {\n    // Export for a browser or Rhino.\n    root._ = _;\n  }\n}.call(this));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)(module), (function() { return this; }())))\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pbmRleC5qcz82NmU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJrQ0FBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsTUFBTSxhQUFhLE9BQU87O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2QsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsU0FBUztBQUNULFNBQVM7QUFDVCxXQUFXO0FBQ1gsVUFBVTtBQUNWLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxFQUFFO0FBQ2YsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxFQUFFO0FBQ2YsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsVUFBVTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLFlBQVksRUFBRTtBQUMzQyxvQkFBb0Isc0JBQXNCO0FBQzFDOztBQUVBLHdCQUF3QjtBQUN4QixpQ0FBaUMsaUJBQWlCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsYUFBYSxFQUFFOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLEVBQUU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGtCQUFrQjtBQUNqQyxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE9BQU8sV0FBVztBQUNqQyxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsRUFBRTtBQUNqQixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckIsaUJBQWlCLEVBQUU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2QkFBNkIsRUFBRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLEVBQUU7QUFDakIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsU0FBUztBQUN4QixlQUFlLEVBQUU7QUFDakIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSw2QkFBNkI7QUFDNUMsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBEQUEwRCwyQkFBMkIsRUFBRTs7QUFFdkY7QUFDQSwrREFBK0Qsd0JBQXdCLEVBQUU7QUFDekYsZ0JBQWdCO0FBQ2hCLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsRUFBRTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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eEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNCQUFzQixzRUFBc0U7QUFDNUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHlEQUF5RDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHlDQUF5QztBQUM3RDtBQUNBLEtBQUs7O0FBRUwsaUVBQWlFLGtDQUFrQzs7QUFFbkc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBsb2Rhc2ggMy43LjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gLWQgLW8gLi9pbmRleC5qc2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUtRVM1IGVudmlyb25tZW50cy4gKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCBhcyB0aGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuICovXG4gIHZhciBWRVJTSU9OID0gJzMuNy4wJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB3cmFwcGVyIG1ldGFkYXRhLiAqL1xuICB2YXIgQklORF9GTEFHID0gMSxcbiAgICAgIEJJTkRfS0VZX0ZMQUcgPSAyLFxuICAgICAgQ1VSUllfQk9VTkRfRkxBRyA9IDQsXG4gICAgICBDVVJSWV9GTEFHID0gOCxcbiAgICAgIENVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICAgIFBBUlRJQUxfRkxBRyA9IDMyLFxuICAgICAgUEFSVElBTF9SSUdIVF9GTEFHID0gNjQsXG4gICAgICBBUllfRkxBRyA9IDEyOCxcbiAgICAgIFJFQVJHX0ZMQUcgPSAyNTY7XG5cbiAgLyoqIFVzZWQgYXMgZGVmYXVsdCBvcHRpb25zIGZvciBgXy50cnVuY2AuICovXG4gIHZhciBERUZBVUxUX1RSVU5DX0xFTkdUSCA9IDMwLFxuICAgICAgREVGQVVMVF9UUlVOQ19PTUlTU0lPTiA9ICcuLi4nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCB3aGVuIGEgZnVuY3Rpb24gYmVjb21lcyBob3QuICovXG4gIHZhciBIT1RfQ09VTlQgPSAxNTAsXG4gICAgICBIT1RfU1BBTiA9IDE2O1xuXG4gIC8qKiBVc2VkIHRvIGluZGljYXRlIHRoZSB0eXBlIG9mIGxhenkgaXRlcmF0ZWVzLiAqL1xuICB2YXIgTEFaWV9EUk9QX1dISUxFX0ZMQUcgPSAwLFxuICAgICAgTEFaWV9GSUxURVJfRkxBRyA9IDEsXG4gICAgICBMQVpZX01BUF9GTEFHID0gMjtcblxuICAvKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xuICB2YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbiAgdmFyIFBMQUNFSE9MREVSID0gJ19fbG9kYXNoX3BsYWNlaG9sZGVyX18nO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG4gIHZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUVzY2FwZWRIdG1sID0gLyYoPzphbXB8bHR8Z3R8cXVvdHwjMzl8Izk2KTsvZyxcbiAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInYF0vZyxcbiAgICAgIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLFxuICAgICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dK3woW1wiJ10pKD86KD8hXFwxKVteXFxuXFxcXF18XFxcXC4pKj8pXFwxXFxdLyxcbiAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxuXFxcXF18XFxcXC4pKj8pXFwyKVxcXS9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIFtzcGVjaWFsIGNoYXJhY3RlcnNdKGh0dHA6Ly93d3cucmVndWxhci1leHByZXNzaW9ucy5pbmZvL2NoYXJhY3RlcnMuaHRtbCNzcGVjaWFsKS5cbiAgICogSW4gYWRkaXRpb24gdG8gc3BlY2lhbCBjaGFyYWN0ZXJzIHRoZSBmb3J3YXJkIHNsYXNoIGlzIGVzY2FwZWQgdG8gYWxsb3cgZm9yXG4gICAqIGVhc2llciBgZXZhbGAgdXNlIGFuZCBgRnVuY3Rpb25gIGNvbXBpbGF0aW9uLlxuICAgKi9cbiAgdmFyIHJlUmVnRXhwQ2hhcnMgPSAvWy4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2csXG4gICAgICByZUhhc1JlZ0V4cENoYXJzID0gUmVnRXhwKHJlUmVnRXhwQ2hhcnMuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLiAqL1xuICB2YXIgcmVDb21ib01hcmsgPSAvW1xcdTAzMDAtXFx1MDM2ZlxcdWZlMjAtXFx1ZmUyM10vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLiAqL1xuICB2YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUhhc0hleFByZWZpeCA9IC9eMFt4WF0vO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpID4gNSkuICovXG4gIHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG4gIHZhciByZUxhdGluMSA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZVxceGRmLVxceGY2XFx4ZjgtXFx4ZmZdL2c7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIHRvIGNyZWF0ZSBjb21wb3VuZCB3b3Jkcy4gKi9cbiAgdmFyIHJlV29yZHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHVwcGVyID0gJ1tBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGVdJyxcbiAgICAgICAgbG93ZXIgPSAnW2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZl0rJztcblxuICAgIHJldHVybiBSZWdFeHAodXBwZXIgKyAnKyg/PScgKyB1cHBlciArIGxvd2VyICsgJyl8JyArIHVwcGVyICsgJz8nICsgbG93ZXIgKyAnfCcgKyB1cHBlciArICcrfFswLTldKycsICdnJyk7XG4gIH0oKSk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGFuZCB0ZXN0IGZvciB3aGl0ZXNwYWNlLiAqL1xuICB2YXIgd2hpdGVzcGFjZSA9IChcbiAgICAvLyBCYXNpYyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAgJyBcXHRcXHgwYlxcZlxceGEwXFx1ZmVmZicgK1xuXG4gICAgLy8gTGluZSB0ZXJtaW5hdG9ycy5cbiAgICAnXFxuXFxyXFx1MjAyOFxcdTIwMjknICtcblxuICAgIC8vIFVuaWNvZGUgY2F0ZWdvcnkgXCJac1wiIHNwYWNlIHNlcGFyYXRvcnMuXG4gICAgJ1xcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDAnXG4gICk7XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgY29udGV4dFByb3BzID0gW1xuICAgICdBcnJheScsICdBcnJheUJ1ZmZlcicsICdEYXRlJywgJ0Vycm9yJywgJ0Zsb2F0MzJBcnJheScsICdGbG9hdDY0QXJyYXknLFxuICAgICdGdW5jdGlvbicsICdJbnQ4QXJyYXknLCAnSW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ01hdGgnLCAnTnVtYmVyJyxcbiAgICAnT2JqZWN0JywgJ1JlZ0V4cCcsICdTZXQnLCAnU3RyaW5nJywgJ18nLCAnY2xlYXJUaW1lb3V0JywgJ2RvY3VtZW50JyxcbiAgICAnaXNGaW5pdGUnLCAncGFyc2VJbnQnLCAnc2V0VGltZW91dCcsICdUeXBlRXJyb3InLCAnVWludDhBcnJheScsXG4gICAgJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ1VpbnQxNkFycmF5JywgJ1VpbnQzMkFycmF5JywgJ1dlYWtNYXAnLFxuICAgICd3aW5kb3cnXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeS4gKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IC0xO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbiAgdmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG4gIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID0gdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID0gdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xuICB2YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuICBjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2RhdGVUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDhUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbiAgY2xvbmVhYmxlVGFnc1ttYXBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIGFzIGFuIGludGVybmFsIGBfLmRlYm91bmNlYCBvcHRpb25zIG9iamVjdCBieSBgXy50aHJvdHRsZWAuICovXG4gIHZhciBkZWJvdW5jZU9wdGlvbnMgPSB7XG4gICAgJ2xlYWRpbmcnOiBmYWxzZSxcbiAgICAnbWF4V2FpdCc6IDAsXG4gICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnMgdG8gYmFzaWMgbGF0aW4gbGV0dGVycy4gKi9cbiAgdmFyIGRlYnVycmVkTGV0dGVycyA9IHtcbiAgICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAgICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgICAnXFx4Y0MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAgICdcXHhlQyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAgICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAgICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAgICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAgICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICAgJ1xceGRmJzogJ3NzJ1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG4gIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OycsXG4gICAgJ2AnOiAnJiM5NjsnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy4gKi9cbiAgdmFyIGh0bWxVbmVzY2FwZXMgPSB7XG4gICAgJyZhbXA7JzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmIzM5Oyc6IFwiJ1wiLFxuICAgICcmIzk2Oyc6ICdgJ1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIGBPYmplY3RgLiAqL1xuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZVxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmIHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgJiYgZ2xvYmFsO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG4gIHZhciBmcmVlU2VsZiA9IG9iamVjdFR5cGVzW3R5cGVvZiBzZWxmXSAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ICYmIHNlbGY7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGB3aW5kb3dgLiAqL1xuICB2YXIgZnJlZVdpbmRvdyA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyAmJiB3aW5kb3cuT2JqZWN0ICYmIHdpbmRvdztcblxuICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyAmJiBmcmVlRXhwb3J0cztcblxuICAvKipcbiAgICogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICpcbiAgICogVGhlIGB0aGlzYCB2YWx1ZSBpcyB1c2VkIGlmIGl0IGlzIHRoZSBnbG9iYWwgb2JqZWN0IHRvIGF2b2lkIEdyZWFzZW1vbmtleSdzXG4gICAqIHJlc3RyaWN0ZWQgYHdpbmRvd2Agb2JqZWN0LCBvdGhlcndpc2UgdGhlIGB3aW5kb3dgIG9iamVjdCBpcyB1c2VkLlxuICAgKi9cbiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8ICgoZnJlZVdpbmRvdyAhPT0gKHRoaXMgJiYgdGhpcy53aW5kb3cpKSAmJiBmcmVlV2luZG93KSB8fCBmcmVlU2VsZiB8fCB0aGlzO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgY29tcGFyZUFzY2VuZGluZ2Agd2hpY2ggY29tcGFyZXMgdmFsdWVzIGFuZFxuICAgKiBzb3J0cyB0aGVtIGluIGFzY2VuZGluZyBvcmRlciB3aXRob3V0IGd1YXJhbnRlZWluZyBhIHN0YWJsZSBzb3J0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlIHRvIGBvdGhlcmAuXG4gICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIHZhbHVlIHRvIGNvbXBhcmUgdG8gYHZhbHVlYC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlQ29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICB2YXIgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWUsXG4gICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXI7XG5cbiAgICAgIGlmICh2YWx1ZSA+IG90aGVyIHx8ICF2YWxJc1JlZmxleGl2ZSB8fCAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPCBvdGhlciB8fCAhb3RoSXNSZWZsZXhpdmUgfHwgKG90aGVyID09PSB1bmRlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICAgKiBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tUmlnaHQpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYmluYXJ5IHNlYXJjaGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgaWYgKHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4T2ZOYU4oYXJyYXksIGZyb21JbmRleCk7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0Z1bmN0aW9uYCB3aXRob3V0IHN1cHBvcnQgZm9yIGVudmlyb25tZW50c1xuICAgKiB3aXRoIGluY29ycmVjdCBgdHlwZW9mYCByZXN1bHRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gQXZvaWQgYSBDaGFrcmEgSklUIGJ1ZyBpbiBjb21wYXRpYmlsaXR5IG1vZGVzIG9mIElFIDExLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvaXNzdWVzLzE2MjEgZm9yIG1vcmUgZGV0YWlscy5cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBpZiBpdCBpcyBub3Qgb25lLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWRcbiAgICogZm9yIGBudWxsYCBvciBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6ICh2YWx1ZSArICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLm1heGAgYW5kIGBfLm1pbmAgYXMgdGhlIGRlZmF1bHQgY2FsbGJhY2sgZm9yIHN0cmluZyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2RlIHVuaXQgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhckF0Q2FsbGJhY2soc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQ29kZUF0KDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1MZWZ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICogb2YgYHN0cmluZ2AgdGhhdCBpcyBub3QgZm91bmQgaW4gYGNoYXJzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFycyBUaGUgY2hhcmFjdGVycyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNMZWZ0SW5kZXgoc3RyaW5nLCBjaGFycykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2hhcnMuaW5kZXhPZihzdHJpbmcuY2hhckF0KGluZGV4KSkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVJpZ2h0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNoYXJhY3RlclxuICAgKiBvZiBgc3RyaW5nYCB0aGF0IGlzIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJzIFRoZSBjaGFyYWN0ZXJzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNoYXJhY3RlciBub3QgZm91bmQgaW4gYGNoYXJzYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzUmlnaHRJbmRleChzdHJpbmcsIGNoYXJzKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIGNoYXJzLmluZGV4T2Yoc3RyaW5nLmNoYXJBdChpbmRleCkpID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uc29ydEJ5YCB0byBjb21wYXJlIHRyYW5zZm9ybWVkIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiBhbmQgc3RhYmxlXG4gICAqIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBvdGhlcmAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb2JqZWN0IHRvIGNvbXBhcmUgdG8gYG9iamVjdGAuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcob2JqZWN0LCBvdGhlcikge1xuICAgIHJldHVybiBiYXNlQ29tcGFyZUFzY2VuZGluZyhvYmplY3QuY3JpdGVyaWEsIG90aGVyLmNyaXRlcmlhKSB8fCAob2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uc29ydEJ5T3JkZXJgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBlYWNoIGVsZW1lbnRcbiAgICogaW4gYSBjb2xsZWN0aW9uIGFuZCBzdGFibGUgc29ydCB0aGVtIGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6XG4gICAqXG4gICAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBzb3J0IGluIGFzY2VuZGluZyBvcmRlciBmb3IgYWxsIHByb3BlcnRpZXMuXG4gICAqIE90aGVyd2lzZSwgZm9yIGVhY2ggcHJvcGVydHksIHNvcnQgaW4gYXNjZW5kaW5nIG9yZGVyIGlmIGl0cyBjb3JyZXNwb25kaW5nIHZhbHVlIGluXG4gICAqIG9yZGVycyBpcyB0cnVlLCBhbmQgZGVzY2VuZGluZyBvcmRlciBpZiBmYWxzZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUgdG8gYG90aGVyYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvYmplY3QgdG8gY29tcGFyZSB0byBgb2JqZWN0YC5cbiAgICogQHBhcmFtIHtib29sZWFuW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcbiAgICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXJzW2luZGV4XSA/IDEgOiAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxuICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnMgdG8gYmFzaWMgbGF0aW4gbGV0dGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBkZWJ1cnJMZXR0ZXIobGV0dGVyKSB7XG4gICAgcmV0dXJuIGRlYnVycmVkTGV0dGVyc1tsZXR0ZXJdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWxDaGFyKGNocikge1xuICAgIHJldHVybiBodG1sRXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWRcbiAgICogc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGBOYU5gIGlzIGZvdW5kIGluIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgYE5hTmAsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGluZGV4T2ZOYU4oYXJyYXksIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMCA6IC0xKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAob3RoZXIgIT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGB0cmltbWVkTGVmdEluZGV4YCBhbmQgYHRyaW1tZWRSaWdodEluZGV4YCB0byBkZXRlcm1pbmUgaWYgYVxuICAgKiBjaGFyYWN0ZXIgY29kZSBpcyB3aGl0ZXNwYWNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gY2hhckNvZGUgVGhlIGNoYXJhY3RlciBjb2RlIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgY2hhckNvZGVgIGlzIHdoaXRlc3BhY2UsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzU3BhY2UoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gKChjaGFyQ29kZSA8PSAxNjAgJiYgKGNoYXJDb2RlID49IDkgJiYgY2hhckNvZGUgPD0gMTMpIHx8IGNoYXJDb2RlID09IDMyIHx8IGNoYXJDb2RlID09IDE2MCkgfHwgY2hhckNvZGUgPT0gNTc2MCB8fCBjaGFyQ29kZSA9PSA2MTU4IHx8XG4gICAgICAoY2hhckNvZGUgPj0gODE5MiAmJiAoY2hhckNvZGUgPD0gODIwMiB8fCBjaGFyQ29kZSA9PSA4MjMyIHx8IGNoYXJDb2RlID09IDgyMzMgfHwgY2hhckNvZGUgPT0gODIzOSB8fCBjaGFyQ29kZSA9PSA4Mjg3IHx8IGNoYXJDb2RlID09IDEyMjg4IHx8IGNoYXJDb2RlID09IDY1Mjc5KSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBgcGxhY2Vob2xkZXJgIGVsZW1lbnRzIGluIGBhcnJheWAgd2l0aCBhbiBpbnRlcm5hbCBwbGFjZWhvbGRlclxuICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVpciBpbmRleGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gUExBQ0VIT0xERVI7XG4gICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFgIG9wdGltaXplZCBmb3Igc29ydGVkIGFycmF5cyB3aXRob3V0IHN1cHBvcnRcbiAgICogZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHNvcnRlZFVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIHNlZW4sXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgICBpZiAoIWluZGV4IHx8IHNlZW4gIT09IGNvbXB1dGVkKSB7XG4gICAgICAgIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUxlZnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG5vbi13aGl0ZXNwYWNlXG4gICAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiB0cmltbWVkTGVmdEluZGV4KHN0cmluZykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgaXNTcGFjZShzdHJpbmcuY2hhckNvZGVBdChpbmRleCkpKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltUmlnaHRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAgICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdHJpbW1lZFJpZ2h0SW5kZXgoc3RyaW5nKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIGlzU3BhY2Uoc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpKSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy51bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5lc2NhcGVIdG1sQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gaHRtbFVuZXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9cm9vdF0gVGhlIGNvbnRleHQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBuZXcgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubWl4aW4oeyAnZm9vJzogXy5jb25zdGFudCgnZm9vJykgfSk7XG4gICAqXG4gICAqIHZhciBsb2Rhc2ggPSBfLnJ1bkluQ29udGV4dCgpO1xuICAgKiBsb2Rhc2gubWl4aW4oeyAnYmFyJzogbG9kYXNoLmNvbnN0YW50KCdiYXInKSB9KTtcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8uZm9vKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKiBfLmlzRnVuY3Rpb24oXy5iYXIpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guZm9vKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmJhcik7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogLy8gdXNpbmcgYGNvbnRleHRgIHRvIG1vY2sgYERhdGUjZ2V0VGltZWAgdXNlIGluIGBfLm5vd2BcbiAgICogdmFyIG1vY2sgPSBfLnJ1bkluQ29udGV4dCh7XG4gICAqICAgJ0RhdGUnOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHJldHVybiB7ICdnZXRUaW1lJzogZ2V0VGltZU1vY2sgfTtcbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBvciBjcmVhdGluZyBhIHN1cGVkLXVwIGBkZWZlcmAgaW4gTm9kZS5qc1xuICAgKiB2YXIgZGVmZXIgPSBfLnJ1bkluQ29udGV4dCh7ICdzZXRUaW1lb3V0Jzogc2V0SW1tZWRpYXRlIH0pLmRlZmVyO1xuICAgKi9cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpIHtcbiAgICAvLyBBdm9pZCBpc3N1ZXMgd2l0aCBzb21lIEVTMyBlbnZpcm9ubWVudHMgdGhhdCBhdHRlbXB0IHRvIHVzZSB2YWx1ZXMsIG5hbWVkXG4gICAgLy8gYWZ0ZXIgYnVpbHQtaW4gY29uc3RydWN0b3JzIGxpa2UgYE9iamVjdGAsIGZvciB0aGUgY3JlYXRpb24gb2YgbGl0ZXJhbHMuXG4gICAgLy8gRVM1IGNsZWFycyB0aGlzIHVwIGJ5IHN0YXRpbmcgdGhhdCBsaXRlcmFscyBtdXN0IHVzZSBidWlsdC1pbiBjb25zdHJ1Y3RvcnMuXG4gICAgLy8gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDExLjEuNSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIGNvbnRleHQgPSBjb250ZXh0ID8gXy5kZWZhdWx0cyhyb290Lk9iamVjdCgpLCBjb250ZXh0LCBfLnBpY2socm9vdCwgY29udGV4dFByb3BzKSkgOiByb290O1xuXG4gICAgLyoqIE5hdGl2ZSBjb25zdHJ1Y3RvciByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEVycm9yID0gY29udGV4dC5FcnJvcixcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBOdW1iZXIgPSBjb250ZXh0Lk51bWJlcixcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dC5PYmplY3QsXG4gICAgICAgIFJlZ0V4cCA9IGNvbnRleHQuUmVnRXhwLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0LlN0cmluZyxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dC5UeXBlRXJyb3I7XG5cbiAgICAvKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIHN0cmluZ1Byb3RvID0gU3RyaW5nLnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBET00gc3VwcG9ydC4gKi9cbiAgICB2YXIgZG9jdW1lbnQgPSAoZG9jdW1lbnQgPSBjb250ZXh0LndpbmRvdykgJiYgZG9jdW1lbnQuZG9jdW1lbnQ7XG5cbiAgICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG4gICAgdmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG4gICAgdmFyIGlkQ291bnRlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBfLm5vQ29uZmxpY3RgLiAqL1xuICAgIHZhciBvbGREYXNoID0gY29udGV4dC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbiAgICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgZXNjYXBlUmVnRXhwKG9ialRvU3RyaW5nKVxuICAgICAgLnJlcGxhY2UoL3RvU3RyaW5nfChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4gICAgKTtcblxuICAgIC8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEFycmF5QnVmZmVyID0gaXNOYXRpdmUoQXJyYXlCdWZmZXIgPSBjb250ZXh0LkFycmF5QnVmZmVyKSAmJiBBcnJheUJ1ZmZlcixcbiAgICAgICAgYnVmZmVyU2xpY2UgPSBpc05hdGl2ZShidWZmZXJTbGljZSA9IEFycmF5QnVmZmVyICYmIG5ldyBBcnJheUJ1ZmZlcigwKS5zbGljZSkgJiYgYnVmZmVyU2xpY2UsXG4gICAgICAgIGNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIGNsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0LFxuICAgICAgICBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgIGdldE93blByb3BlcnR5U3ltYm9scyA9IGlzTmF0aXZlKGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpICYmIGdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2YgPSBpc05hdGl2ZShnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZikgJiYgZ2V0UHJvdG90eXBlT2YsXG4gICAgICAgIHB1c2ggPSBhcnJheVByb3RvLnB1c2gsXG4gICAgICAgIHByZXZlbnRFeHRlbnNpb25zID0gaXNOYXRpdmUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKSAmJiBwcmV2ZW50RXh0ZW5zaW9ucyxcbiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICAgICAgU2V0ID0gaXNOYXRpdmUoU2V0ID0gY29udGV4dC5TZXQpICYmIFNldCxcbiAgICAgICAgc2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICAgIFVpbnQ4QXJyYXkgPSBpc05hdGl2ZShVaW50OEFycmF5ID0gY29udGV4dC5VaW50OEFycmF5KSAmJiBVaW50OEFycmF5LFxuICAgICAgICBXZWFrTWFwID0gaXNOYXRpdmUoV2Vha01hcCA9IGNvbnRleHQuV2Vha01hcCkgJiYgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGNsb25lIGFycmF5IGJ1ZmZlcnMuICovXG4gICAgdmFyIEZsb2F0NjRBcnJheSA9IChmdW5jdGlvbigpIHtcbiAgICAgIC8vIFNhZmFyaSA1IGVycm9ycyB3aGVuIHVzaW5nIGFuIGFycmF5IGJ1ZmZlciB0byBpbml0aWFsaXplIGEgdHlwZWQgYXJyYXlcbiAgICAgIC8vIHdoZXJlIHRoZSBhcnJheSBidWZmZXIncyBgYnl0ZUxlbmd0aGAgaXMgbm90IGEgbXVsdGlwbGUgb2YgdGhlIHR5cGVkXG4gICAgICAvLyBhcnJheSdzIGBCWVRFU19QRVJfRUxFTUVOVGAuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZnVuYyA9IGlzTmF0aXZlKGZ1bmMgPSBjb250ZXh0LkZsb2F0NjRBcnJheSkgJiYgZnVuYyxcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBmdW5jKG5ldyBBcnJheUJ1ZmZlcigxMCksIDAsIDEpICYmIGZ1bmM7XG4gICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0oKSk7XG5cbiAgICAvKiogVXNlZCBhcyBgYmFzZUFzc2lnbmAuICovXG4gICAgdmFyIG5hdGl2ZUFzc2lnbiA9IChmdW5jdGlvbigpIHtcbiAgICAgIC8vIEF2b2lkIGBPYmplY3QuYXNzaWduYCBpbiBGaXJlZm94IDM0LTM3IHdoaWNoIGhhdmUgYW4gZWFybHkgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIHdpdGggYSBub3cgZGVmdW5jdCB0cnkvY2F0Y2ggYmVoYXZpb3IuIFNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTAzMzQ0XG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgLy9cbiAgICAgIC8vIFVzZSBgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zYCBvbiBhIHBsYWluIG9iamVjdCBpbnN0ZWFkIG9mIHNpbXBseSB1c2luZ1xuICAgICAgLy8gYE9iamVjdCgneCcpYCBiZWNhdXNlIENocm9tZSBhbmQgSUUgZmFpbCB0byB0aHJvdyBhbiBlcnJvciB3aGVuIGF0dGVtcHRpbmdcbiAgICAgIC8vIHRvIGFzc2lnbiB2YWx1ZXMgdG8gcmVhZG9ubHkgaW5kZXhlcyBvZiBzdHJpbmdzIGluIHN0cmljdCBtb2RlLlxuICAgICAgdmFyIG9iamVjdCA9IHsgJzEnOiAwIH0sXG4gICAgICAgICAgZnVuYyA9IHByZXZlbnRFeHRlbnNpb25zICYmIGlzTmF0aXZlKGZ1bmMgPSBPYmplY3QuYXNzaWduKSAmJiBmdW5jO1xuXG4gICAgICB0cnkgeyBmdW5jKHByZXZlbnRFeHRlbnNpb25zKG9iamVjdCksICd4bycpOyB9IGNhdGNoKGUpIHt9XG4gICAgICByZXR1cm4gIW9iamVjdFsxXSAmJiBmdW5jO1xuICAgIH0oKSk7XG5cbiAgICAvKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICAgIHZhciBuYXRpdmVJc0FycmF5ID0gaXNOYXRpdmUobmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkpICYmIG5hdGl2ZUlzQXJyYXksXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGlzTmF0aXZlKG5hdGl2ZUNyZWF0ZSA9IE9iamVjdC5jcmVhdGUpICYmIG5hdGl2ZUNyZWF0ZSxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVLZXlzID0gaXNOYXRpdmUobmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzKSAmJiBuYXRpdmVLZXlzLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZU5vdyA9IGlzTmF0aXZlKG5hdGl2ZU5vdyA9IERhdGUubm93KSAmJiBuYXRpdmVOb3csXG4gICAgICAgIG5hdGl2ZU51bUlzRmluaXRlID0gaXNOYXRpdmUobmF0aXZlTnVtSXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUpICYmIG5hdGl2ZU51bUlzRmluaXRlLFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4gICAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgYC1JbmZpbml0eWAgYW5kIGBJbmZpbml0eWAuICovXG4gICAgdmFyIE5FR0FUSVZFX0lORklOSVRZID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgICAgICBQT1NJVElWRV9JTkZJTklUWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAgIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHRoZSBtYXhpbXVtIGxlbmd0aCBhbmQgaW5kZXggb2YgYW4gYXJyYXkuICovXG4gICAgdmFyIE1BWF9BUlJBWV9MRU5HVEggPSBNYXRoLnBvdygyLCAzMikgLSAxLFxuICAgICAgICBNQVhfQVJSQVlfSU5ERVggPSAgTUFYX0FSUkFZX0xFTkdUSCAtIDEsXG4gICAgICAgIEhBTEZfTUFYX0FSUkFZX0xFTkdUSCA9IE1BWF9BUlJBWV9MRU5HVEggPj4+IDE7XG5cbiAgICAvKiogVXNlZCBhcyB0aGUgc2l6ZSwgaW4gYnl0ZXMsIG9mIGVhY2ggYEZsb2F0NjRBcnJheWAgZWxlbWVudC4gKi9cbiAgICB2YXIgRkxPQVQ2NF9CWVRFU19QRVJfRUxFTUVOVCA9IEZsb2F0NjRBcnJheSA/IEZsb2F0NjRBcnJheS5CWVRFU19QRVJfRUxFTUVOVCA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAgICAgKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICAgICAqL1xuICAgIHZhciBNQVhfU0FGRV9JTlRFR0VSID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuICAgIC8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgaW1wbGljaXQgY2hhaW5pbmcuXG4gICAgICogTWV0aG9kcyB0aGF0IG9wZXJhdGUgb24gYW5kIHJldHVybiBhcnJheXMsIGNvbGxlY3Rpb25zLCBhbmQgZnVuY3Rpb25zIGNhblxuICAgICAqIGJlIGNoYWluZWQgdG9nZXRoZXIuIE1ldGhvZHMgdGhhdCByZXR1cm4gYSBib29sZWFuIG9yIHNpbmdsZSB2YWx1ZSB3aWxsXG4gICAgICogYXV0b21hdGljYWxseSBlbmQgdGhlIGNoYWluIHJldHVybmluZyB0aGUgdW53cmFwcGVkIHZhbHVlLiBFeHBsaWNpdCBjaGFpbmluZ1xuICAgICAqIG1heSBiZSBlbmFibGVkIHVzaW5nIGBfLmNoYWluYC4gVGhlIGV4ZWN1dGlvbiBvZiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSxcbiAgICAgKiB0aGF0IGlzLCBleGVjdXRpb24gaXMgZGVmZXJyZWQgdW50aWwgYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseVxuICAgICAqIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIExhenkgZXZhbHVhdGlvbiBhbGxvd3Mgc2V2ZXJhbCBtZXRob2RzIHRvIHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uLiBTaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpcyBhbiBvcHRpbWl6YXRpb24gdGhhdCBtZXJnZXMgaXRlcmF0ZWVzIHRvIGF2b2lkIGNyZWF0aW5nIGludGVybWVkaWF0ZVxuICAgICAqIGFycmF5cyBhbmQgcmVkdWNlIHRoZSBudW1iZXIgb2YgaXRlcmF0ZWUgZXhlY3V0aW9ucy5cbiAgICAgKlxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgQXJyYXlgIG1ldGhvZHMgYXJlOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGByZXZlcnNlYCwgYHNoaWZ0YCwgYHNsaWNlYCwgYHNvcnRgLFxuICAgICAqIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgU3RyaW5nYCBtZXRob2RzIGFyZTpcbiAgICAgKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbiBhcmU6XG4gICAgICogYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsXG4gICAgICogYGZpcnN0YCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcGx1Y2tgLCBgcmVqZWN0YCwgYHJlc3RgLCBgcmV2ZXJzZWAsXG4gICAgICogYHNsaWNlYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0b0FycmF5YCxcbiAgICAgKiBhbmQgYHdoZXJlYFxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGF0YCwgYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsXG4gICAgICogYGNhbGxiYWNrYCwgYGNoYWluYCwgYGNodW5rYCwgYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25zdGFudGAsXG4gICAgICogYGNvdW50QnlgLCBgY3JlYXRlYCwgYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmVyYCwgYGRlbGF5YCxcbiAgICAgKiBgZGlmZmVyZW5jZWAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wUmlnaHRXaGlsZWAsIGBkcm9wV2hpbGVgLCBgZmlsbGAsXG4gICAgICogYGZpbHRlcmAsIGBmbGF0dGVuYCwgYGZsYXR0ZW5EZWVwYCwgYGZsb3dgLCBgZmxvd1JpZ2h0YCwgYGZvckVhY2hgLFxuICAgICAqIGBmb3JFYWNoUmlnaHRgLCBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZnVuY3Rpb25zYCxcbiAgICAgKiBgZ3JvdXBCeWAsIGBpbmRleEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludmVydGAsIGBpbnZva2VgLCBga2V5c2AsXG4gICAgICogYGtleXNJbmAsIGBtYXBgLCBgbWFwVmFsdWVzYCwgYG1hdGNoZXNgLCBgbWF0Y2hlc1Byb3BlcnR5YCwgYG1lbW9pemVgLFxuICAgICAqIGBtZXJnZWAsIGBtaXhpbmAsIGBuZWdhdGVgLCBgb21pdGAsIGBvbmNlYCwgYHBhaXJzYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCxcbiAgICAgKiBgcGFydGl0aW9uYCwgYHBpY2tgLCBgcGxhbnRgLCBgcGx1Y2tgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCxcbiAgICAgKiBgcHVsbEF0YCwgYHB1c2hgLCBgcmFuZ2VgLCBgcmVhcmdgLCBgcmVqZWN0YCwgYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLFxuICAgICAqIGBzaHVmZmxlYCwgYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNvcnRCeUFsbGAsIGBzb3J0QnlPcmRlcmAsIGBzcGxpY2VgLFxuICAgICAqIGBzcHJlYWRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsXG4gICAgICogYHRocm90dGxlYCwgYHRocnVgLCBgdGltZXNgLCBgdG9BcnJheWAsIGB0b1BsYWluT2JqZWN0YCwgYHRyYW5zZm9ybWAsXG4gICAgICogYHVuaW9uYCwgYHVuaXFgLCBgdW5zaGlmdGAsIGB1bnppcGAsIGB2YWx1ZXNgLCBgdmFsdWVzSW5gLCBgd2hlcmVgLFxuICAgICAqIGB3aXRob3V0YCwgYHdyYXBgLCBgeG9yYCwgYHppcGAsIGFuZCBgemlwT2JqZWN0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAgICAgKiBgYWRkYCwgYGF0dGVtcHRgLCBgY2FtZWxDYXNlYCwgYGNhcGl0YWxpemVgLCBgY2xvbmVgLCBgY2xvbmVEZWVwYCwgYGRlYnVycmAsXG4gICAgICogYGVuZHNXaXRoYCwgYGVzY2FwZWAsIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLCBgZmluZEtleWAsXG4gICAgICogYGZpbmRMYXN0YCwgYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgZmluZFdoZXJlYCwgYGZpcnN0YCwgYGhhc2AsXG4gICAgICogYGlkZW50aXR5YCwgYGluY2x1ZGVzYCwgYGluZGV4T2ZgLCBgaW5SYW5nZWAsIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCxcbiAgICAgKiBgaXNCb29sZWFuYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLCBgaXNFbXB0eWAsIGBpc0VxdWFsYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgXG4gICAgICogYGlzRnVuY3Rpb25gLCBgaXNNYXRjaGAsIGBpc05hdGl2ZWAsIGBpc05hTmAsIGBpc051bGxgLCBgaXNOdW1iZXJgLCBgaXNPYmplY3RgLFxuICAgICAqIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsXG4gICAgICogYGpvaW5gLCBga2ViYWJDYXNlYCwgYGxhc3RgLCBgbGFzdEluZGV4T2ZgLCBgbWF4YCwgYG1pbmAsIGBub0NvbmZsaWN0YCxcbiAgICAgKiBgbm9vcGAsIGBub3dgLCBgcGFkYCwgYHBhZExlZnRgLCBgcGFkUmlnaHRgLCBgcGFyc2VJbnRgLCBgcG9wYCwgYHJhbmRvbWAsXG4gICAgICogYHJlZHVjZWAsIGByZWR1Y2VSaWdodGAsIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJ1bkluQ29udGV4dGAsIGBzaGlmdGAsIGBzaXplYCxcbiAgICAgKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkTGFzdEluZGV4YCwgYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCxcbiAgICAgKiBgc3VtYCwgYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUxlZnRgLCBgdHJpbVJpZ2h0YCwgYHRydW5jYCwgYHVuZXNjYXBlYCxcbiAgICAgKiBgdW5pcXVlSWRgLCBgdmFsdWVgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kIGBzYW1wbGVgIHdpbGwgcmV0dXJuIGEgd3JhcHBlZCB2YWx1ZSB3aGVuIGBuYCBpcyBwcm92aWRlZCxcbiAgICAgKiBvdGhlcndpc2UgYW4gdW53cmFwcGVkIHZhbHVlIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm5zIGFuIHVud3JhcHBlZCB2YWx1ZVxuICAgICAqIHdyYXBwZWQucmVkdWNlKGZ1bmN0aW9uKHRvdGFsLCBuKSB7XG4gICAgICogICByZXR1cm4gdG90YWwgKyBuO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIHJldHVybnMgYSB3cmFwcGVkIHZhbHVlXG4gICAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX2NoYWluX18nKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX193cmFwcGVkX18nKSkge1xuICAgICAgICAgIHJldHVybiB3cmFwcGVyQ2xvbmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB3aG9zZSBwcm90b3R5cGUgYWxsIGNoYWluaW5nIHdyYXBwZXJzIGluaGVyaXQgZnJvbS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUxvZGFzaCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGFpbkFsbF0gRW5hYmxlIGNoYWluaW5nIGZvciBhbGwgd3JhcHBlciBtZXRob2RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthY3Rpb25zPVtdXSBBY3Rpb25zIHRvIHBlZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwsIGFjdGlvbnMpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBhY3Rpb25zIHx8IFtdO1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBlbnZpcm9ubWVudCBmZWF0dXJlIGZsYWdzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdmFyIHN1cHBvcnQgPSBsb2Rhc2guc3VwcG9ydCA9IHt9O1xuXG4gICAgKGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBDdG9yID0gZnVuY3Rpb24oKSB7IHRoaXMueCA9IHg7IH0sXG4gICAgICAgICAgb2JqZWN0ID0geyAnMCc6IHgsICdsZW5ndGgnOiB4IH0sXG4gICAgICAgICAgcHJvcHMgPSBbXTtcblxuICAgICAgQ3Rvci5wcm90b3R5cGUgPSB7ICd2YWx1ZU9mJzogeCwgJ3knOiB4IH07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbmV3IEN0b3IpIHsgcHJvcHMucHVzaChrZXkpOyB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGV0ZWN0IGlmIGZ1bmN0aW9ucyBjYW4gYmUgZGVjb21waWxlZCBieSBgRnVuY3Rpb24jdG9TdHJpbmdgXG4gICAgICAgKiAoYWxsIGJ1dCBGaXJlZm94IE9TIGNlcnRpZmllZCBhcHBzLCBvbGRlciBPcGVyYSBtb2JpbGUgYnJvd3NlcnMsIGFuZFxuICAgICAgICogdGhlIFBsYXlTdGF0aW9uIDM7IGZvcmNlZCBgZmFsc2VgIGZvciBXaW5kb3dzIDggYXBwcykuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICovXG4gICAgICBzdXBwb3J0LmZ1bmNEZWNvbXAgPSAvXFxidGhpc1xcYi8udGVzdChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG4gICAgICAvKipcbiAgICAgICAqIERldGVjdCBpZiBgRnVuY3Rpb24jbmFtZWAgaXMgc3VwcG9ydGVkIChhbGwgYnV0IElFKS5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy5zdXBwb3J0XG4gICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgKi9cbiAgICAgIHN1cHBvcnQuZnVuY05hbWVzID0gdHlwZW9mIEZ1bmN0aW9uLm5hbWUgPT0gJ3N0cmluZyc7XG5cbiAgICAgIC8qKlxuICAgICAgICogRGV0ZWN0IGlmIHRoZSBET00gaXMgc3VwcG9ydGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqL1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VwcG9ydC5kb20gPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkubm9kZVR5cGUgPT09IDExO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHN1cHBvcnQuZG9tID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGV0ZWN0IGlmIGBhcmd1bWVudHNgIG9iamVjdCBpbmRleGVzIGFyZSBub24tZW51bWVyYWJsZS5cbiAgICAgICAqXG4gICAgICAgKiBJbiBGaXJlZm94IDwgNCwgSUUgPCA5LCBQaGFudG9tSlMsIGFuZCBTYWZhcmkgPCA1LjEgYGFyZ3VtZW50c2Agb2JqZWN0XG4gICAgICAgKiBpbmRleGVzIGFyZSBub24tZW51bWVyYWJsZS4gQ2hyb21lIDwgMjUgYW5kIE5vZGUuanMgPCAwLjExLjAgdHJlYXRcbiAgICAgICAqIGBhcmd1bWVudHNgIG9iamVjdCBpbmRleGVzIGFzIG5vbi1lbnVtZXJhYmxlIGFuZCBmYWlsIGBoYXNPd25Qcm9wZXJ0eWBcbiAgICAgICAqIGNoZWNrcyBmb3IgaW5kZXhlcyB0aGF0IGV4Y2VlZCB0aGUgbnVtYmVyIG9mIGZ1bmN0aW9uIHBhcmFtZXRlcnMgYW5kXG4gICAgICAgKiB3aG9zZSBhc3NvY2lhdGVkIGFyZ3VtZW50IHZhbHVlcyBhcmUgYDBgLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqL1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VwcG9ydC5ub25FbnVtQXJncyA9ICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgc3VwcG9ydC5ub25FbnVtQXJncyA9IHRydWU7XG4gICAgICB9XG4gICAgfSgxLCAwKSk7XG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICAgICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikuIENoYW5nZSB0aGUgZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZVxuICAgICAqIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBSZWdFeHBcbiAgICAgICAqL1xuICAgICAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXZhbHVhdGUnOiByZUV2YWx1YXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAqL1xuICAgICAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICovXG4gICAgICAnaW1wb3J0cyc6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBsYXp5IHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGxhenkgZXZhbHVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IG51bGw7XG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xuICAgICAgdGhpcy5fX2Ryb3BDb3VudF9fID0gMDtcbiAgICAgIHRoaXMuX19maWx0ZXJlZF9fID0gZmFsc2U7XG4gICAgICB0aGlzLl9faXRlcmF0ZWVzX18gPSBudWxsO1xuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB0aGlzLl9fdmlld3NfXyA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBsYXp5IHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbG9uZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuX19hY3Rpb25zX18sXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgICAgIHZpZXdzID0gdGhpcy5fX3ZpZXdzX18sXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMuX193cmFwcGVkX18pO1xuXG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBhY3Rpb25zID8gYXJyYXlDb3B5KGFjdGlvbnMpIDogbnVsbDtcbiAgICAgIHJlc3VsdC5fX2Rpcl9fID0gdGhpcy5fX2Rpcl9fO1xuICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRoaXMuX19maWx0ZXJlZF9fO1xuICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18gPSBpdGVyYXRlZXMgPyBhcnJheUNvcHkoaXRlcmF0ZWVzKSA6IG51bGw7XG4gICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IHRoaXMuX190YWtlQ291bnRfXztcbiAgICAgIHJlc3VsdC5fX3ZpZXdzX18gPSB2aWV3cyA/IGFycmF5Q29weSh2aWV3cykgOiBudWxsO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgZGlyZWN0aW9uIG9mIGxhenkgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHJldmVyc2VkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlSZXZlcnNlKCkge1xuICAgICAgaWYgKHRoaXMuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fID0gLTE7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHVud3JhcHBlZCB2YWx1ZSBmcm9tIGl0cyBsYXp5IHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5VmFsdWUoKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9fd3JhcHBlZF9fLnZhbHVlKCk7XG4gICAgICBpZiAoIWlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKGFycmF5LCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIH1cbiAgICAgIHZhciBkaXIgPSB0aGlzLl9fZGlyX18sXG4gICAgICAgICAgaXNSaWdodCA9IGRpciA8IDAsXG4gICAgICAgICAgdmlldyA9IGdldFZpZXcoMCwgYXJyYXkubGVuZ3RoLCB0aGlzLl9fdmlld3NfXyksXG4gICAgICAgICAgc3RhcnQgPSB2aWV3LnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IHZpZXcuZW5kLFxuICAgICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IChzdGFydCAtIDEpLFxuICAgICAgICAgIHRha2VDb3VudCA9IG5hdGl2ZU1pbihsZW5ndGgsIHRoaXMuX190YWtlQ291bnRfXyksXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgICAgIGl0ZXJMZW5ndGggPSBpdGVyYXRlZXMgPyBpdGVyYXRlZXMubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKGxlbmd0aC0tICYmIHJlc0luZGV4IDwgdGFrZUNvdW50KSB7XG4gICAgICAgIGluZGV4ICs9IGRpcjtcblxuICAgICAgICB2YXIgaXRlckluZGV4ID0gLTEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICB3aGlsZSAoKytpdGVySW5kZXggPCBpdGVyTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSxcbiAgICAgICAgICAgICAgaXRlcmF0ZWUgPSBkYXRhLml0ZXJhdGVlLFxuICAgICAgICAgICAgICB0eXBlID0gZGF0YS50eXBlO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9EUk9QX1dISUxFX0ZMQUcpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmRvbmUgJiYgKGlzUmlnaHQgPyAoaW5kZXggPiBkYXRhLmluZGV4KSA6IChpbmRleCA8IGRhdGEuaW5kZXgpKSkge1xuICAgICAgICAgICAgICBkYXRhLmNvdW50ID0gMDtcbiAgICAgICAgICAgICAgZGF0YS5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBpZiAoIWRhdGEuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgbGltaXQgPSBkYXRhLmxpbWl0O1xuICAgICAgICAgICAgICBpZiAoIShkYXRhLmRvbmUgPSBsaW1pdCA+IC0xID8gKGRhdGEuY291bnQrKyA+PSBsaW1pdCkgOiAhaXRlcmF0ZWUodmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfTUFQX0ZMQUcpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBjb21wdXRlZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfRklMVEVSX0ZMQUcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXkvdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbmFtZSBDYWNoZVxuICAgICAqIEBtZW1iZXJPZiBfLm1lbW9pemVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBDYWNoZSgpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBfLm1lbW9pemUuQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkIHN1Y2Nlc3NmdWxseSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcERlbGV0ZShrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2FjaGVkIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZS5DYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjYWNoZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwR2V0KGtleSkge1xuICAgICAgcmV0dXJuIGtleSA9PSAnX19wcm90b19fJyA/IHVuZGVmaW5lZCA6IHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBjYWNoZWQgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZS5DYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBIYXMoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5ICE9ICdfX3Byb3RvX18nICYmIGhhc093blByb3BlcnR5LmNhbGwodGhpcy5fX2RhdGFfXywga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGB2YWx1ZWAgdG8gYGtleWAgb2YgdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgXy5tZW1vaXplLkNhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgIT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFfX1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZXMgPyB2YWx1ZXMubGVuZ3RoIDogMDtcblxuICAgICAgdGhpcy5kYXRhID0geyAnaGFzaCc6IG5hdGl2ZUNyZWF0ZShudWxsKSwgJ3NldCc6IG5ldyBTZXQgfTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB0aGlzLnB1c2godmFsdWVzW2xlbmd0aF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjYWNoZWAgbWltaWNraW5nIHRoZSByZXR1cm4gc2lnbmF0dXJlIG9mXG4gICAgICogYF8uaW5kZXhPZmAgYnkgcmV0dXJuaW5nIGAwYCBpZiB0aGUgdmFsdWUgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGAwYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBjYWNoZS5kYXRhLFxuICAgICAgICAgIHJlc3VsdCA9ICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNPYmplY3QodmFsdWUpKSA/IGRhdGEuc2V0Lmhhcyh2YWx1ZSkgOiBkYXRhLmhhc2hbdmFsdWVdO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID8gMCA6IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYHZhbHVlYCB0byB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHB1c2hcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWNoZVB1c2godmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZGF0YS5zZXQuYWRkKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEuaGFzaFt2YWx1ZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUNvcHkoc291cmNlLCBhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlFYWNoUmlnaHQoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RXZlcnkoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWF4YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TWF4KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gTkVHQVRJVkVfSU5GSU5JVFk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1pbmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheU1pbihhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IFBPU0lUSVZFX0lORklOSVRZO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRGcm9tQXJyYXldIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YFxuICAgICAqICBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEZyb21BcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAoaW5pdEZyb21BcnJheSAmJiBsZW5ndGgpIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRGcm9tQXJyYXldIFNwZWNpZnkgdXNpbmcgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgXG4gICAgICogIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVJlZHVjZVJpZ2h0KGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRGcm9tQXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoaW5pdEZyb21BcnJheSAmJiBsZW5ndGgpIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVstLWxlbmd0aF07XG4gICAgICB9XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc3VtYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVN1bShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0ICs9ICthcnJheVtsZW5ndGhdIHx8IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduYCB1c2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0VmFsdWUgVGhlIGRlc3RpbmF0aW9uIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVZhbHVlIFRoZSBzb3VyY2Ugb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24gdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25EZWZhdWx0cyhvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmplY3RWYWx1ZSA9PT0gdW5kZWZpbmVkID8gc291cmNlVmFsdWUgOiBvYmplY3RWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbmAgdXNlLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduRGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IGlnbm9yZXNcbiAgICAgKiBpbmhlcml0ZWQgcHJvcGVydHkgdmFsdWVzIHdoZW4gY2hlY2tpbmcgaWYgYSBwcm9wZXJ0eSBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3RWYWx1ZSBUaGUgZGVzdGluYXRpb24gb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlVmFsdWUgVGhlIHNvdXJjZSBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgb2JqZWN0IGFuZCBzb3VyY2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduT3duRGVmYXVsdHMob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgcmV0dXJuIChvYmplY3RWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSlcbiAgICAgICAgPyBzb3VyY2VWYWx1ZVxuICAgICAgICA6IG9iamVjdFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5hc3NpZ25gIGZvciBjdXN0b21pemluZyBhc3NpZ25lZCB2YWx1ZXMgd2l0aG91dFxuICAgICAqIHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nLCBtdWx0aXBsZSBzb3VyY2VzLCBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgXG4gICAgICogZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpO1xuICAgICAgcHVzaC5hcHBseShwcm9wcywgZ2V0U3ltYm9scyhzb3VyY2UpKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIodmFsdWUsIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKTtcblxuICAgICAgICBpZiAoKHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlc3VsdCAhPT0gdmFsdWUpIDogKHZhbHVlID09PSB2YWx1ZSkpIHx8XG4gICAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZyxcbiAgICAgKiBtdWx0aXBsZSBzb3VyY2VzLCBhbmQgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUFzc2lnbiA9IG5hdGl2ZUFzc2lnbiB8fCBmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZSA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUNvcHkoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIGJhc2VDb3B5KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXRgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RyaW5nIGNvbGxlY3Rpb25zXG4gICAgICogYW5kIGluZGl2aWR1YWwga2V5IGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118c3RyaW5nW119IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyBvciBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBdChjb2xsZWN0aW9uLCBwcm9wcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgaXNBcnIgPSBpc0xlbmd0aChsZW5ndGgpLFxuICAgICAgICAgIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHByb3BzTGVuZ3RoKTtcblxuICAgICAgd2hpbGUoKytpbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBpc0luZGV4KGtleSwgbGVuZ3RoKSA/IGNvbGxlY3Rpb25ba2V5XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gY29sbGVjdGlvbltrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGNvcHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvcHkoc291cmNlLCBwcm9wcywgb2JqZWN0KSB7XG4gICAgICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jYWxsYmFja2Agd2hpY2ggc3VwcG9ydHMgc3BlY2lmeWluZyB0aGVcbiAgICAgKiBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZnVuYztcbiAgICAgIGlmICh0eXBlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNBcmcgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gZnVuY1xuICAgICAgICAgIDogYmluZENhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChmdW5jID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGZ1bmMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNBcmcgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHByb3BlcnR5KGZ1bmMpXG4gICAgICAgIDogYmFzZU1hdGNoZXNQcm9wZXJ0eShmdW5jLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZ1xuICAgICAqIGFuZCBgdGhpc2AgYmluZGluZyBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgYHZhbHVlYCBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyBjbG9uZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0KSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5Q29weSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhZyA9IG9ialRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWc7XG5cbiAgICAgICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZU9iamVjdChpc0Z1bmMgPyB7fSA6IHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjbG9uZWFibGVUYWdzW3RhZ11cbiAgICAgICAgICAgID8gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKVxuICAgICAgICAgICAgOiAob2JqZWN0ID8gdmFsdWUgOiB7fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzIGFuZCBhc3NvY2lhdGUgaXQgd2l0aCBpdHMgY2xvbmUuXG4gICAgICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gICAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgKGlzQXJyID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikodmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBiYXNlQ2xvbmUoc3ViVmFsdWUsIGlzRGVlcCwgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gT2JqZWN0KCkge31cbiAgICAgIHJldHVybiBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSkpIHtcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgT2JqZWN0O1xuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgY29udGV4dC5PYmplY3QoKTtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYW4gaW5kZXhcbiAgICAgKiBvZiB3aGVyZSB0byBzbGljZSB0aGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIFRoZSBhcmd1bWVudHMgcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURlbGF5KGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRpZmZlcmVuY2VgIHdoaWNoIGFjY2VwdHMgYSBzaW5nbGUgYXJyYXlcbiAgICAgKiBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgaXNDb21tb24gPSBpbmRleE9mID09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIGNhY2hlID0gKGlzQ29tbW9uICYmIHZhbHVlcy5sZW5ndGggPj0gMjAwKSA/IGNyZWF0ZUNhY2hlKHZhbHVlcykgOiBudWxsLFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMgPSBjYWNoZTtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiB2YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4T2YodmFsdWVzLCB2YWx1ZSwgMCkgPCAwKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hSaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaFJpZ2h0ID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93blJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsbGAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogKCtzdGFydCB8fCAwKTtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogKCtlbmQgfHwgMCk7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKGVuZCA+Pj4gMCk7XG4gICAgICBzdGFydCA+Pj49IDA7XG5cbiAgICAgIHdoaWxlIChzdGFydCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtzdGFydCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZGAsIGBfLmZpbmRMYXN0YCwgYF8uZmluZEtleWAsIGFuZCBgXy5maW5kTGFzdEtleWAsXG4gICAgICogd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZywgd2hpY2ggaXRlcmF0ZXNcbiAgICAgKiBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyB0aGUgcHJvdmlkZWQgYGVhY2hGdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRLZXldIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBrZXkgb2YgdGhlIGZvdW5kIGVsZW1lbnRcbiAgICAgKiAgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQgb3IgaXRzIGtleSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmluZChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jLCByZXRLZXkpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXRLZXkgPyBrZXkgOiB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIGFkZGVkIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nXG4gICAgICogZmxhdHRlbmluZyBhbmQgc3BlY2lmeWluZyB0aGUgc3RhcnQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEZWVwIFNwZWNpZnkgYSBkZWVwIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1N0cmljdCBSZXN0cmljdCBmbGF0dGVuaW5nIHRvIGFycmF5cyBhbmQgYGFyZ3VtZW50c2Agb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGlzRGVlcCwgaXNTdHJpY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VGbGF0dGVuKHZhbHVlLCBpc0RlZXAsIGlzU3RyaWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZhbEluZGV4ID0gLTEsXG4gICAgICAgICAgICAgIHZhbExlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICAgICAgICAgIHJlc3VsdC5sZW5ndGggKz0gdmFsTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgrK3ZhbEluZGV4IDwgdmFsTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSB2YWx1ZVt2YWxJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9ySW5gIGFuZCBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXNcbiAgICAgKiBvdmVyIGBvYmplY3RgIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvclxuICAgICAqIGVhY2ggcHJvcGVydHkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseVxuICAgICAqIHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlRm9yYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXNcbiAgICAgKiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3JSaWdodCA9IGNyZWF0ZUJhc2VGb3IodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25SaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGb3JSaWdodChvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mdW5jdGlvbnNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBgb2JqZWN0YCBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmaWx0ZXJlZCBmcm9tIHRob3NlIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZmlsdGVyLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGdW5jdGlvbnMob2JqZWN0LCBwcm9wcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9iamVjdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0cmluZyBwYXRoc1xuICAgICAqIGFuZCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhdGhLZXldIFRoZSBrZXkgcmVwcmVzZW50YXRpb24gb2YgcGF0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgsIHBhdGhLZXkpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocGF0aEtleSAhPT0gdW5kZWZpbmVkICYmIHBhdGhLZXkgaW4gdG9PYmplY3Qob2JqZWN0KSkge1xuICAgICAgICBwYXRoID0gW3BhdGhLZXldO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBvYmplY3QgPSBvYmplY3RbcGF0aFtpbmRleF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aXRob3V0IHN1cHBvcnQgZm9yIGB0aGlzYCBiaW5kaW5nXG4gICAgICogYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGZvciBpZGVudGljYWwgdmFsdWVzLlxuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICAvLyBUcmVhdCBgKzBgIHZzLiBgLTBgIGFzIG5vdCBlcXVhbC5cbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSAwIHx8ICgxIC8gdmFsdWUgPT0gMSAvIG90aGVyKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWxUeXBlID0gdHlwZW9mIHZhbHVlLFxuICAgICAgICAgIG90aFR5cGUgPSB0eXBlb2Ygb3RoZXI7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgZm9yIHVubGlrZSBwcmltaXRpdmUgdmFsdWVzLlxuICAgICAgaWYgKCh2YWxUeXBlICE9ICdmdW5jdGlvbicgJiYgdmFsVHlwZSAhPSAnb2JqZWN0JyAmJiBvdGhUeXBlICE9ICdmdW5jdGlvbicgJiYgb3RoVHlwZSAhPSAnb2JqZWN0JykgfHxcbiAgICAgICAgICB2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwpIHtcbiAgICAgICAgLy8gUmV0dXJuIGBmYWxzZWAgdW5sZXNzIGJvdGggdmFsdWVzIGFyZSBgTmFOYC5cbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYmFzZUlzRXF1YWwsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTG9vc2VdIFNwZWNpZnkgcGVyZm9ybWluZyBwYXJ0aWFsIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgICAgICBvYmpUYWcgPSBhcnJheVRhZyxcbiAgICAgICAgICBvdGhUYWcgPSBhcnJheVRhZztcblxuICAgICAgaWYgKCFvYmpJc0Fycikge1xuICAgICAgICBvYmpUYWcgPSBvYmpUb1N0cmluZy5jYWxsKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmpUYWcgPT0gYXJnc1RhZykge1xuICAgICAgICAgIG9ialRhZyA9IG9iamVjdFRhZztcbiAgICAgICAgfSBlbHNlIGlmIChvYmpUYWcgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgICAgb2JqSXNBcnIgPSBpc1R5cGVkQXJyYXkob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFvdGhJc0Fycikge1xuICAgICAgICBvdGhUYWcgPSBvYmpUb1N0cmluZy5jYWxsKG90aGVyKTtcbiAgICAgICAgaWYgKG90aFRhZyA9PSBhcmdzVGFnKSB7XG4gICAgICAgICAgb3RoVGFnID0gb2JqZWN0VGFnO1xuICAgICAgICB9IGVsc2UgaWYgKG90aFRhZyAhPSBvYmplY3RUYWcpIHtcbiAgICAgICAgICBvdGhJc0FyciA9IGlzVHlwZWRBcnJheShvdGhlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgIShvYmpJc0FyciB8fCBvYmpJc09iaikpIHtcbiAgICAgICAgcmV0dXJuIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNMb29zZSkge1xuICAgICAgICB2YXIgdmFsV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgICAgIG90aFdyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgICBpZiAodmFsV3JhcHBlZCB8fCBvdGhXcmFwcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyh2YWxXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsIG90aFdyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXIsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZGV0ZWN0aW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMgc2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jSk8uXG4gICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IFtdKTtcbiAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gW10pO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gb2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09IG90aGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBZGQgYG9iamVjdGAgYW5kIGBvdGhlcmAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgc3RhY2tBLnB1c2gob2JqZWN0KTtcbiAgICAgIHN0YWNrQi5wdXNoKG90aGVyKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IChvYmpJc0FyciA/IGVxdWFsQXJyYXlzIDogZXF1YWxPYmplY3RzKShvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcblxuICAgICAgc3RhY2tBLnBvcCgpO1xuICAgICAgc3RhY2tCLnBvcCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHNvdXJjZSBwcm9wZXJ0eSBuYW1lcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHNvdXJjZSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3RyaWN0Q29tcGFyZUZsYWdzIFN0cmljdCBjb21wYXJpc29uIGZsYWdzIGZvciBzb3VyY2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBwcm9wcywgdmFsdWVzLCBzdHJpY3RDb21wYXJlRmxhZ3MsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgc3RyaWN0Q29tcGFyZUZsYWdzW2luZGV4XSlcbiAgICAgICAgICAgICAgPyB2YWx1ZXNbaW5kZXhdICE9PSBvYmplY3RbcHJvcHNbaW5kZXhdXVxuICAgICAgICAgICAgICA6ICEocHJvcHNbaW5kZXhdIGluIG9iamVjdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5kZXggPSAtMTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF0sXG4gICAgICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgc3JjVmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuXG4gICAgICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgc3RyaWN0Q29tcGFyZUZsYWdzW2luZGV4XSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBvYmpWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gb2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIGN1c3RvbWl6ZXIsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZ2V0TGVuZ3RoKGNvbGxlY3Rpb24pLFxuICAgICAgICAgIHJlc3VsdCA9IGlzTGVuZ3RoKGxlbmd0aCkgPyBBcnJheShsZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lcyBub3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY29uc3RhbnQodHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID09IDEpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICBpZiAoaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHZhbHVlICYmICh2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gdG9PYmplY3Qob2JqZWN0KSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZXMgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIHN0cmljdENvbXBhcmVGbGFncyA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YWx1ZSA9IHNvdXJjZVtwcm9wc1tsZW5ndGhdXTtcbiAgICAgICAgdmFsdWVzW2xlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgc3RyaWN0Q29tcGFyZUZsYWdzW2xlbmd0aF0gPSBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgYmFzZUlzTWF0Y2godG9PYmplY3Qob2JqZWN0KSwgcHJvcHMsIHZhbHVlcywgc3RyaWN0Q29tcGFyZUZsYWdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2VzIG5vdCB3aGljaCBkb2VzXG4gICAgICogbm90IGNsb25lIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHZhbHVlKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHBhdGgpLFxuICAgICAgICAgIGlzQ29tbW9uID0gaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSxcbiAgICAgICAgICBwYXRoS2V5ID0gKHBhdGggKyAnJyk7XG5cbiAgICAgIHBhdGggPSB0b1BhdGgocGF0aCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0gcGF0aEtleTtcbiAgICAgICAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcbiAgICAgICAgaWYgKChpc0FyciB8fCAhaXNDb21tb24pICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgICBvYmplY3QgPSBwYXRoLmxlbmd0aCA9PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXkgPSBsYXN0KHBhdGgpO1xuICAgICAgICAgIG9iamVjdCA9IHRvT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSB2YWx1ZVxuICAgICAgICAgID8gKHZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBvYmplY3QpKVxuICAgICAgICAgIDogYmFzZUlzRXF1YWwodmFsdWUsIG9iamVjdFtrZXldLCBudWxsLCB0cnVlKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsXG4gICAgICogbXVsdGlwbGUgc291cmNlcywgYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgdmFyIGlzU3JjQXJyID0gaXNMZW5ndGgoc291cmNlLmxlbmd0aCkgJiYgKGlzQXJyYXkoc291cmNlKSB8fCBpc1R5cGVkQXJyYXkoc291cmNlKSk7XG4gICAgICBpZiAoIWlzU3JjQXJyKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKTtcbiAgICAgICAgcHVzaC5hcHBseShwcm9wcywgZ2V0U3ltYm9scyhzb3VyY2UpKTtcbiAgICAgIH1cbiAgICAgIGFycmF5RWFjaChwcm9wcyB8fCBzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAga2V5ID0gc3JjVmFsdWU7XG4gICAgICAgICAgc3JjVmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPYmplY3RMaWtlKHNyY1ZhbHVlKSkge1xuICAgICAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuICAgICAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gW10pO1xuICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGlzQ29tbW9uID0gcmVzdWx0ID09PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNyY1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKGlzU3JjQXJyIHx8IHJlc3VsdCAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgICAoaXNDb21tb24gfHwgKHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlc3VsdCAhPT0gdmFsdWUpIDogKHZhbHVlID09PSB2YWx1ZSkpKSkge1xuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoLFxuICAgICAgICAgIHNyY1ZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gc3JjVmFsdWUpIHtcbiAgICAgICAgICBvYmplY3Rba2V5XSA9IHN0YWNrQltsZW5ndGhdO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBpc0NvbW1vbiA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgcmVzdWx0ID0gc3JjVmFsdWU7XG4gICAgICAgIGlmIChpc0xlbmd0aChzcmNWYWx1ZS5sZW5ndGgpICYmIChpc0FycmF5KHNyY1ZhbHVlKSB8fCBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXkodmFsdWUpXG4gICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICA6IChnZXRMZW5ndGgodmFsdWUpID8gYXJyYXlDb3B5KHZhbHVlKSA6IFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQgPSBpc0FyZ3VtZW50cyh2YWx1ZSlcbiAgICAgICAgICAgID8gdG9QbGFpbk9iamVjdCh2YWx1ZSlcbiAgICAgICAgICAgIDogKGlzUGxhaW5PYmplY3QodmFsdWUpID8gdmFsdWUgOiB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzIGFuZCBhc3NvY2lhdGVcbiAgICAgIC8vIGl0IHdpdGggaXRzIG1lcmdlZCB2YWx1ZS5cbiAgICAgIHN0YWNrQS5wdXNoKHNyY1ZhbHVlKTtcbiAgICAgIHN0YWNrQi5wdXNoKHJlc3VsdCk7XG5cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgb2JqZWN0W2tleV0gPSBtZXJnZUZ1bmMocmVzdWx0LCBzcmNWYWx1ZSwgY3VzdG9taXplciwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IHJlc3VsdCA/IChyZXN1bHQgIT09IHZhbHVlKSA6ICh2YWx1ZSA9PT0gdmFsdWUpKSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICAgICAgdmFyIHBhdGhLZXkgPSAocGF0aCArICcnKTtcbiAgICAgIHBhdGggPSB0b1BhdGgocGF0aCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCwgcGF0aEtleSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogaW5kZXggYXJndW1lbnRzIGFuZCBjYXB0dXJpbmcgdGhlIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlcyBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGluZGV4ZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHBhcnNlRmxvYXQoaW5kZXhlc1tsZW5ndGhdKTtcbiAgICAgICAgaWYgKGluZGV4ICE9IHByZXZpb3VzICYmIGlzSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZ1xuICAgICAqIGFuZCByZXR1cm5pbmcgZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIG1pbiArIGZsb29yKG5hdGl2ZVJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYFxuICAgICAqIHVzaW5nIHRoZSBwcm92aWRlZCBgZWFjaEZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRGcm9tQ29sbGVjdGlvbiBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnRcbiAgICAgKiAgb2YgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEZyb21Db2xsZWN0aW9uLCBlYWNoRnVuYykge1xuICAgICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEZyb21Db2xsZWN0aW9uXG4gICAgICAgICAgPyAoaW5pdEZyb21Db2xsZWN0aW9uID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0RGF0YWAgd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBkZXRlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICAgICAgbWV0YU1hcC5zZXQoZnVuYywgZGF0YSk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiAoK3N0YXJ0IHx8IDApO1xuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IGxlbmd0aCkgPyBsZW5ndGggOiAoK2VuZCB8fCAwKTtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gICAgICBzdGFydCA+Pj49IDA7XG5cbiAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb21lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiAhcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lXG4gICAgICogdGhlIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5T3JkZXJgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBnZXRDYWxsYmFjaygpLFxuICAgICAgICAgIGluZGV4ID0gLTE7XG5cbiAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHsgcmV0dXJuIGNhbGxiYWNrKGl0ZXJhdGVlKTsgfSk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHsgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTsgfSk7XG4gICAgICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgICAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zdW1gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIGFuZCBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU3VtKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgKz0gK2l0ZXJhdGVlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikgfHwgMDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBhbmQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGlzQ29tbW9uID0gaW5kZXhPZiA9PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBpc0xhcmdlID0gaXNDb21tb24gJiYgbGVuZ3RoID49IDIwMCxcbiAgICAgICAgICBzZWVuID0gaXNMYXJnZSA/IGNyZWF0ZUNhY2hlKCkgOiBudWxsLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoc2Vlbikge1xuICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNMYXJnZSA9IGZhbHNlO1xuICAgICAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgYXJyYXkpIDogdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIHZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleE9mKHNlZW4sIGNvbXB1dGVkLCAwKSA8IDApIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUgfHwgaXNMYXJnZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gICAgICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gICAgICogb2YgYHByb3BzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IG9iamVjdFtwcm9wc1tpbmRleF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kcm9wUmlnaHRXaGlsZWAsIGBfLmRyb3BXaGlsZWAsIGBfLnRha2VSaWdodFdoaWxlYCxcbiAgICAgKiBhbmQgYF8udGFrZVdoaWxlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEcm9wXSBTcGVjaWZ5IGRyb3BwaW5nIGVsZW1lbnRzIGluc3RlYWQgb2YgdGFraW5nIHRoZW0uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXaGlsZShhcnJheSwgcHJlZGljYXRlLCBpc0Ryb3AsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSAmJiBwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7fVxuICAgICAgcmV0dXJuIGlzRHJvcFxuICAgICAgICA/IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IDAgOiBpbmRleCksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiBsZW5ndGgpKVxuICAgICAgICA6IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IDApLCAoZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgd3JhcHBlclZhbHVlYCB3aGljaCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgICAgKiBwZXJmb3JtaW5nIGEgc2VxdWVuY2Ugb2YgYWN0aW9ucyBvbiB0aGUgdW53cmFwcGVkIGB2YWx1ZWAsIHdoZXJlIGVhY2hcbiAgICAgKiBzdWNjZXNzaXZlIGFjdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFjdGlvbnMgQWN0aW9ucyB0byBwZWZvcm0gdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV3JhcHBlclZhbHVlKHZhbHVlLCBhY3Rpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnZhbHVlKCk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhY3Rpb25zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbcmVzdWx0XSxcbiAgICAgICAgICAgIGFjdGlvbiA9IGFjdGlvbnNbaW5kZXhdO1xuXG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYWN0aW9uLmFyZ3MpO1xuICAgICAgICByZXN1bHQgPSBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvZiBgYXJyYXlgIHRvIGRldGVybWluZSB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmFyeUluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogbG93O1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09PSB2YWx1ZSAmJiBoaWdoIDw9IEhBTEZfTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDEsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gYXJyYXlbbWlkXTtcblxuICAgICAgICAgIGlmIChyZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKSkge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZ2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmluYXJ5SW5kZXhCeShhcnJheSwgdmFsdWUsIGlkZW50aXR5LCByZXRIaWdoZXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJpbmFyeUluZGV4YCBleGNlcHQgdGhhdCBpdCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yXG4gICAgICogYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluYXJ5SW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YWx1ZSA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICB2YWxJc05hTiA9IHZhbHVlICE9PSB2YWx1ZSxcbiAgICAgICAgICB2YWxJc1VuZGVmID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IGZsb29yKChsb3cgKyBoaWdoKSAvIDIpLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKSxcbiAgICAgICAgICAgIGlzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkO1xuXG4gICAgICAgIGlmICh2YWxJc05hTikge1xuICAgICAgICAgIHZhciBzZXRMb3cgPSBpc1JlZmxleGl2ZSB8fCByZXRIaWdoZXN0O1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzVW5kZWYpIHtcbiAgICAgICAgICBzZXRMb3cgPSBpc1JlZmxleGl2ZSAmJiAocmV0SGlnaGVzdCB8fCBjb21wdXRlZCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRMb3cgPSByZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0TG93KSB7XG4gICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlTWluKGhpZ2gsIE1BWF9BUlJBWV9JTkRFWCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQ2FsbGJhY2tgIHdoaWNoIG9ubHkgc3VwcG9ydHMgYHRoaXNgIGJpbmRpbmdcbiAgICAgKiBhbmQgc3BlY2lmeWluZyB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmRDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNBcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoYXJnQ291bnQpIHtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSA1OiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgb3RoZXIsIGtleSwgb2JqZWN0LCBzb3VyY2UpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGdpdmVuIGFycmF5IGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGJ1ZmZlclNsaWNlLmNhbGwoYnVmZmVyLCAwKTtcbiAgICB9XG4gICAgaWYgKCFidWZmZXJTbGljZSkge1xuICAgICAgLy8gUGhhbnRvbUpTIGhhcyBgQXJyYXlCdWZmZXJgIGFuZCBgVWludDhBcnJheWAgYnV0IG5vdCBgRmxvYXQ2NEFycmF5YC5cbiAgICAgIGJ1ZmZlckNsb25lID0gIShBcnJheUJ1ZmZlciAmJiBVaW50OEFycmF5KSA/IGNvbnN0YW50KG51bGwpIDogZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIHZhciBieXRlTGVuZ3RoID0gYnVmZmVyLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICBmbG9hdExlbmd0aCA9IEZsb2F0NjRBcnJheSA/IGZsb29yKGJ5dGVMZW5ndGggLyBGTE9BVDY0X0JZVEVTX1BFUl9FTEVNRU5UKSA6IDAsXG4gICAgICAgICAgICBvZmZzZXQgPSBmbG9hdExlbmd0aCAqIEZMT0FUNjRfQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgaWYgKGZsb2F0TGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZpZXcgPSBuZXcgRmxvYXQ2NEFycmF5KHJlc3VsdCwgMCwgZmxvYXRMZW5ndGgpO1xuICAgICAgICAgIHZpZXcuc2V0KG5ldyBGbG9hdDY0QXJyYXkoYnVmZmVyLCAwLCBmbG9hdExlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieXRlTGVuZ3RoICE9IG9mZnNldCkge1xuICAgICAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheShyZXN1bHQsIG9mZnNldCk7XG4gICAgICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cyxcbiAgICAgKiBwbGFjZWhvbGRlcnMsIGFuZCBwcm92aWRlZCBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMpIHtcbiAgICAgIHZhciBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkoYXJnc0xlbmd0aCArIGxlZnRMZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXgrK10gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFscywgaG9sZGVycykge1xuICAgICAgdmFyIGhvbGRlcnNJbmRleCA9IC0xLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmlnaHRJbmRleCA9IC0xLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGFyZ3NMZW5ndGggKyByaWdodExlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2FyZ3NJbmRleF0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICB9XG4gICAgICB2YXIgcGFkID0gYXJnc0luZGV4O1xuICAgICAgd2hpbGUgKCsrcmlnaHRJbmRleCA8IHJpZ2h0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtwYWQgKyByaWdodEluZGV4XSA9IHBhcnRpYWxzW3JpZ2h0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraG9sZGVyc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICByZXN1bHRbcGFkICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhZ2dyZWdhdGVzIGEgY29sbGVjdGlvbiwgY3JlYXRpbmcgYW4gYWNjdW11bGF0b3JcbiAgICAgKiBvYmplY3QgY29tcG9zZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxuICAgICAqIHRocm91Z2ggYW4gaXRlcmF0ZWUuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSBgXy5jb3VudEJ5YCwgYF8uZ3JvdXBCeWAsIGBfLmluZGV4QnlgLFxuICAgICAqIGFuZCBgXy5wYXJ0aXRpb25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBrZXlzIGFuZCB2YWx1ZXMgb2YgdGhlIGFjY3VtdWxhdG9yIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5pdGlhbGl6ZXJdIFRoZSBmdW5jdGlvbiB0byBpbml0aWFsaXplIHRoZSBhY2N1bXVsYXRvciBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlciwgaW5pdGlhbGl6ZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG4gICAgICAgIGl0ZXJhdGVlID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBzZXR0ZXIocmVzdWx0LCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFzc2lnbnMgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIGEgZ2l2ZW5cbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSBgXy5hc3NpZ25gLCBgXy5kZWZhdWx0c2AsIGFuZCBgXy5tZXJnZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gICAgICByZXR1cm4gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDIgJiYgc291cmNlc1tsZW5ndGggLSAyXSxcbiAgICAgICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiAmJiBzb3VyY2VzWzJdLFxuICAgICAgICAgICAgdGhpc0FyZyA9IGxlbmd0aCA+IDEgJiYgc291cmNlc1tsZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAodHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgNSk7XG4gICAgICAgICAgbGVuZ3RoIC09IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IHR5cGVvZiB0aGlzQXJnID09ICdmdW5jdGlvbicgPyB0aGlzQXJnIDogbnVsbDtcbiAgICAgICAgICBsZW5ndGggLT0gKGN1c3RvbWl6ZXIgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gbnVsbCA6IGN1c3RvbWl6ZXI7XG4gICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gZ2V0TGVuZ3RoKGNvbGxlY3Rpb24pIDogMDtcbiAgICAgICAgaWYgKCFpc0xlbmd0aChsZW5ndGgpKSB7XG4gICAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gdG9PYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgYF8uZm9ySW5gIG9yIGBfLmZvckluUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICAgICAgdmFyIGl0ZXJhYmxlID0gdG9PYmplY3Qob2JqZWN0KSxcbiAgICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgYW5kIGludm9rZXMgaXQgd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCaW5kV3JhcHBlcihmdW5jLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3JXcmFwcGVyKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgU2V0YCBjYWNoZSBvYmplY3QgdG8gb3B0aW1pemUgbGluZWFyIHNlYXJjaGVzIG9mIGxhcmdlIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgdGhlIG5ldyBjYWNoZSBvYmplY3QgaWYgYFNldGAgaXMgc3VwcG9ydGVkLCBlbHNlIGBudWxsYC5cbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlQ2FjaGUgPSAhKG5hdGl2ZUNyZWF0ZSAmJiBTZXQpID8gY29uc3RhbnQobnVsbCkgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgY29tcG91bmQgd29yZHMgb3V0IG9mIHRoZSB3b3JkcyBpbiBhXG4gICAgICogZ2l2ZW4gc3RyaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgYXJyYXkgPSB3b3JkcyhkZWJ1cnIoc3RyaW5nKSksXG4gICAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQgPSAnJztcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKHJlc3VsdCwgYXJyYXlbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3RvcldyYXBwZXIoQ3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gTWltaWMgdGhlIGNvbnN0cnVjdG9yJ3MgYHJldHVybmAgYmVoYXZpb3IuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMy4yLjIgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmbGFnIFRoZSBjdXJyeSBiaXQgZmxhZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXJyeShmbGFnKSB7XG4gICAgICBmdW5jdGlvbiBjdXJyeUZ1bmMoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChmdW5jLCBhcml0eSwgZ3VhcmQpKSB7XG4gICAgICAgICAgYXJpdHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwcGVyKGZ1bmMsIGZsYWcsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIGFyaXR5KTtcbiAgICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnlGdW5jLnBsYWNlaG9sZGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJ5RnVuYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8ubWF4YCBvciBgXy5taW5gIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgZXh0cmVtdW0gdmFsdWUgZnJvbSBhbiBhcnJheS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc01pbl0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIG1pbmltdW0sIGluc3RlYWQgb2YgdGhlIG1heGltdW0sXG4gICAgICogIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGV4dHJlbXVtIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4dHJlbXVtKGFycmF5RnVuYywgaXNNaW4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykpIHtcbiAgICAgICAgICBpdGVyYXRlZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmMgPSBnZXRDYWxsYmFjaygpLFxuICAgICAgICAgICAgbm9JdGVyYXRlZSA9IGl0ZXJhdGVlID09IG51bGw7XG5cbiAgICAgICAgaWYgKCEoZnVuYyA9PT0gYmFzZUNhbGxiYWNrICYmIG5vSXRlcmF0ZWUpKSB7XG4gICAgICAgICAgbm9JdGVyYXRlZSA9IGZhbHNlO1xuICAgICAgICAgIGl0ZXJhdGVlID0gZnVuYyhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vSXRlcmF0ZWUpIHtcbiAgICAgICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KGNvbGxlY3Rpb24pO1xuICAgICAgICAgIGlmICghaXNBcnIgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlID0gY2hhckF0Q2FsbGJhY2s7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheUZ1bmMoaXNBcnIgPyBjb2xsZWN0aW9uIDogdG9JdGVyYWJsZShjb2xsZWN0aW9uKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRyZW11bUJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBpc01pbik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gYmFzZUZpbmRJbmRleChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21SaWdodCk7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBjb2xsZWN0aW9uW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZUZpbmQoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZpbmRJbmRleGAgb3IgYF8uZmluZExhc3RJbmRleGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZEluZGV4KGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tUmlnaHQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmluZEtleWAgb3IgYF8uZmluZExhc3RLZXlgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvYmplY3RGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZEtleShvYmplY3RGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgcmV0dXJuIGJhc2VGaW5kKG9iamVjdCwgcHJlZGljYXRlLCBvYmplY3RGdW5jLCB0cnVlKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsb3cgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzWzBdOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB3cmFwcGVyLFxuICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IDAsXG4gICAgICAgICAgICBmdW5jcyA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2xlZnRJbmRleCsrXSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGZ1bmNOYW1lID0gd3JhcHBlciA/ICcnIDogZ2V0RnVuY05hbWUoZnVuYyk7XG4gICAgICAgICAgd3JhcHBlciA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IG5ldyBMb2Rhc2hXcmFwcGVyKFtdKSA6IHdyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSB3cmFwcGVyID8gLTEgOiBsZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgICBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpO1xuXG4gICAgICAgICAgdmFyIGRhdGEgPSBmdW5jTmFtZSA9PSAnd3JhcHBlcicgPyBnZXREYXRhKGZ1bmMpIDogbnVsbDtcbiAgICAgICAgICBpZiAoZGF0YSAmJiBpc0xhemlhYmxlKGRhdGFbMF0pKSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSAoZnVuYy5sZW5ndGggPT0gMSAmJiBpc0xhemlhYmxlKGZ1bmMpKSA/IHdyYXBwZXJbZnVuY05hbWVdKCkgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICBpZiAod3JhcHBlciAmJiBhcmdzLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KGFyZ3NbMF0pLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jc1tpbmRleF0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLmZvckVhY2hgIG9yIGBfLmZvckVhY2hSaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIGFycmF5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGVhY2ggZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChhcnJheUZ1bmMsIGVhY2hGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnID09PSB1bmRlZmluZWQgJiYgaXNBcnJheShjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGFycmF5RnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSlcbiAgICAgICAgICA6IGVhY2hGdW5jKGNvbGxlY3Rpb24sIGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMykpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLmZvckluYCBvciBgXy5mb3JJblJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JqZWN0RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvckluKG9iamVjdEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmF0ZWUgIT0gJ2Z1bmN0aW9uJyB8fCB0aGlzQXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpdGVyYXRlZSA9IGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdEZ1bmMob2JqZWN0LCBpdGVyYXRlZSwga2V5c0luKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5mb3JPd25gIG9yIGBfLmZvck93blJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JqZWN0RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvck93bihvYmplY3RGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdGVlICE9ICdmdW5jdGlvbicgfHwgdGhpc0FyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaXRlcmF0ZWUgPSBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3RGdW5jKG9iamVjdCwgaXRlcmF0ZWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gZm9yIGBfLnBhZExlZnRgIG9yIGBfLnBhZFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IHBhZGRpbmcgZnJvbSB0aGUgcmlnaHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZERpcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgIHJldHVybiBzdHJpbmcgJiYgKChmcm9tUmlnaHQgPyBzdHJpbmcgOiAnJykgKyBjcmVhdGVQYWRkaW5nKHN0cmluZywgbGVuZ3RoLCBjaGFycykgKyAoZnJvbVJpZ2h0ID8gJycgOiBzdHJpbmcpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnBhcnRpYWxgIG9yIGBfLnBhcnRpYWxSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxhZyBUaGUgcGFydGlhbCBiaXQgZmxhZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWwoZmxhZykge1xuICAgICAgdmFyIHBhcnRpYWxGdW5jID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIHBhcnRpYWxGdW5jLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgZmxhZywgbnVsbCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFydGlhbEZ1bmM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5yZWR1Y2VgIG9yIGBfLnJlZHVjZVJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXJyYXlGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYW4gYXJyYXkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZWFjaCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWR1Y2UoYXJyYXlGdW5jLCBlYWNoRnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgICB2YXIgaW5pdEZyb21BcnJheSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgPT09IHVuZGVmaW5lZCAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKVxuICAgICAgICAgID8gYXJyYXlGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEZyb21BcnJheSlcbiAgICAgICAgICA6IGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEZyb21BcnJheSwgZWFjaEZ1bmMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgYW5kIGludm9rZXMgaXQgd2l0aCBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byByZWZlcmVuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcHBlcmAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzUmlnaHRdIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNSaWdodF0gVGhlIGBwYXJ0aWFsc1JpZ2h0YCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUh5YnJpZFdyYXBwZXIoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNBcnkgPSBiaXRtYXNrICYgQVJZX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kID0gYml0bWFzayAmIEJJTkRfRkxBRyxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgQklORF9LRVlfRkxBRyxcbiAgICAgICAgICBpc0N1cnJ5ID0gYml0bWFzayAmIENVUlJZX0ZMQUcsXG4gICAgICAgICAgaXNDdXJyeUJvdW5kID0gYml0bWFzayAmIENVUlJZX0JPVU5EX0ZMQUcsXG4gICAgICAgICAgaXNDdXJyeVJpZ2h0ID0gYml0bWFzayAmIENVUlJZX1JJR0hUX0ZMQUc7XG5cbiAgICAgIHZhciBDdG9yID0gIWlzQmluZEtleSAmJiBjcmVhdGVDdG9yV3JhcHBlcihmdW5jKSxcbiAgICAgICAgICBrZXkgPSBmdW5jO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICAvLyBBdm9pZCBgYXJndW1lbnRzYCBvYmplY3QgdXNlIGRpc3F1YWxpZnlpbmcgb3B0aW1pemF0aW9ucyBieVxuICAgICAgICAvLyBjb252ZXJ0aW5nIGl0IHRvIGFuIGFycmF5IGJlZm9yZSBwcm92aWRpbmcgaXQgdG8gb3RoZXIgZnVuY3Rpb25zLlxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzKSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHNSaWdodCkge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ3VycnkgfHwgaXNDdXJyeVJpZ2h0KSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gd3JhcHBlci5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgYXJnc0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG5cbiAgICAgICAgICBsZW5ndGggLT0gYXJnc0hvbGRlcnMubGVuZ3RoO1xuICAgICAgICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgICAgdmFyIG5ld0FyZ1BvcyA9IGFyZ1BvcyA/IGFycmF5Q29weShhcmdQb3MpIDogbnVsbCxcbiAgICAgICAgICAgICAgICBuZXdBcml0eSA9IG5hdGl2ZU1heChhcml0eSAtIGxlbmd0aCwgMCksXG4gICAgICAgICAgICAgICAgbmV3c0hvbGRlcnMgPSBpc0N1cnJ5ID8gYXJnc0hvbGRlcnMgOiBudWxsLFxuICAgICAgICAgICAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyBudWxsIDogYXJnc0hvbGRlcnMsXG4gICAgICAgICAgICAgICAgbmV3UGFydGlhbHMgPSBpc0N1cnJ5ID8gYXJncyA6IG51bGwsXG4gICAgICAgICAgICAgICAgbmV3UGFydGlhbHNSaWdodCA9IGlzQ3VycnkgPyBudWxsIDogYXJncztcblxuICAgICAgICAgICAgYml0bWFzayB8PSAoaXNDdXJyeSA/IFBBUlRJQUxfRkxBRyA6IFBBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICAgICAgICBiaXRtYXNrICY9IH4oaXNDdXJyeSA/IFBBUlRJQUxfUklHSFRfRkxBRyA6IFBBUlRJQUxfRkxBRyk7XG5cbiAgICAgICAgICAgIGlmICghaXNDdXJyeUJvdW5kKSB7XG4gICAgICAgICAgICAgIGJpdG1hc2sgJj0gfihCSU5EX0ZMQUcgfCBCSU5EX0tFWV9GTEFHKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdEYXRhID0gW2Z1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIG5ld1BhcnRpYWxzLCBuZXdzSG9sZGVycywgbmV3UGFydGlhbHNSaWdodCwgbmV3SG9sZGVyc1JpZ2h0LCBuZXdBcmdQb3MsIGFyeSwgbmV3QXJpdHldLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZFdyYXBwZXIuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcblxuICAgICAgICAgICAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcbiAgICAgICAgICAgICAgc2V0RGF0YShyZXN1bHQsIG5ld0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcztcbiAgICAgICAgaWYgKGlzQmluZEtleSkge1xuICAgICAgICAgIGZ1bmMgPSB0aGlzQmluZGluZ1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdQb3MpIHtcbiAgICAgICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FyeSAmJiBhcnkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gKEN0b3IgfHwgY3JlYXRlQ3RvcldyYXBwZXIoZnVuYykpIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBhZGRpbmcgcmVxdWlyZWQgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIHRoZSBnaXZlbiBgbGVuZ3RoYC5cbiAgICAgKiBUaGUgYGNoYXJzYCBzdHJpbmcgaXMgdHJ1bmNhdGVkIGlmIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBleGNlZWRzIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY3JlYXRlIHBhZGRpbmcgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkIGZvciBgc3RyaW5nYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWRkaW5nKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBsZW5ndGggPSArbGVuZ3RoO1xuXG4gICAgICBpZiAoc3RyTGVuZ3RoID49IGxlbmd0aCB8fCAhbmF0aXZlSXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgcGFkTGVuZ3RoID0gbGVuZ3RoIC0gc3RyTGVuZ3RoO1xuICAgICAgY2hhcnMgPSBjaGFycyA9PSBudWxsID8gJyAnIDogKGNoYXJzICsgJycpO1xuICAgICAgcmV0dXJuIHJlcGVhdChjaGFycywgY2VpbChwYWRMZW5ndGggLyBjaGFycy5sZW5ndGgpKS5zbGljZSgwLCBwYWRMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCBhbmQgaW52b2tlcyBpdCB3aXRoIHRoZSBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogdGhlIHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcHBlcmAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsV3JhcHBlcihmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBCSU5EX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3JXcmFwcGVyKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICAvLyBBdm9pZCBgYXJndW1lbnRzYCBvYmplY3QgdXNlIGRpc3F1YWxpZnlpbmcgb3B0aW1pemF0aW9ucyBieVxuICAgICAgICAvLyBjb252ZXJ0aW5nIGl0IHRvIGFuIGFycmF5IGJlZm9yZSBwcm92aWRpbmcgaXQgYGZ1bmNgLlxuICAgICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShhcmdzTGVuZ3RoICsgbGVmdExlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnNvcnRlZEluZGV4YCBvciBgXy5zb3J0ZWRMYXN0SW5kZXhgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW5kZXggZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlU29ydGVkSW5kZXgocmV0SGlnaGVzdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSk7XG4gICAgICAgIHJldHVybiAoZnVuYyA9PT0gYmFzZUNhbGxiYWNrICYmIGl0ZXJhdGVlID09IG51bGwpXG4gICAgICAgICAgPyBiaW5hcnlJbmRleChhcnJheSwgdmFsdWUsIHJldEhpZ2hlc3QpXG4gICAgICAgICAgOiBiaW5hcnlJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZnVuYyhpdGVyYXRlZSwgdGhpc0FyZywgMSksIHJldEhpZ2hlc3QpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYCB3aXRoIG9wdGlvbmFsXG4gICAgICogYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBmbGFncy5cbiAgICAgKiAgVGhlIGJpdG1hc2sgbWF5IGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZmxhZ3M6XG4gICAgICogICAgIDEgLSBgXy5iaW5kYFxuICAgICAqICAgICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgICAgNCAtIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBvZiBhIGJvdW5kIGZ1bmN0aW9uXG4gICAgICogICAgIDggLSBgXy5jdXJyeWBcbiAgICAgKiAgICAxNiAtIGBfLmN1cnJ5UmlnaHRgXG4gICAgICogICAgMzIgLSBgXy5wYXJ0aWFsYFxuICAgICAqICAgIDY0IC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqICAgMTI4IC0gYF8ucmVhcmdgXG4gICAgICogICAyNTYgLSBgXy5hcnlgXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcHBlcihmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIEJJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4oUEFSVElBTF9GTEFHIHwgUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCAtPSAoaG9sZGVycyA/IGhvbGRlcnMubGVuZ3RoIDogMCk7XG4gICAgICBpZiAoYml0bWFzayAmIFBBUlRJQUxfUklHSFRfRkxBRykge1xuICAgICAgICB2YXIgcGFydGlhbHNSaWdodCA9IHBhcnRpYWxzLFxuICAgICAgICAgICAgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcblxuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBpc0JpbmRLZXkgPyBudWxsIDogZ2V0RGF0YShmdW5jKSxcbiAgICAgICAgICBuZXdEYXRhID0gW2Z1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eV07XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcbiAgICAgICAgYml0bWFzayA9IG5ld0RhdGFbMV07XG4gICAgICAgIGFyaXR5ID0gbmV3RGF0YVs5XTtcbiAgICAgIH1cbiAgICAgIG5ld0RhdGFbOV0gPSBhcml0eSA9PSBudWxsXG4gICAgICAgID8gKGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aClcbiAgICAgICAgOiAobmF0aXZlTWF4KGFyaXR5IC0gbGVuZ3RoLCAwKSB8fCAwKTtcblxuICAgICAgaWYgKGJpdG1hc2sgPT0gQklORF9GTEFHKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVCaW5kV3JhcHBlcihuZXdEYXRhWzBdLCBuZXdEYXRhWzJdKTtcbiAgICAgIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKEJJTkRfRkxBRyB8IFBBUlRJQUxfRkxBRykpICYmICFuZXdEYXRhWzRdLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVQYXJ0aWFsV3JhcHBlci5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkV3JhcHBlci5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gICAgICByZXR1cm4gc2V0dGVyKHJlc3VsdCwgbmV3RGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyBhcnJheXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcblxuICAgICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc0xvb3NlICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChyZXN1bHQgJiYgKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgcmVzdWx0ID0gaXNMb29zZVxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgpXG4gICAgICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICBpZiAoaXNMb29zZSkge1xuICAgICAgICAgICAgdmFyIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKG90aEluZGV4LS0pIHtcbiAgICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltvdGhJbmRleF07XG4gICAgICAgICAgICAgIHJlc3VsdCA9IChhcnJWYWx1ZSAmJiBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUpIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChhcnJWYWx1ZSAmJiBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUpIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gICAgICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZykge1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAgICAgLy8gdG8gYDFgIG9yIGAwYCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXMgbm90IGVxdWFsLlxuICAgICAgICAgIHJldHVybiArb2JqZWN0ID09ICtvdGhlcjtcblxuICAgICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgICAgLy8gVHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsLlxuICAgICAgICAgIHJldHVybiAob2JqZWN0ICE9ICtvYmplY3QpXG4gICAgICAgICAgICA/IG90aGVyICE9ICtvdGhlclxuICAgICAgICAgICAgLy8gQnV0LCB0cmVhdCBgLTBgIHZzLiBgKzBgIGFzIG5vdCBlcXVhbC5cbiAgICAgICAgICAgIDogKG9iamVjdCA9PSAwID8gKCgxIC8gb2JqZWN0KSA9PSAoMSAvIG90aGVyKSkgOiBvYmplY3QgPT0gK290aGVyKTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncyBwcmltaXRpdmVzIGFuZCBzdHJpbmdcbiAgICAgICAgICAvLyBvYmplY3RzIGFzIGVxdWFsLiBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTAuNi40IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQV0gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQl0gVHJhY2tzIHRyYXZlcnNlZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciBvYmpQcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICAgICAgb3RoUHJvcHMgPSBrZXlzKG90aGVyKSxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc0xvb3NlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBza2lwQ3RvciA9IGlzTG9vc2UsXG4gICAgICAgICAgaW5kZXggPSAtMTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XSxcbiAgICAgICAgICAgIHJlc3VsdCA9IGlzTG9vc2UgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpO1xuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpc0xvb3NlXG4gICAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSlcbiAgICAgICAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICAgIHJlc3VsdCA9IChvYmpWYWx1ZSAmJiBvYmpWYWx1ZSA9PT0gb3RoVmFsdWUpIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICAgICAgfVxuICAgICAgaWYgKCFza2lwQ3Rvcikge1xuICAgICAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICAgICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGV4dHJlbXVtIHZhbHVlIG9mIGBjb2xsZWN0aW9uYCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvciBlYWNoIHZhbHVlXG4gICAgICogaW4gYGNvbGxlY3Rpb25gIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlIGlzIHJhbmtlZC5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTWluXSBTcGVjaWZ5IHJldHVybmluZyB0aGUgbWluaW11bSwgaW5zdGVhZCBvZiB0aGVcbiAgICAgKiAgbWF4aW11bSwgZXh0cmVtdW0gdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4dHJlbXVtQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGlzTWluKSB7XG4gICAgICB2YXIgZXhWYWx1ZSA9IGlzTWluID8gUE9TSVRJVkVfSU5GSU5JVFkgOiBORUdBVElWRV9JTkZJTklUWSxcbiAgICAgICAgICBjb21wdXRlZCA9IGV4VmFsdWUsXG4gICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZWQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIGlmICgoaXNNaW4gPyAoY3VycmVudCA8IGNvbXB1dGVkKSA6IChjdXJyZW50ID4gY29tcHV0ZWQpKSB8fFxuICAgICAgICAgICAgKGN1cnJlbnQgPT09IGV4VmFsdWUgJiYgY3VycmVudCA9PT0gcmVzdWx0KSkge1xuICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiY2FsbGJhY2tcIiBmdW5jdGlvbi4gSWYgdGhlIGBfLmNhbGxiYWNrYCBtZXRob2QgaXNcbiAgICAgKiBjdXN0b21pemVkIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnNcbiAgICAgKiB0aGUgYGJhc2VDYWxsYmFja2AgZnVuY3Rpb24uIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdGhlIGNob3NlbiBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGVtIGFuZCBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldENhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoLmNhbGxiYWNrIHx8IGNhbGxiYWNrO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSBjYWxsYmFjayA/IGJhc2VDYWxsYmFjayA6IHJlc3VsdDtcbiAgICAgIHJldHVybiBhcmdDb3VudCA/IHJlc3VsdChmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0RGF0YSA9ICFtZXRhTWFwID8gbm9vcCA6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHJldHVybiBtZXRhTWFwLmdldChmdW5jKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmFtZSBvZiBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWUuXG4gICAgICovXG4gICAgdmFyIGdldEZ1bmNOYW1lID0gKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFzdXBwb3J0LmZ1bmNOYW1lcykge1xuICAgICAgICByZXR1cm4gY29uc3RhbnQoJycpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnN0YW50Lm5hbWUgPT0gJ2NvbnN0YW50Jykge1xuICAgICAgICByZXR1cm4gYmFzZVByb3BlcnR5KCduYW1lJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZnVuYykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5uYW1lLFxuICAgICAgICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sXG4gICAgICAgICAgICAgIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcblxuICAgICAgICAgIGlmIChvdGhlckZ1bmMgPT0gbnVsbCB8fCBvdGhlckZ1bmMgPT0gZnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiaW5kZXhPZlwiIGZ1bmN0aW9uLiBJZiB0aGUgYF8uaW5kZXhPZmAgbWV0aG9kIGlzXG4gICAgICogY3VzdG9taXplZCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zXG4gICAgICogdGhlIGBiYXNlSW5kZXhPZmAgZnVuY3Rpb24uIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdGhlIGNob3NlbiBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGVtIGFuZCBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258bnVtYmVyfSBSZXR1cm5zIHRoZSBjaG9zZW4gZnVuY3Rpb24gb3IgaXRzIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJbmRleE9mKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoLmluZGV4T2YgfHwgaW5kZXhPZjtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gaW5kZXhPZiA/IGJhc2VJbmRleE9mIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24gPyByZXN1bHQoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGEgW0pJVCBidWddKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI3OTIpXG4gICAgICogaW4gU2FmYXJpIG9uIGlPUyA4LjEgQVJNNjQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgXCJsZW5ndGhcIiB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciBnZXRTeW1ib2xzID0gIWdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbnN0YW50KFtdKSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyh0b09iamVjdChvYmplY3QpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmlldywgYXBwbHlpbmcgYW55IGB0cmFuc2Zvcm1zYCB0byB0aGUgYHN0YXJ0YCBhbmQgYGVuZGAgcG9zaXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdHJhbnNmb3Jtc10gVGhlIHRyYW5zZm9ybWF0aW9ucyB0byBhcHBseSB0byB0aGUgdmlldy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgc3RhcnRgIGFuZCBgZW5kYFxuICAgICAqICBwb3NpdGlvbnMgb2YgdGhlIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VmlldyhzdGFydCwgZW5kLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB0cmFuc2Zvcm1zID8gdHJhbnNmb3Jtcy5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRyYW5zZm9ybXNbaW5kZXhdLFxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlJzogICAgICBlbmQgPSBuYXRpdmVNaW4oZW5kLCBzdGFydCArIHNpemUpOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgLy8gQWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBpZiAoISh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkge1xuICAgICAgICBDdG9yID0gT2JqZWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgcmV0dXJuIGJ1ZmZlckNsb25lKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKGlzRGVlcCA/IGJ1ZmZlckNsb25lKGJ1ZmZlcikgOiBidWZmZXIsIG9iamVjdC5ieXRlT2Zmc2V0LCBvYmplY3QubGVuZ3RoKTtcblxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yKG9iamVjdC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhvYmplY3QpKTtcbiAgICAgICAgICByZXN1bHQubGFzdEluZGV4ID0gb2JqZWN0Lmxhc3RJbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvbiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludm9rZVBhdGgob2JqZWN0LCBwYXRoLCBhcmdzKSB7XG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgIWlzS2V5KHBhdGgsIG9iamVjdCkpIHtcbiAgICAgICAgcGF0aCA9IHRvUGF0aChwYXRoKTtcbiAgICAgICAgb2JqZWN0ID0gcGF0aC5sZW5ndGggPT0gMSA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbiAgICAgICAgcGF0aCA9IGxhc3QocGF0aCk7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3BhdGhdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGZ1bmMuYXBwbHkob2JqZWN0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgICAgIHJldHVybiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChvYmplY3QpLFxuICAgICAgICAgICAgcHJlcmVxID0gaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGluZGV4LCBsZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlcmVxID0gdHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3Q7XG4gICAgICB9XG4gICAgICBpZiAocHJlcmVxKSB7XG4gICAgICAgIHZhciBvdGhlciA9IG9iamVjdFtpbmRleF07XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAodmFsdWUgPT09IG90aGVyKSA6IChvdGhlciAhPT0gb3RoZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGlmICgodHlwZSA9PSAnc3RyaW5nJyAmJiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpKSB8fCB0eXBlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdCB8fCAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gdG9PYmplY3Qob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcbiAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpO1xuICAgICAgcmV0dXJuICEhZnVuY05hbWUgJiYgZnVuYyA9PT0gbG9kYXNoW2Z1bmNOYW1lXSAmJiBmdW5jTmFtZSBpbiBMYXp5V3JhcHBlci5wcm90b3R5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gICAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICh2YWx1ZSA9PT0gMCA/ICgoMSAvIHZhbHVlKSA+IDApIDogIWlzT2JqZWN0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHJlcXVpcmVkIHRvIGludm9rZSBhIGZ1bmN0aW9uLlxuICAgICAqIFRoaXMgaXMgcG9zc2libGUgYmVjYXVzZSBtZXRob2RzIGxpa2UgYF8uYmluZGAsIGBfLmN1cnJ5YCwgYW5kIGBfLnBhcnRpYWxgXG4gICAgICogbWF5IGJlIGFwcGxpZWQgcmVnYXJkbGVzcyBvZiBleGVjdXRpb24gb3JkZXIuIE1ldGhvZHMgbGlrZSBgXy5hcnlgIGFuZCBgXy5yZWFyZ2BcbiAgICAgKiBhdWdtZW50IGZ1bmN0aW9uIGFyZ3VtZW50cywgbWFraW5nIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFyZSBleGVjdXRlZCBpbXBvcnRhbnQsXG4gICAgICogcHJldmVudGluZyB0aGUgbWVyZ2luZyBvZiBtZXRhZGF0YS4gSG93ZXZlciwgd2UgbWFrZSBhbiBleGNlcHRpb24gZm9yIGEgc2FmZVxuICAgICAqIGNvbW1vbiBjYXNlIHdoZXJlIGN1cnJpZWQgZnVuY3Rpb25zIGhhdmUgYF8uYXJ5YCBhbmQgb3IgYF8ucmVhcmdgIGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgVGhlIGRlc3RpbmF0aW9uIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgc291cmNlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGF0YWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VEYXRhKGRhdGEsIHNvdXJjZSkge1xuICAgICAgdmFyIGJpdG1hc2sgPSBkYXRhWzFdLFxuICAgICAgICAgIHNyY0JpdG1hc2sgPSBzb3VyY2VbMV0sXG4gICAgICAgICAgbmV3Qml0bWFzayA9IGJpdG1hc2sgfCBzcmNCaXRtYXNrLFxuICAgICAgICAgIGlzQ29tbW9uID0gbmV3Qml0bWFzayA8IEFSWV9GTEFHO1xuXG4gICAgICB2YXIgaXNDb21ibyA9XG4gICAgICAgIChzcmNCaXRtYXNrID09IEFSWV9GTEFHICYmIGJpdG1hc2sgPT0gQ1VSUllfRkxBRykgfHxcbiAgICAgICAgKHNyY0JpdG1hc2sgPT0gQVJZX0ZMQUcgJiYgYml0bWFzayA9PSBSRUFSR19GTEFHICYmIGRhdGFbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkgfHxcbiAgICAgICAgKHNyY0JpdG1hc2sgPT0gKEFSWV9GTEFHIHwgUkVBUkdfRkxBRykgJiYgYml0bWFzayA9PSBDVVJSWV9GTEFHKTtcblxuICAgICAgLy8gRXhpdCBlYXJseSBpZiBtZXRhZGF0YSBjYW4ndCBiZSBtZXJnZWQuXG4gICAgICBpZiAoIShpc0NvbW1vbiB8fCBpc0NvbWJvKSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYHRoaXNBcmdgIGlmIGF2YWlsYWJsZS5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgQklORF9GTEFHKSB7XG4gICAgICAgIGRhdGFbMl0gPSBzb3VyY2VbMl07XG4gICAgICAgIC8vIFNldCB3aGVuIGN1cnJ5aW5nIGEgYm91bmQgZnVuY3Rpb24uXG4gICAgICAgIG5ld0JpdG1hc2sgfD0gKGJpdG1hc2sgJiBCSU5EX0ZMQUcpID8gMCA6IENVUlJZX0JPVU5EX0ZMQUc7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxuICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XG4gICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IGFycmF5Q29weSh2YWx1ZSk7XG4gICAgICAgIGRhdGFbNF0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbM10sIFBMQUNFSE9MREVSKSA6IGFycmF5Q29weShzb3VyY2VbNF0pO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50cy5cbiAgICAgIHZhbHVlID0gc291cmNlWzVdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHBhcnRpYWxzID0gZGF0YVs1XTtcbiAgICAgICAgZGF0YVs1XSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3NSaWdodChwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs2XSkgOiBhcnJheUNvcHkodmFsdWUpO1xuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBhcnJheUNvcHkoc291cmNlWzZdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbN107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZGF0YVs3XSA9IGFycmF5Q29weSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcnlgIGlmIGl0J3Mgc21hbGxlci5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgQVJZX0ZMQUcpIHtcbiAgICAgICAgZGF0YVs4XSA9IGRhdGFbOF0gPT0gbnVsbCA/IHNvdXJjZVs4XSA6IG5hdGl2ZU1pbihkYXRhWzhdLCBzb3VyY2VbOF0pO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJpdHlgIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG4gICAgICBpZiAoZGF0YVs5XSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGFbOV0gPSBzb3VyY2VbOV07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBmdW5jYCBhbmQgbWVyZ2UgYml0bWFza3MuXG4gICAgICBkYXRhWzBdID0gc291cmNlWzBdO1xuICAgICAgZGF0YVsxXSA9IG5ld0JpdG1hc2s7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5waWNrYCB0aGF0IHBpY2tzIGBvYmplY3RgIHByb3BlcnRpZXMgc3BlY2lmaWVkXG4gICAgICogYnkgYHByb3BzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2tCeUFycmF5KG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIG9iamVjdCA9IHRvT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5waWNrYCB0aGF0IHBpY2tzIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWBcbiAgICAgKiByZXR1cm5zIHRydXRoeSBmb3IuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrQnlDYWxsYmFjayhvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgYmFzZUZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW9yZGVyIGBhcnJheWAgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXhlcyB3aGVyZSB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBmaXJzdCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgZmlyc3QgZWxlbWVudCwgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgc2Vjb25kIGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVvcmRlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcnJheSBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlb3JkZXIoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGluZGV4ZXMubGVuZ3RoLCBhcnJMZW5ndGgpLFxuICAgICAgICAgIG9sZEFycmF5ID0gYXJyYXlDb3B5KGFycmF5KTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGlzSW5kZXgoaW5kZXgsIGFyckxlbmd0aCkgPyBvbGRBcnJheVtpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIHRoaXMgZnVuY3Rpb24gYmVjb21lcyBob3QsIGkuZS4gaXMgaW52b2tlZCBhIGxvdCBpbiBhIHNob3J0XG4gICAgICogcGVyaW9kIG9mIHRpbWUsIGl0IHdpbGwgdHJpcCBpdHMgYnJlYWtlciBhbmQgdHJhbnNpdGlvbiB0byBhbiBpZGVudGl0eSBmdW5jdGlvblxuICAgICAqIHRvIGF2b2lkIGdhcmJhZ2UgY29sbGVjdGlvbiBwYXVzZXMgaW4gVjguIFNlZSBbVjggaXNzdWUgMjA3MF0oaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXREYXRhID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHN0YW1wID0gbm93KCksXG4gICAgICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVNldERhdGEoa2V5LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzUGxhaW5PYmplY3RgIHdoaWNoIGNoZWNrcyBpZiBgdmFsdWVgXG4gICAgICogaXMgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIGhhcyBhIGBbW1Byb3RvdHlwZV1dYFxuICAgICAqIG9mIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIEN0b3IsXG4gICAgICAgICAgc3VwcG9ydCA9IGxvZGFzaC5zdXBwb3J0O1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGZvciBub24gYE9iamVjdGAgb2JqZWN0cy5cbiAgICAgIGlmICghKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gb2JqZWN0VGFnKSB8fFxuICAgICAgICAgICghaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NvbnN0cnVjdG9yJykgJiZcbiAgICAgICAgICAgIChDdG9yID0gdmFsdWUuY29uc3RydWN0b3IsIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgIShDdG9yIGluc3RhbmNlb2YgQ3RvcikpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBJRSA8IDkgaXRlcmF0ZXMgaW5oZXJpdGVkIHByb3BlcnRpZXMgYmVmb3JlIG93biBwcm9wZXJ0aWVzLiBJZiB0aGUgZmlyc3RcbiAgICAgIC8vIGl0ZXJhdGVkIHByb3BlcnR5IGlzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWRcbiAgICAgIC8vIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICAvLyBJbiBtb3N0IGVudmlyb25tZW50cyBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcyBhcmUgaXRlcmF0ZWQgYmVmb3JlXG4gICAgICAvLyBpdHMgaW5oZXJpdGVkIHByb3BlcnRpZXMuIElmIHRoZSBsYXN0IGl0ZXJhdGVkIHByb3BlcnR5IGlzIGFuIG9iamVjdCdzXG4gICAgICAvLyBvd24gcHJvcGVydHkgdGhlbiB0aGVyZSBhcmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgIGJhc2VGb3JJbih2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mIHRoZVxuICAgICAqIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGltS2V5cyhvYmplY3QpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXNJbihvYmplY3QpLFxuICAgICAgICAgIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzTGVuZ3RoICYmIG9iamVjdC5sZW5ndGgsXG4gICAgICAgICAgc3VwcG9ydCA9IGxvZGFzaC5zdXBwb3J0O1xuXG4gICAgICB2YXIgYWxsb3dJbmRleGVzID0gbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCAoc3VwcG9ydC5ub25FbnVtQXJncyAmJiBpc0FyZ3VtZW50cyhvYmplY3QpKSk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIGlmICgoYWxsb3dJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS1saWtlIG9iamVjdCBpZiBpdCBpcyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSXRlcmFibGUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8gdmFsdWUgOiBPYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gb2JqZWN0IGlmIGl0IGlzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8gdmFsdWUgOiBPYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gcHJvcGVydHkgcGF0aCBhcnJheSBpZiBpdCBpcyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BhdGgodmFsdWUpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBiYXNlVG9TdHJpbmcodmFsdWUpLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgICAgICByZXN1bHQucHVzaChxdW90ZSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB3cmFwcGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHdyYXBwZXIgVGhlIHdyYXBwZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNsb25lKHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiB3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXJcbiAgICAgICAgPyB3cmFwcGVyLmNsb25lKClcbiAgICAgICAgOiBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVyLl9fd3JhcHBlZF9fLCB3cmFwcGVyLl9fY2hhaW5fXywgYXJyYXlDb3B5KHdyYXBwZXIuX19hY3Rpb25zX18pKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gZ3JvdXBzIHRoZSBsZW5ndGggb2YgYHNpemVgLlxuICAgICAqIElmIGBjb2xsZWN0aW9uYCBjYW4ndCBiZSBzcGxpdCBldmVubHksIHRoZSBmaW5hbCBjaHVuayB3aWxsIGJlIHRoZSByZW1haW5pbmdcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXSBUaGUgbGVuZ3RoIG9mIGVhY2ggY2h1bmsuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgY29udGFpbmluZyBjaHVua3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDIpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbJ2MnLCAnZCddXVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMyk7XG4gICAgICogLy8gPT4gW1snYScsICdiJywgJ2MnXSwgWydkJ11dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc2l6ZSwgZ3VhcmQpIDogc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IG5hdGl2ZU1heCgrc2l6ZSB8fCAxLCAxKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc0luZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkoY2VpbChsZW5ndGggLyBzaXplKSk7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSBiYXNlU2xpY2UoYXJyYXksIGluZGV4LCAoaW5kZXggKz0gc2l6ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGZhbHNleS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBhcnJheXMgdXNpbmdcbiAgICAgKiBgU2FtZVZhbHVlWmVyb2AgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGNvbXBhcmlzb25zIGFyZSBsaWtlIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgZS5nLiBgPT09YCwgZXhjZXB0IHRoYXRcbiAgICAgKiBgTmFOYCBtYXRjaGVzIGBOYU5gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIGFycmF5cyBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZShbMSwgMiwgM10sIFs0LCAyXSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2UgPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIChpc0FycmF5KGFycmF5KSB8fCBpc0FyZ3VtZW50cyhhcnJheSkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgZmFsc2UsIHRydWUpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH1cbiAgICAgIG4gPSBsZW5ndGggLSAoK24gfHwgMCk7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBtYXRjaCB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gPiAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyksIHRydWUsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BXaGlsZShbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuIDwgMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZHJvcFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5kcm9wV2hpbGUodXNlcnMsICdhY3RpdmUnKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BXaGlsZShhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyksIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbHMgZWxlbWVudHMgb2YgYGFycmF5YCB3aXRoIGB2YWx1ZWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90XG4gICAgICogaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8uZmlsbChhcnJheSwgJ2EnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2EnLCAnYSddXG4gICAgICpcbiAgICAgKiBfLmZpbGwoQXJyYXkoMyksIDIpO1xuICAgICAqIC8vID0+IFsyLCAyLCAyXVxuICAgICAqXG4gICAgICogXy5maWxsKFs0LCA2LCA4XSwgJyonLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBbNCwgJyonLCA4XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICYmIHR5cGVvZiBzdGFydCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgdmFsdWUsIHN0YXJ0KSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIudXNlciA9PSAnYmFybmV5JztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIHZhciBmaW5kSW5kZXggPSBjcmVhdGVGaW5kSW5kZXgoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIudXNlciA9PSAncGViYmxlcyc7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgdmFyIGZpbmRMYXN0SW5kZXggPSBjcmVhdGVGaW5kSW5kZXgodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaGVhZFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5maXJzdChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlyc3QoYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnJheSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5LiBJZiBgaXNEZWVwYCBpcyBgdHJ1ZWAgdGhlIGFycmF5IGlzIHJlY3Vyc2l2ZWx5XG4gICAgICogZmxhdHRlbmVkLCBvdGhlcndpc2UgaXQgaXMgb25seSBmbGF0dGVuZWQgYSBzaW5nbGUgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCAzLCBbNF1dXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGBpc0RlZXBgXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMiwgMywgWzRdXV0sIHRydWUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXksIGlzRGVlcCwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIGlzRGVlcCwgZ3VhcmQpKSB7XG4gICAgICAgIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCBpc0RlZXApIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbnMgYSBuZXN0ZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVjdXJzaXZlbHkgZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlZXAoWzEsIFsyLCAzLCBbNF1dXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlZXAoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIHRydWUpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCBpbiBgYXJyYXlgXG4gICAgICogdXNpbmcgYFNhbWVWYWx1ZVplcm9gIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsXG4gICAgICogaXQgaXMgdXNlZCBhcyB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIHNvcnRlZFxuICAgICAqIHByb3ZpZGluZyBgdHJ1ZWAgZm9yIGBmcm9tSW5kZXhgIHBlcmZvcm1zIGEgZmFzdGVyIGJpbmFyeSBzZWFyY2guXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogY29tcGFyaXNvbnMgYXJlIGxpa2Ugc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlLmcuIGA9PT1gLCBleGNlcHQgdGhhdFxuICAgICAqIGBOYU5gIG1hdGNoZXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtib29sZWFufG51bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20gb3IgYHRydWVgXG4gICAgICogIHRvIHBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGBmcm9tSW5kZXhgXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogLy8gcGVyZm9ybWluZyBhIGJpbmFyeSBzZWFyY2hcbiAgICAgKiBfLmluZGV4T2YoWzEsIDEsIDIsIDJdLCAyLCB0cnVlKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGZyb21JbmRleCA9IGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKSA6IGZyb21JbmRleDtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJpbmFyeUluZGV4KGFycmF5LCB2YWx1ZSksXG4gICAgICAgICAgICBvdGhlciA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IHZhbHVlID8gKHZhbHVlID09PSBvdGhlcikgOiAob3RoZXIgIT09IG90aGVyKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXggfHwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXkpIHtcbiAgICAgIHJldHVybiBkcm9wUmlnaHQoYXJyYXksIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyBpbiBhbGwgcHJvdmlkZWQgYXJyYXlzIHVzaW5nIGBTYW1lVmFsdWVaZXJvYFxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBjb21wYXJpc29ucyBhcmUgbGlrZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGUuZy4gYD09PWAsIGV4Y2VwdCB0aGF0XG4gICAgICogYE5hTmAgbWF0Y2hlcyBgTmFOYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzEsIDJdLCBbNCwgMl0sIFsyLCAxXSk7XG4gICAgICogLy8gPT4gWzJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICBjYWNoZXMgPSBbXSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGlzQ29tbW9uID0gaW5kZXhPZiA9PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbYXJnc0luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkge1xuICAgICAgICAgIGFyZ3MucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgY2FjaGVzLnB1c2goKGlzQ29tbW9uICYmIHZhbHVlLmxlbmd0aCA+PSAxMjApID8gY3JlYXRlQ2FjaGUoYXJnc0luZGV4ICYmIHZhbHVlKSA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICBpZiAoYXJnc0xlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBhcnJheSA9IGFyZ3NbMF0sXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgc2VlbiA9IGNhY2hlc1swXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKChzZWVuID8gY2FjaGVJbmRleE9mKHNlZW4sIHZhbHVlKSA6IGluZGV4T2YocmVzdWx0LCB2YWx1ZSwgMCkpIDwgMCkge1xuICAgICAgICAgIGFyZ3NJbmRleCA9IGFyZ3NMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKC0tYXJnc0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbYXJnc0luZGV4XTtcbiAgICAgICAgICAgIGlmICgoY2FjaGUgPyBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA6IGluZGV4T2YoYXJnc1thcmdzSW5kZXhdLCB2YWx1ZSwgMCkpIDwgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBhcnJheWAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbVxuICAgICAqICBvciBgdHJ1ZWAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGBmcm9tSW5kZXhgXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHBlcmZvcm1pbmcgYSBiaW5hcnkgc2VhcmNoXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMSwgMiwgMl0sIDIsIHRydWUpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKSA6IG5hdGl2ZU1pbihmcm9tSW5kZXggfHwgMCwgbGVuZ3RoIC0gMSkpICsgMTtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbUluZGV4KSB7XG4gICAgICAgIGluZGV4ID0gYmluYXJ5SW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG4gICAgICAgIHZhciBvdGhlciA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2YWx1ZSA/ICh2YWx1ZSA9PT0gb3RoZXIpIDogKG90aGVyICE9PSBvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXhPZk5hTihhcnJheSwgaW5kZXgsIHRydWUpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBwcm92aWRlZCB2YWx1ZXMgZnJvbSBgYXJyYXlgIHVzaW5nIGBTYW1lVmFsdWVaZXJvYCBmb3IgZXF1YWxpdHlcbiAgICAgKiBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZXM6KipcbiAgICAgKiAgLSBVbmxpa2UgYF8ud2l0aG91dGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YFxuICAgICAqICAtIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqICAgIGNvbXBhcmlzb25zIGFyZSBsaWtlIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgZS5nLiBgPT09YCwgZXhjZXB0XG4gICAgICogICAgdGhhdCBgTmFOYCBtYXRjaGVzIGBOYU5gXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCAxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbChhcnJheSwgMiwgMyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGwoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcnJheSA9IGFyZ3NbMF07XG5cbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gYXJnc1tpbmRleF07XG5cbiAgICAgICAgd2hpbGUgKChmcm9tSW5kZXggPSBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSkgPiAtMSkge1xuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGBhcnJheWAgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5kZXhlcyBhbmQgcmV0dXJuc1xuICAgICAqIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBJbmRleGVzIG1heSBiZSBzcGVjaWZpZWQgYXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBpbmRleGVzIG9yIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5hdGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gW2luZGV4ZXNdIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZSxcbiAgICAgKiAgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgaW5kZXhlcyBvciBhcnJheXMgb2YgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbNSwgMTAsIDE1LCAyMF07XG4gICAgICogdmFyIGV2ZW5zID0gXy5wdWxsQXQoYXJyYXksIDEsIDMpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFs1LCAxNV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMTAsIDIwXVxuICAgICAqL1xuICAgIHZhciBwdWxsQXQgPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIGFycmF5IHx8IChhcnJheSA9IFtdKTtcbiAgICAgIGluZGV4ZXMgPSBiYXNlRmxhdHRlbihpbmRleGVzKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzLnNvcnQoYmFzZUNvbXBhcmVBc2NlbmRpbmcpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGBhcnJheWAgdGhhdCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHRhaWxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0KGFycmF5KSB7XG4gICAgICByZXR1cm4gZHJvcChhcnJheSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkIG9mIGBBcnJheSNzbGljZWAgdG8gc3VwcG9ydCBub2RlXG4gICAgICogbGlzdHMgaW4gSUUgPCA5IGFuZCB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAmJiB0eXBlb2YgZW5kICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzdGFydCwgZW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgbG93ZXN0IGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkXG4gICAgICogYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLiBJZiBhbiBpdGVyYXRlZVxuICAgICAqIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgXG4gICAgICogdG8gY29tcHV0ZSB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzQsIDQsIDUsIDVdLCA1KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiB2YXIgZGljdCA9IHsgJ2RhdGEnOiB7ICd0aGlydHknOiAzMCwgJ2ZvcnR5JzogNDAsICdmaWZ0eSc6IDUwIH0gfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uXG4gICAgICogXy5zb3J0ZWRJbmRleChbJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm9ydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5kYXRhW3dvcmRdO1xuICAgICAqIH0sIGRpY3QpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb3J0ZWRJbmRleChbeyAneCc6IDMwIH0sIHsgJ3gnOiA1MCB9XSwgeyAneCc6IDQwIH0sICd4Jyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIHZhciBzb3J0ZWRJbmRleCA9IGNyZWF0ZVNvcnRlZEluZGV4KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXG4gICAgICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4KFs0LCA0LCA1LCA1XSwgNSk7XG4gICAgICogLy8gPT4gNFxuICAgICAqL1xuICAgIHZhciBzb3J0ZWRMYXN0SW5kZXggPSBjcmVhdGVTb3J0ZWRJbmRleCh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBuLCBndWFyZCkgOiBuID09IG51bGwpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH1cbiAgICAgIG4gPSBsZW5ndGggLSAoK24gfHwgMCk7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC4gRWxlbWVudHMgYXJlXG4gICAgICogdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVdoaWxlKFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2V9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzIHVzaW5nXG4gICAgICogYFNhbWVWYWx1ZVplcm9gIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBjb21wYXJpc29ucyBhcmUgbGlrZSBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGUuZy4gYD09PWAsIGV4Y2VwdCB0aGF0XG4gICAgICogYE5hTmAgbWF0Y2hlcyBgTmFOYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb24oWzEsIDJdLCBbNCwgMl0sIFsyLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDRdXG4gICAgICovXG4gICAgdmFyIHVuaW9uID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgZmFsc2UsIHRydWUpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5LCB1c2luZyBgU2FtZVZhbHVlWmVyb2AgZm9yXG4gICAgICogZXF1YWxpdHkgY29tcGFyaXNvbnMsIGluIHdoaWNoIG9ubHkgdGhlIGZpcnN0IG9jY3VyZW5jZSBvZiBlYWNoIGVsZW1lbnRcbiAgICAgKiBpcyBrZXB0LiBQcm92aWRpbmcgYHRydWVgIGZvciBgaXNTb3J0ZWRgIHBlcmZvcm1zIGEgZmFzdGVyIHNlYXJjaCBhbGdvcml0aG1cbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy4gSWYgYW4gaXRlcmF0ZWUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCBmb3JcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdW5pcXVlbmVzc1xuICAgICAqIGlzIGNvbXB1dGVkLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGNvbXBhcmlzb25zIGFyZSBsaWtlIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgZS5nLiBgPT09YCwgZXhjZXB0IHRoYXRcbiAgICAgKiBgTmFOYCBtYXRjaGVzIGBOYU5gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHVuaXF1ZVxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU29ydGVkXSBTcGVjaWZ5IHRoZSBhcnJheSBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcShbMiwgMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYGlzU29ydGVkYFxuICAgICAqIF8udW5pcShbMSwgMSwgMl0sIHRydWUpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYW4gaXRlcmF0ZWUgZnVuY3Rpb25cbiAgICAgKiBfLnVuaXEoWzEsIDIuNSwgMS41LCAyXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIHRoaXMuZmxvb3Iobik7XG4gICAgICogfSwgTWF0aCk7XG4gICAgICogLy8gPT4gWzEsIDIuNV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy51bmlxKFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoaXNTb3J0ZWQgIT0gbnVsbCAmJiB0eXBlb2YgaXNTb3J0ZWQgIT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXNBcmcgPSBpdGVyYXRlZTtcbiAgICAgICAgaXRlcmF0ZWUgPSBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgaXNTb3J0ZWQsIHRoaXNBcmcpID8gbnVsbCA6IGlzU29ydGVkO1xuICAgICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGZ1bmMgPSBnZXRDYWxsYmFjaygpO1xuICAgICAgaWYgKCEoZnVuYyA9PT0gYmFzZUNhbGxiYWNrICYmIGl0ZXJhdGVlID09IG51bGwpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gZnVuYyhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGlzU29ydGVkICYmIGdldEluZGV4T2YoKSA9PSBiYXNlSW5kZXhPZilcbiAgICAgICAgPyBzb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSlcbiAgICAgICAgOiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIGdyb3VwZWRcbiAgICAgKiBlbGVtZW50cyBhbmQgY3JlYXRlcyBhbiBhcnJheSByZWdyb3VwaW5nIHRoZSBlbGVtZW50cyB0byB0aGVpciBwcmUtYF8uemlwYFxuICAgICAqIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnLCAzMCwgdHJ1ZV0sIFsnYmFybmV5JywgNDAsIGZhbHNlXV1cbiAgICAgKlxuICAgICAqIF8udW56aXAoemlwcGVkKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiBhcnJheU1heChhcnJheU1hcChhcnJheSwgZ2V0TGVuZ3RoKSkpID4+PiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheU1hcChhcnJheSwgYmFzZVByb3BlcnR5KGluZGV4KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCBwcm92aWRlZCB2YWx1ZXMgdXNpbmcgYFNhbWVWYWx1ZVplcm9gIGZvclxuICAgICAqIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGNvbXBhcmlzb25zIGFyZSBsaWtlIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgZS5nLiBgPT09YCwgZXhjZXB0IHRoYXRcbiAgICAgKiBgTmFOYCBtYXRjaGVzIGBOYU5gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbHRlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud2l0aG91dChbMSwgMiwgMSwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqL1xuICAgIHZhciB3aXRob3V0ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiAoaXNBcnJheShhcnJheSkgfHwgaXNBcmd1bWVudHMoYXJyYXkpKVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHRoYXQgaXMgdGhlIFtzeW1tZXRyaWMgZGlmZmVyZW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UpXG4gICAgICogb2YgdGhlIHByb3ZpZGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yKFsxLCAyXSwgWzQsIDJdKTtcbiAgICAgKiAvLyA9PiBbMSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB4b3IoKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICBpZiAoaXNBcnJheShhcnJheSkgfHwgaXNBcmd1bWVudHMoYXJyYXkpKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdFxuICAgICAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShyZXN1bHQsIGFycmF5KS5jb25jYXQoYmFzZURpZmZlcmVuY2UoYXJyYXksIHJlc3VsdCkpXG4gICAgICAgICAgICA6IGFycmF5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ID8gYmFzZVVuaXEocmVzdWx0KSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlIHNlY29uZCBlbGVtZW50c1xuICAgICAqIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJywgMzAsIHRydWVdLCBbJ2Jhcm5leScsIDQwLCBmYWxzZV1dXG4gICAgICovXG4gICAgdmFyIHppcCA9IHJlc3RQYXJhbSh1bnppcCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5wYWlyc2A7IHRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkIGZyb20gYXJyYXlzXG4gICAgICogb2YgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcy4gUHJvdmlkZSBlaXRoZXIgYSBzaW5nbGUgdHdvIGRpbWVuc2lvbmFsIGFycmF5LFxuICAgICAqIGUuZy4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYCBvciB0d28gYXJyYXlzLCBvbmUgb2YgcHJvcGVydHkgbmFtZXNcbiAgICAgKiBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG9iamVjdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFtbJ2ZyZWQnLCAzMF0sIFsnYmFybmV5JywgNDBdXSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDMwLCAnYmFybmV5JzogNDAgfVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDMwLCAnYmFybmV5JzogNDAgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdChwcm9wcywgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcyA/IHByb3BzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIGlmIChsZW5ndGggJiYgIXZhbHVlcyAmJiAhaXNBcnJheShwcm9wc1swXSkpIHtcbiAgICAgICAgdmFsdWVzID0gW107XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSkge1xuICAgICAgICAgIHJlc3VsdFtrZXlbMF1dID0ga2V5WzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3QgdGhhdCB3cmFwcyBgdmFsdWVgIHdpdGggZXhwbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW5pbmcgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciB5b3VuZ2VzdCA9IF8uY2hhaW4odXNlcnMpXG4gICAgICogICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgLm1hcChmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgICAgcmV0dXJuIGNoci51c2VyICsgJyBpcyAnICsgY2hyLmFnZTtcbiAgICAgKiAgIH0pXG4gICAgICogICAuZmlyc3QoKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICByZXN1bHQuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBgaW50ZXJjZXB0b3JgIGFuZCByZXR1cm5zIGB2YWx1ZWAuIFRoZSBpbnRlcmNlcHRvciBpc1xuICAgICAqIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS4gVGhlIHB1cnBvc2Ugb2ZcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4gaW4gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zXG4gICAgICogb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKVxuICAgICAqICAudGFwKGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICogICAgYXJyYXkucG9wKCk7XG4gICAgICogIH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvciwgdGhpc0FyZykge1xuICAgICAgaW50ZXJjZXB0b3IuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy50YXBgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKCcgIGFiYyAgJylcbiAgICAgKiAgLmNoYWluKClcbiAgICAgKiAgLnRyaW0oKVxuICAgICAqICAudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAqICB9KVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhydSh2YWx1ZSwgaW50ZXJjZXB0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBpbnRlcmNlcHRvci5jYWxsKHRoaXNBcmcsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGV4cGxpY2l0IG1ldGhvZCBjaGFpbmluZyBvbiB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjaGFpblxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGhvdXQgZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKHVzZXJzKS5maXJzdCgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIHdpdGggZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKHVzZXJzKS5jaGFpbigpXG4gICAgICogICAuZmlyc3QoKVxuICAgICAqICAgLnBpY2soJ3VzZXInKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICByZXR1cm4gY2hhaW4odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluZWQgc2VxdWVuY2UgYW5kIHJldHVybnMgdGhlIHdyYXBwZWQgcmVzdWx0LlxuICAgICAqXG4gICAgICogQG5hbWUgY29tbWl0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuICAgICAqIHZhciB3cmFwcGVyID0gXyhhcnJheSkucHVzaCgzKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHdyYXBwZXIgPSB3cmFwcGVyLmNvbW1pdCgpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIHdyYXBwZXIubGFzdCgpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ29tbWl0KCkge1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHRoaXMudmFsdWUoKSwgdGhpcy5fX2NoYWluX18pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgY2hhaW5lZCBzZXF1ZW5jZSBwbGFudGluZyBgdmFsdWVgIGFzIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgcGxhbnRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMl07XG4gICAgICogdmFyIHdyYXBwZXIgPSBfKGFycmF5KS5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBNYXRoLnBvdyh2YWx1ZSwgMik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgb3RoZXIgPSBbMywgNF07XG4gICAgICogdmFyIG90aGVyV3JhcHBlciA9IHdyYXBwZXIucGxhbnQob3RoZXIpO1xuICAgICAqXG4gICAgICogb3RoZXJXcmFwcGVyLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzksIDE2XVxuICAgICAqXG4gICAgICogd3JhcHBlci52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJQbGFudCh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzO1xuXG4gICAgICB3aGlsZSAocGFyZW50IGluc3RhbmNlb2YgYmFzZUxvZGFzaCkge1xuICAgICAgICB2YXIgY2xvbmUgPSB3cmFwcGVyQ2xvbmUocGFyZW50KTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gY2xvbmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzID0gY2xvbmU7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fX3dyYXBwZWRfXztcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSB3cmFwcGVkIGFycmF5IHNvIHRoZSBmaXJzdCBlbGVtZW50IGJlY29tZXMgdGhlIGxhc3QsIHRoZVxuICAgICAqIHNlY29uZCBlbGVtZW50IGJlY29tZXMgdGhlIHNlY29uZCB0byBsYXN0LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyB0aGUgd3JhcHBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyByZXZlcnNlZCBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfKGFycmF5KS5yZXZlcnNlKCkudmFsdWUoKVxuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJSZXZlcnNlKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXztcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCkge1xuICAgICAgICAgIHZhbHVlID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZS5yZXZlcnNlKCksIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRocnUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJldmVyc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIHRoZSByZXN1bHQgb2YgY29lcmNpbmcgdGhlIHVud3JhcHBlZCB2YWx1ZSB0byBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBuYW1lIHRvU3RyaW5nXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb2VyY2VkIHN0cmluZyB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnRvU3RyaW5nKCk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb1N0cmluZygpIHtcbiAgICAgIHJldHVybiAodGhpcy52YWx1ZSgpICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbmVkIHNlcXVlbmNlIHRvIGV4dHJhY3QgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgcnVuLCB0b0pTT04sIHZhbHVlT2ZcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XG4gICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZSh0aGlzLl9fd3JhcHBlZF9fLCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGtleXMsIG9yIGluZGV4ZXMsXG4gICAgICogb2YgYGNvbGxlY3Rpb25gLiBLZXlzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2Yga2V5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW118c3RyaW5nfHN0cmluZ1tdKX0gW3Byb3BzXSBUaGUgcHJvcGVydHkgbmFtZXNcbiAgICAgKiAgb3IgaW5kZXhlcyBvZiBlbGVtZW50cyB0byBwaWNrLCBzcGVjaWZpZWQgaW5kaXZpZHVhbGx5IG9yIGluIGFycmF5cy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwaWNrZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYXQoWydhJywgJ2InLCAnYyddLCBbMCwgMl0pO1xuICAgICAqIC8vID0+IFsnYScsICdjJ11cbiAgICAgKlxuICAgICAqIF8uYXQoWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ10sIDAsIDIpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIHZhciBhdCA9IHJlc3RQYXJhbShmdW5jdGlvbihjb2xsZWN0aW9uLCBwcm9wcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBnZXRMZW5ndGgoY29sbGVjdGlvbikgOiAwO1xuICAgICAgaWYgKGlzTGVuZ3RoKGxlbmd0aCkpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHRvSXRlcmFibGUoY29sbGVjdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUF0KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKHByb3BzKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocm91Z2ggYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IGBpdGVyYXRlZWAuXG4gICAgICogVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNC4zLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBNYXRoLmZsb29yKG4pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIHRoaXMuZmxvb3Iobik7XG4gICAgICogfSwgTWF0aCk7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSA/ICsrcmVzdWx0W2tleV0gOiAocmVzdWx0W2tleV0gPSAxKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgYWxsXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RXZlcnkgOiBiYXNlRXZlcnk7XG4gICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nIHx8IHRoaXNBcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgc2VsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maWx0ZXIoWzQsIDUsIDZdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbNCwgNl1cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRldGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVzdWx0KF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlc3VsdChfLmZpbmQodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVzdWx0KF8uZmluZCh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICovXG4gICAgdmFyIGZpbmQgPSBjcmVhdGVGaW5kKGJhc2VFYWNoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgdmFyIGZpbmRMYXN0ID0gY3JlYXRlRmluZChiYXNlRWFjaFJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCBhbmQgdGhlXG4gICAgICogc291cmNlIG9iamVjdCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaGFzIGVxdWl2YWxlbnQgcHJvcGVydHlcbiAgICAgKiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYm9vbGVhbnMsIGBEYXRlYCBvYmplY3RzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBPYmplY3RzIGFyZSBjb21wYXJlZCBieVxuICAgICAqIHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGb3IgY29tcGFyaW5nIGEgc2luZ2xlXG4gICAgICogb3duIG9yIGluaGVyaXRlZCBwcm9wZXJ0eSB2YWx1ZSBzZWUgYF8ubWF0Y2hlc1Byb3BlcnR5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KF8uZmluZFdoZXJlKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KF8uZmluZFdoZXJlKHVzZXJzLCB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0pLCAndXNlcicpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRXaGVyZShjb2xsZWN0aW9uLCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBmaW5kKGNvbGxlY3Rpb24sIGJhc2VNYXRjaGVzKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGludm9raW5nIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5XG4gICAgICogYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiIHByb3BlcnR5XG4gICAgICogYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIGBfLmZvckluYCBvciBgXy5mb3JPd25gXG4gICAgICogbWF5IGJlIHVzZWQgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDJdKS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKG4pO1xuICAgICAqIH0pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIHZhbHVlIGZyb20gbGVmdCB0byByaWdodCBhbmQgcmV0dXJucyB0aGUgYXJyYXlcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKG4sIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2cobiwga2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggdmFsdWUta2V5IHBhaXIgYW5kIHJldHVybnMgdGhlIG9iamVjdCAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciBmb3JFYWNoID0gY3JlYXRlRm9yRWFjaChhcnJheUVhY2gsIGJhc2VFYWNoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMl0pLmZvckVhY2hSaWdodChmdW5jdGlvbihuKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhuKTtcbiAgICAgKiB9KS52YWx1ZSgpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCB2YWx1ZSBmcm9tIHJpZ2h0IHRvIGxlZnQgYW5kIHJldHVybnMgdGhlIGFycmF5XG4gICAgICovXG4gICAgdmFyIGZvckVhY2hSaWdodCA9IGNyZWF0ZUZvckVhY2goYXJyYXlFYWNoUmlnaHQsIGJhc2VFYWNoUmlnaHQpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgdGhlIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuXG4gICAgICogVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBNYXRoLmZsb29yKG4pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmZsb29yKG4pO1xuICAgICAqIH0sIE1hdGgpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNvbGxlY3Rpb25gIHVzaW5nIGBTYW1lVmFsdWVaZXJvYCBmb3IgZXF1YWxpdHlcbiAgICAgKiBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWQgYXMgdGhlIG9mZnNldCBmcm9tXG4gICAgICogdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogY29tcGFyaXNvbnMgYXJlIGxpa2Ugc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlLmcuIGA9PT1gLCBleGNlcHQgdGhhdFxuICAgICAqIGBOYU5gIG1hdGNoZXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgY29udGFpbnMsIGluY2x1ZGVcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIG1hdGNoaW5nIGVsZW1lbnQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyh7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKCdwZWJibGVzJywgJ2ViJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluY2x1ZGVzKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBnZXRMZW5ndGgoY29sbGVjdGlvbikgOiAwO1xuICAgICAgaWYgKCFpc0xlbmd0aChsZW5ndGgpKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHRhcmdldCwgZnJvbUluZGV4LCBndWFyZCkpKSB7XG4gICAgICAgIGZyb21JbmRleCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tSW5kZXggPSBmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCkgOiAoZnJvbUluZGV4IHx8IDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuICh0eXBlb2YgY29sbGVjdGlvbiA9PSAnc3RyaW5nJyB8fCAhaXNBcnJheShjb2xsZWN0aW9uKSAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSlcbiAgICAgICAgPyAoZnJvbUluZGV4IDwgbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih0YXJnZXQsIGZyb21JbmRleCkgPiAtMSlcbiAgICAgICAgOiAoZ2V0SW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkgPiAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgdGhlIGxhc3QgZWxlbWVudCByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LiBUaGVcbiAgICAgKiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGtleURhdGEgPSBbXG4gICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleURhdGEsICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleURhdGEsIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2JqZWN0LmNvZGUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlEYXRhLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLmZyb21DaGFyQ29kZShvYmplY3QuY29kZSk7XG4gICAgICogfSwgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGluZGV4QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb24gZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogYXJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBtZXRob2ROYW1lYCBpcyBhIGZ1bmN0aW9uIGl0IGlzXG4gICAgICogaW52b2tlZCBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZShbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgdmFyIGludm9rZSA9IHJlc3RQYXJhbShmdW5jdGlvbihjb2xsZWN0aW9uLCBwYXRoLCBhcmdzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIGlzUHJvcCA9IGlzS2V5KHBhdGgpLFxuICAgICAgICAgIGxlbmd0aCA9IGdldExlbmd0aChjb2xsZWN0aW9uKSxcbiAgICAgICAgICByZXN1bHQgPSBpc0xlbmd0aChsZW5ndGgpID8gQXJyYXkobGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgZnVuYyA9IGlzRnVuYyA/IHBhdGggOiAoaXNQcm9wICYmIHZhbHVlICE9IG51bGwgJiYgdmFsdWVbcGF0aF0pO1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBmdW5jID8gZnVuYy5hcHBseSh2YWx1ZSwgYXJncykgOiBpbnZva2VQYXRoKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJvdWdoXG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpbnRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhcnlgLCBgY2FsbGJhY2tgLCBgY2h1bmtgLCBgY2xvbmVgLCBgY3JlYXRlYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsXG4gICAgICogYGRyb3BSaWdodGAsIGBldmVyeWAsIGBmaWxsYCwgYGZsYXR0ZW5gLCBgaW52ZXJ0YCwgYG1heGAsIGBtaW5gLCBgcGFyc2VJbnRgLFxuICAgICAqIGBzbGljZWAsIGBzb3J0QnlgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltTGVmdGAsXG4gICAgICogYHRyaW1SaWdodGAsIGB0cnVuY2AsIGByYW5kb21gLCBgcmFuZ2VgLCBgc2FtcGxlYCwgYHNvbWVgLCBgdW5pcWAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgY29sbGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gdGltZXNUaHJlZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5tYXAoWzEsIDJdLCB0aW1lc1RocmVlKTtcbiAgICAgKiAvLyA9PiBbMywgNl1cbiAgICAgKlxuICAgICAqIF8ubWFwKHsgJ2EnOiAxLCAnYic6IDIgfSwgdGltZXNUaHJlZSk7XG4gICAgICogLy8gPT4gWzMsIDZdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIHR3byBncm91cHMsIHRoZSBmaXJzdCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciwgd2hpbGUgdGhlIHNlY29uZCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZFxuICAgICAqIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG4gICAgICogIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYXJ0aXRpb24oWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDI7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gW1sxLCAzXSwgWzJdXVxuICAgICAqXG4gICAgICogXy5wYXJ0aXRpb24oWzEuMiwgMi4zLCAzLjRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5mbG9vcihuKSAlIDI7XG4gICAgICogfSwgTWF0aCk7XG4gICAgICogLy8gPT4gW1sxLjIsIDMuNF0sIFsyLjNdXVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIG1hcHBlciA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICogICByZXR1cm4gXy5wbHVjayhhcnJheSwgJ3VzZXInKTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKF8ucGFydGl0aW9uKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogZmFsc2UgfSksIG1hcHBlcik7XG4gICAgICogLy8gPT4gW1sncGViYmxlcyddLCBbJ2Jhcm5leScsICdmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgbWFwcGVyKTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAncGViYmxlcyddLCBbJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnKSwgbWFwcGVyKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKi9cbiAgICB2YXIgcGFydGl0aW9uID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXkgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24oKSB7IHJldHVybiBbW10sIFtdXTsgfSk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiBgcGF0aGAgZnJvbSBhbGwgZWxlbWVudHMgaW4gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBwbHVjay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wbHVjayh1c2VycywgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIHZhciB1c2VySW5kZXggPSBfLmluZGV4QnkodXNlcnMsICd1c2VyJyk7XG4gICAgICogXy5wbHVjayh1c2VySW5kZXgsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiBbMzYsIDQwXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBsdWNrKGNvbGxlY3Rpb24sIHBhdGgpIHtcbiAgICAgIHJldHVybiBtYXAoY29sbGVjdGlvbiwgcHJvcGVydHkocGF0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAgICAgKiBpcyBub3QgcHJvdmlkZWQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAgICAgKiB2YWx1ZS4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gICAgICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpbnRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBzb3J0QnlBbGxgLCBhbmQgYHNvcnRCeU9yZGVyYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGZvbGRsLCBpbmplY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbih0b3RhbCwgbikge1xuICAgICAqICAgcmV0dXJuIHRvdGFsICsgbjtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHJlc3VsdCwgbiwga2V5KSB7XG4gICAgICogICByZXN1bHRba2V5XSA9IG4gKiAzO1xuICAgICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIHJlZHVjZSA9IGNyZWF0ZVJlZHVjZShhcnJheVJlZHVjZSwgYmFzZUVhY2gpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yZWR1Y2VgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGZvbGRyXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtbMCwgMV0sIFsyLCAzXSwgWzQsIDVdXTtcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlUmlnaHQoYXJyYXksIGZ1bmN0aW9uKGZsYXR0ZW5lZCwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiBmbGF0dGVuZWQuY29uY2F0KG90aGVyKTtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgdmFyIHJlZHVjZVJpZ2h0ID0gIGNyZWF0ZVJlZHVjZShhcnJheVJlZHVjZVJpZ2h0LCBiYXNlRWFjaFJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgOyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aGF0IGBwcmVkaWNhdGVgIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1dGh5IGZvci5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZWplY3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8ucmVqZWN0KHVzZXJzLCB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLnJlamVjdCh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSByYW5kb20gZWxlbWVudCBvciBgbmAgcmFuZG9tIGVsZW1lbnRzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbl0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBzYW1wbGUocykuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdLCAyKTtcbiAgICAgKiAvLyA9PiBbMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuICAgICAgICBjb2xsZWN0aW9uID0gdG9JdGVyYWJsZShjb2xsZWN0aW9uKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuZ3RoID4gMCA/IGNvbGxlY3Rpb25bYmFzZVJhbmRvbSgwLCBsZW5ndGggLSAxKV0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc2h1ZmZsZShjb2xsZWN0aW9uKTtcbiAgICAgIHJlc3VsdC5sZW5ndGggPSBuYXRpdmVNaW4obiA8IDAgPyAwIDogKCtuIHx8IDApLCByZXN1bHQubGVuZ3RoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAgICAgKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbiA9IHRvSXRlcmFibGUoY29sbGVjdGlvbik7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbSgwLCBpbmRleCk7XG4gICAgICAgIGlmIChpbmRleCAhPSByYW5kKSB7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHJlc3VsdFtyYW5kXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmFuZF0gPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGl0cyBsZW5ndGggZm9yIGFycmF5LWxpa2VcbiAgICAgKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBnZXRMZW5ndGgoY29sbGVjdGlvbikgOiAwO1xuICAgICAgcmV0dXJuIGlzTGVuZ3RoKGxlbmd0aCkgPyBsZW5ndGggOiBrZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogVGhlIGZ1bmN0aW9uIHJldHVybnMgYXMgc29vbiBhcyBpdCBmaW5kcyBhIHBhc3NpbmcgdmFsdWUgYW5kIGRvZXMgbm90IGl0ZXJhdGVcbiAgICAgKiBvdmVyIHRoZSBlbnRpcmUgY29sbGVjdGlvbi4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgYW55XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U29tZSA6IGJhc2VTb21lO1xuICAgICAgaWYgKHRoaXNBcmcgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJyB8fCB0aGlzQXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoaXMgbWV0aG9kIHBlcmZvcm1zXG4gICAgICogYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mIGVxdWFsIGVsZW1lbnRzLlxuICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIE1hdGguc2luKG4pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFszLCAxLCAyXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gdGhpcy5zaW4obik7XG4gICAgICogfSwgTWF0aCk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5zb3J0QnkodXNlcnMsICd1c2VyJyksICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0QnkoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNBcmcgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbiksICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgY29tcGFyZUFzY2VuZGluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGNhbiBzb3J0IGJ5IG11bHRpcGxlIGl0ZXJhdGVlc1xuICAgICAqIG9yIHByb3BlcnR5IG5hbWVzLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBhbiBpdGVyYXRlZSB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcbiAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYW4gaXRlcmF0ZWUgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW118T2JqZWN0fE9iamVjdFtdfHN0cmluZ3xzdHJpbmdbXSl9IGl0ZXJhdGVlc1xuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnksIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIHZhbHVlcyBvciBhcnJheXMgb2YgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MiB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChfLnNvcnRCeUFsbCh1c2VycywgWyd1c2VyJywgJ2FnZSddKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQyXSwgWydmcmVkJywgNDhdXVxuICAgICAqXG4gICAgICogXy5tYXAoXy5zb3J0QnlBbGwodXNlcnMsICd1c2VyJywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gTWF0aC5mbG9vcihjaHIuYWdlIC8gMTApO1xuICAgICAqIH0pLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0Ml1dXG4gICAgICovXG4gICAgdmFyIHNvcnRCeUFsbCA9IHJlc3RQYXJhbShmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGd1YXJkID0gaXRlcmF0ZWVzWzJdO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgaXRlcmF0ZWVzLmxlbmd0aCA9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcyksIFtdKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5QWxsYCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGVcbiAgICAgKiBzb3J0IG9yZGVycyBvZiB0aGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuIEEgdHJ1dGh5IHZhbHVlIGluIGBvcmRlcnNgIHdpbGxcbiAgICAgKiBzb3J0IHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWUgaW4gYXNjZW5kaW5nIG9yZGVyIHdoaWxlIGEgZmFsc2V5XG4gICAgICogdmFsdWUgd2lsbCBzb3J0IGl0IGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGFuIGl0ZXJhdGVlIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBhbiBpdGVyYXRlZSB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbltdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MiB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBzb3J0IGJ5IGB1c2VyYCBpbiBhc2NlbmRpbmcgb3JkZXIgYW5kIGJ5IGBhZ2VgIGluIGRlc2NlbmRpbmcgb3JkZXJcbiAgICAgKiBfLm1hcChfLnNvcnRCeU9yZGVyKHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10sIFt0cnVlLCBmYWxzZV0pLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0Ml1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydEJ5T3JkZXIoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMsIGd1YXJkKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpKSB7XG4gICAgICAgIG9yZGVycyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBpdGVyYXRlZXMgPT0gbnVsbCA/IFtdIDogW2l0ZXJhdGVlc107XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xuICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgYW5kIHRoZVxuICAgICAqIHNvdXJjZSBvYmplY3QsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYm9vbGVhbnMsIGBEYXRlYCBvYmplY3RzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBPYmplY3RzIGFyZSBjb21wYXJlZCBieVxuICAgICAqIHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGb3IgY29tcGFyaW5nIGEgc2luZ2xlXG4gICAgICogb3duIG9yIGluaGVyaXRlZCBwcm9wZXJ0eSB2YWx1ZSBzZWUgYF8ubWF0Y2hlc1Byb3BlcnR5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlLCAncGV0cyc6IFsnaG9wcHknXSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGx1Y2soXy53aGVyZSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiBfLnBsdWNrKF8ud2hlcmUodXNlcnMsIHsgJ3BldHMnOiBbJ2Rpbm8nXSB9KSwgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdoZXJlKGNvbGxlY3Rpb24sIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZpbHRlcihjb2xsZWN0aW9uLCBiYXNlTWF0Y2hlcyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBVbml4IGVwb2NoXG4gICAgICogKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRGF0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICAgICAqIH0sIF8ubm93KCkpO1xuICAgICAqIC8vID0+IGxvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGZ1bmN0aW9uIHRvIGJlIGludm9rZWRcbiAgICAgKi9cbiAgICB2YXIgbm93ID0gbmF0aXZlTm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uYmVmb3JlYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIGBmdW5jYCBvbmNlIGl0IGlzIGNhbGxlZCBgbmAgb3IgbW9yZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIG4gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB0ZW1wID0gbjtcbiAgICAgICAgICBuID0gZnVuYztcbiAgICAgICAgICBmdW5jID0gdGVtcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG4gPSBuYXRpdmVJc0Zpbml0ZShuID0gK24pID8gbiA6IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIGBuYCBhcmd1bWVudHMgaWdub3JpbmcgYW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBjYXAuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8uYXJ5KHBhcnNlSW50LCAxKSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFyeShmdW5jLCBuLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGZ1bmMsIG4sIGd1YXJkKSkge1xuICAgICAgICBuID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIG4gPSAoZnVuYyAmJiBuID09IG51bGwpID8gZnVuYy5sZW5ndGggOiBuYXRpdmVNYXgoK24gfHwgMCwgMCk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCBBUllfRkxBRywgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcbiAgICAgKiBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hpbGUgaXQgaXMgY2FsbGVkIGxlc3MgdGhhbiBgbmAgdGltZXMuIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYXQgd2hpY2ggYGZ1bmNgIGlzIG5vIGxvbmdlciBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGpRdWVyeSgnI2FkZCcpLm9uKCdjbGljaycsIF8uYmVmb3JlKDUsIGFkZENvbnRhY3RUb0xpc3QpKTtcbiAgICAgKiAvLyA9PiBhbGxvd3MgYWRkaW5nIHVwIHRvIDQgY29udGFjdHMgdG8gdGhlIGxpc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmUobiwgZnVuYykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSBuO1xuICAgICAgICAgIG4gPSBmdW5jO1xuICAgICAgICAgIGZ1bmMgPSB0ZW1wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgZnVuYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXG4gICAgICogYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBfLmJpbmRgIGFyZ3VtZW50cyB0byB0aG9zZSBwcm92aWRlZCB0byB0aGVcbiAgICAgKiBib3VuZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCB0aGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IEJJTkRfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgYmluZC5wbGFjZWhvbGRlcik7XG4gICAgICAgIGJpdG1hc2sgfD0gUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC4gTWV0aG9kIG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2YgbWV0aG9kIG5hbWVzLiBJZiBubyBtZXRob2QgbmFtZXMgYXJlIHByb3ZpZGVkIGFsbCBlbnVtZXJhYmxlIGZ1bmN0aW9uXG4gICAgICogcHJvcGVydGllcywgb3duIGFuZCBpbmhlcml0ZWQsIG9mIGBvYmplY3RgIGFyZSBib3VuZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbbWV0aG9kTmFtZXNdIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvIGJpbmQsXG4gICAgICogIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIG1ldGhvZCBuYW1lcyBvciBhcnJheXMgb2YgbWV0aG9kIG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ29uQ2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldyk7XG4gICAgICogalF1ZXJ5KCcjZG9jcycpLm9uKCdjbGljaycsIHZpZXcub25DbGljayk7XG4gICAgICogLy8gPT4gbG9ncyAnY2xpY2tlZCBkb2NzJyB3aGVuIHRoZSBlbGVtZW50IGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICB2YXIgYmluZEFsbCA9IHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIG1ldGhvZE5hbWVzKSB7XG4gICAgICBtZXRob2ROYW1lcyA9IG1ldGhvZE5hbWVzLmxlbmd0aCA/IGJhc2VGbGF0dGVuKG1ldGhvZE5hbWVzKSA6IGZ1bmN0aW9ucyhvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBtZXRob2ROYW1lcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBtZXRob2ROYW1lc1tpbmRleF07XG4gICAgICAgIG9iamVjdFtrZXldID0gY3JlYXRlV3JhcHBlcihvYmplY3Rba2V5XSwgQklORF9GTEFHLCBvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gIGFuZCBwcmVwZW5kc1xuICAgICAqIGFueSBhZGRpdGlvbmFsIGBfLmJpbmRLZXlgIGFyZ3VtZW50cyB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYm91bmQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvIHJlZmVyZW5jZVxuICAgICAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC5cbiAgICAgKiBTZWUgW1BldGVyIE1pY2hhdXgncyBhcnRpY2xlXShodHRwOi8vcGV0ZXIubWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybilcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmRLZXkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRoZSBtZXRob2QgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICd1c2VyJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmRLZXkgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IEJJTkRfRkxBRyB8IEJJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGJpbmRLZXkucGxhY2Vob2xkZXIpO1xuICAgICAgICBiaXRtYXNrIHw9IFBBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGtleSwgYml0bWFzaywgb2JqZWN0LCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBvciBtb3JlIGFyZ3VtZW50cyBvZiBgZnVuY2AgdGhhdCB3aGVuXG4gICAgICogY2FsbGVkIGVpdGhlciBpbnZva2VzIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYWxsIGBmdW5jYCBhcmd1bWVudHNcbiAgICAgKiBoYXZlIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIG9yIG1vcmUgb2YgdGhlXG4gICAgICogcmVtYWluaW5nIGBmdW5jYCBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBtYXkgYmUgc3BlY2lmaWVkXG4gICAgICogaWYgYGZ1bmMubGVuZ3RoYCBpcyBub3Qgc3VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiBjdXJyaWVkKDEpKF8sIDMpKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIHZhciBjdXJyeSA9IGNyZWF0ZUN1cnJ5KENVUlJZX0ZMQUcpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jdXJyeWAgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFyZSBhcHBsaWVkIHRvIGBmdW5jYFxuICAgICAqIGluIHRoZSBtYW5uZXIgb2YgYF8ucGFydGlhbFJpZ2h0YCBpbnN0ZWFkIG9mIGBfLnBhcnRpYWxgLlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5UmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeVJpZ2h0KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDMpKDIpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgyLCAzKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcbiAgICAgKiBjdXJyaWVkKDMpKDEsIF8pKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIHZhciBjdXJyeVJpZ2h0ID0gY3JlYXRlQ3VycnkoQ1VSUllfUklHSFRfRkxBRyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHNcbiAgICAgKiBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSBpdCB3YXMgaW52b2tlZC4gVGhlIGNyZWF0ZWQgZnVuY3Rpb24gY29tZXNcbiAgICAgKiB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGludm9jYXRpb25zLiBQcm92aWRlIGFuIG9wdGlvbnNcbiAgICAgKiBvYmplY3QgdG8gaW5kaWNhdGUgdGhhdCBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yXG4gICAgICogdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIGRlYm91bmNlZFxuICAgICAqIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpcyBpbnZva2VkXG4gICAgICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBpc1xuICAgICAqIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwOi8vZHJ1cGFsbW90aW9uLmNvbS9hcnRpY2xlL2RlYm91bmNlLWFuZC10aHJvdHRsZS12aXN1YWwtZXhwbGFuYXRpb24pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmdcbiAgICAgKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF0gVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZVxuICAgICAqICBkZWxheWVkIGJlZm9yZSBpdCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmdcbiAgICAgKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIGF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXhcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICAgICAqXG4gICAgICogLy8gaW52b2tlIGBzZW5kTWFpbGAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxsc1xuICAgICAqIGpRdWVyeSgnI3Bvc3Rib3gnKS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gZW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxsc1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwge1xuICAgICAqICAgJ21heFdhaXQnOiAxMDAwXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gY2FuY2VsIGEgZGVib3VuY2VkIGNhbGxcbiAgICAgKiB2YXIgdG9kb0NoYW5nZXMgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAxMDAwKTtcbiAgICAgKiBPYmplY3Qub2JzZXJ2ZShtb2RlbHMudG9kbywgdG9kb0NoYW5nZXMpO1xuICAgICAqXG4gICAgICogT2JqZWN0Lm9ic2VydmUobW9kZWxzLCBmdW5jdGlvbihjaGFuZ2VzKSB7XG4gICAgICogICBpZiAoXy5maW5kKGNoYW5nZXMsIHsgJ3VzZXInOiAndG9kbycsICd0eXBlJzogJ2RlbGV0ZSd9KSkge1xuICAgICAqICAgICB0b2RvQ2hhbmdlcy5jYW5jZWwoKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9LCBbJ2RlbGV0ZSddKTtcbiAgICAgKlxuICAgICAqIC8vIC4uLmF0IHNvbWUgcG9pbnQgYG1vZGVscy50b2RvYCBpcyBjaGFuZ2VkXG4gICAgICogbW9kZWxzLnRvZG8uY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgKlxuICAgICAqIC8vIC4uLmJlZm9yZSAxIHNlY29uZCBoYXMgcGFzc2VkIGBtb2RlbHMudG9kb2AgaXMgZGVsZXRlZFxuICAgICAqIC8vIHdoaWNoIGNhbmNlbHMgdGhlIGRlYm91bmNlZCBgdG9kb0NoYW5nZXNgIGNhbGxcbiAgICAgKiBkZWxldGUgbW9kZWxzLnRvZG87XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MsXG4gICAgICAgICAgbWF4VGltZW91dElkLFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICBzdGFtcCxcbiAgICAgICAgICB0aGlzQXJnLFxuICAgICAgICAgIHRpbWVvdXRJZCxcbiAgICAgICAgICB0cmFpbGluZ0NhbGwsXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDAsXG4gICAgICAgICAgbWF4V2FpdCA9IGZhbHNlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgd2FpdCA9IHdhaXQgPCAwID8gMCA6ICgrd2FpdCB8fCAwKTtcbiAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgdHJhaWxpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9IG9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4V2FpdCA9ICdtYXhXYWl0JyBpbiBvcHRpb25zICYmIG5hdGl2ZU1heCgrb3B0aW9ucy5tYXhXYWl0IHx8IDAsIHdhaXQpO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVsYXllZCgpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93KCkgLSBzdGFtcCk7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpc0NhbGxlZCA9IHRyYWlsaW5nQ2FsbDtcbiAgICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYXhEZWxheWVkKCkge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHJhaWxpbmcgfHwgKG1heFdhaXQgIT09IHdhaXQpKSB7XG4gICAgICAgICAgbGFzdENhbGxlZCA9IG5vdygpO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN0YW1wID0gbm93KCk7XG4gICAgICAgIHRoaXNBcmcgPSB0aGlzO1xuICAgICAgICB0cmFpbGluZ0NhbGwgPSB0cmFpbGluZyAmJiAodGltZW91dElkIHx8ICFsZWFkaW5nKTtcblxuICAgICAgICBpZiAobWF4V2FpdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB2YXIgbGVhZGluZ0NhbGwgPSBsZWFkaW5nICYmICF0aW1lb3V0SWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFtYXhUaW1lb3V0SWQgJiYgIWxlYWRpbmcpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlbWFpbmluZyA9IG1heFdhaXQgLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKSxcbiAgICAgICAgICAgICAgaXNDYWxsZWQgPSByZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiBtYXhXYWl0O1xuXG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgbWF4VGltZW91dElkID0gc2V0VGltZW91dChtYXhEZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgdGltZW91dElkKSB7XG4gICAgICAgICAgdGltZW91dElkID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRpbWVvdXRJZCAmJiB3YWl0ICE9PSBtYXhXYWl0KSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcbiAgICAgICAgICBpc0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgaW52b2tpbmcgdGhlIGBmdW5jYCB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLiBBbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sICdkZWZlcnJlZCcpO1xuICAgICAqIC8vIGxvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgb3IgbW9yZSBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICB2YXIgZGVmZXIgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYGZ1bmNgIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAxMDAwLCAnbGF0ZXInKTtcbiAgICAgKiAvLyA9PiBsb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZFxuICAgICAqL1xuICAgIHZhciBkZWxheSA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHdhaXQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBwcm92aWRlZFxuICAgICAqIGZ1bmN0aW9ucyB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jc10gRnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93KF8uYWRkLCBzcXVhcmUpO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsb3dgIGV4Y2VwdCB0aGF0IGl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaW52b2tlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBiYWNrZmxvdywgY29tcG9zZVxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jc10gRnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93UmlnaHQoc3F1YXJlLCBfLmFkZCk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gICAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIGNvZXJjZWQgdG8gYSBzdHJpbmcgYW5kIHVzZWQgYXMgdGhlXG4gICAgICogY2FjaGUga2V5LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGUgW2BNYXBgXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAgICogbWV0aG9kIGludGVyZmFjZSBvZiBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6aW5nIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXBwZXJDYXNlID0gXy5tZW1vaXplKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIHN0cmluZy50b1VwcGVyQ2FzZSgpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdXBwZXJDYXNlKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZSRUQnXG4gICAgICpcbiAgICAgKiAvLyBtb2RpZnlpbmcgdGhlIHJlc3VsdCBjYWNoZVxuICAgICAqIHVwcGVyQ2FzZS5jYWNoZS5zZXQoJ2ZyZWQnLCAnQkFSTkVZJyk7XG4gICAgICogdXBwZXJDYXNlKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0JBUk5FWSdcbiAgICAgKlxuICAgICAqIC8vIHJlcGxhY2luZyBgXy5tZW1vaXplLkNhY2hlYFxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIG90aGVyID0geyAndXNlcic6ICdiYXJuZXknIH07XG4gICAgICogdmFyIGlkZW50aXR5ID0gXy5tZW1vaXplKF8uaWRlbnRpdHkpO1xuICAgICAqXG4gICAgICogaWRlbnRpdHkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBpZGVudGl0eShvdGhlcik7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICAgICAqIHZhciBpZGVudGl0eSA9IF8ubWVtb2l6ZShfLmlkZW50aXR5KTtcbiAgICAgKlxuICAgICAqIGlkZW50aXR5KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogaWRlbnRpdHkob3RoZXIpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF07XG5cbiAgICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBjYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IG1lbW9pemUuQ2FjaGU7XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAgICAgKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbmVnYXRlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0V2ZW4obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBfLm5lZ2F0ZShpc0V2ZW4pKTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBpbnZva2luZyBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzXG4gICAgICogdG8gdGhlIGZ1bmN0aW9uIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGNhbGwuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiAvLyBgaW5pdGlhbGl6ZWAgaW52b2tlcyBgY3JlYXRlQXBwbGljYXRpb25gIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiZWZvcmUoMiwgZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBgcGFydGlhbGAgYXJndW1lbnRzIHByZXBlbmRlZFxuICAgICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYmluZGAgZXhjZXB0XG4gICAgICogaXQgZG9lcyAqKm5vdCoqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWwoZ3JlZXQsICdoZWxsbycpO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWwoZ3JlZXQsIF8sICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsID0gY3JlYXRlUGFydGlhbChQQVJUSUFMX0ZMQUcpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHNcbiAgICAgKiBhcmUgYXBwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsUmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2hlbGxvJywgXyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsUmlnaHQgPSBjcmVhdGVQYXJ0aWFsKFBBUlRJQUxfUklHSFRfRkxBRyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyBhcnJhbmdlZCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBmaXJzdCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBzZWNvbmQgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZWFycmFuZ2UgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcmd1bWVudCBpbmRleGVzLFxuICAgICAqICBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBpbmRleGVzIG9yIGFycmF5cyBvZiBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhcmdlZCA9IF8ucmVhcmcoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9LCAyLCAwLCAxKTtcbiAgICAgKlxuICAgICAqIHJlYXJnZWQoJ2InLCAnYycsICdhJylcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIHZhciBtYXAgPSBfLnJlYXJnKF8ubWFwLCBbMSwgMF0pO1xuICAgICAqIG1hcChmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAqIDM7XG4gICAgICogfSwgWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMywgNiwgOV1cbiAgICAgKi9cbiAgICB2YXIgcmVhcmcgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgaW5kZXhlcykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgUkVBUkdfRkxBRywgbnVsbCwgbnVsbCwgbnVsbCwgYmFzZUZsYXR0ZW4oaW5kZXhlcykpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiBhbmQgYXJndW1lbnRzIGZyb20gYHN0YXJ0YCBhbmQgYmV5b25kIHByb3ZpZGVkIGFzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZSBbcmVzdCBwYXJhbWV0ZXJdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Z1bmN0aW9ucy9yZXN0X3BhcmFtZXRlcnMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnJlc3RQYXJhbShmdW5jdGlvbih3aGF0LCBuYW1lcykge1xuICAgICAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuICAgICAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3RQYXJhbShmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogKCtzdGFydCB8fCAwKSwgMCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgICAgIHJlc3QgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdFtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc3RhcnQpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpcywgcmVzdCk7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIHJlc3QpO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCByZXN0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlckFyZ3Nbc3RhcnRdID0gcmVzdDtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbiBhbmQgYW4gYXJyYXkgb2YgYXJndW1lbnRzIG11Y2ggbGlrZSBbYEZ1bmN0aW9uI2FwcGx5YF0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjMpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZSBbc3ByZWFkIG9wZXJhdG9yXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvU3ByZWFkX29wZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNwcmVhZCBhcmd1bWVudHMgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8uc3ByZWFkKGZ1bmN0aW9uKHdobywgd2hhdCkge1xuICAgICAqICAgcmV0dXJuIHdobyArICcgc2F5cyAnICsgd2hhdDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheShbJ2ZyZWQnLCAnaGVsbG8nXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQgc2F5cyBoZWxsbydcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYSBQcm9taXNlXG4gICAgICogdmFyIG51bWJlcnMgPSBQcm9taXNlLmFsbChbXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoNDApLFxuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDM2KVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogbnVtYmVycy50aGVuKF8uc3ByZWFkKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiB4ICsgeTtcbiAgICAgKiB9KSk7XG4gICAgICogLy8gPT4gYSBQcm9taXNlIG9mIDc2XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3ByZWFkKGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihhcnJheSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcnJheSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlciBldmVyeSBgd2FpdGBcbiAgICAgKiBtaWxsaXNlY29uZHMuIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gICAgICogZGVsYXllZCBpbnZvY2F0aW9ucy4gUHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCB0byBpbmRpY2F0ZSB0aGF0IGBmdW5jYFxuICAgICAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3RcbiAgICAgKiBgZnVuY2AgY2FsbC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cDovL2RydXBhbG1vdGlvbi5jb20vYXJ0aWNsZS9kZWJvdW5jZS1hbmQtdGhyb3R0bGUtdmlzdWFsLWV4cGxhbmF0aW9uKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmdcbiAgICAgKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nXG4gICAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICAgICAqXG4gICAgICogLy8gaW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXNcbiAgICAgKiBqUXVlcnkoJy5pbnRlcmFjdGl2ZScpLm9uKCdjbGljaycsIF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7XG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIGNhbmNlbCBhIHRyYWlsaW5nIHRocm90dGxlZCBjYWxsXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGxlYWRpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgZGVib3VuY2VPcHRpb25zLmxlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgZGVib3VuY2VPcHRpb25zLm1heFdhaXQgPSArd2FpdDtcbiAgICAgIGRlYm91bmNlT3B0aW9ucy50cmFpbGluZyA9IHRyYWlsaW5nO1xuICAgICAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGRlYm91bmNlT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbiBhcyBpdHNcbiAgICAgKiBmaXJzdCBhcmd1bWVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmVcbiAgICAgKiBhcHBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbi4gVGhlIHdyYXBwZXIgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPmZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgd3JhcHBlciA9IHdyYXBwZXIgPT0gbnVsbCA/IGlkZW50aXR5IDogd3JhcHBlcjtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKHdyYXBwZXIsIFBBUlRJQUxfRkxBRywgbnVsbCwgW3ZhbHVlXSwgW10pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdmFsdWVgLiBJZiBgaXNEZWVwYCBpcyBgdHJ1ZWAgbmVzdGVkIG9iamVjdHMgYXJlIGNsb25lZCxcbiAgICAgKiBvdGhlcndpc2UgdGhleSBhcmUgYXNzaWduZWQgYnkgcmVmZXJlbmNlLiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogY2xvbmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudDsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0XSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjaW50ZXJuYWwtc3RydWN0dXJlZC1jbG9uaW5nLWFsZ29yaXRobSkuXG4gICAgICogVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZCBvYmplY3RzIGNyZWF0ZWQgYnlcbiAgICAgKiBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuIEFuXG4gICAgICogZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaCBhcyBmdW5jdGlvbnMsIERPTSBub2RlcyxcbiAgICAgKiBNYXBzLCBTZXRzLCBhbmQgV2Vha01hcHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUodXNlcnMpO1xuICAgICAqIHNoYWxsb3dbMF0gPT09IHVzZXJzWzBdO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZSh1c2VycywgdHJ1ZSk7XG4gICAgICogZGVlcFswXSA9PT0gdXNlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBlbCA9IF8uY2xvbmUoZG9jdW1lbnQuYm9keSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBlbCA9PT0gZG9jdW1lbnQuYm9keVxuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogZWwubm9kZU5hbWVcbiAgICAgKiAvLyA9PiBCT0RZXG4gICAgICogZWwuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlLCBpc0RlZXAsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcbiAgICAgIGlmIChpc0RlZXAgJiYgdHlwZW9mIGlzRGVlcCAhPSAnYm9vbGVhbicgJiYgaXNJdGVyYXRlZUNhbGwodmFsdWUsIGlzRGVlcCwgY3VzdG9taXplcikpIHtcbiAgICAgICAgaXNEZWVwID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgaXNEZWVwID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpc0FyZyA9IGN1c3RvbWl6ZXI7XG4gICAgICAgIGN1c3RvbWl6ZXIgPSBpc0RlZXA7XG4gICAgICAgIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgJiYgYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDEpO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVlcCBjbG9uZSBvZiBgdmFsdWVgLiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZFxuICAgICAqIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgIGNsb25pbmdcbiAgICAgKiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudDsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0XSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjaW50ZXJuYWwtc3RydWN0dXJlZC1jbG9uaW5nLWFsZ29yaXRobSkuXG4gICAgICogVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZCBvYmplY3RzIGNyZWF0ZWQgYnlcbiAgICAgKiBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuIEFuXG4gICAgICogZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaCBhcyBmdW5jdGlvbnMsIERPTSBub2RlcyxcbiAgICAgKiBNYXBzLCBTZXRzLCBhbmQgV2Vha01hcHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAodXNlcnMpO1xuICAgICAqIGRlZXBbMF0gPT09IHVzZXJzWzBdO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lRGVlcChkb2N1bWVudC5ib2R5LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZWwgPT09IGRvY3VtZW50LmJvZHlcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGVsLm5vZGVOYW1lXG4gICAgICogLy8gPT4gQk9EWVxuICAgICAqIGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyAmJiBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMSk7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCB0cnVlLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGlzT2JqZWN0TGlrZSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gaXNMZW5ndGgobGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheVRhZztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8IChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGJvb2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUoJ01vbiBBcHJpbCAyMyAyMDEyJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGRhdGVUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudCgnPGJvZHk+Jyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiAhIXZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgKG9ialRvU3RyaW5nLmNhbGwodmFsdWUpLmluZGV4T2YoJ0VsZW1lbnQnKSA+IC0xKTtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgZm9yIGVudmlyb25tZW50cyB3aXRob3V0IERPTSBzdXBwb3J0LlxuICAgIGlmICghc3VwcG9ydC5kb20pIHtcbiAgICAgIGlzRWxlbWVudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhIXZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBlbXB0eS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGVtcHR5IHVubGVzcyBpdCBpcyBhblxuICAgICAqIGBhcmd1bWVudHNgIG9iamVjdCwgYXJyYXksIHN0cmluZywgb3IgalF1ZXJ5LWxpa2UgY29sbGVjdGlvbiB3aXRoIGEgbGVuZ3RoXG4gICAgICogZ3JlYXRlciB0aGFuIGAwYCBvciBhbiBvYmplY3Qgd2l0aCBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkodHJ1ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgodmFsdWUpO1xuICAgICAgaWYgKGlzTGVuZ3RoKGxlbmd0aCkgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzU3RyaW5nKHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnNwbGljZSkpKSkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAha2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICAgKiBlcXVpdmFsZW50LiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBjb21wYXJpc29ucyBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kXG4gICAgICogaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBvdGhlciBbLCBpbmRleHxrZXldKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG4gICAgICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NIG5vZGVzXG4gICAgICogYXJlICoqbm90Kiogc3VwcG9ydGVkLiBQcm92aWRlIGEgY3VzdG9taXplciBmdW5jdGlvbiB0byBleHRlbmQgc3VwcG9ydFxuICAgICAqIGZvciBjb21wYXJpbmcgb3RoZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PSBvdGhlcjtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBhcnJheSA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgICAqIHZhciBvdGhlciA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKGFycmF5LCBvdGhlciwgZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICogICBpZiAoXy5ldmVyeShbdmFsdWUsIG90aGVyXSwgUmVnRXhwLnByb3RvdHlwZS50ZXN0LCAvXmgoPzppfGVsbG8pJC8pKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplciwgdGhpc0FyZykge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgJiYgYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKCFjdXN0b21pemVyICYmIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKG90aGVyKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBvdGhlcikgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIpIDogISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcbiAgICAgKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IoRXJyb3IpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZXJyb3JUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgcHJpbWl0aXZlIG51bWJlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiBbYE51bWJlci5pc0Zpbml0ZWBdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1udW1iZXIuaXNmaW5pdGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgxMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMTAnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSh0cnVlKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShPYmplY3QoMTApKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNGaW5pdGUgPSBuYXRpdmVOdW1Jc0Zpbml0ZSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNGdW5jdGlvbiA9ICEoYmFzZUlzRnVuY3Rpb24oL3gvKSB8fCAoVWludDhBcnJheSAmJiAhYmFzZUlzRnVuY3Rpb24oVWludDhBcnJheSkpKSA/IGJhc2VJc0Z1bmN0aW9uIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAgICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcbiAgICAgIC8vIGFuZCBTYWZhcmkgOCBlcXVpdmFsZW50cyB3aGljaCByZXR1cm4gJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9ycy5cbiAgICAgIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBmdW5jVGFnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICAgICAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gdHlwZSA9PSAnZnVuY3Rpb24nIHx8ICghIXZhbHVlICYmIHR5cGUgPT0gJ29iamVjdCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYG9iamVjdGAgYW5kIGBzb3VyY2VgIHRvIGRldGVybWluZSBpZlxuICAgICAqIGBvYmplY3RgIGNvbnRhaW5zIGVxdWl2YWxlbnQgcHJvcGVydHkgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWRcbiAgICAgKiBpdCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIGNvbXBhcmlzb25zIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZFxuICAgICAqIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBvdGhlciwgaW5kZXh8a2V5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgcHJvcGVydGllcyBvZiBhcnJheXMsIGJvb2xlYW5zLFxuICAgICAqIGBEYXRlYCBvYmplY3RzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gRnVuY3Rpb25zXG4gICAgICogYW5kIERPTSBub2RlcyBhcmUgKipub3QqKiBzdXBwb3J0ZWQuIFByb3ZpZGUgYSBjdXN0b21pemVyIGZ1bmN0aW9uIHRvIGV4dGVuZFxuICAgICAqIHN1cHBvcnQgZm9yIGNvbXBhcmluZyBvdGhlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdhZ2UnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2dyZWV0aW5nJzogJ2hlbGxvJyB9O1xuICAgICAqIHZhciBzb3VyY2UgPSB7ICdncmVldGluZyc6ICdoaScgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gXy5ldmVyeShbdmFsdWUsIG90aGVyXSwgUmVnRXhwLnByb3RvdHlwZS50ZXN0LCAvXmgoPzppfGVsbG8pJC8pIHx8IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplciwgdGhpc0FyZykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgJiYgYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDMpO1xuICAgICAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcbiAgICAgIGlmICghY3VzdG9taXplciAmJiBsZW5ndGggPT0gMSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbMF0sXG4gICAgICAgICAgICB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICAgIGlmIChpc1N0cmljdENvbXBhcmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBvYmplY3Rba2V5XSAmJiAodmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIG9iamVjdCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBzdHJpY3RDb21wYXJlRmxhZ3MgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZXNbbGVuZ3RoXSA9IHNvdXJjZVtwcm9wc1tsZW5ndGhdXTtcbiAgICAgICAgc3RyaWN0Q29tcGFyZUZsYWdzW2xlbmd0aF0gPSBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgcHJvcHMsIHZhbHVlcywgc3RyaWN0Q29tcGFyZUZsYWdzLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBub3QgdGhlIHNhbWUgYXMgW2Bpc05hTmBdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi40KVxuICAgICAqIHdoaWNoIHJldHVybnMgYHRydWVgIGZvciBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWVyaWMgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIEFuIGBOYU5gIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGYuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBgdG9TdHJpbmdUYWdgIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWUgaG9zdCBvYmplY3RzIGluIElFLlxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoXyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWcpIHtcbiAgICAgICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHJlSXNIb3N0Q3Rvci50ZXN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh2b2lkIDApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmUgY2xhc3NpZmllZFxuICAgICAqIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcig4LjQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKCc4LjQnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IG51bWJlclRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICAgICAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhc3N1bWVzIG9iamVjdHMgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3JcbiAgICAgKiBoYXZlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgaXNQbGFpbk9iamVjdCA9ICFnZXRQcm90b3R5cGVPZiA/IHNoaW1Jc1BsYWluT2JqZWN0IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghKHZhbHVlICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdFRhZykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mLFxuICAgICAgICAgIG9ialByb3RvID0gaXNOYXRpdmUodmFsdWVPZikgJiYgKG9ialByb3RvID0gZ2V0UHJvdG90eXBlT2YodmFsdWVPZikpICYmIGdldFByb3RvdHlwZU9mKG9ialByb3RvKTtcblxuICAgICAgcmV0dXJuIG9ialByb3RvXG4gICAgICAgID8gKHZhbHVlID09IG9ialByb3RvIHx8IGdldFByb3RvdHlwZU9mKHZhbHVlKSA9PSBvYmpQcm90bylcbiAgICAgICAgOiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoL2FiYy8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IHJlZ2V4cFRhZykgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW29ialRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkge1xuICAgICAqICAgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpLnNsaWNlKDEpO1xuICAgICAqIH0oMSwgMiwgMykpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZSA/IGdldExlbmd0aCh2YWx1ZSkgOiAwO1xuICAgICAgaWYgKCFpc0xlbmd0aChsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5Q29weSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlXG4gICAgICogcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDb3B5KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czpcbiAgICAgKiAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBiYXNlZCBvblxuICAgICAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3QuYXNzaWduKS5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ2FnZSc6IDQwIH0sIHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduLCBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKHZhbHVlKSA/IG90aGVyIDogdmFsdWU7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAnYWdlJzogMzYgfSwgeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICByZXR1cm4gY3VzdG9taXplclxuICAgICAgICA/IGFzc2lnbldpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpXG4gICAgICAgIDogYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgcHJvdmlkZWQgaXRzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGFzc2lnbmVkXG4gICAgICogdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMsIGd1YXJkKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHByb3RvdHlwZSwgcHJvcGVydGllcywgZ3VhcmQpKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnRpZXMgPyBiYXNlQXNzaWduKHJlc3VsdCwgcHJvcGVydGllcykgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAgICogb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIE9uY2UgYVxuICAgICAqIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0cyh7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAnYWdlJzogMzYgfSwgeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIHZhciBvYmplY3QgPSBhcmdzWzBdO1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICBhcmdzLnB1c2goYXNzaWduRGVmYXVsdHMpO1xuICAgICAgcmV0dXJuIGFzc2lnbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kS2V5ID0gY3JlYXRlRmluZEtleShiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cbiAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgYHBlYmJsZXNgIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgYGJhcm5leWBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3RLZXkgPSBjcmVhdGVGaW5kS2V5KGJhc2VGb3JPd25SaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgaW52b2tpbmdcbiAgICAgKiBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdhJywgJ2InLCBhbmQgJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIGZvckluID0gY3JlYXRlRm9ySW4oYmFzZUZvcik7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnYycsICdiJywgYW5kICdhJyBhc3N1bWluZyBgXy5mb3JJbiBgIGxvZ3MgJ2EnLCAnYicsIGFuZCAnYydcbiAgICAgKi9cbiAgICB2YXIgZm9ySW5SaWdodCA9IGNyZWF0ZUZvckluKGJhc2VGb3JSaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGludm9raW5nIGBpdGVyYXRlZWBcbiAgICAgKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2EnIGFuZCAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgZm9yT3duID0gY3JlYXRlRm9yT3duKGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JPd25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnYicgYW5kICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIGFuZCAnYidcbiAgICAgKi9cbiAgICB2YXIgZm9yT3duUmlnaHQgPSBjcmVhdGVGb3JPd24oYmFzZUZvck93blJpZ2h0KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLFxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkLCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBtZXRob2RzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhfKTtcbiAgICAgKiAvLyA9PiBbJ2FmdGVyJywgJ2FyeScsICdhc3NpZ24nLCAuLi5dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgYHBhdGhgIG9uIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgdXNlZCBpbiBpdHMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGB1bmRlZmluZWRgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHRvUGF0aChwYXRoKSwgcGF0aCArICcnKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IHsgJ2MnOiAzIH0gfSB9O1xuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EuYi5jJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwYXRoKTtcbiAgICAgIGlmICghcmVzdWx0ICYmICFpc0tleShwYXRoKSkge1xuICAgICAgICBwYXRoID0gdG9QYXRoKHBhdGgpO1xuICAgICAgICBvYmplY3QgPSBwYXRoLmxlbmd0aCA9PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgICAgICBwYXRoID0gbGFzdChwYXRoKTtcbiAgICAgICAgcmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHBhdGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqIElmIGBvYmplY3RgIGNvbnRhaW5zIGR1cGxpY2F0ZSB2YWx1ZXMsIHN1YnNlcXVlbnQgdmFsdWVzIG92ZXJ3cml0ZSBwcm9wZXJ0eVxuICAgICAqIGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHZhbHVlcyB1bmxlc3MgYG11bHRpVmFsdWVgIGlzIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211bHRpVmFsdWVdIEFsbG93IG11bHRpcGxlIHZhbHVlcyBwZXIga2V5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6ICdjJywgJzInOiAnYicgfVxuICAgICAqXG4gICAgICogLy8gd2l0aCBgbXVsdGlWYWx1ZWBcbiAgICAgKiBfLmludmVydChvYmplY3QsIHRydWUpO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZlcnQob2JqZWN0LCBtdWx0aVZhbHVlLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKG9iamVjdCwgbXVsdGlWYWx1ZSwgZ3VhcmQpKSB7XG4gICAgICAgIG11bHRpVmFsdWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAobXVsdGlWYWx1ZSkge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHRbdmFsdWVdLnB1c2goa2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy5rZXlzKCdoaScpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJ11cbiAgICAgKi9cbiAgICB2YXIga2V5cyA9ICFuYXRpdmVLZXlzID8gc2hpbUtleXMgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBsZW5ndGggPSBvYmplY3QubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKCh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlID09PSBvYmplY3QpIHx8XG4gICAgICAgICAgKHR5cGVvZiBvYmplY3QgIT0gJ2Z1bmN0aW9uJyAmJiBpc0xlbmd0aChsZW5ndGgpKSkge1xuICAgICAgICByZXR1cm4gc2hpbUtleXMob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc09iamVjdChvYmplY3QpID8gbmF0aXZlS2V5cyhvYmplY3QpIDogW107XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5c0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IChsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IChzdXBwb3J0Lm5vbkVudW1BcmdzICYmIGlzQXJndW1lbnRzKG9iamVjdCkpKSAmJiBsZW5ndGgpIHx8IDA7XG5cbiAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNQcm90byA9IHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIHNraXBJbmRleGVzID0gbGVuZ3RoID4gMDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IChpbmRleCArICcnKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKCEoc2tpcEluZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpICYmXG4gICAgICAgICAgICAhKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWQgYnlcbiAgICAgKiBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhyb3VnaCBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2IH1cbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0KHMpLCB0aGF0XG4gICAgICogZG9uJ3QgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlc1xuICAgICAqIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLiBJZiBgY3VzdG9taXplcmAgaXNcbiAgICAgKiBwcm92aWRlZCBpdCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZFxuICAgICAqIHNvdXJjZSBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCBtZXJnaW5nIGlzIGhhbmRsZWRcbiAgICAgKiBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCBmaXZlIGFyZ3VtZW50czogKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdkYXRhJzogW3sgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICd1c2VyJzogJ2ZyZWQnIH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBhZ2VzID0ge1xuICAgICAqICAgJ2RhdGEnOiBbeyAnYWdlJzogMzYgfSwgeyAnYWdlJzogNDAgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZSh1c2VycywgYWdlcyk7XG4gICAgICogLy8gPT4geyAnZGF0YSc6IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV0gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2FwcGxlJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnYmVldCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2JhbmFuYSddLFxuICAgICAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2NhcnJvdCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlciwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgaWYgKF8uaXNBcnJheShhKSkge1xuICAgICAqICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZnJ1aXRzJzogWydhcHBsZScsICdiYW5hbmEnXSwgJ3ZlZ2V0YWJsZXMnOiBbJ2JlZXQnLCAnY2Fycm90J10gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGJhc2VNZXJnZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAgICAgKiBQcm9wZXJ0eSBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5cyBvZlxuICAgICAqIHByb3BlcnR5IG5hbWVzLiBJZiBgcHJlZGljYXRlYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIGZvciBlYWNoIHByb3BlcnR5XG4gICAgICogb2YgYG9iamVjdGAgb21pdHRpbmcgdGhlIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGVcbiAgICAgKiBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnwuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3ByZWRpY2F0ZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbiBvciBwcm9wZXJ0eSBuYW1lcyB0byBvbWl0LCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBwcm9wZXJ0eVxuICAgICAqICBuYW1lcyBvciBhcnJheXMgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdChvYmplY3QsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ub21pdChvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIHZhciBvbWl0ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByb3BzWzBdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHByb3BzID0gYXJyYXlNYXAoYmFzZUZsYXR0ZW4ocHJvcHMpLCBTdHJpbmcpO1xuICAgICAgICByZXR1cm4gcGlja0J5QXJyYXkob2JqZWN0LCBiYXNlRGlmZmVyZW5jZShrZXlzSW4ob2JqZWN0KSwgcHJvcHMpKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcmVkaWNhdGUgPSBiaW5kQ2FsbGJhY2socHJvcHNbMF0sIHByb3BzWzFdLCAzKTtcbiAgICAgIHJldHVybiBwaWNrQnlDYWxsYmFjayhvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdHdvIGRpbWVuc2lvbmFsIGFycmF5IG9mIHRoZSBrZXktdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgLFxuICAgICAqIGUuZy4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhaXJzKHsgJ2Jhcm5leSc6IDM2LCAnZnJlZCc6IDQwIH0pO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhaXJzKG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBba2V5LCBvYmplY3Rba2V5XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy4gUHJvcGVydHlcbiAgICAgKiBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5cyBvZiBwcm9wZXJ0eVxuICAgICAqIG5hbWVzLiBJZiBgcHJlZGljYXRlYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIGZvciBlYWNoIHByb3BlcnR5IG9mIGBvYmplY3RgXG4gICAgICogcGlja2luZyB0aGUgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnwuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3ByZWRpY2F0ZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbiBvciBwcm9wZXJ0eSBuYW1lcyB0byBwaWNrLCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBwcm9wZXJ0eVxuICAgICAqICBuYW1lcyBvciBhcnJheXMgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfTtcbiAgICAgKlxuICAgICAqIF8ucGljayhvYmplY3QsICd1c2VyJyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLnBpY2sob2JqZWN0LCBfLmlzU3RyaW5nKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKi9cbiAgICB2YXIgcGljayA9IHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIHByb3BzKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiBwcm9wc1swXSA9PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGlja0J5Q2FsbGJhY2sob2JqZWN0LCBiaW5kQ2FsbGJhY2socHJvcHNbMF0sIHByb3BzWzFdLCAzKSlcbiAgICAgICAgOiBwaWNrQnlBcnJheShvYmplY3QsIGJhc2VGbGF0dGVuKHByb3BzKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmdldGAgZXhjZXB0IHRoYXQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGEgZnVuY3Rpb25cbiAgICAgKiBpdCBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGl0cyBwYXJlbnQgb2JqZWN0IGFuZCBpdHMgcmVzdWx0XG4gICAgICogaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjMSc6IDMsICdjMic6IF8uY29uc3RhbnQoNCkgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMxJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMyJyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYS5iLmMnLCBfLmNvbnN0YW50KCdkZWZhdWx0JykpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W3BhdGhdO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiAhaXNLZXkocGF0aCwgb2JqZWN0KSkge1xuICAgICAgICAgIHBhdGggPSB0b1BhdGgocGF0aCk7XG4gICAgICAgICAgb2JqZWN0ID0gcGF0aC5sZW5ndGggPT0gMSA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbiAgICAgICAgICByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtsYXN0KHBhdGgpXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHJlc3VsdCkgPyByZXN1bHQuY2FsbChvYmplY3QpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIGBwYXRoYCBvbiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYFxuICAgICAqIGRvZXMgbm90IGV4aXN0IGl0IGlzIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGF1Z21lbnQuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsICd4WzBdLnkueicsIDUpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHZhciBwYXRoS2V5ID0gKHBhdGggKyAnJyk7XG4gICAgICBwYXRoID0gKG9iamVjdFtwYXRoS2V5XSAhPSBudWxsIHx8IGlzS2V5KHBhdGgsIG9iamVjdCkpID8gW3BhdGhLZXldIDogdG9QYXRoKHBhdGgpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICBlbmRJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gICAgICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG4gICAgICAgIGlmIChpc09iamVjdChuZXN0ZWQpKSB7XG4gICAgICAgICAgaWYgKGluZGV4ID09IGVuZEluZGV4KSB7XG4gICAgICAgICAgICBuZXN0ZWRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmVzdGVkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbmVzdGVkW2tleV0gPSBpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd24gZW51bWVyYWJsZVxuICAgICAqIHByb3BlcnRpZXMgdGhyb3VnaCBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvbiBwb3RlbnRpYWxseSBtdXRhdGluZ1xuICAgICAqIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnNcbiAgICAgKiBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAgICAgKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbNCwgOV1cbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24ocmVzdWx0LCBuLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbiAqIDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XG4gICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCA0KTtcblxuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzQXJyIHx8IGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnJheShvYmplY3QpID8gbmV3IEN0b3IgOiBbXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBiYXNlQ3JlYXRlKGlzRnVuY3Rpb24oQ3RvcikgJiYgQ3Rvci5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAoaXNBcnIgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcygnaGknKTtcbiAgICAgKiAvLyA9PiBbJ2gnLCAnaSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzXG4gICAgICogb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBuYCBpcyBiZXR3ZWVuIGBzdGFydGAgYW5kIHVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gSWZcbiAgICAgKiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkIGl0IGlzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG5gIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMywgMiwgNCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDgpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDIsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMS4yLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNS4yLCA0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluUmFuZ2UodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9ICtlbmQgfHwgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA+PSBuYXRpdmVNaW4oc3RhcnQsIGVuZCkgJiYgdmFsdWUgPCBuYXRpdmVNYXgoc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIChpbmNsdXNpdmUpLiBJZiBvbmx5IG9uZVxuICAgICAqIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyIGlzIHJldHVybmVkLlxuICAgICAqIElmIGBmbG9hdGluZ2AgaXMgYHRydWVgLCBvciBlaXRoZXIgYG1pbmAgb3IgYG1heGAgYXJlIGZsb2F0cywgYSBmbG9hdGluZy1wb2ludFxuICAgICAqIG51bWJlciBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmddIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDAsIDUpO1xuICAgICAqIC8vID0+IGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1KTtcbiAgICAgKiAvLyA9PiBhbHNvIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1LCB0cnVlKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDEuMiwgNS4yKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDEuMiBhbmQgNS4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4LCBmbG9hdGluZykge1xuICAgICAgaWYgKGZsb2F0aW5nICYmIGlzSXRlcmF0ZWVDYWxsKG1pbiwgbWF4LCBmbG9hdGluZykpIHtcbiAgICAgICAgbWF4ID0gZmxvYXRpbmcgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIG5vTWluID0gbWluID09IG51bGwsXG4gICAgICAgICAgbm9NYXggPSBtYXggPT0gbnVsbDtcblxuICAgICAgaWYgKGZsb2F0aW5nID09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vTWF4ICYmIHR5cGVvZiBtaW4gPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBtaW47XG4gICAgICAgICAgbWluID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWF4ID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWF4O1xuICAgICAgICAgIG5vTWF4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vTWluICYmIG5vTWF4KSB7XG4gICAgICAgIG1heCA9IDE7XG4gICAgICAgIG5vTWF4ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBtaW4gPSArbWluIHx8IDA7XG4gICAgICBpZiAobm9NYXgpIHtcbiAgICAgICAgbWF4ID0gbWluO1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4ID0gK21heCB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nIHx8IG1pbiAlIDEgfHwgbWF4ICUgMSkge1xuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWluKG1pbiArIChyYW5kICogKG1heCAtIG1pbiArIHBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKyAnJykubGVuZ3RoIC0gMSkpKSksIG1heCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJhbmRvbShtaW4sIG1heCk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2NhbWVsIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWVsQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKi9cbiAgICB2YXIgY2FtZWxDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICh3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSkgOiB3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENhcGl0YWxpemVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FwaXRhbGl6ZSgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgKHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nIFtsYXRpbi0xIHN1cHBsZW1lbnRhcnkgbGV0dGVyc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW4tMV9TdXBwbGVtZW50XyhVbmljb2RlX2Jsb2NrKSNDaGFyYWN0ZXJfdGFibGUpXG4gICAgICogdG8gYmFzaWMgbGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmcgW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gICAgICogLy8gPT4gJ2RlamEgdnUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4xLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249c3RyaW5nLmxlbmd0aF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBlbmRzIHdpdGggYHRhcmdldGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2MnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgdGFyZ2V0ID0gKHRhcmdldCArICcnKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBsZW5ndGhcbiAgICAgICAgOiBuYXRpdmVNaW4ocG9zaXRpb24gPCAwID8gMCA6ICgrcG9zaXRpb24gfHwgMCksIGxlbmd0aCk7XG5cbiAgICAgIHBvc2l0aW9uIC09IHRhcmdldC5sZW5ndGg7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPj0gMCAmJiBzdHJpbmcuaW5kZXhPZih0YXJnZXQsIHBvc2l0aW9uKSA9PSBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBcIidcIiwgYW5kIFwiXFxgXCIsIGluIGBzdHJpbmdgIHRvXG4gICAgICogdGhlaXIgY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsIGNoYXJhY3RlcnNcbiAgICAgKiB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gICAgICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IHJlcXVpcmUgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAgICAgKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKiBTZWUgW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICAgICAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQmFja3RpY2tzIGFyZSBlc2NhcGVkIGJlY2F1c2UgaW4gSW50ZXJuZXQgRXhwbG9yZXIgPCA5LCB0aGV5IGNhbiBicmVhayBvdXRcbiAgICAgKiBvZiBhdHRyaWJ1dGUgdmFsdWVzIG9yIEhUTUwgY29tbWVudHMuIFNlZSBbIzU5XShodHRwczovL2h0bWw1c2VjLm9yZy8jNTkpLFxuICAgICAqIFsjMTAyXShodHRwczovL2h0bWw1c2VjLm9yZy8jMTAyKSwgWyMxMDhdKGh0dHBzOi8vaHRtbDVzZWMub3JnLyMxMDgpLCBhbmRcbiAgICAgKiBbIzEzM10oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEzMykgb2YgdGhlIFtIVE1MNSBTZWN1cml0eSBDaGVhdHNoZWV0XShodHRwczovL2h0bWw1c2VjLm9yZy8pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXMgW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKVxuICAgICAqIHRvIHJlZHVjZSBYU1MgdmVjdG9ycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgICAgLy8gUmVzZXQgYGxhc3RJbmRleGAgYmVjYXVzZSBpbiBJRSA8IDkgYFN0cmluZyNyZXBsYWNlYCBkb2VzIG5vdC5cbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIHRoZSBgUmVnRXhwYCBzcGVjaWFsIGNoYXJhY3RlcnMgXCJcXFwiLCBcIi9cIiwgXCJeXCIsIFwiJFwiLCBcIi5cIiwgXCJ8XCIsIFwiP1wiLFxuICAgICAqIFwiKlwiLCBcIitcIiwgXCIoXCIsIFwiKVwiLCBcIltcIiwgXCJdXCIsIFwie1wiIGFuZCBcIn1cIiBpbiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICAgICAqIC8vID0+ICdcXFtsb2Rhc2hcXF1cXChodHRwczpcXC9cXC9sb2Rhc2hcXC5jb21cXC9cXCknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1JlZ0V4cENoYXJzLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXJzLCAnXFxcXCQmJylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2tlYmFiIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICovXG4gICAgdmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICctJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIGlmIGl0IGlzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC5cbiAgICAgKiBQYWRkaW5nIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGNhbid0IGJlIGV2ZW5seSBkaXZpZGVkIGJ5IGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4KTtcbiAgICAgKiAvLyA9PiAnICBhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSArbGVuZ3RoO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGlmIChzdHJMZW5ndGggPj0gbGVuZ3RoIHx8ICFuYXRpdmVJc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbWlkID0gKGxlbmd0aCAtIHN0ckxlbmd0aCkgLyAyLFxuICAgICAgICAgIGxlZnRMZW5ndGggPSBmbG9vcihtaWQpLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gY2VpbChtaWQpO1xuXG4gICAgICBjaGFycyA9IGNyZWF0ZVBhZGRpbmcoJycsIHJpZ2h0TGVuZ3RoLCBjaGFycyk7XG4gICAgICByZXR1cm4gY2hhcnMuc2xpY2UoMCwgbGVmdExlbmd0aCkgKyBzdHJpbmcgKyBjaGFycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IHNpZGUgaWYgaXQgaXMgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkTGVmdCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJyAgIGFiYydcbiAgICAgKlxuICAgICAqIF8ucGFkTGVmdCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tX2FiYydcbiAgICAgKlxuICAgICAqIF8ucGFkTGVmdCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICB2YXIgcGFkTGVmdCA9IGNyZWF0ZVBhZERpcigpO1xuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgcmlnaHQgc2lkZSBpZiBpdCBpcyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRSaWdodCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJ2FiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkUmlnaHQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZFJpZ2h0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIHZhciBwYWRSaWdodCA9IGNyZWF0ZVBhZERpcih0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC4gSWYgYHJhZGl4YCBpc1xuICAgICAqIGB1bmRlZmluZWRgIG9yIGAwYCwgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgYHZhbHVlYCBpcyBhIGhleGFkZWNpbWFsLFxuICAgICAqIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhbGlnbnMgd2l0aCB0aGUgW0VTNSBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyNFKVxuICAgICAqIG9mIGBwYXJzZUludGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeF0gVGhlIHJhZGl4IHRvIGludGVycHJldCBgdmFsdWVgIGJ5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHJhZGl4LCBndWFyZCkpIHtcbiAgICAgICAgcmFkaXggPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHN0cmluZywgcmFkaXgpO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayBmb3IgZW52aXJvbm1lbnRzIHdpdGggcHJlLUVTNSBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKG5hdGl2ZVBhcnNlSW50KHdoaXRlc3BhY2UgKyAnMDgnKSAhPSA4KSB7XG4gICAgICBwYXJzZUludCA9IGZ1bmN0aW9uKHN0cmluZywgcmFkaXgsIGd1YXJkKSB7XG4gICAgICAgIC8vIEZpcmVmb3ggPCAyMSBhbmQgT3BlcmEgPCAxNSBmb2xsb3cgRVMzIGZvciBgcGFyc2VJbnRgLlxuICAgICAgICAvLyBDaHJvbWUgZmFpbHMgdG8gdHJpbSBsZWFkaW5nIDxCT00+IHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTA5IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgcmFkaXgsIGd1YXJkKSA6IHJhZGl4ID09IG51bGwpIHtcbiAgICAgICAgICByYWRpeCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAocmFkaXgpIHtcbiAgICAgICAgICByYWRpeCA9ICtyYWRpeDtcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmcgPSB0cmltKHN0cmluZyk7XG4gICAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludChzdHJpbmcsIHJhZGl4IHx8IChyZUhhc0hleFByZWZpeC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGVhdHMgdGhlIGdpdmVuIHN0cmluZyBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBlYXQoJyonLCAzKTtcbiAgICAgKiAvLyA9PiAnKioqJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDIpO1xuICAgICAqIC8vID0+ICdhYmNhYmMnXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIG4gPSArbjtcbiAgICAgIGlmIChuIDwgMSB8fCAhc3RyaW5nIHx8ICFuYXRpdmVJc0Zpbml0ZShuKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gTGV2ZXJhZ2UgdGhlIGV4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nIGFsZ29yaXRobSBmb3IgYSBmYXN0ZXIgcmVwZWF0LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4cG9uZW50aWF0aW9uX2J5X3NxdWFyaW5nIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGZsb29yKG4gLyAyKTtcbiAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgIH0gd2hpbGUgKG4pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtzbmFrZSBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbmFrZV9jYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKi9cbiAgICB2YXIgc25ha2VDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJ18nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW3N0YXJ0IGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1N0eWxpc3RpY19vcl9zcGVjaWFsaXNlZF91c2FnZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdGFydCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqL1xuICAgIHZhciBzdGFydENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyAod29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249MF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCBgdGFyZ2V0YCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT0gbnVsbFxuICAgICAgICA/IDBcbiAgICAgICAgOiBuYXRpdmVNaW4ocG9zaXRpb24gPCAwID8gMCA6ICgrcG9zaXRpb24gfHwgMCksIHN0cmluZy5sZW5ndGgpO1xuXG4gICAgICByZXR1cm4gc3RyaW5nLmxhc3RJbmRleE9mKHRhcmdldCwgcG9zaXRpb24pID09IHBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAgICAgKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICAgICAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICAgICAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gICAgICogb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICAgICAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICAgICAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAgICAgKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAgICAgKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGVdIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZV0gVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHNdIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlXSBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMXSBUaGUgc291cmNlVVJMIG9mIHRoZSB0ZW1wbGF0ZSdzIGNvbXBpbGVkIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGVdIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW290aGVyT3B0aW9uc10gRW5hYmxlcyB0aGUgbGVnYWN5IGBvcHRpb25zYCBwYXJhbSBzaWduYXR1cmUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlc1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gICAgICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTFxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVyc1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIEVTIGRlbGltaXRlciBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgZGVmYXVsdCBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dFxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWBcbiAgICAgKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gICAgICogY29tcGlsZWQoZGF0YSk7XG4gICAgICogLy8gPT4gZmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3RvclxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAgICAgKiBjb21waWxlZC5zb3VyY2U7XG4gICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gICAgICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gICAgICogLy8gICByZXR1cm4gX19wO1xuICAgICAqIC8vIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBhIHN0YWNrIHRyYWNlXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4oY3dkLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgb3RoZXJPcHRpb25zKSB7XG4gICAgICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICAgICAgdmFyIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgICAgIGlmIChvdGhlck9wdGlvbnMgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBvdGhlck9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvdGhlck9wdGlvbnMgPSBudWxsO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBvcHRpb25zID0gYXNzaWduV2l0aChiYXNlQXNzaWduKHt9LCBvdGhlck9wdGlvbnMgfHwgb3B0aW9ucyksIHNldHRpbmdzLCBhc3NpZ25Pd25EZWZhdWx0cyk7XG5cbiAgICAgIHZhciBpbXBvcnRzID0gYXNzaWduV2l0aChiYXNlQXNzaWduKHt9LCBvcHRpb25zLmltcG9ydHMpLCBzZXR0aW5ncy5pbXBvcnRzLCBhc3NpZ25Pd25EZWZhdWx0cyksXG4gICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICAgICAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICcvLyMgc291cmNlVVJMPScgK1xuICAgICAgICAoJ3NvdXJjZVVSTCcgaW4gb3B0aW9uc1xuICAgICAgICAgID8gb3B0aW9ucy5zb3VyY2VVUkxcbiAgICAgICAgICA6ICgnbG9kYXNoLnRlbXBsYXRlU291cmNlc1snICsgKCsrdGVtcGxhdGVDb3VudGVyKSArICddJylcbiAgICAgICAgKSArICdcXG4nO1xuXG4gICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAgICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgcmVxdWlyZXMgcmV0dXJuaW5nIHRoZSBgbWF0Y2hgXG4gICAgICAgIC8vIHN0cmluZyBpbiBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAgICAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICAgICAgdmFyIHZhcmlhYmxlID0gb3B0aW9ucy52YXJpYWJsZTtcbiAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gICAgICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgICAgIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG4gICAgICAgICh2YXJpYWJsZVxuICAgICAgICAgID8gJydcbiAgICAgICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgICAgICAoaXNFc2NhcGluZ1xuICAgICAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgICAgICA6ICcnXG4gICAgICAgICkgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKS5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAgICAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBpZiAoaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbSgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLm1hcChbJyAgZm9vICAnLCAnICBiYXIgICddLCBfLnRyaW0pO1xuICAgICAqIC8vID0+IFsnZm9vJywgJ2JhciddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgdmFyIHZhbHVlID0gc3RyaW5nO1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoIXN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGNoYXJzLCBndWFyZCkgOiBjaGFycyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UodHJpbW1lZExlZnRJbmRleChzdHJpbmcpLCB0cmltbWVkUmlnaHRJbmRleChzdHJpbmcpICsgMSk7XG4gICAgICB9XG4gICAgICBjaGFycyA9IChjaGFycyArICcnKTtcbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoY2hhcnNMZWZ0SW5kZXgoc3RyaW5nLCBjaGFycyksIGNoYXJzUmlnaHRJbmRleChzdHJpbmcsIGNoYXJzKSArIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbUxlZnQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjICAnXG4gICAgICpcbiAgICAgKiBfLnRyaW1MZWZ0KCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjLV8tJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1MZWZ0KHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdHJpbmc7XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmICghc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgY2hhcnMsIGd1YXJkKSA6IGNoYXJzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSh0cmltbWVkTGVmdEluZGV4KHN0cmluZykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShjaGFyc0xlZnRJbmRleChzdHJpbmcsIChjaGFycyArICcnKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1SaWdodCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICcgIGFiYydcbiAgICAgKlxuICAgICAqIF8udHJpbVJpZ2h0KCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnLV8tYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1SaWdodChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgdmFyIHZhbHVlID0gc3RyaW5nO1xuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoIXN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGNoYXJzLCBndWFyZCkgOiBjaGFycyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZFJpZ2h0SW5kZXgoc3RyaW5nKSArIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCBjaGFyc1JpZ2h0SW5kZXgoc3RyaW5nLCAoY2hhcnMgKyAnJykpICsgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIGBzdHJpbmdgIGlmIGl0IGlzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogVGhlIGxhc3QgY2hhcmFjdGVycyBvZiB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgb21pc3Npb25cbiAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXCIuLi5cIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cnVuY2F0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxudW1iZXJ9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3Qgb3IgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MzBdIFRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9taXNzaW9uPScuLi4nXSBUaGUgc3RyaW5nIHRvIGluZGljYXRlIHRleHQgaXMgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtvcHRpb25zLnNlcGFyYXRvcl0gVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHRydW5jYXRlIHRvLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRydW5jYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nKTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIDI0KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuYygnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAnICdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLC4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogLyw/ICsvXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZS4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnb21pc3Npb24nOiAnIFsuLi5dJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWcgWy4uLl0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmMoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IERFRkFVTFRfVFJVTkNfTEVOR1RILFxuICAgICAgICAgIG9taXNzaW9uID0gREVGQVVMVF9UUlVOQ19PTUlTU0lPTjtcblxuICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogc2VwYXJhdG9yO1xuICAgICAgICAgIGxlbmd0aCA9ICdsZW5ndGgnIGluIG9wdGlvbnMgPyAoK29wdGlvbnMubGVuZ3RoIHx8IDApIDogbGVuZ3RoO1xuICAgICAgICAgIG9taXNzaW9uID0gJ29taXNzaW9uJyBpbiBvcHRpb25zID8gYmFzZVRvU3RyaW5nKG9wdGlvbnMub21pc3Npb24pIDogb21pc3Npb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVuZ3RoID0gK29wdGlvbnMgfHwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAobGVuZ3RoID49IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBlbmQgPSBsZW5ndGggLSBvbWlzc2lvbi5sZW5ndGg7XG4gICAgICBpZiAoZW5kIDwgMSkge1xuICAgICAgICByZXR1cm4gb21pc3Npb247XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG4gICAgICBpZiAoc2VwYXJhdG9yID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoLFxuICAgICAgICAgICAgICBuZXdFbmQsXG4gICAgICAgICAgICAgIHN1YnN0cmluZyA9IHN0cmluZy5zbGljZSgwLCBlbmQpO1xuXG4gICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgKHJlRmxhZ3MuZXhlYyhzZXBhcmF0b3IpIHx8ICcnKSArICdnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdWJzdHJpbmcpKSkge1xuICAgICAgICAgICAgbmV3RW5kID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBuZXdFbmQgPT0gbnVsbCA/IGVuZCA6IG5ld0VuZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmluZGV4T2Yoc2VwYXJhdG9yLCBlbmQpICE9IGVuZCkge1xuICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYDsgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGAmIzM5O2AsIGFuZCBgJiM5NjtgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIEhUTUwgZW50aXRpZXMgYXJlIHVuZXNjYXBlZC4gVG8gdW5lc2NhcGUgYWRkaXRpb25hbCBIVE1MXG4gICAgICogZW50aXRpZXMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNFc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkpIHtcbiAgICAgICAgcGF0dGVybiA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybiB8fCByZVdvcmRzKSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICAgICAqIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBgZnVuY2AgcmVzdWx0IG9yIGVycm9yIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgdGhyb3dpbmcgZXJyb3JzIGZvciBpbnZhbGlkIHNlbGVjdG9yc1xuICAgICAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAqIH0sICc+Xz4nKTtcbiAgICAgKlxuICAgICAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gICAgICogICBlbGVtZW50cyA9IFtdO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICB2YXIgYXR0ZW1wdCA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYFxuICAgICAqIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5IG5hbWUgdGhlXG4gICAgICogY3JlYXRlZCBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LiBJZiBgZnVuY2BcbiAgICAgKiBpcyBhbiBvYmplY3QgdGhlIGNyZWF0ZWQgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgY29udGFpblxuICAgICAqIHRoZSBlcXVpdmFsZW50IG9iamVjdCBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGl0ZXJhdGVlXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3cmFwIHRvIGNyZWF0ZSBjdXN0b20gY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIF8uY2FsbGJhY2sgPSBfLndyYXAoXy5jYWxsYmFjaywgZnVuY3Rpb24oY2FsbGJhY2ssIGZ1bmMsIHRoaXNBcmcpIHtcbiAgICAgKiAgIHZhciBtYXRjaCA9IC9eKC4rPylfXyhbZ2xddCkoLispJC8uZXhlYyhmdW5jKTtcbiAgICAgKiAgIGlmICghbWF0Y2gpIHtcbiAgICAgKiAgICAgcmV0dXJuIGNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcpO1xuICAgICAqICAgfVxuICAgICAqICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgICByZXR1cm4gbWF0Y2hbMl0gPT0gJ2d0J1xuICAgICAqICAgICAgID8gb2JqZWN0W21hdGNoWzFdXSA+IG1hdGNoWzNdXG4gICAgICogICAgICAgOiBvYmplY3RbbWF0Y2hbMV1dIDwgbWF0Y2hbM107XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIodXNlcnMsICdhZ2VfX2d0MzYnKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsbGJhY2soZnVuYywgdGhpc0FyZywgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChmdW5jLCB0aGlzQXJnLCBndWFyZCkpIHtcbiAgICAgICAgdGhpc0FyZyA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgZ2V0dGVyID0gXy5jb25zdGFudChvYmplY3QpO1xuICAgICAqXG4gICAgICogZ2V0dGVyKCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0O1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB3aGljaCBwZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGEgZ2l2ZW4gb2JqZWN0XG4gICAgICogYW5kIGBzb3VyY2VgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGVxdWl2YWxlbnQgcHJvcGVydHlcbiAgICAgKiB2YWx1ZXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG4gICAgICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZvciBjb21wYXJpbmcgYSBzaW5nbGVcbiAgICAgKiBvd24gb3IgaW5oZXJpdGVkIHByb3BlcnR5IHZhbHVlIHNlZSBgXy5tYXRjaGVzUHJvcGVydHlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5tYXRjaGVzKHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXMoYmFzZUNsb25lKHNvdXJjZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB3aGljaCBjb21wYXJlcyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgYHBhdGhgIG9uIGEgZ2l2ZW5cbiAgICAgKiBvYmplY3QgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG4gICAgICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKHVzZXJzLCBfLm1hdGNoZXNQcm9wZXJ0eSgndXNlcicsICdmcmVkJykpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNQcm9wZXJ0eShwYXRoLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgYmFzZUNsb25lKHZhbHVlLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHdoaWNoIGludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb24gYSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogeyAnYyc6IF8uY29uc3RhbnQoMikgfSB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IHsgJ2MnOiBfLmNvbnN0YW50KDEpIH0gfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKCdhLmIuYycpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlKF8uc29ydEJ5KG9iamVjdHMsIF8ubWV0aG9kKFsnYScsICdiJywgJ2MnXSkpLCAnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kID0gcmVzdFBhcmFtKGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGludm9rZVBhdGgob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tZXRob2RgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggaW52b2tlc1xuICAgICAqIHRoZSBtZXRob2QgYXQgYSBnaXZlbiBwYXRoIG9uIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IF8udGltZXMoMywgXy5jb25zdGFudCksXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kT2YgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gaW52b2tlUGF0aChvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIG93biBlbnVtZXJhYmxlIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiB0aGVuIG1ldGhvZHMgYXJlIGFkZGVkIHRvXG4gICAgICogaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVzZSBgXy5ydW5JbkNvbnRleHRgIHRvIGNyZWF0ZSBhIHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHRvXG4gICAgICogYXZvaWQgY29uZmxpY3RzIGNhdXNlZCBieSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gW29iamVjdD1sb2Rhc2hdIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgdGhlIGZ1bmN0aW9ucyBhZGRlZFxuICAgICAqICBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHZvd2VscyhzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBfLmZpbHRlcihzdHJpbmcsIGZ1bmN0aW9uKHYpIHtcbiAgICAgKiAgICAgcmV0dXJuIC9bYWVpb3VdL2kudGVzdCh2KTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIHVzZSBgXy5ydW5JbkNvbnRleHRgIHRvIGF2b2lkIGNvbmZsaWN0cyAoZXNwLiBpbiBOb2RlLmpzKVxuICAgICAqIHZhciBfID0gcmVxdWlyZSgnbG9kYXNoJykucnVuSW5Db250ZXh0KCk7XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcbiAgICAgKiBfLnZvd2VscygnZnJlZCcpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNPYmogPSBpc09iamVjdChzb3VyY2UpLFxuICAgICAgICAgICAgcHJvcHMgPSBpc09iaiAmJiBrZXlzKHNvdXJjZSksXG4gICAgICAgICAgICBtZXRob2ROYW1lcyA9IHByb3BzICYmIHByb3BzLmxlbmd0aCAmJiBiYXNlRnVuY3Rpb25zKHNvdXJjZSwgcHJvcHMpO1xuXG4gICAgICAgIGlmICghKG1ldGhvZE5hbWVzID8gbWV0aG9kTmFtZXMubGVuZ3RoIDogaXNPYmopKSB7XG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBmYWxzZTtcbiAgICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgICBvYmplY3QgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW1ldGhvZE5hbWVzKSB7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhaW4gPSB0cnVlLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IG1ldGhvZE5hbWVzLmxlbmd0aDtcblxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNoYWluID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykge1xuICAgICAgICBjaGFpbiA9IG9wdGlvbnMuY2hhaW47XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IG1ldGhvZE5hbWVzW2luZGV4XSxcbiAgICAgICAgICAgIGZ1bmMgPSBzb3VyY2VbbWV0aG9kTmFtZV07XG5cbiAgICAgICAgb2JqZWN0W21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSAoZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IHJlc3VsdC5fX2FjdGlvbnNfXyA9IGFycmF5Q29weSh0aGlzLl9fYWN0aW9uc19fKTtcblxuICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7ICdmdW5jJzogZnVuYywgJ2FyZ3MnOiBhcmd1bWVudHMsICd0aGlzQXJnJzogb2JqZWN0IH0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gW3RoaXMudmFsdWUoKV07XG4gICAgICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqZWN0LCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfShmdW5jKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICBjb250ZXh0Ll8gPSBvbGREYXNoO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBuby1vcGVyYXRpb24gZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBgdW5kZWZpbmVkYCByZWdhcmRsZXNzIG9mIHRoZVxuICAgICAqIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiBfLm5vb3Aob2JqZWN0KSA9PT0gdW5kZWZpbmVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgYXQgYHBhdGhgIG9uIGFcbiAgICAgKiBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiB7ICdjJzogMiB9IH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogeyAnYyc6IDEgfSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iLmMnKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLnBsdWNrKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InLCAnYyddKSksICdhLmIuYycpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eShwYXRoKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnByb3BlcnR5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnNcbiAgICAgKiB0aGUgcHJvcGVydHkgdmFsdWUgYXQgYSBnaXZlbiBwYXRoIG9uIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFswLCAxLCAyXSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCB0b1BhdGgocGF0aCksIHBhdGggKyAnJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkIGl0IGlzXG4gICAgICogc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC4gSWYgYGVuZGAgaXMgbGVzcyB0aGFuIGBzdGFydGBcbiAgICAgKiBhIHplcm8tbGVuZ3RoIHJhbmdlIGlzIGNyZWF0ZWQgdW5sZXNzIGEgbmVnYXRpdmUgYHN0ZXBgIGlzIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIG51bWJlcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgaWYgKHN0ZXAgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgICAgZW5kID0gc3RlcCA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdGFydCA9ICtzdGFydCB8fCAwO1xuICAgICAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiAoK3N0ZXAgfHwgMCk7XG5cbiAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gK2VuZCB8fCAwO1xuICAgICAgfVxuICAgICAgLy8gVXNlIGBBcnJheShsZW5ndGgpYCBzbyBlbmdpbmVzIGxpa2UgQ2hha3JhIGFuZCBWOCBhdm9pZCBzbG93ZXIgbW9kZXMuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly95b3V0dS5iZS9YQXFJcEdVOFpaayN0PTE3bTI1cyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBpdGVyYXRlZSBmdW5jdGlvbiBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0c1xuICAgICAqIG9mIGVhY2ggaW52b2NhdGlvbi4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZGljZVJvbGxzID0gXy50aW1lcygzLCBfLnBhcnRpYWwoXy5yYW5kb20sIDEsIDYsIGZhbHNlKSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDRdXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIG1hZ2UuY2FzdFNwZWxsKG4pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGludm9rZXMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lcyB3aXRoIGBuYCBvZiBgMGAsIGAxYCwgYW5kIGAyYFxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBmdW5jdGlvbihuKSB7XG4gICAgICogICB0aGlzLmNhc3Qobik7XG4gICAgICogfSwgbWFnZSk7XG4gICAgICogLy8gPT4gYWxzbyBpbnZva2VzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgbiA9IGZsb29yKG4pO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IHRvIGF2b2lkIGEgSlNDIEpJVCBidWcgaW4gU2FmYXJpIDhcbiAgICAgIC8vIHdoZXJlIGBBcnJheSgwKWAgaXMgdHJlYXRlZCBhcyBgQXJyYXkoMSlgLlxuICAgICAgaWYgKG4gPCAxIHx8ICFuYXRpdmVJc0Zpbml0ZShuKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCkpO1xuXG4gICAgICBpdGVyYXRlZSA9IGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgaWYgKGluZGV4IDwgTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgcHJvdmlkZWQgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeF0gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiBiYXNlVG9TdHJpbmcocHJlZml4KSArIGlkO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdWdlbmQgVGhlIGZpcnN0IG51bWJlciB0byBhZGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGVuZCBUaGUgc2Vjb25kIG51bWJlciB0byBhZGQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFkZCg2LCA0KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZChhdWdlbmQsIGFkZGVuZCkge1xuICAgICAgcmV0dXJuICgrYXVnZW5kIHx8IDApICsgKCthZGRlbmQgfHwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBlbXB0eSBvciBmYWxzZXlcbiAgICAgKiBgLUluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYW4gaXRlcmF0ZWUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIGBjb2xsZWN0aW9uYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWF4KFtdKTtcbiAgICAgKiAvLyA9PiAtSW5maW5pdHlcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWF4KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWF4KHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAgICAgKi9cbiAgICB2YXIgbWF4ID0gY3JlYXRlRXh0cmVtdW0oYXJyYXlNYXgpO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBlbXB0eSBvciBmYWxzZXlcbiAgICAgKiBgSW5maW5pdHlgIGlzIHJldHVybmVkLiBJZiBhbiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkXG4gICAgICogZm9yIGVhY2ggdmFsdWUgaW4gYGNvbGxlY3Rpb25gIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG4gICAgICogaXMgcmFua2VkLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG4gICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG4gICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG4gICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5taW4oW10pO1xuICAgICAqIC8vID0+IEluZmluaXR5XG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1pbih1c2VycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWluKHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqL1xuICAgIHZhciBtaW4gPSBjcmVhdGVFeHRyZW11bShhcnJheU1pbiwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1bShbNCwgNl0pO1xuICAgICAqIC8vID0+IDEwXG4gICAgICpcbiAgICAgKiBfLnN1bSh7ICdhJzogNCwgJ2InOiA2IH0pO1xuICAgICAqIC8vID0+IDEwXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ24nOiA0IH0sXG4gICAgICogICB7ICduJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uc3VtKG9iamVjdHMsIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgcmV0dXJuIG9iamVjdC5uO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDEwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc3VtKG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW0oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcbiAgICAgIGlmICh0aGlzQXJnICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSkge1xuICAgICAgICBpdGVyYXRlZSA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IGdldENhbGxiYWNrKCksXG4gICAgICAgICAgbm9JdGVyYXRlZSA9IGl0ZXJhdGVlID09IG51bGw7XG5cbiAgICAgIGlmICghKGZ1bmMgPT09IGJhc2VDYWxsYmFjayAmJiBub0l0ZXJhdGVlKSkge1xuICAgICAgICBub0l0ZXJhdGVlID0gZmFsc2U7XG4gICAgICAgIGl0ZXJhdGVlID0gZnVuYyhpdGVyYXRlZSwgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9JdGVyYXRlZVxuICAgICAgICA/IGFycmF5U3VtKGlzQXJyYXkoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdG9JdGVyYWJsZShjb2xsZWN0aW9uKSlcbiAgICAgICAgOiBiYXNlU3VtKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBFbnN1cmUgd3JhcHBlcnMgYXJlIGluc3RhbmNlcyBvZiBgYmFzZUxvZGFzaGAuXG4gICAgbG9kYXNoLnByb3RvdHlwZSA9IGJhc2VMb2Rhc2gucHJvdG90eXBlO1xuXG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvZGFzaFdyYXBwZXI7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXp5V3JhcHBlcjtcblxuICAgIC8vIEFkZCBmdW5jdGlvbnMgdG8gdGhlIGBNYXBgIGNhY2hlLlxuICAgIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBEZWxldGU7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcEdldDtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwSGFzO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBTZXQ7XG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRvIHRoZSBgU2V0YCBjYWNoZS5cbiAgICBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IGNhY2hlUHVzaDtcblxuICAgIC8vIEFzc2lnbiBjYWNoZSB0byBgXy5tZW1vaXplYC5cbiAgICBtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmcuXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFyeSA9IGFyeTtcbiAgICBsb2Rhc2guYXNzaWduID0gYXNzaWduO1xuICAgIGxvZGFzaC5hdCA9IGF0O1xuICAgIGxvZGFzaC5iZWZvcmUgPSBiZWZvcmU7XG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICAgIGxvZGFzaC5iaW5kQWxsID0gYmluZEFsbDtcbiAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgbG9kYXNoLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gICAgbG9kYXNoLmNodW5rID0gY2h1bms7XG4gICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5jdXJyeVJpZ2h0ID0gY3VycnlSaWdodDtcbiAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuICAgIGxvZGFzaC5kcm9wUmlnaHQgPSBkcm9wUmlnaHQ7XG4gICAgbG9kYXNoLmRyb3BSaWdodFdoaWxlID0gZHJvcFJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcbiAgICBsb2Rhc2guZmlsbCA9IGZpbGw7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZsYXR0ZW5EZWVwID0gZmxhdHRlbkRlZXA7XG4gICAgbG9kYXNoLmZsb3cgPSBmbG93O1xuICAgIGxvZGFzaC5mbG93UmlnaHQgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluZGV4QnkgPSBpbmRleEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLmtleXNJbiA9IGtleXNJbjtcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGxvZGFzaC5tYXRjaGVzUHJvcGVydHkgPSBtYXRjaGVzUHJvcGVydHk7XG4gICAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICAgIGxvZGFzaC5tZXRob2QgPSBtZXRob2Q7XG4gICAgbG9kYXNoLm1ldGhvZE9mID0gbWV0aG9kT2Y7XG4gICAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gICAgbG9kYXNoLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5wYWlycyA9IHBhaXJzO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4gICAgbG9kYXNoLnBpY2sgPSBwaWNrO1xuICAgIGxvZGFzaC5wbHVjayA9IHBsdWNrO1xuICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eU9mID0gcHJvcGVydHlPZjtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnB1bGxBdCA9IHB1bGxBdDtcbiAgICBsb2Rhc2gucmFuZ2UgPSByYW5nZTtcbiAgICBsb2Rhc2gucmVhcmcgPSByZWFyZztcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgbG9kYXNoLnJlc3QgPSByZXN0O1xuICAgIGxvZGFzaC5yZXN0UGFyYW0gPSByZXN0UGFyYW07XG4gICAgbG9kYXNoLnNldCA9IHNldDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNsaWNlID0gc2xpY2U7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2guc29ydEJ5QWxsID0gc29ydEJ5QWxsO1xuICAgIGxvZGFzaC5zb3J0QnlPcmRlciA9IHNvcnRCeU9yZGVyO1xuICAgIGxvZGFzaC5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgbG9kYXNoLnRha2UgPSB0YWtlO1xuICAgIGxvZGFzaC50YWtlUmlnaHQgPSB0YWtlUmlnaHQ7XG4gICAgbG9kYXNoLnRha2VSaWdodFdoaWxlID0gdGFrZVJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLnRha2VXaGlsZSA9IHRha2VXaGlsZTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aHJ1ID0gdGhydTtcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRvUGxhaW5PYmplY3QgPSB0b1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICAgIGxvZGFzaC51bnppcCA9IHVuemlwO1xuICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgbG9kYXNoLnZhbHVlc0luID0gdmFsdWVzSW47XG4gICAgbG9kYXNoLndoZXJlID0gd2hlcmU7XG4gICAgbG9kYXNoLndpdGhvdXQgPSB3aXRob3V0O1xuICAgIGxvZGFzaC53cmFwID0gd3JhcDtcbiAgICBsb2Rhc2gueG9yID0geG9yO1xuICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgbG9kYXNoLnppcE9iamVjdCA9IHppcE9iamVjdDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5iYWNrZmxvdyA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guY29sbGVjdCA9IG1hcDtcbiAgICBsb2Rhc2guY29tcG9zZSA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduO1xuICAgIGxvZGFzaC5pdGVyYXRlZSA9IGNhbGxiYWNrO1xuICAgIGxvZGFzaC5tZXRob2RzID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5vYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnNlbGVjdCA9IGZpbHRlcjtcbiAgICBsb2Rhc2gudGFpbCA9IHJlc3Q7XG4gICAgbG9kYXNoLnVuaXF1ZSA9IHVuaXE7XG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBtaXhpbihsb2Rhc2gsIGxvZGFzaCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZy5cbiAgICBsb2Rhc2guYWRkID0gYWRkO1xuICAgIGxvZGFzaC5hdHRlbXB0ID0gYXR0ZW1wdDtcbiAgICBsb2Rhc2guY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuICAgIGxvZGFzaC5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgIGxvZGFzaC5kZWJ1cnIgPSBkZWJ1cnI7XG4gICAgbG9kYXNoLmVuZHNXaXRoID0gZW5kc1dpdGg7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5maW5kID0gZmluZDtcbiAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcbiAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XG4gICAgbG9kYXNoLmZpbmRXaGVyZSA9IGZpbmRXaGVyZTtcbiAgICBsb2Rhc2guZmlyc3QgPSBmaXJzdDtcbiAgICBsb2Rhc2guZ2V0ID0gZ2V0O1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluY2x1ZGVzID0gaW5jbHVkZXM7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pblJhbmdlID0gaW5SYW5nZTtcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgICBsb2Rhc2guaXNFcnJvciA9IGlzRXJyb3I7XG4gICAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOYXRpdmUgPSBpc05hdGl2ZTtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuICAgIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIGxvZGFzaC5rZWJhYkNhc2UgPSBrZWJhYkNhc2U7XG4gICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5tYXggPSBtYXg7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhZCA9IHBhZDtcbiAgICBsb2Rhc2gucGFkTGVmdCA9IHBhZExlZnQ7XG4gICAgbG9kYXNoLnBhZFJpZ2h0ID0gcGFkUmlnaHQ7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXBlYXQgPSByZXBlYXQ7XG4gICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcbiAgICBsb2Rhc2gucnVuSW5Db250ZXh0ID0gcnVuSW5Db250ZXh0O1xuICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICBsb2Rhc2guc25ha2VDYXNlID0gc25ha2VDYXNlO1xuICAgIGxvZGFzaC5zb21lID0gc29tZTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4ID0gc29ydGVkTGFzdEluZGV4O1xuICAgIGxvZGFzaC5zdGFydENhc2UgPSBzdGFydENhc2U7XG4gICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuICAgIGxvZGFzaC5zdW0gPSBzdW07XG4gICAgbG9kYXNoLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgbG9kYXNoLnRyaW0gPSB0cmltO1xuICAgIGxvZGFzaC50cmltTGVmdCA9IHRyaW1MZWZ0O1xuICAgIGxvZGFzaC50cmltUmlnaHQgPSB0cmltUmlnaHQ7XG4gICAgbG9kYXNoLnRydW5jID0gdHJ1bmM7XG4gICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgbG9kYXNoLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgbG9kYXNoLndvcmRzID0gd29yZHM7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guYWxsID0gZXZlcnk7XG4gICAgbG9kYXNoLmFueSA9IHNvbWU7XG4gICAgbG9kYXNoLmNvbnRhaW5zID0gaW5jbHVkZXM7XG4gICAgbG9kYXNoLmRldGVjdCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZvbGRsID0gcmVkdWNlO1xuICAgIGxvZGFzaC5mb2xkciA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5oZWFkID0gZmlyc3Q7XG4gICAgbG9kYXNoLmluY2x1ZGUgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5qZWN0ID0gcmVkdWNlO1xuXG4gICAgbWl4aW4obG9kYXNoLCAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0ge307XG4gICAgICBiYXNlRm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpKSwgZmFsc2UpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIGZ1bmN0aW9ucyBjYXBhYmxlIG9mIHJldHVybmluZyB3cmFwcGVkIGFuZCB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmcuXG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcblxuICAgIGxvZGFzaC5wcm90b3R5cGUuc2FtcGxlID0gZnVuY3Rpb24obikge1xuICAgICAgaWYgKCF0aGlzLl9fY2hhaW5fXyAmJiBuID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZSh0aGlzLnZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gc2FtcGxlKHZhbHVlLCBuKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKi9cbiAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgICAvLyBBc3NpZ24gZGVmYXVsdCBwbGFjZWhvbGRlcnMuXG4gICAgYXJyYXlFYWNoKFsnYmluZCcsICdiaW5kS2V5JywgJ2N1cnJ5JywgJ2N1cnJ5UmlnaHQnLCAncGFydGlhbCcsICdwYXJ0aWFsUmlnaHQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgbG9kYXNoW21ldGhvZE5hbWVdLnBsYWNlaG9sZGVyID0gbG9kYXNoO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0aGF0IGFjY2VwdCBhbiBgaXRlcmF0ZWVgIHZhbHVlLlxuICAgIGFycmF5RWFjaChbJ2Ryb3BXaGlsZScsICdmaWx0ZXInLCAnbWFwJywgJ3Rha2VXaGlsZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCB0eXBlKSB7XG4gICAgICB2YXIgaXNGaWx0ZXIgPSB0eXBlICE9IExBWllfTUFQX0ZMQUcsXG4gICAgICAgICAgaXNEcm9wV2hpbGUgPSB0eXBlID09IExBWllfRFJPUF9XSElMRV9GTEFHO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihpdGVyYXRlZSwgdGhpc0FyZykge1xuICAgICAgICB2YXIgZmlsdGVyZWQgPSB0aGlzLl9fZmlsdGVyZWRfXyxcbiAgICAgICAgICAgIHJlc3VsdCA9IChmaWx0ZXJlZCAmJiBpc0Ryb3BXaGlsZSkgPyBuZXcgTGF6eVdyYXBwZXIodGhpcykgOiB0aGlzLmNsb25lKCksXG4gICAgICAgICAgICBpdGVyYXRlZXMgPSByZXN1bHQuX19pdGVyYXRlZXNfXyB8fCAocmVzdWx0Ll9faXRlcmF0ZWVzX18gPSBbXSk7XG5cbiAgICAgICAgaXRlcmF0ZWVzLnB1c2goe1xuICAgICAgICAgICdkb25lJzogZmFsc2UsXG4gICAgICAgICAgJ2NvdW50JzogMCxcbiAgICAgICAgICAnaW5kZXgnOiAwLFxuICAgICAgICAgICdpdGVyYXRlZSc6IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAxKSxcbiAgICAgICAgICAnbGltaXQnOiAtMSxcbiAgICAgICAgICAndHlwZSc6IHR5cGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IGZpbHRlcmVkIHx8IGlzRmlsdGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmRyb3BgIGFuZCBgXy50YWtlYCB2YXJpYW50cy5cbiAgICBhcnJheUVhY2goWydkcm9wJywgJ3Rha2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB3aGlsZU5hbWUgPSBtZXRob2ROYW1lICsgJ1doaWxlJztcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICB2YXIgZmlsdGVyZWQgPSB0aGlzLl9fZmlsdGVyZWRfXyxcbiAgICAgICAgICAgIHJlc3VsdCA9IChmaWx0ZXJlZCAmJiAhaW5kZXgpID8gdGhpcy5kcm9wV2hpbGUoKSA6IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBuID0gbiA9PSBudWxsID8gMSA6IG5hdGl2ZU1heChmbG9vcihuKSB8fCAwLCAwKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkKSB7XG4gICAgICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IG5hdGl2ZU1pbihyZXN1bHQuX190YWtlQ291bnRfXywgbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3QocmVzdWx0Ll9faXRlcmF0ZWVzX18pLmxpbWl0ID0gbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHZpZXdzID0gcmVzdWx0Ll9fdmlld3NfXyB8fCAocmVzdWx0Ll9fdmlld3NfXyA9IFtdKTtcbiAgICAgICAgICB2aWV3cy5wdXNoKHsgJ3NpemUnOiBuLCAndHlwZSc6IG1ldGhvZE5hbWUgKyAocmVzdWx0Ll9fZGlyX18gPCAwID8gJ1JpZ2h0JyA6ICcnKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWUgKyAnUmlnaHQnXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpW21ldGhvZE5hbWVdKG4pLnJldmVyc2UoKTtcbiAgICAgIH07XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lICsgJ1JpZ2h0V2hpbGUnXSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbd2hpbGVOYW1lXShwcmVkaWNhdGUsIHRoaXNBcmcpLnJldmVyc2UoKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5maXJzdGAgYW5kIGBfLmxhc3RgLlxuICAgIGFycmF5RWFjaChbJ2ZpcnN0JywgJ2xhc3QnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0YWtlTmFtZSA9ICd0YWtlJyArIChpbmRleCA/ICdSaWdodCcgOiAnJyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5pbml0aWFsYCBhbmQgYF8ucmVzdGAuXG4gICAgYXJyYXlFYWNoKFsnaW5pdGlhbCcsICdyZXN0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgZHJvcE5hbWUgPSAnZHJvcCcgKyAoaW5kZXggPyAnJyA6ICdSaWdodCcpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbZHJvcE5hbWVdKDEpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLnBsdWNrYCBhbmQgYF8ud2hlcmVgLlxuICAgIGFycmF5RWFjaChbJ3BsdWNrJywgJ3doZXJlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgb3BlcmF0aW9uTmFtZSA9IGluZGV4ID8gJ2ZpbHRlcicgOiAnbWFwJyxcbiAgICAgICAgICBjcmVhdGVDYWxsYmFjayA9IGluZGV4ID8gYmFzZU1hdGNoZXMgOiBwcm9wZXJ0eTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbb3BlcmF0aW9uTmFtZV0oY3JlYXRlQ2FsbGJhY2sodmFsdWUpKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGlkZW50aXR5KTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAxKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6ICgrc3RhcnQgfHwgMCk7XG4gICAgICB2YXIgcmVzdWx0ID0gc3RhcnQgPCAwID8gdGhpcy50YWtlUmlnaHQoLXN0YXJ0KSA6IHRoaXMuZHJvcChzdGFydCk7XG5cbiAgICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSAoK2VuZCB8fCAwKTtcbiAgICAgICAgcmVzdWx0ID0gZW5kIDwgMCA/IHJlc3VsdC5kcm9wUmlnaHQoLWVuZCkgOiByZXN1bHQudGFrZShlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZHJvcCgwKTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBsb2Rhc2hGdW5jID0gbG9kYXNoW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKCFsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjaGVja0l0ZXJhdGVlID0gL14oPzpmaWx0ZXJ8bWFwfHJlamVjdCl8V2hpbGUkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IC9eKD86Zmlyc3R8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgICBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgaXNIeWJyaWQgPSAhIXRoaXMuX19hY3Rpb25zX18ubGVuZ3RoLFxuICAgICAgICAgICAgaXNMYXp5ID0gdmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcixcbiAgICAgICAgICAgIGl0ZXJhdGVlID0gYXJnc1swXSxcbiAgICAgICAgICAgIHVzZUxhenkgPSBpc0xhenkgfHwgaXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHVzZUxhenkgJiYgY2hlY2tJdGVyYXRlZSAmJiB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiBpdGVyYXRlZS5sZW5ndGggIT0gMSkge1xuICAgICAgICAgIC8vIGF2b2lkIGxhenkgdXNlIGlmIHRoZSBpdGVyYXRlZSBoYXMgYSBcImxlbmd0aFwiIHZhbHVlIG90aGVyIHRoYW4gYDFgXG4gICAgICAgICAgaXNMYXp5ID0gdXNlTGF6eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbmx5TGF6eSA9IGlzTGF6eSAmJiAhaXNIeWJyaWQ7XG4gICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIWNoYWluQWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG9ubHlMYXp5XG4gICAgICAgICAgICA/IGZ1bmMuY2FsbCh2YWx1ZSlcbiAgICAgICAgICAgIDogbG9kYXNoRnVuYy5jYWxsKGxvZGFzaCwgdGhpcy52YWx1ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciBvdGhlckFyZ3MgPSBbdmFsdWVdO1xuICAgICAgICAgIHB1c2guYXBwbHkob3RoZXJBcmdzLCBhcmdzKTtcbiAgICAgICAgICByZXR1cm4gbG9kYXNoRnVuYy5hcHBseShsb2Rhc2gsIG90aGVyQXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh1c2VMYXp5KSB7XG4gICAgICAgICAgdmFyIHdyYXBwZXIgPSBvbmx5TGF6eSA/IHZhbHVlIDogbmV3IExhenlXcmFwcGVyKHRoaXMpLFxuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHdyYXBwZXIsIGFyZ3MpO1xuXG4gICAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgKGlzSHlicmlkIHx8IHJlc3VsdC5fX2FjdGlvbnNfXykpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb25zID0gcmVzdWx0Ll9fYWN0aW9uc19fIHx8IChyZXN1bHQuX19hY3Rpb25zX18gPSBbXSk7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goeyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiBsb2Rhc2ggfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYEFycmF5YCBhbmQgYFN0cmluZ2AgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYXJyYXlFYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAncG9wJywgJ3B1c2gnLCAncmVwbGFjZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICdzcGxpdCcsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gKC9eKD86cmVwbGFjZXxzcGxpdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gc3RyaW5nUHJvdG8gOiBhcnJheVByb3RvKVttZXRob2ROYW1lXSxcbiAgICAgICAgICBjaGFpbk5hbWUgPSAvXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyAndGFwJyA6ICd0aHJ1JyxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OmpvaW58cG9wfHJlcGxhY2V8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLnZhbHVlKCksIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIE1hcCBtaW5pZmllZCBmdW5jdGlvbiBuYW1lcyB0byB0aGVpciByZWFsIG5hbWVzLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcbiAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHZhciBrZXkgPSBsb2Rhc2hGdW5jLm5hbWUsXG4gICAgICAgICAgICBuYW1lcyA9IHJlYWxOYW1lc1trZXldIHx8IChyZWFsTmFtZXNba2V5XSA9IFtdKTtcblxuICAgICAgICBuYW1lcy5wdXNoKHsgJ25hbWUnOiBtZXRob2ROYW1lLCAnZnVuYyc6IGxvZGFzaEZ1bmMgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFsTmFtZXNbY3JlYXRlSHlicmlkV3JhcHBlcihudWxsLCBCSU5EX0tFWV9GTEFHKS5uYW1lXSA9IFt7ICduYW1lJzogJ3dyYXBwZXInLCAnZnVuYyc6IG51bGwgfV07XG5cbiAgICAvLyBBZGQgZnVuY3Rpb25zIHRvIHRoZSBsYXp5IHdyYXBwZXIuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNsb25lID0gbGF6eUNsb25lO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZXZlcnNlID0gbGF6eVJldmVyc2U7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gbGF6eVZhbHVlO1xuXG4gICAgLy8gQWRkIGNoYWluaW5nIGZ1bmN0aW9ucyB0byB0aGUgYGxvZGFzaGAgd3JhcHBlci5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29tbWl0ID0gd3JhcHBlckNvbW1pdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnBsYW50ID0gd3JhcHBlclBsYW50O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucmV2ZXJzZSA9IHdyYXBwZXJSZXZlcnNlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9TdHJpbmcgPSB3cmFwcGVyVG9TdHJpbmc7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5ydW4gPSBsb2Rhc2gucHJvdG90eXBlLnRvSlNPTiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWU7XG5cbiAgICAvLyBBZGQgZnVuY3Rpb24gYWxpYXNlcyB0byB0aGUgYGxvZGFzaGAgd3JhcHBlci5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbGxlY3QgPSBsb2Rhc2gucHJvdG90eXBlLm1hcDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmhlYWQgPSBsb2Rhc2gucHJvdG90eXBlLmZpcnN0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUuc2VsZWN0ID0gbG9kYXNoLnByb3RvdHlwZS5maWx0ZXI7XG4gICAgbG9kYXNoLnByb3RvdHlwZS50YWlsID0gbG9kYXNoLnByb3RvdHlwZS5yZXN0O1xuXG4gICAgcmV0dXJuIGxvZGFzaDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEV4cG9ydCBsb2Rhc2guXG4gIHZhciBfID0gcnVuSW5Db250ZXh0KCk7XG5cbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycyBsaWtlIHIuanMgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBsb2Rhc2ggdG8gdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBhbiBBTUQgbG9hZGVyIGlzIHByZXNlbnQgdG8gYXZvaWRcbiAgICAvLyBlcnJvcnMgaW4gY2FzZXMgd2hlcmUgbG9kYXNoIGlzIGxvYWRlZCBieSBhIHNjcmlwdCB0YWcgYW5kIG5vdCBpbnRlbmRlZFxuICAgIC8vIGFzIGFuIEFNRCBtb2R1bGUuIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvclxuICAgIC8vIG1vcmUgZGV0YWlscy5cbiAgICByb290Ll8gPSBfO1xuXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgYW4gYGV4cG9ydHNgIG9iamVjdC5cbiAgZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgIC8vIEV4cG9ydCBmb3IgTm9kZS5qcyBvciBSaW5nb0pTLlxuICAgIGlmIChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgfVxuICAgIC8vIEV4cG9ydCBmb3IgTmFyd2hhbCBvciBSaGlubyAtcmVxdWlyZS5cbiAgICBlbHNlIHtcbiAgICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIGEgYnJvd3NlciBvciBSaGluby5cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbG9kYXNoL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

},function(module,exports,__webpack_require__){eval("var _ = __webpack_require__(2)\nvar machina = __webpack_require__(6)\n\nfunction propStore (initialProps) {\n	var store = _.merge({}, initialProps)\n	return store\n}\n\nfunction after(duration, f) {\n	return setTimeout(f,duration)\n}\n\n// var direction = {UP: 1, DOWN: -1}\nvar direction = {UP: 'UP', DOWN: 'DOWN'}\nvar doors = {CLOSE: 1, OPEN: -1}\n\n// var signal = {\n// 	CLOSING_DOORS: \"CLOSING_DOORS\",\n// 	OPENING_DOORS: \"OPENING_DOORS\",\n// }\n\nvar defaultProps = {\n	direction: direction.UP, // no matter at the beginning but IT must be set\n	currentStorey: 0,\n\n	// WAYPOINTS. waypoints stores are sets, i.e we only consider the keys. Set\n	// wp[2]to any value to stop at the storey which index is 2.\n	// delete wp[2] when at the storey to clean the object keys. (clean the\n	// three lists).\n	// --\n	// We handle two buttons at each storey : one to go down, one to go up\n	waypointsUp: {}, // list of storeys that upmoving people want to reach\n	waypointsDown: {}, // … the opposite\n	// when in the cabin, the selected storeys are stored into waypoints,\n	// because we do not know (IRL) which people pushed them ant where they want\n	// to go. To implement undirected buttons at storeys, make a call to add\n	// calls there and ignore waypointsUp/Down\n	waypoints: {},\n\n	// DOORS\n	doorsState : doors.CLOSE,\n\n	// TIMING\n	timer: undefined, // A timer used to have cancellable setTimeout\n	openAwaitingTime: 300, // time with the doors left open\n	closedAwaitingTime: 300, // time after doors close and starting to move\n\n	// CABIN AND ENGINES\n	hardware: {\n		cabinWeight: 200,\n		tractionForce: 2,\n		counterWeight: 200,\n		doors: {\n			openingDuration:200,\n			closingDuration:200,\n		}\n	},\n\n	// STOREYS\n	storeys: [], // a list of storey objects\n}\n\nfunction createElevator(_props) {\n\n	var lastWakeupID = -999\n\n	var wid = (function(){\n		var wid = 0\n		return function(){\n			wid++\n			console.log('generate new wid ' + wid)\n			return wid\n		}\n	}())\n\n	// this handles state data @todo use immutable data (deep (mori ?), Immutable stores mutable objects)\n	var props = propStore(_.merge({},defaultProps,_props))\n\n	var STOPPER = 3\n\n	var ElevatorFsm = machina.Fsm.extend({\n		namespace: 'elevator',\n		initialState: 'uninitialized',\n		initialize: function() {},\n		states: {\n			uninitialized: {\n				_onEnter: function(){\n					this.deferUntilTransition()\n					this.transition('maybeMove')\n				}\n			},\n			idle: {\n				_onEnter: function(){\n					console.log('Elevator idle')\n				},\n				wakeup: function(id) {\n					console.log('received signal ' + id)\n					console.log(' - lastWakeupID =  ' + lastWakeupID)\n					if (id > lastWakeupID) {\n						console.log('set lastWakeupID to ' + id)\n						lastWakeupID = id\n						console.log('go maybeMove')\n						this.transition('maybeMove')\n					}\n					else {\n						console.log('ignore signal')\n						return //ignore, not the last signal\n					}\n				}\n			},\n			// maybeMove is the state juut before the elevator moves. It must\n			// be transitionned to AFTER the doors were closed, and AFTER a\n			// little more time allowing people to push a storey button to go to\n			maybeMove: {\n				_onEnter: function(){\n					this.deferUntilTransition()\n					console.log('Elevator maybeMove')\n					var nextIndex = this.nextDestination()\n					if (nextIndex !== false) { // next can be 0\n						var diff = Math.abs(nextIndex - props.currentStorey)\n						// @todo time calculation should happen only when\n						// hardware changes (and on init)\n						var duration = diff * storeyTravelDuration(props.direction, props.hardware)\n						this.emit('moving', nextIndex, duration)\n						var self = this\n						after(duration, function(){\n							props.currentStorey = nextIndex\n							self.emit('waypointReached', nextIndex)\n							self.deleteWaypoint(nextIndex)\n							self.transition('openingDoors')\n						})\n					} else {\n						this.transition('idle')\n					}\n				},\n			},\n			openingDoors: {\n				_onEnter: function(){\n					this.deferUntilTransition()\n					var self = this\n					after(props.hardware.doors.openingDuration, function(){\n						self.transition('doorsOpen')\n					})\n				}\n			},\n			doorsOpen: {\n				_onEnter: function(){\n					this.deferUntilTransition()\n					var self = this\n					after(props.openAwaitingTime, function(){\n						self.transition('closingDoors')\n					})\n				}\n			},\n			closingDoors: {\n				_onEnter: function(){\n					this.deferUntilTransition()\n					// animation reflects only the closing time\n					this.emit('closingDoors', props.hardware.doors.closingDuration)\n					// but we wait more\n					var totalDuration = props.hardware.doors.closingDuration + props.closedAwaitingTime\n					var self = this\n					after(totalDuration, function(){\n						self.transition('maybeMove')\n					})\n				}\n			},\n		},\n		// public API --\n		getProps: function() {\n			return _.cloneDeep(props)\n		},\n		changeDirection: function() {\n			console.log('changeDirection')\n			if (props.direction === direction.UP) {\n				props.direction = direction.DOWN\n			} else if (props.direction === direction.DOWN) {\n				props.direction = direction.UP\n			}\n		},\n		addWaypointUp: function(index) {\n			console.log('addWaypointUp',index)\n			props.waypointsUp[index] = true\n			this.handle('wakeup', wid())\n		},\n		addWaypointDown: function(index) {\n			console.log('addWaypointDown',index)\n			props.waypointsDown[index] = true\n			this.handle('wakeup', wid())\n		},\n		addWaypoint: function(index) {\n			console.log('addWaypoint',index)\n			props.waypoints[index] = true\n			this.handle('wakeup', wid())\n		},\n		deleteWaypoint: function(index) {\n			console.log('deleteWaypoint', index)\n			delete props.waypoints[index]\n			delete props.waypointsUp[index]\n			delete props.waypointsDown[index]\n		},\n		nextDestination: function () {\n			console.log('nextDestination')\n			function OR (a,b) { return a || b }\n			var upwards = _.keys(_.merge({},props.waypointsUp, props.waypoints, OR))\n			var downwards = _.keys(_.merge({},props.waypointsDown, props.waypoints, OR))\n			// if we are moving up, we want the next destination that is higher\n			// than our current position, and the opposite if moving downwards\n			// so for moving up, we want the MINIMUM higher.\n			// We convert the keys to Numbers as _.isFinite returns true only for numbers\n			var choices = {}\n			choices[direction.UP]   = _.min(_.filter(upwards, function(x){ return  x > props.currentStorey }).map(Number))\n			choices[direction.DOWN] = _.max(_.filter(downwards, function(x){ return  x < props.currentStorey }).map(Number))\n			// if there is no destination in the current direction, we should\n			// change direction. the _.min / _.max values return Infinity / -Infinity\n			// if the filter returns no value. So we want something finite\n			if (! _.isFinite(choices[props.direction])) this.changeDirection()\n			// here, direction could have changed. Again, we check if finite and\n			// return either the next destination or false\n			return (_.isFinite(choices[props.direction])\n				? choices[props.direction]\n				: false)\n		},\n	})\n\n	return new ElevatorFsm()\n}\n\n\n// -- helpers (stateless) -----------------------------------------------------\n\n/**\n * Returns the travel time for 1 storey at full speed, according to the\n * direction\n */\nfunction storeyTravelDuration(direction, hardware) {\n	if (direction === direction.UP) return 1000\n	else return 1200\n	// @todo use hardware.cabinWeight, hardware.tractionForce, hardware.counterWeight\n}\n\n\nexports.createElevator = createElevator\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvZWxldmF0b3IuanM/NzI5MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQixpQkFBaUI7QUFDakIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxpQ0FBaUM7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsa0NBQWtDO0FBQ2xDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGtDQUFrQztBQUNuRyxtRUFBbUUsa0NBQWtDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfID0gcmVxdWlyZSgnbG9kYXNoJylcbnZhciBtYWNoaW5hID0gcmVxdWlyZSgnbWFjaGluYScpXG5cbmZ1bmN0aW9uIHByb3BTdG9yZSAoaW5pdGlhbFByb3BzKSB7XG5cdHZhciBzdG9yZSA9IF8ubWVyZ2Uoe30sIGluaXRpYWxQcm9wcylcblx0cmV0dXJuIHN0b3JlXG59XG5cbmZ1bmN0aW9uIGFmdGVyKGR1cmF0aW9uLCBmKSB7XG5cdHJldHVybiBzZXRUaW1lb3V0KGYsZHVyYXRpb24pXG59XG5cbi8vIHZhciBkaXJlY3Rpb24gPSB7VVA6IDEsIERPV046IC0xfVxudmFyIGRpcmVjdGlvbiA9IHtVUDogJ1VQJywgRE9XTjogJ0RPV04nfVxudmFyIGRvb3JzID0ge0NMT1NFOiAxLCBPUEVOOiAtMX1cblxuLy8gdmFyIHNpZ25hbCA9IHtcbi8vIFx0Q0xPU0lOR19ET09SUzogXCJDTE9TSU5HX0RPT1JTXCIsXG4vLyBcdE9QRU5JTkdfRE9PUlM6IFwiT1BFTklOR19ET09SU1wiLFxuLy8gfVxuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuXHRkaXJlY3Rpb246IGRpcmVjdGlvbi5VUCwgLy8gbm8gbWF0dGVyIGF0IHRoZSBiZWdpbm5pbmcgYnV0IElUIG11c3QgYmUgc2V0XG5cdGN1cnJlbnRTdG9yZXk6IDAsXG5cblx0Ly8gV0FZUE9JTlRTLiB3YXlwb2ludHMgc3RvcmVzIGFyZSBzZXRzLCBpLmUgd2Ugb25seSBjb25zaWRlciB0aGUga2V5cy4gU2V0XG5cdC8vIHdwWzJddG8gYW55IHZhbHVlIHRvIHN0b3AgYXQgdGhlIHN0b3JleSB3aGljaCBpbmRleCBpcyAyLlxuXHQvLyBkZWxldGUgd3BbMl0gd2hlbiBhdCB0aGUgc3RvcmV5IHRvIGNsZWFuIHRoZSBvYmplY3Qga2V5cy4gKGNsZWFuIHRoZVxuXHQvLyB0aHJlZSBsaXN0cykuXG5cdC8vIC0tXG5cdC8vIFdlIGhhbmRsZSB0d28gYnV0dG9ucyBhdCBlYWNoIHN0b3JleSA6IG9uZSB0byBnbyBkb3duLCBvbmUgdG8gZ28gdXBcblx0d2F5cG9pbnRzVXA6IHt9LCAvLyBsaXN0IG9mIHN0b3JleXMgdGhhdCB1cG1vdmluZyBwZW9wbGUgd2FudCB0byByZWFjaFxuXHR3YXlwb2ludHNEb3duOiB7fSwgLy8g4oCmIHRoZSBvcHBvc2l0ZVxuXHQvLyB3aGVuIGluIHRoZSBjYWJpbiwgdGhlIHNlbGVjdGVkIHN0b3JleXMgYXJlIHN0b3JlZCBpbnRvIHdheXBvaW50cyxcblx0Ly8gYmVjYXVzZSB3ZSBkbyBub3Qga25vdyAoSVJMKSB3aGljaCBwZW9wbGUgcHVzaGVkIHRoZW0gYW50IHdoZXJlIHRoZXkgd2FudFxuXHQvLyB0byBnby4gVG8gaW1wbGVtZW50IHVuZGlyZWN0ZWQgYnV0dG9ucyBhdCBzdG9yZXlzLCBtYWtlIGEgY2FsbCB0byBhZGRcblx0Ly8gY2FsbHMgdGhlcmUgYW5kIGlnbm9yZSB3YXlwb2ludHNVcC9Eb3duXG5cdHdheXBvaW50czoge30sXG5cblx0Ly8gRE9PUlNcblx0ZG9vcnNTdGF0ZSA6IGRvb3JzLkNMT1NFLFxuXG5cdC8vIFRJTUlOR1xuXHR0aW1lcjogdW5kZWZpbmVkLCAvLyBBIHRpbWVyIHVzZWQgdG8gaGF2ZSBjYW5jZWxsYWJsZSBzZXRUaW1lb3V0XG5cdG9wZW5Bd2FpdGluZ1RpbWU6IDMwMCwgLy8gdGltZSB3aXRoIHRoZSBkb29ycyBsZWZ0IG9wZW5cblx0Y2xvc2VkQXdhaXRpbmdUaW1lOiAzMDAsIC8vIHRpbWUgYWZ0ZXIgZG9vcnMgY2xvc2UgYW5kIHN0YXJ0aW5nIHRvIG1vdmVcblxuXHQvLyBDQUJJTiBBTkQgRU5HSU5FU1xuXHRoYXJkd2FyZToge1xuXHRcdGNhYmluV2VpZ2h0OiAyMDAsXG5cdFx0dHJhY3Rpb25Gb3JjZTogMixcblx0XHRjb3VudGVyV2VpZ2h0OiAyMDAsXG5cdFx0ZG9vcnM6IHtcblx0XHRcdG9wZW5pbmdEdXJhdGlvbjoyMDAsXG5cdFx0XHRjbG9zaW5nRHVyYXRpb246MjAwLFxuXHRcdH1cblx0fSxcblxuXHQvLyBTVE9SRVlTXG5cdHN0b3JleXM6IFtdLCAvLyBhIGxpc3Qgb2Ygc3RvcmV5IG9iamVjdHNcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxldmF0b3IoX3Byb3BzKSB7XG5cblx0dmFyIGxhc3RXYWtldXBJRCA9IC05OTlcblxuXHR2YXIgd2lkID0gKGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHdpZCA9IDBcblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdHdpZCsrXG5cdFx0XHRjb25zb2xlLmxvZygnZ2VuZXJhdGUgbmV3IHdpZCAnICsgd2lkKVxuXHRcdFx0cmV0dXJuIHdpZFxuXHRcdH1cblx0fSgpKVxuXG5cdC8vIHRoaXMgaGFuZGxlcyBzdGF0ZSBkYXRhIEB0b2RvIHVzZSBpbW11dGFibGUgZGF0YSAoZGVlcCAobW9yaSA/KSwgSW1tdXRhYmxlIHN0b3JlcyBtdXRhYmxlIG9iamVjdHMpXG5cdHZhciBwcm9wcyA9IHByb3BTdG9yZShfLm1lcmdlKHt9LGRlZmF1bHRQcm9wcyxfcHJvcHMpKVxuXG5cdHZhciBTVE9QUEVSID0gM1xuXG5cdHZhciBFbGV2YXRvckZzbSA9IG1hY2hpbmEuRnNtLmV4dGVuZCh7XG5cdFx0bmFtZXNwYWNlOiAnZWxldmF0b3InLFxuXHRcdGluaXRpYWxTdGF0ZTogJ3VuaW5pdGlhbGl6ZWQnLFxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge30sXG5cdFx0c3RhdGVzOiB7XG5cdFx0XHR1bmluaXRpYWxpemVkOiB7XG5cdFx0XHRcdF9vbkVudGVyOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHRoaXMuZGVmZXJVbnRpbFRyYW5zaXRpb24oKVxuXHRcdFx0XHRcdHRoaXMudHJhbnNpdGlvbignbWF5YmVNb3ZlJylcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGlkbGU6IHtcblx0XHRcdFx0X29uRW50ZXI6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ0VsZXZhdG9yIGlkbGUnKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHR3YWtldXA6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ3JlY2VpdmVkIHNpZ25hbCAnICsgaWQpXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJyAtIGxhc3RXYWtldXBJRCA9ICAnICsgbGFzdFdha2V1cElEKVxuXHRcdFx0XHRcdGlmIChpZCA+IGxhc3RXYWtldXBJRCkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coJ3NldCBsYXN0V2FrZXVwSUQgdG8gJyArIGlkKVxuXHRcdFx0XHRcdFx0bGFzdFdha2V1cElEID0gaWRcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCdnbyBtYXliZU1vdmUnKVxuXHRcdFx0XHRcdFx0dGhpcy50cmFuc2l0aW9uKCdtYXliZU1vdmUnKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCdpZ25vcmUgc2lnbmFsJylcblx0XHRcdFx0XHRcdHJldHVybiAvL2lnbm9yZSwgbm90IHRoZSBsYXN0IHNpZ25hbFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8vIG1heWJlTW92ZSBpcyB0aGUgc3RhdGUganV1dCBiZWZvcmUgdGhlIGVsZXZhdG9yIG1vdmVzLiBJdCBtdXN0XG5cdFx0XHQvLyBiZSB0cmFuc2l0aW9ubmVkIHRvIEFGVEVSIHRoZSBkb29ycyB3ZXJlIGNsb3NlZCwgYW5kIEFGVEVSIGFcblx0XHRcdC8vIGxpdHRsZSBtb3JlIHRpbWUgYWxsb3dpbmcgcGVvcGxlIHRvIHB1c2ggYSBzdG9yZXkgYnV0dG9uIHRvIGdvIHRvXG5cdFx0XHRtYXliZU1vdmU6IHtcblx0XHRcdFx0X29uRW50ZXI6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0dGhpcy5kZWZlclVudGlsVHJhbnNpdGlvbigpXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ0VsZXZhdG9yIG1heWJlTW92ZScpXG5cdFx0XHRcdFx0dmFyIG5leHRJbmRleCA9IHRoaXMubmV4dERlc3RpbmF0aW9uKClcblx0XHRcdFx0XHRpZiAobmV4dEluZGV4ICE9PSBmYWxzZSkgeyAvLyBuZXh0IGNhbiBiZSAwXG5cdFx0XHRcdFx0XHR2YXIgZGlmZiA9IE1hdGguYWJzKG5leHRJbmRleCAtIHByb3BzLmN1cnJlbnRTdG9yZXkpXG5cdFx0XHRcdFx0XHQvLyBAdG9kbyB0aW1lIGNhbGN1bGF0aW9uIHNob3VsZCBoYXBwZW4gb25seSB3aGVuXG5cdFx0XHRcdFx0XHQvLyBoYXJkd2FyZSBjaGFuZ2VzIChhbmQgb24gaW5pdClcblx0XHRcdFx0XHRcdHZhciBkdXJhdGlvbiA9IGRpZmYgKiBzdG9yZXlUcmF2ZWxEdXJhdGlvbihwcm9wcy5kaXJlY3Rpb24sIHByb3BzLmhhcmR3YXJlKVxuXHRcdFx0XHRcdFx0dGhpcy5lbWl0KCdtb3ZpbmcnLCBuZXh0SW5kZXgsIGR1cmF0aW9uKVxuXHRcdFx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzXG5cdFx0XHRcdFx0XHRhZnRlcihkdXJhdGlvbiwgZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdFx0cHJvcHMuY3VycmVudFN0b3JleSA9IG5leHRJbmRleFxuXHRcdFx0XHRcdFx0XHRzZWxmLmVtaXQoJ3dheXBvaW50UmVhY2hlZCcsIG5leHRJbmRleClcblx0XHRcdFx0XHRcdFx0c2VsZi5kZWxldGVXYXlwb2ludChuZXh0SW5kZXgpXG5cdFx0XHRcdFx0XHRcdHNlbGYudHJhbnNpdGlvbignb3BlbmluZ0Rvb3JzJylcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMudHJhbnNpdGlvbignaWRsZScpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0fSxcblx0XHRcdG9wZW5pbmdEb29yczoge1xuXHRcdFx0XHRfb25FbnRlcjogZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR0aGlzLmRlZmVyVW50aWxUcmFuc2l0aW9uKClcblx0XHRcdFx0XHR2YXIgc2VsZiA9IHRoaXNcblx0XHRcdFx0XHRhZnRlcihwcm9wcy5oYXJkd2FyZS5kb29ycy5vcGVuaW5nRHVyYXRpb24sIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRzZWxmLnRyYW5zaXRpb24oJ2Rvb3JzT3BlbicpXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRvb3JzT3Blbjoge1xuXHRcdFx0XHRfb25FbnRlcjogZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR0aGlzLmRlZmVyVW50aWxUcmFuc2l0aW9uKClcblx0XHRcdFx0XHR2YXIgc2VsZiA9IHRoaXNcblx0XHRcdFx0XHRhZnRlcihwcm9wcy5vcGVuQXdhaXRpbmdUaW1lLCBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0c2VsZi50cmFuc2l0aW9uKCdjbG9zaW5nRG9vcnMnKVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRjbG9zaW5nRG9vcnM6IHtcblx0XHRcdFx0X29uRW50ZXI6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0dGhpcy5kZWZlclVudGlsVHJhbnNpdGlvbigpXG5cdFx0XHRcdFx0Ly8gYW5pbWF0aW9uIHJlZmxlY3RzIG9ubHkgdGhlIGNsb3NpbmcgdGltZVxuXHRcdFx0XHRcdHRoaXMuZW1pdCgnY2xvc2luZ0Rvb3JzJywgcHJvcHMuaGFyZHdhcmUuZG9vcnMuY2xvc2luZ0R1cmF0aW9uKVxuXHRcdFx0XHRcdC8vIGJ1dCB3ZSB3YWl0IG1vcmVcblx0XHRcdFx0XHR2YXIgdG90YWxEdXJhdGlvbiA9IHByb3BzLmhhcmR3YXJlLmRvb3JzLmNsb3NpbmdEdXJhdGlvbiArIHByb3BzLmNsb3NlZEF3YWl0aW5nVGltZVxuXHRcdFx0XHRcdHZhciBzZWxmID0gdGhpc1xuXHRcdFx0XHRcdGFmdGVyKHRvdGFsRHVyYXRpb24sIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRzZWxmLnRyYW5zaXRpb24oJ21heWJlTW92ZScpXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHR9LFxuXHRcdC8vIHB1YmxpYyBBUEkgLS1cblx0XHRnZXRQcm9wczogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gXy5jbG9uZURlZXAocHJvcHMpXG5cdFx0fSxcblx0XHRjaGFuZ2VEaXJlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29uc29sZS5sb2coJ2NoYW5nZURpcmVjdGlvbicpXG5cdFx0XHRpZiAocHJvcHMuZGlyZWN0aW9uID09PSBkaXJlY3Rpb24uVVApIHtcblx0XHRcdFx0cHJvcHMuZGlyZWN0aW9uID0gZGlyZWN0aW9uLkRPV05cblx0XHRcdH0gZWxzZSBpZiAocHJvcHMuZGlyZWN0aW9uID09PSBkaXJlY3Rpb24uRE9XTikge1xuXHRcdFx0XHRwcm9wcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb24uVVBcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFkZFdheXBvaW50VXA6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHRjb25zb2xlLmxvZygnYWRkV2F5cG9pbnRVcCcsaW5kZXgpXG5cdFx0XHRwcm9wcy53YXlwb2ludHNVcFtpbmRleF0gPSB0cnVlXG5cdFx0XHR0aGlzLmhhbmRsZSgnd2FrZXVwJywgd2lkKCkpXG5cdFx0fSxcblx0XHRhZGRXYXlwb2ludERvd246IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHRjb25zb2xlLmxvZygnYWRkV2F5cG9pbnREb3duJyxpbmRleClcblx0XHRcdHByb3BzLndheXBvaW50c0Rvd25baW5kZXhdID0gdHJ1ZVxuXHRcdFx0dGhpcy5oYW5kbGUoJ3dha2V1cCcsIHdpZCgpKVxuXHRcdH0sXG5cdFx0YWRkV2F5cG9pbnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHRjb25zb2xlLmxvZygnYWRkV2F5cG9pbnQnLGluZGV4KVxuXHRcdFx0cHJvcHMud2F5cG9pbnRzW2luZGV4XSA9IHRydWVcblx0XHRcdHRoaXMuaGFuZGxlKCd3YWtldXAnLCB3aWQoKSlcblx0XHR9LFxuXHRcdGRlbGV0ZVdheXBvaW50OiBmdW5jdGlvbihpbmRleCkge1xuXHRcdFx0Y29uc29sZS5sb2coJ2RlbGV0ZVdheXBvaW50JywgaW5kZXgpXG5cdFx0XHRkZWxldGUgcHJvcHMud2F5cG9pbnRzW2luZGV4XVxuXHRcdFx0ZGVsZXRlIHByb3BzLndheXBvaW50c1VwW2luZGV4XVxuXHRcdFx0ZGVsZXRlIHByb3BzLndheXBvaW50c0Rvd25baW5kZXhdXG5cdFx0fSxcblx0XHRuZXh0RGVzdGluYXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRcdGNvbnNvbGUubG9nKCduZXh0RGVzdGluYXRpb24nKVxuXHRcdFx0ZnVuY3Rpb24gT1IgKGEsYikgeyByZXR1cm4gYSB8fCBiIH1cblx0XHRcdHZhciB1cHdhcmRzID0gXy5rZXlzKF8ubWVyZ2Uoe30scHJvcHMud2F5cG9pbnRzVXAsIHByb3BzLndheXBvaW50cywgT1IpKVxuXHRcdFx0dmFyIGRvd253YXJkcyA9IF8ua2V5cyhfLm1lcmdlKHt9LHByb3BzLndheXBvaW50c0Rvd24sIHByb3BzLndheXBvaW50cywgT1IpKVxuXHRcdFx0Ly8gaWYgd2UgYXJlIG1vdmluZyB1cCwgd2Ugd2FudCB0aGUgbmV4dCBkZXN0aW5hdGlvbiB0aGF0IGlzIGhpZ2hlclxuXHRcdFx0Ly8gdGhhbiBvdXIgY3VycmVudCBwb3NpdGlvbiwgYW5kIHRoZSBvcHBvc2l0ZSBpZiBtb3ZpbmcgZG93bndhcmRzXG5cdFx0XHQvLyBzbyBmb3IgbW92aW5nIHVwLCB3ZSB3YW50IHRoZSBNSU5JTVVNIGhpZ2hlci5cblx0XHRcdC8vIFdlIGNvbnZlcnQgdGhlIGtleXMgdG8gTnVtYmVycyBhcyBfLmlzRmluaXRlIHJldHVybnMgdHJ1ZSBvbmx5IGZvciBudW1iZXJzXG5cdFx0XHR2YXIgY2hvaWNlcyA9IHt9XG5cdFx0XHRjaG9pY2VzW2RpcmVjdGlvbi5VUF0gICA9IF8ubWluKF8uZmlsdGVyKHVwd2FyZHMsIGZ1bmN0aW9uKHgpeyByZXR1cm4gIHggPiBwcm9wcy5jdXJyZW50U3RvcmV5IH0pLm1hcChOdW1iZXIpKVxuXHRcdFx0Y2hvaWNlc1tkaXJlY3Rpb24uRE9XTl0gPSBfLm1heChfLmZpbHRlcihkb3dud2FyZHMsIGZ1bmN0aW9uKHgpeyByZXR1cm4gIHggPCBwcm9wcy5jdXJyZW50U3RvcmV5IH0pLm1hcChOdW1iZXIpKVxuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgbm8gZGVzdGluYXRpb24gaW4gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLCB3ZSBzaG91bGRcblx0XHRcdC8vIGNoYW5nZSBkaXJlY3Rpb24uIHRoZSBfLm1pbiAvIF8ubWF4IHZhbHVlcyByZXR1cm4gSW5maW5pdHkgLyAtSW5maW5pdHlcblx0XHRcdC8vIGlmIHRoZSBmaWx0ZXIgcmV0dXJucyBubyB2YWx1ZS4gU28gd2Ugd2FudCBzb21ldGhpbmcgZmluaXRlXG5cdFx0XHRpZiAoISBfLmlzRmluaXRlKGNob2ljZXNbcHJvcHMuZGlyZWN0aW9uXSkpIHRoaXMuY2hhbmdlRGlyZWN0aW9uKClcblx0XHRcdC8vIGhlcmUsIGRpcmVjdGlvbiBjb3VsZCBoYXZlIGNoYW5nZWQuIEFnYWluLCB3ZSBjaGVjayBpZiBmaW5pdGUgYW5kXG5cdFx0XHQvLyByZXR1cm4gZWl0aGVyIHRoZSBuZXh0IGRlc3RpbmF0aW9uIG9yIGZhbHNlXG5cdFx0XHRyZXR1cm4gKF8uaXNGaW5pdGUoY2hvaWNlc1twcm9wcy5kaXJlY3Rpb25dKVxuXHRcdFx0XHQ/IGNob2ljZXNbcHJvcHMuZGlyZWN0aW9uXVxuXHRcdFx0XHQ6IGZhbHNlKVxuXHRcdH0sXG5cdH0pXG5cblx0cmV0dXJuIG5ldyBFbGV2YXRvckZzbSgpXG59XG5cblxuLy8gLS0gaGVscGVycyAoc3RhdGVsZXNzKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHRyYXZlbCB0aW1lIGZvciAxIHN0b3JleSBhdCBmdWxsIHNwZWVkLCBhY2NvcmRpbmcgdG8gdGhlXG4gKiBkaXJlY3Rpb25cbiAqL1xuZnVuY3Rpb24gc3RvcmV5VHJhdmVsRHVyYXRpb24oZGlyZWN0aW9uLCBoYXJkd2FyZSkge1xuXHRpZiAoZGlyZWN0aW9uID09PSBkaXJlY3Rpb24uVVApIHJldHVybiAxMDAwXG5cdGVsc2UgcmV0dXJuIDEyMDBcblx0Ly8gQHRvZG8gdXNlIGhhcmR3YXJlLmNhYmluV2VpZ2h0LCBoYXJkd2FyZS50cmFjdGlvbkZvcmNlLCBoYXJkd2FyZS5jb3VudGVyV2VpZ2h0XG59XG5cblxuZXhwb3J0cy5jcmVhdGVFbGV2YXRvciA9IGNyZWF0ZUVsZXZhdG9yXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL2pzL2VsZXZhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("var Ractive = __webpack_require__(8)\nvar CONF = __webpack_require__(1)\nvar appSVGTemplate = __webpack_require__(7)\n\n/**\n* Returns a storey's bounding box. Svg vertical coordinates are descending\n* @param  {0..} index   the storey's index\n* @param  {1..} amt     the total number of storeys (= max index + 1)\n * @return {integer}       y coordinate\n*/\nfunction getStoreyY(index, amt) {\n	var maxIndex = amt - 1\n	var sa = maxIndex - index // count of storeys above\n	var y = CONF.buildingWallThickness + (sa * CONF.storeyHeight) + (sa * CONF.storeySpacing)\n	return y\n}\n\n/**\n * Get the elevator Y position when at a storey\n * @param  {integer} index The storey's index the elevator is at\n * @param  {integer} amt   The total number of storeys\n * @return {integer}       y coordinate\n */\nfunction getElevatorY(index, amt) {\n	console.log('getElevatorY', index, amt)\n	var y = getStoreyY(index, amt) + (CONF.storeyHeight - CONF.elevatorHeight)\n	return y\n}\n\n\n\nfunction wrapStoreys (_storeys) {\n	// @todo if reducing the amount of storeys, check if elevator is not\n	// above the new max\n	var data = _storeys.map(function(s){\n		return {\n			i: s.position,\n			_storey: s,\n			x: CONF.buildingX + CONF.buildingWallThickness,\n			y: getStoreyY(s.position, _storeys.length),\n			width: CONF.storeyWidth,\n			height: CONF.storeyHeight,\n		}\n	})\n	console.log('wrapped', data)\n	return data\n}\n\nfunction createRenderer(opts) {\n	console.log('createRenderer',opts)\n	var elv = opts.elevator\n	var initialProps = elv.getProps()\n	var ractive = new Ractive({\n		el: opts.domnode,\n		template: appSVGTemplate,\n		data: {\n			storeys: wrapStoreys(opts.storeys),\n			elv: { // elevator\n				height: CONF.elevatorHeight,\n				width: CONF.elevatorWidth,\n				x: CONF.elevatorX,\n				pos: initialProps.currentStorey,\n				y: getElevatorY(initialProps.currentStorey, opts.storeys.length)\n			}\n		},\n		storeysAmt: function() { return ractive.get('storeys').length },\n		currentPos: function() { return ractive.get('elv.pos') },\n	});\n\n	// -- listen to elevator changes\n\n	elv.on('*',function(){\n		// console.log('elv emit',arguments)\n		// console.log(' (state)', elv.state)\n	})\n	elv.on('transition',function(){\n		// console.log('elv emit',arguments)\n		console.log(' (state)', elv.state)\n	})\n\n	elv.on('moving', function(nextPostion, duration){\n		var newY = getElevatorY(nextPostion, opts.storeys.length)\n		return ractive.animate(\n			{'elv.y': newY, 'elv.pos':nextPostion},\n			{duration:duration,easing:'easeInOut'}\n		)\n	})\n\n	return ractive\n}\n\nexports.createRenderer = createRenderer\n\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvZ3JhcGhpY3MuanM/NjZlYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFdBQVcsSUFBSTtBQUNmLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDBCQUEwQix1Q0FBdUM7QUFDakUsMEJBQTBCLGdDQUFnQztBQUMxRCxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUkscUNBQXFDO0FBQ3pDLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIFJhY3RpdmUgPSByZXF1aXJlKCdyYWN0aXZlJylcbnZhciBDT05GID0gcmVxdWlyZSgnY29uZicpXG52YXIgYXBwU1ZHVGVtcGxhdGUgPSByZXF1aXJlKCd0cGwvYXBwLnN2ZycpXG5cbi8qKlxuKiBSZXR1cm5zIGEgc3RvcmV5J3MgYm91bmRpbmcgYm94LiBTdmcgdmVydGljYWwgY29vcmRpbmF0ZXMgYXJlIGRlc2NlbmRpbmdcbiogQHBhcmFtICB7MC4ufSBpbmRleCAgIHRoZSBzdG9yZXkncyBpbmRleFxuKiBAcGFyYW0gIHsxLi59IGFtdCAgICAgdGhlIHRvdGFsIG51bWJlciBvZiBzdG9yZXlzICg9IG1heCBpbmRleCArIDEpXG4gKiBAcmV0dXJuIHtpbnRlZ2VyfSAgICAgICB5IGNvb3JkaW5hdGVcbiovXG5mdW5jdGlvbiBnZXRTdG9yZXlZKGluZGV4LCBhbXQpIHtcblx0dmFyIG1heEluZGV4ID0gYW10IC0gMVxuXHR2YXIgc2EgPSBtYXhJbmRleCAtIGluZGV4IC8vIGNvdW50IG9mIHN0b3JleXMgYWJvdmVcblx0dmFyIHkgPSBDT05GLmJ1aWxkaW5nV2FsbFRoaWNrbmVzcyArIChzYSAqIENPTkYuc3RvcmV5SGVpZ2h0KSArIChzYSAqIENPTkYuc3RvcmV5U3BhY2luZylcblx0cmV0dXJuIHlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGVsZXZhdG9yIFkgcG9zaXRpb24gd2hlbiBhdCBhIHN0b3JleVxuICogQHBhcmFtICB7aW50ZWdlcn0gaW5kZXggVGhlIHN0b3JleSdzIGluZGV4IHRoZSBlbGV2YXRvciBpcyBhdFxuICogQHBhcmFtICB7aW50ZWdlcn0gYW10ICAgVGhlIHRvdGFsIG51bWJlciBvZiBzdG9yZXlzXG4gKiBAcmV0dXJuIHtpbnRlZ2VyfSAgICAgICB5IGNvb3JkaW5hdGVcbiAqL1xuZnVuY3Rpb24gZ2V0RWxldmF0b3JZKGluZGV4LCBhbXQpIHtcblx0Y29uc29sZS5sb2coJ2dldEVsZXZhdG9yWScsIGluZGV4LCBhbXQpXG5cdHZhciB5ID0gZ2V0U3RvcmV5WShpbmRleCwgYW10KSArIChDT05GLnN0b3JleUhlaWdodCAtIENPTkYuZWxldmF0b3JIZWlnaHQpXG5cdHJldHVybiB5XG59XG5cblxuXG5mdW5jdGlvbiB3cmFwU3RvcmV5cyAoX3N0b3JleXMpIHtcblx0Ly8gQHRvZG8gaWYgcmVkdWNpbmcgdGhlIGFtb3VudCBvZiBzdG9yZXlzLCBjaGVjayBpZiBlbGV2YXRvciBpcyBub3Rcblx0Ly8gYWJvdmUgdGhlIG5ldyBtYXhcblx0dmFyIGRhdGEgPSBfc3RvcmV5cy5tYXAoZnVuY3Rpb24ocyl7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGk6IHMucG9zaXRpb24sXG5cdFx0XHRfc3RvcmV5OiBzLFxuXHRcdFx0eDogQ09ORi5idWlsZGluZ1ggKyBDT05GLmJ1aWxkaW5nV2FsbFRoaWNrbmVzcyxcblx0XHRcdHk6IGdldFN0b3JleVkocy5wb3NpdGlvbiwgX3N0b3JleXMubGVuZ3RoKSxcblx0XHRcdHdpZHRoOiBDT05GLnN0b3JleVdpZHRoLFxuXHRcdFx0aGVpZ2h0OiBDT05GLnN0b3JleUhlaWdodCxcblx0XHR9XG5cdH0pXG5cdGNvbnNvbGUubG9nKCd3cmFwcGVkJywgZGF0YSlcblx0cmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIob3B0cykge1xuXHRjb25zb2xlLmxvZygnY3JlYXRlUmVuZGVyZXInLG9wdHMpXG5cdHZhciBlbHYgPSBvcHRzLmVsZXZhdG9yXG5cdHZhciBpbml0aWFsUHJvcHMgPSBlbHYuZ2V0UHJvcHMoKVxuXHR2YXIgcmFjdGl2ZSA9IG5ldyBSYWN0aXZlKHtcblx0XHRlbDogb3B0cy5kb21ub2RlLFxuXHRcdHRlbXBsYXRlOiBhcHBTVkdUZW1wbGF0ZSxcblx0XHRkYXRhOiB7XG5cdFx0XHRzdG9yZXlzOiB3cmFwU3RvcmV5cyhvcHRzLnN0b3JleXMpLFxuXHRcdFx0ZWx2OiB7IC8vIGVsZXZhdG9yXG5cdFx0XHRcdGhlaWdodDogQ09ORi5lbGV2YXRvckhlaWdodCxcblx0XHRcdFx0d2lkdGg6IENPTkYuZWxldmF0b3JXaWR0aCxcblx0XHRcdFx0eDogQ09ORi5lbGV2YXRvclgsXG5cdFx0XHRcdHBvczogaW5pdGlhbFByb3BzLmN1cnJlbnRTdG9yZXksXG5cdFx0XHRcdHk6IGdldEVsZXZhdG9yWShpbml0aWFsUHJvcHMuY3VycmVudFN0b3JleSwgb3B0cy5zdG9yZXlzLmxlbmd0aClcblx0XHRcdH1cblx0XHR9LFxuXHRcdHN0b3JleXNBbXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmFjdGl2ZS5nZXQoJ3N0b3JleXMnKS5sZW5ndGggfSxcblx0XHRjdXJyZW50UG9zOiBmdW5jdGlvbigpIHsgcmV0dXJuIHJhY3RpdmUuZ2V0KCdlbHYucG9zJykgfSxcblx0fSk7XG5cblx0Ly8gLS0gbGlzdGVuIHRvIGVsZXZhdG9yIGNoYW5nZXNcblxuXHRlbHYub24oJyonLGZ1bmN0aW9uKCl7XG5cdFx0Ly8gY29uc29sZS5sb2coJ2VsdiBlbWl0Jyxhcmd1bWVudHMpXG5cdFx0Ly8gY29uc29sZS5sb2coJyAoc3RhdGUpJywgZWx2LnN0YXRlKVxuXHR9KVxuXHRlbHYub24oJ3RyYW5zaXRpb24nLGZ1bmN0aW9uKCl7XG5cdFx0Ly8gY29uc29sZS5sb2coJ2VsdiBlbWl0Jyxhcmd1bWVudHMpXG5cdFx0Y29uc29sZS5sb2coJyAoc3RhdGUpJywgZWx2LnN0YXRlKVxuXHR9KVxuXG5cdGVsdi5vbignbW92aW5nJywgZnVuY3Rpb24obmV4dFBvc3Rpb24sIGR1cmF0aW9uKXtcblx0XHR2YXIgbmV3WSA9IGdldEVsZXZhdG9yWShuZXh0UG9zdGlvbiwgb3B0cy5zdG9yZXlzLmxlbmd0aClcblx0XHRyZXR1cm4gcmFjdGl2ZS5hbmltYXRlKFxuXHRcdFx0eydlbHYueSc6IG5ld1ksICdlbHYucG9zJzpuZXh0UG9zdGlvbn0sXG5cdFx0XHR7ZHVyYXRpb246ZHVyYXRpb24sZWFzaW5nOidlYXNlSW5PdXQnfVxuXHRcdClcblx0fSlcblxuXHRyZXR1cm4gcmFjdGl2ZVxufVxuXG5leHBvcnRzLmNyZWF0ZVJlbmRlcmVyID0gY3JlYXRlUmVuZGVyZXJcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2FwcC9qcy9ncmFwaGljcy5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("function Storey(position) {\n	this.position = position\n}\n\nmodule.exports = Storey\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvbW9kZWwvU3RvcmV5LmpzPzFmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBTdG9yZXkocG9zaXRpb24pIHtcblx0dGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3RvcmV5XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL2pzL21vZGVsL1N0b3JleS5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * machina - A library for creating powerful and flexible finite state machines. Loosely inspired by Erlang/OTP\'s gen_fsm behavior.\n * Author: Jim Cowart (http://ifandelse.com)\n * Version: v1.0.0\n * Url: http://machina-js.org/\n * License(s): MIT, GPL\n */\n\n(function (root, factory) { /* istanbul ignore if  */\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (_) {\n            return factory(_, root);\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); /* istanbul ignore else  */\n    } else if (typeof module === "object" && module.exports) {\n        // Node, or CommonJS-Like environments\n        module.exports = factory(require("lodash"));\n    } else {\n        // Browser globals\n        root.machina = factory(root._, root);\n    }\n}(this, function (_, global, undefined) {\n    var slice = [].slice;\n    var NEXT_TRANSITION = "transition";\n    var HANDLING = "handling";\n    var HANDLED = "handled";\n    var NO_HANDLER = "nohandler";\n    var TRANSITION = "transition";\n    var INVALID_STATE = "invalidstate";\n    var DEFERRED = "deferred";\n    var NEW_FSM = "newfsm";\n\n    function getDefaultBehavioralOptions() {\n        return {\n            initialState: "uninitialized",\n            eventListeners: {\n                "*": []\n            },\n            states: {},\n            namespace: utils.makeFsmNamespace(),\n            useSafeEmit: false,\n            hierarchy: {},\n            pendingDelegations: {}\n        };\n    }\n\n    function getDefaultClientMeta() {\n        return {\n            inputQueue: [],\n            targetReplayState: "",\n            state: undefined,\n            priorState: undefined,\n            priorAction: "",\n            currentAction: "",\n            currentActionArgs: undefined,\n            inExitHandler: false\n        };\n    }\n\n    function getLeaklessArgs(args, startIdx) {\n        var result = [];\n        for (var i = (startIdx || 0); i < args.length; i++) {\n            result[i] = args[i];\n        }\n        return result;\n    }\n\n    function getChildFsmInstance(config) {\n        if (!config) {\n            return;\n        }\n        var childFsmDefinition = {};\n        if (typeof config === "object") {\n            // is this a config object with a factory?\n            if (config.factory) {\n                childFsmDefinition = config;\n            } else {\n                // assuming this is a machina instance\n                childFsmDefinition.factory = function () {\n                    return config;\n                };\n            }\n        } else if (typeof config === "function") {\n            childFsmDefinition.factory = config;\n        }\n        childFsmDefinition.instance = childFsmDefinition.factory();\n        return childFsmDefinition;\n    }\n\n    function listenToChild(fsm, child) {\n        return child.on("*", function (eventName, data) {\n            switch (eventName) {\n            case "nohandler":\n                if (!data.ticket && !data.delegated && data.namespace !== fsm.namespace) {\n                    // Ok - we\'re dealing w/ a child handling input that should bubble up\n                    data.args[1].bubbling = true;\n                }\n                // we do NOT bubble _reset inputs up to the parent\n                if (data.inputType !== "_reset") {\n                    fsm.handle.apply(fsm, data.args);\n                }\n                break;\n            case "handling":\n                var ticket = data.ticket;\n                if (ticket && fsm.pendingDelegations[ticket]) {\n                    delete fsm.pendingDelegations[ticket];\n                }\n                fsm.emit(eventName, data); // possibly transform payload?\n                break;\n            default:\n                fsm.emit(eventName, data); // possibly transform payload?\n                break;\n            }\n        });\n    }\n\n    // _machKeys are members we want to track across the prototype chain of an extended FSM constructor\n    // Since we want to eventually merge the aggregate of those values onto the instance so that FSMs\n    // that share the same extended prototype won\'t share state *on* those prototypes.\n    var _machKeys = ["states", "initialState"];\n    var extend = function (protoProps, staticProps) {\n        var parent = this;\n        var fsm; // placeholder for instance constructor\n        var machObj = {}; // object used to hold initialState & states from prototype for instance-level merging\n        var ctor = function () {}; // placeholder ctor function used to insert level in prototype chain\n        // The constructor function for the new subclass is either defined by you\n        // (the "constructor" property in your `extend` definition), or defaulted\n        // by us to simply call the parent\'s constructor.\n        if (protoProps && protoProps.hasOwnProperty(\'constructor\')) {\n            fsm = protoProps.constructor;\n        } else {\n            // The default machina constructor (when using inheritance) creates a\n            // deep copy of the states/initialState values from the prototype and\n            // extends them over the instance so that they\'ll be instance-level.\n            // If an options arg (args[0]) is passed in, a states or intialState\n            // value will be preferred over any data pulled up from the prototype.\n            fsm = function () {\n                var args = slice.call(arguments, 0);\n                args[0] = args[0] || {};\n                var blendedState;\n                var instanceStates = args[0].states || {};\n                blendedState = _.merge(_.cloneDeep(machObj), {\n                    states: instanceStates\n                });\n                blendedState.initialState = args[0].initialState || this.initialState;\n                _.extend(args[0], blendedState);\n                parent.apply(this, args);\n            };\n        }\n\n        // Inherit class (static) properties from parent.\n        _.merge(fsm, parent);\n\n        // Set the prototype chain to inherit from `parent`, without calling\n        // `parent`\'s constructor function.\n        ctor.prototype = parent.prototype;\n        fsm.prototype = new ctor();\n\n        // Add prototype properties (instance properties) to the subclass,\n        // if supplied.\n        if (protoProps) {\n            _.extend(fsm.prototype, protoProps);\n            _.merge(machObj, _.transform(protoProps, function (accum, val, key) {\n                if (_machKeys.indexOf(key) !== -1) {\n                    accum[key] = val;\n                }\n            }));\n        }\n\n        // Add static properties to the constructor function, if supplied.\n        if (staticProps) {\n            _.merge(fsm, staticProps);\n        }\n\n        // Correctly set child\'s `prototype.constructor`.\n        fsm.prototype.constructor = fsm;\n\n        // Set a convenience property in case the parent\'s prototype is needed later.\n        fsm.__super__ = parent.prototype;\n        return fsm;\n    };\n\n    function createUUID() {\n        var s = [];\n        var hexDigits = "0123456789abcdef";\n        for (var i = 0; i < 36; i++) {\n            s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);\n        }\n        s[14] = "4"; // bits 12-15 of the time_hi_and_version field to 0010\n        s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01\n        s[8] = s[13] = s[18] = s[23] = "-";\n        return s.join("");\n    }\n\n    var utils = {\n        makeFsmNamespace: (function () {\n            var machinaCount = 0;\n            return function () {\n                return "fsm." + machinaCount++;\n            };\n        })(),\n        listenToChild: listenToChild,\n        getLeaklessArgs: getLeaklessArgs,\n        getDefaultOptions: getDefaultBehavioralOptions,\n        getDefaultClientMeta: getDefaultClientMeta,\n        createUUID: createUUID\n    };\n\n    var emitter = {\n\n        emit: function (eventName) {\n            var args = getLeaklessArgs(arguments);\n            if (this.eventListeners["*"]) {\n                _.each(this.eventListeners["*"], function (callback) {\n                    if (!this.useSafeEmit) {\n                        callback.apply(this, args);\n                    } else {\n                        try {\n                            callback.apply(this, args);\n                        } catch (exception) { /* istanbul ignore else  */\n                            if (console && typeof console.log !== "undefined") {\n                                console.log(exception.stack);\n                            }\n                        }\n                    }\n                }, this);\n            }\n            if (this.eventListeners[eventName]) {\n                _.each(this.eventListeners[eventName], function (callback) {\n                    if (!this.useSafeEmit) {\n                        callback.apply(this, args.slice(1));\n                    } else {\n                        try {\n                            callback.apply(this, args.slice(1));\n                        } catch (exception) { /* istanbul ignore else  */\n                            if (console && typeof console.log !== "undefined") {\n                                console.log(exception.stack);\n                            }\n                        }\n                    }\n                }, this);\n            }\n        },\n\n        on: function (eventName, callback) {\n            var self = this;\n            self.eventListeners = self.eventListeners || {\n                "*": []\n            };\n            if (!self.eventListeners[eventName]) {\n                self.eventListeners[eventName] = [];\n            }\n            self.eventListeners[eventName].push(callback);\n            return {\n                eventName: eventName,\n                callback: callback,\n                off: function () {\n                    self.off(eventName, callback);\n                }\n            };\n        },\n\n        off: function (eventName, callback) {\n            this.eventListeners = this.eventListeners || {\n                "*": []\n            };\n            if (!eventName) {\n                this.eventListeners = {};\n            } else {\n                if (callback) {\n                    this.eventListeners[eventName] = _.without(this.eventListeners[eventName], callback);\n                } else {\n                    this.eventListeners[eventName] = [];\n                }\n            }\n        },\n    };\n\n    var MACHINA_PROP = "__machina__";\n\n    function BehavioralFsm(options) {\n        _.extend(this, options);\n        _.defaults(this, getDefaultBehavioralOptions());\n        this.initialize.apply(this, arguments);\n        machina.emit(NEW_FSM, this);\n    }\n\n    _.extend(BehavioralFsm.prototype, {\n        initialize: function () {},\n\n        initClient: function initClient(client) {\n            var initialState = this.initialState;\n            if (!initialState) {\n                throw new Error("You must specify an initial state for this FSM");\n            }\n            if (!this.states[initialState]) {\n                throw new Error("The initial state specified does not exist in the states object.");\n            }\n            this.transition(client, initialState);\n        },\n\n        ensureClientMeta: function ensureClientMeta(client) {\n            if (typeof client !== "object") {\n                throw new Error("An FSM client must be an object.");\n            }\n            client[MACHINA_PROP] = client[MACHINA_PROP] || {};\n            if (!client[MACHINA_PROP][this.namespace]) {\n                client[MACHINA_PROP][this.namespace] = _.cloneDeep(utils.getDefaultClientMeta());\n                this.initClient(client);\n            }\n            return client[MACHINA_PROP][this.namespace];\n        },\n\n        buildEventPayload: function (client, data) {\n            if (_.isPlainObject(data)) {\n                return _.extend(data, {\n                    client: client,\n                    namespace: this.namespace\n                });\n            } else {\n                return {\n                    client: client,\n                    data: data || null,\n                    namespace: this.namespace\n                };\n            }\n        },\n\n        getHandlerArgs: function (args, isCatchAll) {\n            // index 0 is the client, index 1 is inputType\n            // if we\'re in a catch-all handler, input type needs to be included in the args\n            // inputType might be an object, so we need to just get the inputType string if so\n            var _args = args.slice(0);\n            var input = _args[1];\n            if (typeof input === "object") {\n                _args.splice(1, 1, input.inputType);\n            }\n            return isCatchAll ? _args : [_args[0]].concat(_args.slice(2));\n        },\n\n        handle: function (client, input) {\n            var inputType;\n            var delegated;\n            var ticket;\n            var inputDef = input;\n            if (typeof input === "undefined") {\n                throw new Error("The input argument passed to the FSM\'s handle method is undefined. Did you forget to pass the input name?");\n            }\n            if (typeof input === "string") {\n                inputDef = {\n                    inputType: input,\n                    delegated: false,\n                    ticket: undefined\n                };\n            }\n            var clientMeta = this.ensureClientMeta(client);\n            var args = getLeaklessArgs(arguments);\n            if (typeof input !== "object") {\n                args.splice(1, 1, inputDef);\n            }\n            clientMeta.currentActionArgs = args.slice(1);\n            var currentState = clientMeta.state;\n            var stateObj = this.states[currentState];\n            var handlerName;\n            var handler;\n            var isCatchAll = false;\n            var child;\n            var result;\n            if (!clientMeta.inExitHandler) {\n                child = stateObj._child && stateObj._child.instance;\n                if (child && !this.pendingDelegations[inputDef.ticket] && !inputDef.bubbling) {\n                    inputDef.ticket = (inputDef.ticket || utils.createUUID());\n                    inputDef.delegated = true;\n                    this.pendingDelegations[inputDef.ticket] = {\n                        delegatedTo: child.namespace\n                    };\n                    // WARNING - returning a value from `handle` on child FSMs is not really supported.\n                    // If you need to return values from child FSM input handlers, use events instead.\n                    result = child.handle.apply(child, args);\n                } else {\n                    if (inputDef.ticket && this.pendingDelegations[inputDef.ticket]) {\n                        delete this.pendingDelegations[inputDef.ticket];\n                    }\n                    handlerName = stateObj[inputDef.inputType] ? inputDef.inputType : "*";\n                    isCatchAll = (handlerName === "*");\n                    handler = (stateObj[handlerName] || this[handlerName]) || this["*"];\n                    action = clientMeta.state + "." + handlerName;\n                    clientMeta.currentAction = action;\n                    var eventPayload = this.buildEventPayload(\n                    client, {\n                        inputType: inputDef.inputType,\n                        delegated: inputDef.delegated,\n                        ticket: inputDef.ticket\n                    });\n                    if (!handler) {\n                        this.emit(NO_HANDLER, _.extend({\n                            args: args\n                        }, eventPayload));\n                    } else {\n                        this.emit(HANDLING, eventPayload);\n                        if (typeof handler === "function") {\n                            result = handler.apply(this, this.getHandlerArgs(args, isCatchAll));\n                        } else {\n                            result = handler;\n                            this.transition(client, handler);\n                        }\n                        this.emit(HANDLED, eventPayload);\n                    }\n                    clientMeta.priorAction = clientMeta.currentAction;\n                    clientMeta.currentAction = "";\n                }\n            }\n            return result;\n        },\n\n        transition: function (client, newState) {\n            var clientMeta = this.ensureClientMeta(client);\n            var curState = clientMeta.state;\n            var curStateObj = this.states[curState];\n            var newStateObj = this.states[newState];\n            var childDef;\n            var child;\n            if (!clientMeta.inExitHandler && newState !== curState) {\n                if (newStateObj) {\n                    if (newStateObj._child) {\n                        newStateObj._child = getChildFsmInstance(newStateObj._child);\n                        child = newStateObj._child && newStateObj._child.instance;\n                    }\n                    if (curStateObj && curStateObj._onExit) {\n                        clientMeta.inExitHandler = true;\n                        curStateObj._onExit.call(this, client);\n                        clientMeta.inExitHandler = false;\n                    }\n                    if (curStateObj && curStateObj._child && curStateObj._child.instance && this.hierarchy[curStateObj._child.instance.namespace]) {\n                        this.hierarchy[curStateObj._child.instance.namespace].off();\n                    }\n                    clientMeta.targetReplayState = newState;\n                    clientMeta.priorState = curState;\n                    clientMeta.state = newState;\n                    if (child) {\n                        this.hierarchy[child.namespace] = utils.listenToChild(this, child);\n                    }\n                    var eventPayload = this.buildEventPayload(client, {\n                        fromState: clientMeta.priorState,\n                        action: clientMeta.currentAction,\n                        toState: newState\n                    });\n                    this.emit(TRANSITION, eventPayload);\n                    if (newStateObj._onEnter) {\n                        newStateObj._onEnter.call(this, client);\n                    }\n                    if (child) {\n                        child.handle(client, "_reset");\n                    }\n                    if (clientMeta.targetReplayState === newState) {\n                        this.processQueue(client, NEXT_TRANSITION);\n                    }\n                    return;\n                }\n                this.emit(INVALID_STATE, this.buildEventPayload(client, {\n                    state: clientMeta.state,\n                    attemptedState: newState\n                }));\n            }\n        },\n\n        deferUntilTransition: function (client, stateName) {\n            var clientMeta = this.ensureClientMeta(client);\n            if (clientMeta.currentActionArgs) {\n                var queued = {\n                    type: NEXT_TRANSITION,\n                    untilState: stateName,\n                    args: clientMeta.currentActionArgs\n                };\n                clientMeta.inputQueue.push(queued);\n                var eventPayload = this.buildEventPayload(client, {\n                    state: clientMeta.state,\n                    queuedArgs: queued\n                });\n                this.emit(DEFERRED, eventPayload);\n            }\n        },\n\n        deferAndTransition: function (client, stateName) {\n            this.deferUntilTransition(client, stateName);\n            this.transition(client, stateName);\n        },\n\n        processQueue: function (client) {\n            var clientMeta = this.ensureClientMeta(client);\n            var filterFn = function (item) {\n                return ((!item.untilState) || (item.untilState === clientMeta.state));\n            };\n            var toProcess = _.filter(clientMeta.inputQueue, filterFn);\n            clientMeta.inputQueue = _.difference(clientMeta.inputQueue, toProcess);\n            _.each(toProcess, function (item) {\n                this.handle.apply(this, [client].concat(item.args));\n            }, this);\n        },\n\n        clearQueue: function (client, name) {\n            var clientMeta = this.ensureClientMeta(client);\n            if (!name) {\n                clientMeta.inputQueue = [];\n            } else {\n                var filter = function (evnt) {\n                    return (name ? evnt.untilState !== name : true);\n                };\n                clientMeta.inputQueue = _.filter(clientMeta.inputQueue, filter);\n            }\n        }\n    }, emitter);\n\n    BehavioralFsm.extend = extend;\n\n    var Fsm = BehavioralFsm.extend({\n        constructor: function () {\n            BehavioralFsm.apply(this, arguments);\n            this.ensureClientMeta();\n        },\n        initClient: function initClient() {\n            var initialState = this.initialState;\n            if (!initialState) {\n                throw new Error("You must specify an initial state for this FSM");\n            }\n            if (!this.states[initialState]) {\n                throw new Error("The initial state specified does not exist in the states object.");\n            }\n            this.transition(initialState);\n        },\n        ensureClientMeta: function ensureClientMeta() {\n            if (!this._stamped) {\n                this._stamped = true;\n                _.defaults(this, _.cloneDeep(getDefaultClientMeta()));\n                this.initClient();\n            }\n            return this;\n        },\n\n        ensureClientArg: function (args) {\n            var _args = args;\n            // we need to test the args and verify that if a client arg has\n            // been passed, it must be this FSM instance (this isn\'t a behavioral FSM)\n            if (typeof _args[0] === "object" && !("inputType" in _args[0]) && _args[0] !== this) {\n                _args.splice(0, 1, this);\n            } else if (typeof _args[0] !== "object" || (typeof _args[0] === "object" && ("inputType" in _args[0]))) {\n                _args.unshift(this);\n            }\n            return _args;\n        },\n\n        getHandlerArgs: function (args, isCatchAll) {\n            // index 0 is the client, index 1 is inputType\n            // if we\'re in a catch-all handler, input type needs to be included in the args\n            // inputType might be an object, so we need to just get the inputType string if so\n            var _args = args;\n            var input = _args[1];\n            if (typeof inputType === "object") {\n                _args.splice(1, 1, input.inputType);\n            }\n            return isCatchAll ? _args.slice(1) : _args.slice(2);\n        },\n        // "classic" machina FSM do not emit the client property on events (which would be the FSM itself)\n        buildEventPayload: function () {\n            var args = this.ensureClientArg(utils.getLeaklessArgs(arguments));\n            var data = args[1];\n            if (_.isPlainObject(data)) {\n                return _.extend(data, {\n                    namespace: this.namespace\n                });\n            } else {\n                return {\n                    data: data || null,\n                    namespace: this.namespace\n                };\n            }\n        },\n        handle: function (inputType) {\n            var args = this.ensureClientArg(utils.getLeaklessArgs(arguments));\n            return BehavioralFsm.prototype.handle.apply(this, args);\n        },\n        transition: function (newState) {\n            var args = this.ensureClientArg(utils.getLeaklessArgs(arguments));\n            return BehavioralFsm.prototype.transition.apply(this, args);\n        },\n        deferUntilTransition: function (stateName) {\n            var args = this.ensureClientArg(utils.getLeaklessArgs(arguments));\n            return BehavioralFsm.prototype.deferUntilTransition.apply(this, args);\n        },\n        processQueue: function () {\n            var args = this.ensureClientArg(utils.getLeaklessArgs(arguments));\n            return BehavioralFsm.prototype.processQueue.apply(this, args);\n        },\n        clearQueue: function (stateName) {\n            var args = this.ensureClientArg(utils.getLeaklessArgs(arguments));\n            return BehavioralFsm.prototype.clearQueue.apply(this, args);\n        }\n    });\n\n    var machina = _.merge(emitter, {\n        Fsm: Fsm,\n        BehavioralFsm: BehavioralFsm,\n        utils: utils,\n        eventListeners: {\n            newFsm: []\n        }\n    });\n\n    return machina;\n}));\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21hY2hpbmEvbGliL21hY2hpbmEuanM/YmMzZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdKQUFFO0FBQ1gsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQix5QkFBeUI7QUFDekIsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUMiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbWFjaGluYSAtIEEgbGlicmFyeSBmb3IgY3JlYXRpbmcgcG93ZXJmdWwgYW5kIGZsZXhpYmxlIGZpbml0ZSBzdGF0ZSBtYWNoaW5lcy4gTG9vc2VseSBpbnNwaXJlZCBieSBFcmxhbmcvT1RQJ3MgZ2VuX2ZzbSBiZWhhdmlvci5cbiAqIEF1dGhvcjogSmltIENvd2FydCAoaHR0cDovL2lmYW5kZWxzZS5jb20pXG4gKiBWZXJzaW9uOiB2MS4wLjBcbiAqIFVybDogaHR0cDovL21hY2hpbmEtanMub3JnL1xuICogTGljZW5zZShzKTogTUlULCBHUExcbiAqL1xuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHsgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbXCJsb2Rhc2hcIl0sIGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeShfLCByb290KTtcbiAgICAgICAgfSk7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAvLyBOb2RlLCBvciBDb21tb25KUy1MaWtlIGVudmlyb25tZW50c1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImxvZGFzaFwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgICAgIHJvb3QubWFjaGluYSA9IGZhY3Rvcnkocm9vdC5fLCByb290KTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIChfLCBnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIHZhciBzbGljZSA9IFtdLnNsaWNlO1xuICAgIHZhciBORVhUX1RSQU5TSVRJT04gPSBcInRyYW5zaXRpb25cIjtcbiAgICB2YXIgSEFORExJTkcgPSBcImhhbmRsaW5nXCI7XG4gICAgdmFyIEhBTkRMRUQgPSBcImhhbmRsZWRcIjtcbiAgICB2YXIgTk9fSEFORExFUiA9IFwibm9oYW5kbGVyXCI7XG4gICAgdmFyIFRSQU5TSVRJT04gPSBcInRyYW5zaXRpb25cIjtcbiAgICB2YXIgSU5WQUxJRF9TVEFURSA9IFwiaW52YWxpZHN0YXRlXCI7XG4gICAgdmFyIERFRkVSUkVEID0gXCJkZWZlcnJlZFwiO1xuICAgIHZhciBORVdfRlNNID0gXCJuZXdmc21cIjtcblxuICAgIGZ1bmN0aW9uIGdldERlZmF1bHRCZWhhdmlvcmFsT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluaXRpYWxTdGF0ZTogXCJ1bmluaXRpYWxpemVkXCIsXG4gICAgICAgICAgICBldmVudExpc3RlbmVyczoge1xuICAgICAgICAgICAgICAgIFwiKlwiOiBbXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXRlczoge30sXG4gICAgICAgICAgICBuYW1lc3BhY2U6IHV0aWxzLm1ha2VGc21OYW1lc3BhY2UoKSxcbiAgICAgICAgICAgIHVzZVNhZmVFbWl0OiBmYWxzZSxcbiAgICAgICAgICAgIGhpZXJhcmNoeToge30sXG4gICAgICAgICAgICBwZW5kaW5nRGVsZWdhdGlvbnM6IHt9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGVmYXVsdENsaWVudE1ldGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dFF1ZXVlOiBbXSxcbiAgICAgICAgICAgIHRhcmdldFJlcGxheVN0YXRlOiBcIlwiLFxuICAgICAgICAgICAgc3RhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByaW9yU3RhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByaW9yQWN0aW9uOiBcIlwiLFxuICAgICAgICAgICAgY3VycmVudEFjdGlvbjogXCJcIixcbiAgICAgICAgICAgIGN1cnJlbnRBY3Rpb25BcmdzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpbkV4aXRIYW5kbGVyOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldExlYWtsZXNzQXJncyhhcmdzLCBzdGFydElkeCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAoc3RhcnRJZHggfHwgMCk7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBhcmdzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q2hpbGRGc21JbnN0YW5jZShjb25maWcpIHtcbiAgICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRGc21EZWZpbml0aW9uID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBpcyB0aGlzIGEgY29uZmlnIG9iamVjdCB3aXRoIGEgZmFjdG9yeT9cbiAgICAgICAgICAgIGlmIChjb25maWcuZmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIGNoaWxkRnNtRGVmaW5pdGlvbiA9IGNvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYXNzdW1pbmcgdGhpcyBpcyBhIG1hY2hpbmEgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBjaGlsZEZzbURlZmluaXRpb24uZmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25maWcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY2hpbGRGc21EZWZpbml0aW9uLmZhY3RvcnkgPSBjb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRGc21EZWZpbml0aW9uLmluc3RhbmNlID0gY2hpbGRGc21EZWZpbml0aW9uLmZhY3RvcnkoKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkRnNtRGVmaW5pdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW5Ub0NoaWxkKGZzbSwgY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLm9uKFwiKlwiLCBmdW5jdGlvbiAoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcIm5vaGFuZGxlclwiOlxuICAgICAgICAgICAgICAgIGlmICghZGF0YS50aWNrZXQgJiYgIWRhdGEuZGVsZWdhdGVkICYmIGRhdGEubmFtZXNwYWNlICE9PSBmc20ubmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9rIC0gd2UncmUgZGVhbGluZyB3LyBhIGNoaWxkIGhhbmRsaW5nIGlucHV0IHRoYXQgc2hvdWxkIGJ1YmJsZSB1cFxuICAgICAgICAgICAgICAgICAgICBkYXRhLmFyZ3NbMV0uYnViYmxpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB3ZSBkbyBOT1QgYnViYmxlIF9yZXNldCBpbnB1dHMgdXAgdG8gdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmlucHV0VHlwZSAhPT0gXCJfcmVzZXRcIikge1xuICAgICAgICAgICAgICAgICAgICBmc20uaGFuZGxlLmFwcGx5KGZzbSwgZGF0YS5hcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaGFuZGxpbmdcIjpcbiAgICAgICAgICAgICAgICB2YXIgdGlja2V0ID0gZGF0YS50aWNrZXQ7XG4gICAgICAgICAgICAgICAgaWYgKHRpY2tldCAmJiBmc20ucGVuZGluZ0RlbGVnYXRpb25zW3RpY2tldF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZzbS5wZW5kaW5nRGVsZWdhdGlvbnNbdGlja2V0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnNtLmVtaXQoZXZlbnROYW1lLCBkYXRhKTsgLy8gcG9zc2libHkgdHJhbnNmb3JtIHBheWxvYWQ/XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGZzbS5lbWl0KGV2ZW50TmFtZSwgZGF0YSk7IC8vIHBvc3NpYmx5IHRyYW5zZm9ybSBwYXlsb2FkP1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBfbWFjaEtleXMgYXJlIG1lbWJlcnMgd2Ugd2FudCB0byB0cmFjayBhY3Jvc3MgdGhlIHByb3RvdHlwZSBjaGFpbiBvZiBhbiBleHRlbmRlZCBGU00gY29uc3RydWN0b3JcbiAgICAvLyBTaW5jZSB3ZSB3YW50IHRvIGV2ZW50dWFsbHkgbWVyZ2UgdGhlIGFnZ3JlZ2F0ZSBvZiB0aG9zZSB2YWx1ZXMgb250byB0aGUgaW5zdGFuY2Ugc28gdGhhdCBGU01zXG4gICAgLy8gdGhhdCBzaGFyZSB0aGUgc2FtZSBleHRlbmRlZCBwcm90b3R5cGUgd29uJ3Qgc2hhcmUgc3RhdGUgKm9uKiB0aG9zZSBwcm90b3R5cGVzLlxuICAgIHZhciBfbWFjaEtleXMgPSBbXCJzdGF0ZXNcIiwgXCJpbml0aWFsU3RhdGVcIl07XG4gICAgdmFyIGV4dGVuZCA9IGZ1bmN0aW9uIChwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICAgICAgdmFyIGZzbTsgLy8gcGxhY2Vob2xkZXIgZm9yIGluc3RhbmNlIGNvbnN0cnVjdG9yXG4gICAgICAgIHZhciBtYWNoT2JqID0ge307IC8vIG9iamVjdCB1c2VkIHRvIGhvbGQgaW5pdGlhbFN0YXRlICYgc3RhdGVzIGZyb20gcHJvdG90eXBlIGZvciBpbnN0YW5jZS1sZXZlbCBtZXJnaW5nXG4gICAgICAgIHZhciBjdG9yID0gZnVuY3Rpb24gKCkge307IC8vIHBsYWNlaG9sZGVyIGN0b3IgZnVuY3Rpb24gdXNlZCB0byBpbnNlcnQgbGV2ZWwgaW4gcHJvdG90eXBlIGNoYWluXG4gICAgICAgIC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3VcbiAgICAgICAgLy8gKHRoZSBcImNvbnN0cnVjdG9yXCIgcHJvcGVydHkgaW4geW91ciBgZXh0ZW5kYCBkZWZpbml0aW9uKSwgb3IgZGVmYXVsdGVkXG4gICAgICAgIC8vIGJ5IHVzIHRvIHNpbXBseSBjYWxsIHRoZSBwYXJlbnQncyBjb25zdHJ1Y3Rvci5cbiAgICAgICAgaWYgKHByb3RvUHJvcHMgJiYgcHJvdG9Qcm9wcy5oYXNPd25Qcm9wZXJ0eSgnY29uc3RydWN0b3InKSkge1xuICAgICAgICAgICAgZnNtID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IG1hY2hpbmEgY29uc3RydWN0b3IgKHdoZW4gdXNpbmcgaW5oZXJpdGFuY2UpIGNyZWF0ZXMgYVxuICAgICAgICAgICAgLy8gZGVlcCBjb3B5IG9mIHRoZSBzdGF0ZXMvaW5pdGlhbFN0YXRlIHZhbHVlcyBmcm9tIHRoZSBwcm90b3R5cGUgYW5kXG4gICAgICAgICAgICAvLyBleHRlbmRzIHRoZW0gb3ZlciB0aGUgaW5zdGFuY2Ugc28gdGhhdCB0aGV5J2xsIGJlIGluc3RhbmNlLWxldmVsLlxuICAgICAgICAgICAgLy8gSWYgYW4gb3B0aW9ucyBhcmcgKGFyZ3NbMF0pIGlzIHBhc3NlZCBpbiwgYSBzdGF0ZXMgb3IgaW50aWFsU3RhdGVcbiAgICAgICAgICAgIC8vIHZhbHVlIHdpbGwgYmUgcHJlZmVycmVkIG92ZXIgYW55IGRhdGEgcHVsbGVkIHVwIGZyb20gdGhlIHByb3RvdHlwZS5cbiAgICAgICAgICAgIGZzbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgICAgICAgICBhcmdzWzBdID0gYXJnc1swXSB8fCB7fTtcbiAgICAgICAgICAgICAgICB2YXIgYmxlbmRlZFN0YXRlO1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZVN0YXRlcyA9IGFyZ3NbMF0uc3RhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICAgIGJsZW5kZWRTdGF0ZSA9IF8ubWVyZ2UoXy5jbG9uZURlZXAobWFjaE9iaiksIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVzOiBpbnN0YW5jZVN0YXRlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJsZW5kZWRTdGF0ZS5pbml0aWFsU3RhdGUgPSBhcmdzWzBdLmluaXRpYWxTdGF0ZSB8fCB0aGlzLmluaXRpYWxTdGF0ZTtcbiAgICAgICAgICAgICAgICBfLmV4dGVuZChhcmdzWzBdLCBibGVuZGVkU3RhdGUpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbmhlcml0IGNsYXNzIChzdGF0aWMpIHByb3BlcnRpZXMgZnJvbSBwYXJlbnQuXG4gICAgICAgIF8ubWVyZ2UoZnNtLCBwYXJlbnQpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgcHJvdG90eXBlIGNoYWluIHRvIGluaGVyaXQgZnJvbSBgcGFyZW50YCwgd2l0aG91dCBjYWxsaW5nXG4gICAgICAgIC8vIGBwYXJlbnRgJ3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICAgIGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICAgICAgZnNtLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7XG5cbiAgICAgICAgLy8gQWRkIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChpbnN0YW5jZSBwcm9wZXJ0aWVzKSB0byB0aGUgc3ViY2xhc3MsXG4gICAgICAgIC8vIGlmIHN1cHBsaWVkLlxuICAgICAgICBpZiAocHJvdG9Qcm9wcykge1xuICAgICAgICAgICAgXy5leHRlbmQoZnNtLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgICAgICAgICBfLm1lcmdlKG1hY2hPYmosIF8udHJhbnNmb3JtKHByb3RvUHJvcHMsIGZ1bmN0aW9uIChhY2N1bSwgdmFsLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoX21hY2hLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjdW1ba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgc3RhdGljIHByb3BlcnRpZXMgdG8gdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBpZiBzdXBwbGllZC5cbiAgICAgICAgaWYgKHN0YXRpY1Byb3BzKSB7XG4gICAgICAgICAgICBfLm1lcmdlKGZzbSwgc3RhdGljUHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29ycmVjdGx5IHNldCBjaGlsZCdzIGBwcm90b3R5cGUuY29uc3RydWN0b3JgLlxuICAgICAgICBmc20ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZnNtO1xuXG4gICAgICAgIC8vIFNldCBhIGNvbnZlbmllbmNlIHByb3BlcnR5IGluIGNhc2UgdGhlIHBhcmVudCdzIHByb3RvdHlwZSBpcyBuZWVkZWQgbGF0ZXIuXG4gICAgICAgIGZzbS5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gZnNtO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVUlEKCkge1xuICAgICAgICB2YXIgcyA9IFtdO1xuICAgICAgICB2YXIgaGV4RGlnaXRzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzY7IGkrKykge1xuICAgICAgICAgICAgc1tpXSA9IGhleERpZ2l0cy5zdWJzdHIoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMCksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHNbMTRdID0gXCI0XCI7IC8vIGJpdHMgMTItMTUgb2YgdGhlIHRpbWVfaGlfYW5kX3ZlcnNpb24gZmllbGQgdG8gMDAxMFxuICAgICAgICBzWzE5XSA9IGhleERpZ2l0cy5zdWJzdHIoKHNbMTldICYgMHgzKSB8IDB4OCwgMSk7IC8vIGJpdHMgNi03IG9mIHRoZSBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkIHRvIDAxXG4gICAgICAgIHNbOF0gPSBzWzEzXSA9IHNbMThdID0gc1syM10gPSBcIi1cIjtcbiAgICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICB9XG5cbiAgICB2YXIgdXRpbHMgPSB7XG4gICAgICAgIG1ha2VGc21OYW1lc3BhY2U6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWFjaGluYUNvdW50ID0gMDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZnNtLlwiICsgbWFjaGluYUNvdW50Kys7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpLFxuICAgICAgICBsaXN0ZW5Ub0NoaWxkOiBsaXN0ZW5Ub0NoaWxkLFxuICAgICAgICBnZXRMZWFrbGVzc0FyZ3M6IGdldExlYWtsZXNzQXJncyxcbiAgICAgICAgZ2V0RGVmYXVsdE9wdGlvbnM6IGdldERlZmF1bHRCZWhhdmlvcmFsT3B0aW9ucyxcbiAgICAgICAgZ2V0RGVmYXVsdENsaWVudE1ldGE6IGdldERlZmF1bHRDbGllbnRNZXRhLFxuICAgICAgICBjcmVhdGVVVUlEOiBjcmVhdGVVVUlEXG4gICAgfTtcblxuICAgIHZhciBlbWl0dGVyID0ge1xuXG4gICAgICAgIGVtaXQ6IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gZ2V0TGVha2xlc3NBcmdzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudExpc3RlbmVyc1tcIipcIl0pIHtcbiAgICAgICAgICAgICAgICBfLmVhY2godGhpcy5ldmVudExpc3RlbmVyc1tcIipcIl0sIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMudXNlU2FmZUVtaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikgeyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZSAmJiB0eXBlb2YgY29uc29sZS5sb2cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXhjZXB0aW9uLnN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgICBfLmVhY2godGhpcy5ldmVudExpc3RlbmVyc1tldmVudE5hbWVdLCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnVzZVNhZmVFbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncy5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUgJiYgdHlwZW9mIGNvbnNvbGUubG9nICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4Y2VwdGlvbi5zdGFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb246IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLmV2ZW50TGlzdGVuZXJzID0gc2VsZi5ldmVudExpc3RlbmVycyB8fCB7XG4gICAgICAgICAgICAgICAgXCIqXCI6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFzZWxmLmV2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmV2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXZlbnROYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIG9mZjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9mZihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIG9mZjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzIHx8IHtcbiAgICAgICAgICAgICAgICBcIipcIjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIWV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSA9IF8ud2l0aG91dCh0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIHZhciBNQUNISU5BX1BST1AgPSBcIl9fbWFjaGluYV9fXCI7XG5cbiAgICBmdW5jdGlvbiBCZWhhdmlvcmFsRnNtKG9wdGlvbnMpIHtcbiAgICAgICAgXy5leHRlbmQodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIF8uZGVmYXVsdHModGhpcywgZ2V0RGVmYXVsdEJlaGF2aW9yYWxPcHRpb25zKCkpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgbWFjaGluYS5lbWl0KE5FV19GU00sIHRoaXMpO1xuICAgIH1cblxuICAgIF8uZXh0ZW5kKEJlaGF2aW9yYWxGc20ucHJvdG90eXBlLCB7XG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgIGluaXRDbGllbnQ6IGZ1bmN0aW9uIGluaXRDbGllbnQoY2xpZW50KSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5pbml0aWFsU3RhdGU7XG4gICAgICAgICAgICBpZiAoIWluaXRpYWxTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHNwZWNpZnkgYW4gaW5pdGlhbCBzdGF0ZSBmb3IgdGhpcyBGU01cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGVzW2luaXRpYWxTdGF0ZV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgaW5pdGlhbCBzdGF0ZSBzcGVjaWZpZWQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHN0YXRlcyBvYmplY3QuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uKGNsaWVudCwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbnN1cmVDbGllbnRNZXRhOiBmdW5jdGlvbiBlbnN1cmVDbGllbnRNZXRhKGNsaWVudCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjbGllbnQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBGU00gY2xpZW50IG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsaWVudFtNQUNISU5BX1BST1BdID0gY2xpZW50W01BQ0hJTkFfUFJPUF0gfHwge307XG4gICAgICAgICAgICBpZiAoIWNsaWVudFtNQUNISU5BX1BST1BdW3RoaXMubmFtZXNwYWNlXSkge1xuICAgICAgICAgICAgICAgIGNsaWVudFtNQUNISU5BX1BST1BdW3RoaXMubmFtZXNwYWNlXSA9IF8uY2xvbmVEZWVwKHV0aWxzLmdldERlZmF1bHRDbGllbnRNZXRhKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdENsaWVudChjbGllbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudFtNQUNISU5BX1BST1BdW3RoaXMubmFtZXNwYWNlXTtcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZEV2ZW50UGF5bG9hZDogZnVuY3Rpb24gKGNsaWVudCwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLmV4dGVuZChkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudDogY2xpZW50LFxuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IHRoaXMubmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudDogY2xpZW50LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogdGhpcy5uYW1lc3BhY2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEhhbmRsZXJBcmdzOiBmdW5jdGlvbiAoYXJncywgaXNDYXRjaEFsbCkge1xuICAgICAgICAgICAgLy8gaW5kZXggMCBpcyB0aGUgY2xpZW50LCBpbmRleCAxIGlzIGlucHV0VHlwZVxuICAgICAgICAgICAgLy8gaWYgd2UncmUgaW4gYSBjYXRjaC1hbGwgaGFuZGxlciwgaW5wdXQgdHlwZSBuZWVkcyB0byBiZSBpbmNsdWRlZCBpbiB0aGUgYXJnc1xuICAgICAgICAgICAgLy8gaW5wdXRUeXBlIG1pZ2h0IGJlIGFuIG9iamVjdCwgc28gd2UgbmVlZCB0byBqdXN0IGdldCB0aGUgaW5wdXRUeXBlIHN0cmluZyBpZiBzb1xuICAgICAgICAgICAgdmFyIF9hcmdzID0gYXJncy5zbGljZSgwKTtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IF9hcmdzWzFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIF9hcmdzLnNwbGljZSgxLCAxLCBpbnB1dC5pbnB1dFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzQ2F0Y2hBbGwgPyBfYXJncyA6IFtfYXJnc1swXV0uY29uY2F0KF9hcmdzLnNsaWNlKDIpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGU6IGZ1bmN0aW9uIChjbGllbnQsIGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRUeXBlO1xuICAgICAgICAgICAgdmFyIGRlbGVnYXRlZDtcbiAgICAgICAgICAgIHZhciB0aWNrZXQ7XG4gICAgICAgICAgICB2YXIgaW5wdXREZWYgPSBpbnB1dDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgaW5wdXQgYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBGU00ncyBoYW5kbGUgbWV0aG9kIGlzIHVuZGVmaW5lZC4gRGlkIHlvdSBmb3JnZXQgdG8gcGFzcyB0aGUgaW5wdXQgbmFtZT9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXREZWYgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0VHlwZTogaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRpY2tldDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjbGllbnRNZXRhID0gdGhpcy5lbnN1cmVDbGllbnRNZXRhKGNsaWVudCk7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGdldExlYWtsZXNzQXJncyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKDEsIDEsIGlucHV0RGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsaWVudE1ldGEuY3VycmVudEFjdGlvbkFyZ3MgPSBhcmdzLnNsaWNlKDEpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IGNsaWVudE1ldGEuc3RhdGU7XG4gICAgICAgICAgICB2YXIgc3RhdGVPYmogPSB0aGlzLnN0YXRlc1tjdXJyZW50U3RhdGVdO1xuICAgICAgICAgICAgdmFyIGhhbmRsZXJOYW1lO1xuICAgICAgICAgICAgdmFyIGhhbmRsZXI7XG4gICAgICAgICAgICB2YXIgaXNDYXRjaEFsbCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIGlmICghY2xpZW50TWV0YS5pbkV4aXRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBzdGF0ZU9iai5fY2hpbGQgJiYgc3RhdGVPYmouX2NoaWxkLmluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCAmJiAhdGhpcy5wZW5kaW5nRGVsZWdhdGlvbnNbaW5wdXREZWYudGlja2V0XSAmJiAhaW5wdXREZWYuYnViYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXREZWYudGlja2V0ID0gKGlucHV0RGVmLnRpY2tldCB8fCB1dGlscy5jcmVhdGVVVUlEKCkpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dERlZi5kZWxlZ2F0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEZWxlZ2F0aW9uc1tpbnB1dERlZi50aWNrZXRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVkVG86IGNoaWxkLm5hbWVzcGFjZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBXQVJOSU5HIC0gcmV0dXJuaW5nIGEgdmFsdWUgZnJvbSBgaGFuZGxlYCBvbiBjaGlsZCBGU01zIGlzIG5vdCByZWFsbHkgc3VwcG9ydGVkLlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB5b3UgbmVlZCB0byByZXR1cm4gdmFsdWVzIGZyb20gY2hpbGQgRlNNIGlucHV0IGhhbmRsZXJzLCB1c2UgZXZlbnRzIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNoaWxkLmhhbmRsZS5hcHBseShjaGlsZCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0RGVmLnRpY2tldCAmJiB0aGlzLnBlbmRpbmdEZWxlZ2F0aW9uc1tpbnB1dERlZi50aWNrZXRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wZW5kaW5nRGVsZWdhdGlvbnNbaW5wdXREZWYudGlja2V0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyTmFtZSA9IHN0YXRlT2JqW2lucHV0RGVmLmlucHV0VHlwZV0gPyBpbnB1dERlZi5pbnB1dFR5cGUgOiBcIipcIjtcbiAgICAgICAgICAgICAgICAgICAgaXNDYXRjaEFsbCA9IChoYW5kbGVyTmFtZSA9PT0gXCIqXCIpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyID0gKHN0YXRlT2JqW2hhbmRsZXJOYW1lXSB8fCB0aGlzW2hhbmRsZXJOYW1lXSkgfHwgdGhpc1tcIipcIl07XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IGNsaWVudE1ldGEuc3RhdGUgKyBcIi5cIiArIGhhbmRsZXJOYW1lO1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRNZXRhLmN1cnJlbnRBY3Rpb24gPSBhY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudFBheWxvYWQgPSB0aGlzLmJ1aWxkRXZlbnRQYXlsb2FkKFxuICAgICAgICAgICAgICAgICAgICBjbGllbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VHlwZTogaW5wdXREZWYuaW5wdXRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVkOiBpbnB1dERlZi5kZWxlZ2F0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrZXQ6IGlucHV0RGVmLnRpY2tldFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoTk9fSEFORExFUiwgXy5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGV2ZW50UGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KEhBTkRMSU5HLCBldmVudFBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyLmFwcGx5KHRoaXMsIHRoaXMuZ2V0SGFuZGxlckFyZ3MoYXJncywgaXNDYXRjaEFsbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbihjbGllbnQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KEhBTkRMRUQsIGV2ZW50UGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xpZW50TWV0YS5wcmlvckFjdGlvbiA9IGNsaWVudE1ldGEuY3VycmVudEFjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50TWV0YS5jdXJyZW50QWN0aW9uID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zaXRpb246IGZ1bmN0aW9uIChjbGllbnQsIG5ld1N0YXRlKSB7XG4gICAgICAgICAgICB2YXIgY2xpZW50TWV0YSA9IHRoaXMuZW5zdXJlQ2xpZW50TWV0YShjbGllbnQpO1xuICAgICAgICAgICAgdmFyIGN1clN0YXRlID0gY2xpZW50TWV0YS5zdGF0ZTtcbiAgICAgICAgICAgIHZhciBjdXJTdGF0ZU9iaiA9IHRoaXMuc3RhdGVzW2N1clN0YXRlXTtcbiAgICAgICAgICAgIHZhciBuZXdTdGF0ZU9iaiA9IHRoaXMuc3RhdGVzW25ld1N0YXRlXTtcbiAgICAgICAgICAgIHZhciBjaGlsZERlZjtcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIGlmICghY2xpZW50TWV0YS5pbkV4aXRIYW5kbGVyICYmIG5ld1N0YXRlICE9PSBjdXJTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZU9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGVPYmouX2NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZU9iai5fY2hpbGQgPSBnZXRDaGlsZEZzbUluc3RhbmNlKG5ld1N0YXRlT2JqLl9jaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IG5ld1N0YXRlT2JqLl9jaGlsZCAmJiBuZXdTdGF0ZU9iai5fY2hpbGQuaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clN0YXRlT2JqICYmIGN1clN0YXRlT2JqLl9vbkV4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudE1ldGEuaW5FeGl0SGFuZGxlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJTdGF0ZU9iai5fb25FeGl0LmNhbGwodGhpcywgY2xpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudE1ldGEuaW5FeGl0SGFuZGxlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJTdGF0ZU9iaiAmJiBjdXJTdGF0ZU9iai5fY2hpbGQgJiYgY3VyU3RhdGVPYmouX2NoaWxkLmluc3RhbmNlICYmIHRoaXMuaGllcmFyY2h5W2N1clN0YXRlT2JqLl9jaGlsZC5pbnN0YW5jZS5uYW1lc3BhY2VdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZXJhcmNoeVtjdXJTdGF0ZU9iai5fY2hpbGQuaW5zdGFuY2UubmFtZXNwYWNlXS5vZmYoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbGllbnRNZXRhLnRhcmdldFJlcGxheVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudE1ldGEucHJpb3JTdGF0ZSA9IGN1clN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRNZXRhLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWVyYXJjaHlbY2hpbGQubmFtZXNwYWNlXSA9IHV0aWxzLmxpc3RlblRvQ2hpbGQodGhpcywgY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudFBheWxvYWQgPSB0aGlzLmJ1aWxkRXZlbnRQYXlsb2FkKGNsaWVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVN0YXRlOiBjbGllbnRNZXRhLnByaW9yU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGNsaWVudE1ldGEuY3VycmVudEFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RhdGU6IG5ld1N0YXRlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoVFJBTlNJVElPTiwgZXZlbnRQYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1N0YXRlT2JqLl9vbkVudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZU9iai5fb25FbnRlci5jYWxsKHRoaXMsIGNsaWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5oYW5kbGUoY2xpZW50LCBcIl9yZXNldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50TWV0YS50YXJnZXRSZXBsYXlTdGF0ZSA9PT0gbmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1F1ZXVlKGNsaWVudCwgTkVYVF9UUkFOU0lUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChJTlZBTElEX1NUQVRFLCB0aGlzLmJ1aWxkRXZlbnRQYXlsb2FkKGNsaWVudCwge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogY2xpZW50TWV0YS5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdGVkU3RhdGU6IG5ld1N0YXRlXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRlZmVyVW50aWxUcmFuc2l0aW9uOiBmdW5jdGlvbiAoY2xpZW50LCBzdGF0ZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjbGllbnRNZXRhID0gdGhpcy5lbnN1cmVDbGllbnRNZXRhKGNsaWVudCk7XG4gICAgICAgICAgICBpZiAoY2xpZW50TWV0YS5jdXJyZW50QWN0aW9uQXJncykge1xuICAgICAgICAgICAgICAgIHZhciBxdWV1ZWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE5FWFRfVFJBTlNJVElPTixcbiAgICAgICAgICAgICAgICAgICAgdW50aWxTdGF0ZTogc3RhdGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBjbGllbnRNZXRhLmN1cnJlbnRBY3Rpb25BcmdzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjbGllbnRNZXRhLmlucHV0UXVldWUucHVzaChxdWV1ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBldmVudFBheWxvYWQgPSB0aGlzLmJ1aWxkRXZlbnRQYXlsb2FkKGNsaWVudCwge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogY2xpZW50TWV0YS5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgcXVldWVkQXJnczogcXVldWVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KERFRkVSUkVELCBldmVudFBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRlZmVyQW5kVHJhbnNpdGlvbjogZnVuY3Rpb24gKGNsaWVudCwgc3RhdGVOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmVyVW50aWxUcmFuc2l0aW9uKGNsaWVudCwgc3RhdGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbihjbGllbnQsIHN0YXRlTmFtZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJvY2Vzc1F1ZXVlOiBmdW5jdGlvbiAoY2xpZW50KSB7XG4gICAgICAgICAgICB2YXIgY2xpZW50TWV0YSA9IHRoaXMuZW5zdXJlQ2xpZW50TWV0YShjbGllbnQpO1xuICAgICAgICAgICAgdmFyIGZpbHRlckZuID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCghaXRlbS51bnRpbFN0YXRlKSB8fCAoaXRlbS51bnRpbFN0YXRlID09PSBjbGllbnRNZXRhLnN0YXRlKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRvUHJvY2VzcyA9IF8uZmlsdGVyKGNsaWVudE1ldGEuaW5wdXRRdWV1ZSwgZmlsdGVyRm4pO1xuICAgICAgICAgICAgY2xpZW50TWV0YS5pbnB1dFF1ZXVlID0gXy5kaWZmZXJlbmNlKGNsaWVudE1ldGEuaW5wdXRRdWV1ZSwgdG9Qcm9jZXNzKTtcbiAgICAgICAgICAgIF8uZWFjaCh0b1Byb2Nlc3MsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGUuYXBwbHkodGhpcywgW2NsaWVudF0uY29uY2F0KGl0ZW0uYXJncykpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gKGNsaWVudCwgbmFtZSkge1xuICAgICAgICAgICAgdmFyIGNsaWVudE1ldGEgPSB0aGlzLmVuc3VyZUNsaWVudE1ldGEoY2xpZW50KTtcbiAgICAgICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgICAgIGNsaWVudE1ldGEuaW5wdXRRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gZnVuY3Rpb24gKGV2bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChuYW1lID8gZXZudC51bnRpbFN0YXRlICE9PSBuYW1lIDogdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjbGllbnRNZXRhLmlucHV0UXVldWUgPSBfLmZpbHRlcihjbGllbnRNZXRhLmlucHV0UXVldWUsIGZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBlbWl0dGVyKTtcblxuICAgIEJlaGF2aW9yYWxGc20uZXh0ZW5kID0gZXh0ZW5kO1xuXG4gICAgdmFyIEZzbSA9IEJlaGF2aW9yYWxGc20uZXh0ZW5kKHtcbiAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIEJlaGF2aW9yYWxGc20uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlQ2xpZW50TWV0YSgpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0Q2xpZW50OiBmdW5jdGlvbiBpbml0Q2xpZW50KCkge1xuICAgICAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuaW5pdGlhbFN0YXRlO1xuICAgICAgICAgICAgaWYgKCFpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBzcGVjaWZ5IGFuIGluaXRpYWwgc3RhdGUgZm9yIHRoaXMgRlNNXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlc1tpbml0aWFsU3RhdGVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGluaXRpYWwgc3RhdGUgc3BlY2lmaWVkIGRvZXMgbm90IGV4aXN0IGluIHRoZSBzdGF0ZXMgb2JqZWN0LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbihpbml0aWFsU3RhdGUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnN1cmVDbGllbnRNZXRhOiBmdW5jdGlvbiBlbnN1cmVDbGllbnRNZXRhKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFtcGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhbXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgXy5kZWZhdWx0cyh0aGlzLCBfLmNsb25lRGVlcChnZXREZWZhdWx0Q2xpZW50TWV0YSgpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0Q2xpZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBlbnN1cmVDbGllbnRBcmc6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICB2YXIgX2FyZ3MgPSBhcmdzO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB0ZXN0IHRoZSBhcmdzIGFuZCB2ZXJpZnkgdGhhdCBpZiBhIGNsaWVudCBhcmcgaGFzXG4gICAgICAgICAgICAvLyBiZWVuIHBhc3NlZCwgaXQgbXVzdCBiZSB0aGlzIEZTTSBpbnN0YW5jZSAodGhpcyBpc24ndCBhIGJlaGF2aW9yYWwgRlNNKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBfYXJnc1swXSA9PT0gXCJvYmplY3RcIiAmJiAhKFwiaW5wdXRUeXBlXCIgaW4gX2FyZ3NbMF0pICYmIF9hcmdzWzBdICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgX2FyZ3Muc3BsaWNlKDAsIDEsIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgX2FyZ3NbMF0gIT09IFwib2JqZWN0XCIgfHwgKHR5cGVvZiBfYXJnc1swXSA9PT0gXCJvYmplY3RcIiAmJiAoXCJpbnB1dFR5cGVcIiBpbiBfYXJnc1swXSkpKSB7XG4gICAgICAgICAgICAgICAgX2FyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfYXJncztcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRIYW5kbGVyQXJnczogZnVuY3Rpb24gKGFyZ3MsIGlzQ2F0Y2hBbGwpIHtcbiAgICAgICAgICAgIC8vIGluZGV4IDAgaXMgdGhlIGNsaWVudCwgaW5kZXggMSBpcyBpbnB1dFR5cGVcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGluIGEgY2F0Y2gtYWxsIGhhbmRsZXIsIGlucHV0IHR5cGUgbmVlZHMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIGFyZ3NcbiAgICAgICAgICAgIC8vIGlucHV0VHlwZSBtaWdodCBiZSBhbiBvYmplY3QsIHNvIHdlIG5lZWQgdG8ganVzdCBnZXQgdGhlIGlucHV0VHlwZSBzdHJpbmcgaWYgc29cbiAgICAgICAgICAgIHZhciBfYXJncyA9IGFyZ3M7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBfYXJnc1sxXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXRUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgX2FyZ3Muc3BsaWNlKDEsIDEsIGlucHV0LmlucHV0VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNDYXRjaEFsbCA/IF9hcmdzLnNsaWNlKDEpIDogX2FyZ3Muc2xpY2UoMik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFwiY2xhc3NpY1wiIG1hY2hpbmEgRlNNIGRvIG5vdCBlbWl0IHRoZSBjbGllbnQgcHJvcGVydHkgb24gZXZlbnRzICh3aGljaCB3b3VsZCBiZSB0aGUgRlNNIGl0c2VsZilcbiAgICAgICAgYnVpbGRFdmVudFBheWxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5lbnN1cmVDbGllbnRBcmcodXRpbHMuZ2V0TGVha2xlc3NBcmdzKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBhcmdzWzFdO1xuICAgICAgICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLmV4dGVuZChkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogdGhpcy5uYW1lc3BhY2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IHRoaXMubmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlOiBmdW5jdGlvbiAoaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMuZW5zdXJlQ2xpZW50QXJnKHV0aWxzLmdldExlYWtsZXNzQXJncyhhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIHJldHVybiBCZWhhdmlvcmFsRnNtLnByb3RvdHlwZS5oYW5kbGUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zaXRpb246IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLmVuc3VyZUNsaWVudEFyZyh1dGlscy5nZXRMZWFrbGVzc0FyZ3MoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICByZXR1cm4gQmVoYXZpb3JhbEZzbS5wcm90b3R5cGUudHJhbnNpdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVmZXJVbnRpbFRyYW5zaXRpb246IGZ1bmN0aW9uIChzdGF0ZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5lbnN1cmVDbGllbnRBcmcodXRpbHMuZ2V0TGVha2xlc3NBcmdzKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgcmV0dXJuIEJlaGF2aW9yYWxGc20ucHJvdG90eXBlLmRlZmVyVW50aWxUcmFuc2l0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBwcm9jZXNzUXVldWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5lbnN1cmVDbGllbnRBcmcodXRpbHMuZ2V0TGVha2xlc3NBcmdzKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgcmV0dXJuIEJlaGF2aW9yYWxGc20ucHJvdG90eXBlLnByb2Nlc3NRdWV1ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gKHN0YXRlTmFtZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLmVuc3VyZUNsaWVudEFyZyh1dGlscy5nZXRMZWFrbGVzc0FyZ3MoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICByZXR1cm4gQmVoYXZpb3JhbEZzbS5wcm90b3R5cGUuY2xlYXJRdWV1ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIG1hY2hpbmEgPSBfLm1lcmdlKGVtaXR0ZXIsIHtcbiAgICAgICAgRnNtOiBGc20sXG4gICAgICAgIEJlaGF2aW9yYWxGc206IEJlaGF2aW9yYWxGc20sXG4gICAgICAgIHV0aWxzOiB1dGlscyxcbiAgICAgICAgZXZlbnRMaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgIG5ld0ZzbTogW11cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1hY2hpbmE7XG59KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbWFjaGluYS9saWIvbWFjaGluYS5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=');

},function(module,exports,__webpack_require__){eval('module.exports={"v":3,"t":[{"t":7,"e":"svg","f":[{"t":7,"e":"style","a":{"type":"text/css"},"f":["#storeys rect {\\n\\t\\t\\tfill:none;\\n\\t\\t\\tstroke:black;\\n\\t\\t\\tstroke-width:1px;\\n\\t\\t}\\n\\t\\trect#elevator {\\n\\t\\t\\tfill:none;\\n\\t\\t\\tstroke:black;\\n\\t\\t\\tstroke-width:1px;\\n\\t\\t}\\n\\t\\tsvg {\\n\\t\\t\\theight: 1000px;\\n\\t\\t\\twidth:800px;\\n\\t\\t}"]}," ",{"t":7,"e":"g","a":{"transform":"translate(30,30)"},"f":[" ",{"t":7,"e":"g","a":{"id":"storeys"},"f":[{"t":4,"f":[{"t":7,"e":"rect","a":{"width":[{"t":2,"r":"width"}],"height":[{"t":2,"r":"height"}],"x":[{"t":2,"r":"x"}],"y":[{"t":2,"r":"y"}]}}],"r":"storeys"}]}," ",{"t":7,"e":"rect","a":{"id":"elevator","width":[{"t":2,"r":"elv.width"}],"height":[{"t":2,"r":"elv.height"}],"x":[{"t":2,"r":"elv.x"}],"y":[{"t":2,"r":"elv.y"}]}}]}]}]};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvdHBsL2FwcC5zdmc/OTRiOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsWUFBWSxzQkFBc0IsdUJBQXVCLGtCQUFrQixzQkFBc0Isa0JBQWtCLHFCQUFxQix5QkFBeUIsT0FBTyxxQkFBcUIsa0JBQWtCLHFCQUFxQix5QkFBeUIsT0FBTyxXQUFXLHVCQUF1QixvQkFBb0IsT0FBTyxHQUFHLE1BQU0sbUJBQW1CLCtCQUErQixXQUFXLG1CQUFtQixlQUFlLE9BQU8sWUFBWSxzQkFBc0IsVUFBVSxrQkFBa0IsYUFBYSxtQkFBbUIsUUFBUSxjQUFjLFFBQVEsY0FBYyxHQUFHLGdCQUFnQixFQUFFLE1BQU0sc0JBQXNCLDBCQUEwQixzQkFBc0IsYUFBYSx1QkFBdUIsUUFBUSxrQkFBa0IsUUFBUSxrQkFBa0IsR0FBRyxFQUFFLEVBQUUiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtcInZcIjozLFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcInN2Z1wiLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcInN0eWxlXCIsXCJhXCI6e1widHlwZVwiOlwidGV4dC9jc3NcIn0sXCJmXCI6W1wiI3N0b3JleXMgcmVjdCB7XFxuXFx0XFx0XFx0ZmlsbDpub25lO1xcblxcdFxcdFxcdHN0cm9rZTpibGFjaztcXG5cXHRcXHRcXHRzdHJva2Utd2lkdGg6MXB4O1xcblxcdFxcdH1cXG5cXHRcXHRyZWN0I2VsZXZhdG9yIHtcXG5cXHRcXHRcXHRmaWxsOm5vbmU7XFxuXFx0XFx0XFx0c3Ryb2tlOmJsYWNrO1xcblxcdFxcdFxcdHN0cm9rZS13aWR0aDoxcHg7XFxuXFx0XFx0fVxcblxcdFxcdHN2ZyB7XFxuXFx0XFx0XFx0aGVpZ2h0OiAxMDAwcHg7XFxuXFx0XFx0XFx0d2lkdGg6ODAwcHg7XFxuXFx0XFx0fVwiXX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJnXCIsXCJhXCI6e1widHJhbnNmb3JtXCI6XCJ0cmFuc2xhdGUoMzAsMzApXCJ9LFwiZlwiOltcIiBcIix7XCJ0XCI6NyxcImVcIjpcImdcIixcImFcIjp7XCJpZFwiOlwic3RvcmV5c1wifSxcImZcIjpbe1widFwiOjQsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwicmVjdFwiLFwiYVwiOntcIndpZHRoXCI6W3tcInRcIjoyLFwiclwiOlwid2lkdGhcIn1dLFwiaGVpZ2h0XCI6W3tcInRcIjoyLFwiclwiOlwiaGVpZ2h0XCJ9XSxcInhcIjpbe1widFwiOjIsXCJyXCI6XCJ4XCJ9XSxcInlcIjpbe1widFwiOjIsXCJyXCI6XCJ5XCJ9XX19XSxcInJcIjpcInN0b3JleXNcIn1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcInJlY3RcIixcImFcIjp7XCJpZFwiOlwiZWxldmF0b3JcIixcIndpZHRoXCI6W3tcInRcIjoyLFwiclwiOlwiZWx2LndpZHRoXCJ9XSxcImhlaWdodFwiOlt7XCJ0XCI6MixcInJcIjpcImVsdi5oZWlnaHRcIn1dLFwieFwiOlt7XCJ0XCI6MixcInJcIjpcImVsdi54XCJ9XSxcInlcIjpbe1widFwiOjIsXCJyXCI6XCJlbHYueVwifV19fV19XX1dfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL2pzL3RwbC9hcHAuc3ZnXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('/*\n	Ractive.js v0.7.2\n	Thu Apr 02 2015 13:53:56 GMT-0400 (EDT) - commit 8bae4689db1bb54ce0804697b66c658639a53e93\n\n	http://ractivejs.org\n	http://twitter.com/RactiveJS\n\n	Released under the MIT License.\n*/\n\n(function (global, factory) {\n  true ? module.exports = factory() :\n  typeof define === \'function\' && define.amd ? define(factory) :\n  global.Ractive = factory()\n}(this, function () { \'use strict\';\n\n  var TEMPLATE_VERSION = 3;\n\n  var defaultOptions = {\n\n  	// render placement:\n  	el: void 0,\n  	append: false,\n\n  	// template:\n  	template: { v: TEMPLATE_VERSION, t: [] },\n\n  	// parse:     // TODO static delimiters?\n  	preserveWhitespace: false,\n  	sanitize: false,\n  	stripComments: true,\n  	delimiters: ["{{", "}}"],\n  	tripleDelimiters: ["{{{", "}}}"],\n  	interpolate: false,\n\n  	// data & binding:\n  	data: {},\n  	computed: {},\n  	magic: false,\n  	modifyArrays: true,\n  	adapt: [],\n  	isolated: false,\n  	twoway: true,\n  	lazy: false,\n\n  	// transitions:\n  	noIntro: false,\n  	transitionsEnabled: true,\n  	complete: void 0,\n\n  	// css:\n  	css: null,\n  	noCssTransform: false\n  };\n\n  var config_defaults = defaultOptions;\n\n  // These are a subset of the easing equations found at\n  // https://raw.github.com/danro/easing-js - license info\n  // follows:\n\n  // --------------------------------------------------\n  // easing.js v0.5.4\n  // Generic set of easing functions with AMD support\n  // https://github.com/danro/easing-js\n  // This code may be freely distributed under the MIT license\n  // http://danro.mit-license.org/\n  // --------------------------------------------------\n  // All functions adapted from Thomas Fuchs & Jeremy Kahn\n  // Easing Equations (c) 2003 Robert Penner, BSD license\n  // https://raw.github.com/danro/easing-js/master/LICENSE\n  // --------------------------------------------------\n\n  // In that library, the functions named easeIn, easeOut, and\n  // easeInOut below are named easeInCubic, easeOutCubic, and\n  // (you guessed it) easeInOutCubic.\n  //\n  // You can add additional easing functions to this list, and they\n  // will be globally available.\n\n  var static_easing = {\n  	linear: function (pos) {\n  		return pos;\n  	},\n  	easeIn: function (pos) {\n  		return Math.pow(pos, 3);\n  	},\n  	easeOut: function (pos) {\n  		return Math.pow(pos - 1, 3) + 1;\n  	},\n  	easeInOut: function (pos) {\n  		if ((pos /= 0.5) < 1) {\n  			return 0.5 * Math.pow(pos, 3);\n  		}\n  		return 0.5 * (Math.pow(pos - 2, 3) + 2);\n  	}\n  };\n\n  /*global console, navigator */\n  var isClient, isJsdom, hasConsole, environment__magic, namespaces, svg, vendors;\n\n  isClient = typeof document === "object";\n\n  isJsdom = typeof navigator !== "undefined" && /jsDom/.test(navigator.appName);\n\n  hasConsole = typeof console !== "undefined" && typeof console.warn === "function" && typeof console.warn.apply === "function";\n\n  try {\n  	Object.defineProperty({}, "test", { value: 0 });\n  	environment__magic = true;\n  } catch (e) {\n  	environment__magic = false;\n  }\n\n  namespaces = {\n  	html: "http://www.w3.org/1999/xhtml",\n  	mathml: "http://www.w3.org/1998/Math/MathML",\n  	svg: "http://www.w3.org/2000/svg",\n  	xlink: "http://www.w3.org/1999/xlink",\n  	xml: "http://www.w3.org/XML/1998/namespace",\n  	xmlns: "http://www.w3.org/2000/xmlns/"\n  };\n\n  if (typeof document === "undefined") {\n  	svg = false;\n  } else {\n  	svg = document && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");\n  }\n\n  vendors = ["o", "ms", "moz", "webkit"];\n\n  var createElement, matches, dom__div, methodNames, unprefixed, prefixed, dom__i, j, makeFunction;\n\n  // Test for SVG support\n  if (!svg) {\n  	createElement = function (type, ns) {\n  		if (ns && ns !== namespaces.html) {\n  			throw "This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information";\n  		}\n\n  		return document.createElement(type);\n  	};\n  } else {\n  	createElement = function (type, ns) {\n  		if (!ns || ns === namespaces.html) {\n  			return document.createElement(type);\n  		}\n\n  		return document.createElementNS(ns, type);\n  	};\n  }\n\n  function getElement(input) {\n  	var output;\n\n  	if (!input || typeof input === "boolean") {\n  		return;\n  	}\n\n  	if (typeof window === "undefined" || !document || !input) {\n  		return null;\n  	}\n\n  	// We already have a DOM node - no work to do. (Duck typing alert!)\n  	if (input.nodeType) {\n  		return input;\n  	}\n\n  	// Get node from string\n  	if (typeof input === "string") {\n  		// try ID first\n  		output = document.getElementById(input);\n\n  		// then as selector, if possible\n  		if (!output && document.querySelector) {\n  			output = document.querySelector(input);\n  		}\n\n  		// did it work?\n  		if (output && output.nodeType) {\n  			return output;\n  		}\n  	}\n\n  	// If we\'ve been given a collection (jQuery, Zepto etc), extract the first item\n  	if (input[0] && input[0].nodeType) {\n  		return input[0];\n  	}\n\n  	return null;\n  }\n\n  if (!isClient) {\n  	matches = null;\n  } else {\n  	dom__div = createElement("div");\n  	methodNames = ["matches", "matchesSelector"];\n\n  	makeFunction = function (methodName) {\n  		return function (node, selector) {\n  			return node[methodName](selector);\n  		};\n  	};\n\n  	dom__i = methodNames.length;\n\n  	while (dom__i-- && !matches) {\n  		unprefixed = methodNames[dom__i];\n\n  		if (dom__div[unprefixed]) {\n  			matches = makeFunction(unprefixed);\n  		} else {\n  			j = vendors.length;\n  			while (j--) {\n  				prefixed = vendors[dom__i] + unprefixed.substr(0, 1).toUpperCase() + unprefixed.substring(1);\n\n  				if (dom__div[prefixed]) {\n  					matches = makeFunction(prefixed);\n  					break;\n  				}\n  			}\n  		}\n  	}\n\n  	// IE8...\n  	if (!matches) {\n  		matches = function (node, selector) {\n  			var nodes, parentNode, i;\n\n  			parentNode = node.parentNode;\n\n  			if (!parentNode) {\n  				// empty dummy <div>\n  				dom__div.innerHTML = "";\n\n  				parentNode = dom__div;\n  				node = node.cloneNode();\n\n  				dom__div.appendChild(node);\n  			}\n\n  			nodes = parentNode.querySelectorAll(selector);\n\n  			i = nodes.length;\n  			while (i--) {\n  				if (nodes[i] === node) {\n  					return true;\n  				}\n  			}\n\n  			return false;\n  		};\n  	}\n  }\n\n  function detachNode(node) {\n  	if (node && typeof node.parentNode !== "unknown" && node.parentNode) {\n  		node.parentNode.removeChild(node);\n  	}\n\n  	return node;\n  }\n\n  function safeToStringValue(value) {\n  	return value == null || !value.toString ? "" : value;\n  }\n\n  var legacy = null;\n\n  var create, defineProperty, defineProperties;\n\n  try {\n  	Object.defineProperty({}, "test", { value: 0 });\n\n  	if (isClient) {\n  		Object.defineProperty(document.createElement("div"), "test", { value: 0 });\n  	}\n\n  	defineProperty = Object.defineProperty;\n  } catch (err) {\n  	// Object.defineProperty doesn\'t exist, or we\'re in IE8 where you can\n  	// only use it with DOM objects (what were you smoking, MSFT?)\n  	defineProperty = function (obj, prop, desc) {\n  		obj[prop] = desc.value;\n  	};\n  }\n\n  try {\n  	try {\n  		Object.defineProperties({}, { test: { value: 0 } });\n  	} catch (err) {\n  		// TODO how do we account for this? noMagic = true;\n  		throw err;\n  	}\n\n  	if (isClient) {\n  		Object.defineProperties(createElement("div"), { test: { value: 0 } });\n  	}\n\n  	defineProperties = Object.defineProperties;\n  } catch (err) {\n  	defineProperties = function (obj, props) {\n  		var prop;\n\n  		for (prop in props) {\n  			if (props.hasOwnProperty(prop)) {\n  				defineProperty(obj, prop, props[prop]);\n  			}\n  		}\n  	};\n  }\n\n  try {\n  	Object.create(null);\n\n  	create = Object.create;\n  } catch (err) {\n  	// sigh\n  	create = (function () {\n  		var F = function () {};\n\n  		return function (proto, props) {\n  			var obj;\n\n  			if (proto === null) {\n  				return {};\n  			}\n\n  			F.prototype = proto;\n  			obj = new F();\n\n  			if (props) {\n  				Object.defineProperties(obj, props);\n  			}\n\n  			return obj;\n  		};\n  	})();\n  }\n\n  function utils_object__extend(target) {\n  	for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  		sources[_key - 1] = arguments[_key];\n  	}\n\n  	var prop, source;\n\n  	while (source = sources.shift()) {\n  		for (prop in source) {\n  			if (hasOwn.call(source, prop)) {\n  				target[prop] = source[prop];\n  			}\n  		}\n  	}\n\n  	return target;\n  }\n\n  function fillGaps(target) {\n  	for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  		sources[_key - 1] = arguments[_key];\n  	}\n\n  	sources.forEach(function (s) {\n  		for (var key in s) {\n  			if (s.hasOwnProperty(key) && !(key in target)) {\n  				target[key] = s[key];\n  			}\n  		}\n  	});\n\n  	return target;\n  }\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  // thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n  var is__toString = Object.prototype.toString,\n      arrayLikePattern = /^\\[object (?:Array|FileList)\\]$/;\n  function isArray(thing) {\n  	return is__toString.call(thing) === "[object Array]";\n  }\n\n  function isArrayLike(obj) {\n  	return arrayLikePattern.test(is__toString.call(obj));\n  }\n\n  function isEqual(a, b) {\n  	if (a === null && b === null) {\n  		return true;\n  	}\n\n  	if (typeof a === "object" || typeof b === "object") {\n  		return false;\n  	}\n\n  	return a === b;\n  }\n\n  function is__isNumeric(thing) {\n  	return !isNaN(parseFloat(thing)) && isFinite(thing);\n  }\n\n  function isObject(thing) {\n  	return thing && is__toString.call(thing) === "[object Object]";\n  }\n\n  var noop = function () {};\n\n  /* global console */\n  var alreadyWarned = {},\n      log,\n      printWarning,\n      welcome;\n\n  if (hasConsole) {\n  	(function () {\n  		var welcomeIntro = ["%cRactive.js %c0.7.2 %cin debug mode, %cmore...", "color: rgb(114, 157, 52); font-weight: normal;", "color: rgb(85, 85, 85); font-weight: normal;", "color: rgb(85, 85, 85); font-weight: normal;", "color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;"];\n  		var welcomeMessage = "You\'re running Ractive 0.7.2 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\\n\\nTo disable debug mode, add this line at the start of your app:\\n  Ractive.DEBUG = false;\\n\\nTo disable debug mode when your app is minified, add this snippet:\\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\\n\\nGet help and support:\\n  http://docs.ractivejs.org\\n  http://stackoverflow.com/questions/tagged/ractivejs\\n  http://groups.google.com/forum/#!forum/ractive-js\\n  http://twitter.com/ractivejs\\n\\nFound a bug? Raise an issue:\\n  https://github.com/ractivejs/ractive/issues\\n\\n";\n\n  		welcome = function () {\n  			var hasGroup = !!console.groupCollapsed;\n  			console[hasGroup ? "groupCollapsed" : "log"].apply(console, welcomeIntro);\n  			console.log(welcomeMessage);\n  			if (hasGroup) {\n  				console.groupEnd(welcomeIntro);\n  			}\n\n  			welcome = noop;\n  		};\n\n  		printWarning = function (message, args) {\n  			welcome();\n\n  			// extract information about the instance this message pertains to, if applicable\n  			if (typeof args[args.length - 1] === "object") {\n  				var options = args.pop();\n  				var ractive = options ? options.ractive : null;\n\n  				if (ractive) {\n  					// if this is an instance of a component that we know the name of, add\n  					// it to the message\n  					var _name = undefined;\n  					if (ractive.component && (_name = ractive.component.name)) {\n  						message = "<" + _name + "> " + message;\n  					}\n\n  					var node = undefined;\n  					if (node = options.node || ractive.fragment && ractive.fragment.rendered && ractive.find("*")) {\n  						args.push(node);\n  					}\n  				}\n  			}\n\n  			console.warn.apply(console, ["%cRactive.js: %c" + message, "color: rgb(114, 157, 52);", "color: rgb(85, 85, 85);"].concat(args));\n  		};\n\n  		log = function () {\n  			console.log.apply(console, arguments);\n  		};\n  	})();\n  } else {\n  	printWarning = log = welcome = noop;\n  }\n\n  function format(message, args) {\n  	return message.replace(/%s/g, function () {\n  		return args.shift();\n  	});\n  }\n\n  function fatal(message) {\n  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  		args[_key - 1] = arguments[_key];\n  	}\n\n  	message = format(message, args);\n  	throw new Error(message);\n  }\n\n  function logIfDebug() {\n  	if (_Ractive.DEBUG) {\n  		log.apply(null, arguments);\n  	}\n  }\n\n  function warn(message) {\n  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  		args[_key - 1] = arguments[_key];\n  	}\n\n  	message = format(message, args);\n  	printWarning(message, args);\n  }\n\n  function warnOnce(message) {\n  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  		args[_key - 1] = arguments[_key];\n  	}\n\n  	message = format(message, args);\n\n  	if (alreadyWarned[message]) {\n  		return;\n  	}\n\n  	alreadyWarned[message] = true;\n  	printWarning(message, args);\n  }\n\n  function warnIfDebug() {\n  	if (_Ractive.DEBUG) {\n  		warn.apply(null, arguments);\n  	}\n  }\n\n  function warnOnceIfDebug() {\n  	if (_Ractive.DEBUG) {\n  		warnOnce.apply(null, arguments);\n  	}\n  }\n\n  // Error messages that are used (or could be) in multiple places\n  var badArguments = "Bad arguments";\n  var noRegistryFunctionReturn = "A function was specified for \\"%s\\" %s, but no %s was returned";\n  var missingPlugin = function (name, type) {\n    return "Missing \\"" + name + "\\" " + type + " plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#" + type + "s";\n  };\n\n  function findInViewHierarchy(registryName, ractive, name) {\n  	var instance = findInstance(registryName, ractive, name);\n  	return instance ? instance[registryName][name] : null;\n  }\n\n  function findInstance(registryName, ractive, name) {\n  	while (ractive) {\n  		if (name in ractive[registryName]) {\n  			return ractive;\n  		}\n\n  		if (ractive.isolated) {\n  			return null;\n  		}\n\n  		ractive = ractive.parent;\n  	}\n  }\n\n  var interpolate = function (from, to, ractive, type) {\n  	if (from === to) {\n  		return snap(to);\n  	}\n\n  	if (type) {\n\n  		var interpol = findInViewHierarchy("interpolators", ractive, type);\n  		if (interpol) {\n  			return interpol(from, to) || snap(to);\n  		}\n\n  		fatal(missingPlugin(type, "interpolator"));\n  	}\n\n  	return static_interpolators.number(from, to) || static_interpolators.array(from, to) || static_interpolators.object(from, to) || snap(to);\n  };\n\n  var shared_interpolate = interpolate;\n\n  function snap(to) {\n  	return function () {\n  		return to;\n  	};\n  }\n\n  var interpolators = {\n  	number: function (from, to) {\n  		var delta;\n\n  		if (!is__isNumeric(from) || !is__isNumeric(to)) {\n  			return null;\n  		}\n\n  		from = +from;\n  		to = +to;\n\n  		delta = to - from;\n\n  		if (!delta) {\n  			return function () {\n  				return from;\n  			};\n  		}\n\n  		return function (t) {\n  			return from + t * delta;\n  		};\n  	},\n\n  	array: function (from, to) {\n  		var intermediate, interpolators, len, i;\n\n  		if (!isArray(from) || !isArray(to)) {\n  			return null;\n  		}\n\n  		intermediate = [];\n  		interpolators = [];\n\n  		i = len = Math.min(from.length, to.length);\n  		while (i--) {\n  			interpolators[i] = shared_interpolate(from[i], to[i]);\n  		}\n\n  		// surplus values - don\'t interpolate, but don\'t exclude them either\n  		for (i = len; i < from.length; i += 1) {\n  			intermediate[i] = from[i];\n  		}\n\n  		for (i = len; i < to.length; i += 1) {\n  			intermediate[i] = to[i];\n  		}\n\n  		return function (t) {\n  			var i = len;\n\n  			while (i--) {\n  				intermediate[i] = interpolators[i](t);\n  			}\n\n  			return intermediate;\n  		};\n  	},\n\n  	object: function (from, to) {\n  		var properties, len, interpolators, intermediate, prop;\n\n  		if (!isObject(from) || !isObject(to)) {\n  			return null;\n  		}\n\n  		properties = [];\n  		intermediate = {};\n  		interpolators = {};\n\n  		for (prop in from) {\n  			if (hasOwn.call(from, prop)) {\n  				if (hasOwn.call(to, prop)) {\n  					properties.push(prop);\n  					interpolators[prop] = shared_interpolate(from[prop], to[prop]);\n  				} else {\n  					intermediate[prop] = from[prop];\n  				}\n  			}\n  		}\n\n  		for (prop in to) {\n  			if (hasOwn.call(to, prop) && !hasOwn.call(from, prop)) {\n  				intermediate[prop] = to[prop];\n  			}\n  		}\n\n  		len = properties.length;\n\n  		return function (t) {\n  			var i = len,\n  			    prop;\n\n  			while (i--) {\n  				prop = properties[i];\n\n  				intermediate[prop] = interpolators[prop](t);\n  			}\n\n  			return intermediate;\n  		};\n  	}\n  };\n\n  var static_interpolators = interpolators;\n\n  // This function takes a keypath such as \'foo.bar.baz\', and returns\n  // all the variants of that keypath that include a wildcard in place\n  // of a key, such as \'foo.bar.*\', \'foo.*.baz\', \'foo.*.*\' and so on.\n  // These are then checked against the dependants map (ractive.viewmodel.depsMap)\n  // to see if any pattern observers are downstream of one or more of\n  // these wildcard keypaths (e.g. \'foo.bar.*.status\')\n  var utils_getPotentialWildcardMatches = getPotentialWildcardMatches;\n\n  var starMaps = {};\n  function getPotentialWildcardMatches(keypath) {\n  	var keys, starMap, mapper, i, result, wildcardKeypath;\n\n  	keys = keypath.split(".");\n  	if (!(starMap = starMaps[keys.length])) {\n  		starMap = getStarMap(keys.length);\n  	}\n\n  	result = [];\n\n  	mapper = function (star, i) {\n  		return star ? "*" : keys[i];\n  	};\n\n  	i = starMap.length;\n  	while (i--) {\n  		wildcardKeypath = starMap[i].map(mapper).join(".");\n\n  		if (!result.hasOwnProperty(wildcardKeypath)) {\n  			result.push(wildcardKeypath);\n  			result[wildcardKeypath] = true;\n  		}\n  	}\n\n  	return result;\n  }\n\n  // This function returns all the possible true/false combinations for\n  // a given number - e.g. for two, the possible combinations are\n  // [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n  // It does so by getting all the binary values between 0 and e.g. 11\n  function getStarMap(num) {\n  	var ones = "",\n  	    max,\n  	    binary,\n  	    starMap,\n  	    mapper,\n  	    i,\n  	    j,\n  	    l,\n  	    map;\n\n  	if (!starMaps[num]) {\n  		starMap = [];\n\n  		while (ones.length < num) {\n  			ones += 1;\n  		}\n\n  		max = parseInt(ones, 2);\n\n  		mapper = function (digit) {\n  			return digit === "1";\n  		};\n\n  		for (i = 0; i <= max; i += 1) {\n  			binary = i.toString(2);\n  			while (binary.length < num) {\n  				binary = "0" + binary;\n  			}\n\n  			map = [];\n  			l = binary.length;\n  			for (j = 0; j < l; j++) {\n  				map.push(mapper(binary[j]));\n  			}\n  			starMap[i] = map;\n  		}\n\n  		starMaps[num] = starMap;\n  	}\n\n  	return starMaps[num];\n  }\n\n  var refPattern = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\n  var patternPattern = /\\*/;\n  var keypathCache = {};\n\n  var Keypath = function (str) {\n  	var keys = str.split(".");\n\n  	this.str = str;\n\n  	if (str[0] === "@") {\n  		this.isSpecial = true;\n  		this.value = decodeKeypath(str);\n  	}\n\n  	this.firstKey = keys[0];\n  	this.lastKey = keys.pop();\n\n  	this.isPattern = patternPattern.test(str);\n\n  	this.parent = str === "" ? null : getKeypath(keys.join("."));\n  	this.isRoot = !str;\n  };\n\n  Keypath.prototype = {\n  	equalsOrStartsWith: function (keypath) {\n  		return keypath === this || this.startsWith(keypath);\n  	},\n\n  	join: function (str) {\n  		return getKeypath(this.isRoot ? String(str) : this.str + "." + str);\n  	},\n\n  	replace: function (oldKeypath, newKeypath) {\n  		if (this === oldKeypath) {\n  			return newKeypath;\n  		}\n\n  		if (this.startsWith(oldKeypath)) {\n  			return newKeypath === null ? newKeypath : getKeypath(this.str.replace(oldKeypath.str + ".", newKeypath.str + "."));\n  		}\n  	},\n\n  	startsWith: function (keypath) {\n  		if (!keypath) {\n  			// TODO under what circumstances does this happen?\n  			return false;\n  		}\n\n  		return keypath && this.str.substr(0, keypath.str.length + 1) === keypath.str + ".";\n  	},\n\n  	toString: function () {\n  		throw new Error("Bad coercion");\n  	},\n\n  	valueOf: function () {\n  		throw new Error("Bad coercion");\n  	},\n\n  	wildcardMatches: function () {\n  		return this._wildcardMatches || (this._wildcardMatches = utils_getPotentialWildcardMatches(this.str));\n  	}\n  };\n  function assignNewKeypath(target, property, oldKeypath, newKeypath) {\n  	var existingKeypath = target[property];\n\n  	if (existingKeypath && (existingKeypath.equalsOrStartsWith(newKeypath) || !existingKeypath.equalsOrStartsWith(oldKeypath))) {\n  		return;\n  	}\n\n  	target[property] = existingKeypath ? existingKeypath.replace(oldKeypath, newKeypath) : newKeypath;\n  	return true;\n  }\n\n  function decodeKeypath(keypath) {\n  	var value = keypath.slice(2);\n\n  	if (keypath[1] === "i") {\n  		return is__isNumeric(value) ? +value : value;\n  	} else {\n  		return value;\n  	}\n  }\n\n  function getKeypath(str) {\n  	if (str == null) {\n  		return str;\n  	}\n\n  	// TODO it *may* be worth having two versions of this function - one where\n  	// keypathCache inherits from null, and one for IE8. Depends on how\n  	// much of an overhead hasOwnProperty is - probably negligible\n  	if (!keypathCache.hasOwnProperty(str)) {\n  		keypathCache[str] = new Keypath(str);\n  	}\n\n  	return keypathCache[str];\n  }\n\n  function getMatchingKeypaths(ractive, keypath) {\n  	var keys, key, matchingKeypaths;\n\n  	keys = keypath.str.split(".");\n  	matchingKeypaths = [rootKeypath];\n\n  	while (key = keys.shift()) {\n  		if (key === "*") {\n  			// expand to find all valid child keypaths\n  			matchingKeypaths = matchingKeypaths.reduce(expand, []);\n  		} else {\n  			if (matchingKeypaths[0] === rootKeypath) {\n  				// first key\n  				matchingKeypaths[0] = getKeypath(key);\n  			} else {\n  				matchingKeypaths = matchingKeypaths.map(concatenate(key));\n  			}\n  		}\n  	}\n\n  	return matchingKeypaths;\n\n  	function expand(matchingKeypaths, keypath) {\n  		var wrapper, value, keys;\n\n  		if (keypath.isRoot) {\n  			keys = [].concat(Object.keys(ractive.viewmodel.data), Object.keys(ractive.viewmodel.mappings), Object.keys(ractive.viewmodel.computations));\n  		} else {\n  			wrapper = ractive.viewmodel.wrapped[keypath.str];\n  			value = wrapper ? wrapper.get() : ractive.viewmodel.get(keypath);\n\n  			keys = value ? Object.keys(value) : null;\n  		}\n\n  		if (keys) {\n  			keys.forEach(function (key) {\n  				if (key !== "_ractive" || !isArray(value)) {\n  					matchingKeypaths.push(keypath.join(key));\n  				}\n  			});\n  		}\n\n  		return matchingKeypaths;\n  	}\n  }\n\n  function concatenate(key) {\n  	return function (keypath) {\n  		return keypath.join(key);\n  	};\n  }\n  function normalise(ref) {\n  	return ref ? ref.replace(refPattern, ".$1") : "";\n  }\n\n  var rootKeypath = getKeypath("");\n\n  var shared_add = add;\n  var shared_add__errorMessage = "Cannot add to a non-numeric value";\n  function add(root, keypath, d) {\n  	if (typeof keypath !== "string" || !is__isNumeric(d)) {\n  		throw new Error("Bad arguments");\n  	}\n\n  	var value = undefined,\n  	    changes = undefined;\n\n  	if (/\\*/.test(keypath)) {\n  		changes = {};\n\n  		getMatchingKeypaths(root, getKeypath(normalise(keypath))).forEach(function (keypath) {\n  			var value = root.viewmodel.get(keypath);\n\n  			if (!is__isNumeric(value)) {\n  				throw new Error(shared_add__errorMessage);\n  			}\n\n  			changes[keypath.str] = value + d;\n  		});\n\n  		return root.set(changes);\n  	}\n\n  	value = root.get(keypath);\n\n  	if (!is__isNumeric(value)) {\n  		throw new Error(shared_add__errorMessage);\n  	}\n\n  	return root.set(keypath, +value + d);\n  }\n\n  var prototype_add = Ractive$add;\n  function Ractive$add(keypath, d) {\n  	return shared_add(this, keypath, d === undefined ? 1 : +d);\n  }\n\n  var requestAnimationFrame;\n\n  // If window doesn\'t exist, we don\'t need requestAnimationFrame\n  if (typeof window === "undefined") {\n  	requestAnimationFrame = null;\n  } else {\n  	// https://gist.github.com/paulirish/1579671\n  	(function (vendors, lastTime, window) {\n\n  		var x, setTimeout;\n\n  		if (window.requestAnimationFrame) {\n  			return;\n  		}\n\n  		for (x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n  			window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];\n  		}\n\n  		if (!window.requestAnimationFrame) {\n  			setTimeout = window.setTimeout;\n\n  			window.requestAnimationFrame = function (callback) {\n  				var currTime, timeToCall, id;\n\n  				currTime = Date.now();\n  				timeToCall = Math.max(0, 16 - (currTime - lastTime));\n  				id = setTimeout(function () {\n  					callback(currTime + timeToCall);\n  				}, timeToCall);\n\n  				lastTime = currTime + timeToCall;\n  				return id;\n  			};\n  		}\n  	})(vendors, 0, window);\n\n  	requestAnimationFrame = window.requestAnimationFrame;\n  }\n\n  var rAF = requestAnimationFrame;\n\n  var getTime;\n\n  if (typeof window !== "undefined" && window.performance && typeof window.performance.now === "function") {\n  	getTime = function () {\n  		return window.performance.now();\n  	};\n  } else {\n  	getTime = function () {\n  		return Date.now();\n  	};\n  }\n\n  var utils_getTime = getTime;\n\n  var deprecations = {\n  	construct: {\n  		deprecated: "beforeInit",\n  		replacement: "onconstruct"\n  	},\n  	render: {\n  		deprecated: "init",\n  		message: "The \\"init\\" method has been deprecated " + "and will likely be removed in a future release. " + "You can either use the \\"oninit\\" method which will fire " + "only once prior to, and regardless of, any eventual ractive " + "instance being rendered, or if you need to access the " + "rendered DOM, use \\"onrender\\" instead. " + "See http://docs.ractivejs.org/latest/migrating for more information."\n  	},\n  	complete: {\n  		deprecated: "complete",\n  		replacement: "oncomplete"\n  	}\n  };\n\n  function Hook(event) {\n  	this.event = event;\n  	this.method = "on" + event;\n  	this.deprecate = deprecations[event];\n  }\n\n  Hook.prototype.fire = function (ractive, arg) {\n  	function call(method) {\n  		if (ractive[method]) {\n  			arg ? ractive[method](arg) : ractive[method]();\n  			return true;\n  		}\n  	}\n\n  	call(this.method);\n\n  	if (!ractive[this.method] && this.deprecate && call(this.deprecate.deprecated)) {\n  		if (this.deprecate.message) {\n  			warnIfDebug(this.deprecate.message);\n  		} else {\n  			warnIfDebug("The method \\"%s\\" has been deprecated in favor of \\"%s\\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.", this.deprecate.deprecated, this.deprecate.replacement);\n  		}\n  	}\n\n  	arg ? ractive.fire(this.event, arg) : ractive.fire(this.event);\n  };\n\n  var hooks_Hook = Hook;\n\n  function addToArray(array, value) {\n  	var index = array.indexOf(value);\n\n  	if (index === -1) {\n  		array.push(value);\n  	}\n  }\n\n  function arrayContains(array, value) {\n  	for (var i = 0, c = array.length; i < c; i++) {\n  		if (array[i] == value) {\n  			return true;\n  		}\n  	}\n\n  	return false;\n  }\n\n  function arrayContentsMatch(a, b) {\n  	var i;\n\n  	if (!isArray(a) || !isArray(b)) {\n  		return false;\n  	}\n\n  	if (a.length !== b.length) {\n  		return false;\n  	}\n\n  	i = a.length;\n  	while (i--) {\n  		if (a[i] !== b[i]) {\n  			return false;\n  		}\n  	}\n\n  	return true;\n  }\n\n  function ensureArray(x) {\n  	if (typeof x === "string") {\n  		return [x];\n  	}\n\n  	if (x === undefined) {\n  		return [];\n  	}\n\n  	return x;\n  }\n\n  function lastItem(array) {\n  	return array[array.length - 1];\n  }\n\n  function removeFromArray(array, member) {\n  	var index = array.indexOf(member);\n\n  	if (index !== -1) {\n  		array.splice(index, 1);\n  	}\n  }\n\n  function toArray(arrayLike) {\n  	var array = [],\n  	    i = arrayLike.length;\n  	while (i--) {\n  		array[i] = arrayLike[i];\n  	}\n\n  	return array;\n  }\n\n  var _Promise,\n      PENDING = {},\n      FULFILLED = {},\n      REJECTED = {};\n\n  if (typeof Promise === "function") {\n  	// use native Promise\n  	_Promise = Promise;\n  } else {\n  	_Promise = function (callback) {\n  		var fulfilledHandlers = [],\n  		    rejectedHandlers = [],\n  		    state = PENDING,\n  		    result,\n  		    dispatchHandlers,\n  		    makeResolver,\n  		    fulfil,\n  		    reject,\n  		    promise;\n\n  		makeResolver = function (newState) {\n  			return function (value) {\n  				if (state !== PENDING) {\n  					return;\n  				}\n\n  				result = value;\n  				state = newState;\n\n  				dispatchHandlers = makeDispatcher(state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result);\n\n  				// dispatch onFulfilled and onRejected handlers asynchronously\n  				wait(dispatchHandlers);\n  			};\n  		};\n\n  		fulfil = makeResolver(FULFILLED);\n  		reject = makeResolver(REJECTED);\n\n  		try {\n  			callback(fulfil, reject);\n  		} catch (err) {\n  			reject(err);\n  		}\n\n  		promise = {\n  			// `then()` returns a Promise - 2.2.7\n  			then: function (onFulfilled, onRejected) {\n  				var promise2 = new _Promise(function (fulfil, reject) {\n\n  					var processResolutionHandler = function (handler, handlers, forward) {\n\n  						// 2.2.1.1\n  						if (typeof handler === "function") {\n  							handlers.push(function (p1result) {\n  								var x;\n\n  								try {\n  									x = handler(p1result);\n  									utils_Promise__resolve(promise2, x, fulfil, reject);\n  								} catch (err) {\n  									reject(err);\n  								}\n  							});\n  						} else {\n  							// Forward the result of promise1 to promise2, if resolution handlers\n  							// are not given\n  							handlers.push(forward);\n  						}\n  					};\n\n  					// 2.2\n  					processResolutionHandler(onFulfilled, fulfilledHandlers, fulfil);\n  					processResolutionHandler(onRejected, rejectedHandlers, reject);\n\n  					if (state !== PENDING) {\n  						// If the promise has resolved already, dispatch the appropriate handlers asynchronously\n  						wait(dispatchHandlers);\n  					}\n  				});\n\n  				return promise2;\n  			}\n  		};\n\n  		promise["catch"] = function (onRejected) {\n  			return this.then(null, onRejected);\n  		};\n\n  		return promise;\n  	};\n\n  	_Promise.all = function (promises) {\n  		return new _Promise(function (fulfil, reject) {\n  			var result = [],\n  			    pending,\n  			    i,\n  			    processPromise;\n\n  			if (!promises.length) {\n  				fulfil(result);\n  				return;\n  			}\n\n  			processPromise = function (promise, i) {\n  				if (promise && typeof promise.then === "function") {\n  					promise.then(function (value) {\n  						result[i] = value;\n  						--pending || fulfil(result);\n  					}, reject);\n  				} else {\n  					result[i] = promise;\n  					--pending || fulfil(result);\n  				}\n  			};\n\n  			pending = i = promises.length;\n  			while (i--) {\n  				processPromise(promises[i], i);\n  			}\n  		});\n  	};\n\n  	_Promise.resolve = function (value) {\n  		return new _Promise(function (fulfil) {\n  			fulfil(value);\n  		});\n  	};\n\n  	_Promise.reject = function (reason) {\n  		return new _Promise(function (fulfil, reject) {\n  			reject(reason);\n  		});\n  	};\n  }\n\n  var utils_Promise = _Promise;\n\n  // TODO use MutationObservers or something to simulate setImmediate\n  function wait(callback) {\n  	setTimeout(callback, 0);\n  }\n\n  function makeDispatcher(handlers, result) {\n  	return function () {\n  		var handler;\n\n  		while (handler = handlers.shift()) {\n  			handler(result);\n  		}\n  	};\n  }\n\n  function utils_Promise__resolve(promise, x, fulfil, reject) {\n  	// Promise Resolution Procedure\n  	var then;\n\n  	// 2.3.1\n  	if (x === promise) {\n  		throw new TypeError("A promise\'s fulfillment handler cannot return the same promise");\n  	}\n\n  	// 2.3.2\n  	if (x instanceof _Promise) {\n  		x.then(fulfil, reject);\n  	}\n\n  	// 2.3.3\n  	else if (x && (typeof x === "object" || typeof x === "function")) {\n  		try {\n  			then = x.then; // 2.3.3.1\n  		} catch (e) {\n  			reject(e); // 2.3.3.2\n  			return;\n  		}\n\n  		// 2.3.3.3\n  		if (typeof then === "function") {\n  			var called, resolvePromise, rejectPromise;\n\n  			resolvePromise = function (y) {\n  				if (called) {\n  					return;\n  				}\n  				called = true;\n  				utils_Promise__resolve(promise, y, fulfil, reject);\n  			};\n\n  			rejectPromise = function (r) {\n  				if (called) {\n  					return;\n  				}\n  				called = true;\n  				reject(r);\n  			};\n\n  			try {\n  				then.call(x, resolvePromise, rejectPromise);\n  			} catch (e) {\n  				if (!called) {\n  					// 2.3.3.3.4.1\n  					reject(e); // 2.3.3.3.4.2\n  					called = true;\n  					return;\n  				}\n  			}\n  		} else {\n  			fulfil(x);\n  		}\n  	} else {\n  		fulfil(x);\n  	}\n  }\n\n  var getInnerContext = function (fragment) {\n  	do {\n  		if (fragment.context !== undefined) {\n  			return fragment.context;\n  		}\n  	} while (fragment = fragment.parent);\n\n  	return rootKeypath;\n  };\n\n  var shared_resolveRef = resolveRef;\n\n  function resolveRef(ractive, ref, fragment) {\n  	var keypath;\n\n  	ref = normalise(ref);\n\n  	// If a reference begins \'~/\', it\'s a top-level reference\n  	if (ref.substr(0, 2) === "~/") {\n  		keypath = getKeypath(ref.substring(2));\n  		createMappingIfNecessary(ractive, keypath.firstKey, fragment);\n  	}\n\n  	// If a reference begins with \'.\', it\'s either a restricted reference or\n  	// an ancestor reference...\n  	else if (ref[0] === ".") {\n  		keypath = resolveAncestorRef(getInnerContext(fragment), ref);\n\n  		if (keypath) {\n  			createMappingIfNecessary(ractive, keypath.firstKey, fragment);\n  		}\n  	}\n\n  	// ...otherwise we need to figure out the keypath based on context\n  	else {\n  		keypath = resolveAmbiguousReference(ractive, getKeypath(ref), fragment);\n  	}\n\n  	return keypath;\n  }\n\n  function resolveAncestorRef(baseContext, ref) {\n  	var contextKeys;\n\n  	// TODO...\n  	if (baseContext != undefined && typeof baseContext !== "string") {\n  		baseContext = baseContext.str;\n  	}\n\n  	// {{.}} means \'current context\'\n  	if (ref === ".") return getKeypath(baseContext);\n\n  	contextKeys = baseContext ? baseContext.split(".") : [];\n\n  	// ancestor references (starting "../") go up the tree\n  	if (ref.substr(0, 3) === "../") {\n  		while (ref.substr(0, 3) === "../") {\n  			if (!contextKeys.length) {\n  				throw new Error("Could not resolve reference - too many \\"../\\" prefixes");\n  			}\n\n  			contextKeys.pop();\n  			ref = ref.substring(3);\n  		}\n\n  		contextKeys.push(ref);\n  		return getKeypath(contextKeys.join("."));\n  	}\n\n  	// not an ancestor reference - must be a restricted reference (prepended with "." or "./")\n  	if (!baseContext) {\n  		return getKeypath(ref.replace(/^\\.\\/?/, ""));\n  	}\n\n  	return getKeypath(baseContext + ref.replace(/^\\.\\//, "."));\n  }\n\n  function resolveAmbiguousReference(ractive, ref, fragment, isParentLookup) {\n  	var context, key, parentValue, hasContextChain, parentKeypath;\n\n  	if (ref.isRoot) {\n  		return ref;\n  	}\n\n  	key = ref.firstKey;\n\n  	while (fragment) {\n  		context = fragment.context;\n  		fragment = fragment.parent;\n\n  		if (!context) {\n  			continue;\n  		}\n\n  		hasContextChain = true;\n  		parentValue = ractive.viewmodel.get(context);\n\n  		if (parentValue && (typeof parentValue === "object" || typeof parentValue === "function") && key in parentValue) {\n  			return context.join(ref.str);\n  		}\n  	}\n\n  	// Root/computed/mapped property?\n  	if (isRootProperty(ractive.viewmodel, key)) {\n  		return ref;\n  	}\n\n  	// If this is an inline component, and it\'s not isolated, we\n  	// can try going up the scope chain\n  	if (ractive.parent && !ractive.isolated) {\n  		hasContextChain = true;\n  		fragment = ractive.component.parentFragment;\n\n  		key = getKeypath(key);\n\n  		if (parentKeypath = resolveAmbiguousReference(ractive.parent, key, fragment, true)) {\n  			// We need to create an inter-component binding\n  			ractive.viewmodel.map(key, {\n  				origin: ractive.parent.viewmodel,\n  				keypath: parentKeypath\n  			});\n\n  			return ref;\n  		}\n  	}\n\n  	// If there\'s no context chain, and the instance is either a) isolated or\n  	// b) an orphan, then we know that the keypath is identical to the reference\n  	if (!isParentLookup && !hasContextChain) {\n  		// the data object needs to have a property by this name,\n  		// to prevent future failed lookups\n  		ractive.viewmodel.set(ref, undefined);\n  		return ref;\n  	}\n  }\n\n  function createMappingIfNecessary(ractive, key) {\n  	var parentKeypath;\n\n  	if (!ractive.parent || ractive.isolated || isRootProperty(ractive.viewmodel, key)) {\n  		return;\n  	}\n\n  	key = getKeypath(key);\n\n  	if (parentKeypath = resolveAmbiguousReference(ractive.parent, key, ractive.component.parentFragment, true)) {\n  		ractive.viewmodel.map(key, {\n  			origin: ractive.parent.viewmodel,\n  			keypath: parentKeypath\n  		});\n  	}\n  }\n\n  function isRootProperty(viewmodel, key) {\n  	// special case for reference to root\n  	return key === "" || key in viewmodel.data || key in viewmodel.computations || key in viewmodel.mappings;\n  }\n\n  function teardown(x) {\n    x.teardown();\n  }\n\n  function methodCallers__unbind(x) {\n    x.unbind();\n  }\n\n  function methodCallers__unrender(x) {\n    x.unrender();\n  }\n\n  function cancel(x) {\n    x.cancel();\n  }\n\n  var TransitionManager = function (callback, parent) {\n  	this.callback = callback;\n  	this.parent = parent;\n\n  	this.intros = [];\n  	this.outros = [];\n\n  	this.children = [];\n  	this.totalChildren = this.outroChildren = 0;\n\n  	this.detachQueue = [];\n  	this.decoratorQueue = [];\n  	this.outrosComplete = false;\n\n  	if (parent) {\n  		parent.addChild(this);\n  	}\n  };\n\n  TransitionManager.prototype = {\n  	addChild: function (child) {\n  		this.children.push(child);\n\n  		this.totalChildren += 1;\n  		this.outroChildren += 1;\n  	},\n\n  	decrementOutros: function () {\n  		this.outroChildren -= 1;\n  		check(this);\n  	},\n\n  	decrementTotal: function () {\n  		this.totalChildren -= 1;\n  		check(this);\n  	},\n\n  	add: function (transition) {\n  		var list = transition.isIntro ? this.intros : this.outros;\n  		list.push(transition);\n  	},\n\n  	addDecorator: function (decorator) {\n  		this.decoratorQueue.push(decorator);\n  	},\n\n  	remove: function (transition) {\n  		var list = transition.isIntro ? this.intros : this.outros;\n  		removeFromArray(list, transition);\n  		check(this);\n  	},\n\n  	init: function () {\n  		this.ready = true;\n  		check(this);\n  	},\n\n  	detachNodes: function () {\n  		this.decoratorQueue.forEach(teardown);\n  		this.detachQueue.forEach(detach);\n  		this.children.forEach(detachNodes);\n  	}\n  };\n\n  function detach(element) {\n  	element.detach();\n  }\n\n  function detachNodes(tm) {\n  	tm.detachNodes();\n  }\n\n  function check(tm) {\n  	if (!tm.ready || tm.outros.length || tm.outroChildren) return;\n\n  	// If all outros are complete, and we haven\'t already done this,\n  	// we notify the parent if there is one, otherwise\n  	// start detaching nodes\n  	if (!tm.outrosComplete) {\n  		if (tm.parent) {\n  			tm.parent.decrementOutros(tm);\n  		} else {\n  			tm.detachNodes();\n  		}\n\n  		tm.outrosComplete = true;\n  	}\n\n  	// Once everything is done, we can notify parent transition\n  	// manager and call the callback\n  	if (!tm.intros.length && !tm.totalChildren) {\n  		if (typeof tm.callback === "function") {\n  			tm.callback();\n  		}\n\n  		if (tm.parent) {\n  			tm.parent.decrementTotal();\n  		}\n  	}\n  }\n\n  var global_TransitionManager = TransitionManager;\n\n  var batch,\n      runloop,\n      unresolved = [],\n      changeHook = new hooks_Hook("change");\n\n  runloop = {\n  	start: function (instance, returnPromise) {\n  		var promise, fulfilPromise;\n\n  		if (returnPromise) {\n  			promise = new utils_Promise(function (f) {\n  				return fulfilPromise = f;\n  			});\n  		}\n\n  		batch = {\n  			previousBatch: batch,\n  			transitionManager: new global_TransitionManager(fulfilPromise, batch && batch.transitionManager),\n  			views: [],\n  			tasks: [],\n  			ractives: [],\n  			instance: instance\n  		};\n\n  		if (instance) {\n  			batch.ractives.push(instance);\n  		}\n\n  		return promise;\n  	},\n\n  	end: function () {\n  		flushChanges();\n\n  		batch.transitionManager.init();\n  		if (!batch.previousBatch && !!batch.instance) batch.instance.viewmodel.changes = [];\n  		batch = batch.previousBatch;\n  	},\n\n  	addRactive: function (ractive) {\n  		if (batch) {\n  			addToArray(batch.ractives, ractive);\n  		}\n  	},\n\n  	registerTransition: function (transition) {\n  		transition._manager = batch.transitionManager;\n  		batch.transitionManager.add(transition);\n  	},\n\n  	registerDecorator: function (decorator) {\n  		batch.transitionManager.addDecorator(decorator);\n  	},\n\n  	addView: function (view) {\n  		batch.views.push(view);\n  	},\n\n  	addUnresolved: function (thing) {\n  		unresolved.push(thing);\n  	},\n\n  	removeUnresolved: function (thing) {\n  		removeFromArray(unresolved, thing);\n  	},\n\n  	// synchronise node detachments with transition ends\n  	detachWhenReady: function (thing) {\n  		batch.transitionManager.detachQueue.push(thing);\n  	},\n\n  	scheduleTask: function (task, postRender) {\n  		var _batch;\n\n  		if (!batch) {\n  			task();\n  		} else {\n  			_batch = batch;\n  			while (postRender && _batch.previousBatch) {\n  				// this can\'t happen until the DOM has been fully updated\n  				// otherwise in some situations (with components inside elements)\n  				// transitions and decorators will initialise prematurely\n  				_batch = _batch.previousBatch;\n  			}\n\n  			_batch.tasks.push(task);\n  		}\n  	}\n  };\n\n  var global_runloop = runloop;\n\n  function flushChanges() {\n  	var i, thing, changeHash;\n\n  	while (batch.ractives.length) {\n  		thing = batch.ractives.pop();\n  		changeHash = thing.viewmodel.applyChanges();\n\n  		if (changeHash) {\n  			changeHook.fire(thing, changeHash);\n  		}\n  	}\n\n  	attemptKeypathResolution();\n\n  	// Now that changes have been fully propagated, we can update the DOM\n  	// and complete other tasks\n  	for (i = 0; i < batch.views.length; i += 1) {\n  		batch.views[i].update();\n  	}\n  	batch.views.length = 0;\n\n  	for (i = 0; i < batch.tasks.length; i += 1) {\n  		batch.tasks[i]();\n  	}\n  	batch.tasks.length = 0;\n\n  	// If updating the view caused some model blowback - e.g. a triple\n  	// containing <option> elements caused the binding on the <select>\n  	// to update - then we start over\n  	if (batch.ractives.length) return flushChanges();\n  }\n\n  function attemptKeypathResolution() {\n  	var i, item, keypath, resolved;\n\n  	i = unresolved.length;\n\n  	// see if we can resolve any unresolved references\n  	while (i--) {\n  		item = unresolved[i];\n\n  		if (item.keypath) {\n  			// it resolved some other way. TODO how? two-way binding? Seems\n  			// weird that we\'d still end up here\n  			unresolved.splice(i, 1);\n  			continue; // avoid removing the wrong thing should the next condition be true\n  		}\n\n  		if (keypath = shared_resolveRef(item.root, item.ref, item.parentFragment)) {\n  			(resolved || (resolved = [])).push({\n  				item: item,\n  				keypath: keypath\n  			});\n\n  			unresolved.splice(i, 1);\n  		}\n  	}\n\n  	if (resolved) {\n  		resolved.forEach(global_runloop__resolve);\n  	}\n  }\n\n  function global_runloop__resolve(resolved) {\n  	resolved.item.resolve(resolved.keypath);\n  }\n\n  var queue = [];\n\n  var animations = {\n  	tick: function () {\n  		var i, animation, now;\n\n  		now = utils_getTime();\n\n  		global_runloop.start();\n\n  		for (i = 0; i < queue.length; i += 1) {\n  			animation = queue[i];\n\n  			if (!animation.tick(now)) {\n  				// animation is complete, remove it from the stack, and decrement i so we don\'t miss one\n  				queue.splice(i--, 1);\n  			}\n  		}\n\n  		global_runloop.end();\n\n  		if (queue.length) {\n  			rAF(animations.tick);\n  		} else {\n  			animations.running = false;\n  		}\n  	},\n\n  	add: function (animation) {\n  		queue.push(animation);\n\n  		if (!animations.running) {\n  			animations.running = true;\n  			rAF(animations.tick);\n  		}\n  	},\n\n  	// TODO optimise this\n  	abort: function (keypath, root) {\n  		var i = queue.length,\n  		    animation;\n\n  		while (i--) {\n  			animation = queue[i];\n\n  			if (animation.root === root && animation.keypath === keypath) {\n  				animation.stop();\n  			}\n  		}\n  	}\n  };\n\n  var shared_animations = animations;\n\n  var Animation = function (options) {\n  	var key;\n\n  	this.startTime = Date.now();\n\n  	// from and to\n  	for (key in options) {\n  		if (options.hasOwnProperty(key)) {\n  			this[key] = options[key];\n  		}\n  	}\n\n  	this.interpolator = shared_interpolate(this.from, this.to, this.root, this.interpolator);\n  	this.running = true;\n\n  	this.tick();\n  };\n\n  Animation.prototype = {\n  	tick: function () {\n  		var elapsed, t, value, timeNow, index, keypath;\n\n  		keypath = this.keypath;\n\n  		if (this.running) {\n  			timeNow = Date.now();\n  			elapsed = timeNow - this.startTime;\n\n  			if (elapsed >= this.duration) {\n  				if (keypath !== null) {\n  					global_runloop.start(this.root);\n  					this.root.viewmodel.set(keypath, this.to);\n  					global_runloop.end();\n  				}\n\n  				if (this.step) {\n  					this.step(1, this.to);\n  				}\n\n  				this.complete(this.to);\n\n  				index = this.root._animations.indexOf(this);\n\n  				// TODO investigate why this happens\n  				if (index === -1) {\n  					warnIfDebug("Animation was not found");\n  				}\n\n  				this.root._animations.splice(index, 1);\n\n  				this.running = false;\n  				return false; // remove from the stack\n  			}\n\n  			t = this.easing ? this.easing(elapsed / this.duration) : elapsed / this.duration;\n\n  			if (keypath !== null) {\n  				value = this.interpolator(t);\n  				global_runloop.start(this.root);\n  				this.root.viewmodel.set(keypath, value);\n  				global_runloop.end();\n  			}\n\n  			if (this.step) {\n  				this.step(t, value);\n  			}\n\n  			return true; // keep in the stack\n  		}\n\n  		return false; // remove from the stack\n  	},\n\n  	stop: function () {\n  		var index;\n\n  		this.running = false;\n\n  		index = this.root._animations.indexOf(this);\n\n  		// TODO investigate why this happens\n  		if (index === -1) {\n  			warnIfDebug("Animation was not found");\n  		}\n\n  		this.root._animations.splice(index, 1);\n  	}\n  };\n\n  var animate_Animation = Animation;\n\n  var prototype_animate = Ractive$animate;\n\n  var noAnimation = { stop: noop };\n  function Ractive$animate(keypath, to, options) {\n  	var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;\n\n  	promise = new utils_Promise(function (fulfil) {\n  		return fulfilPromise = fulfil;\n  	});\n\n  	// animate multiple keypaths\n  	if (typeof keypath === "object") {\n  		options = to || {};\n  		easing = options.easing;\n  		duration = options.duration;\n\n  		animations = [];\n\n  		// we don\'t want to pass the `step` and `complete` handlers, as they will\n  		// run for each animation! So instead we\'ll store the handlers and create\n  		// our own...\n  		step = options.step;\n  		complete = options.complete;\n\n  		if (step || complete) {\n  			currentValues = {};\n\n  			options.step = null;\n  			options.complete = null;\n\n  			makeValueCollector = function (keypath) {\n  				return function (t, value) {\n  					currentValues[keypath] = value;\n  				};\n  			};\n  		}\n\n  		for (k in keypath) {\n  			if (keypath.hasOwnProperty(k)) {\n  				if (step || complete) {\n  					collectValue = makeValueCollector(k);\n  					options = { easing: easing, duration: duration };\n\n  					if (step) {\n  						options.step = collectValue;\n  					}\n  				}\n\n  				options.complete = complete ? collectValue : noop;\n  				animations.push(animate(this, k, keypath[k], options));\n  			}\n  		}\n\n  		// Create a dummy animation, to facilitate step/complete\n  		// callbacks, and Promise fulfilment\n  		dummyOptions = { easing: easing, duration: duration };\n\n  		if (step) {\n  			dummyOptions.step = function (t) {\n  				return step(t, currentValues);\n  			};\n  		}\n\n  		if (complete) {\n  			promise.then(function (t) {\n  				return complete(t, currentValues);\n  			});\n  		}\n\n  		dummyOptions.complete = fulfilPromise;\n\n  		dummy = animate(this, null, null, dummyOptions);\n  		animations.push(dummy);\n\n  		promise.stop = function () {\n  			var animation;\n\n  			while (animation = animations.pop()) {\n  				animation.stop();\n  			}\n\n  			if (dummy) {\n  				dummy.stop();\n  			}\n  		};\n\n  		return promise;\n  	}\n\n  	// animate a single keypath\n  	options = options || {};\n\n  	if (options.complete) {\n  		promise.then(options.complete);\n  	}\n\n  	options.complete = fulfilPromise;\n  	animation = animate(this, keypath, to, options);\n\n  	promise.stop = function () {\n  		return animation.stop();\n  	};\n  	return promise;\n  }\n\n  function animate(root, keypath, to, options) {\n  	var easing, duration, animation, from;\n\n  	if (keypath) {\n  		keypath = getKeypath(normalise(keypath));\n  	}\n\n  	if (keypath !== null) {\n  		from = root.viewmodel.get(keypath);\n  	}\n\n  	// cancel any existing animation\n  	// TODO what about upstream/downstream keypaths?\n  	shared_animations.abort(keypath, root);\n\n  	// don\'t bother animating values that stay the same\n  	if (isEqual(from, to)) {\n  		if (options.complete) {\n  			options.complete(options.to);\n  		}\n\n  		return noAnimation;\n  	}\n\n  	// easing function\n  	if (options.easing) {\n  		if (typeof options.easing === "function") {\n  			easing = options.easing;\n  		} else {\n  			easing = root.easing[options.easing];\n  		}\n\n  		if (typeof easing !== "function") {\n  			easing = null;\n  		}\n  	}\n\n  	// duration\n  	duration = options.duration === undefined ? 400 : options.duration;\n\n  	// TODO store keys, use an internal set method\n  	animation = new animate_Animation({\n  		keypath: keypath,\n  		from: from,\n  		to: to,\n  		root: root,\n  		duration: duration,\n  		easing: easing,\n  		interpolator: options.interpolator,\n\n  		// TODO wrap callbacks if necessary, to use instance as context\n  		step: options.step,\n  		complete: options.complete\n  	});\n\n  	shared_animations.add(animation);\n  	root._animations.push(animation);\n\n  	return animation;\n  }\n\n  var prototype_detach = Ractive$detach;\n  var prototype_detach__detachHook = new hooks_Hook("detach");\n  function Ractive$detach() {\n  	if (this.detached) {\n  		return this.detached;\n  	}\n\n  	if (this.el) {\n  		removeFromArray(this.el.__ractive_instances__, this);\n  	}\n  	this.detached = this.fragment.detach();\n  	prototype_detach__detachHook.fire(this);\n  	return this.detached;\n  }\n\n  var prototype_find = Ractive$find;\n\n  function Ractive$find(selector) {\n  	if (!this.el) {\n  		return null;\n  	}\n\n  	return this.fragment.find(selector);\n  }\n\n  var test = Query$test;\n  function Query$test(item, noDirty) {\n  	var itemMatches;\n\n  	if (this._isComponentQuery) {\n  		itemMatches = !this.selector || item.name === this.selector;\n  	} else {\n  		itemMatches = item.node ? matches(item.node, this.selector) : null;\n  	}\n\n  	if (itemMatches) {\n  		this.push(item.node || item.instance);\n\n  		if (!noDirty) {\n  			this._makeDirty();\n  		}\n\n  		return true;\n  	}\n  }\n\n  var makeQuery_cancel = function () {\n  	var liveQueries, selector, index;\n\n  	liveQueries = this._root[this._isComponentQuery ? "liveComponentQueries" : "liveQueries"];\n  	selector = this.selector;\n\n  	index = liveQueries.indexOf(selector);\n\n  	if (index !== -1) {\n  		liveQueries.splice(index, 1);\n  		liveQueries[selector] = null;\n  	}\n  };\n\n  var sortByItemPosition = function (a, b) {\n  	var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;\n\n  	ancestryA = getAncestry(a.component || a._ractive.proxy);\n  	ancestryB = getAncestry(b.component || b._ractive.proxy);\n\n  	oldestA = lastItem(ancestryA);\n  	oldestB = lastItem(ancestryB);\n\n  	// remove items from the end of both ancestries as long as they are identical\n  	// - the final one removed is the closest mutual ancestor\n  	while (oldestA && oldestA === oldestB) {\n  		ancestryA.pop();\n  		ancestryB.pop();\n\n  		mutualAncestor = oldestA;\n\n  		oldestA = lastItem(ancestryA);\n  		oldestB = lastItem(ancestryB);\n  	}\n\n  	// now that we have the mutual ancestor, we can find which is earliest\n  	oldestA = oldestA.component || oldestA;\n  	oldestB = oldestB.component || oldestB;\n\n  	fragmentA = oldestA.parentFragment;\n  	fragmentB = oldestB.parentFragment;\n\n  	// if both items share a parent fragment, our job is easy\n  	if (fragmentA === fragmentB) {\n  		indexA = fragmentA.items.indexOf(oldestA);\n  		indexB = fragmentB.items.indexOf(oldestB);\n\n  		// if it\'s the same index, it means one contains the other,\n  		// so we see which has the longest ancestry\n  		return indexA - indexB || ancestryA.length - ancestryB.length;\n  	}\n\n  	// if mutual ancestor is a section, we first test to see which section\n  	// fragment comes first\n  	if (fragments = mutualAncestor.fragments) {\n  		indexA = fragments.indexOf(fragmentA);\n  		indexB = fragments.indexOf(fragmentB);\n\n  		return indexA - indexB || ancestryA.length - ancestryB.length;\n  	}\n\n  	throw new Error("An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!");\n  };\n\n  function getParent(item) {\n  	var parentFragment;\n\n  	if (parentFragment = item.parentFragment) {\n  		return parentFragment.owner;\n  	}\n\n  	if (item.component && (parentFragment = item.component.parentFragment)) {\n  		return parentFragment.owner;\n  	}\n  }\n\n  function getAncestry(item) {\n  	var ancestry, ancestor;\n\n  	ancestry = [item];\n\n  	ancestor = getParent(item);\n\n  	while (ancestor) {\n  		ancestry.push(ancestor);\n  		ancestor = getParent(ancestor);\n  	}\n\n  	return ancestry;\n  }\n\n  var sortByDocumentPosition = function (node, otherNode) {\n  	var bitmask;\n\n  	if (node.compareDocumentPosition) {\n  		bitmask = node.compareDocumentPosition(otherNode);\n  		return bitmask & 2 ? 1 : -1;\n  	}\n\n  	// In old IE, we can piggy back on the mechanism for\n  	// comparing component positions\n  	return sortByItemPosition(node, otherNode);\n  };\n\n  var sort = function () {\n  	this.sort(this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition);\n  	this._dirty = false;\n  };\n\n  var makeQuery_dirty = function () {\n  	var _this = this;\n\n  	if (!this._dirty) {\n  		this._dirty = true;\n\n  		// Once the DOM has been updated, ensure the query\n  		// is correctly ordered\n  		global_runloop.scheduleTask(function () {\n  			_this._sort();\n  		});\n  	}\n  };\n\n  var remove = function (nodeOrComponent) {\n  	var index = this.indexOf(this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent);\n\n  	if (index !== -1) {\n  		this.splice(index, 1);\n  	}\n  };\n\n  var _makeQuery = makeQuery;\n  function makeQuery(ractive, selector, live, isComponentQuery) {\n  	var query = [];\n\n  	defineProperties(query, {\n  		selector: { value: selector },\n  		live: { value: live },\n\n  		_isComponentQuery: { value: isComponentQuery },\n  		_test: { value: test }\n  	});\n\n  	if (!live) {\n  		return query;\n  	}\n\n  	defineProperties(query, {\n  		cancel: { value: makeQuery_cancel },\n\n  		_root: { value: ractive },\n  		_sort: { value: sort },\n  		_makeDirty: { value: makeQuery_dirty },\n  		_remove: { value: remove },\n\n  		_dirty: { value: false, writable: true }\n  	});\n\n  	return query;\n  }\n\n  var prototype_findAll = Ractive$findAll;\n  function Ractive$findAll(selector, options) {\n  	var liveQueries, query;\n\n  	if (!this.el) {\n  		return [];\n  	}\n\n  	options = options || {};\n  	liveQueries = this._liveQueries;\n\n  	// Shortcut: if we\'re maintaining a live query with this\n  	// selector, we don\'t need to traverse the parallel DOM\n  	if (query = liveQueries[selector]) {\n\n  		// Either return the exact same query, or (if not live) a snapshot\n  		return options && options.live ? query : query.slice();\n  	}\n\n  	query = _makeQuery(this, selector, !!options.live, false);\n\n  	// Add this to the list of live queries Ractive needs to maintain,\n  	// if applicable\n  	if (query.live) {\n  		liveQueries.push(selector);\n  		liveQueries["_" + selector] = query;\n  	}\n\n  	this.fragment.findAll(selector, query);\n  	return query;\n  }\n\n  var prototype_findAllComponents = Ractive$findAllComponents;\n  function Ractive$findAllComponents(selector, options) {\n  	var liveQueries, query;\n\n  	options = options || {};\n  	liveQueries = this._liveComponentQueries;\n\n  	// Shortcut: if we\'re maintaining a live query with this\n  	// selector, we don\'t need to traverse the parallel DOM\n  	if (query = liveQueries[selector]) {\n\n  		// Either return the exact same query, or (if not live) a snapshot\n  		return options && options.live ? query : query.slice();\n  	}\n\n  	query = _makeQuery(this, selector, !!options.live, true);\n\n  	// Add this to the list of live queries Ractive needs to maintain,\n  	// if applicable\n  	if (query.live) {\n  		liveQueries.push(selector);\n  		liveQueries["_" + selector] = query;\n  	}\n\n  	this.fragment.findAllComponents(selector, query);\n  	return query;\n  }\n\n  var prototype_findComponent = Ractive$findComponent;\n\n  function Ractive$findComponent(selector) {\n  	return this.fragment.findComponent(selector);\n  }\n\n  var findContainer = Ractive$findContainer;\n\n  function Ractive$findContainer(selector) {\n  	if (this.container) {\n  		if (this.container.component && this.container.component.name === selector) {\n  			return this.container;\n  		} else {\n  			return this.container.findContainer(selector);\n  		}\n  	}\n\n  	return null;\n  }\n\n  var findParent = Ractive$findParent;\n\n  function Ractive$findParent(selector) {\n\n  	if (this.parent) {\n  		if (this.parent.component && this.parent.component.name === selector) {\n  			return this.parent;\n  		} else {\n  			return this.parent.findParent(selector);\n  		}\n  	}\n\n  	return null;\n  }\n\n  var eventStack = {\n  	enqueue: function (ractive, event) {\n  		if (ractive.event) {\n  			ractive._eventQueue = ractive._eventQueue || [];\n  			ractive._eventQueue.push(ractive.event);\n  		}\n  		ractive.event = event;\n  	},\n  	dequeue: function (ractive) {\n  		if (ractive._eventQueue && ractive._eventQueue.length) {\n  			ractive.event = ractive._eventQueue.pop();\n  		} else {\n  			delete ractive.event;\n  		}\n  	}\n  };\n\n  var shared_eventStack = eventStack;\n\n  var shared_fireEvent = fireEvent;\n\n  function fireEvent(ractive, eventName) {\n  	var options = arguments[2] === undefined ? {} : arguments[2];\n\n  	if (!eventName) {\n  		return;\n  	}\n\n  	if (!options.event) {\n  		options.event = {\n  			name: eventName,\n  			// until event not included as argument default\n  			_noArg: true\n  		};\n  	} else {\n  		options.event.name = eventName;\n  	}\n\n  	var eventNames = getKeypath(eventName).wildcardMatches();\n  	fireEventAs(ractive, eventNames, options.event, options.args, true);\n  }\n\n  function fireEventAs(ractive, eventNames, event, args) {\n  	var initialFire = arguments[4] === undefined ? false : arguments[4];\n\n  	var subscribers,\n  	    i,\n  	    bubble = true;\n\n  	shared_eventStack.enqueue(ractive, event);\n\n  	for (i = eventNames.length; i >= 0; i--) {\n  		subscribers = ractive._subs[eventNames[i]];\n\n  		if (subscribers) {\n  			bubble = notifySubscribers(ractive, subscribers, event, args) && bubble;\n  		}\n  	}\n\n  	shared_eventStack.dequeue(ractive);\n\n  	if (ractive.parent && bubble) {\n\n  		if (initialFire && ractive.component) {\n  			var fullName = ractive.component.name + "." + eventNames[eventNames.length - 1];\n  			eventNames = getKeypath(fullName).wildcardMatches();\n\n  			if (event) {\n  				event.component = ractive;\n  			}\n  		}\n\n  		fireEventAs(ractive.parent, eventNames, event, args);\n  	}\n  }\n\n  function notifySubscribers(ractive, subscribers, event, args) {\n  	var originalEvent = null,\n  	    stopEvent = false;\n\n  	if (event && !event._noArg) {\n  		args = [event].concat(args);\n  	}\n\n  	// subscribers can be modified inflight, e.g. "once" functionality\n  	// so we need to copy to make sure everyone gets called\n  	subscribers = subscribers.slice();\n\n  	for (var i = 0, len = subscribers.length; i < len; i += 1) {\n  		if (subscribers[i].apply(ractive, args) === false) {\n  			stopEvent = true;\n  		}\n  	}\n\n  	if (event && !event._noArg && stopEvent && (originalEvent = event.original)) {\n  		originalEvent.preventDefault && originalEvent.preventDefault();\n  		originalEvent.stopPropagation && originalEvent.stopPropagation();\n  	}\n\n  	return !stopEvent;\n  }\n\n  var prototype_fire = Ractive$fire;\n  function Ractive$fire(eventName) {\n\n  	var options = {\n  		args: Array.prototype.slice.call(arguments, 1)\n  	};\n\n  	shared_fireEvent(this, eventName, options);\n  }\n\n  var prototype_get = Ractive$get;\n  var options = {\n  	capture: true, // top-level calls should be intercepted\n  	noUnwrap: true, // wrapped values should NOT be unwrapped\n  	fullRootGet: true // root get should return mappings\n  };\n  function Ractive$get(keypath) {\n  	var value;\n\n  	keypath = getKeypath(normalise(keypath));\n  	value = this.viewmodel.get(keypath, options);\n\n  	// Create inter-component binding, if necessary\n  	if (value === undefined && this.parent && !this.isolated) {\n  		if (shared_resolveRef(this, keypath.str, this.component.parentFragment)) {\n  			// creates binding as side-effect, if appropriate\n  			value = this.viewmodel.get(keypath);\n  		}\n  	}\n\n  	return value;\n  }\n\n  var insert = Ractive$insert;\n\n  var insertHook = new hooks_Hook("insert");\n  function Ractive$insert(target, anchor) {\n  	if (!this.fragment.rendered) {\n  		// TODO create, and link to, documentation explaining this\n  		throw new Error("The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.");\n  	}\n\n  	target = getElement(target);\n  	anchor = getElement(anchor) || null;\n\n  	if (!target) {\n  		throw new Error("You must specify a valid target to insert into");\n  	}\n\n  	target.insertBefore(this.detach(), anchor);\n  	this.el = target;\n\n  	(target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(this);\n  	this.detached = null;\n\n  	fireInsertHook(this);\n  }\n\n  function fireInsertHook(ractive) {\n  	insertHook.fire(ractive);\n\n  	ractive.findAllComponents("*").forEach(function (child) {\n  		fireInsertHook(child.instance);\n  	});\n  }\n\n  var prototype_merge = Ractive$merge;\n  function Ractive$merge(keypath, array, options) {\n  	var currentArray, promise;\n\n  	keypath = getKeypath(normalise(keypath));\n  	currentArray = this.viewmodel.get(keypath);\n\n  	// If either the existing value or the new value isn\'t an\n  	// array, just do a regular set\n  	if (!isArray(currentArray) || !isArray(array)) {\n  		return this.set(keypath, array, options && options.complete);\n  	}\n\n  	// Manage transitions\n  	promise = global_runloop.start(this, true);\n  	this.viewmodel.merge(keypath, currentArray, array, options);\n  	global_runloop.end();\n\n  	return promise;\n  }\n\n  var Observer = function (ractive, keypath, callback, options) {\n  	this.root = ractive;\n  	this.keypath = keypath;\n  	this.callback = callback;\n  	this.defer = options.defer;\n\n  	// default to root as context, but allow it to be overridden\n  	this.context = options && options.context ? options.context : ractive;\n  };\n\n  Observer.prototype = {\n  	init: function (immediate) {\n  		this.value = this.root.get(this.keypath.str);\n\n  		if (immediate !== false) {\n  			this.update();\n  		} else {\n  			this.oldValue = this.value;\n  		}\n  	},\n\n  	setValue: function (value) {\n  		var _this = this;\n\n  		if (!isEqual(value, this.value)) {\n  			this.value = value;\n\n  			if (this.defer && this.ready) {\n  				global_runloop.scheduleTask(function () {\n  					return _this.update();\n  				});\n  			} else {\n  				this.update();\n  			}\n  		}\n  	},\n\n  	update: function () {\n  		// Prevent infinite loops\n  		if (this.updating) {\n  			return;\n  		}\n\n  		this.updating = true;\n\n  		this.callback.call(this.context, this.value, this.oldValue, this.keypath.str);\n  		this.oldValue = this.value;\n\n  		this.updating = false;\n  	}\n  };\n\n  var observe_Observer = Observer;\n\n  var observe_getPattern = getPattern;\n  function getPattern(ractive, pattern) {\n  	var matchingKeypaths, values;\n\n  	matchingKeypaths = getMatchingKeypaths(ractive, pattern);\n\n  	values = {};\n  	matchingKeypaths.forEach(function (keypath) {\n  		values[keypath.str] = ractive.get(keypath.str);\n  	});\n\n  	return values;\n  }\n\n  var PatternObserver,\n      slice = Array.prototype.slice;\n\n  PatternObserver = function (ractive, keypath, callback, options) {\n  	this.root = ractive;\n\n  	this.callback = callback;\n  	this.defer = options.defer;\n\n  	this.keypath = keypath;\n  	this.regex = new RegExp("^" + keypath.str.replace(/\\./g, "\\\\.").replace(/\\*/g, "([^\\\\.]+)") + "$");\n  	this.values = {};\n\n  	if (this.defer) {\n  		this.proxies = [];\n  	}\n\n  	// default to root as context, but allow it to be overridden\n  	this.context = options && options.context ? options.context : ractive;\n  };\n\n  PatternObserver.prototype = {\n  	init: function (immediate) {\n  		var values, keypath;\n\n  		values = observe_getPattern(this.root, this.keypath);\n\n  		if (immediate !== false) {\n  			for (keypath in values) {\n  				if (values.hasOwnProperty(keypath)) {\n  					this.update(getKeypath(keypath));\n  				}\n  			}\n  		} else {\n  			this.values = values;\n  		}\n  	},\n\n  	update: function (keypath) {\n  		var _this = this;\n\n  		var values;\n\n  		if (keypath.isPattern) {\n  			values = observe_getPattern(this.root, keypath);\n\n  			for (keypath in values) {\n  				if (values.hasOwnProperty(keypath)) {\n  					this.update(getKeypath(keypath));\n  				}\n  			}\n\n  			return;\n  		}\n\n  		// special case - array mutation should not trigger `array.*`\n  		// pattern observer with `array.length`\n  		if (this.root.viewmodel.implicitChanges[keypath.str]) {\n  			return;\n  		}\n\n  		if (this.defer && this.ready) {\n  			global_runloop.scheduleTask(function () {\n  				return _this.getProxy(keypath).update();\n  			});\n  			return;\n  		}\n\n  		this.reallyUpdate(keypath);\n  	},\n\n  	reallyUpdate: function (keypath) {\n  		var keypathStr, value, keys, args;\n\n  		keypathStr = keypath.str;\n  		value = this.root.viewmodel.get(keypath);\n\n  		// Prevent infinite loops\n  		if (this.updating) {\n  			this.values[keypathStr] = value;\n  			return;\n  		}\n\n  		this.updating = true;\n\n  		if (!isEqual(value, this.values[keypathStr]) || !this.ready) {\n  			keys = slice.call(this.regex.exec(keypathStr), 1);\n  			args = [value, this.values[keypathStr], keypathStr].concat(keys);\n\n  			this.values[keypathStr] = value;\n  			this.callback.apply(this.context, args);\n  		}\n\n  		this.updating = false;\n  	},\n\n  	getProxy: function (keypath) {\n  		var _this = this;\n\n  		if (!this.proxies[keypath.str]) {\n  			this.proxies[keypath.str] = {\n  				update: function () {\n  					return _this.reallyUpdate(keypath);\n  				}\n  			};\n  		}\n\n  		return this.proxies[keypath.str];\n  	}\n  };\n\n  var observe_PatternObserver = PatternObserver;\n\n  var observe_getObserverFacade = getObserverFacade;\n  var emptyObject = {};\n  function getObserverFacade(ractive, keypath, callback, options) {\n  	var observer, isPatternObserver, cancelled;\n\n  	keypath = getKeypath(normalise(keypath));\n  	options = options || emptyObject;\n\n  	// pattern observers are treated differently\n  	if (keypath.isPattern) {\n  		observer = new observe_PatternObserver(ractive, keypath, callback, options);\n  		ractive.viewmodel.patternObservers.push(observer);\n  		isPatternObserver = true;\n  	} else {\n  		observer = new observe_Observer(ractive, keypath, callback, options);\n  	}\n\n  	observer.init(options.init);\n  	ractive.viewmodel.register(keypath, observer, isPatternObserver ? "patternObservers" : "observers");\n\n  	// This flag allows observers to initialise even with undefined values\n  	observer.ready = true;\n\n  	var facade = {\n  		cancel: function () {\n  			var index;\n\n  			if (cancelled) {\n  				return;\n  			}\n\n  			if (isPatternObserver) {\n  				index = ractive.viewmodel.patternObservers.indexOf(observer);\n\n  				ractive.viewmodel.patternObservers.splice(index, 1);\n  				ractive.viewmodel.unregister(keypath, observer, "patternObservers");\n  			} else {\n  				ractive.viewmodel.unregister(keypath, observer, "observers");\n  			}\n  			cancelled = true;\n  		}\n  	};\n\n  	ractive._observers.push(facade);\n  	return facade;\n  }\n\n  var observe = Ractive$observe;\n  function Ractive$observe(keypath, callback, options) {\n\n  	var observers, map, keypaths, i;\n\n  	// Allow a map of keypaths to handlers\n  	if (isObject(keypath)) {\n  		options = callback;\n  		map = keypath;\n\n  		observers = [];\n\n  		for (keypath in map) {\n  			if (map.hasOwnProperty(keypath)) {\n  				callback = map[keypath];\n  				observers.push(this.observe(keypath, callback, options));\n  			}\n  		}\n\n  		return {\n  			cancel: function () {\n  				while (observers.length) {\n  					observers.pop().cancel();\n  				}\n  			}\n  		};\n  	}\n\n  	// Allow `ractive.observe( callback )` - i.e. observe entire model\n  	if (typeof keypath === "function") {\n  		options = callback;\n  		callback = keypath;\n  		keypath = "";\n\n  		return observe_getObserverFacade(this, keypath, callback, options);\n  	}\n\n  	keypaths = keypath.split(" ");\n\n  	// Single keypath\n  	if (keypaths.length === 1) {\n  		return observe_getObserverFacade(this, keypath, callback, options);\n  	}\n\n  	// Multiple space-separated keypaths\n  	observers = [];\n\n  	i = keypaths.length;\n  	while (i--) {\n  		keypath = keypaths[i];\n\n  		if (keypath) {\n  			observers.push(observe_getObserverFacade(this, keypath, callback, options));\n  		}\n  	}\n\n  	return {\n  		cancel: function () {\n  			while (observers.length) {\n  				observers.pop().cancel();\n  			}\n  		}\n  	};\n  }\n\n  var observeOnce = Ractive$observeOnce;\n\n  function Ractive$observeOnce(property, callback, options) {\n\n  	var observer = this.observe(property, function () {\n  		callback.apply(this, arguments);\n  		observer.cancel();\n  	}, { init: false, defer: options && options.defer });\n\n  	return observer;\n  }\n\n  var shared_trim = function (str) {\n    return str.trim();\n  };\n\n  var notEmptyString = function (str) {\n    return str !== "";\n  };\n\n  var off = Ractive$off;\n  function Ractive$off(eventName, callback) {\n  	var _this = this;\n\n  	var eventNames;\n\n  	// if no arguments specified, remove all callbacks\n  	if (!eventName) {\n  		// TODO use this code instead, once the following issue has been resolved\n  		// in PhantomJS (tests are unpassable otherwise!)\n  		// https://github.com/ariya/phantomjs/issues/11856\n  		// defineProperty( this, \'_subs\', { value: create( null ), configurable: true });\n  		for (eventName in this._subs) {\n  			delete this._subs[eventName];\n  		}\n  	} else {\n  		// Handle multiple space-separated event names\n  		eventNames = eventName.split(" ").map(shared_trim).filter(notEmptyString);\n\n  		eventNames.forEach(function (eventName) {\n  			var subscribers, index;\n\n  			// If we have subscribers for this event...\n  			if (subscribers = _this._subs[eventName]) {\n  				// ...if a callback was specified, only remove that\n  				if (callback) {\n  					index = subscribers.indexOf(callback);\n  					if (index !== -1) {\n  						subscribers.splice(index, 1);\n  					}\n  				}\n\n  				// ...otherwise remove all callbacks\n  				else {\n  					_this._subs[eventName] = [];\n  				}\n  			}\n  		});\n  	}\n\n  	return this;\n  }\n\n  var on = Ractive$on;\n  function Ractive$on(eventName, callback) {\n  	var _this = this;\n\n  	var listeners, n, eventNames;\n\n  	// allow mutliple listeners to be bound in one go\n  	if (typeof eventName === "object") {\n  		listeners = [];\n\n  		for (n in eventName) {\n  			if (eventName.hasOwnProperty(n)) {\n  				listeners.push(this.on(n, eventName[n]));\n  			}\n  		}\n\n  		return {\n  			cancel: function () {\n  				var listener;\n\n  				while (listener = listeners.pop()) {\n  					listener.cancel();\n  				}\n  			}\n  		};\n  	}\n\n  	// Handle multiple space-separated event names\n  	eventNames = eventName.split(" ").map(shared_trim).filter(notEmptyString);\n\n  	eventNames.forEach(function (eventName) {\n  		(_this._subs[eventName] || (_this._subs[eventName] = [])).push(callback);\n  	});\n\n  	return {\n  		cancel: function () {\n  			return _this.off(eventName, callback);\n  		}\n  	};\n  }\n\n  var once = Ractive$once;\n\n  function Ractive$once(eventName, handler) {\n\n  	var listener = this.on(eventName, function () {\n  		handler.apply(this, arguments);\n  		listener.cancel();\n  	});\n\n  	// so we can still do listener.cancel() manually\n  	return listener;\n  }\n\n  // This function takes an array, the name of a mutator method, and the\n  // arguments to call that mutator method with, and returns an array that\n  // maps the old indices to their new indices.\n\n  // So if you had something like this...\n  //\n  //     array = [ \'a\', \'b\', \'c\', \'d\' ];\n  //     array.push( \'e\' );\n  //\n  // ...you\'d get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n  // have changed. If you then did this...\n  //\n  //     array.unshift( \'z\' );\n  //\n  // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n  // one higher to make room for the \'z\'. If you removed an item, the new index\n  // would be -1...\n  //\n  //     array.splice( 2, 2 );\n  //\n  // ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n  //\n  // This information is used to enable fast, non-destructive shuffling of list\n  // sections when you do e.g. `ractive.splice( \'items\', 2, 2 );\n\n  var shared_getNewIndices = getNewIndices;\n\n  function getNewIndices(array, methodName, args) {\n  	var spliceArguments,\n  	    len,\n  	    newIndices = [],\n  	    removeStart,\n  	    removeEnd,\n  	    balance,\n  	    i;\n\n  	spliceArguments = getSpliceEquivalent(array, methodName, args);\n\n  	if (!spliceArguments) {\n  		return null; // TODO support reverse and sort?\n  	}\n\n  	len = array.length;\n  	balance = spliceArguments.length - 2 - spliceArguments[1];\n\n  	removeStart = Math.min(len, spliceArguments[0]);\n  	removeEnd = removeStart + spliceArguments[1];\n\n  	for (i = 0; i < removeStart; i += 1) {\n  		newIndices.push(i);\n  	}\n\n  	for (; i < removeEnd; i += 1) {\n  		newIndices.push(-1);\n  	}\n\n  	for (; i < len; i += 1) {\n  		newIndices.push(i + balance);\n  	}\n\n  	// there is a net shift for the rest of the array starting with index + balance\n  	if (balance !== 0) {\n  		newIndices.touchedFrom = spliceArguments[0];\n  	} else {\n  		newIndices.touchedFrom = array.length;\n  	}\n\n  	return newIndices;\n  }\n\n  // The pop, push, shift an unshift methods can all be represented\n  // as an equivalent splice\n  function getSpliceEquivalent(array, methodName, args) {\n  	switch (methodName) {\n  		case "splice":\n  			if (args[0] !== undefined && args[0] < 0) {\n  				args[0] = array.length + Math.max(args[0], -array.length);\n  			}\n\n  			while (args.length < 2) {\n  				args.push(0);\n  			}\n\n  			// ensure we only remove elements that exist\n  			args[1] = Math.min(args[1], array.length - args[0]);\n\n  			return args;\n\n  		case "sort":\n  		case "reverse":\n  			return null;\n\n  		case "pop":\n  			if (array.length) {\n  				return [array.length - 1, 1];\n  			}\n  			return [0, 0];\n\n  		case "push":\n  			return [array.length, 0].concat(args);\n\n  		case "shift":\n  			return [0, array.length ? 1 : 0];\n\n  		case "unshift":\n  			return [0, 0].concat(args);\n  	}\n  }\n\n  var arrayProto = Array.prototype;\n\n  var makeArrayMethod = function (methodName) {\n  	return function (keypath) {\n  		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  			args[_key - 1] = arguments[_key];\n  		}\n\n  		var array,\n  		    newIndices = [],\n  		    len,\n  		    promise,\n  		    result;\n\n  		keypath = getKeypath(normalise(keypath));\n\n  		array = this.viewmodel.get(keypath);\n  		len = array.length;\n\n  		if (!isArray(array)) {\n  			throw new Error("Called ractive." + methodName + "(\'" + keypath.str + "\'), but \'" + keypath.str + "\' does not refer to an array");\n  		}\n\n  		newIndices = shared_getNewIndices(array, methodName, args);\n\n  		result = arrayProto[methodName].apply(array, args);\n  		promise = global_runloop.start(this, true).then(function () {\n  			return result;\n  		});\n\n  		if (!!newIndices) {\n  			this.viewmodel.smartUpdate(keypath, array, newIndices);\n  		} else {\n  			this.viewmodel.mark(keypath);\n  		}\n\n  		global_runloop.end();\n\n  		return promise;\n  	};\n  };\n\n  var pop = makeArrayMethod("pop");\n\n  var push = makeArrayMethod("push");\n\n  var css,\n      update,\n      styleElement,\n      head,\n      styleSheet,\n      inDom,\n      global_css__prefix = "/* Ractive.js component styles */\\n",\n      styles = [],\n      dirty = false;\n\n  if (!isClient) {\n  	css = null;\n  } else {\n  	styleElement = document.createElement("style");\n  	styleElement.type = "text/css";\n\n  	head = document.getElementsByTagName("head")[0];\n\n  	inDom = false;\n\n  	// Internet Exploder won\'t let you use styleSheet.innerHTML - we have to\n  	// use styleSheet.cssText instead\n  	styleSheet = styleElement.styleSheet;\n\n  	update = function () {\n  		var css = global_css__prefix + styles.map(function (s) {\n  			return "\\n/* {" + s.id + "} */\\n" + s.styles;\n  		}).join("\\n");\n\n  		if (styleSheet) {\n  			styleSheet.cssText = css;\n  		} else {\n  			styleElement.innerHTML = css;\n  		}\n\n  		if (!inDom) {\n  			head.appendChild(styleElement);\n  			inDom = true;\n  		}\n  	};\n\n  	css = {\n  		add: function (s) {\n  			styles.push(s);\n  			dirty = true;\n  		},\n\n  		apply: function () {\n  			if (dirty) {\n  				update();\n  				dirty = false;\n  			}\n  		}\n  	};\n  }\n\n  var global_css = css;\n\n  var prototype_render = Ractive$render;\n\n  var renderHook = new hooks_Hook("render"),\n      completeHook = new hooks_Hook("complete");\n  function Ractive$render(target, anchor) {\n  	var _this = this;\n\n  	var promise, instances, transitionsEnabled;\n\n  	// if `noIntro` is `true`, temporarily disable transitions\n  	transitionsEnabled = this.transitionsEnabled;\n  	if (this.noIntro) {\n  		this.transitionsEnabled = false;\n  	}\n\n  	promise = global_runloop.start(this, true);\n  	global_runloop.scheduleTask(function () {\n  		return renderHook.fire(_this);\n  	}, true);\n\n  	if (this.fragment.rendered) {\n  		throw new Error("You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first");\n  	}\n\n  	target = getElement(target) || this.el;\n  	anchor = getElement(anchor) || this.anchor;\n\n  	this.el = target;\n  	this.anchor = anchor;\n\n  	if (!this.append && target) {\n  		// Teardown any existing instances *before* trying to set up the new one -\n  		// avoids certain weird bugs\n  		var others = target.__ractive_instances__;\n  		if (others && others.length) {\n  			removeOtherInstances(others);\n  		}\n\n  		// make sure we are the only occupants\n  		target.innerHTML = ""; // TODO is this quicker than removeChild? Initial research inconclusive\n  	}\n\n  	if (this.cssId) {\n  		// ensure encapsulated CSS is up-to-date\n  		global_css.apply();\n  	}\n\n  	if (target) {\n  		if (!(instances = target.__ractive_instances__)) {\n  			target.__ractive_instances__ = [this];\n  		} else {\n  			instances.push(this);\n  		}\n\n  		if (anchor) {\n  			target.insertBefore(this.fragment.render(), anchor);\n  		} else {\n  			target.appendChild(this.fragment.render());\n  		}\n  	}\n\n  	global_runloop.end();\n\n  	this.transitionsEnabled = transitionsEnabled;\n\n  	return promise.then(function () {\n  		return completeHook.fire(_this);\n  	});\n  }\n\n  function removeOtherInstances(others) {\n  	others.splice(0, others.length).forEach(teardown);\n  }\n\n  var adaptConfigurator = {\n  	extend: function (Parent, proto, options) {\n  		proto.adapt = custom_adapt__combine(proto.adapt, ensureArray(options.adapt));\n  	},\n\n  	init: function () {}\n  };\n\n  var custom_adapt = adaptConfigurator;\n\n  function custom_adapt__combine(a, b) {\n  	var c = a.slice(),\n  	    i = b.length;\n\n  	while (i--) {\n  		if (! ~c.indexOf(b[i])) {\n  			c.push(b[i]);\n  		}\n  	}\n\n  	return c;\n  }\n\n  var transform = transformCss;\n\n  var selectorsPattern = /(?:^|\\})?\\s*([^\\{\\}]+)\\s*\\{/g,\n      commentsPattern = /\\/\\*.*?\\*\\//g,\n      selectorUnitPattern = /((?:(?:\\[[^\\]+]\\])|(?:[^\\s\\+\\>\\~:]))+)((?::[^\\s\\+\\>\\~\\(]+(?:\\([^\\)]+\\))?)?\\s*[\\s\\+\\>\\~]?)\\s*/g,\n      mediaQueryPattern = /^@media/,\n      dataRvcGuidPattern = /\\[data-ractive-css~="\\{[a-z0-9-]+\\}"]/g;\n  function transformCss(css, id) {\n  	var transformed, dataAttr, addGuid;\n\n  	dataAttr = "[data-ractive-css~=\\"{" + id + "}\\"]";\n\n  	addGuid = function (selector) {\n  		var selectorUnits,\n  		    match,\n  		    unit,\n  		    base,\n  		    prepended,\n  		    appended,\n  		    i,\n  		    transformed = [];\n\n  		selectorUnits = [];\n\n  		while (match = selectorUnitPattern.exec(selector)) {\n  			selectorUnits.push({\n  				str: match[0],\n  				base: match[1],\n  				modifiers: match[2]\n  			});\n  		}\n\n  		// For each simple selector within the selector, we need to create a version\n  		// that a) combines with the id, and b) is inside the id\n  		base = selectorUnits.map(extractString);\n\n  		i = selectorUnits.length;\n  		while (i--) {\n  			appended = base.slice();\n\n  			// Pseudo-selectors should go after the attribute selector\n  			unit = selectorUnits[i];\n  			appended[i] = unit.base + dataAttr + unit.modifiers || "";\n\n  			prepended = base.slice();\n  			prepended[i] = dataAttr + " " + prepended[i];\n\n  			transformed.push(appended.join(" "), prepended.join(" "));\n  		}\n\n  		return transformed.join(", ");\n  	};\n\n  	if (dataRvcGuidPattern.test(css)) {\n  		transformed = css.replace(dataRvcGuidPattern, dataAttr);\n  	} else {\n  		transformed = css.replace(commentsPattern, "").replace(selectorsPattern, function (match, $1) {\n  			var selectors, transformed;\n\n  			// don\'t transform media queries!\n  			if (mediaQueryPattern.test($1)) return match;\n\n  			selectors = $1.split(",").map(trim);\n  			transformed = selectors.map(addGuid).join(", ") + " ";\n\n  			return match.replace($1, transformed);\n  		});\n  	}\n\n  	return transformed;\n  }\n\n  function trim(str) {\n  	if (str.trim) {\n  		return str.trim();\n  	}\n\n  	return str.replace(/^\\s+/, "").replace(/\\s+$/, "");\n  }\n\n  function extractString(unit) {\n  	return unit.str;\n  }\n\n  var css_css__uid = 1;\n\n  var cssConfigurator = {\n  	name: "css",\n\n  	extend: function (Parent, proto, options) {\n  		if (options.css) {\n  			var id = css_css__uid++;\n  			var styles = options.noCssTransform ? options.css : transform(options.css, id);\n\n  			proto.cssId = id;\n  			global_css.add({ id: id, styles: styles });\n  		}\n  	},\n\n  	init: function () {}\n  };\n\n  var css_css = cssConfigurator;\n\n  function validate(data) {\n  	// Warn if userOptions.data is a non-POJO\n  	if (data && data.constructor !== Object) {\n  		if (typeof data === "function") {} else if (typeof data !== "object") {\n  			fatal("data option must be an object or a function, `" + data + "` is not valid");\n  		} else {\n  			warnIfDebug("If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged");\n  		}\n  	}\n  }\n\n  var dataConfigurator = {\n  	name: "data",\n\n  	extend: function (Parent, proto, options) {\n  		var key = undefined,\n  		    value = undefined;\n\n  		// check for non-primitives, which could cause mutation-related bugs\n  		if (options.data && isObject(options.data)) {\n  			for (key in options.data) {\n  				value = options.data[key];\n\n  				if (value && typeof value === "object") {\n  					if (isObject(value) || isArray(value)) {\n  						warnIfDebug("Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\\n\\n  // this...\\n  data: function () {\\n    return {\\n      myObject: {}\\n    };\\n  })\\n\\n  // instead of this:\\n  data: {\\n    myObject: {}\\n  }");\n  					}\n  				}\n  			}\n  		}\n\n  		proto.data = custom_data__combine(proto.data, options.data);\n  	},\n\n  	init: function (Parent, ractive, options) {\n  		var result = custom_data__combine(Parent.prototype.data, options.data);\n\n  		if (typeof result === "function") {\n  			result = result.call(ractive);\n  		}\n\n  		return result || {};\n  	},\n\n  	reset: function (ractive) {\n  		var result = this.init(ractive.constructor, ractive, ractive.viewmodel);\n\n  		ractive.viewmodel.reset(result);\n  		return true;\n  	}\n  };\n\n  var custom_data = dataConfigurator;\n\n  function custom_data__combine(parentValue, childValue) {\n  	validate(childValue);\n\n  	var parentIsFn = typeof parentValue === "function";\n  	var childIsFn = typeof childValue === "function";\n\n  	// Very important, otherwise child instance can become\n  	// the default data object on Ractive or a component.\n  	// then ractive.set() ends up setting on the prototype!\n  	if (!childValue && !parentIsFn) {\n  		childValue = {};\n  	}\n\n  	// Fast path, where we just need to copy properties from\n  	// parent to child\n  	if (!parentIsFn && !childIsFn) {\n  		return fromProperties(childValue, parentValue);\n  	}\n\n  	return function () {\n  		var child = childIsFn ? callDataFunction(childValue, this) : childValue;\n  		var parent = parentIsFn ? callDataFunction(parentValue, this) : parentValue;\n\n  		return fromProperties(child, parent);\n  	};\n  }\n\n  function callDataFunction(fn, context) {\n  	var data = fn.call(context);\n\n  	if (!data) return;\n\n  	if (typeof data !== "object") {\n  		fatal("Data function must return an object");\n  	}\n\n  	if (data.constructor !== Object) {\n  		warnOnceIfDebug("Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged");\n  	}\n\n  	return data;\n  }\n\n  function fromProperties(primary, secondary) {\n  	if (primary && secondary) {\n  		for (var key in secondary) {\n  			if (!(key in primary)) {\n  				primary[key] = secondary[key];\n  			}\n  		}\n\n  		return primary;\n  	}\n\n  	return primary || secondary;\n  }\n\n  // TODO do we need to support this in the new Ractive() case?\n\n  var Parser,\n      ParseError,\n      parse_Parser__leadingWhitespace = /^\\s+/;\n\n  ParseError = function (message) {\n  	this.name = "ParseError";\n  	this.message = message;\n  	try {\n  		throw new Error(message);\n  	} catch (e) {\n  		this.stack = e.stack;\n  	}\n  };\n\n  ParseError.prototype = Error.prototype;\n\n  Parser = function (str, options) {\n  	var items,\n  	    item,\n  	    lineStart = 0;\n\n  	this.str = str;\n  	this.options = options || {};\n  	this.pos = 0;\n\n  	this.lines = this.str.split("\\n");\n  	this.lineEnds = this.lines.map(function (line) {\n  		var lineEnd = lineStart + line.length + 1; // +1 for the newline\n\n  		lineStart = lineEnd;\n  		return lineEnd;\n  	}, 0);\n\n  	// Custom init logic\n  	if (this.init) this.init(str, options);\n\n  	items = [];\n\n  	while (this.pos < this.str.length && (item = this.read())) {\n  		items.push(item);\n  	}\n\n  	this.leftover = this.remaining();\n  	this.result = this.postProcess ? this.postProcess(items, options) : items;\n  };\n\n  Parser.prototype = {\n  	read: function (converters) {\n  		var pos, i, len, item;\n\n  		if (!converters) converters = this.converters;\n\n  		pos = this.pos;\n\n  		len = converters.length;\n  		for (i = 0; i < len; i += 1) {\n  			this.pos = pos; // reset for each attempt\n\n  			if (item = converters[i](this)) {\n  				return item;\n  			}\n  		}\n\n  		return null;\n  	},\n\n  	getLinePos: function (char) {\n  		var lineNum = 0,\n  		    lineStart = 0,\n  		    columnNum;\n\n  		while (char >= this.lineEnds[lineNum]) {\n  			lineStart = this.lineEnds[lineNum];\n  			lineNum += 1;\n  		}\n\n  		columnNum = char - lineStart;\n  		return [lineNum + 1, columnNum + 1, char]; // line/col should be one-based, not zero-based!\n  	},\n\n  	error: function (message) {\n  		var pos = this.getLinePos(this.pos);\n  		var lineNum = pos[0];\n  		var columnNum = pos[1];\n\n  		var line = this.lines[pos[0] - 1];\n  		var numTabs = 0;\n  		var annotation = line.replace(/\\t/g, function (match, char) {\n  			if (char < pos[1]) {\n  				numTabs += 1;\n  			}\n\n  			return "  ";\n  		}) + "\\n" + new Array(pos[1] + numTabs).join(" ") + "^----";\n\n  		var error = new ParseError("" + message + " at line " + lineNum + " character " + columnNum + ":\\n" + annotation);\n\n  		error.line = pos[0];\n  		error.character = pos[1];\n  		error.shortMessage = message;\n\n  		throw error;\n  	},\n\n  	matchString: function (string) {\n  		if (this.str.substr(this.pos, string.length) === string) {\n  			this.pos += string.length;\n  			return string;\n  		}\n  	},\n\n  	matchPattern: function (pattern) {\n  		var match;\n\n  		if (match = pattern.exec(this.remaining())) {\n  			this.pos += match[0].length;\n  			return match[1] || match[0];\n  		}\n  	},\n\n  	allowWhitespace: function () {\n  		this.matchPattern(parse_Parser__leadingWhitespace);\n  	},\n\n  	remaining: function () {\n  		return this.str.substring(this.pos);\n  	},\n\n  	nextChar: function () {\n  		return this.str.charAt(this.pos);\n  	}\n  };\n\n  Parser.extend = function (proto) {\n  	var Parent = this,\n  	    Child,\n  	    key;\n\n  	Child = function (str, options) {\n  		Parser.call(this, str, options);\n  	};\n\n  	Child.prototype = create(Parent.prototype);\n\n  	for (key in proto) {\n  		if (hasOwn.call(proto, key)) {\n  			Child.prototype[key] = proto[key];\n  		}\n  	}\n\n  	Child.extend = Parser.extend;\n  	return Child;\n  };\n\n  var parse_Parser = Parser;\n\n  var TEXT = 1;\n  var INTERPOLATOR = 2;\n  var TRIPLE = 3;\n  var SECTION = 4;\n  var INVERTED = 5;\n  var CLOSING = 6;\n  var ELEMENT = 7;\n  var PARTIAL = 8;\n  var COMMENT = 9;\n  var DELIMCHANGE = 10;\n  var ATTRIBUTE = 13;\n  var CLOSING_TAG = 14;\n  var COMPONENT = 15;\n  var YIELDER = 16;\n  var INLINE_PARTIAL = 17;\n  var DOCTYPE = 18;\n\n  var NUMBER_LITERAL = 20;\n  var STRING_LITERAL = 21;\n  var ARRAY_LITERAL = 22;\n  var OBJECT_LITERAL = 23;\n  var BOOLEAN_LITERAL = 24;\n  var REGEXP_LITERAL = 25;\n\n  var GLOBAL = 26;\n  var KEY_VALUE_PAIR = 27;\n\n  var REFERENCE = 30;\n  var REFINEMENT = 31;\n  var MEMBER = 32;\n  var PREFIX_OPERATOR = 33;\n  var BRACKETED = 34;\n  var CONDITIONAL = 35;\n  var INFIX_OPERATOR = 36;\n\n  var INVOCATION = 40;\n\n  var SECTION_IF = 50;\n  var SECTION_UNLESS = 51;\n  var SECTION_EACH = 52;\n  var SECTION_WITH = 53;\n  var SECTION_IF_WITH = 54;\n\n  var ELSE = 60;\n  var ELSEIF = 61;\n\n  var mustache_readDelimiterChange = readDelimiterChange;\n  var delimiterChangePattern = /^[^\\s=]+/,\n      whitespacePattern = /^\\s+/;\n  function readDelimiterChange(parser) {\n  	var start, opening, closing;\n\n  	if (!parser.matchString("=")) {\n  		return null;\n  	}\n\n  	start = parser.pos;\n\n  	// allow whitespace before new opening delimiter\n  	parser.allowWhitespace();\n\n  	opening = parser.matchPattern(delimiterChangePattern);\n  	if (!opening) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	// allow whitespace (in fact, it\'s necessary...)\n  	if (!parser.matchPattern(whitespacePattern)) {\n  		return null;\n  	}\n\n  	closing = parser.matchPattern(delimiterChangePattern);\n  	if (!closing) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	// allow whitespace before closing \'=\'\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("=")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	return [opening, closing];\n  }\n\n  var readRegexpLiteral = readRegexpLiteral__readNumberLiteral;\n  var regexpPattern = /^(\\/(?:[^\\n\\r\\u2028\\u2029/\\\\[]|\\\\.|\\[(?:[^\\n\\r\\u2028\\u2029\\]\\\\]|\\\\.)*])+\\/(?:([gimuy])(?![a-z]*\\2))*(?![a-zA-Z_$0-9]))/;\n  function readRegexpLiteral__readNumberLiteral(parser) {\n  	var result;\n\n  	if (result = parser.matchPattern(regexpPattern)) {\n  		return {\n  			t: REGEXP_LITERAL,\n  			v: result\n  		};\n  	}\n\n  	return null;\n  }\n\n  var converters_readMustache = readMustache;\n\n  var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };\n  function readMustache(parser) {\n  	var mustache, i;\n\n  	// If we\'re inside a <script> or <style> tag, and we\'re not\n  	// interpolating, bug out\n  	if (parser.interpolate[parser.inside] === false) {\n  		return null;\n  	}\n\n  	for (i = 0; i < parser.tags.length; i += 1) {\n  		if (mustache = readMustacheOfType(parser, parser.tags[i])) {\n  			return mustache;\n  		}\n  	}\n  }\n\n  function readMustacheOfType(parser, tag) {\n  	var start, mustache, reader, i;\n\n  	start = parser.pos;\n\n  	if (parser.matchString("\\\\" + tag.open)) {\n  		if (start === 0 || parser.str[start - 1] !== "\\\\") {\n  			return tag.open;\n  		}\n  	} else if (!parser.matchString(tag.open)) {\n  		return null;\n  	}\n\n  	// delimiter change?\n  	if (mustache = mustache_readDelimiterChange(parser)) {\n  		// find closing delimiter or abort...\n  		if (!parser.matchString(tag.close)) {\n  			return null;\n  		}\n\n  		// ...then make the switch\n  		tag.open = mustache[0];\n  		tag.close = mustache[1];\n  		parser.sortMustacheTags();\n\n  		return delimiterChangeToken;\n  	}\n\n  	parser.allowWhitespace();\n\n  	// illegal section closer\n  	if (parser.matchString("/")) {\n  		parser.pos -= 1;\n  		var rewind = parser.pos;\n  		if (!readRegexpLiteral(parser)) {\n  			parser.pos = rewind - tag.close.length;\n  			parser.error("Attempted to close a section that wasn\'t open");\n  		} else {\n  			parser.pos = rewind;\n  		}\n  	}\n\n  	for (i = 0; i < tag.readers.length; i += 1) {\n  		reader = tag.readers[i];\n\n  		if (mustache = reader(parser, tag)) {\n  			if (tag.isStatic) {\n  				mustache.s = true; // TODO make this `1` instead - more compact\n  			}\n\n  			if (parser.includeLinePositions) {\n  				mustache.p = parser.getLinePos(start);\n  			}\n\n  			return mustache;\n  		}\n  	}\n\n  	parser.pos = start;\n  	return null;\n  }\n\n  var expectedExpression = "Expected a JavaScript expression";\n  var expectedParen = "Expected closing paren";\n\n  var literal_readNumberLiteral = literal_readNumberLiteral__readNumberLiteral;\n  var literal_readNumberLiteral__numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n  function literal_readNumberLiteral__readNumberLiteral(parser) {\n  	var result;\n\n  	if (result = parser.matchPattern(literal_readNumberLiteral__numberPattern)) {\n  		return {\n  			t: NUMBER_LITERAL,\n  			v: result\n  		};\n  	}\n\n  	return null;\n  }\n\n  var literal_readBooleanLiteral = readBooleanLiteral;\n  function readBooleanLiteral(parser) {\n  	var remaining = parser.remaining();\n\n  	if (remaining.substr(0, 4) === "true") {\n  		parser.pos += 4;\n  		return {\n  			t: BOOLEAN_LITERAL,\n  			v: "true"\n  		};\n  	}\n\n  	if (remaining.substr(0, 5) === "false") {\n  		parser.pos += 5;\n  		return {\n  			t: BOOLEAN_LITERAL,\n  			v: "false"\n  		};\n  	}\n\n  	return null;\n  }\n\n  var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;\n\n  // Match one or more characters until: ", \', \\, or EOL/EOF.\n  // EOL/EOF is written as (?!.) (meaning there\'s no non-newline char next).\n  stringMiddlePattern = /^(?=.)[^"\'\\\\]+?(?:(?!.)|(?=["\'\\\\]))/;\n\n  // Match one escape sequence, including the backslash.\n  escapeSequencePattern = /^\\\\(?:[\'"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\n  // Match one ES5 line continuation (backslash + line terminator).\n  lineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\n  // Helper for defining getDoubleQuotedString and getSingleQuotedString.\n  var makeQuotedStringMatcher = function (okQuote) {\n  	return function (parser) {\n  		var start, literal, done, next;\n\n  		start = parser.pos;\n  		literal = "\\"";\n  		done = false;\n\n  		while (!done) {\n  			next = parser.matchPattern(stringMiddlePattern) || parser.matchPattern(escapeSequencePattern) || parser.matchString(okQuote);\n  			if (next) {\n  				if (next === "\\"") {\n  					literal += "\\\\\\"";\n  				} else if (next === "\\\\\'") {\n  					literal += "\'";\n  				} else {\n  					literal += next;\n  				}\n  			} else {\n  				next = parser.matchPattern(lineContinuationPattern);\n  				if (next) {\n  					// convert \\(newline-like) into a \\u escape, which is allowed in JSON\n  					literal += "\\\\u" + ("000" + next.charCodeAt(1).toString(16)).slice(-4);\n  				} else {\n  					done = true;\n  				}\n  			}\n  		}\n\n  		literal += "\\"";\n\n  		// use JSON.parse to interpret escapes\n  		return JSON.parse(literal);\n  	};\n  };\n\n  var getSingleQuotedString = makeQuotedStringMatcher("\\"");\n  var getDoubleQuotedString = makeQuotedStringMatcher("\'");\n\n  var readStringLiteral = function (parser) {\n  	var start, string;\n\n  	start = parser.pos;\n\n  	if (parser.matchString("\\"")) {\n  		string = getDoubleQuotedString(parser);\n\n  		if (!parser.matchString("\\"")) {\n  			parser.pos = start;\n  			return null;\n  		}\n\n  		return {\n  			t: STRING_LITERAL,\n  			v: string\n  		};\n  	}\n\n  	if (parser.matchString("\'")) {\n  		string = getSingleQuotedString(parser);\n\n  		if (!parser.matchString("\'")) {\n  			parser.pos = start;\n  			return null;\n  		}\n\n  		return {\n  			t: STRING_LITERAL,\n  			v: string\n  		};\n  	}\n\n  	return null;\n  };\n\n  var patterns__name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;\n\n  // http://mathiasbynens.be/notes/javascript-properties\n  // can be any name, string literal, or number literal\n  var shared_readKey = readKey;\n  var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n  function readKey(parser) {\n  	var token;\n\n  	if (token = readStringLiteral(parser)) {\n  		return identifier.test(token.v) ? token.v : "\\"" + token.v.replace(/"/g, "\\\\\\"") + "\\"";\n  	}\n\n  	if (token = literal_readNumberLiteral(parser)) {\n  		return token.v;\n  	}\n\n  	if (token = parser.matchPattern(patterns__name)) {\n  		return token;\n  	}\n  }\n\n  var keyValuePair = readKeyValuePair;\n  function readKeyValuePair(parser) {\n  	var start, key, value;\n\n  	start = parser.pos;\n\n  	// allow whitespace between \'{\' and key\n  	parser.allowWhitespace();\n\n  	key = shared_readKey(parser);\n  	if (key === null) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	// allow whitespace between key and \':\'\n  	parser.allowWhitespace();\n\n  	// next character must be \':\'\n  	if (!parser.matchString(":")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	// allow whitespace between \':\' and value\n  	parser.allowWhitespace();\n\n  	// next expression must be a, well... expression\n  	value = converters_readExpression(parser);\n  	if (value === null) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	return {\n  		t: KEY_VALUE_PAIR,\n  		k: key,\n  		v: value\n  	};\n  }\n\n  var objectLiteral_keyValuePairs = readKeyValuePairs;\n  function readKeyValuePairs(parser) {\n  	var start, pairs, pair, keyValuePairs;\n\n  	start = parser.pos;\n\n  	pair = keyValuePair(parser);\n  	if (pair === null) {\n  		return null;\n  	}\n\n  	pairs = [pair];\n\n  	if (parser.matchString(",")) {\n  		keyValuePairs = readKeyValuePairs(parser);\n\n  		if (!keyValuePairs) {\n  			parser.pos = start;\n  			return null;\n  		}\n\n  		return pairs.concat(keyValuePairs);\n  	}\n\n  	return pairs;\n  }\n\n  var readObjectLiteral = function (parser) {\n  	var start, keyValuePairs;\n\n  	start = parser.pos;\n\n  	// allow whitespace\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("{")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	keyValuePairs = objectLiteral_keyValuePairs(parser);\n\n  	// allow whitespace between final value and \'}\'\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("}")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	return {\n  		t: OBJECT_LITERAL,\n  		m: keyValuePairs\n  	};\n  };\n\n  var shared_readExpressionList = readExpressionList;\n  function readExpressionList(parser) {\n  	var start, expressions, expr, next;\n\n  	start = parser.pos;\n\n  	parser.allowWhitespace();\n\n  	expr = converters_readExpression(parser);\n\n  	if (expr === null) {\n  		return null;\n  	}\n\n  	expressions = [expr];\n\n  	// allow whitespace between expression and \',\'\n  	parser.allowWhitespace();\n\n  	if (parser.matchString(",")) {\n  		next = readExpressionList(parser);\n  		if (next === null) {\n  			parser.error(expectedExpression);\n  		}\n\n  		next.forEach(append);\n  	}\n\n  	function append(expression) {\n  		expressions.push(expression);\n  	}\n\n  	return expressions;\n  }\n\n  var readArrayLiteral = function (parser) {\n  	var start, expressionList;\n\n  	start = parser.pos;\n\n  	// allow whitespace before \'[\'\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("[")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	expressionList = shared_readExpressionList(parser);\n\n  	if (!parser.matchString("]")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	return {\n  		t: ARRAY_LITERAL,\n  		m: expressionList\n  	};\n  };\n\n  var primary_readLiteral = readLiteral;\n  function readLiteral(parser) {\n  	return literal_readNumberLiteral(parser) || literal_readBooleanLiteral(parser) || readStringLiteral(parser) || readObjectLiteral(parser) || readArrayLiteral(parser) || readRegexpLiteral(parser);\n  }\n\n  var primary_readReference = readReference;\n  var prefixPattern = /^(?:~\\/|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/,\n      globals,\n      keywords;\n\n  // if a reference is a browser global, we don\'t deference it later, so it needs special treatment\n  globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)\\b/;\n\n  // keywords are not valid references, with the exception of `this`\n  keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\n  var legalReference = /^[a-zA-Z$_0-9]+(?:(?:\\.[a-zA-Z$_0-9]+)|(?:\\[[0-9]+\\]))*/;\n  var relaxedName = /^[a-zA-Z_$][-a-zA-Z_$0-9]*/;\n  function readReference(parser) {\n  	var startPos, prefix, name, global, reference, lastDotIndex;\n\n  	startPos = parser.pos;\n\n  	name = parser.matchPattern(/^@(?:keypath|index|key)/);\n\n  	if (!name) {\n  		prefix = parser.matchPattern(prefixPattern) || "";\n  		name = !prefix && parser.relaxedNames && parser.matchPattern(relaxedName) || parser.matchPattern(legalReference);\n\n  		if (!name && prefix === ".") {\n  			prefix = "";\n  			name = ".";\n  		}\n  	}\n\n  	if (!name) {\n  		return null;\n  	}\n\n  	// bug out if it\'s a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)\n  	if (!prefix && !parser.relaxedNames && keywords.test(name)) {\n  		parser.pos = startPos;\n  		return null;\n  	}\n\n  	// if this is a browser global, stop here\n  	if (!prefix && globals.test(name)) {\n  		global = globals.exec(name)[0];\n  		parser.pos = startPos + global.length;\n\n  		return {\n  			t: GLOBAL,\n  			v: global\n  		};\n  	}\n\n  	reference = (prefix || "") + normalise(name);\n\n  	if (parser.matchString("(")) {\n  		// if this is a method invocation (as opposed to a function) we need\n  		// to strip the method name from the reference combo, else the context\n  		// will be wrong\n  		lastDotIndex = reference.lastIndexOf(".");\n  		if (lastDotIndex !== -1) {\n  			reference = reference.substr(0, lastDotIndex);\n  			parser.pos = startPos + reference.length;\n  		} else {\n  			parser.pos -= 1;\n  		}\n  	}\n\n  	return {\n  		t: REFERENCE,\n  		n: reference.replace(/^this\\./, "./").replace(/^this$/, ".")\n  	};\n  }\n\n  var primary_readBracketedExpression = readBracketedExpression;\n  function readBracketedExpression(parser) {\n  	var start, expr;\n\n  	start = parser.pos;\n\n  	if (!parser.matchString("(")) {\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	expr = converters_readExpression(parser);\n  	if (!expr) {\n  		parser.error(expectedExpression);\n  	}\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString(")")) {\n  		parser.error(expectedParen);\n  	}\n\n  	return {\n  		t: BRACKETED,\n  		x: expr\n  	};\n  }\n\n  var readPrimary = function (parser) {\n  	return primary_readLiteral(parser) || primary_readReference(parser) || primary_readBracketedExpression(parser);\n  };\n\n  var shared_readRefinement = readRefinement;\n  function readRefinement(parser) {\n  	var start, name, expr;\n\n  	start = parser.pos;\n\n  	parser.allowWhitespace();\n\n  	// "." name\n  	if (parser.matchString(".")) {\n  		parser.allowWhitespace();\n\n  		if (name = parser.matchPattern(patterns__name)) {\n  			return {\n  				t: REFINEMENT,\n  				n: name\n  			};\n  		}\n\n  		parser.error("Expected a property name");\n  	}\n\n  	// "[" expression "]"\n  	if (parser.matchString("[")) {\n  		parser.allowWhitespace();\n\n  		expr = converters_readExpression(parser);\n  		if (!expr) {\n  			parser.error(expectedExpression);\n  		}\n\n  		parser.allowWhitespace();\n\n  		if (!parser.matchString("]")) {\n  			parser.error("Expected \']\'");\n  		}\n\n  		return {\n  			t: REFINEMENT,\n  			x: expr\n  		};\n  	}\n\n  	return null;\n  }\n\n  var readMemberOrInvocation = function (parser) {\n  	var current, expression, refinement, expressionList;\n\n  	expression = readPrimary(parser);\n\n  	if (!expression) {\n  		return null;\n  	}\n\n  	while (expression) {\n  		current = parser.pos;\n\n  		if (refinement = shared_readRefinement(parser)) {\n  			expression = {\n  				t: MEMBER,\n  				x: expression,\n  				r: refinement\n  			};\n  		} else if (parser.matchString("(")) {\n  			parser.allowWhitespace();\n  			expressionList = shared_readExpressionList(parser);\n\n  			parser.allowWhitespace();\n\n  			if (!parser.matchString(")")) {\n  				parser.error(expectedParen);\n  			}\n\n  			expression = {\n  				t: INVOCATION,\n  				x: expression\n  			};\n\n  			if (expressionList) {\n  				expression.o = expressionList;\n  			}\n  		} else {\n  			break;\n  		}\n  	}\n\n  	return expression;\n  };\n\n  var readTypeOf, makePrefixSequenceMatcher;\n\n  makePrefixSequenceMatcher = function (symbol, fallthrough) {\n  	return function (parser) {\n  		var expression;\n\n  		if (expression = fallthrough(parser)) {\n  			return expression;\n  		}\n\n  		if (!parser.matchString(symbol)) {\n  			return null;\n  		}\n\n  		parser.allowWhitespace();\n\n  		expression = converters_readExpression(parser);\n  		if (!expression) {\n  			parser.error(expectedExpression);\n  		}\n\n  		return {\n  			s: symbol,\n  			o: expression,\n  			t: PREFIX_OPERATOR\n  		};\n  	};\n  };\n\n  // create all prefix sequence matchers, return readTypeOf\n  (function () {\n  	var i, len, matcher, prefixOperators, fallthrough;\n\n  	prefixOperators = "! ~ + - typeof".split(" ");\n\n  	fallthrough = readMemberOrInvocation;\n  	for (i = 0, len = prefixOperators.length; i < len; i += 1) {\n  		matcher = makePrefixSequenceMatcher(prefixOperators[i], fallthrough);\n  		fallthrough = matcher;\n  	}\n\n  	// typeof operator is higher precedence than multiplication, so provides the\n  	// fallthrough for the multiplication sequence matcher we\'re about to create\n  	// (we\'re skipping void and delete)\n  	readTypeOf = fallthrough;\n  })();\n\n  var readTypeof = readTypeOf;\n\n  var readLogicalOr, makeInfixSequenceMatcher;\n\n  makeInfixSequenceMatcher = function (symbol, fallthrough) {\n  	return function (parser) {\n  		var start, left, right;\n\n  		left = fallthrough(parser);\n  		if (!left) {\n  			return null;\n  		}\n\n  		// Loop to handle left-recursion in a case like `a * b * c` and produce\n  		// left association, i.e. `(a * b) * c`.  The matcher can\'t call itself\n  		// to parse `left` because that would be infinite regress.\n  		while (true) {\n  			start = parser.pos;\n\n  			parser.allowWhitespace();\n\n  			if (!parser.matchString(symbol)) {\n  				parser.pos = start;\n  				return left;\n  			}\n\n  			// special case - in operator must not be followed by [a-zA-Z_$0-9]\n  			if (symbol === "in" && /[a-zA-Z_$0-9]/.test(parser.remaining().charAt(0))) {\n  				parser.pos = start;\n  				return left;\n  			}\n\n  			parser.allowWhitespace();\n\n  			// right operand must also consist of only higher-precedence operators\n  			right = fallthrough(parser);\n  			if (!right) {\n  				parser.pos = start;\n  				return left;\n  			}\n\n  			left = {\n  				t: INFIX_OPERATOR,\n  				s: symbol,\n  				o: [left, right]\n  			};\n\n  			// Loop back around.  If we don\'t see another occurrence of the symbol,\n  			// we\'ll return left.\n  		}\n  	};\n  };\n\n  // create all infix sequence matchers, and return readLogicalOr\n  (function () {\n  	var i, len, matcher, infixOperators, fallthrough;\n\n  	// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n  	// Each sequence matcher will initially fall through to its higher precedence\n  	// neighbour, and only attempt to match if one of the higher precedence operators\n  	// (or, ultimately, a literal, reference, or bracketed expression) already matched\n  	infixOperators = "* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||".split(" ");\n\n  	// A typeof operator is higher precedence than multiplication\n  	fallthrough = readTypeof;\n  	for (i = 0, len = infixOperators.length; i < len; i += 1) {\n  		matcher = makeInfixSequenceMatcher(infixOperators[i], fallthrough);\n  		fallthrough = matcher;\n  	}\n\n  	// Logical OR is the fallthrough for the conditional matcher\n  	readLogicalOr = fallthrough;\n  })();\n\n  var expressions_readLogicalOr = readLogicalOr;\n\n  // The conditional operator is the lowest precedence operator, so we start here\n  var readConditional = getConditional;\n  function getConditional(parser) {\n  	var start, expression, ifTrue, ifFalse;\n\n  	expression = expressions_readLogicalOr(parser);\n  	if (!expression) {\n  		return null;\n  	}\n\n  	start = parser.pos;\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("?")) {\n  		parser.pos = start;\n  		return expression;\n  	}\n\n  	parser.allowWhitespace();\n\n  	ifTrue = converters_readExpression(parser);\n  	if (!ifTrue) {\n  		parser.error(expectedExpression);\n  	}\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString(":")) {\n  		parser.error("Expected \\":\\"");\n  	}\n\n  	parser.allowWhitespace();\n\n  	ifFalse = converters_readExpression(parser);\n  	if (!ifFalse) {\n  		parser.error(expectedExpression);\n  	}\n\n  	return {\n  		t: CONDITIONAL,\n  		o: [expression, ifTrue, ifFalse]\n  	};\n  }\n\n  var converters_readExpression = readExpression;\n  function readExpression(parser) {\n  	// The conditional operator is the lowest precedence operator (except yield,\n  	// assignment operators, and commas, none of which are supported), so we\n  	// start there. If it doesn\'t match, it \'falls through\' to progressively\n  	// higher precedence operators, until it eventually matches (or fails to\n  	// match) a \'primary\' - a literal or a reference. This way, the abstract syntax\n  	// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n  	return readConditional(parser);\n  }\n\n  var utils_flattenExpression = flattenExpression;\n\n  function flattenExpression(expression) {\n  	var refs;\n\n  	extractRefs(expression, refs = []);\n\n  	return {\n  		r: refs,\n  		s: stringify(expression)\n  	};\n\n  	function stringify(node) {\n  		switch (node.t) {\n  			case BOOLEAN_LITERAL:\n  			case GLOBAL:\n  			case NUMBER_LITERAL:\n  			case REGEXP_LITERAL:\n  				return node.v;\n\n  			case STRING_LITERAL:\n  				return JSON.stringify(String(node.v));\n\n  			case ARRAY_LITERAL:\n  				return "[" + (node.m ? node.m.map(stringify).join(",") : "") + "]";\n\n  			case OBJECT_LITERAL:\n  				return "{" + (node.m ? node.m.map(stringify).join(",") : "") + "}";\n\n  			case KEY_VALUE_PAIR:\n  				return node.k + ":" + stringify(node.v);\n\n  			case PREFIX_OPERATOR:\n  				return (node.s === "typeof" ? "typeof " : node.s) + stringify(node.o);\n\n  			case INFIX_OPERATOR:\n  				return stringify(node.o[0]) + (node.s.substr(0, 2) === "in" ? " " + node.s + " " : node.s) + stringify(node.o[1]);\n\n  			case INVOCATION:\n  				return stringify(node.x) + "(" + (node.o ? node.o.map(stringify).join(",") : "") + ")";\n\n  			case BRACKETED:\n  				return "(" + stringify(node.x) + ")";\n\n  			case MEMBER:\n  				return stringify(node.x) + stringify(node.r);\n\n  			case REFINEMENT:\n  				return node.n ? "." + node.n : "[" + stringify(node.x) + "]";\n\n  			case CONDITIONAL:\n  				return stringify(node.o[0]) + "?" + stringify(node.o[1]) + ":" + stringify(node.o[2]);\n\n  			case REFERENCE:\n  				return "_" + refs.indexOf(node.n);\n\n  			default:\n  				throw new Error("Expected legal JavaScript");\n  		}\n  	}\n  }\n\n  // TODO maybe refactor this?\n  function extractRefs(node, refs) {\n  	var i, list;\n\n  	if (node.t === REFERENCE) {\n  		if (refs.indexOf(node.n) === -1) {\n  			refs.unshift(node.n);\n  		}\n  	}\n\n  	list = node.o || node.m;\n  	if (list) {\n  		if (isObject(list)) {\n  			extractRefs(list, refs);\n  		} else {\n  			i = list.length;\n  			while (i--) {\n  				extractRefs(list[i], refs);\n  			}\n  		}\n  	}\n\n  	if (node.x) {\n  		extractRefs(node.x, refs);\n  	}\n\n  	if (node.r) {\n  		extractRefs(node.r, refs);\n  	}\n\n  	if (node.v) {\n  		extractRefs(node.v, refs);\n  	}\n  }\n\n  var utils_refineExpression = refineExpression;\n\n  var arrayMemberPattern = /^[0-9][1-9]*$/;\n  function refineExpression(expression, mustache) {\n  	var referenceExpression;\n\n  	if (expression) {\n  		while (expression.t === BRACKETED && expression.x) {\n  			expression = expression.x;\n  		}\n\n  		// special case - integers should be treated as array members references,\n  		// rather than as expressions in their own right\n  		if (expression.t === REFERENCE) {\n  			mustache.r = expression.n;\n  		} else {\n  			if (expression.t === NUMBER_LITERAL && arrayMemberPattern.test(expression.v)) {\n  				mustache.r = expression.v;\n  			} else if (referenceExpression = getReferenceExpression(expression)) {\n  				mustache.rx = referenceExpression;\n  			} else {\n  				mustache.x = utils_flattenExpression(expression);\n  			}\n  		}\n\n  		return mustache;\n  	}\n  }\n\n  // TODO refactor this! it\'s bewildering\n  function getReferenceExpression(expression) {\n  	var members = [],\n  	    refinement;\n\n  	while (expression.t === MEMBER && expression.r.t === REFINEMENT) {\n  		refinement = expression.r;\n\n  		if (refinement.x) {\n  			if (refinement.x.t === REFERENCE) {\n  				members.unshift(refinement.x);\n  			} else {\n  				members.unshift(utils_flattenExpression(refinement.x));\n  			}\n  		} else {\n  			members.unshift(refinement.n);\n  		}\n\n  		expression = expression.x;\n  	}\n\n  	if (expression.t !== REFERENCE) {\n  		return null;\n  	}\n\n  	return {\n  		r: expression.n,\n  		m: members\n  	};\n  }\n\n  var mustache_readTriple = readTriple;\n  function readTriple(parser, tag) {\n  	var expression = converters_readExpression(parser),\n  	    triple;\n\n  	if (!expression) {\n  		return null;\n  	}\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	triple = { t: TRIPLE };\n  	utils_refineExpression(expression, triple); // TODO handle this differently - it\'s mysterious\n\n  	return triple;\n  }\n\n  var mustache_readUnescaped = readUnescaped;\n  function readUnescaped(parser, tag) {\n  	var expression, triple;\n\n  	if (!parser.matchString("&")) {\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	expression = converters_readExpression(parser);\n\n  	if (!expression) {\n  		return null;\n  	}\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	triple = { t: TRIPLE };\n  	utils_refineExpression(expression, triple); // TODO handle this differently - it\'s mysterious\n\n  	return triple;\n  }\n\n  var mustache_readPartial = readPartial;\n  function readPartial(parser, tag) {\n  	var start, nameStart, expression, context, partial;\n\n  	start = parser.pos;\n\n  	if (!parser.matchString(">")) {\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n  	nameStart = parser.pos;\n\n  	// Partial names can include hyphens, so we can\'t use readExpression\n  	// blindly. Instead, we use the `relaxedNames` flag to indicate that\n  	// `foo-bar` should be read as a single name, rather than \'subtract\n  	// bar from foo\'\n  	parser.relaxedNames = true;\n  	expression = converters_readExpression(parser);\n  	parser.relaxedNames = false;\n\n  	parser.allowWhitespace();\n  	context = converters_readExpression(parser);\n  	parser.allowWhitespace();\n\n  	if (!expression) {\n  		return null;\n  	}\n\n  	partial = { t: PARTIAL };\n  	utils_refineExpression(expression, partial); // TODO...\n\n  	parser.allowWhitespace();\n\n  	// if we have another expression - e.g. `{{>foo bar}}` - then\n  	// we turn it into `{{#with bar}}{{>foo}}{{/with}}`\n  	if (context) {\n  		partial = {\n  			t: SECTION,\n  			n: SECTION_WITH,\n  			f: [partial]\n  		};\n\n  		utils_refineExpression(context, partial);\n  	}\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	return partial;\n  }\n\n  var readMustacheComment = readComment;\n  function readComment(parser, tag) {\n  	var index;\n\n  	if (!parser.matchString("!")) {\n  		return null;\n  	}\n\n  	index = parser.remaining().indexOf(tag.close);\n\n  	if (index !== -1) {\n  		parser.pos += index + tag.close.length;\n  		return { t: COMMENT };\n  	}\n  }\n\n  var converters_readExpressionOrReference = readExpressionOrReference;\n  function readExpressionOrReference(parser, expectedFollowers) {\n  	var start, expression, i;\n\n  	start = parser.pos;\n  	expression = converters_readExpression(parser);\n\n  	if (!expression) {\n  		return null;\n  	}\n\n  	for (i = 0; i < expectedFollowers.length; i += 1) {\n  		if (parser.remaining().substr(0, expectedFollowers[i].length) === expectedFollowers[i]) {\n  			return expression;\n  		}\n  	}\n\n  	parser.pos = start;\n  	return primary_readReference(parser);\n  }\n\n  var mustache_readInterpolator = readInterpolator;\n  function readInterpolator(parser, tag) {\n  	var start, expression, interpolator, err;\n\n  	start = parser.pos;\n\n  	// TODO would be good for perf if we could do away with the try-catch\n  	try {\n  		expression = converters_readExpressionOrReference(parser, [tag.close]);\n  	} catch (e) {\n  		err = e;\n  	}\n\n  	if (!expression) {\n  		if (parser.str.charAt(start) === "!") {\n  			// special case - comment\n  			parser.pos = start;\n  			return null;\n  		}\n\n  		if (err) {\n  			throw err;\n  		}\n  	}\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\' after reference");\n\n  		if (!expression) {\n  			// special case - comment\n  			if (parser.nextChar() === "!") {\n  				return null;\n  			}\n\n  			parser.error("Expected expression or legal reference");\n  		}\n  	}\n\n  	interpolator = { t: INTERPOLATOR };\n  	utils_refineExpression(expression, interpolator); // TODO handle this differently - it\'s mysterious\n\n  	return interpolator;\n  }\n\n  var mustache_readYielder = readYielder;\n  var yieldPattern = /^yield\\s*/;\n  function readYielder(parser, tag) {\n  	var start, name, yielder;\n\n  	if (!parser.matchPattern(yieldPattern)) {\n  		return null;\n  	}\n\n  	start = parser.pos;\n  	name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/);\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("expected legal partial name");\n  	}\n\n  	yielder = { t: YIELDER };\n\n  	if (name) {\n  		yielder.n = name;\n  	}\n\n  	return yielder;\n  }\n\n  var section_readClosing = readClosing;\n  function readClosing(parser, tag) {\n  	var start, remaining, index, closing;\n\n  	start = parser.pos;\n\n  	if (!parser.matchString(tag.open)) {\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("/")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	remaining = parser.remaining();\n  	index = remaining.indexOf(tag.close);\n\n  	if (index !== -1) {\n  		closing = {\n  			t: CLOSING,\n  			r: remaining.substr(0, index).split(" ")[0]\n  		};\n\n  		parser.pos += index;\n\n  		if (!parser.matchString(tag.close)) {\n  			parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  		}\n\n  		return closing;\n  	}\n\n  	parser.pos = start;\n  	return null;\n  }\n\n  var section_readElse = section_readElse__readElse;\n  var section_readElse__elsePattern = /^\\s*else\\s*/;\n  function section_readElse__readElse(parser, tag) {\n  	var start = parser.pos;\n\n  	if (!parser.matchString(tag.open)) {\n  		return null;\n  	}\n\n  	if (!parser.matchPattern(section_readElse__elsePattern)) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	return {\n  		t: ELSE\n  	};\n  }\n\n  var readElseIf = readElseIf__readElse;\n  var readElseIf__elsePattern = /^\\s*elseif\\s+/;\n  function readElseIf__readElse(parser, tag) {\n  	var start = parser.pos,\n  	    expression;\n\n  	if (!parser.matchString(tag.open)) {\n  		return null;\n  	}\n\n  	if (!parser.matchPattern(readElseIf__elsePattern)) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	expression = converters_readExpression(parser);\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	return {\n  		t: ELSEIF,\n  		x: expression\n  	};\n  }\n\n  var handlebarsBlockCodes = {\n  	each: SECTION_EACH,\n  	"if": SECTION_IF,\n  	"if-with": SECTION_IF_WITH,\n  	"with": SECTION_WITH,\n  	unless: SECTION_UNLESS\n  };\n\n  var mustache_readSection = readSection;\n\n  var indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n      keyIndexRefPattern = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n      handlebarsBlockPattern = new RegExp("^(" + Object.keys(handlebarsBlockCodes).join("|") + ")\\\\b");\n  function readSection(parser, tag) {\n  	var start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose;\n\n  	start = parser.pos;\n\n  	if (parser.matchString("^")) {\n  		section = { t: SECTION, f: [], n: SECTION_UNLESS };\n  	} else if (parser.matchString("#")) {\n  		section = { t: SECTION, f: [] };\n\n  		if (parser.matchString("partial")) {\n  			parser.pos = start - parser.standardDelimiters[0].length;\n  			parser.error("Partial definitions can only be at the top level of the template, or immediately inside components");\n  		}\n\n  		if (block = parser.matchPattern(handlebarsBlockPattern)) {\n  			expectedClose = block;\n  			section.n = handlebarsBlockCodes[block];\n  		}\n  	} else {\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	expression = converters_readExpression(parser);\n\n  	if (!expression) {\n  		parser.error("Expected expression");\n  	}\n\n  	// optional index and key references\n  	if (i = parser.matchPattern(indexRefPattern)) {\n  		var extra = undefined;\n\n  		if (extra = parser.matchPattern(keyIndexRefPattern)) {\n  			section.i = i + "," + extra;\n  		} else {\n  			section.i = i;\n  		}\n  	}\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString(tag.close)) {\n  		parser.error("Expected closing delimiter \'" + tag.close + "\'");\n  	}\n\n  	parser.sectionDepth += 1;\n  	children = section.f;\n\n  	conditions = [];\n\n  	do {\n  		if (child = section_readClosing(parser, tag)) {\n  			if (expectedClose && child.r !== expectedClose) {\n  				parser.error("Expected " + tag.open + "/" + expectedClose + "" + tag.close);\n  			}\n\n  			parser.sectionDepth -= 1;\n  			closed = true;\n  		} else if (child = readElseIf(parser, tag)) {\n  			if (section.n === SECTION_UNLESS) {\n  				parser.error("{{else}} not allowed in {{#unless}}");\n  			}\n\n  			if (hasElse) {\n  				parser.error("illegal {{elseif...}} after {{else}}");\n  			}\n\n  			if (!unlessBlock) {\n  				unlessBlock = createUnlessBlock(expression, section.n);\n  			}\n\n  			unlessBlock.f.push({\n  				t: SECTION,\n  				n: SECTION_IF,\n  				x: utils_flattenExpression(mustache_readSection__combine(conditions.concat(child.x))),\n  				f: children = []\n  			});\n\n  			conditions.push(invert(child.x));\n  		} else if (child = section_readElse(parser, tag)) {\n  			if (section.n === SECTION_UNLESS) {\n  				parser.error("{{else}} not allowed in {{#unless}}");\n  			}\n\n  			if (hasElse) {\n  				parser.error("there can only be one {{else}} block, at the end of a section");\n  			}\n\n  			hasElse = true;\n\n  			// use an unless block if there\'s no elseif\n  			if (!unlessBlock) {\n  				unlessBlock = createUnlessBlock(expression, section.n);\n  				children = unlessBlock.f;\n  			} else {\n  				unlessBlock.f.push({\n  					t: SECTION,\n  					n: SECTION_IF,\n  					x: utils_flattenExpression(mustache_readSection__combine(conditions)),\n  					f: children = []\n  				});\n  			}\n  		} else {\n  			child = parser.read(READERS);\n\n  			if (!child) {\n  				break;\n  			}\n\n  			children.push(child);\n  		}\n  	} while (!closed);\n\n  	if (unlessBlock) {\n  		// special case - `with` should become `if-with` (TODO is this right?\n  		// seems to me that `with` ought to behave consistently, regardless\n  		// of the presence/absence of `else`. In other words should always\n  		// be `if-with`\n  		if (section.n === SECTION_WITH) {\n  			section.n = SECTION_IF_WITH;\n  		}\n\n  		section.l = unlessBlock;\n  	}\n\n  	utils_refineExpression(expression, section);\n\n  	// TODO if a section is empty it should be discarded. Don\'t do\n  	// that here though - we need to clean everything up first, as\n  	// it may contain removeable whitespace. As a temporary measure,\n  	// to pass the existing tests, remove empty `f` arrays\n  	if (!section.f.length) {\n  		delete section.f;\n  	}\n\n  	return section;\n  }\n\n  function createUnlessBlock(expression, sectionType) {\n  	var unlessBlock;\n\n  	if (sectionType === SECTION_WITH) {\n  		// special case - a `{{#with foo}}` section will render if `foo` is\n  		// truthy, so the `{{else}}` section needs to render if `foo` is falsy,\n  		// rather than adhering to the normal `{{#unless foo}}` logic (which\n  		// treats empty arrays/objects as falsy)\n  		unlessBlock = {\n  			t: SECTION,\n  			n: SECTION_IF,\n  			f: []\n  		};\n\n  		utils_refineExpression(invert(expression), unlessBlock);\n  	} else {\n  		unlessBlock = {\n  			t: SECTION,\n  			n: SECTION_UNLESS,\n  			f: []\n  		};\n\n  		utils_refineExpression(expression, unlessBlock);\n  	}\n\n  	return unlessBlock;\n  }\n\n  function invert(expression) {\n  	if (expression.t === PREFIX_OPERATOR && expression.s === "!") {\n  		return expression.o;\n  	}\n\n  	return {\n  		t: PREFIX_OPERATOR,\n  		s: "!",\n  		o: parensIfNecessary(expression)\n  	};\n  }\n\n  function mustache_readSection__combine(expressions) {\n  	if (expressions.length === 1) {\n  		return expressions[0];\n  	}\n\n  	return {\n  		t: INFIX_OPERATOR,\n  		s: "&&",\n  		o: [parensIfNecessary(expressions[0]), parensIfNecessary(mustache_readSection__combine(expressions.slice(1)))]\n  	};\n  }\n\n  function parensIfNecessary(expression) {\n  	// TODO only wrap if necessary\n  	return {\n  		t: BRACKETED,\n  		x: expression\n  	};\n  }\n\n  var converters_readHtmlComment = readHtmlComment;\n  var OPEN_COMMENT = "<!--",\n      CLOSE_COMMENT = "-->";\n  function readHtmlComment(parser) {\n  	var start, content, remaining, endIndex, comment;\n\n  	start = parser.pos;\n\n  	if (!parser.matchString(OPEN_COMMENT)) {\n  		return null;\n  	}\n\n  	remaining = parser.remaining();\n  	endIndex = remaining.indexOf(CLOSE_COMMENT);\n\n  	if (endIndex === -1) {\n  		parser.error("Illegal HTML - expected closing comment sequence (\'-->\')");\n  	}\n\n  	content = remaining.substr(0, endIndex);\n  	parser.pos += endIndex + 3;\n\n  	comment = {\n  		t: COMMENT,\n  		c: content\n  	};\n\n  	if (parser.includeLinePositions) {\n  		comment.p = parser.getLinePos(start);\n  	}\n\n  	return comment;\n  }\n\n  var booleanAttributes, voidElementNames, htmlEntities, controlCharacters, entityPattern, lessThan, greaterThan, amp;\n\n  // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n  booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\n  voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\n\n  htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 };\n  controlCharacters = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376];\n  entityPattern = new RegExp("&(#?(?:x[\\\\w\\\\d]+|\\\\d+|" + Object.keys(htmlEntities).join("|") + "));?", "g");\n\n  function decodeCharacterReferences(html) {\n  	return html.replace(entityPattern, function (match, entity) {\n  		var code;\n\n  		// Handle named entities\n  		if (entity[0] !== "#") {\n  			code = htmlEntities[entity];\n  		} else if (entity[1] === "x") {\n  			code = parseInt(entity.substring(2), 16);\n  		} else {\n  			code = parseInt(entity.substring(1), 10);\n  		}\n\n  		if (!code) {\n  			return match;\n  		}\n\n  		return String.fromCharCode(validateCode(code));\n  	});\n  }\n\n  // some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n  // code points with alternatives in some cases - since we\'re bypassing that mechanism, we need\n  // to replace them ourselves\n  //\n  // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n  function validateCode(code) {\n  	if (!code) {\n  		return 65533;\n  	}\n\n  	// line feed becomes generic whitespace\n  	if (code === 10) {\n  		return 32;\n  	}\n\n  	// ASCII range. (Why someone would use HTML entities for ASCII characters I don\'t know, but...)\n  	if (code < 128) {\n  		return code;\n  	}\n\n  	// code points 128-159 are dealt with leniently by browsers, but they\'re incorrect. We need\n  	// to correct the mistake or we\'ll end up with missing € signs and so on\n  	if (code <= 159) {\n  		return controlCharacters[code - 128];\n  	}\n\n  	// basic multilingual plane\n  	if (code < 55296) {\n  		return code;\n  	}\n\n  	// UTF-16 surrogate halves\n  	if (code <= 57343) {\n  		return 65533;\n  	}\n\n  	// rest of the basic multilingual plane\n  	if (code <= 65535) {\n  		return code;\n  	}\n\n  	return 65533;\n  }\n\n  lessThan = /</g;\n  greaterThan = />/g;\n  amp = /&/g;\n\n  function escapeHtml(str) {\n  	return str.replace(amp, "&amp;").replace(lessThan, "&lt;").replace(greaterThan, "&gt;");\n  }\n\n  var leadingLinebreak = /^\\s*\\r?\\n/,\n      trailingLinebreak = /\\r?\\n\\s*$/;\n\n  var stripStandalones = function (items) {\n  	var i, current, backOne, backTwo, lastSectionItem;\n\n  	for (i = 1; i < items.length; i += 1) {\n  		current = items[i];\n  		backOne = items[i - 1];\n  		backTwo = items[i - 2];\n\n  		// if we\'re at the end of a [text][comment][text] sequence...\n  		if (isString(current) && isComment(backOne) && isString(backTwo)) {\n\n  			// ... and the comment is a standalone (i.e. line breaks either side)...\n  			if (trailingLinebreak.test(backTwo) && leadingLinebreak.test(current)) {\n\n  				// ... then we want to remove the whitespace after the first line break\n  				items[i - 2] = backTwo.replace(trailingLinebreak, "\\n");\n\n  				// and the leading line break of the second text token\n  				items[i] = current.replace(leadingLinebreak, "");\n  			}\n  		}\n\n  		// if the current item is a section, and it is preceded by a linebreak, and\n  		// its first item is a linebreak...\n  		if (isSection(current) && isString(backOne)) {\n  			if (trailingLinebreak.test(backOne) && isString(current.f[0]) && leadingLinebreak.test(current.f[0])) {\n  				items[i - 1] = backOne.replace(trailingLinebreak, "\\n");\n  				current.f[0] = current.f[0].replace(leadingLinebreak, "");\n  			}\n  		}\n\n  		// if the last item was a section, and it is followed by a linebreak, and\n  		// its last item is a linebreak...\n  		if (isString(current) && isSection(backOne)) {\n  			lastSectionItem = lastItem(backOne.f);\n\n  			if (isString(lastSectionItem) && trailingLinebreak.test(lastSectionItem) && leadingLinebreak.test(current)) {\n  				backOne.f[backOne.f.length - 1] = lastSectionItem.replace(trailingLinebreak, "\\n");\n  				items[i] = current.replace(leadingLinebreak, "");\n  			}\n  		}\n  	}\n\n  	return items;\n  };\n\n  function isString(item) {\n  	return typeof item === "string";\n  }\n\n  function isComment(item) {\n  	return item.t === COMMENT || item.t === DELIMCHANGE;\n  }\n\n  function isSection(item) {\n  	return (item.t === SECTION || item.t === INVERTED) && item.f;\n  }\n\n  var trimWhitespace__leadingWhitespace = /^[ \\t\\f\\r\\n]+/,\n      trimWhitespace__trailingWhitespace = /[ \\t\\f\\r\\n]+$/;\n\n  var trimWhitespace = function (items, leading, trailing) {\n  	var item;\n\n  	if (leading) {\n  		item = items[0];\n  		if (typeof item === "string") {\n  			item = item.replace(trimWhitespace__leadingWhitespace, "");\n\n  			if (!item) {\n  				items.shift();\n  			} else {\n  				items[0] = item;\n  			}\n  		}\n  	}\n\n  	if (trailing) {\n  		item = lastItem(items);\n  		if (typeof item === "string") {\n  			item = item.replace(trimWhitespace__trailingWhitespace, "");\n\n  			if (!item) {\n  				items.pop();\n  			} else {\n  				items[items.length - 1] = item;\n  			}\n  		}\n  	}\n  };\n\n  var utils_cleanup = cleanup;\n  var contiguousWhitespace = /[ \\t\\f\\r\\n]+/g;\n  var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;\n  var utils_cleanup__leadingWhitespace = /^\\s+/;\n  var utils_cleanup__trailingWhitespace = /\\s+$/;\n  function cleanup(items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace) {\n  	var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, key;\n\n  	// First pass - remove standalones and comments etc\n  	stripStandalones(items);\n\n  	i = items.length;\n  	while (i--) {\n  		item = items[i];\n\n  		// Remove delimiter changes, unsafe elements etc\n  		if (item.exclude) {\n  			items.splice(i, 1);\n  		}\n\n  		// Remove comments, unless we want to keep them\n  		else if (stripComments && item.t === COMMENT) {\n  			items.splice(i, 1);\n  		}\n  	}\n\n  	// If necessary, remove leading and trailing whitespace\n  	trimWhitespace(items, removeLeadingWhitespace, removeTrailingWhitespace);\n\n  	i = items.length;\n  	while (i--) {\n  		item = items[i];\n\n  		// Recurse\n  		if (item.f) {\n  			preserveWhitespaceInsideFragment = preserveWhitespace || item.t === ELEMENT && preserveWhitespaceElements.test(item.e);\n\n  			if (!preserveWhitespaceInsideFragment) {\n  				previousItem = items[i - 1];\n  				nextItem = items[i + 1];\n\n  				// if the previous item was a text item with trailing whitespace,\n  				// remove leading whitespace inside the fragment\n  				if (!previousItem || typeof previousItem === "string" && utils_cleanup__trailingWhitespace.test(previousItem)) {\n  					removeLeadingWhitespaceInsideFragment = true;\n  				}\n\n  				// and vice versa\n  				if (!nextItem || typeof nextItem === "string" && utils_cleanup__leadingWhitespace.test(nextItem)) {\n  					removeTrailingWhitespaceInsideFragment = true;\n  				}\n  			}\n\n  			cleanup(item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  		}\n\n  		// Split if-else blocks into two (an if, and an unless)\n  		if (item.l) {\n  			cleanup(item.l.f, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n\n  			items.splice(i + 1, 0, item.l);\n  			delete item.l; // TODO would be nice if there was a way around this\n  		}\n\n  		// Clean up element attributes\n  		if (item.a) {\n  			for (key in item.a) {\n  				if (item.a.hasOwnProperty(key) && typeof item.a[key] !== "string") {\n  					cleanup(item.a[key], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  				}\n  			}\n  		}\n\n  		// Clean up conditional attributes\n  		if (item.m) {\n  			cleanup(item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  		}\n\n  		// Clean up event handlers\n  		if (item.v) {\n  			for (key in item.v) {\n  				if (item.v.hasOwnProperty(key)) {\n  					// clean up names\n  					if (isArray(item.v[key].n)) {\n  						cleanup(item.v[key].n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  					}\n\n  					// clean up params\n  					if (isArray(item.v[key].d)) {\n  						cleanup(item.v[key].d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  					}\n  				}\n  			}\n  		}\n  	}\n\n  	// final pass - fuse text nodes together\n  	i = items.length;\n  	while (i--) {\n  		if (typeof items[i] === "string") {\n  			if (typeof items[i + 1] === "string") {\n  				items[i] = items[i] + items[i + 1];\n  				items.splice(i + 1, 1);\n  			}\n\n  			if (!preserveWhitespace) {\n  				items[i] = items[i].replace(contiguousWhitespace, " ");\n  			}\n\n  			if (items[i] === "") {\n  				items.splice(i, 1);\n  			}\n  		}\n  	}\n  }\n\n  var element_readClosingTag = readClosingTag;\n  var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n  function readClosingTag(parser) {\n  	var start, tag;\n\n  	start = parser.pos;\n\n  	// are we looking at a closing tag?\n  	if (!parser.matchString("</")) {\n  		return null;\n  	}\n\n  	if (tag = parser.matchPattern(closingTagPattern)) {\n  		if (parser.inside && tag !== parser.inside) {\n  			parser.pos = start;\n  			return null;\n  		}\n\n  		return {\n  			t: CLOSING_TAG,\n  			e: tag\n  		};\n  	}\n\n  	// We have an illegal closing tag, report it\n  	parser.pos -= 2;\n  	parser.error("Illegal closing tag");\n  }\n\n  var getLowestIndex = function (haystack, needles) {\n  	var i, index, lowest;\n\n  	i = needles.length;\n  	while (i--) {\n  		index = haystack.indexOf(needles[i]);\n\n  		// short circuit\n  		if (!index) {\n  			return 0;\n  		}\n\n  		if (index === -1) {\n  			continue;\n  		}\n\n  		if (!lowest || index < lowest) {\n  			lowest = index;\n  		}\n  	}\n\n  	return lowest || -1;\n  };\n\n  var element_readAttribute = readAttribute;\n\n  var attributeNamePattern = /^[^\\s"\'>\\/=]+/,\n      unquotedAttributeValueTextPattern = /^[^\\s"\'=<>`]+/;\n  function readAttribute(parser) {\n  	var attr, name, value;\n\n  	parser.allowWhitespace();\n\n  	name = parser.matchPattern(attributeNamePattern);\n  	if (!name) {\n  		return null;\n  	}\n\n  	attr = { name: name };\n\n  	value = readAttributeValue(parser);\n  	if (value != null) {\n  		// not null/undefined\n  		attr.value = value;\n  	}\n\n  	return attr;\n  }\n\n  function readAttributeValue(parser) {\n  	var start, valueStart, startDepth, value;\n\n  	start = parser.pos;\n\n  	// next character must be `=`, `/`, `>` or whitespace\n  	if (!/[=\\/>\\s]/.test(parser.nextChar())) {\n  		parser.error("Expected `=`, `/`, `>` or whitespace");\n  	}\n\n  	parser.allowWhitespace();\n\n  	if (!parser.matchString("=")) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	parser.allowWhitespace();\n\n  	valueStart = parser.pos;\n  	startDepth = parser.sectionDepth;\n\n  	value = readQuotedAttributeValue(parser, "\'") || readQuotedAttributeValue(parser, "\\"") || readUnquotedAttributeValue(parser);\n\n  	if (value === null) {\n  		parser.error("Expected valid attribute value");\n  	}\n\n  	if (parser.sectionDepth !== startDepth) {\n  		parser.pos = valueStart;\n  		parser.error("An attribute value must contain as many opening section tags as closing section tags");\n  	}\n\n  	if (!value.length) {\n  		return "";\n  	}\n\n  	if (value.length === 1 && typeof value[0] === "string") {\n  		return decodeCharacterReferences(value[0]);\n  	}\n\n  	return value;\n  }\n\n  function readUnquotedAttributeValueToken(parser) {\n  	var start, text, haystack, needles, index;\n\n  	start = parser.pos;\n\n  	text = parser.matchPattern(unquotedAttributeValueTextPattern);\n\n  	if (!text) {\n  		return null;\n  	}\n\n  	haystack = text;\n  	needles = parser.tags.map(function (t) {\n  		return t.open;\n  	}); // TODO refactor... we do this in readText.js as well\n\n  	if ((index = getLowestIndex(haystack, needles)) !== -1) {\n  		text = text.substr(0, index);\n  		parser.pos = start + text.length;\n  	}\n\n  	return text;\n  }\n\n  function readUnquotedAttributeValue(parser) {\n  	var tokens, token;\n\n  	parser.inAttribute = true;\n\n  	tokens = [];\n\n  	token = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  	while (token !== null) {\n  		tokens.push(token);\n  		token = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  	}\n\n  	if (!tokens.length) {\n  		return null;\n  	}\n\n  	parser.inAttribute = false;\n  	return tokens;\n  }\n\n  function readQuotedAttributeValue(parser, quoteMark) {\n  	var start, tokens, token;\n\n  	start = parser.pos;\n\n  	if (!parser.matchString(quoteMark)) {\n  		return null;\n  	}\n\n  	parser.inAttribute = quoteMark;\n\n  	tokens = [];\n\n  	token = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  	while (token !== null) {\n  		tokens.push(token);\n  		token = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  	}\n\n  	if (!parser.matchString(quoteMark)) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	parser.inAttribute = false;\n\n  	return tokens;\n  }\n\n  function readQuotedStringToken(parser, quoteMark) {\n  	var start, index, haystack, needles;\n\n  	start = parser.pos;\n  	haystack = parser.remaining();\n\n  	needles = parser.tags.map(function (t) {\n  		return t.open;\n  	}); // TODO refactor... we do this in readText.js as well\n  	needles.push(quoteMark);\n\n  	index = getLowestIndex(haystack, needles);\n\n  	if (index === -1) {\n  		parser.error("Quoted attribute value must have a closing quote");\n  	}\n\n  	if (!index) {\n  		return null;\n  	}\n\n  	parser.pos += index;\n  	return haystack.substr(0, index);\n  }\n\n  var JsonParser, specials, specialsPattern, parseJSON__numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;\n\n  specials = {\n  	"true": true,\n  	"false": false,\n  	undefined: undefined,\n  	"null": null\n  };\n\n  specialsPattern = new RegExp("^(?:" + Object.keys(specials).join("|") + ")");\n  parseJSON__numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n  placeholderPattern = /\\$\\{([^\\}]+)\\}/g;\n  placeholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\n  onlyWhitespace = /^\\s*$/;\n\n  JsonParser = parse_Parser.extend({\n  	init: function (str, options) {\n  		this.values = options.values;\n  		this.allowWhitespace();\n  	},\n\n  	postProcess: function (result) {\n  		if (result.length !== 1 || !onlyWhitespace.test(this.leftover)) {\n  			return null;\n  		}\n\n  		return { value: result[0].v };\n  	},\n\n  	converters: [function getPlaceholder(parser) {\n  		var placeholder;\n\n  		if (!parser.values) {\n  			return null;\n  		}\n\n  		placeholder = parser.matchPattern(placeholderAtStartPattern);\n\n  		if (placeholder && parser.values.hasOwnProperty(placeholder)) {\n  			return { v: parser.values[placeholder] };\n  		}\n  	}, function getSpecial(parser) {\n  		var special;\n\n  		if (special = parser.matchPattern(specialsPattern)) {\n  			return { v: specials[special] };\n  		}\n  	}, function getNumber(parser) {\n  		var number;\n\n  		if (number = parser.matchPattern(parseJSON__numberPattern)) {\n  			return { v: +number };\n  		}\n  	}, function getString(parser) {\n  		var stringLiteral = readStringLiteral(parser),\n  		    values;\n\n  		if (stringLiteral && (values = parser.values)) {\n  			return {\n  				v: stringLiteral.v.replace(placeholderPattern, function (match, $1) {\n  					return $1 in values ? values[$1] : $1;\n  				})\n  			};\n  		}\n\n  		return stringLiteral;\n  	}, function getObject(parser) {\n  		var result, pair;\n\n  		if (!parser.matchString("{")) {\n  			return null;\n  		}\n\n  		result = {};\n\n  		parser.allowWhitespace();\n\n  		if (parser.matchString("}")) {\n  			return { v: result };\n  		}\n\n  		while (pair = getKeyValuePair(parser)) {\n  			result[pair.key] = pair.value;\n\n  			parser.allowWhitespace();\n\n  			if (parser.matchString("}")) {\n  				return { v: result };\n  			}\n\n  			if (!parser.matchString(",")) {\n  				return null;\n  			}\n  		}\n\n  		return null;\n  	}, function getArray(parser) {\n  		var result, valueToken;\n\n  		if (!parser.matchString("[")) {\n  			return null;\n  		}\n\n  		result = [];\n\n  		parser.allowWhitespace();\n\n  		if (parser.matchString("]")) {\n  			return { v: result };\n  		}\n\n  		while (valueToken = parser.read()) {\n  			result.push(valueToken.v);\n\n  			parser.allowWhitespace();\n\n  			if (parser.matchString("]")) {\n  				return { v: result };\n  			}\n\n  			if (!parser.matchString(",")) {\n  				return null;\n  			}\n\n  			parser.allowWhitespace();\n  		}\n\n  		return null;\n  	}]\n  });\n\n  function getKeyValuePair(parser) {\n  	var key, valueToken, pair;\n\n  	parser.allowWhitespace();\n\n  	key = shared_readKey(parser);\n\n  	if (!key) {\n  		return null;\n  	}\n\n  	pair = { key: key };\n\n  	parser.allowWhitespace();\n  	if (!parser.matchString(":")) {\n  		return null;\n  	}\n  	parser.allowWhitespace();\n\n  	valueToken = parser.read();\n  	if (!valueToken) {\n  		return null;\n  	}\n\n  	pair.value = valueToken.v;\n\n  	return pair;\n  }\n\n  var parseJSON = function (str, values) {\n  	var parser = new JsonParser(str, {\n  		values: values\n  	});\n\n  	return parser.result;\n  };\n\n  // TODO clean this up, it\'s shocking\n  var element_processDirective = processDirective;\n  var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\\(/,\n      methodCallExcessPattern = /\\)\\s*$/,\n      ExpressionParser;\n\n  ExpressionParser = parse_Parser.extend({\n  	converters: [converters_readExpression]\n  });\n  function processDirective(tokens, parentParser) {\n  	var result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;\n\n  	if (typeof tokens === "string") {\n  		if (match = methodCallPattern.exec(tokens)) {\n  			var end = tokens.lastIndexOf(")");\n\n  			// check for invalid method calls\n  			if (!methodCallExcessPattern.test(tokens)) {\n  				parentParser.error("Invalid input after method call expression \'" + tokens.slice(end + 1) + "\'");\n  			}\n\n  			result = { m: match[1] };\n  			args = "[" + tokens.slice(result.m.length + 1, end) + "]";\n\n  			parser = new ExpressionParser(args);\n  			result.a = utils_flattenExpression(parser.result[0]);\n\n  			return result;\n  		}\n\n  		if (tokens.indexOf(":") === -1) {\n  			return tokens.trim();\n  		}\n\n  		tokens = [tokens];\n  	}\n\n  	result = {};\n\n  	directiveName = [];\n  	directiveArgs = [];\n\n  	if (tokens) {\n  		while (tokens.length) {\n  			token = tokens.shift();\n\n  			if (typeof token === "string") {\n  				colonIndex = token.indexOf(":");\n\n  				if (colonIndex === -1) {\n  					directiveName.push(token);\n  				} else {\n\n  					// is the colon the first character?\n  					if (colonIndex) {\n  						// no\n  						directiveName.push(token.substr(0, colonIndex));\n  					}\n\n  					// if there is anything after the colon in this token, treat\n  					// it as the first token of the directiveArgs fragment\n  					if (token.length > colonIndex + 1) {\n  						directiveArgs[0] = token.substring(colonIndex + 1);\n  					}\n\n  					break;\n  				}\n  			} else {\n  				directiveName.push(token);\n  			}\n  		}\n\n  		directiveArgs = directiveArgs.concat(tokens);\n  	}\n\n  	if (!directiveName.length) {\n  		result = "";\n  	} else if (directiveArgs.length || typeof directiveName !== "string") {\n  		result = {\n  			// TODO is this really necessary? just use the array\n  			n: directiveName.length === 1 && typeof directiveName[0] === "string" ? directiveName[0] : directiveName\n  		};\n\n  		if (directiveArgs.length === 1 && typeof directiveArgs[0] === "string") {\n  			parsed = parseJSON("[" + directiveArgs[0] + "]");\n  			result.a = parsed ? parsed.value : directiveArgs[0].trim();\n  		} else {\n  			result.d = directiveArgs;\n  		}\n  	} else {\n  		result = directiveName;\n  	}\n\n  	return result;\n  }\n\n  var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/,\n      validTagNameFollower = /^[\\s\\n\\/>]/,\n      onPattern = /^on/,\n      proxyEventPattern = /^on-([a-zA-Z\\\\*\\\\.$_][a-zA-Z\\\\*\\\\.$_0-9\\-]+)$/,\n      reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,\n      directives = { "intro-outro": "t0", intro: "t1", outro: "t2", decorator: "o" },\n      exclude = { exclude: true },\n      disallowedContents;\n\n  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\n  disallowedContents = {\n  	li: ["li"],\n  	dt: ["dt", "dd"],\n  	dd: ["dt", "dd"],\n  	p: "address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(" "),\n  	rt: ["rt", "rp"],\n  	rp: ["rt", "rp"],\n  	optgroup: ["optgroup"],\n  	option: ["option", "optgroup"],\n  	thead: ["tbody", "tfoot"],\n  	tbody: ["tbody", "tfoot"],\n  	tfoot: ["tbody"],\n  	tr: ["tr", "tbody"],\n  	td: ["td", "th", "tr"],\n  	th: ["td", "th", "tr"]\n  };\n\n  var converters_readElement = readElement;\n\n  function readElement(parser) {\n  	var start, element, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, partials, hasPartials, child, closed, pos, remaining, closingTag;\n\n  	start = parser.pos;\n\n  	if (parser.inside || parser.inAttribute) {\n  		return null;\n  	}\n\n  	if (!parser.matchString("<")) {\n  		return null;\n  	}\n\n  	// if this is a closing tag, abort straight away\n  	if (parser.nextChar() === "/") {\n  		return null;\n  	}\n\n  	element = {};\n  	if (parser.includeLinePositions) {\n  		element.p = parser.getLinePos(start);\n  	}\n\n  	if (parser.matchString("!")) {\n  		element.t = DOCTYPE;\n  		if (!parser.matchPattern(/^doctype/i)) {\n  			parser.error("Expected DOCTYPE declaration");\n  		}\n\n  		element.a = parser.matchPattern(/^(.+?)>/);\n  		return element;\n  	}\n\n  	element.t = ELEMENT;\n\n  	// element name\n  	element.e = parser.matchPattern(tagNamePattern);\n  	if (!element.e) {\n  		return null;\n  	}\n\n  	// next character must be whitespace, closing solidus or \'>\'\n  	if (!validTagNameFollower.test(parser.nextChar())) {\n  		parser.error("Illegal tag name");\n  	}\n\n  	addProxyEvent = function (name, directive) {\n  		var directiveName = directive.n || directive;\n\n  		if (reservedEventNames.test(directiveName)) {\n  			parser.pos -= directiveName.length;\n  			parser.error("Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)");\n  		}\n\n  		element.v[name] = directive;\n  	};\n\n  	parser.allowWhitespace();\n\n  	// directives and attributes\n  	while (attribute = converters_readMustache(parser) || element_readAttribute(parser)) {\n  		// regular attributes\n  		if (attribute.name) {\n  			// intro, outro, decorator\n  			if (directiveName = directives[attribute.name]) {\n  				element[directiveName] = element_processDirective(attribute.value, parser);\n  			}\n\n  			// on-click etc\n  			else if (match = proxyEventPattern.exec(attribute.name)) {\n  				if (!element.v) element.v = {};\n  				directive = element_processDirective(attribute.value, parser);\n  				addProxyEvent(match[1], directive);\n  			} else {\n  				if (!parser.sanitizeEventAttributes || !onPattern.test(attribute.name)) {\n  					if (!element.a) element.a = {};\n  					element.a[attribute.name] = attribute.value || (attribute.value === "" ? "" : 0);\n  				}\n  			}\n  		}\n\n  		// {{#if foo}}class=\'foo\'{{/if}}\n  		else {\n  			if (!element.m) element.m = [];\n  			element.m.push(attribute);\n  		}\n\n  		parser.allowWhitespace();\n  	}\n\n  	// allow whitespace before closing solidus\n  	parser.allowWhitespace();\n\n  	// self-closing solidus?\n  	if (parser.matchString("/")) {\n  		selfClosing = true;\n  	}\n\n  	// closing angle bracket\n  	if (!parser.matchString(">")) {\n  		return null;\n  	}\n\n  	var lowerCaseName = element.e.toLowerCase();\n  	var preserveWhitespace = parser.preserveWhitespace;\n\n  	if (!selfClosing && !voidElementNames.test(element.e)) {\n  		parser.elementStack.push(lowerCaseName);\n\n  		// Special case - if we open a script element, further tags should\n  		// be ignored unless they\'re a closing script element\n  		if (lowerCaseName === "script" || lowerCaseName === "style") {\n  			parser.inside = lowerCaseName;\n  		}\n\n  		children = [];\n  		partials = create(null);\n\n  		do {\n  			pos = parser.pos;\n  			remaining = parser.remaining();\n\n  			// if for example we\'re in an <li> element, and we see another\n  			// <li> tag, close the first so they become siblings\n  			if (!canContain(lowerCaseName, remaining)) {\n  				closed = true;\n  			}\n\n  			// closing tag\n  			else if (closingTag = element_readClosingTag(parser)) {\n  				closed = true;\n\n  				var closingTagName = closingTag.e.toLowerCase();\n\n  				// if this *isn\'t* the closing tag for the current element...\n  				if (closingTagName !== lowerCaseName) {\n  					// rewind parser\n  					parser.pos = pos;\n\n  					// if it doesn\'t close a parent tag, error\n  					if (! ~parser.elementStack.indexOf(closingTagName)) {\n  						var errorMessage = "Unexpected closing tag";\n\n  						// add additional help for void elements, since component names\n  						// might clash with them\n  						if (voidElementNames.test(closingTagName)) {\n  							errorMessage += " (<" + closingTagName + "> is a void element - it cannot contain children)";\n  						}\n\n  						parser.error(errorMessage);\n  					}\n  				}\n  			}\n\n  			// implicit close by closing section tag. TODO clean this up\n  			else if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {\n  				closed = true;\n  				parser.pos = pos;\n  			} else {\n  				if (child = parser.read(PARTIAL_READERS)) {\n  					if (partials[child.n]) {\n  						parser.pos = pos;\n  						parser.error("Duplicate partial definition");\n  					}\n\n  					utils_cleanup(child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);\n\n  					partials[child.n] = child.f;\n  					hasPartials = true;\n  				} else {\n  					if (child = parser.read(READERS)) {\n  						children.push(child);\n  					} else {\n  						closed = true;\n  					}\n  				}\n  			}\n  		} while (!closed);\n\n  		if (children.length) {\n  			element.f = children;\n  		}\n\n  		if (hasPartials) {\n  			element.p = partials;\n  		}\n\n  		parser.elementStack.pop();\n  	}\n\n  	parser.inside = null;\n\n  	if (parser.sanitizeElements && parser.sanitizeElements.indexOf(lowerCaseName) !== -1) {\n  		return exclude;\n  	}\n\n  	return element;\n  }\n\n  function canContain(name, remaining) {\n  	var match, disallowed;\n\n  	match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(remaining);\n  	disallowed = disallowedContents[name];\n\n  	if (!match || !disallowed) {\n  		return true;\n  	}\n\n  	return ! ~disallowed.indexOf(match[1].toLowerCase());\n  }\n\n  var converters_readText = readText;\n  function readText(parser) {\n  	var index, remaining, disallowed, barrier;\n\n  	remaining = parser.remaining();\n\n  	barrier = parser.inside ? "</" + parser.inside : "<";\n\n  	if (parser.inside && !parser.interpolate[parser.inside]) {\n  		index = remaining.indexOf(barrier);\n  	} else {\n  		disallowed = parser.tags.map(function (t) {\n  			return t.open;\n  		});\n  		disallowed = disallowed.concat(parser.tags.map(function (t) {\n  			return "\\\\" + t.open;\n  		}));\n\n  		// http://developers.whatwg.org/syntax.html#syntax-attributes\n  		if (parser.inAttribute === true) {\n  			// we\'re inside an unquoted attribute value\n  			disallowed.push("\\"", "\'", "=", "<", ">", "`");\n  		} else if (parser.inAttribute) {\n  			// quoted attribute value\n  			disallowed.push(parser.inAttribute);\n  		} else {\n  			disallowed.push(barrier);\n  		}\n\n  		index = getLowestIndex(remaining, disallowed);\n  	}\n\n  	if (!index) {\n  		return null;\n  	}\n\n  	if (index === -1) {\n  		index = remaining.length;\n  	}\n\n  	parser.pos += index;\n\n  	return parser.inside ? remaining.substr(0, index) : decodeCharacterReferences(remaining.substr(0, index));\n  }\n\n  var utils_escapeRegExp = escapeRegExp;\n  var utils_escapeRegExp__pattern = /[-/\\\\^$*+?.()|[\\]{}]/g;\n  function escapeRegExp(str) {\n  	return str.replace(utils_escapeRegExp__pattern, "\\\\$&");\n  }\n\n  var converters_readPartialDefinitionComment = readPartialDefinitionComment;\n\n  var startPattern = /^<!--\\s*/,\n      namePattern = /s*>\\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\\s*/,\n      finishPattern = /\\s*-->/,\n      child;\n\n  function readPartialDefinitionComment(parser) {\n  	var firstPos = parser.pos,\n  	    open = parser.standardDelimiters[0],\n  	    close = parser.standardDelimiters[1],\n  	    content = undefined,\n  	    closed = undefined;\n\n  	if (!parser.matchPattern(startPattern) || !parser.matchString(open)) {\n  		parser.pos = firstPos;\n  		return null;\n  	}\n\n  	var name = parser.matchPattern(namePattern);\n\n  	warnOnceIfDebug("Inline partial comments are deprecated.\\nUse this...\\n  {{#partial " + name + "}} ... {{/partial}}\\n\\n...instead of this:\\n  <!-- {{>" + name + "}} --> ... <!-- {{/" + name + "}} -->\'");\n\n  	// make sure the rest of the comment is in the correct place\n  	if (!parser.matchString(close) || !parser.matchPattern(finishPattern)) {\n  		parser.pos = firstPos;\n  		return null;\n  	}\n\n  	content = [];\n\n  	var endPattern = new RegExp("^<!--\\\\s*" + utils_escapeRegExp(open) + "\\\\s*\\\\/\\\\s*" + name + "\\\\s*" + utils_escapeRegExp(close) + "\\\\s*-->");\n\n  	do {\n  		if (parser.matchPattern(endPattern)) {\n  			closed = true;\n  		} else {\n  			child = parser.read(READERS);\n  			if (!child) {\n  				parser.error("expected closing comment (\'<!-- " + open + "/" + name + "" + close + " -->\')");\n  			}\n\n  			content.push(child);\n  		}\n  	} while (!closed);\n\n  	return {\n  		t: INLINE_PARTIAL,\n  		f: content,\n  		n: name\n  	};\n  }\n\n  var converters_readPartialDefinitionSection = readPartialDefinitionSection;\n  var partialDefinitionSectionPattern = /^#\\s*partial\\s+/;\n  function readPartialDefinitionSection(parser) {\n  	var start, name, content, child, closed;\n\n  	start = parser.pos;\n\n  	var delimiters = parser.standardDelimiters;\n\n  	if (!parser.matchString(delimiters[0])) {\n  		return null;\n  	}\n\n  	if (!parser.matchPattern(partialDefinitionSectionPattern)) {\n  		parser.pos = start;\n  		return null;\n  	}\n\n  	name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/);\n\n  	if (!name) {\n  		parser.error("expected legal partial name");\n  	}\n\n  	if (!parser.matchString(delimiters[1])) {\n  		parser.error("Expected closing delimiter \'" + delimiters[1] + "\'");\n  	}\n\n  	content = [];\n\n  	do {\n  		// TODO clean this up\n  		if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {\n  			if (!child.r === "partial") {\n  				parser.error("Expected " + delimiters[0] + "/partial" + delimiters[1]);\n  			}\n\n  			closed = true;\n  		} else {\n  			child = parser.read(READERS);\n\n  			if (!child) {\n  				parser.error("Expected " + delimiters[0] + "/partial" + delimiters[1]);\n  			}\n\n  			content.push(child);\n  		}\n  	} while (!closed);\n\n  	return {\n  		t: INLINE_PARTIAL,\n  		n: name,\n  		f: content\n  	};\n  }\n\n  var converters_readTemplate = readTemplate;\n  function readTemplate(parser) {\n  	var fragment = [];\n  	var partials = create(null);\n  	var hasPartials = false;\n\n  	var preserveWhitespace = parser.preserveWhitespace;\n\n  	while (parser.pos < parser.str.length) {\n  		var pos = parser.pos,\n  		    item = undefined,\n  		    partial = undefined;\n\n  		if (partial = parser.read(PARTIAL_READERS)) {\n  			if (partials[partial.n]) {\n  				parser.pos = pos;\n  				parser.error("Duplicated partial definition");\n  			}\n\n  			utils_cleanup(partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);\n\n  			partials[partial.n] = partial.f;\n  			hasPartials = true;\n  		} else if (item = parser.read(READERS)) {\n  			fragment.push(item);\n  		} else {\n  			parser.error("Unexpected template content");\n  		}\n  	}\n\n  	var result = {\n  		v: TEMPLATE_VERSION,\n  		t: fragment\n  	};\n\n  	if (hasPartials) {\n  		result.p = partials;\n  	}\n\n  	return result;\n  }\n\n  var _parse = parse;\n\n  var STANDARD_READERS = [mustache_readPartial, mustache_readUnescaped, mustache_readSection, mustache_readYielder, mustache_readInterpolator, readMustacheComment];\n  var TRIPLE_READERS = [mustache_readTriple];\n  var STATIC_READERS = [mustache_readUnescaped, mustache_readSection, mustache_readInterpolator]; // TODO does it make sense to have a static section?\n\n  var StandardParser = undefined;\n  function parse(template, options) {\n  	return new StandardParser(template, options || {}).result;\n  }\n\n  var READERS = [converters_readMustache, converters_readHtmlComment, converters_readElement, converters_readText];\n  var PARTIAL_READERS = [converters_readPartialDefinitionComment, converters_readPartialDefinitionSection];\n\n  StandardParser = parse_Parser.extend({\n  	init: function (str, options) {\n  		var tripleDelimiters = options.tripleDelimiters || ["{{{", "}}}"],\n  		    staticDelimiters = options.staticDelimiters || ["[[", "]]"],\n  		    staticTripleDelimiters = options.staticTripleDelimiters || ["[[[", "]]]"];\n\n  		this.standardDelimiters = options.delimiters || ["{{", "}}"];\n\n  		this.tags = [{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS }, { isStatic: false, isTriple: true, open: tripleDelimiters[0], close: tripleDelimiters[1], readers: TRIPLE_READERS }, { isStatic: true, isTriple: false, open: staticDelimiters[0], close: staticDelimiters[1], readers: STATIC_READERS }, { isStatic: true, isTriple: true, open: staticTripleDelimiters[0], close: staticTripleDelimiters[1], readers: TRIPLE_READERS }];\n\n  		this.sortMustacheTags();\n\n  		this.sectionDepth = 0;\n  		this.elementStack = [];\n\n  		this.interpolate = {\n  			script: !options.interpolate || options.interpolate.script !== false,\n  			style: !options.interpolate || options.interpolate.style !== false\n  		};\n\n  		if (options.sanitize === true) {\n  			options.sanitize = {\n  				// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n  				elements: "applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title".split(" "),\n  				eventAttributes: true\n  			};\n  		}\n\n  		this.stripComments = options.stripComments !== false;\n  		this.preserveWhitespace = options.preserveWhitespace;\n  		this.sanitizeElements = options.sanitize && options.sanitize.elements;\n  		this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n  		this.includeLinePositions = options.includeLinePositions;\n  	},\n\n  	postProcess: function (result) {\n  		// special case - empty string\n  		if (!result.length) {\n  			return { t: [], v: TEMPLATE_VERSION };\n  		}\n\n  		if (this.sectionDepth > 0) {\n  			this.error("A section was left open");\n  		}\n\n  		utils_cleanup(result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace);\n\n  		return result[0];\n  	},\n\n  	converters: [converters_readTemplate],\n\n  	sortMustacheTags: function () {\n  		// Sort in order of descending opening delimiter length (longer first),\n  		// to protect against opening delimiters being substrings of each other\n  		this.tags.sort(function (a, b) {\n  			return b.open.length - a.open.length;\n  		});\n  	}\n  });\n\n  var parseOptions = ["preserveWhitespace", "sanitize", "stripComments", "delimiters", "tripleDelimiters", "interpolate"];\n\n  var parser = {\n  	parse: doParse,\n  	fromId: fromId,\n  	isHashedId: isHashedId,\n  	isParsed: isParsed,\n  	getParseOptions: getParseOptions,\n  	createHelper: template_parser__createHelper\n  };\n\n  function template_parser__createHelper(parseOptions) {\n  	var helper = create(parser);\n  	helper.parse = function (template, options) {\n  		return doParse(template, options || parseOptions);\n  	};\n  	return helper;\n  }\n\n  function doParse(template, parseOptions) {\n  	if (!_parse) {\n  		throw new Error("Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser");\n  	}\n\n  	return _parse(template, parseOptions || this.options);\n  }\n\n  function fromId(id, options) {\n  	var template;\n\n  	if (!isClient) {\n  		if (options && options.noThrow) {\n  			return;\n  		}\n  		throw new Error("Cannot retrieve template #" + id + " as Ractive is not running in a browser.");\n  	}\n\n  	if (isHashedId(id)) {\n  		id = id.substring(1);\n  	}\n\n  	if (!(template = document.getElementById(id))) {\n  		if (options && options.noThrow) {\n  			return;\n  		}\n  		throw new Error("Could not find template element with id #" + id);\n  	}\n\n  	if (template.tagName.toUpperCase() !== "SCRIPT") {\n  		if (options && options.noThrow) {\n  			return;\n  		}\n  		throw new Error("Template element with id #" + id + ", must be a <script> element");\n  	}\n\n  	return template.textContent;\n  }\n\n  function isHashedId(id) {\n  	return id && id.charAt(0) === "#"; // TODO what about `id[0]`, does that work everywhere?\n  }\n\n  function isParsed(template) {\n  	return !(typeof template === "string");\n  }\n\n  function getParseOptions(ractive) {\n  	// Could be Ractive or a Component\n  	if (ractive.defaults) {\n  		ractive = ractive.defaults;\n  	}\n\n  	return parseOptions.reduce(function (val, key) {\n  		val[key] = ractive[key];\n  		return val;\n  	}, {});\n  }\n\n  var template_parser = parser;\n\n  var templateConfigurator = {\n  	name: "template",\n\n  	extend: function extend(Parent, proto, options) {\n  		var template;\n\n  		// only assign if exists\n  		if ("template" in options) {\n  			template = options.template;\n\n  			if (typeof template === "function") {\n  				proto.template = template;\n  			} else {\n  				proto.template = parseIfString(template, proto);\n  			}\n  		}\n  	},\n\n  	init: function init(Parent, ractive, options) {\n  		var template, fn;\n\n  		// TODO because of prototypal inheritance, we might just be able to use\n  		// ractive.template, and not bother passing through the Parent object.\n  		// At present that breaks the test mocks\' expectations\n  		template = "template" in options ? options.template : Parent.prototype.template;\n\n  		if (typeof template === "function") {\n  			fn = template;\n  			template = getDynamicTemplate(ractive, fn);\n\n  			ractive._config.template = {\n  				fn: fn,\n  				result: template\n  			};\n  		}\n\n  		template = parseIfString(template, ractive);\n\n  		// TODO the naming of this is confusing - ractive.template refers to [...],\n  		// but Component.prototype.template refers to {v:1,t:[],p:[]}...\n  		// it\'s unnecessary, because the developer never needs to access\n  		// ractive.template\n  		ractive.template = template.t;\n\n  		if (template.p) {\n  			extendPartials(ractive.partials, template.p);\n  		}\n  	},\n\n  	reset: function (ractive) {\n  		var result = resetValue(ractive),\n  		    parsed;\n\n  		if (result) {\n  			parsed = parseIfString(result, ractive);\n\n  			ractive.template = parsed.t;\n  			extendPartials(ractive.partials, parsed.p, true);\n\n  			return true;\n  		}\n  	}\n  };\n\n  function resetValue(ractive) {\n  	var initial = ractive._config.template,\n  	    result;\n\n  	// If this isn\'t a dynamic template, there\'s nothing to do\n  	if (!initial || !initial.fn) {\n  		return;\n  	}\n\n  	result = getDynamicTemplate(ractive, initial.fn);\n\n  	// TODO deep equality check to prevent unnecessary re-rendering\n  	// in the case of already-parsed templates\n  	if (result !== initial.result) {\n  		initial.result = result;\n  		result = parseIfString(result, ractive);\n  		return result;\n  	}\n  }\n\n  function getDynamicTemplate(ractive, fn) {\n  	var helper = template_template__createHelper(template_parser.getParseOptions(ractive));\n  	return fn.call(ractive, helper);\n  }\n\n  function template_template__createHelper(parseOptions) {\n  	var helper = create(template_parser);\n  	helper.parse = function (template, options) {\n  		return template_parser.parse(template, options || parseOptions);\n  	};\n  	return helper;\n  }\n\n  function parseIfString(template, ractive) {\n  	if (typeof template === "string") {\n  		// ID of an element containing the template?\n  		if (template[0] === "#") {\n  			template = template_parser.fromId(template);\n  		}\n\n  		template = _parse(template, template_parser.getParseOptions(ractive));\n  	}\n\n  	// Check the parsed template has a version at all\n  	else if (typeof template.v !== "number") {\n  		throw new Error("The template parser was passed a non-string template, but the template doesn\'t have a version.  Make sure you\'re passing in the template you think you are.");\n  	}\n\n  	// Check we\'re using the correct version\n  	else if (template.v !== TEMPLATE_VERSION) {\n  		throw new Error("Mismatched template version (expected " + TEMPLATE_VERSION + ", got " + template.v + ") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app");\n  	}\n\n  	return template;\n  }\n\n  function extendPartials(existingPartials, newPartials, overwrite) {\n  	if (!newPartials) return;\n\n  	// TODO there\'s an ambiguity here - we need to overwrite in the `reset()`\n  	// case, but not initially...\n\n  	for (var key in newPartials) {\n  		if (overwrite || !existingPartials.hasOwnProperty(key)) {\n  			existingPartials[key] = newPartials[key];\n  		}\n  	}\n  }\n\n  var template_template = templateConfigurator;\n\n  var config_registries__registryNames, Registry, registries;\n\n  config_registries__registryNames = ["adaptors", "components", "computed", "decorators", "easing", "events", "interpolators", "partials", "transitions"];\n\n  Registry = function (name, useDefaults) {\n  	this.name = name;\n  	this.useDefaults = useDefaults;\n  };\n\n  Registry.prototype = {\n  	constructor: Registry,\n\n  	extend: function (Parent, proto, options) {\n  		this.configure(this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options);\n  	},\n\n  	init: function () {},\n\n  	configure: function (Parent, target, options) {\n  		var name = this.name,\n  		    option = options[name],\n  		    registry;\n\n  		registry = create(Parent[name]);\n\n  		for (var key in option) {\n  			registry[key] = option[key];\n  		}\n\n  		target[name] = registry;\n  	},\n\n  	reset: function (ractive) {\n  		var registry = ractive[this.name];\n  		var changed = false;\n  		Object.keys(registry).forEach(function (key) {\n  			var item = registry[key];\n  			if (item._fn) {\n  				if (item._fn.isOwner) {\n  					registry[key] = item._fn;\n  				} else {\n  					delete registry[key];\n  				}\n  				changed = true;\n  			}\n  		});\n  		return changed;\n  	}\n  };\n\n  registries = config_registries__registryNames.map(function (name) {\n  	return new Registry(name, name === "computed");\n  });\n\n  var config_registries = registries;\n\n  /*this.configure(\n  	this.useDefaults ? Parent.defaults : Parent,\n  	ractive,\n  	options );*/\n\n  var wrapPrototype = wrap;\n\n  function wrap(parent, name, method) {\n  	if (!/_super/.test(method)) {\n  		return method;\n  	}\n\n  	var wrapper = function wrapSuper() {\n  		var superMethod = getSuperMethod(wrapper._parent, name),\n  		    hasSuper = ("_super" in this),\n  		    oldSuper = this._super,\n  		    result;\n\n  		this._super = superMethod;\n\n  		result = method.apply(this, arguments);\n\n  		if (hasSuper) {\n  			this._super = oldSuper;\n  		} else {\n  			delete this._super;\n  		}\n\n  		return result;\n  	};\n\n  	wrapper._parent = parent;\n  	wrapper._method = method;\n\n  	return wrapper;\n  }\n\n  function getSuperMethod(parent, name) {\n  	var value, method;\n\n  	if (name in parent) {\n  		value = parent[name];\n\n  		if (typeof value === "function") {\n  			method = value;\n  		} else {\n  			method = function returnValue() {\n  				return value;\n  			};\n  		}\n  	} else {\n  		method = noop;\n  	}\n\n  	return method;\n  }\n\n  var config_deprecate = deprecate;\n  function getMessage(deprecated, correct, isError) {\n  	return "options." + deprecated + " has been deprecated in favour of options." + correct + "." + (isError ? " You cannot specify both options, please use options." + correct + "." : "");\n  }\n\n  function deprecateOption(options, deprecatedOption, correct) {\n  	if (deprecatedOption in options) {\n  		if (!(correct in options)) {\n  			warnIfDebug(getMessage(deprecatedOption, correct));\n  			options[correct] = options[deprecatedOption];\n  		} else {\n  			throw new Error(getMessage(deprecatedOption, correct, true));\n  		}\n  	}\n  }\n  function deprecate(options) {\n  	deprecateOption(options, "beforeInit", "onconstruct");\n  	deprecateOption(options, "init", "onrender");\n  	deprecateOption(options, "complete", "oncomplete");\n  	deprecateOption(options, "eventDefinitions", "events");\n\n  	// Using extend with Component instead of options,\n  	// like Human.extend( Spider ) means adaptors as a registry\n  	// gets copied to options. So we have to check if actually an array\n  	if (isArray(options.adaptors)) {\n  		deprecateOption(options, "adaptors", "adapt");\n  	}\n  }\n\n  var config, order, defaultKeys, custom, isBlacklisted, isStandardKey;\n\n  custom = {\n  	adapt: custom_adapt,\n  	css: css_css,\n  	data: custom_data,\n  	template: template_template\n  };\n\n  defaultKeys = Object.keys(config_defaults);\n\n  isStandardKey = makeObj(defaultKeys.filter(function (key) {\n  	return !custom[key];\n  }));\n\n  // blacklisted keys that we don\'t double extend\n  isBlacklisted = makeObj(defaultKeys.concat(config_registries.map(function (r) {\n  	return r.name;\n  })));\n\n  order = [].concat(defaultKeys.filter(function (key) {\n  	return !config_registries[key] && !custom[key];\n  }), config_registries, custom.data, custom.template, custom.css);\n\n  config = {\n  	extend: function (Parent, proto, options) {\n  		return configure("extend", Parent, proto, options);\n  	},\n\n  	init: function (Parent, ractive, options) {\n  		return configure("init", Parent, ractive, options);\n  	},\n\n  	reset: function (ractive) {\n  		return order.filter(function (c) {\n  			return c.reset && c.reset(ractive);\n  		}).map(function (c) {\n  			return c.name;\n  		});\n  	},\n\n  	// this defines the order. TODO this isn\'t used anywhere in the codebase,\n  	// only in the test suite - should get rid of it\n  	order: order };\n\n  function configure(method, Parent, target, options) {\n  	config_deprecate(options);\n\n  	for (var key in options) {\n  		if (isStandardKey.hasOwnProperty(key)) {\n  			var value = options[key];\n\n  			// warn the developer if they passed a function and ignore its value\n\n  			// NOTE: we allow some functions on "el" because we duck type element lists\n  			// and some libraries or ef\'ed-up virtual browsers (phantomJS) return a\n  			// function object as the result of querySelector methods\n  			if (key !== "el" && typeof value === "function") {\n  				warnIfDebug("" + key + " is a Ractive option that does not expect a function and will be ignored", method === "init" ? target : null);\n  			} else {\n  				target[key] = value;\n  			}\n  		}\n  	}\n\n  	config_registries.forEach(function (registry) {\n  		registry[method](Parent, target, options);\n  	});\n\n  	custom_adapt[method](Parent, target, options);\n  	template_template[method](Parent, target, options);\n  	css_css[method](Parent, target, options);\n\n  	extendOtherMethods(Parent.prototype, target, options);\n  }\n\n  function extendOtherMethods(parent, target, options) {\n  	for (var key in options) {\n  		if (!isBlacklisted[key] && options.hasOwnProperty(key)) {\n  			var member = options[key];\n\n  			// if this is a method that overwrites a method, wrap it:\n  			if (typeof member === "function") {\n  				member = wrapPrototype(parent, key, member);\n  			}\n\n  			target[key] = member;\n  		}\n  	}\n  }\n\n  function makeObj(array) {\n  	var obj = {};\n  	array.forEach(function (x) {\n  		return obj[x] = true;\n  	});\n  	return obj;\n  }\n\n  var config_config = config;\n\n  var prototype_bubble = Fragment$bubble;\n\n  function Fragment$bubble() {\n  	this.dirtyValue = this.dirtyArgs = true;\n\n  	if (this.bound && typeof this.owner.bubble === "function") {\n  		this.owner.bubble();\n  	}\n  }\n\n  var Fragment_prototype_detach = Fragment$detach;\n\n  function Fragment$detach() {\n  	var docFrag;\n\n  	if (this.items.length === 1) {\n  		return this.items[0].detach();\n  	}\n\n  	docFrag = document.createDocumentFragment();\n\n  	this.items.forEach(function (item) {\n  		var node = item.detach();\n\n  		// TODO The if {...} wasn\'t previously required - it is now, because we\'re\n  		// forcibly detaching everything to reorder sections after an update. That\'s\n  		// a non-ideal brute force approach, implemented to get all the tests to pass\n  		// - as soon as it\'s replaced with something more elegant, this should\n  		// revert to `docFrag.appendChild( item.detach() )`\n  		if (node) {\n  			docFrag.appendChild(node);\n  		}\n  	});\n\n  	return docFrag;\n  }\n\n  var Fragment_prototype_find = Fragment$find;\n\n  function Fragment$find(selector) {\n  	var i, len, item, queryResult;\n\n  	if (this.items) {\n  		len = this.items.length;\n  		for (i = 0; i < len; i += 1) {\n  			item = this.items[i];\n\n  			if (item.find && (queryResult = item.find(selector))) {\n  				return queryResult;\n  			}\n  		}\n\n  		return null;\n  	}\n  }\n\n  var Fragment_prototype_findAll = Fragment$findAll;\n\n  function Fragment$findAll(selector, query) {\n  	var i, len, item;\n\n  	if (this.items) {\n  		len = this.items.length;\n  		for (i = 0; i < len; i += 1) {\n  			item = this.items[i];\n\n  			if (item.findAll) {\n  				item.findAll(selector, query);\n  			}\n  		}\n  	}\n\n  	return query;\n  }\n\n  var Fragment_prototype_findAllComponents = Fragment$findAllComponents;\n\n  function Fragment$findAllComponents(selector, query) {\n  	var i, len, item;\n\n  	if (this.items) {\n  		len = this.items.length;\n  		for (i = 0; i < len; i += 1) {\n  			item = this.items[i];\n\n  			if (item.findAllComponents) {\n  				item.findAllComponents(selector, query);\n  			}\n  		}\n  	}\n\n  	return query;\n  }\n\n  var Fragment_prototype_findComponent = Fragment$findComponent;\n\n  function Fragment$findComponent(selector) {\n  	var len, i, item, queryResult;\n\n  	if (this.items) {\n  		len = this.items.length;\n  		for (i = 0; i < len; i += 1) {\n  			item = this.items[i];\n\n  			if (item.findComponent && (queryResult = item.findComponent(selector))) {\n  				return queryResult;\n  			}\n  		}\n\n  		return null;\n  	}\n  }\n\n  var prototype_findNextNode = Fragment$findNextNode;\n\n  function Fragment$findNextNode(item) {\n  	var index = item.index,\n  	    node;\n\n  	if (this.items[index + 1]) {\n  		node = this.items[index + 1].firstNode();\n  	}\n\n  	// if this is the root fragment, and there are no more items,\n  	// it means we\'re at the end...\n  	else if (this.owner === this.root) {\n  		if (!this.owner.component) {\n  			// TODO but something else could have been appended to\n  			// this.root.el, no?\n  			node = null;\n  		}\n\n  		// ...unless this is a component\n  		else {\n  			node = this.owner.component.findNextNode();\n  		}\n  	} else {\n  		node = this.owner.findNextNode(this);\n  	}\n\n  	return node;\n  }\n\n  var prototype_firstNode = Fragment$firstNode;\n\n  function Fragment$firstNode() {\n  	if (this.items && this.items[0]) {\n  		return this.items[0].firstNode();\n  	}\n\n  	return null;\n  }\n\n  var shared_processItems = processItems;\n\n  function processItems(items, values, guid, counter) {\n  	counter = counter || 0;\n\n  	return items.map(function (item) {\n  		var placeholderId, wrapped, value;\n\n  		if (item.text) {\n  			return item.text;\n  		}\n\n  		if (item.fragments) {\n  			return item.fragments.map(function (fragment) {\n  				return processItems(fragment.items, values, guid, counter);\n  			}).join("");\n  		}\n\n  		placeholderId = guid + "-" + counter++;\n\n  		if (item.keypath && (wrapped = item.root.viewmodel.wrapped[item.keypath.str])) {\n  			value = wrapped.value;\n  		} else {\n  			value = item.getValue();\n  		}\n\n  		values[placeholderId] = value;\n\n  		return "${" + placeholderId + "}";\n  	}).join("");\n  }\n\n  var getArgsList = Fragment$getArgsList;\n  function Fragment$getArgsList() {\n  	var values, source, parsed, result;\n\n  	if (this.dirtyArgs) {\n  		source = shared_processItems(this.items, values = {}, this.root._guid);\n  		parsed = parseJSON("[" + source + "]", values);\n\n  		if (!parsed) {\n  			result = [this.toString()];\n  		} else {\n  			result = parsed.value;\n  		}\n\n  		this.argsList = result;\n  		this.dirtyArgs = false;\n  	}\n\n  	return this.argsList;\n  }\n\n  var getNode = Fragment$getNode;\n\n  function Fragment$getNode() {\n  	var fragment = this;\n\n  	do {\n  		if (fragment.pElement) {\n  			return fragment.pElement.node;\n  		}\n  	} while (fragment = fragment.parent);\n\n  	return this.root.detached || this.root.el;\n  }\n\n  var prototype_getValue = Fragment$getValue;\n  function Fragment$getValue() {\n  	var values, source, parsed, result;\n\n  	if (this.dirtyValue) {\n  		source = shared_processItems(this.items, values = {}, this.root._guid);\n  		parsed = parseJSON(source, values);\n\n  		if (!parsed) {\n  			result = this.toString();\n  		} else {\n  			result = parsed.value;\n  		}\n\n  		this.value = result;\n  		this.dirtyValue = false;\n  	}\n\n  	return this.value;\n  }\n\n  var shared_detach = function () {\n  	return detachNode(this.node);\n  };\n\n  var Text = function (options) {\n  	this.type = TEXT;\n  	this.text = options.template;\n  };\n\n  Text.prototype = {\n  	detach: shared_detach,\n\n  	firstNode: function () {\n  		return this.node;\n  	},\n\n  	render: function () {\n  		if (!this.node) {\n  			this.node = document.createTextNode(this.text);\n  		}\n\n  		return this.node;\n  	},\n\n  	toString: function (escape) {\n  		return escape ? escapeHtml(this.text) : this.text;\n  	},\n\n  	unrender: function (shouldDestroy) {\n  		if (shouldDestroy) {\n  			return this.detach();\n  		}\n  	}\n  };\n\n  var items_Text = Text;\n\n  var shared_unbind = shared_unbind__unbind;\n\n  function shared_unbind__unbind() {\n  	if (this.registered) {\n  		// this was registered as a dependant\n  		this.root.viewmodel.unregister(this.keypath, this);\n  	}\n\n  	if (this.resolver) {\n  		this.resolver.unbind();\n  	}\n  }\n\n  var Mustache_getValue = Mustache$getValue;\n\n  function Mustache$getValue() {\n  	return this.value;\n  }\n\n  var ReferenceResolver = function (owner, ref, callback) {\n  	var keypath;\n\n  	this.ref = ref;\n  	this.resolved = false;\n\n  	this.root = owner.root;\n  	this.parentFragment = owner.parentFragment;\n  	this.callback = callback;\n\n  	keypath = shared_resolveRef(owner.root, ref, owner.parentFragment);\n  	if (keypath != undefined) {\n  		this.resolve(keypath);\n  	} else {\n  		global_runloop.addUnresolved(this);\n  	}\n  };\n\n  ReferenceResolver.prototype = {\n  	resolve: function (keypath) {\n  		if (this.keypath && !keypath) {\n  			// it was resolved, and now it\'s not. Can happen if e.g. `bar` in\n  			// `{{foo[bar]}}` becomes undefined\n  			global_runloop.addUnresolved(this);\n  		}\n\n  		this.resolved = true;\n\n  		this.keypath = keypath;\n  		this.callback(keypath);\n  	},\n\n  	forceResolution: function () {\n  		this.resolve(getKeypath(this.ref));\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		var keypath;\n\n  		if (this.keypath != undefined) {\n  			keypath = this.keypath.replace(oldKeypath, newKeypath);\n  			// was a new keypath created?\n  			if (keypath !== undefined) {\n  				// resolve it\n  				this.resolve(keypath);\n  			}\n  		}\n  	},\n\n  	unbind: function () {\n  		if (!this.resolved) {\n  			global_runloop.removeUnresolved(this);\n  		}\n  	}\n  };\n\n  var Resolvers_ReferenceResolver = ReferenceResolver;\n\n  var SpecialResolver = function (owner, ref, callback) {\n  	this.parentFragment = owner.parentFragment;\n  	this.ref = ref;\n  	this.callback = callback;\n\n  	this.rebind();\n  };\n\n  var props = {\n  	"@keypath": { prefix: "c", prop: ["context"] },\n  	"@index": { prefix: "i", prop: ["index"] },\n  	"@key": { prefix: "k", prop: ["key", "index"] }\n  };\n\n  function getProp(target, prop) {\n  	var value;\n  	for (var i = 0; i < prop.prop.length; i++) {\n  		if ((value = target[prop.prop[i]]) !== undefined) {\n  			return value;\n  		}\n  	}\n  }\n\n  SpecialResolver.prototype = {\n  	rebind: function () {\n  		var ref = this.ref,\n  		    fragment = this.parentFragment,\n  		    prop = props[ref],\n  		    value;\n\n  		if (!prop) {\n  			throw new Error("Unknown special reference \\"" + ref + "\\" - valid references are @index, @key and @keypath");\n  		}\n\n  		// have we already found the nearest parent?\n  		if (this.cached) {\n  			return this.callback(getKeypath("@" + prop.prefix + getProp(this.cached, prop)));\n  		}\n\n  		// special case for indices, which may cross component boundaries\n  		if (prop.prop.indexOf("index") !== -1 || prop.prop.indexOf("key") !== -1) {\n  			while (fragment) {\n  				if (fragment.owner.currentSubtype === SECTION_EACH && (value = getProp(fragment, prop)) !== undefined) {\n  					this.cached = fragment;\n\n  					fragment.registerIndexRef(this);\n\n  					return this.callback(getKeypath("@" + prop.prefix + value));\n  				}\n\n  				// watch for component boundaries\n  				if (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {\n  					fragment = fragment.owner.component.parentFragment;\n  				} else {\n  					fragment = fragment.parent;\n  				}\n  			}\n  		} else {\n  			while (fragment) {\n  				if ((value = getProp(fragment, prop)) !== undefined) {\n  					return this.callback(getKeypath("@" + prop.prefix + value.str));\n  				}\n\n  				fragment = fragment.parent;\n  			}\n  		}\n  	},\n\n  	unbind: function () {\n  		if (this.cached) {\n  			this.cached.unregisterIndexRef(this);\n  		}\n  	}\n  };\n\n  var Resolvers_SpecialResolver = SpecialResolver;\n\n  var IndexResolver = function (owner, ref, callback) {\n  	this.parentFragment = owner.parentFragment;\n  	this.ref = ref;\n  	this.callback = callback;\n\n  	ref.ref.fragment.registerIndexRef(this);\n\n  	this.rebind();\n  };\n\n  IndexResolver.prototype = {\n  	rebind: function () {\n  		var index,\n  		    ref = this.ref.ref;\n\n  		if (ref.ref.t === "k") {\n  			index = "k" + ref.fragment.key;\n  		} else {\n  			index = "i" + ref.fragment.index;\n  		}\n\n  		if (index !== undefined) {\n  			this.callback(getKeypath("@" + index));\n  		}\n  	},\n\n  	unbind: function () {\n  		this.ref.ref.fragment.unregisterIndexRef(this);\n  	}\n  };\n\n  var Resolvers_IndexResolver = IndexResolver;\n\n  var Resolvers_findIndexRefs = findIndexRefs;\n\n  function findIndexRefs(fragment, refName) {\n  	var result = {},\n  	    refs,\n  	    fragRefs,\n  	    ref,\n  	    i,\n  	    owner,\n  	    hit = false;\n\n  	if (!refName) {\n  		result.refs = refs = {};\n  	}\n\n  	while (fragment) {\n  		if ((owner = fragment.owner) && (fragRefs = owner.indexRefs)) {\n\n  			// we\'re looking for a particular ref, and it\'s here\n  			if (refName && (ref = owner.getIndexRef(refName))) {\n  				result.ref = {\n  					fragment: fragment,\n  					ref: ref\n  				};\n  				return result;\n  			}\n\n  			// we\'re collecting refs up-tree\n  			else if (!refName) {\n  				for (i in fragRefs) {\n  					ref = fragRefs[i];\n\n  					// don\'t overwrite existing refs - they should shadow parents\n  					if (!refs[ref.n]) {\n  						hit = true;\n  						refs[ref.n] = {\n  							fragment: fragment,\n  							ref: ref\n  						};\n  					}\n  				}\n  			}\n  		}\n\n  		// watch for component boundaries\n  		if (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {\n  			result.componentBoundary = true;\n  			fragment = fragment.owner.component.parentFragment;\n  		} else {\n  			fragment = fragment.parent;\n  		}\n  	}\n\n  	if (!hit) {\n  		return undefined;\n  	} else {\n  		return result;\n  	}\n  }\n\n  findIndexRefs.resolve = function resolve(indices) {\n  	var refs = {},\n  	    k,\n  	    ref;\n\n  	for (k in indices.refs) {\n  		ref = indices.refs[k];\n  		refs[ref.ref.n] = ref.ref.t === "k" ? ref.fragment.key : ref.fragment.index;\n  	}\n\n  	return refs;\n  };\n\n  var Resolvers_createReferenceResolver = createReferenceResolver;\n  function createReferenceResolver(owner, ref, callback) {\n  	var indexRef;\n\n  	if (ref.charAt(0) === "@") {\n  		return new Resolvers_SpecialResolver(owner, ref, callback);\n  	}\n\n  	if (indexRef = Resolvers_findIndexRefs(owner.parentFragment, ref)) {\n  		return new Resolvers_IndexResolver(owner, indexRef, callback);\n  	}\n\n  	return new Resolvers_ReferenceResolver(owner, ref, callback);\n  }\n\n  var shared_getFunctionFromString = getFunctionFromString;\n  var cache = {};\n  function getFunctionFromString(str, i) {\n  	var fn, args;\n\n  	if (cache[str]) {\n  		return cache[str];\n  	}\n\n  	args = [];\n  	while (i--) {\n  		args[i] = "_" + i;\n  	}\n\n  	fn = new Function(args.join(","), "return(" + str + ")");\n\n  	cache[str] = fn;\n  	return fn;\n  }\n\n  var ExpressionResolver,\n      Resolvers_ExpressionResolver__bind = Function.prototype.bind;\n\n  ExpressionResolver = function (owner, parentFragment, expression, callback) {\n  	var _this = this;\n\n  	var ractive;\n\n  	ractive = owner.root;\n\n  	this.root = ractive;\n  	this.parentFragment = parentFragment;\n  	this.callback = callback;\n  	this.owner = owner;\n  	this.str = expression.s;\n  	this.keypaths = [];\n\n  	// Create resolvers for each reference\n  	this.pending = expression.r.length;\n  	this.refResolvers = expression.r.map(function (ref, i) {\n  		return Resolvers_createReferenceResolver(_this, ref, function (keypath) {\n  			_this.resolve(i, keypath);\n  		});\n  	});\n\n  	this.ready = true;\n  	this.bubble();\n  };\n\n  ExpressionResolver.prototype = {\n  	bubble: function () {\n  		if (!this.ready) {\n  			return;\n  		}\n\n  		this.uniqueString = getUniqueString(this.str, this.keypaths);\n  		this.keypath = createExpressionKeypath(this.uniqueString);\n\n  		this.createEvaluator();\n  		this.callback(this.keypath);\n  	},\n\n  	unbind: function () {\n  		var resolver;\n\n  		while (resolver = this.refResolvers.pop()) {\n  			resolver.unbind();\n  		}\n  	},\n\n  	resolve: function (index, keypath) {\n  		this.keypaths[index] = keypath;\n  		this.bubble();\n  	},\n\n  	createEvaluator: function () {\n  		var _this = this;\n\n  		var computation, valueGetters, signature, keypath, fn;\n\n  		keypath = this.keypath;\n  		computation = this.root.viewmodel.computations[keypath.str];\n\n  		// only if it doesn\'t exist yet!\n  		if (!computation) {\n  			fn = shared_getFunctionFromString(this.str, this.refResolvers.length);\n\n  			valueGetters = this.keypaths.map(function (keypath) {\n  				var value;\n\n  				if (keypath === "undefined") {\n  					return function () {\n  						return undefined;\n  					};\n  				}\n\n  				// \'special\' keypaths encode a value\n  				if (keypath.isSpecial) {\n  					value = keypath.value;\n  					return function () {\n  						return value;\n  					};\n  				}\n\n  				return function () {\n  					var value = _this.root.viewmodel.get(keypath, { noUnwrap: true, fullRootGet: true });\n  					if (typeof value === "function") {\n  						value = wrapFunction(value, _this.root);\n  					}\n  					return value;\n  				};\n  			});\n\n  			signature = {\n  				deps: this.keypaths.filter(isValidDependency),\n  				getter: function () {\n  					var args = valueGetters.map(call);\n  					return fn.apply(null, args);\n  				}\n  			};\n\n  			computation = this.root.viewmodel.compute(keypath, signature);\n  		} else {\n  			this.root.viewmodel.mark(keypath);\n  		}\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		// TODO only bubble once, no matter how many references are affected by the rebind\n  		this.refResolvers.forEach(function (r) {\n  			return r.rebind(oldKeypath, newKeypath);\n  		});\n  	}\n  };\n\n  var Resolvers_ExpressionResolver = ExpressionResolver;\n\n  function call(value) {\n  	return value.call();\n  }\n\n  function getUniqueString(str, keypaths) {\n  	// get string that is unique to this expression\n  	return str.replace(/_([0-9]+)/g, function (match, $1) {\n  		var keypath, value;\n\n  		// make sure we\'re not replacing a non-keypath _[0-9]\n  		if (+$1 >= keypaths.length) {\n  			return "_" + $1;\n  		}\n\n  		keypath = keypaths[$1];\n\n  		if (keypath === undefined) {\n  			return "undefined";\n  		}\n\n  		if (keypath.isSpecial) {\n  			value = keypath.value;\n  			return typeof value === "number" ? value : "\\"" + value + "\\"";\n  		}\n\n  		return keypath.str;\n  	});\n  }\n\n  function createExpressionKeypath(uniqueString) {\n  	// Sanitize by removing any periods or square brackets. Otherwise\n  	// we can\'t split the keypath into keys!\n  	// Remove asterisks too, since they mess with pattern observers\n  	return getKeypath("${" + uniqueString.replace(/[\\.\\[\\]]/g, "-").replace(/\\*/, "#MUL#") + "}");\n  }\n\n  function isValidDependency(keypath) {\n  	return keypath !== undefined && keypath[0] !== "@";\n  }\n\n  function wrapFunction(fn, ractive) {\n  	var wrapped, prop, key;\n\n  	if (fn.__ractive_nowrap) {\n  		return fn;\n  	}\n\n  	prop = "__ractive_" + ractive._guid;\n  	wrapped = fn[prop];\n\n  	if (wrapped) {\n  		return wrapped;\n  	} else if (/this/.test(fn.toString())) {\n  		defineProperty(fn, prop, {\n  			value: Resolvers_ExpressionResolver__bind.call(fn, ractive),\n  			configurable: true\n  		});\n\n  		// Add properties/methods to wrapped function\n  		for (key in fn) {\n  			if (fn.hasOwnProperty(key)) {\n  				fn[prop][key] = fn[key];\n  			}\n  		}\n\n  		ractive._boundFunctions.push({\n  			fn: fn,\n  			prop: prop\n  		});\n\n  		return fn[prop];\n  	}\n\n  	defineProperty(fn, "__ractive_nowrap", {\n  		value: fn\n  	});\n\n  	return fn.__ractive_nowrap;\n  }\n\n  var MemberResolver = function (template, resolver, parentFragment) {\n  	var _this = this;\n\n  	this.resolver = resolver;\n  	this.root = resolver.root;\n  	this.parentFragment = parentFragment;\n  	this.viewmodel = resolver.root.viewmodel;\n\n  	if (typeof template === "string") {\n  		this.value = template;\n  	}\n\n  	// Simple reference?\n  	else if (template.t === REFERENCE) {\n  		this.refResolver = Resolvers_createReferenceResolver(this, template.n, function (keypath) {\n  			_this.resolve(keypath);\n  		});\n  	}\n\n  	// Otherwise we have an expression in its own right\n  	else {\n  		new Resolvers_ExpressionResolver(resolver, parentFragment, template, function (keypath) {\n  			_this.resolve(keypath);\n  		});\n  	}\n  };\n\n  MemberResolver.prototype = {\n  	resolve: function (keypath) {\n  		if (this.keypath) {\n  			this.viewmodel.unregister(this.keypath, this);\n  		}\n\n  		this.keypath = keypath;\n  		this.value = this.viewmodel.get(keypath);\n\n  		this.bind();\n\n  		this.resolver.bubble();\n  	},\n\n  	bind: function () {\n  		this.viewmodel.register(this.keypath, this);\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		if (this.refResolver) {\n  			this.refResolver.rebind(oldKeypath, newKeypath);\n  		}\n  	},\n\n  	setValue: function (value) {\n  		this.value = value;\n  		this.resolver.bubble();\n  	},\n\n  	unbind: function () {\n  		if (this.keypath) {\n  			this.viewmodel.unregister(this.keypath, this);\n  		}\n\n  		if (this.refResolver) {\n  			this.refResolver.unbind();\n  		}\n  	},\n\n  	forceResolution: function () {\n  		if (this.refResolver) {\n  			this.refResolver.forceResolution();\n  		}\n  	}\n  };\n\n  var ReferenceExpressionResolver_MemberResolver = MemberResolver;\n\n  var ReferenceExpressionResolver = function (mustache, template, callback) {\n  	var _this = this;\n\n  	var ractive, ref, keypath, parentFragment;\n\n  	this.parentFragment = parentFragment = mustache.parentFragment;\n  	this.root = ractive = mustache.root;\n  	this.mustache = mustache;\n\n  	this.ref = ref = template.r;\n  	this.callback = callback;\n\n  	this.unresolved = [];\n\n  	// Find base keypath\n  	if (keypath = shared_resolveRef(ractive, ref, parentFragment)) {\n  		this.base = keypath;\n  	} else {\n  		this.baseResolver = new Resolvers_ReferenceResolver(this, ref, function (keypath) {\n  			_this.base = keypath;\n  			_this.baseResolver = null;\n  			_this.bubble();\n  		});\n  	}\n\n  	// Find values for members, or mark them as unresolved\n  	this.members = template.m.map(function (template) {\n  		return new ReferenceExpressionResolver_MemberResolver(template, _this, parentFragment);\n  	});\n\n  	this.ready = true;\n  	this.bubble(); // trigger initial resolution if possible\n  };\n\n  ReferenceExpressionResolver.prototype = {\n  	getKeypath: function () {\n  		var values = this.members.map(ReferenceExpressionResolver_ReferenceExpressionResolver__getValue);\n\n  		if (!values.every(isDefined) || this.baseResolver) {\n  			return null;\n  		}\n\n  		return this.base.join(values.join("."));\n  	},\n\n  	bubble: function () {\n  		if (!this.ready || this.baseResolver) {\n  			return;\n  		}\n\n  		this.callback(this.getKeypath());\n  	},\n\n  	unbind: function () {\n  		this.members.forEach(methodCallers__unbind);\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		var changed;\n\n  		if (this.base) {\n  			var newBase = this.base.replace(oldKeypath, newKeypath);\n  			if (newBase && newBase !== this.base) {\n  				this.base = newBase;\n  				changed = true;\n  			}\n  		}\n\n  		this.members.forEach(function (members) {\n  			if (members.rebind(oldKeypath, newKeypath)) {\n  				changed = true;\n  			}\n  		});\n\n  		if (changed) {\n  			this.bubble();\n  		}\n  	},\n\n  	forceResolution: function () {\n  		if (this.baseResolver) {\n  			this.base = getKeypath(this.ref);\n\n  			this.baseResolver.unbind();\n  			this.baseResolver = null;\n  		}\n\n  		this.members.forEach(forceResolution);\n  		this.bubble();\n  	}\n  };\n\n  function ReferenceExpressionResolver_ReferenceExpressionResolver__getValue(member) {\n  	return member.value;\n  }\n\n  function isDefined(value) {\n  	return value != undefined;\n  }\n\n  function forceResolution(member) {\n  	member.forceResolution();\n  }\n\n  var ReferenceExpressionResolver_ReferenceExpressionResolver = ReferenceExpressionResolver;\n\n  var Mustache_initialise = Mustache$init;\n  function Mustache$init(mustache, options) {\n\n  	var ref, parentFragment, template;\n\n  	parentFragment = options.parentFragment;\n  	template = options.template;\n\n  	mustache.root = parentFragment.root;\n  	mustache.parentFragment = parentFragment;\n  	mustache.pElement = parentFragment.pElement;\n\n  	mustache.template = options.template;\n  	mustache.index = options.index || 0;\n  	mustache.isStatic = options.template.s;\n\n  	mustache.type = options.template.t;\n\n  	mustache.registered = false;\n\n  	// if this is a simple mustache, with a reference, we just need to resolve\n  	// the reference to a keypath\n  	if (ref = template.r) {\n  		mustache.resolver = Resolvers_createReferenceResolver(mustache, ref, resolve);\n  	}\n\n  	// if it\'s an expression, we have a bit more work to do\n  	if (options.template.x) {\n  		mustache.resolver = new Resolvers_ExpressionResolver(mustache, parentFragment, options.template.x, resolveAndRebindChildren);\n  	}\n\n  	if (options.template.rx) {\n  		mustache.resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(mustache, options.template.rx, resolveAndRebindChildren);\n  	}\n\n  	// Special case - inverted sections\n  	if (mustache.template.n === SECTION_UNLESS && !mustache.hasOwnProperty("value")) {\n  		mustache.setValue(undefined);\n  	}\n\n  	function resolve(keypath) {\n  		mustache.resolve(keypath);\n  	}\n\n  	function resolveAndRebindChildren(newKeypath) {\n  		var oldKeypath = mustache.keypath;\n\n  		if (newKeypath != oldKeypath) {\n  			mustache.resolve(newKeypath);\n\n  			if (oldKeypath !== undefined) {\n  				mustache.fragments && mustache.fragments.forEach(function (f) {\n  					f.rebind(oldKeypath, newKeypath);\n  				});\n  			}\n  		}\n  	}\n  }\n\n  var Mustache_resolve = Mustache$resolve;\n\n  function Mustache$resolve(keypath) {\n  	var wasResolved, value, twowayBinding;\n\n  	// \'Special\' keypaths, e.g. @foo or @7, encode a value\n  	if (keypath && keypath.isSpecial) {\n  		this.keypath = keypath;\n  		this.setValue(keypath.value);\n  		return;\n  	}\n\n  	// If we resolved previously, we need to unregister\n  	if (this.registered) {\n  		// undefined or null\n  		this.root.viewmodel.unregister(this.keypath, this);\n  		this.registered = false;\n\n  		wasResolved = true;\n  	}\n\n  	this.keypath = keypath;\n\n  	// If the new keypath exists, we need to register\n  	// with the viewmodel\n  	if (keypath != undefined) {\n  		// undefined or null\n  		value = this.root.viewmodel.get(keypath);\n  		this.root.viewmodel.register(keypath, this);\n\n  		this.registered = true;\n  	}\n\n  	// Either way we need to queue up a render (`value`\n  	// will be `undefined` if there\'s no keypath)\n  	this.setValue(value);\n\n  	// Two-way bindings need to point to their new target keypath\n  	if (wasResolved && (twowayBinding = this.twowayBinding)) {\n  		twowayBinding.rebound();\n  	}\n  }\n\n  var Mustache_rebind = Mustache$rebind;\n\n  function Mustache$rebind(oldKeypath, newKeypath) {\n  	// Children first\n  	if (this.fragments) {\n  		this.fragments.forEach(function (f) {\n  			return f.rebind(oldKeypath, newKeypath);\n  		});\n  	}\n\n  	// Expression mustache?\n  	if (this.resolver) {\n  		this.resolver.rebind(oldKeypath, newKeypath);\n  	}\n  }\n\n  var Mustache = {\n  	getValue: Mustache_getValue,\n  	init: Mustache_initialise,\n  	resolve: Mustache_resolve,\n  	rebind: Mustache_rebind\n  };\n\n  var Interpolator = function (options) {\n  	this.type = INTERPOLATOR;\n  	Mustache.init(this, options);\n  };\n\n  Interpolator.prototype = {\n  	update: function () {\n  		this.node.data = this.value == undefined ? "" : this.value;\n  	},\n  	resolve: Mustache.resolve,\n  	rebind: Mustache.rebind,\n  	detach: shared_detach,\n\n  	unbind: shared_unbind,\n\n  	render: function () {\n  		if (!this.node) {\n  			this.node = document.createTextNode(safeToStringValue(this.value));\n  		}\n\n  		return this.node;\n  	},\n\n  	unrender: function (shouldDestroy) {\n  		if (shouldDestroy) {\n  			detachNode(this.node);\n  		}\n  	},\n\n  	getValue: Mustache.getValue,\n\n  	// TEMP\n  	setValue: function (value) {\n  		var wrapper;\n\n  		// TODO is there a better way to approach this?\n  		if (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {\n  			value = wrapper.get();\n  		}\n\n  		if (!isEqual(value, this.value)) {\n  			this.value = value;\n  			this.parentFragment.bubble();\n\n  			if (this.node) {\n  				global_runloop.addView(this);\n  			}\n  		}\n  	},\n\n  	firstNode: function () {\n  		return this.node;\n  	},\n\n  	toString: function (escape) {\n  		var string = "" + safeToStringValue(this.value);\n  		return escape ? escapeHtml(string) : string;\n  	}\n  };\n\n  var items_Interpolator = Interpolator;\n\n  var Section_prototype_bubble = Section$bubble;\n\n  function Section$bubble() {\n  	this.parentFragment.bubble();\n  }\n\n  var Section_prototype_detach = Section$detach;\n\n  function Section$detach() {\n  	var docFrag;\n\n  	if (this.fragments.length === 1) {\n  		return this.fragments[0].detach();\n  	}\n\n  	docFrag = document.createDocumentFragment();\n\n  	this.fragments.forEach(function (item) {\n  		docFrag.appendChild(item.detach());\n  	});\n\n  	return docFrag;\n  }\n\n  var find = Section$find;\n\n  function Section$find(selector) {\n  	var i, len, queryResult;\n\n  	len = this.fragments.length;\n  	for (i = 0; i < len; i += 1) {\n  		if (queryResult = this.fragments[i].find(selector)) {\n  			return queryResult;\n  		}\n  	}\n\n  	return null;\n  }\n\n  var findAll = Section$findAll;\n\n  function Section$findAll(selector, query) {\n  	var i, len;\n\n  	len = this.fragments.length;\n  	for (i = 0; i < len; i += 1) {\n  		this.fragments[i].findAll(selector, query);\n  	}\n  }\n\n  var findAllComponents = Section$findAllComponents;\n\n  function Section$findAllComponents(selector, query) {\n  	var i, len;\n\n  	len = this.fragments.length;\n  	for (i = 0; i < len; i += 1) {\n  		this.fragments[i].findAllComponents(selector, query);\n  	}\n  }\n\n  var findComponent = Section$findComponent;\n\n  function Section$findComponent(selector) {\n  	var i, len, queryResult;\n\n  	len = this.fragments.length;\n  	for (i = 0; i < len; i += 1) {\n  		if (queryResult = this.fragments[i].findComponent(selector)) {\n  			return queryResult;\n  		}\n  	}\n\n  	return null;\n  }\n\n  var findNextNode = Section$findNextNode;\n\n  function Section$findNextNode(fragment) {\n  	if (this.fragments[fragment.index + 1]) {\n  		return this.fragments[fragment.index + 1].firstNode();\n  	}\n\n  	return this.parentFragment.findNextNode(this);\n  }\n\n  var firstNode = Section$firstNode;\n\n  function Section$firstNode() {\n  	var len, i, node;\n\n  	if (len = this.fragments.length) {\n  		for (i = 0; i < len; i += 1) {\n  			if (node = this.fragments[i].firstNode()) {\n  				return node;\n  			}\n  		}\n  	}\n\n  	return this.parentFragment.findNextNode(this);\n  }\n\n  var shuffle = Section$shuffle;\n\n  function Section$shuffle(newIndices) {\n  	var _this = this;\n\n  	var parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;\n\n  	// short circuit any double-updates, and ensure that this isn\'t applied to\n  	// non-list sections\n  	if (this.shuffling || this.unbound || this.currentSubtype !== SECTION_EACH) {\n  		return;\n  	}\n\n  	this.shuffling = true;\n  	global_runloop.scheduleTask(function () {\n  		return _this.shuffling = false;\n  	});\n\n  	parentFragment = this.parentFragment;\n\n  	reboundFragments = [];\n\n  	// TODO: need to update this\n  	// first, rebind existing fragments\n  	newIndices.forEach(function (newIndex, oldIndex) {\n  		var fragment, by, oldKeypath, newKeypath, deps;\n\n  		if (newIndex === oldIndex) {\n  			reboundFragments[newIndex] = _this.fragments[oldIndex];\n  			return;\n  		}\n\n  		fragment = _this.fragments[oldIndex];\n\n  		if (firstChange === undefined) {\n  			firstChange = oldIndex;\n  		}\n\n  		// does this fragment need to be torn down?\n  		if (newIndex === -1) {\n  			_this.fragmentsToUnrender.push(fragment);\n  			fragment.unbind();\n  			return;\n  		}\n\n  		// Otherwise, it needs to be rebound to a new index\n  		by = newIndex - oldIndex;\n  		oldKeypath = _this.keypath.join(oldIndex);\n  		newKeypath = _this.keypath.join(newIndex);\n\n  		fragment.index = newIndex;\n\n  		// notify any registered index refs directly\n  		if (deps = fragment.registeredIndexRefs) {\n  			deps.forEach(shuffle__blindRebind);\n  		}\n\n  		fragment.rebind(oldKeypath, newKeypath);\n  		reboundFragments[newIndex] = fragment;\n  	});\n\n  	newLength = this.root.viewmodel.get(this.keypath).length;\n\n  	// If nothing changed with the existing fragments, then we start adding\n  	// new fragments at the end...\n  	if (firstChange === undefined) {\n  		// ...unless there are no new fragments to add\n  		if (this.length === newLength) {\n  			return;\n  		}\n\n  		firstChange = this.length;\n  	}\n\n  	this.length = this.fragments.length = newLength;\n\n  	if (this.rendered) {\n  		global_runloop.addView(this);\n  	}\n\n  	// Prepare new fragment options\n  	fragmentOptions = {\n  		template: this.template.f,\n  		root: this.root,\n  		owner: this\n  	};\n\n  	// Add as many new fragments as we need to, or add back existing\n  	// (detached) fragments\n  	for (i = firstChange; i < newLength; i += 1) {\n  		fragment = reboundFragments[i];\n\n  		if (!fragment) {\n  			this.fragmentsToCreate.push(i);\n  		}\n\n  		this.fragments[i] = fragment;\n  	}\n  }\n\n  function shuffle__blindRebind(dep) {\n  	// the keypath doesn\'t actually matter here as it won\'t have changed\n  	dep.rebind("", "");\n  }\n\n  var prototype_rebind = function (oldKeypath, newKeypath) {\n  	Mustache.rebind.call(this, oldKeypath, newKeypath);\n  };\n\n  var Section_prototype_render = Section$render;\n\n  function Section$render() {\n  	var _this = this;\n\n  	this.docFrag = document.createDocumentFragment();\n\n  	this.fragments.forEach(function (f) {\n  		return _this.docFrag.appendChild(f.render());\n  	});\n\n  	this.renderedFragments = this.fragments.slice();\n  	this.fragmentsToRender = [];\n\n  	this.rendered = true;\n  	return this.docFrag;\n  }\n\n  var setValue = Section$setValue;\n\n  function Section$setValue(value) {\n  	var _this = this;\n\n  	var wrapper, fragmentOptions;\n\n  	if (this.updating) {\n  		// If a child of this section causes a re-evaluation - for example, an\n  		// expression refers to a function that mutates the array that this\n  		// section depends on - we\'ll end up with a double rendering bug (see\n  		// https://github.com/ractivejs/ractive/issues/748). This prevents it.\n  		return;\n  	}\n\n  	this.updating = true;\n\n  	// with sections, we need to get the fake value if we have a wrapped object\n  	if (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {\n  		value = wrapper.get();\n  	}\n\n  	// If any fragments are awaiting creation after a splice,\n  	// this is the place to do it\n  	if (this.fragmentsToCreate.length) {\n  		fragmentOptions = {\n  			template: this.template.f || [],\n  			root: this.root,\n  			pElement: this.pElement,\n  			owner: this\n  		};\n\n  		this.fragmentsToCreate.forEach(function (index) {\n  			var fragment;\n\n  			fragmentOptions.context = _this.keypath.join(index);\n  			fragmentOptions.index = index;\n\n  			fragment = new virtualdom_Fragment(fragmentOptions);\n  			_this.fragmentsToRender.push(_this.fragments[index] = fragment);\n  		});\n\n  		this.fragmentsToCreate.length = 0;\n  	} else if (reevaluateSection(this, value)) {\n  		this.bubble();\n\n  		if (this.rendered) {\n  			global_runloop.addView(this);\n  		}\n  	}\n\n  	this.value = value;\n  	this.updating = false;\n  }\n\n  function changeCurrentSubtype(section, value, obj) {\n  	if (value === SECTION_EACH) {\n  		// make sure ref type is up to date for key or value indices\n  		if (section.indexRefs && section.indexRefs[0]) {\n  			var ref = section.indexRefs[0];\n\n  			// when switching flavors, make sure the section gets updated\n  			if (obj && ref.t === "i" || !obj && ref.t === "k") {\n  				// if switching from object to list, unbind all of the old fragments\n  				if (!obj) {\n  					section.length = 0;\n  					section.fragmentsToUnrender = section.fragments.slice(0);\n  					section.fragmentsToUnrender.forEach(function (f) {\n  						return f.unbind();\n  					});\n  				}\n  			}\n\n  			ref.t = obj ? "k" : "i";\n  		}\n  	}\n\n  	section.currentSubtype = value;\n  }\n\n  function reevaluateSection(section, value) {\n  	var fragmentOptions = {\n  		template: section.template.f || [],\n  		root: section.root,\n  		pElement: section.parentFragment.pElement,\n  		owner: section\n  	};\n\n  	section.hasContext = true;\n\n  	// If we already know the section type, great\n  	// TODO can this be optimised? i.e. pick an reevaluateSection function during init\n  	// and avoid doing this each time?\n  	if (section.subtype) {\n  		switch (section.subtype) {\n  			case SECTION_IF:\n  				section.hasContext = false;\n  				return reevaluateConditionalSection(section, value, false, fragmentOptions);\n\n  			case SECTION_UNLESS:\n  				section.hasContext = false;\n  				return reevaluateConditionalSection(section, value, true, fragmentOptions);\n\n  			case SECTION_WITH:\n  				return reevaluateContextSection(section, fragmentOptions);\n\n  			case SECTION_IF_WITH:\n  				return reevaluateConditionalContextSection(section, value, fragmentOptions);\n\n  			case SECTION_EACH:\n  				if (isObject(value)) {\n  					changeCurrentSubtype(section, section.subtype, true);\n  					return reevaluateListObjectSection(section, value, fragmentOptions);\n  				}\n\n  				// Fallthrough - if it\'s a conditional or an array we need to continue\n  		}\n  	}\n\n  	// Otherwise we need to work out what sort of section we\'re dealing with\n  	section.ordered = !!isArrayLike(value);\n\n  	// Ordered list section\n  	if (section.ordered) {\n  		changeCurrentSubtype(section, SECTION_EACH, false);\n  		return reevaluateListSection(section, value, fragmentOptions);\n  	}\n\n  	// Unordered list, or context\n  	if (isObject(value) || typeof value === "function") {\n  		// Index reference indicates section should be treated as a list\n  		if (section.template.i) {\n  			changeCurrentSubtype(section, SECTION_EACH, true);\n  			return reevaluateListObjectSection(section, value, fragmentOptions);\n  		}\n\n  		// Otherwise, object provides context for contents\n  		changeCurrentSubtype(section, SECTION_WITH, false);\n  		return reevaluateContextSection(section, fragmentOptions);\n  	}\n\n  	// Conditional section\n  	changeCurrentSubtype(section, SECTION_IF, false);\n  	section.hasContext = false;\n  	return reevaluateConditionalSection(section, value, false, fragmentOptions);\n  }\n\n  function reevaluateListSection(section, value, fragmentOptions) {\n  	var i, length, fragment;\n\n  	length = value.length;\n\n  	if (length === section.length) {\n  		// Nothing to do\n  		return false;\n  	}\n\n  	// if the array is shorter than it was previously, remove items\n  	if (length < section.length) {\n  		section.fragmentsToUnrender = section.fragments.splice(length, section.length - length);\n  		section.fragmentsToUnrender.forEach(methodCallers__unbind);\n  	}\n\n  	// otherwise...\n  	else {\n  		if (length > section.length) {\n  			// add any new ones\n  			for (i = section.length; i < length; i += 1) {\n  				// append list item to context stack\n  				fragmentOptions.context = section.keypath.join(i);\n  				fragmentOptions.index = i;\n\n  				fragment = new virtualdom_Fragment(fragmentOptions);\n  				section.fragmentsToRender.push(section.fragments[i] = fragment);\n  			}\n  		}\n  	}\n\n  	section.length = length;\n  	return true;\n  }\n\n  function reevaluateListObjectSection(section, value, fragmentOptions) {\n  	var id, i, hasKey, fragment, changed, deps;\n\n  	hasKey = section.hasKey || (section.hasKey = {});\n\n  	// remove any fragments that should no longer exist\n  	i = section.fragments.length;\n  	while (i--) {\n  		fragment = section.fragments[i];\n\n  		if (!(fragment.key in value)) {\n  			changed = true;\n\n  			fragment.unbind();\n  			section.fragmentsToUnrender.push(fragment);\n  			section.fragments.splice(i, 1);\n\n  			hasKey[fragment.key] = false;\n  		}\n  	}\n\n  	// notify any dependents about changed indices\n  	i = section.fragments.length;\n  	while (i--) {\n  		fragment = section.fragments[i];\n\n  		if (fragment.index !== i) {\n  			fragment.index = i;\n  			if (deps = fragment.registeredIndexRefs) {\n  				deps.forEach(setValue__blindRebind);\n  			}\n  		}\n  	}\n\n  	// add any that haven\'t been created yet\n  	i = section.fragments.length;\n  	for (id in value) {\n  		if (!hasKey[id]) {\n  			changed = true;\n\n  			fragmentOptions.context = section.keypath.join(id);\n  			fragmentOptions.key = id;\n  			fragmentOptions.index = i++;\n\n  			fragment = new virtualdom_Fragment(fragmentOptions);\n\n  			section.fragmentsToRender.push(fragment);\n  			section.fragments.push(fragment);\n  			hasKey[id] = true;\n  		}\n  	}\n\n  	section.length = section.fragments.length;\n  	return changed;\n  }\n\n  function reevaluateConditionalContextSection(section, value, fragmentOptions) {\n  	if (value) {\n  		return reevaluateContextSection(section, fragmentOptions);\n  	} else {\n  		return removeSectionFragments(section);\n  	}\n  }\n\n  function reevaluateContextSection(section, fragmentOptions) {\n  	var fragment;\n\n  	// ...then if it isn\'t rendered, render it, adding section.keypath to the context stack\n  	// (if it is already rendered, then any children dependent on the context stack\n  	// will update themselves without any prompting)\n  	if (!section.length) {\n  		// append this section to the context stack\n  		fragmentOptions.context = section.keypath;\n  		fragmentOptions.index = 0;\n\n  		fragment = new virtualdom_Fragment(fragmentOptions);\n\n  		section.fragmentsToRender.push(section.fragments[0] = fragment);\n  		section.length = 1;\n\n  		return true;\n  	}\n  }\n\n  function reevaluateConditionalSection(section, value, inverted, fragmentOptions) {\n  	var doRender, emptyArray, emptyObject, fragment, name;\n\n  	emptyArray = isArrayLike(value) && value.length === 0;\n  	emptyObject = false;\n  	if (!isArrayLike(value) && isObject(value)) {\n  		emptyObject = true;\n  		for (name in value) {\n  			emptyObject = false;\n  			break;\n  		}\n  	}\n\n  	if (inverted) {\n  		doRender = emptyArray || emptyObject || !value;\n  	} else {\n  		doRender = value && !emptyArray && !emptyObject;\n  	}\n\n  	if (doRender) {\n  		if (!section.length) {\n  			// no change to context stack\n  			fragmentOptions.index = 0;\n\n  			fragment = new virtualdom_Fragment(fragmentOptions);\n  			section.fragmentsToRender.push(section.fragments[0] = fragment);\n  			section.length = 1;\n\n  			return true;\n  		}\n\n  		if (section.length > 1) {\n  			section.fragmentsToUnrender = section.fragments.splice(1);\n  			section.fragmentsToUnrender.forEach(methodCallers__unbind);\n\n  			return true;\n  		}\n  	} else {\n  		return removeSectionFragments(section);\n  	}\n  }\n\n  function removeSectionFragments(section) {\n  	if (section.length) {\n  		section.fragmentsToUnrender = section.fragments.splice(0, section.fragments.length).filter(isRendered);\n  		section.fragmentsToUnrender.forEach(methodCallers__unbind);\n  		section.length = section.fragmentsToRender.length = 0;\n  		return true;\n  	}\n  }\n\n  function isRendered(fragment) {\n  	return fragment.rendered;\n  }\n\n  function setValue__blindRebind(dep) {\n  	// the keypath doesn\'t actually matter here as it won\'t have changed\n  	dep.rebind("", "");\n  }\n\n  var prototype_toString = Section$toString;\n\n  function Section$toString(escape) {\n  	var str, i, len;\n\n  	str = "";\n\n  	i = 0;\n  	len = this.length;\n\n  	for (i = 0; i < len; i += 1) {\n  		str += this.fragments[i].toString(escape);\n  	}\n\n  	return str;\n  }\n\n  var prototype_unbind = Section$unbind;\n  function Section$unbind() {\n  	var _this = this;\n\n  	this.fragments.forEach(methodCallers__unbind);\n  	this.fragmentsToRender.forEach(function (f) {\n  		return removeFromArray(_this.fragments, f);\n  	});\n  	this.fragmentsToRender = [];\n  	shared_unbind.call(this);\n\n  	this.length = 0;\n  	this.unbound = true;\n  }\n\n  var prototype_unrender = Section$unrender;\n\n  function Section$unrender(shouldDestroy) {\n  	this.fragments.forEach(shouldDestroy ? unrenderAndDestroy : prototype_unrender__unrender);\n  	this.renderedFragments = [];\n  	this.rendered = false;\n  }\n\n  function unrenderAndDestroy(fragment) {\n  	fragment.unrender(true);\n  }\n\n  function prototype_unrender__unrender(fragment) {\n  	fragment.unrender(false);\n  }\n\n  var prototype_update = Section$update;\n\n  function Section$update() {\n  	var fragment, renderIndex, renderedFragments, anchor, target, i, len;\n\n  	// `this.renderedFragments` is in the order of the previous render.\n  	// If fragments have shuffled about, this allows us to quickly\n  	// reinsert them in the correct place\n  	renderedFragments = this.renderedFragments;\n\n  	// Remove fragments that have been marked for destruction\n  	while (fragment = this.fragmentsToUnrender.pop()) {\n  		fragment.unrender(true);\n  		renderedFragments.splice(renderedFragments.indexOf(fragment), 1);\n  	}\n\n  	// Render new fragments (but don\'t insert them yet)\n  	while (fragment = this.fragmentsToRender.shift()) {\n  		fragment.render();\n  	}\n\n  	if (this.rendered) {\n  		target = this.parentFragment.getNode();\n  	}\n\n  	len = this.fragments.length;\n  	for (i = 0; i < len; i += 1) {\n  		fragment = this.fragments[i];\n  		renderIndex = renderedFragments.indexOf(fragment, i); // search from current index - it\'s guaranteed to be the same or higher\n\n  		if (renderIndex === i) {\n  			// already in the right place. insert accumulated nodes (if any) and carry on\n  			if (this.docFrag.childNodes.length) {\n  				anchor = fragment.firstNode();\n  				target.insertBefore(this.docFrag, anchor);\n  			}\n\n  			continue;\n  		}\n\n  		this.docFrag.appendChild(fragment.detach());\n\n  		// update renderedFragments\n  		if (renderIndex !== -1) {\n  			renderedFragments.splice(renderIndex, 1);\n  		}\n  		renderedFragments.splice(i, 0, fragment);\n  	}\n\n  	if (this.rendered && this.docFrag.childNodes.length) {\n  		anchor = this.parentFragment.findNextNode(this);\n  		target.insertBefore(this.docFrag, anchor);\n  	}\n\n  	// Save the rendering order for next time\n  	this.renderedFragments = this.fragments.slice();\n  }\n\n  var Section = function (options) {\n  	this.type = SECTION;\n  	this.subtype = this.currentSubtype = options.template.n;\n  	this.inverted = this.subtype === SECTION_UNLESS;\n\n  	this.pElement = options.pElement;\n\n  	this.fragments = [];\n  	this.fragmentsToCreate = [];\n  	this.fragmentsToRender = [];\n  	this.fragmentsToUnrender = [];\n\n  	if (options.template.i) {\n  		this.indexRefs = options.template.i.split(",").map(function (k, i) {\n  			return { n: k, t: i === 0 ? "k" : "i" };\n  		});\n  	}\n\n  	this.renderedFragments = [];\n\n  	this.length = 0; // number of times this section is rendered\n\n  	Mustache.init(this, options);\n  };\n\n  Section.prototype = {\n  	bubble: Section_prototype_bubble,\n  	detach: Section_prototype_detach,\n  	find: find,\n  	findAll: findAll,\n  	findAllComponents: findAllComponents,\n  	findComponent: findComponent,\n  	findNextNode: findNextNode,\n  	firstNode: firstNode,\n  	getIndexRef: function (name) {\n  		if (this.indexRefs) {\n  			var i = this.indexRefs.length;\n  			while (i--) {\n  				var ref = this.indexRefs[i];\n  				if (ref.n === name) {\n  					return ref;\n  				}\n  			}\n  		}\n  	},\n  	getValue: Mustache.getValue,\n  	shuffle: shuffle,\n  	rebind: prototype_rebind,\n  	render: Section_prototype_render,\n  	resolve: Mustache.resolve,\n  	setValue: setValue,\n  	toString: prototype_toString,\n  	unbind: prototype_unbind,\n  	unrender: prototype_unrender,\n  	update: prototype_update\n  };\n\n  var _Section = Section;\n\n  var Triple_prototype_detach = Triple$detach;\n\n  function Triple$detach() {\n  	var len, i;\n\n  	if (this.docFrag) {\n  		len = this.nodes.length;\n  		for (i = 0; i < len; i += 1) {\n  			this.docFrag.appendChild(this.nodes[i]);\n  		}\n\n  		return this.docFrag;\n  	}\n  }\n\n  var Triple_prototype_find = Triple$find;\n  function Triple$find(selector) {\n  	var i, len, node, queryResult;\n\n  	len = this.nodes.length;\n  	for (i = 0; i < len; i += 1) {\n  		node = this.nodes[i];\n\n  		if (node.nodeType !== 1) {\n  			continue;\n  		}\n\n  		if (matches(node, selector)) {\n  			return node;\n  		}\n\n  		if (queryResult = node.querySelector(selector)) {\n  			return queryResult;\n  		}\n  	}\n\n  	return null;\n  }\n\n  var Triple_prototype_findAll = Triple$findAll;\n  function Triple$findAll(selector, queryResult) {\n  	var i, len, node, queryAllResult, numNodes, j;\n\n  	len = this.nodes.length;\n  	for (i = 0; i < len; i += 1) {\n  		node = this.nodes[i];\n\n  		if (node.nodeType !== 1) {\n  			continue;\n  		}\n\n  		if (matches(node, selector)) {\n  			queryResult.push(node);\n  		}\n\n  		if (queryAllResult = node.querySelectorAll(selector)) {\n  			numNodes = queryAllResult.length;\n  			for (j = 0; j < numNodes; j += 1) {\n  				queryResult.push(queryAllResult[j]);\n  			}\n  		}\n  	}\n  }\n\n  var Triple_prototype_firstNode = Triple$firstNode;\n\n  function Triple$firstNode() {\n  	if (this.rendered && this.nodes[0]) {\n  		return this.nodes[0];\n  	}\n\n  	return this.parentFragment.findNextNode(this);\n  }\n\n  var elementCache = {},\n      ieBug,\n      ieBlacklist;\n\n  try {\n  	createElement("table").innerHTML = "foo";\n  } catch (err) {\n  	ieBug = true;\n\n  	ieBlacklist = {\n  		TABLE: ["<table class=\\"x\\">", "</table>"],\n  		THEAD: ["<table><thead class=\\"x\\">", "</thead></table>"],\n  		TBODY: ["<table><tbody class=\\"x\\">", "</tbody></table>"],\n  		TR: ["<table><tr class=\\"x\\">", "</tr></table>"],\n  		SELECT: ["<select class=\\"x\\">", "</select>"]\n  	};\n  }\n\n  var insertHtml = function (html, node, docFrag) {\n  	var container,\n  	    nodes = [],\n  	    wrapper,\n  	    selectedOption,\n  	    child,\n  	    i;\n\n  	// render 0 and false\n  	if (html != null && html !== "") {\n  		if (ieBug && (wrapper = ieBlacklist[node.tagName])) {\n  			container = element("DIV");\n  			container.innerHTML = wrapper[0] + html + wrapper[1];\n  			container = container.querySelector(".x");\n\n  			if (container.tagName === "SELECT") {\n  				selectedOption = container.options[container.selectedIndex];\n  			}\n  		} else if (node.namespaceURI === namespaces.svg) {\n  			container = element("DIV");\n  			container.innerHTML = "<svg class=\\"x\\">" + html + "</svg>";\n  			container = container.querySelector(".x");\n  		} else {\n  			container = element(node.tagName);\n  			container.innerHTML = html;\n\n  			if (container.tagName === "SELECT") {\n  				selectedOption = container.options[container.selectedIndex];\n  			}\n  		}\n\n  		while (child = container.firstChild) {\n  			nodes.push(child);\n  			docFrag.appendChild(child);\n  		}\n\n  		// This is really annoying. Extracting <option> nodes from the\n  		// temporary container <select> causes the remaining ones to\n  		// become selected. So now we have to deselect them. IE8, you\n  		// amaze me. You really do\n  		// ...and now Chrome too\n  		if (node.tagName === "SELECT") {\n  			i = nodes.length;\n  			while (i--) {\n  				if (nodes[i] !== selectedOption) {\n  					nodes[i].selected = false;\n  				}\n  			}\n  		}\n  	}\n\n  	return nodes;\n  };\n\n  function element(tagName) {\n  	return elementCache[tagName] || (elementCache[tagName] = createElement(tagName));\n  }\n\n  var helpers_updateSelect = updateSelect;\n\n  function updateSelect(parentElement) {\n  	var selectedOptions, option, value;\n\n  	if (!parentElement || parentElement.name !== "select" || !parentElement.binding) {\n  		return;\n  	}\n\n  	selectedOptions = toArray(parentElement.node.options).filter(isSelected);\n\n  	// If one of them had a `selected` attribute, we need to sync\n  	// the model to the view\n  	if (parentElement.getAttribute("multiple")) {\n  		value = selectedOptions.map(function (o) {\n  			return o.value;\n  		});\n  	} else if (option = selectedOptions[0]) {\n  		value = option.value;\n  	}\n\n  	if (value !== undefined) {\n  		parentElement.binding.setValue(value);\n  	}\n\n  	parentElement.bubble();\n  }\n\n  function isSelected(option) {\n  	return option.selected;\n  }\n\n  var Triple_prototype_render = Triple$render;\n  function Triple$render() {\n  	if (this.rendered) {\n  		throw new Error("Attempted to render an item that was already rendered");\n  	}\n\n  	this.docFrag = document.createDocumentFragment();\n  	this.nodes = insertHtml(this.value, this.parentFragment.getNode(), this.docFrag);\n\n  	// Special case - we\'re inserting the contents of a <select>\n  	helpers_updateSelect(this.pElement);\n\n  	this.rendered = true;\n  	return this.docFrag;\n  }\n\n  var prototype_setValue = Triple$setValue;\n  function Triple$setValue(value) {\n  	var wrapper;\n\n  	// TODO is there a better way to approach this?\n  	if (wrapper = this.root.viewmodel.wrapped[this.keypath.str]) {\n  		value = wrapper.get();\n  	}\n\n  	if (value !== this.value) {\n  		this.value = value;\n  		this.parentFragment.bubble();\n\n  		if (this.rendered) {\n  			global_runloop.addView(this);\n  		}\n  	}\n  }\n\n  var Triple_prototype_toString = Triple$toString;\n  function Triple$toString() {\n  	return this.value != undefined ? decodeCharacterReferences("" + this.value) : "";\n  }\n\n  var Triple_prototype_unrender = Triple$unrender;\n  function Triple$unrender(shouldDestroy) {\n  	if (this.rendered && shouldDestroy) {\n  		this.nodes.forEach(detachNode);\n  		this.rendered = false;\n  	}\n\n  	// TODO update live queries\n  }\n\n  var Triple_prototype_update = Triple$update;\n  function Triple$update() {\n  	var node, parentNode;\n\n  	if (!this.rendered) {\n  		return;\n  	}\n\n  	// Remove existing nodes\n  	while (this.nodes && this.nodes.length) {\n  		node = this.nodes.pop();\n  		node.parentNode.removeChild(node);\n  	}\n\n  	// Insert new nodes\n  	parentNode = this.parentFragment.getNode();\n\n  	this.nodes = insertHtml(this.value, parentNode, this.docFrag);\n  	parentNode.insertBefore(this.docFrag, this.parentFragment.findNextNode(this));\n\n  	// Special case - we\'re inserting the contents of a <select>\n  	helpers_updateSelect(this.pElement);\n  }\n\n  var Triple = function (options) {\n  	this.type = TRIPLE;\n  	Mustache.init(this, options);\n  };\n\n  Triple.prototype = {\n  	detach: Triple_prototype_detach,\n  	find: Triple_prototype_find,\n  	findAll: Triple_prototype_findAll,\n  	firstNode: Triple_prototype_firstNode,\n  	getValue: Mustache.getValue,\n  	rebind: Mustache.rebind,\n  	render: Triple_prototype_render,\n  	resolve: Mustache.resolve,\n  	setValue: prototype_setValue,\n  	toString: Triple_prototype_toString,\n  	unbind: shared_unbind,\n  	unrender: Triple_prototype_unrender,\n  	update: Triple_prototype_update\n  };\n\n  var _Triple = Triple;\n\n  var Element_prototype_bubble = function () {\n  	this.parentFragment.bubble();\n  };\n\n  var Element_prototype_detach = Element$detach;\n\n  function Element$detach() {\n  	var node = this.node,\n  	    parentNode;\n\n  	if (node) {\n  		// need to check for parent node - DOM may have been altered\n  		// by something other than Ractive! e.g. jQuery UI...\n  		if (parentNode = node.parentNode) {\n  			parentNode.removeChild(node);\n  		}\n\n  		return node;\n  	}\n  }\n\n  var Element_prototype_find = function (selector) {\n  	if (!this.node) {\n  		// this element hasn\'t been rendered yet\n  		return null;\n  	}\n\n  	if (matches(this.node, selector)) {\n  		return this.node;\n  	}\n\n  	if (this.fragment && this.fragment.find) {\n  		return this.fragment.find(selector);\n  	}\n  };\n\n  var Element_prototype_findAll = function (selector, query) {\n  	// Add this node to the query, if applicable, and register the\n  	// query on this element\n  	if (query._test(this, true) && query.live) {\n  		(this.liveQueries || (this.liveQueries = [])).push(query);\n  	}\n\n  	if (this.fragment) {\n  		this.fragment.findAll(selector, query);\n  	}\n  };\n\n  var Element_prototype_findAllComponents = function (selector, query) {\n  	if (this.fragment) {\n  		this.fragment.findAllComponents(selector, query);\n  	}\n  };\n\n  var Element_prototype_findComponent = function (selector) {\n  	if (this.fragment) {\n  		return this.fragment.findComponent(selector);\n  	}\n  };\n\n  var Element_prototype_findNextNode = Element$findNextNode;\n\n  function Element$findNextNode() {\n  	return null;\n  }\n\n  var Element_prototype_firstNode = Element$firstNode;\n\n  function Element$firstNode() {\n  	return this.node;\n  }\n\n  var getAttribute = Element$getAttribute;\n\n  function Element$getAttribute(name) {\n  	if (!this.attributes || !this.attributes[name]) {\n  		return;\n  	}\n\n  	return this.attributes[name].value;\n  }\n\n  var truthy = /^true|on|yes|1$/i;\n  var processBindingAttributes__isNumeric = /^[0-9]+$/;\n\n  var processBindingAttributes = function (element, template) {\n  	var val, attrs, attributes;\n\n  	attributes = template.a || {};\n  	attrs = {};\n\n  	// attributes that are present but don\'t have a value (=)\n  	// will be set to the number 0, which we condider to be true\n  	// the string \'0\', however is false\n\n  	val = attributes.twoway;\n  	if (val !== undefined) {\n  		attrs.twoway = val === 0 || truthy.test(val);\n  	}\n\n  	val = attributes.lazy;\n  	if (val !== undefined) {\n  		// check for timeout value\n  		if (val !== 0 && processBindingAttributes__isNumeric.test(val)) {\n  			attrs.lazy = parseInt(val);\n  		} else {\n  			attrs.lazy = val === 0 || truthy.test(val);\n  		}\n  	}\n\n  	return attrs;\n  };\n\n  var Attribute_prototype_bubble = Attribute$bubble;\n  function Attribute$bubble() {\n  	var value = this.useProperty || !this.rendered ? this.fragment.getValue() : this.fragment.toString();\n\n  	// TODO this can register the attribute multiple times (see render test\n  	// \'Attribute with nested mustaches\')\n  	if (!isEqual(value, this.value)) {\n\n  		// Need to clear old id from ractive.nodes\n  		if (this.name === "id" && this.value) {\n  			delete this.root.nodes[this.value];\n  		}\n\n  		this.value = value;\n\n  		if (this.name === "value" && this.node) {\n  			// We need to store the value on the DOM like this so we\n  			// can retrieve it later without it being coerced to a string\n  			this.node._ractive.value = value;\n  		}\n\n  		if (this.rendered) {\n  			global_runloop.addView(this);\n  		}\n  	}\n  }\n\n  var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;\n  svgCamelCaseElements = "altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern".split(" ");\n  svgCamelCaseAttributes = "attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan".split(" ");\n\n  createMap = function (items) {\n  	var map = {},\n  	    i = items.length;\n  	while (i--) {\n  		map[items[i].toLowerCase()] = items[i];\n  	}\n  	return map;\n  };\n\n  map = createMap(svgCamelCaseElements.concat(svgCamelCaseAttributes));\n\n  var enforceCase = function (elementName) {\n  	var lowerCaseElementName = elementName.toLowerCase();\n  	return map[lowerCaseElementName] || lowerCaseElementName;\n  };\n\n  var determineNameAndNamespace = function (attribute, name) {\n  	var colonIndex, namespacePrefix;\n\n  	// are we dealing with a namespaced attribute, e.g. xlink:href?\n  	colonIndex = name.indexOf(":");\n  	if (colonIndex !== -1) {\n\n  		// looks like we are, yes...\n  		namespacePrefix = name.substr(0, colonIndex);\n\n  		// ...unless it\'s a namespace *declaration*, which we ignore (on the assumption\n  		// that only valid namespaces will be used)\n  		if (namespacePrefix !== "xmlns") {\n  			name = name.substring(colonIndex + 1);\n\n  			attribute.name = enforceCase(name);\n  			attribute.namespace = namespaces[namespacePrefix.toLowerCase()];\n  			attribute.namespacePrefix = namespacePrefix;\n\n  			if (!attribute.namespace) {\n  				throw "Unknown namespace (\\"" + namespacePrefix + "\\")";\n  			}\n\n  			return;\n  		}\n  	}\n\n  	// SVG attribute names are case sensitive\n  	attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase(name) : name;\n  };\n\n  var helpers_getInterpolator = getInterpolator;\n  function getInterpolator(attribute) {\n  	var items = attribute.fragment.items;\n\n  	if (items.length !== 1) {\n  		return;\n  	}\n\n  	if (items[0].type === INTERPOLATOR) {\n  		return items[0];\n  	}\n  }\n\n  var prototype_init = Attribute$init;\n  function Attribute$init(options) {\n  	this.type = ATTRIBUTE;\n  	this.element = options.element;\n  	this.root = options.root;\n\n  	determineNameAndNamespace(this, options.name);\n  	this.isBoolean = booleanAttributes.test(this.name);\n\n  	// if it\'s an empty attribute, or just a straight key-value pair, with no\n  	// mustache shenanigans, set the attribute accordingly and go home\n  	if (!options.value || typeof options.value === "string") {\n  		this.value = this.isBoolean ? true : options.value || "";\n  		return;\n  	}\n\n  	// otherwise we need to do some work\n\n  	// share parentFragment with parent element\n  	this.parentFragment = this.element.parentFragment;\n\n  	this.fragment = new virtualdom_Fragment({\n  		template: options.value,\n  		root: this.root,\n  		owner: this\n  	});\n\n  	// TODO can we use this.fragment.toString() in some cases? It\'s quicker\n  	this.value = this.fragment.getValue();\n\n  	// Store a reference to this attribute\'s interpolator, if its fragment\n  	// takes the form `{{foo}}`. This is necessary for two-way binding and\n  	// for correctly rendering HTML later\n  	this.interpolator = helpers_getInterpolator(this);\n  	this.isBindable = !!this.interpolator && !this.interpolator.isStatic;\n\n  	// mark as ready\n  	this.ready = true;\n  }\n\n  var Attribute_prototype_rebind = Attribute$rebind;\n\n  function Attribute$rebind(oldKeypath, newKeypath) {\n  	if (this.fragment) {\n  		this.fragment.rebind(oldKeypath, newKeypath);\n  	}\n  }\n\n  var Attribute_prototype_render = Attribute$render;\n  var propertyNames = {\n  	"accept-charset": "acceptCharset",\n  	accesskey: "accessKey",\n  	bgcolor: "bgColor",\n  	"class": "className",\n  	codebase: "codeBase",\n  	colspan: "colSpan",\n  	contenteditable: "contentEditable",\n  	datetime: "dateTime",\n  	dirname: "dirName",\n  	"for": "htmlFor",\n  	"http-equiv": "httpEquiv",\n  	ismap: "isMap",\n  	maxlength: "maxLength",\n  	novalidate: "noValidate",\n  	pubdate: "pubDate",\n  	readonly: "readOnly",\n  	rowspan: "rowSpan",\n  	tabindex: "tabIndex",\n  	usemap: "useMap"\n  };\n  function Attribute$render(node) {\n  	var propertyName;\n\n  	this.node = node;\n\n  	// should we use direct property access, or setAttribute?\n  	if (!node.namespaceURI || node.namespaceURI === namespaces.html) {\n  		propertyName = propertyNames[this.name] || this.name;\n\n  		if (node[propertyName] !== undefined) {\n  			this.propertyName = propertyName;\n  		}\n\n  		// is attribute a boolean attribute or \'value\'? If so we\'re better off doing e.g.\n  		// node.selected = true rather than node.setAttribute( \'selected\', \'\' )\n  		if (this.isBoolean || this.isTwoway) {\n  			this.useProperty = true;\n  		}\n\n  		if (propertyName === "value") {\n  			node._ractive.value = this.value;\n  		}\n  	}\n\n  	this.rendered = true;\n  	this.update();\n  }\n\n  var Attribute_prototype_toString = Attribute$toString;\n\n  function Attribute$toString() {\n  	var _ref = this;\n\n  	var name = _ref.name;\n  	var namespacePrefix = _ref.namespacePrefix;\n  	var value = _ref.value;\n  	var interpolator = _ref.interpolator;\n  	var fragment = _ref.fragment;\n\n  	// Special case - select and textarea values (should not be stringified)\n  	if (name === "value" && (this.element.name === "select" || this.element.name === "textarea")) {\n  		return;\n  	}\n\n  	// Special case - content editable\n  	if (name === "value" && this.element.getAttribute("contenteditable") !== undefined) {\n  		return;\n  	}\n\n  	// Special case - radio names\n  	if (name === "name" && this.element.name === "input" && interpolator) {\n  		return "name={{" + (interpolator.keypath.str || interpolator.ref) + "}}";\n  	}\n\n  	// Boolean attributes\n  	if (this.isBoolean) {\n  		return value ? name : "";\n  	}\n\n  	if (fragment) {\n  		// special case - this catches undefined/null values (#1211)\n  		if (fragment.items.length === 1 && fragment.items[0].value == null) {\n  			return "";\n  		}\n\n  		value = fragment.toString();\n  	}\n\n  	if (namespacePrefix) {\n  		name = namespacePrefix + ":" + name;\n  	}\n\n  	return value ? name + "=\\"" + Attribute_prototype_toString__escape(value) + "\\"" : name;\n  }\n\n  function Attribute_prototype_toString__escape(value) {\n  	return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/\'/g, "&#39;");\n  }\n\n  var Attribute_prototype_unbind = Attribute$unbind;\n\n  function Attribute$unbind() {\n  	// ignore non-dynamic attributes\n  	if (this.fragment) {\n  		this.fragment.unbind();\n  	}\n\n  	if (this.name === "id") {\n  		delete this.root.nodes[this.value];\n  	}\n  }\n\n  var updateSelectValue = Attribute$updateSelect;\n\n  function Attribute$updateSelect() {\n  	var value = this.value,\n  	    options,\n  	    option,\n  	    optionValue,\n  	    i;\n\n  	if (!this.locked) {\n  		this.node._ractive.value = value;\n\n  		options = this.node.options;\n  		i = options.length;\n\n  		while (i--) {\n  			option = options[i];\n  			optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don\'t have _ractive\n\n  			if (optionValue == value) {\n  				// double equals as we may be comparing numbers with strings\n  				option.selected = true;\n  				break;\n  			}\n  		}\n  	}\n\n  	// if we\'re still here, it means the new value didn\'t match any of the options...\n  	// TODO figure out what to do in this situation\n  }\n\n  var updateMultipleSelectValue = Attribute$updateMultipleSelect;\n  function Attribute$updateMultipleSelect() {\n  	var value = this.value,\n  	    options,\n  	    i,\n  	    option,\n  	    optionValue;\n\n  	if (!isArray(value)) {\n  		value = [value];\n  	}\n\n  	options = this.node.options;\n  	i = options.length;\n\n  	while (i--) {\n  		option = options[i];\n  		optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don\'t have _ractive\n  		option.selected = arrayContains(value, optionValue);\n  	}\n  }\n\n  var updateRadioName = Attribute$updateRadioName;\n\n  function Attribute$updateRadioName() {\n  	var _ref = this;\n\n  	var node = _ref.node;\n  	var value = _ref.value;\n\n  	node.checked = value == node._ractive.value;\n  }\n\n  var updateRadioValue = Attribute$updateRadioValue;\n  function Attribute$updateRadioValue() {\n  	var wasChecked,\n  	    node = this.node,\n  	    binding,\n  	    bindings,\n  	    i;\n\n  	wasChecked = node.checked;\n\n  	node.value = this.element.getAttribute("value");\n  	node.checked = this.element.getAttribute("value") === this.element.getAttribute("name");\n\n  	// This is a special case - if the input was checked, and the value\n  	// changed so that it\'s no longer checked, the twoway binding is\n  	// most likely out of date. To fix it we have to jump through some\n  	// hoops... this is a little kludgy but it works\n  	if (wasChecked && !node.checked && this.element.binding) {\n  		bindings = this.element.binding.siblings;\n\n  		if (i = bindings.length) {\n  			while (i--) {\n  				binding = bindings[i];\n\n  				if (!binding.element.node) {\n  					// this is the initial render, siblings are still rendering!\n  					// we\'ll come back later...\n  					return;\n  				}\n\n  				if (binding.element.node.checked) {\n  					global_runloop.addRactive(binding.root);\n  					return binding.handleChange();\n  				}\n  			}\n\n  			this.root.viewmodel.set(binding.keypath, undefined);\n  		}\n  	}\n  }\n\n  var updateCheckboxName = Attribute$updateCheckboxName;\n  function Attribute$updateCheckboxName() {\n  	var _ref = this;\n\n  	var element = _ref.element;\n  	var node = _ref.node;\n  	var value = _ref.value;var binding = element.binding;var valueAttribute;var i;\n\n  	valueAttribute = element.getAttribute("value");\n\n  	if (!isArray(value)) {\n  		binding.isChecked = node.checked = value == valueAttribute;\n  	} else {\n  		i = value.length;\n  		while (i--) {\n  			if (valueAttribute == value[i]) {\n  				binding.isChecked = node.checked = true;\n  				return;\n  			}\n  		}\n  		binding.isChecked = node.checked = false;\n  	}\n  }\n\n  var updateClassName = Attribute$updateClassName;\n  function Attribute$updateClassName() {\n  	this.node.className = safeToStringValue(this.value);\n  }\n\n  var updateIdAttribute = Attribute$updateIdAttribute;\n\n  function Attribute$updateIdAttribute() {\n  	var _ref = this;\n\n  	var node = _ref.node;\n  	var value = _ref.value;\n\n  	this.root.nodes[value] = node;\n  	node.id = value;\n  }\n\n  var updateIEStyleAttribute = Attribute$updateIEStyleAttribute;\n\n  function Attribute$updateIEStyleAttribute() {\n  	var node, value;\n\n  	node = this.node;\n  	value = this.value;\n\n  	if (value === undefined) {\n  		value = "";\n  	}\n\n  	node.style.setAttribute("cssText", value);\n  }\n\n  var updateContentEditableValue = Attribute$updateContentEditableValue;\n\n  function Attribute$updateContentEditableValue() {\n  	var value = this.value;\n\n  	if (value === undefined) {\n  		value = "";\n  	}\n\n  	if (!this.locked) {\n  		this.node.innerHTML = value;\n  	}\n  }\n\n  var updateValue = Attribute$updateValue;\n\n  function Attribute$updateValue() {\n  	var _ref = this;\n\n  	var node = _ref.node;\n  	var value = _ref.value;\n\n  	// store actual value, so it doesn\'t get coerced to a string\n  	node._ractive.value = value;\n\n  	// with two-way binding, only update if the change wasn\'t initiated by the user\n  	// otherwise the cursor will often be sent to the wrong place\n  	if (!this.locked) {\n  		node.value = value == undefined ? "" : value;\n  	}\n  }\n\n  var updateBoolean = Attribute$updateBooleanAttribute;\n\n  function Attribute$updateBooleanAttribute() {\n  	// with two-way binding, only update if the change wasn\'t initiated by the user\n  	// otherwise the cursor will often be sent to the wrong place\n  	if (!this.locked) {\n  		this.node[this.propertyName] = this.value;\n  	}\n  }\n\n  var updateEverythingElse = Attribute$updateEverythingElse;\n\n  function Attribute$updateEverythingElse() {\n  	var _ref = this;\n\n  	var node = _ref.node;\n  	var namespace = _ref.namespace;\n  	var name = _ref.name;\n  	var value = _ref.value;\n  	var fragment = _ref.fragment;\n\n  	if (namespace) {\n  		node.setAttributeNS(namespace, name, (fragment || value).toString());\n  	} else if (!this.isBoolean) {\n  		if (value == null) {\n  			node.removeAttribute(name);\n  		} else {\n  			node.setAttribute(name, (fragment || value).toString());\n  		}\n  	}\n\n  	// Boolean attributes - truthy becomes \'\', falsy means \'remove attribute\'\n  	else {\n  		if (value) {\n  			node.setAttribute(name, "");\n  		} else {\n  			node.removeAttribute(name);\n  		}\n  	}\n  }\n\n  // There are a few special cases when it comes to updating attributes. For this reason,\n  // the prototype .update() method points to this method, which waits until the\n  // attribute has finished initialising, then replaces the prototype method with a more\n  // suitable one. That way, we save ourselves doing a bunch of tests on each call\n  var Attribute_prototype_update = Attribute$update;\n  function Attribute$update() {\n  	var _ref = this;\n\n  	var name = _ref.name;\n  	var element = _ref.element;\n  	var node = _ref.node;var type;var updateMethod;\n\n  	if (name === "id") {\n  		updateMethod = updateIdAttribute;\n  	} else if (name === "value") {\n  		// special case - selects\n  		if (element.name === "select" && name === "value") {\n  			updateMethod = element.getAttribute("multiple") ? updateMultipleSelectValue : updateSelectValue;\n  		} else if (element.name === "textarea") {\n  			updateMethod = updateValue;\n  		}\n\n  		// special case - contenteditable\n  		else if (element.getAttribute("contenteditable") != null) {\n  			updateMethod = updateContentEditableValue;\n  		}\n\n  		// special case - <input>\n  		else if (element.name === "input") {\n  			type = element.getAttribute("type");\n\n  			// type=\'file\' value=\'{{fileList}}\'>\n  			if (type === "file") {\n  				updateMethod = noop; // read-only\n  			}\n\n  			// type=\'radio\' name=\'{{twoway}}\'\n  			else if (type === "radio" && element.binding && element.binding.name === "name") {\n  				updateMethod = updateRadioValue;\n  			} else {\n  				updateMethod = updateValue;\n  			}\n  		}\n  	}\n\n  	// special case - <input type=\'radio\' name=\'{{twoway}}\' value=\'foo\'>\n  	else if (this.isTwoway && name === "name") {\n  		if (node.type === "radio") {\n  			updateMethod = updateRadioName;\n  		} else if (node.type === "checkbox") {\n  			updateMethod = updateCheckboxName;\n  		}\n  	}\n\n  	// special case - style attributes in Internet Exploder\n  	else if (name === "style" && node.style.setAttribute) {\n  		updateMethod = updateIEStyleAttribute;\n  	}\n\n  	// special case - class names. IE fucks things up, again\n  	else if (name === "class" && (!node.namespaceURI || node.namespaceURI === namespaces.html)) {\n  		updateMethod = updateClassName;\n  	} else if (this.useProperty) {\n  		updateMethod = updateBoolean;\n  	}\n\n  	if (!updateMethod) {\n  		updateMethod = updateEverythingElse;\n  	}\n\n  	this.update = updateMethod;\n  	this.update();\n  }\n\n  var Attribute = function (options) {\n  	this.init(options);\n  };\n\n  Attribute.prototype = {\n  	bubble: Attribute_prototype_bubble,\n  	init: prototype_init,\n  	rebind: Attribute_prototype_rebind,\n  	render: Attribute_prototype_render,\n  	toString: Attribute_prototype_toString,\n  	unbind: Attribute_prototype_unbind,\n  	update: Attribute_prototype_update\n  };\n\n  var _Attribute = Attribute;\n\n  var createAttributes = function (element, attributes) {\n  	var name,\n  	    attribute,\n  	    result = [];\n\n  	for (name in attributes) {\n  		// skip binding attributes\n  		if (name === "twoway" || name === "lazy") {\n  			continue;\n  		}\n\n  		if (attributes.hasOwnProperty(name)) {\n  			attribute = new _Attribute({\n  				element: element,\n  				name: name,\n  				value: attributes[name],\n  				root: element.root\n  			});\n\n  			result[name] = attribute;\n\n  			if (name !== "value") {\n  				result.push(attribute);\n  			}\n  		}\n  	}\n\n  	// value attribute goes last. This is because it\n  	// may get clamped on render otherwise, e.g. in\n  	// `<input type=\'range\' value=\'999\' min=\'0\' max=\'1000\'>`\n  	// since default max is 100\n  	if (attribute = result.value) {\n  		result.push(attribute);\n  	}\n\n  	return result;\n  };\n\n  var _ConditionalAttribute__div;\n\n  if (typeof document !== "undefined") {\n  	_ConditionalAttribute__div = createElement("div");\n  }\n\n  var ConditionalAttribute = function (element, template) {\n  	this.element = element;\n  	this.root = element.root;\n  	this.parentFragment = element.parentFragment;\n\n  	this.attributes = [];\n\n  	this.fragment = new virtualdom_Fragment({\n  		root: element.root,\n  		owner: this,\n  		template: [template]\n  	});\n  };\n\n  ConditionalAttribute.prototype = {\n  	bubble: function () {\n  		if (this.node) {\n  			this.update();\n  		}\n\n  		this.element.bubble();\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		this.fragment.rebind(oldKeypath, newKeypath);\n  	},\n\n  	render: function (node) {\n  		this.node = node;\n  		this.isSvg = node.namespaceURI === namespaces.svg;\n\n  		this.update();\n  	},\n\n  	unbind: function () {\n  		this.fragment.unbind();\n  	},\n\n  	update: function () {\n  		var _this = this;\n\n  		var str, attrs;\n\n  		str = this.fragment.toString();\n  		attrs = parseAttributes(str, this.isSvg);\n\n  		// any attributes that previously existed but no longer do\n  		// must be removed\n  		this.attributes.filter(function (a) {\n  			return notIn(attrs, a);\n  		}).forEach(function (a) {\n  			_this.node.removeAttribute(a.name);\n  		});\n\n  		attrs.forEach(function (a) {\n  			_this.node.setAttribute(a.name, a.value);\n  		});\n\n  		this.attributes = attrs;\n  	},\n\n  	toString: function () {\n  		return this.fragment.toString();\n  	}\n  };\n\n  var _ConditionalAttribute = ConditionalAttribute;\n\n  function parseAttributes(str, isSvg) {\n  	var tag = isSvg ? "svg" : "div";\n  	_ConditionalAttribute__div.innerHTML = "<" + tag + " " + str + "></" + tag + ">";\n\n  	return toArray(_ConditionalAttribute__div.childNodes[0].attributes);\n  }\n\n  function notIn(haystack, needle) {\n  	var i = haystack.length;\n\n  	while (i--) {\n  		if (haystack[i].name === needle.name) {\n  			return false;\n  		}\n  	}\n\n  	return true;\n  }\n\n  var createConditionalAttributes = function (element, attributes) {\n  	if (!attributes) {\n  		return [];\n  	}\n\n  	return attributes.map(function (a) {\n  		return new _ConditionalAttribute(element, a);\n  	});\n  };\n\n  var Binding = function (element) {\n  	var interpolator, keypath, value, parentForm;\n\n  	this.element = element;\n  	this.root = element.root;\n  	this.attribute = element.attributes[this.name || "value"];\n\n  	interpolator = this.attribute.interpolator;\n  	interpolator.twowayBinding = this;\n\n  	if (keypath = interpolator.keypath) {\n  		if (keypath.str.slice(-1) === "}") {\n  			warnOnceIfDebug("Two-way binding does not work with expressions (`%s` on <%s>)", interpolator.resolver.uniqueString, element.name, { ractive: this.root });\n  			return false;\n  		}\n\n  		if (keypath.isSpecial) {\n  			warnOnceIfDebug("Two-way binding does not work with %s", interpolator.resolver.ref, { ractive: this.root });\n  			return false;\n  		}\n  	} else {\n  		// A mustache may be *ambiguous*. Let\'s say we were given\n  		// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`\n  		// *wasn\'t* `undefined`, the keypath would be `foo.bar`.\n  		// Then, any user input would result in `foo.bar` being updated.\n  		//\n  		// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be\n  		// left with an unresolved partial keypath - so we are forced to make an\n  		// assumption. That assumption is that the input in question should\n  		// be forced to resolve to `bar`, and any user input would affect `bar`\n  		// and not `foo.bar`.\n  		//\n  		// Did that make any sense? No? Oh. Sorry. Well the moral of the story is\n  		// be explicit when using two-way data-binding about what keypath you\'re\n  		// updating. Using it in lists is probably a recipe for confusion...\n  		var ref = interpolator.template.r ? "\'" + interpolator.template.r + "\' reference" : "expression";\n  		warnIfDebug("The %s being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity", ref, { ractive: this.root });\n  		interpolator.resolver.forceResolution();\n  		keypath = interpolator.keypath;\n  	}\n\n  	this.attribute.isTwoway = true;\n  	this.keypath = keypath;\n\n  	// initialise value, if it\'s undefined\n  	value = this.root.viewmodel.get(keypath);\n\n  	if (value === undefined && this.getInitialValue) {\n  		value = this.getInitialValue();\n\n  		if (value !== undefined) {\n  			this.root.viewmodel.set(keypath, value);\n  		}\n  	}\n\n  	if (parentForm = findParentForm(element)) {\n  		this.resetValue = value;\n  		parentForm.formBindings.push(this);\n  	}\n  };\n\n  Binding.prototype = {\n  	handleChange: function () {\n  		var _this = this;\n\n  		global_runloop.start(this.root);\n  		this.attribute.locked = true;\n  		this.root.viewmodel.set(this.keypath, this.getValue());\n  		global_runloop.scheduleTask(function () {\n  			return _this.attribute.locked = false;\n  		});\n  		global_runloop.end();\n  	},\n\n  	rebound: function () {\n  		var bindings, oldKeypath, newKeypath;\n\n  		oldKeypath = this.keypath;\n  		newKeypath = this.attribute.interpolator.keypath;\n\n  		// The attribute this binding is linked to has already done the work\n  		if (oldKeypath === newKeypath) {\n  			return;\n  		}\n\n  		removeFromArray(this.root._twowayBindings[oldKeypath.str], this);\n\n  		this.keypath = newKeypath;\n\n  		bindings = this.root._twowayBindings[newKeypath.str] || (this.root._twowayBindings[newKeypath.str] = []);\n  		bindings.push(this);\n  	},\n\n  	unbind: function () {}\n  };\n\n  Binding.extend = function (properties) {\n  	var Parent = this,\n  	    SpecialisedBinding;\n\n  	SpecialisedBinding = function (element) {\n  		Binding.call(this, element);\n\n  		if (this.init) {\n  			this.init();\n  		}\n  	};\n\n  	SpecialisedBinding.prototype = create(Parent.prototype);\n  	utils_object__extend(SpecialisedBinding.prototype, properties);\n\n  	SpecialisedBinding.extend = Binding.extend;\n\n  	return SpecialisedBinding;\n  };\n\n  var Binding_Binding = Binding;\n\n  function findParentForm(element) {\n  	while (element = element.parent) {\n  		if (element.name === "form") {\n  			return element;\n  		}\n  	}\n  }\n\n  // this is called when the element is unbound.\n  // Specialised bindings can override it\n\n  // This is the handler for DOM events that would lead to a change in the model\n  // (i.e. change, sometimes, input, and occasionally click and keyup)\n  var handleDomEvent = handleChange;\n\n  function handleChange() {\n  	this._ractive.binding.handleChange();\n  }\n\n  var ContentEditableBinding = Binding_Binding.extend({\n  	getInitialValue: function () {\n  		return this.element.fragment ? this.element.fragment.toString() : "";\n  	},\n\n  	render: function () {\n  		var node = this.element.node;\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		if (!this.root.lazy) {\n  			node.addEventListener("input", handleDomEvent, false);\n\n  			if (node.attachEvent) {\n  				node.addEventListener("keyup", handleDomEvent, false);\n  			}\n  		}\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("input", handleDomEvent, false);\n  		node.removeEventListener("keyup", handleDomEvent, false);\n  	},\n\n  	getValue: function () {\n  		return this.element.node.innerHTML;\n  	}\n  });\n\n  var Binding_ContentEditableBinding = ContentEditableBinding;\n\n  var shared_getSiblings = getSiblings;\n  var sets = {};\n  function getSiblings(id, group, keypath) {\n  	var hash = id + group + keypath;\n  	return sets[hash] || (sets[hash] = []);\n  }\n\n  var RadioBinding = Binding_Binding.extend({\n  	name: "checked",\n\n  	init: function () {\n  		this.siblings = shared_getSiblings(this.root._guid, "radio", this.element.getAttribute("name"));\n  		this.siblings.push(this);\n  	},\n\n  	render: function () {\n  		var node = this.element.node;\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		if (node.attachEvent) {\n  			node.addEventListener("click", handleDomEvent, false);\n  		}\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("click", handleDomEvent, false);\n  	},\n\n  	handleChange: function () {\n  		global_runloop.start(this.root);\n\n  		this.siblings.forEach(function (binding) {\n  			binding.root.viewmodel.set(binding.keypath, binding.getValue());\n  		});\n\n  		global_runloop.end();\n  	},\n\n  	getValue: function () {\n  		return this.element.node.checked;\n  	},\n\n  	unbind: function () {\n  		removeFromArray(this.siblings, this);\n  	}\n  });\n\n  var Binding_RadioBinding = RadioBinding;\n\n  var RadioNameBinding = Binding_Binding.extend({\n  	name: "name",\n\n  	init: function () {\n  		this.siblings = shared_getSiblings(this.root._guid, "radioname", this.keypath.str);\n  		this.siblings.push(this);\n\n  		this.radioName = true; // so that ractive.updateModel() knows what to do with this\n  	},\n\n  	getInitialValue: function () {\n  		if (this.element.getAttribute("checked")) {\n  			return this.element.getAttribute("value");\n  		}\n  	},\n\n  	render: function () {\n  		var node = this.element.node;\n\n  		node.name = "{{" + this.keypath.str + "}}";\n  		node.checked = this.root.viewmodel.get(this.keypath) == this.element.getAttribute("value");\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		if (node.attachEvent) {\n  			node.addEventListener("click", handleDomEvent, false);\n  		}\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("click", handleDomEvent, false);\n  	},\n\n  	getValue: function () {\n  		var node = this.element.node;\n  		return node._ractive ? node._ractive.value : node.value;\n  	},\n\n  	handleChange: function () {\n  		// If this <input> is the one that\'s checked, then the value of its\n  		// `name` keypath gets set to its value\n  		if (this.element.node.checked) {\n  			Binding_Binding.prototype.handleChange.call(this);\n  		}\n  	},\n\n  	rebound: function (oldKeypath, newKeypath) {\n  		var node;\n\n  		Binding_Binding.prototype.rebound.call(this, oldKeypath, newKeypath);\n\n  		if (node = this.element.node) {\n  			node.name = "{{" + this.keypath.str + "}}";\n  		}\n  	},\n\n  	unbind: function () {\n  		removeFromArray(this.siblings, this);\n  	}\n  });\n\n  var Binding_RadioNameBinding = RadioNameBinding;\n\n  var CheckboxNameBinding = Binding_Binding.extend({\n  	name: "name",\n\n  	getInitialValue: function () {\n  		// This only gets called once per group (of inputs that\n  		// share a name), because it only gets called if there\n  		// isn\'t an initial value. By the same token, we can make\n  		// a note of that fact that there was no initial value,\n  		// and populate it using any `checked` attributes that\n  		// exist (which users should avoid, but which we should\n  		// support anyway to avoid breaking expectations)\n  		this.noInitialValue = true;\n  		return [];\n  	},\n\n  	init: function () {\n  		var existingValue, bindingValue;\n\n  		this.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\n  		// Each input has a reference to an array containing it and its\n  		// siblings, as two-way binding depends on being able to ascertain\n  		// the status of all inputs within the group\n  		this.siblings = shared_getSiblings(this.root._guid, "checkboxes", this.keypath.str);\n  		this.siblings.push(this);\n\n  		if (this.noInitialValue) {\n  			this.siblings.noInitialValue = true;\n  		}\n\n  		// If no initial value was set, and this input is checked, we\n  		// update the model\n  		if (this.siblings.noInitialValue && this.element.getAttribute("checked")) {\n  			existingValue = this.root.viewmodel.get(this.keypath);\n  			bindingValue = this.element.getAttribute("value");\n\n  			existingValue.push(bindingValue);\n  		}\n  	},\n\n  	unbind: function () {\n  		removeFromArray(this.siblings, this);\n  	},\n\n  	render: function () {\n  		var node = this.element.node,\n  		    existingValue,\n  		    bindingValue;\n\n  		existingValue = this.root.viewmodel.get(this.keypath);\n  		bindingValue = this.element.getAttribute("value");\n\n  		if (isArray(existingValue)) {\n  			this.isChecked = arrayContains(existingValue, bindingValue);\n  		} else {\n  			this.isChecked = existingValue == bindingValue;\n  		}\n\n  		node.name = "{{" + this.keypath.str + "}}";\n  		node.checked = this.isChecked;\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		// in case of IE emergency, bind to click event as well\n  		if (node.attachEvent) {\n  			node.addEventListener("click", handleDomEvent, false);\n  		}\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("click", handleDomEvent, false);\n  	},\n\n  	changed: function () {\n  		var wasChecked = !!this.isChecked;\n  		this.isChecked = this.element.node.checked;\n  		return this.isChecked === wasChecked;\n  	},\n\n  	handleChange: function () {\n  		this.isChecked = this.element.node.checked;\n  		Binding_Binding.prototype.handleChange.call(this);\n  	},\n\n  	getValue: function () {\n  		return this.siblings.filter(isChecked).map(Binding_CheckboxNameBinding__getValue);\n  	}\n  });\n\n  function isChecked(binding) {\n  	return binding.isChecked;\n  }\n\n  function Binding_CheckboxNameBinding__getValue(binding) {\n  	return binding.element.getAttribute("value");\n  }\n\n  var Binding_CheckboxNameBinding = CheckboxNameBinding;\n\n  var CheckboxBinding = Binding_Binding.extend({\n  	name: "checked",\n\n  	render: function () {\n  		var node = this.element.node;\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		if (node.attachEvent) {\n  			node.addEventListener("click", handleDomEvent, false);\n  		}\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("click", handleDomEvent, false);\n  	},\n\n  	getValue: function () {\n  		return this.element.node.checked;\n  	}\n  });\n\n  var Binding_CheckboxBinding = CheckboxBinding;\n\n  var SelectBinding = Binding_Binding.extend({\n  	getInitialValue: function () {\n  		var options = this.element.options,\n  		    len,\n  		    i,\n  		    value,\n  		    optionWasSelected;\n\n  		if (this.element.getAttribute("value") !== undefined) {\n  			return;\n  		}\n\n  		i = len = options.length;\n\n  		if (!len) {\n  			return;\n  		}\n\n  		// take the final selected option...\n  		while (i--) {\n  			if (options[i].getAttribute("selected")) {\n  				value = options[i].getAttribute("value");\n  				optionWasSelected = true;\n  				break;\n  			}\n  		}\n\n  		// or the first non-disabled option, if none are selected\n  		if (!optionWasSelected) {\n  			while (++i < len) {\n  				if (!options[i].getAttribute("disabled")) {\n  					value = options[i].getAttribute("value");\n  					break;\n  				}\n  			}\n  		}\n\n  		// This is an optimisation (aka hack) that allows us to forgo some\n  		// other more expensive work\n  		if (value !== undefined) {\n  			this.element.attributes.value.value = value;\n  		}\n\n  		return value;\n  	},\n\n  	render: function () {\n  		this.element.node.addEventListener("change", handleDomEvent, false);\n  	},\n\n  	unrender: function () {\n  		this.element.node.removeEventListener("change", handleDomEvent, false);\n  	},\n\n  	// TODO this method is an anomaly... is it necessary?\n  	setValue: function (value) {\n  		this.root.viewmodel.set(this.keypath, value);\n  	},\n\n  	getValue: function () {\n  		var options, i, len, option, optionValue;\n\n  		options = this.element.node.options;\n  		len = options.length;\n\n  		for (i = 0; i < len; i += 1) {\n  			option = options[i];\n\n  			if (options[i].selected) {\n  				optionValue = option._ractive ? option._ractive.value : option.value;\n  				return optionValue;\n  			}\n  		}\n  	},\n\n  	forceUpdate: function () {\n  		var _this = this;\n\n  		var value = this.getValue();\n\n  		if (value !== undefined) {\n  			this.attribute.locked = true;\n  			global_runloop.scheduleTask(function () {\n  				return _this.attribute.locked = false;\n  			});\n  			this.root.viewmodel.set(this.keypath, value);\n  		}\n  	}\n  });\n\n  var Binding_SelectBinding = SelectBinding;\n\n  var MultipleSelectBinding = Binding_SelectBinding.extend({\n  	getInitialValue: function () {\n  		return this.element.options.filter(function (option) {\n  			return option.getAttribute("selected");\n  		}).map(function (option) {\n  			return option.getAttribute("value");\n  		});\n  	},\n\n  	render: function () {\n  		var valueFromModel;\n\n  		this.element.node.addEventListener("change", handleDomEvent, false);\n\n  		valueFromModel = this.root.viewmodel.get(this.keypath);\n\n  		if (valueFromModel === undefined) {\n  			// get value from DOM, if possible\n  			this.handleChange();\n  		}\n  	},\n\n  	unrender: function () {\n  		this.element.node.removeEventListener("change", handleDomEvent, false);\n  	},\n\n  	setValue: function () {\n  		throw new Error("TODO not implemented yet");\n  	},\n\n  	getValue: function () {\n  		var selectedValues, options, i, len, option, optionValue;\n\n  		selectedValues = [];\n  		options = this.element.node.options;\n  		len = options.length;\n\n  		for (i = 0; i < len; i += 1) {\n  			option = options[i];\n\n  			if (option.selected) {\n  				optionValue = option._ractive ? option._ractive.value : option.value;\n  				selectedValues.push(optionValue);\n  			}\n  		}\n\n  		return selectedValues;\n  	},\n\n  	handleChange: function () {\n  		var attribute, previousValue, value;\n\n  		attribute = this.attribute;\n  		previousValue = attribute.value;\n\n  		value = this.getValue();\n\n  		if (previousValue === undefined || !arrayContentsMatch(value, previousValue)) {\n  			Binding_SelectBinding.prototype.handleChange.call(this);\n  		}\n\n  		return this;\n  	},\n\n  	forceUpdate: function () {\n  		var _this = this;\n\n  		var value = this.getValue();\n\n  		if (value !== undefined) {\n  			this.attribute.locked = true;\n  			global_runloop.scheduleTask(function () {\n  				return _this.attribute.locked = false;\n  			});\n  			this.root.viewmodel.set(this.keypath, value);\n  		}\n  	},\n\n  	updateModel: function () {\n  		if (this.attribute.value === undefined || !this.attribute.value.length) {\n  			this.root.viewmodel.set(this.keypath, this.initialValue);\n  		}\n  	}\n  });\n\n  var Binding_MultipleSelectBinding = MultipleSelectBinding;\n\n  var FileListBinding = Binding_Binding.extend({\n  	render: function () {\n  		this.element.node.addEventListener("change", handleDomEvent, false);\n  	},\n\n  	unrender: function () {\n  		this.element.node.removeEventListener("change", handleDomEvent, false);\n  	},\n\n  	getValue: function () {\n  		return this.element.node.files;\n  	}\n  });\n\n  var Binding_FileListBinding = FileListBinding;\n\n  var GenericBinding;\n\n  GenericBinding = Binding_Binding.extend({\n  	getInitialValue: function () {\n  		return "";\n  	},\n\n  	getValue: function () {\n  		return this.element.node.value;\n  	},\n\n  	render: function () {\n  		var node = this.element.node,\n  		    lazy,\n  		    timeout = false;\n  		this.rendered = true;\n\n  		// any lazy setting for this element overrides the root\n  		// if the value is a number, it\'s a timeout\n  		lazy = this.root.lazy;\n  		if (this.element.lazy === true) {\n  			lazy = true;\n  		} else if (this.element.lazy === false) {\n  			lazy = false;\n  		} else if (is__isNumeric(this.element.lazy)) {\n  			lazy = false;\n  			timeout = +this.element.lazy;\n  		} else if (is__isNumeric(lazy || "")) {\n  			timeout = +lazy;\n  			lazy = false;\n\n  			// make sure the timeout is available to the handler\n  			this.element.lazy = timeout;\n  		}\n\n  		this.handler = timeout ? handleDelay : handleDomEvent;\n\n  		node.addEventListener("change", handleDomEvent, false);\n\n  		if (!lazy) {\n  			node.addEventListener("input", this.handler, false);\n\n  			if (node.attachEvent) {\n  				node.addEventListener("keyup", this.handler, false);\n  			}\n  		}\n\n  		node.addEventListener("blur", handleBlur, false);\n  	},\n\n  	unrender: function () {\n  		var node = this.element.node;\n  		this.rendered = false;\n\n  		node.removeEventListener("change", handleDomEvent, false);\n  		node.removeEventListener("input", this.handler, false);\n  		node.removeEventListener("keyup", this.handler, false);\n  		node.removeEventListener("blur", handleBlur, false);\n  	}\n  });\n\n  var Binding_GenericBinding = GenericBinding;\n\n  function handleBlur() {\n  	var value;\n\n  	handleDomEvent.call(this);\n\n  	value = this._ractive.root.viewmodel.get(this._ractive.binding.keypath);\n  	this.value = value == undefined ? "" : value;\n  }\n\n  function handleDelay() {\n  	var binding = this._ractive.binding,\n  	    el = this;\n\n  	if (!!binding._timeout) clearTimeout(binding._timeout);\n\n  	binding._timeout = setTimeout(function () {\n  		if (binding.rendered) handleDomEvent.call(el);\n  		binding._timeout = undefined;\n  	}, binding.element.lazy);\n  }\n\n  var NumericBinding = Binding_GenericBinding.extend({\n  	getInitialValue: function () {\n  		return undefined;\n  	},\n\n  	getValue: function () {\n  		var value = parseFloat(this.element.node.value);\n  		return isNaN(value) ? undefined : value;\n  	}\n  });\n\n  var init_createTwowayBinding = createTwowayBinding;\n\n  function createTwowayBinding(element) {\n  	var attributes = element.attributes,\n  	    type,\n  	    Binding,\n  	    bindName,\n  	    bindChecked,\n  	    binding;\n\n  	// if this is a late binding, and there\'s already one, it\n  	// needs to be torn down\n  	if (element.binding) {\n  		element.binding.teardown();\n  		element.binding = null;\n  	}\n\n  	// contenteditable\n  	if (\n  	// if the contenteditable attribute is true or is bindable and may thus become true\n  	(element.getAttribute("contenteditable") || !!attributes.contenteditable && isBindable(attributes.contenteditable)) && isBindable(attributes.value)) {\n  		Binding = Binding_ContentEditableBinding;\n  	}\n\n  	// <input>\n  	else if (element.name === "input") {\n  		type = element.getAttribute("type");\n\n  		if (type === "radio" || type === "checkbox") {\n  			bindName = isBindable(attributes.name);\n  			bindChecked = isBindable(attributes.checked);\n\n  			// we can either bind the name attribute, or the checked attribute - not both\n  			if (bindName && bindChecked) {\n  				warnIfDebug("A radio input can have two-way binding on its name attribute, or its checked attribute - not both", { ractive: element.root });\n  			}\n\n  			if (bindName) {\n  				Binding = type === "radio" ? Binding_RadioNameBinding : Binding_CheckboxNameBinding;\n  			} else if (bindChecked) {\n  				Binding = type === "radio" ? Binding_RadioBinding : Binding_CheckboxBinding;\n  			}\n  		} else if (type === "file" && isBindable(attributes.value)) {\n  			Binding = Binding_FileListBinding;\n  		} else if (isBindable(attributes.value)) {\n  			Binding = type === "number" || type === "range" ? NumericBinding : Binding_GenericBinding;\n  		}\n  	}\n\n  	// <select>\n  	else if (element.name === "select" && isBindable(attributes.value)) {\n  		Binding = element.getAttribute("multiple") ? Binding_MultipleSelectBinding : Binding_SelectBinding;\n  	}\n\n  	// <textarea>\n  	else if (element.name === "textarea" && isBindable(attributes.value)) {\n  		Binding = Binding_GenericBinding;\n  	}\n\n  	if (Binding && (binding = new Binding(element)) && binding.keypath) {\n  		return binding;\n  	}\n  }\n\n  function isBindable(attribute) {\n  	return attribute && attribute.isBindable;\n  }\n\n  // and this element also has a value attribute to bind\n\n  var EventHandler_prototype_bubble = EventHandler$bubble;\n\n  function EventHandler$bubble() {\n  	var hasAction = this.getAction();\n\n  	if (hasAction && !this.hasListener) {\n  		this.listen();\n  	} else if (!hasAction && this.hasListener) {\n  		this.unrender();\n  	}\n  }\n\n  // This function may be overwritten, if the event directive\n  // includes parameters\n  var EventHandler_prototype_fire = EventHandler$fire;\n  function EventHandler$fire(event) {\n  	shared_fireEvent(this.root, this.getAction(), { event: event });\n  }\n\n  var getAction = EventHandler$getAction;\n\n  function EventHandler$getAction() {\n  	return this.action.toString().trim();\n  }\n\n  var EventHandler_prototype_init = EventHandler$init;\n\n  var eventPattern = /^event(?:\\.(.+))?/;\n  function EventHandler$init(element, name, template) {\n  	var _this = this;\n\n  	var action, refs, ractive;\n\n  	this.element = element;\n  	this.root = element.root;\n  	this.parentFragment = element.parentFragment;\n  	this.name = name;\n\n  	if (name.indexOf("*") !== -1) {\n  		fatal("Only component proxy-events may contain \\"*\\" wildcards, <%s on-%s=\\"...\\"/> is not valid", element.name, name);\n  		this.invalid = true;\n  	}\n\n  	if (template.m) {\n  		refs = template.a.r;\n\n  		// This is a method call\n  		this.method = template.m;\n  		this.keypaths = [];\n  		this.fn = shared_getFunctionFromString(template.a.s, refs.length);\n\n  		this.parentFragment = element.parentFragment;\n  		ractive = this.root;\n\n  		// Create resolvers for each reference\n  		this.refResolvers = [];\n  		refs.forEach(function (ref, i) {\n  			var match = undefined;\n\n  			// special case - the `event` object\n  			if (match = eventPattern.exec(ref)) {\n  				_this.keypaths[i] = {\n  					eventObject: true,\n  					refinements: match[1] ? match[1].split(".") : []\n  				};\n  			} else {\n  				_this.refResolvers.push(Resolvers_createReferenceResolver(_this, ref, function (keypath) {\n  					return _this.resolve(i, keypath);\n  				}));\n  			}\n  		});\n\n  		this.fire = fireMethodCall;\n  	} else {\n  		// Get action (\'foo\' in \'on-click=\'foo\')\n  		action = template.n || template;\n  		if (typeof action !== "string") {\n  			action = new virtualdom_Fragment({\n  				template: action,\n  				root: this.root,\n  				owner: this\n  			});\n  		}\n\n  		this.action = action;\n\n  		// Get parameters\n  		if (template.d) {\n  			this.dynamicParams = new virtualdom_Fragment({\n  				template: template.d,\n  				root: this.root,\n  				owner: this.element\n  			});\n\n  			this.fire = fireEventWithDynamicParams;\n  		} else if (template.a) {\n  			this.params = template.a;\n  			this.fire = fireEventWithParams;\n  		}\n  	}\n  }\n\n  function fireMethodCall(event) {\n  	var ractive, values, args;\n\n  	ractive = this.root;\n\n  	if (typeof ractive[this.method] !== "function") {\n  		throw new Error("Attempted to call a non-existent method (\\"" + this.method + "\\")");\n  	}\n\n  	values = this.keypaths.map(function (keypath) {\n  		var value, len, i;\n\n  		if (keypath === undefined) {\n  			// not yet resolved\n  			return undefined;\n  		}\n\n  		// TODO the refinements stuff would be better handled at parse time\n  		if (keypath.eventObject) {\n  			value = event;\n\n  			if (len = keypath.refinements.length) {\n  				for (i = 0; i < len; i += 1) {\n  					value = value[keypath.refinements[i]];\n  				}\n  			}\n  		} else {\n  			value = ractive.viewmodel.get(keypath);\n  		}\n\n  		return value;\n  	});\n\n  	shared_eventStack.enqueue(ractive, event);\n\n  	args = this.fn.apply(null, values);\n  	ractive[this.method].apply(ractive, args);\n\n  	shared_eventStack.dequeue(ractive);\n  }\n\n  function fireEventWithParams(event) {\n  	shared_fireEvent(this.root, this.getAction(), { event: event, args: this.params });\n  }\n\n  function fireEventWithDynamicParams(event) {\n  	var args = this.dynamicParams.getArgsList();\n\n  	// need to strip [] from ends if a string!\n  	if (typeof args === "string") {\n  		args = args.substr(1, args.length - 2);\n  	}\n\n  	shared_fireEvent(this.root, this.getAction(), { event: event, args: args });\n  }\n\n  var shared_genericHandler = genericHandler;\n  function genericHandler(event) {\n  	var storage,\n  	    handler,\n  	    indices,\n  	    index = {};\n\n  	storage = this._ractive;\n  	handler = storage.events[event.type];\n\n  	if (indices = Resolvers_findIndexRefs(handler.element.parentFragment)) {\n  		index = Resolvers_findIndexRefs.resolve(indices);\n  	}\n\n  	handler.fire({\n  		node: this,\n  		original: event,\n  		index: index,\n  		keypath: storage.keypath.str,\n  		context: storage.root.viewmodel.get(storage.keypath)\n  	});\n  }\n\n  var listen = EventHandler$listen;\n\n  var customHandlers = {},\n      touchEvents = {\n  	touchstart: true,\n  	touchmove: true,\n  	touchend: true,\n  	touchcancel: true,\n  	//not w3c, but supported in some browsers\n  	touchleave: true\n  };\n  function EventHandler$listen() {\n  	var definition,\n  	    name = this.name;\n\n  	if (this.invalid) {\n  		return;\n  	}\n\n  	if (definition = findInViewHierarchy("events", this.root, name)) {\n  		this.custom = definition(this.node, getCustomHandler(name));\n  	} else {\n  		// Looks like we\'re dealing with a standard DOM event... but let\'s check\n  		if (!("on" + name in this.node) && !(window && "on" + name in window) && !isJsdom) {\n\n  			// okay to use touch events if this browser doesn\'t support them\n  			if (!touchEvents[name]) {\n  				warnOnceIfDebug(missingPlugin(name, "event"), { node: this.node });\n  			}\n\n  			return;\n  		}\n\n  		this.node.addEventListener(name, shared_genericHandler, false);\n  	}\n\n  	this.hasListener = true;\n  }\n\n  function getCustomHandler(name) {\n  	if (!customHandlers[name]) {\n  		customHandlers[name] = function (event) {\n  			var storage = event.node._ractive;\n\n  			event.index = storage.index;\n  			event.keypath = storage.keypath.str;\n  			event.context = storage.root.viewmodel.get(storage.keypath);\n\n  			storage.events[name].fire(event);\n  		};\n  	}\n\n  	return customHandlers[name];\n  }\n\n  var EventHandler_prototype_rebind = EventHandler$rebind;\n\n  function EventHandler$rebind(oldKeypath, newKeypath) {\n  	var fragment;\n  	if (this.method) {\n  		fragment = this.element.parentFragment;\n  		this.refResolvers.forEach(rebind);\n\n  		return;\n  	}\n\n  	if (typeof this.action !== "string") {\n  		rebind(this.action);\n  	}\n\n  	if (this.dynamicParams) {\n  		rebind(this.dynamicParams);\n  	}\n\n  	function rebind(thing) {\n  		thing && thing.rebind(oldKeypath, newKeypath);\n  	}\n  }\n\n  var EventHandler_prototype_render = EventHandler$render;\n\n  function EventHandler$render() {\n  	this.node = this.element.node;\n  	// store this on the node itself, so it can be retrieved by a\n  	// universal handler\n  	this.node._ractive.events[this.name] = this;\n\n  	if (this.method || this.getAction()) {\n  		this.listen();\n  	}\n  }\n\n  var prototype_resolve = EventHandler$resolve;\n\n  function EventHandler$resolve(index, keypath) {\n  	this.keypaths[index] = keypath;\n  }\n\n  var EventHandler_prototype_unbind = EventHandler$unbind;\n  function EventHandler$unbind() {\n  	if (this.method) {\n  		this.refResolvers.forEach(methodCallers__unbind);\n  		return;\n  	}\n\n  	// Tear down dynamic name\n  	if (typeof this.action !== "string") {\n  		this.action.unbind();\n  	}\n\n  	// Tear down dynamic parameters\n  	if (this.dynamicParams) {\n  		this.dynamicParams.unbind();\n  	}\n  }\n\n  var EventHandler_prototype_unrender = EventHandler$unrender;\n  function EventHandler$unrender() {\n\n  	if (this.custom) {\n  		this.custom.teardown();\n  	} else {\n  		this.node.removeEventListener(this.name, shared_genericHandler, false);\n  	}\n\n  	this.hasListener = false;\n  }\n\n  var EventHandler = function (element, name, template) {\n  	this.init(element, name, template);\n  };\n\n  EventHandler.prototype = {\n  	bubble: EventHandler_prototype_bubble,\n  	fire: EventHandler_prototype_fire,\n  	getAction: getAction,\n  	init: EventHandler_prototype_init,\n  	listen: listen,\n  	rebind: EventHandler_prototype_rebind,\n  	render: EventHandler_prototype_render,\n  	resolve: prototype_resolve,\n  	unbind: EventHandler_prototype_unbind,\n  	unrender: EventHandler_prototype_unrender\n  };\n\n  var _EventHandler = EventHandler;\n\n  var createEventHandlers = function (element, template) {\n  	var i,\n  	    name,\n  	    names,\n  	    handler,\n  	    result = [];\n\n  	for (name in template) {\n  		if (template.hasOwnProperty(name)) {\n  			names = name.split("-");\n  			i = names.length;\n\n  			while (i--) {\n  				handler = new _EventHandler(element, names[i], template[name]);\n  				result.push(handler);\n  			}\n  		}\n  	}\n\n  	return result;\n  };\n\n  var Decorator = function (element, template) {\n  	var self = this,\n  	    ractive,\n  	    name,\n  	    fragment;\n\n  	this.element = element;\n  	this.root = ractive = element.root;\n\n  	name = template.n || template;\n\n  	if (typeof name !== "string") {\n  		fragment = new virtualdom_Fragment({\n  			template: name,\n  			root: ractive,\n  			owner: element\n  		});\n\n  		name = fragment.toString();\n  		fragment.unbind();\n\n  		if (name === "") {\n  			// empty string okay, just no decorator\n  			return;\n  		}\n  	}\n\n  	if (template.a) {\n  		this.params = template.a;\n  	} else if (template.d) {\n  		this.fragment = new virtualdom_Fragment({\n  			template: template.d,\n  			root: ractive,\n  			owner: element\n  		});\n\n  		this.params = this.fragment.getArgsList();\n\n  		this.fragment.bubble = function () {\n  			this.dirtyArgs = this.dirtyValue = true;\n  			self.params = this.getArgsList();\n\n  			if (self.ready) {\n  				self.update();\n  			}\n  		};\n  	}\n\n  	this.fn = findInViewHierarchy("decorators", ractive, name);\n\n  	if (!this.fn) {\n  		fatal(missingPlugin(name, "decorator"));\n  	}\n  };\n\n  Decorator.prototype = {\n  	init: function () {\n  		var node, result, args;\n\n  		node = this.element.node;\n\n  		if (this.params) {\n  			args = [node].concat(this.params);\n  			result = this.fn.apply(this.root, args);\n  		} else {\n  			result = this.fn.call(this.root, node);\n  		}\n\n  		if (!result || !result.teardown) {\n  			throw new Error("Decorator definition must return an object with a teardown method");\n  		}\n\n  		// TODO does this make sense?\n  		this.actual = result;\n  		this.ready = true;\n  	},\n\n  	update: function () {\n  		if (this.actual.update) {\n  			this.actual.update.apply(this.root, this.params);\n  		} else {\n  			this.actual.teardown(true);\n  			this.init();\n  		}\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		if (this.fragment) {\n  			this.fragment.rebind(oldKeypath, newKeypath);\n  		}\n  	},\n\n  	teardown: function (updating) {\n  		this.torndown = true;\n  		if (this.ready) {\n  			this.actual.teardown();\n  		}\n\n  		if (!updating && this.fragment) {\n  			this.fragment.unbind();\n  		}\n  	}\n  };\n\n  var _Decorator = Decorator;\n\n  function select__bubble() {\n  	var _this = this;\n\n  	if (!this.dirty) {\n  		this.dirty = true;\n\n  		global_runloop.scheduleTask(function () {\n  			sync(_this);\n  			_this.dirty = false;\n  		});\n  	}\n\n  	this.parentFragment.bubble(); // default behaviour\n  }\n\n  function sync(selectElement) {\n  	var selectNode, selectValue, isMultiple, options, optionWasSelected;\n\n  	selectNode = selectElement.node;\n\n  	if (!selectNode) {\n  		return;\n  	}\n\n  	options = toArray(selectNode.options);\n\n  	selectValue = selectElement.getAttribute("value");\n  	isMultiple = selectElement.getAttribute("multiple");\n\n  	// If the <select> has a specified value, that should override\n  	// these options\n  	if (selectValue !== undefined) {\n  		options.forEach(function (o) {\n  			var optionValue, shouldSelect;\n\n  			optionValue = o._ractive ? o._ractive.value : o.value;\n  			shouldSelect = isMultiple ? valueContains(selectValue, optionValue) : selectValue == optionValue;\n\n  			if (shouldSelect) {\n  				optionWasSelected = true;\n  			}\n\n  			o.selected = shouldSelect;\n  		});\n\n  		if (!optionWasSelected) {\n  			if (options[0]) {\n  				options[0].selected = true;\n  			}\n\n  			if (selectElement.binding) {\n  				selectElement.binding.forceUpdate();\n  			}\n  		}\n  	}\n\n  	// Otherwise the value should be initialised according to which\n  	// <option> element is selected, if twoway binding is in effect\n  	else if (selectElement.binding) {\n  		selectElement.binding.forceUpdate();\n  	}\n  }\n\n  function valueContains(selectValue, optionValue) {\n  	var i = selectValue.length;\n  	while (i--) {\n  		if (selectValue[i] == optionValue) {\n  			return true;\n  		}\n  	}\n  }\n\n  function special_option__init(option, template) {\n  	option.select = findParentSelect(option.parent);\n\n  	// we might be inside a <datalist> element\n  	if (!option.select) {\n  		return;\n  	}\n\n  	option.select.options.push(option);\n\n  	// If the value attribute is missing, use the element\'s content\n  	if (!template.a) {\n  		template.a = {};\n  	}\n\n  	// ...as long as it isn\'t disabled\n  	if (template.a.value === undefined && !template.a.hasOwnProperty("disabled")) {\n  		template.a.value = template.f;\n  	}\n\n  	// If there is a `selected` attribute, but the <select>\n  	// already has a value, delete it\n  	if ("selected" in template.a && option.select.getAttribute("value") !== undefined) {\n  		delete template.a.selected;\n  	}\n  }\n\n  function special_option__unbind(option) {\n  	if (option.select) {\n  		removeFromArray(option.select.options, option);\n  	}\n  }\n\n  function findParentSelect(element) {\n  	if (!element) {\n  		return;\n  	}\n\n  	do {\n  		if (element.name === "select") {\n  			return element;\n  		}\n  	} while (element = element.parent);\n  }\n\n  var Element_prototype_init = Element$init;\n  function Element$init(options) {\n  	var parentFragment, template, ractive, binding, bindings, twoway, bindingAttrs;\n\n  	this.type = ELEMENT;\n\n  	// stuff we\'ll need later\n  	parentFragment = this.parentFragment = options.parentFragment;\n  	template = this.template = options.template;\n\n  	this.parent = options.pElement || parentFragment.pElement;\n\n  	this.root = ractive = parentFragment.root;\n  	this.index = options.index;\n  	this.key = options.key;\n\n  	this.name = enforceCase(template.e);\n\n  	// Special case - <option> elements\n  	if (this.name === "option") {\n  		special_option__init(this, template);\n  	}\n\n  	// Special case - <select> elements\n  	if (this.name === "select") {\n  		this.options = [];\n  		this.bubble = select__bubble; // TODO this is a kludge\n  	}\n\n  	// Special case - <form> elements\n  	if (this.name === "form") {\n  		this.formBindings = [];\n  	}\n\n  	// handle binding attributes first (twoway, lazy)\n  	bindingAttrs = processBindingAttributes(this, template);\n\n  	// create attributes\n  	this.attributes = createAttributes(this, template.a);\n  	this.conditionalAttributes = createConditionalAttributes(this, template.m);\n\n  	// append children, if there are any\n  	if (template.f) {\n  		this.fragment = new virtualdom_Fragment({\n  			template: template.f,\n  			root: ractive,\n  			owner: this,\n  			pElement: this,\n  			cssIds: null\n  		});\n  	}\n\n  	// the element setting should override the ractive setting\n  	twoway = ractive.twoway;\n  	if (bindingAttrs.twoway === false) twoway = false;else if (bindingAttrs.twoway === true) twoway = true;\n\n  	this.twoway = twoway;\n  	this.lazy = bindingAttrs.lazy;\n\n  	// create twoway binding\n  	if (twoway && (binding = init_createTwowayBinding(this, template.a))) {\n  		this.binding = binding;\n\n  		// register this with the root, so that we can do ractive.updateModel()\n  		bindings = this.root._twowayBindings[binding.keypath.str] || (this.root._twowayBindings[binding.keypath.str] = []);\n  		bindings.push(binding);\n  	}\n\n  	// create event proxies\n  	if (template.v) {\n  		this.eventHandlers = createEventHandlers(this, template.v);\n  	}\n\n  	// create decorator\n  	if (template.o) {\n  		this.decorator = new _Decorator(this, template.o);\n  	}\n\n  	// create transitions\n  	this.intro = template.t0 || template.t1;\n  	this.outro = template.t0 || template.t2;\n  }\n\n  var Element_prototype_rebind = Element$rebind;\n  function Element$rebind(oldKeypath, newKeypath) {\n  	var i, storage, liveQueries, ractive;\n\n  	if (this.attributes) {\n  		this.attributes.forEach(rebind);\n  	}\n\n  	if (this.conditionalAttributes) {\n  		this.conditionalAttributes.forEach(rebind);\n  	}\n\n  	if (this.eventHandlers) {\n  		this.eventHandlers.forEach(rebind);\n  	}\n\n  	if (this.decorator) {\n  		rebind(this.decorator);\n  	}\n\n  	// rebind children\n  	if (this.fragment) {\n  		rebind(this.fragment);\n  	}\n\n  	// Update live queries, if necessary\n  	if (liveQueries = this.liveQueries) {\n  		ractive = this.root;\n\n  		i = liveQueries.length;\n  		while (i--) {\n  			liveQueries[i]._makeDirty();\n  		}\n  	}\n\n  	if (this.node && (storage = this.node._ractive)) {\n\n  		// adjust keypath if needed\n  		assignNewKeypath(storage, "keypath", oldKeypath, newKeypath);\n  	}\n\n  	function rebind(thing) {\n  		thing.rebind(oldKeypath, newKeypath);\n  	}\n  }\n\n  function special_img__render(img) {\n  	var loadHandler;\n\n  	// if this is an <img>, and we\'re in a crap browser, we may need to prevent it\n  	// from overriding width and height when it loads the src\n  	if (img.attributes.width || img.attributes.height) {\n  		img.node.addEventListener("load", loadHandler = function () {\n  			var width = img.getAttribute("width"),\n  			    height = img.getAttribute("height");\n\n  			if (width !== undefined) {\n  				img.node.setAttribute("width", width);\n  			}\n\n  			if (height !== undefined) {\n  				img.node.setAttribute("height", height);\n  			}\n\n  			img.node.removeEventListener("load", loadHandler, false);\n  		}, false);\n  	}\n  }\n\n  function form__render(element) {\n  	element.node.addEventListener("reset", handleReset, false);\n  }\n\n  function form__unrender(element) {\n  	element.node.removeEventListener("reset", handleReset, false);\n  }\n\n  function handleReset() {\n  	var element = this._ractive.proxy;\n\n  	global_runloop.start();\n  	element.formBindings.forEach(updateModel);\n  	global_runloop.end();\n  }\n\n  function updateModel(binding) {\n  	binding.root.viewmodel.set(binding.keypath, binding.resetValue);\n  }\n\n  var Transition_prototype_init = Transition$init;\n  function Transition$init(element, template, isIntro) {\n  	var ractive, name, fragment;\n\n  	this.element = element;\n  	this.root = ractive = element.root;\n  	this.isIntro = isIntro;\n\n  	name = template.n || template;\n\n  	if (typeof name !== "string") {\n  		fragment = new virtualdom_Fragment({\n  			template: name,\n  			root: ractive,\n  			owner: element\n  		});\n\n  		name = fragment.toString();\n  		fragment.unbind();\n\n  		if (name === "") {\n  			// empty string okay, just no transition\n  			return;\n  		}\n  	}\n\n  	this.name = name;\n\n  	if (template.a) {\n  		this.params = template.a;\n  	} else if (template.d) {\n  		// TODO is there a way to interpret dynamic arguments without all the\n  		// \'dependency thrashing\'?\n  		fragment = new virtualdom_Fragment({\n  			template: template.d,\n  			root: ractive,\n  			owner: element\n  		});\n\n  		this.params = fragment.getArgsList();\n  		fragment.unbind();\n  	}\n\n  	this._fn = findInViewHierarchy("transitions", ractive, name);\n\n  	if (!this._fn) {\n  		warnOnceIfDebug(missingPlugin(name, "transition"), { ractive: this.root });\n  	}\n  }\n\n  var camelCase = function (hyphenatedStr) {\n  	return hyphenatedStr.replace(/-([a-zA-Z])/g, function (match, $1) {\n  		return $1.toUpperCase();\n  	});\n  };\n\n  var helpers_prefix__prefix, prefixCache, helpers_prefix__testStyle;\n\n  if (!isClient) {\n  	helpers_prefix__prefix = null;\n  } else {\n  	prefixCache = {};\n  	helpers_prefix__testStyle = createElement("div").style;\n\n  	helpers_prefix__prefix = function (prop) {\n  		var i, vendor, capped;\n\n  		prop = camelCase(prop);\n\n  		if (!prefixCache[prop]) {\n  			if (helpers_prefix__testStyle[prop] !== undefined) {\n  				prefixCache[prop] = prop;\n  			} else {\n  				// test vendors...\n  				capped = prop.charAt(0).toUpperCase() + prop.substring(1);\n\n  				i = vendors.length;\n  				while (i--) {\n  					vendor = vendors[i];\n  					if (helpers_prefix__testStyle[vendor + capped] !== undefined) {\n  						prefixCache[prop] = vendor + capped;\n  						break;\n  					}\n  				}\n  			}\n  		}\n\n  		return prefixCache[prop];\n  	};\n  }\n\n  var helpers_prefix = helpers_prefix__prefix;\n\n  var getStyle, prototype_getStyle__getComputedStyle;\n\n  if (!isClient) {\n  	getStyle = null;\n  } else {\n  	prototype_getStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n  	getStyle = function (props) {\n  		var computedStyle, styles, i, prop, value;\n\n  		computedStyle = prototype_getStyle__getComputedStyle(this.node);\n\n  		if (typeof props === "string") {\n  			value = computedStyle[helpers_prefix(props)];\n  			if (value === "0px") {\n  				value = 0;\n  			}\n  			return value;\n  		}\n\n  		if (!isArray(props)) {\n  			throw new Error("Transition$getStyle must be passed a string, or an array of strings representing CSS properties");\n  		}\n\n  		styles = {};\n\n  		i = props.length;\n  		while (i--) {\n  			prop = props[i];\n  			value = computedStyle[helpers_prefix(prop)];\n  			if (value === "0px") {\n  				value = 0;\n  			}\n  			styles[prop] = value;\n  		}\n\n  		return styles;\n  	};\n  }\n\n  var prototype_getStyle = getStyle;\n\n  var setStyle = function (style, value) {\n  	var prop;\n\n  	if (typeof style === "string") {\n  		this.node.style[helpers_prefix(style)] = value;\n  	} else {\n  		for (prop in style) {\n  			if (style.hasOwnProperty(prop)) {\n  				this.node.style[helpers_prefix(prop)] = style[prop];\n  			}\n  		}\n  	}\n\n  	return this;\n  };\n\n  var Ticker = function (options) {\n  	var easing;\n\n  	this.duration = options.duration;\n  	this.step = options.step;\n  	this.complete = options.complete;\n\n  	// easing\n  	if (typeof options.easing === "string") {\n  		easing = options.root.easing[options.easing];\n\n  		if (!easing) {\n  			warnOnceIfDebug(missingPlugin(options.easing, "easing"));\n  			easing = linear;\n  		}\n  	} else if (typeof options.easing === "function") {\n  		easing = options.easing;\n  	} else {\n  		easing = linear;\n  	}\n\n  	this.easing = easing;\n\n  	this.start = utils_getTime();\n  	this.end = this.start + this.duration;\n\n  	this.running = true;\n  	shared_animations.add(this);\n  };\n\n  Ticker.prototype = {\n  	tick: function (now) {\n  		var elapsed, eased;\n\n  		if (!this.running) {\n  			return false;\n  		}\n\n  		if (now > this.end) {\n  			if (this.step) {\n  				this.step(1);\n  			}\n\n  			if (this.complete) {\n  				this.complete(1);\n  			}\n\n  			return false;\n  		}\n\n  		elapsed = now - this.start;\n  		eased = this.easing(elapsed / this.duration);\n\n  		if (this.step) {\n  			this.step(eased);\n  		}\n\n  		return true;\n  	},\n\n  	stop: function () {\n  		if (this.abort) {\n  			this.abort();\n  		}\n\n  		this.running = false;\n  	}\n  };\n\n  var shared_Ticker = Ticker;\n  function linear(t) {\n  	return t;\n  }\n\n  var unprefixPattern = new RegExp("^-(?:" + vendors.join("|") + ")-");\n\n  var unprefix = function (prop) {\n  	return prop.replace(unprefixPattern, "");\n  };\n\n  var vendorPattern = new RegExp("^(?:" + vendors.join("|") + ")([A-Z])");\n\n  var hyphenate = function (str) {\n  	var hyphenated;\n\n  	if (!str) {\n  		return ""; // edge case\n  	}\n\n  	if (vendorPattern.test(str)) {\n  		str = "-" + str;\n  	}\n\n  	hyphenated = str.replace(/[A-Z]/g, function (match) {\n  		return "-" + match.toLowerCase();\n  	});\n\n  	return hyphenated;\n  };\n\n  var createTransitions,\n      animateStyle_createTransitions__testStyle,\n      TRANSITION,\n      TRANSITIONEND,\n      CSS_TRANSITIONS_ENABLED,\n      TRANSITION_DURATION,\n      TRANSITION_PROPERTY,\n      TRANSITION_TIMING_FUNCTION,\n      canUseCssTransitions = {},\n      cannotUseCssTransitions = {};\n\n  if (!isClient) {\n  	createTransitions = null;\n  } else {\n  	animateStyle_createTransitions__testStyle = createElement("div").style;\n\n  	// determine some facts about our environment\n  	(function () {\n  		if (animateStyle_createTransitions__testStyle.transition !== undefined) {\n  			TRANSITION = "transition";\n  			TRANSITIONEND = "transitionend";\n  			CSS_TRANSITIONS_ENABLED = true;\n  		} else if (animateStyle_createTransitions__testStyle.webkitTransition !== undefined) {\n  			TRANSITION = "webkitTransition";\n  			TRANSITIONEND = "webkitTransitionEnd";\n  			CSS_TRANSITIONS_ENABLED = true;\n  		} else {\n  			CSS_TRANSITIONS_ENABLED = false;\n  		}\n  	})();\n\n  	if (TRANSITION) {\n  		TRANSITION_DURATION = TRANSITION + "Duration";\n  		TRANSITION_PROPERTY = TRANSITION + "Property";\n  		TRANSITION_TIMING_FUNCTION = TRANSITION + "TimingFunction";\n  	}\n\n  	createTransitions = function (t, to, options, changedProperties, resolve) {\n\n  		// Wait a beat (otherwise the target styles will be applied immediately)\n  		// TODO use a fastdom-style mechanism?\n  		setTimeout(function () {\n\n  			var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;\n\n  			checkComplete = function () {\n  				if (jsTransitionsComplete && cssTransitionsComplete) {\n  					// will changes to events and fire have an unexpected consequence here?\n  					t.root.fire(t.name + ":end", t.node, t.isIntro);\n  					resolve();\n  				}\n  			};\n\n  			// this is used to keep track of which elements can use CSS to animate\n  			// which properties\n  			hashPrefix = (t.node.namespaceURI || "") + t.node.tagName;\n\n  			t.node.style[TRANSITION_PROPERTY] = changedProperties.map(helpers_prefix).map(hyphenate).join(",");\n  			t.node.style[TRANSITION_TIMING_FUNCTION] = hyphenate(options.easing || "linear");\n  			t.node.style[TRANSITION_DURATION] = options.duration / 1000 + "s";\n\n  			transitionEndHandler = function (event) {\n  				var index;\n\n  				index = changedProperties.indexOf(camelCase(unprefix(event.propertyName)));\n  				if (index !== -1) {\n  					changedProperties.splice(index, 1);\n  				}\n\n  				if (changedProperties.length) {\n  					// still transitioning...\n  					return;\n  				}\n\n  				t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n  				cssTransitionsComplete = true;\n  				checkComplete();\n  			};\n\n  			t.node.addEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n  			setTimeout(function () {\n  				var i = changedProperties.length,\n  				    hash,\n  				    originalValue,\n  				    index,\n  				    propertiesToTransitionInJs = [],\n  				    prop,\n  				    suffix;\n\n  				while (i--) {\n  					prop = changedProperties[i];\n  					hash = hashPrefix + prop;\n\n  					if (CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[hash]) {\n  						t.node.style[helpers_prefix(prop)] = to[prop];\n\n  						// If we\'re not sure if CSS transitions are supported for\n  						// this tag/property combo, find out now\n  						if (!canUseCssTransitions[hash]) {\n  							originalValue = t.getStyle(prop);\n\n  							// if this property is transitionable in this browser,\n  							// the current style will be different from the target style\n  							canUseCssTransitions[hash] = t.getStyle(prop) != to[prop];\n  							cannotUseCssTransitions[hash] = !canUseCssTransitions[hash];\n\n  							// Reset, if we\'re going to use timers after all\n  							if (cannotUseCssTransitions[hash]) {\n  								t.node.style[helpers_prefix(prop)] = originalValue;\n  							}\n  						}\n  					}\n\n  					if (!CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[hash]) {\n  						// we need to fall back to timer-based stuff\n  						if (originalValue === undefined) {\n  							originalValue = t.getStyle(prop);\n  						}\n\n  						// need to remove this from changedProperties, otherwise transitionEndHandler\n  						// will get confused\n  						index = changedProperties.indexOf(prop);\n  						if (index === -1) {\n  							warnIfDebug("Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!", { node: t.node });\n  						} else {\n  							changedProperties.splice(index, 1);\n  						}\n\n  						// TODO Determine whether this property is animatable at all\n\n  						suffix = /[^\\d]*$/.exec(to[prop])[0];\n\n  						// ...then kick off a timer-based transition\n  						propertiesToTransitionInJs.push({\n  							name: helpers_prefix(prop),\n  							interpolator: shared_interpolate(parseFloat(originalValue), parseFloat(to[prop])),\n  							suffix: suffix\n  						});\n  					}\n  				}\n\n  				// javascript transitions\n  				if (propertiesToTransitionInJs.length) {\n  					new shared_Ticker({\n  						root: t.root,\n  						duration: options.duration,\n  						easing: camelCase(options.easing || ""),\n  						step: function (pos) {\n  							var prop, i;\n\n  							i = propertiesToTransitionInJs.length;\n  							while (i--) {\n  								prop = propertiesToTransitionInJs[i];\n  								t.node.style[prop.name] = prop.interpolator(pos) + prop.suffix;\n  							}\n  						},\n  						complete: function () {\n  							jsTransitionsComplete = true;\n  							checkComplete();\n  						}\n  					});\n  				} else {\n  					jsTransitionsComplete = true;\n  				}\n\n  				if (!changedProperties.length) {\n  					// We need to cancel the transitionEndHandler, and deal with\n  					// the fact that it will never fire\n  					t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n  					cssTransitionsComplete = true;\n  					checkComplete();\n  				}\n  			}, 0);\n  		}, options.delay || 0);\n  	};\n  }\n\n  var animateStyle_createTransitions = createTransitions;\n\n  var hidden, vendor, animateStyle_visibility__prefix, animateStyle_visibility__i, visibility;\n\n  if (typeof document !== "undefined") {\n  	hidden = "hidden";\n\n  	visibility = {};\n\n  	if (hidden in document) {\n  		animateStyle_visibility__prefix = "";\n  	} else {\n  		animateStyle_visibility__i = vendors.length;\n  		while (animateStyle_visibility__i--) {\n  			vendor = vendors[animateStyle_visibility__i];\n  			hidden = vendor + "Hidden";\n\n  			if (hidden in document) {\n  				animateStyle_visibility__prefix = vendor;\n  			}\n  		}\n  	}\n\n  	if (animateStyle_visibility__prefix !== undefined) {\n  		document.addEventListener(animateStyle_visibility__prefix + "visibilitychange", onChange);\n\n  		// initialise\n  		onChange();\n  	} else {\n  		// gah, we\'re in an old browser\n  		if ("onfocusout" in document) {\n  			document.addEventListener("focusout", onHide);\n  			document.addEventListener("focusin", onShow);\n  		} else {\n  			window.addEventListener("pagehide", onHide);\n  			window.addEventListener("blur", onHide);\n\n  			window.addEventListener("pageshow", onShow);\n  			window.addEventListener("focus", onShow);\n  		}\n\n  		visibility.hidden = false; // until proven otherwise. Not ideal but hey\n  	}\n  }\n\n  function onChange() {\n  	visibility.hidden = document[hidden];\n  }\n\n  function onHide() {\n  	visibility.hidden = true;\n  }\n\n  function onShow() {\n  	visibility.hidden = false;\n  }\n\n  var animateStyle_visibility = visibility;\n\n  var animateStyle, _animateStyle__getComputedStyle, resolved;\n\n  if (!isClient) {\n  	animateStyle = null;\n  } else {\n  	_animateStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n  	animateStyle = function (style, value, options) {\n  		var _this = this;\n\n  		var to;\n\n  		if (arguments.length === 4) {\n  			throw new Error("t.animateStyle() returns a promise - use .then() instead of passing a callback");\n  		}\n\n  		// Special case - page isn\'t visible. Don\'t animate anything, because\n  		// that way you\'ll never get CSS transitionend events\n  		if (animateStyle_visibility.hidden) {\n  			this.setStyle(style, value);\n  			return resolved || (resolved = utils_Promise.resolve());\n  		}\n\n  		if (typeof style === "string") {\n  			to = {};\n  			to[style] = value;\n  		} else {\n  			to = style;\n\n  			// shuffle arguments\n  			options = value;\n  		}\n\n  		// As of 0.3.9, transition authors should supply an `option` object with\n  		// `duration` and `easing` properties (and optional `delay`), plus a\n  		// callback function that gets called after the animation completes\n\n  		// TODO remove this check in a future version\n  		if (!options) {\n  			warnOnceIfDebug("The \\"%s\\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340", this.name);\n  			options = this;\n  		}\n\n  		var promise = new utils_Promise(function (resolve) {\n  			var propertyNames, changedProperties, computedStyle, current, from, i, prop;\n\n  			// Edge case - if duration is zero, set style synchronously and complete\n  			if (!options.duration) {\n  				_this.setStyle(to);\n  				resolve();\n  				return;\n  			}\n\n  			// Get a list of the properties we\'re animating\n  			propertyNames = Object.keys(to);\n  			changedProperties = [];\n\n  			// Store the current styles\n  			computedStyle = _animateStyle__getComputedStyle(_this.node);\n\n  			from = {};\n  			i = propertyNames.length;\n  			while (i--) {\n  				prop = propertyNames[i];\n  				current = computedStyle[helpers_prefix(prop)];\n\n  				if (current === "0px") {\n  					current = 0;\n  				}\n\n  				// we need to know if we\'re actually changing anything\n  				if (current != to[prop]) {\n  					// use != instead of !==, so we can compare strings with numbers\n  					changedProperties.push(prop);\n\n  					// make the computed style explicit, so we can animate where\n  					// e.g. height=\'auto\'\n  					_this.node.style[helpers_prefix(prop)] = current;\n  				}\n  			}\n\n  			// If we\'re not actually changing anything, the transitionend event\n  			// will never fire! So we complete early\n  			if (!changedProperties.length) {\n  				resolve();\n  				return;\n  			}\n\n  			animateStyle_createTransitions(_this, to, options, changedProperties, resolve);\n  		});\n\n  		return promise;\n  	};\n  }\n\n  var _animateStyle = animateStyle;\n\n  var processParams = function (params, defaults) {\n  	if (typeof params === "number") {\n  		params = { duration: params };\n  	} else if (typeof params === "string") {\n  		if (params === "slow") {\n  			params = { duration: 600 };\n  		} else if (params === "fast") {\n  			params = { duration: 200 };\n  		} else {\n  			params = { duration: 400 };\n  		}\n  	} else if (!params) {\n  		params = {};\n  	}\n\n  	return fillGaps({}, params, defaults);\n  };\n\n  var prototype_start = Transition$start;\n\n  function Transition$start() {\n  	var _this = this;\n\n  	var node, originalStyle, completed;\n\n  	node = this.node = this.element.node;\n  	originalStyle = node.getAttribute("style");\n\n  	// create t.complete() - we don\'t want this on the prototype,\n  	// because we don\'t want `this` silliness when passing it as\n  	// an argument\n  	this.complete = function (noReset) {\n  		if (completed) {\n  			return;\n  		}\n\n  		if (!noReset && _this.isIntro) {\n  			resetStyle(node, originalStyle);\n  		}\n\n  		node._ractive.transition = null;\n  		_this._manager.remove(_this);\n\n  		completed = true;\n  	};\n\n  	// If the transition function doesn\'t exist, abort\n  	if (!this._fn) {\n  		this.complete();\n  		return;\n  	}\n\n  	this._fn.apply(this.root, [this].concat(this.params));\n  }\n\n  function resetStyle(node, style) {\n  	if (style) {\n  		node.setAttribute("style", style);\n  	} else {\n\n  		// Next line is necessary, to remove empty style attribute!\n  		// See http://stackoverflow.com/a/7167553\n  		node.getAttribute("style");\n  		node.removeAttribute("style");\n  	}\n  }\n\n  var Transition = function (owner, template, isIntro) {\n  	this.init(owner, template, isIntro);\n  };\n\n  Transition.prototype = {\n  	init: Transition_prototype_init,\n  	start: prototype_start,\n  	getStyle: prototype_getStyle,\n  	setStyle: setStyle,\n  	animateStyle: _animateStyle,\n  	processParams: processParams\n  };\n\n  var _Transition = Transition;\n\n  var Element_prototype_render = Element$render;\n\n  var updateCss, updateScript;\n\n  updateCss = function () {\n  	var node = this.node,\n  	    content = this.fragment.toString(false);\n\n  	// IE8 has no styleSheet unless there\'s a type text/css\n  	if (window && window.appearsToBeIELessEqual8) {\n  		node.type = "text/css";\n  	}\n\n  	if (node.styleSheet) {\n  		node.styleSheet.cssText = content;\n  	} else {\n\n  		while (node.hasChildNodes()) {\n  			node.removeChild(node.firstChild);\n  		}\n\n  		node.appendChild(document.createTextNode(content));\n  	}\n  };\n\n  updateScript = function () {\n  	if (!this.node.type || this.node.type === "text/javascript") {\n  		warnIfDebug("Script tag was updated. This does not cause the code to be re-evaluated!", { ractive: this.root });\n  		// As it happens, we ARE in a position to re-evaluate the code if we wanted\n  		// to - we could eval() it, or insert it into a fresh (temporary) script tag.\n  		// But this would be a terrible idea with unpredictable results, so let\'s not.\n  	}\n\n  	this.node.text = this.fragment.toString(false);\n  };\n  function Element$render() {\n  	var _this = this;\n\n  	var root = this.root,\n  	    namespace,\n  	    node,\n  	    transition;\n\n  	namespace = getNamespace(this);\n  	node = this.node = createElement(this.name, namespace);\n\n  	// Is this a top-level node of a component? If so, we may need to add\n  	// a data-ractive-css attribute, for CSS encapsulation\n  	if (this.parentFragment.cssIds) {\n  		this.node.setAttribute("data-ractive-css", this.parentFragment.cssIds.map(function (x) {\n  			return "{" + x + "}";\n  		}).join(" "));\n  	}\n\n  	// Add _ractive property to the node - we use this object to store stuff\n  	// related to proxy events, two-way bindings etc\n  	defineProperty(this.node, "_ractive", {\n  		value: {\n  			proxy: this,\n  			keypath: getInnerContext(this.parentFragment),\n  			events: create(null),\n  			root: root\n  		}\n  	});\n\n  	// Render attributes\n  	this.attributes.forEach(function (a) {\n  		return a.render(node);\n  	});\n  	this.conditionalAttributes.forEach(function (a) {\n  		return a.render(node);\n  	});\n\n  	// Render children\n  	if (this.fragment) {\n  		// Special case - <script> element\n  		if (this.name === "script") {\n  			this.bubble = updateScript;\n  			this.node.text = this.fragment.toString(false); // bypass warning initially\n  			this.fragment.unrender = noop; // TODO this is a kludge\n  		}\n\n  		// Special case - <style> element\n  		else if (this.name === "style") {\n  			this.bubble = updateCss;\n  			this.bubble();\n  			this.fragment.unrender = noop;\n  		}\n\n  		// Special case - contenteditable\n  		else if (this.binding && this.getAttribute("contenteditable")) {\n  			this.fragment.unrender = noop;\n  		} else {\n  			this.node.appendChild(this.fragment.render());\n  		}\n  	}\n\n  	// deal with two-way bindings\n  	if (this.binding) {\n  		this.binding.render();\n  		this.node._ractive.binding = this.binding;\n  	}\n\n  	// Add proxy event handlers\n  	if (this.eventHandlers) {\n  		this.eventHandlers.forEach(function (h) {\n  			return h.render();\n  		});\n  	}\n\n  	if (this.name === "option") {\n  		processOption(this);\n  	}\n\n  	// Special cases\n  	if (this.name === "img") {\n  		// if this is an <img>, and we\'re in a crap browser, we may\n  		// need to prevent it from overriding width and height when\n  		// it loads the src\n  		special_img__render(this);\n  	} else if (this.name === "form") {\n  		// forms need to keep track of their bindings, in case of reset\n  		form__render(this);\n  	} else if (this.name === "input" || this.name === "textarea") {\n  		// inputs and textareas should store their initial value as\n  		// `defaultValue` in case of reset\n  		this.node.defaultValue = this.node.value;\n  	} else if (this.name === "option") {\n  		// similarly for option nodes\n  		this.node.defaultSelected = this.node.selected;\n  	}\n\n  	// apply decorator(s)\n  	if (this.decorator && this.decorator.fn) {\n  		global_runloop.scheduleTask(function () {\n  			if (!_this.decorator.torndown) {\n  				_this.decorator.init();\n  			}\n  		}, true);\n  	}\n\n  	// trigger intro transition\n  	if (root.transitionsEnabled && this.intro) {\n  		transition = new _Transition(this, this.intro, true);\n  		global_runloop.registerTransition(transition);\n  		global_runloop.scheduleTask(function () {\n  			return transition.start();\n  		}, true);\n\n  		this.transition = transition;\n  	}\n\n  	if (this.node.autofocus) {\n  		// Special case. Some browsers (*cough* Firefix *cough*) have a problem\n  		// with dynamically-generated elements having autofocus, and they won\'t\n  		// allow you to programmatically focus the element until it\'s in the DOM\n  		global_runloop.scheduleTask(function () {\n  			return _this.node.focus();\n  		}, true);\n  	}\n\n  	updateLiveQueries(this);\n  	return this.node;\n  }\n\n  function getNamespace(element) {\n  	var namespace, xmlns, parent;\n\n  	// Use specified namespace...\n  	if (xmlns = element.getAttribute("xmlns")) {\n  		namespace = xmlns;\n  	}\n\n  	// ...or SVG namespace, if this is an <svg> element\n  	else if (element.name === "svg") {\n  		namespace = namespaces.svg;\n  	} else if (parent = element.parent) {\n  		// ...or HTML, if the parent is a <foreignObject>\n  		if (parent.name === "foreignObject") {\n  			namespace = namespaces.html;\n  		}\n\n  		// ...or inherit from the parent node\n  		else {\n  			namespace = parent.node.namespaceURI;\n  		}\n  	} else {\n  		namespace = element.root.el.namespaceURI;\n  	}\n\n  	return namespace;\n  }\n\n  function processOption(option) {\n  	var optionValue, selectValue, i;\n\n  	if (!option.select) {\n  		return;\n  	}\n\n  	selectValue = option.select.getAttribute("value");\n  	if (selectValue === undefined) {\n  		return;\n  	}\n\n  	optionValue = option.getAttribute("value");\n\n  	if (option.select.node.multiple && isArray(selectValue)) {\n  		i = selectValue.length;\n  		while (i--) {\n  			if (optionValue == selectValue[i]) {\n  				option.node.selected = true;\n  				break;\n  			}\n  		}\n  	} else {\n  		option.node.selected = optionValue == selectValue;\n  	}\n  }\n\n  function updateLiveQueries(element) {\n  	var instance, liveQueries, i, selector, query;\n\n  	// Does this need to be added to any live queries?\n  	instance = element.root;\n\n  	do {\n  		liveQueries = instance._liveQueries;\n\n  		i = liveQueries.length;\n  		while (i--) {\n  			selector = liveQueries[i];\n  			query = liveQueries["_" + selector];\n\n  			if (query._test(element)) {\n  				// keep register of applicable selectors, for when we teardown\n  				(element.liveQueries || (element.liveQueries = [])).push(query);\n  			}\n  		}\n  	} while (instance = instance.parent);\n  }\n\n  var Element_prototype_toString = function () {\n  	var str, escape;\n\n  	if (this.template.y) {\n  		// DOCTYPE declaration\n  		return "<!DOCTYPE" + this.template.dd + ">";\n  	}\n\n  	str = "<" + this.template.e;\n\n  	str += this.attributes.map(stringifyAttribute).join("") + this.conditionalAttributes.map(stringifyAttribute).join("");\n\n  	// Special case - selected options\n  	if (this.name === "option" && optionIsSelected(this)) {\n  		str += " selected";\n  	}\n\n  	// Special case - two-way radio name bindings\n  	if (this.name === "input" && inputIsCheckedRadio(this)) {\n  		str += " checked";\n  	}\n\n  	str += ">";\n\n  	// Special case - textarea\n  	if (this.name === "textarea" && this.getAttribute("value") !== undefined) {\n  		str += escapeHtml(this.getAttribute("value"));\n  	}\n\n  	// Special case - contenteditable\n  	else if (this.getAttribute("contenteditable") !== undefined) {\n  		str += this.getAttribute("value") || "";\n  	}\n\n  	if (this.fragment) {\n  		escape = this.name !== "script" && this.name !== "style";\n  		str += this.fragment.toString(escape);\n  	}\n\n  	// add a closing tag if this isn\'t a void element\n  	if (!voidElementNames.test(this.template.e)) {\n  		str += "</" + this.template.e + ">";\n  	}\n\n  	return str;\n  };\n\n  function optionIsSelected(element) {\n  	var optionValue, selectValue, i;\n\n  	optionValue = element.getAttribute("value");\n\n  	if (optionValue === undefined || !element.select) {\n  		return false;\n  	}\n\n  	selectValue = element.select.getAttribute("value");\n\n  	if (selectValue == optionValue) {\n  		return true;\n  	}\n\n  	if (element.select.getAttribute("multiple") && isArray(selectValue)) {\n  		i = selectValue.length;\n  		while (i--) {\n  			if (selectValue[i] == optionValue) {\n  				return true;\n  			}\n  		}\n  	}\n  }\n\n  function inputIsCheckedRadio(element) {\n  	var attributes, typeAttribute, valueAttribute, nameAttribute;\n\n  	attributes = element.attributes;\n\n  	typeAttribute = attributes.type;\n  	valueAttribute = attributes.value;\n  	nameAttribute = attributes.name;\n\n  	if (!typeAttribute || typeAttribute.value !== "radio" || !valueAttribute || !nameAttribute.interpolator) {\n  		return;\n  	}\n\n  	if (valueAttribute.value === nameAttribute.interpolator.value) {\n  		return true;\n  	}\n  }\n\n  function stringifyAttribute(attribute) {\n  	var str = attribute.toString();\n  	return str ? " " + str : "";\n  }\n\n  var Element_prototype_unbind = Element$unbind;\n  function Element$unbind() {\n  	if (this.fragment) {\n  		this.fragment.unbind();\n  	}\n\n  	if (this.binding) {\n  		this.binding.unbind();\n  	}\n\n  	if (this.eventHandlers) {\n  		this.eventHandlers.forEach(methodCallers__unbind);\n  	}\n\n  	// Special case - <option>\n  	if (this.name === "option") {\n  		special_option__unbind(this);\n  	}\n\n  	this.attributes.forEach(methodCallers__unbind);\n  	this.conditionalAttributes.forEach(methodCallers__unbind);\n  }\n\n  var Element_prototype_unrender = Element$unrender;\n\n  function Element$unrender(shouldDestroy) {\n  	var binding, bindings, transition;\n\n  	if (transition = this.transition) {\n  		transition.complete();\n  	}\n\n  	// Detach as soon as we can\n  	if (this.name === "option") {\n  		// <option> elements detach immediately, so that\n  		// their parent <select> element syncs correctly, and\n  		// since option elements can\'t have transitions anyway\n  		this.detach();\n  	} else if (shouldDestroy) {\n  		global_runloop.detachWhenReady(this);\n  	}\n\n  	// Children first. that way, any transitions on child elements will be\n  	// handled by the current transitionManager\n  	if (this.fragment) {\n  		this.fragment.unrender(false);\n  	}\n\n  	if (binding = this.binding) {\n  		this.binding.unrender();\n\n  		this.node._ractive.binding = null;\n  		bindings = this.root._twowayBindings[binding.keypath.str];\n  		bindings.splice(bindings.indexOf(binding), 1);\n  	}\n\n  	// Remove event handlers\n  	if (this.eventHandlers) {\n  		this.eventHandlers.forEach(methodCallers__unrender);\n  	}\n\n  	if (this.decorator) {\n  		global_runloop.registerDecorator(this.decorator);\n  	}\n\n  	// trigger outro transition if necessary\n  	if (this.root.transitionsEnabled && this.outro) {\n  		transition = new _Transition(this, this.outro, false);\n  		global_runloop.registerTransition(transition);\n  		global_runloop.scheduleTask(function () {\n  			return transition.start();\n  		});\n  	}\n\n  	// Remove this node from any live queries\n  	if (this.liveQueries) {\n  		removeFromLiveQueries(this);\n  	}\n\n  	if (this.name === "form") {\n  		form__unrender(this);\n  	}\n  }\n\n  function removeFromLiveQueries(element) {\n  	var query, selector, i;\n\n  	i = element.liveQueries.length;\n  	while (i--) {\n  		query = element.liveQueries[i];\n  		selector = query.selector;\n\n  		query._remove(element.node);\n  	}\n  }\n\n  var Element = function (options) {\n  	this.init(options);\n  };\n\n  Element.prototype = {\n  	bubble: Element_prototype_bubble,\n  	detach: Element_prototype_detach,\n  	find: Element_prototype_find,\n  	findAll: Element_prototype_findAll,\n  	findAllComponents: Element_prototype_findAllComponents,\n  	findComponent: Element_prototype_findComponent,\n  	findNextNode: Element_prototype_findNextNode,\n  	firstNode: Element_prototype_firstNode,\n  	getAttribute: getAttribute,\n  	init: Element_prototype_init,\n  	rebind: Element_prototype_rebind,\n  	render: Element_prototype_render,\n  	toString: Element_prototype_toString,\n  	unbind: Element_prototype_unbind,\n  	unrender: Element_prototype_unrender\n  };\n\n  var _Element = Element;\n\n  var deIndent__empty = /^\\s*$/,\n      deIndent__leadingWhitespace = /^\\s*/;\n\n  var deIndent = function (str) {\n  	var lines, firstLine, lastLine, minIndent;\n\n  	lines = str.split("\\n");\n\n  	// remove first and last line, if they only contain whitespace\n  	firstLine = lines[0];\n  	if (firstLine !== undefined && deIndent__empty.test(firstLine)) {\n  		lines.shift();\n  	}\n\n  	lastLine = lastItem(lines);\n  	if (lastLine !== undefined && deIndent__empty.test(lastLine)) {\n  		lines.pop();\n  	}\n\n  	minIndent = lines.reduce(reducer, null);\n\n  	if (minIndent) {\n  		str = lines.map(function (line) {\n  			return line.replace(minIndent, "");\n  		}).join("\\n");\n  	}\n\n  	return str;\n  };\n\n  function reducer(previous, line) {\n  	var lineIndent = deIndent__leadingWhitespace.exec(line)[0];\n\n  	if (previous === null || lineIndent.length < previous.length) {\n  		return lineIndent;\n  	}\n\n  	return previous;\n  }\n\n  var Partial_getPartialTemplate = getPartialTemplate;\n\n  function getPartialTemplate(ractive, name, parentFragment) {\n  	var partial;\n\n  	// If the partial in instance or view heirarchy instances, great\n  	if (partial = getPartialFromRegistry(ractive, name, parentFragment || {})) {\n  		return partial;\n  	}\n\n  	// Does it exist on the page as a script tag?\n  	partial = template_parser.fromId(name, { noThrow: true });\n\n  	if (partial) {\n  		// is this necessary?\n  		partial = deIndent(partial);\n\n  		// parse and register to this ractive instance\n  		var parsed = template_parser.parse(partial, template_parser.getParseOptions(ractive));\n\n  		// register (and return main partial if there are others in the template)\n  		return ractive.partials[name] = parsed.t;\n  	}\n  }\n\n  function getPartialFromRegistry(ractive, name, parentFragment) {\n  	var fn = undefined,\n  	    partial = findParentPartial(name, parentFragment.owner);\n\n  	// if there was an instance up-hierarchy, cool\n  	if (partial) return partial;\n\n  	// find first instance in the ractive or view hierarchy that has this partial\n  	var instance = findInstance("partials", ractive, name);\n\n  	if (!instance) {\n  		return;\n  	}\n\n  	partial = instance.partials[name];\n\n  	// partial is a function?\n  	if (typeof partial === "function") {\n  		fn = partial.bind(instance);\n  		fn.isOwner = instance.partials.hasOwnProperty(name);\n  		partial = fn.call(ractive, template_parser);\n  	}\n\n  	if (!partial && partial !== "") {\n  		warnIfDebug(noRegistryFunctionReturn, name, "partial", "partial", { ractive: ractive });\n  		return;\n  	}\n\n  	// If this was added manually to the registry,\n  	// but hasn\'t been parsed, parse it now\n  	if (!template_parser.isParsed(partial)) {\n\n  		// use the parseOptions of the ractive instance on which it was found\n  		var parsed = template_parser.parse(partial, template_parser.getParseOptions(instance));\n\n  		// Partials cannot contain nested partials!\n  		// TODO add a test for this\n  		if (parsed.p) {\n  			warnIfDebug("Partials ({{>%s}}) cannot contain nested inline partials", name, { ractive: ractive });\n  		}\n\n  		// if fn, use instance to store result, otherwise needs to go\n  		// in the correct point in prototype chain on instance or constructor\n  		var target = fn ? instance : findOwner(instance, name);\n\n  		// may be a template with partials, which need to be registered and main template extracted\n  		target.partials[name] = partial = parsed.t;\n  	}\n\n  	// store for reset\n  	if (fn) {\n  		partial._fn = fn;\n  	}\n\n  	return partial.v ? partial.t : partial;\n  }\n\n  function findOwner(ractive, key) {\n  	return ractive.partials.hasOwnProperty(key) ? ractive : findConstructor(ractive.constructor, key);\n  }\n\n  function findConstructor(constructor, key) {\n  	if (!constructor) {\n  		return;\n  	}\n  	return constructor.partials.hasOwnProperty(key) ? constructor : findConstructor(constructor._Parent, key);\n  }\n\n  function findParentPartial(name, parent) {\n  	if (parent) {\n  		if (parent.template && parent.template.p && parent.template.p[name]) {\n  			return parent.template.p[name];\n  		} else if (parent.parentFragment && parent.parentFragment.owner) {\n  			return findParentPartial(name, parent.parentFragment.owner);\n  		}\n  	}\n  }\n\n  var applyIndent = function (string, indent) {\n  	var indented;\n\n  	if (!indent) {\n  		return string;\n  	}\n\n  	indented = string.split("\\n").map(function (line, notFirstLine) {\n  		return notFirstLine ? indent + line : line;\n  	}).join("\\n");\n\n  	return indented;\n  };\n\n  var missingPartialMessage = "Could not find template for partial \\"%s\\"";\n\n  var Partial = function (options) {\n  	var parentFragment, template;\n\n  	parentFragment = this.parentFragment = options.parentFragment;\n\n  	this.root = parentFragment.root;\n  	this.type = PARTIAL;\n  	this.index = options.index;\n  	this.name = options.template.r;\n  	this.rendered = false;\n\n  	this.fragment = this.fragmentToRender = this.fragmentToUnrender = null;\n\n  	Mustache.init(this, options);\n\n  	// If this didn\'t resolve, it most likely means we have a named partial\n  	// (i.e. `{{>foo}}` means \'use the foo partial\', not \'use the partial\n  	// whose name is the value of `foo`\')\n  	if (!this.keypath) {\n  		if (template = Partial_getPartialTemplate(this.root, this.name, parentFragment)) {\n  			shared_unbind.call(this); // prevent any further changes\n  			this.isNamed = true;\n  			this.setTemplate(template);\n  		} else {\n  			warnOnceIfDebug(missingPartialMessage, this.name);\n  		}\n  	}\n  };\n\n  Partial.prototype = {\n  	bubble: function () {\n  		this.parentFragment.bubble();\n  	},\n\n  	detach: function () {\n  		return this.fragment.detach();\n  	},\n\n  	find: function (selector) {\n  		return this.fragment.find(selector);\n  	},\n\n  	findAll: function (selector, query) {\n  		return this.fragment.findAll(selector, query);\n  	},\n\n  	findComponent: function (selector) {\n  		return this.fragment.findComponent(selector);\n  	},\n\n  	findAllComponents: function (selector, query) {\n  		return this.fragment.findAllComponents(selector, query);\n  	},\n\n  	firstNode: function () {\n  		return this.fragment.firstNode();\n  	},\n\n  	findNextNode: function () {\n  		return this.parentFragment.findNextNode(this);\n  	},\n\n  	getPartialName: function () {\n  		if (this.isNamed && this.name) return this.name;else if (this.value === undefined) return this.name;else return this.value;\n  	},\n\n  	getValue: function () {\n  		return this.fragment.getValue();\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		// named partials aren\'t bound, so don\'t rebind\n  		if (!this.isNamed) {\n  			Mustache_rebind.call(this, oldKeypath, newKeypath);\n  		}\n\n  		if (this.fragment) {\n  			this.fragment.rebind(oldKeypath, newKeypath);\n  		}\n  	},\n\n  	render: function () {\n  		this.docFrag = document.createDocumentFragment();\n  		this.update();\n\n  		this.rendered = true;\n  		return this.docFrag;\n  	},\n\n  	resolve: Mustache.resolve,\n\n  	setValue: function (value) {\n  		var template;\n\n  		if (value !== undefined && value === this.value) {\n  			// nothing has changed, so no work to be done\n  			return;\n  		}\n\n  		if (value !== undefined) {\n  			template = Partial_getPartialTemplate(this.root, "" + value, this.parentFragment);\n  		}\n\n  		// we may be here if we have a partial like `{{>foo}}` and `foo` is the\n  		// name of both a data property (whose value ISN\'T the name of a partial)\n  		// and a partial. In those cases, this becomes a named partial\n  		if (!template && this.name && (template = Partial_getPartialTemplate(this.root, this.name, this.parentFragment))) {\n  			shared_unbind.call(this);\n  			this.isNamed = true;\n  		}\n\n  		if (!template) {\n  			warnOnceIfDebug(missingPartialMessage, this.name, { ractive: this.root });\n  		}\n\n  		this.value = value;\n\n  		this.setTemplate(template || []);\n\n  		this.bubble();\n\n  		if (this.rendered) {\n  			global_runloop.addView(this);\n  		}\n  	},\n\n  	setTemplate: function (template) {\n  		if (this.fragment) {\n  			this.fragment.unbind();\n  			if (this.rendered) {\n  				this.fragmentToUnrender = this.fragment;\n  			}\n  		}\n\n  		this.fragment = new virtualdom_Fragment({\n  			template: template,\n  			root: this.root,\n  			owner: this,\n  			pElement: this.parentFragment.pElement\n  		});\n\n  		this.fragmentToRender = this.fragment;\n  	},\n\n  	toString: function (toString) {\n  		var string, previousItem, lastLine, match;\n\n  		string = this.fragment.toString(toString);\n\n  		previousItem = this.parentFragment.items[this.index - 1];\n\n  		if (!previousItem || previousItem.type !== TEXT) {\n  			return string;\n  		}\n\n  		lastLine = previousItem.text.split("\\n").pop();\n\n  		if (match = /^\\s+$/.exec(lastLine)) {\n  			return applyIndent(string, match[0]);\n  		}\n\n  		return string;\n  	},\n\n  	unbind: function () {\n  		if (!this.isNamed) {\n  			// dynamic partial - need to unbind self\n  			shared_unbind.call(this);\n  		}\n\n  		if (this.fragment) {\n  			this.fragment.unbind();\n  		}\n  	},\n\n  	unrender: function (shouldDestroy) {\n  		if (this.rendered) {\n  			if (this.fragment) {\n  				this.fragment.unrender(shouldDestroy);\n  			}\n  			this.rendered = false;\n  		}\n  	},\n\n  	update: function () {\n  		var target, anchor;\n\n  		if (this.fragmentToUnrender) {\n  			this.fragmentToUnrender.unrender(true);\n  			this.fragmentToUnrender = null;\n  		}\n\n  		if (this.fragmentToRender) {\n  			this.docFrag.appendChild(this.fragmentToRender.render());\n  			this.fragmentToRender = null;\n  		}\n\n  		if (this.rendered) {\n  			target = this.parentFragment.getNode();\n  			anchor = this.parentFragment.findNextNode(this);\n  			target.insertBefore(this.docFrag, anchor);\n  		}\n  	}\n  };\n\n  var _Partial = Partial;\n\n  // finds the component constructor in the registry or view hierarchy registries\n\n  var Component_getComponent = getComponent;\n  function getComponent(ractive, name) {\n\n  	var Component,\n  	    instance = findInstance("components", ractive, name);\n\n  	if (instance) {\n  		Component = instance.components[name];\n\n  		// best test we have for not Ractive.extend\n  		if (!Component._Parent) {\n  			// function option, execute and store for reset\n  			var fn = Component.bind(instance);\n  			fn.isOwner = instance.components.hasOwnProperty(name);\n  			Component = fn();\n\n  			if (!Component) {\n  				warnIfDebug(noRegistryFunctionReturn, name, "component", "component", { ractive: ractive });\n\n  				return;\n  			}\n\n  			if (typeof Component === "string") {\n  				// allow string lookup\n  				Component = getComponent(ractive, Component);\n  			}\n\n  			Component._fn = fn;\n  			instance.components[name] = Component;\n  		}\n  	}\n\n  	return Component;\n  }\n\n  var Component_prototype_detach = Component$detach;\n  var Component_prototype_detach__detachHook = new hooks_Hook("detach");\n  function Component$detach() {\n  	var detached = this.instance.fragment.detach();\n  	Component_prototype_detach__detachHook.fire(this.instance);\n  	return detached;\n  }\n\n  var Component_prototype_find = Component$find;\n\n  function Component$find(selector) {\n  	return this.instance.fragment.find(selector);\n  }\n\n  var Component_prototype_findAll = Component$findAll;\n\n  function Component$findAll(selector, query) {\n  	return this.instance.fragment.findAll(selector, query);\n  }\n\n  var Component_prototype_findAllComponents = Component$findAllComponents;\n\n  function Component$findAllComponents(selector, query) {\n  	query._test(this, true);\n\n  	if (this.instance.fragment) {\n  		this.instance.fragment.findAllComponents(selector, query);\n  	}\n  }\n\n  var Component_prototype_findComponent = Component$findComponent;\n\n  function Component$findComponent(selector) {\n  	if (!selector || selector === this.name) {\n  		return this.instance;\n  	}\n\n  	if (this.instance.fragment) {\n  		return this.instance.fragment.findComponent(selector);\n  	}\n\n  	return null;\n  }\n\n  var Component_prototype_findNextNode = Component$findNextNode;\n\n  function Component$findNextNode() {\n  	return this.parentFragment.findNextNode(this);\n  }\n\n  var Component_prototype_firstNode = Component$firstNode;\n\n  function Component$firstNode() {\n  	if (this.rendered) {\n  		return this.instance.fragment.firstNode();\n  	}\n\n  	return null;\n  }\n\n  var processWrapper = function (wrapper, array, methodName, newIndices) {\n  	var root = wrapper.root;\n  	var keypath = wrapper.keypath;\n\n  	if (!!newIndices) {\n  		root.viewmodel.smartUpdate(keypath, array, newIndices);\n  	} else {\n  		// If this is a sort or reverse, we just do root.set()...\n  		// TODO use merge logic?\n  		root.viewmodel.mark(keypath);\n  	}\n  };\n\n  var patchedArrayProto = [],\n      mutatorMethods = ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"],\n      testObj,\n      patchArrayMethods,\n      unpatchArrayMethods;\n\n  mutatorMethods.forEach(function (methodName) {\n  	var method = function () {\n  		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n  			args[_key] = arguments[_key];\n  		}\n\n  		var newIndices, result, wrapper, i;\n\n  		newIndices = shared_getNewIndices(this, methodName, args);\n\n  		// apply the underlying method\n  		result = Array.prototype[methodName].apply(this, arguments);\n\n  		// trigger changes\n  		global_runloop.start();\n\n  		this._ractive.setting = true;\n  		i = this._ractive.wrappers.length;\n  		while (i--) {\n  			wrapper = this._ractive.wrappers[i];\n\n  			global_runloop.addRactive(wrapper.root);\n  			processWrapper(wrapper, this, methodName, newIndices);\n  		}\n\n  		global_runloop.end();\n\n  		this._ractive.setting = false;\n  		return result;\n  	};\n\n  	defineProperty(patchedArrayProto, methodName, {\n  		value: method\n  	});\n  });\n\n  // can we use prototype chain injection?\n  // http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\n  testObj = {};\n\n  if (testObj.__proto__) {\n  	// yes, we can\n  	patchArrayMethods = function (array) {\n  		array.__proto__ = patchedArrayProto;\n  	};\n\n  	unpatchArrayMethods = function (array) {\n  		array.__proto__ = Array.prototype;\n  	};\n  } else {\n  	// no, we can\'t\n  	patchArrayMethods = function (array) {\n  		var i, methodName;\n\n  		i = mutatorMethods.length;\n  		while (i--) {\n  			methodName = mutatorMethods[i];\n  			defineProperty(array, methodName, {\n  				value: patchedArrayProto[methodName],\n  				configurable: true\n  			});\n  		}\n  	};\n\n  	unpatchArrayMethods = function (array) {\n  		var i;\n\n  		i = mutatorMethods.length;\n  		while (i--) {\n  			delete array[mutatorMethods[i]];\n  		}\n  	};\n  }\n\n  patchArrayMethods.unpatch = unpatchArrayMethods;\n  var patch = patchArrayMethods;\n\n  var arrayAdaptor,\n\n  // helpers\n  ArrayWrapper, array_index__errorMessage;\n\n  arrayAdaptor = {\n  	filter: function (object) {\n  		// wrap the array if a) b) it\'s an array, and b) either it hasn\'t been wrapped already,\n  		// or the array didn\'t trigger the get() itself\n  		return isArray(object) && (!object._ractive || !object._ractive.setting);\n  	},\n  	wrap: function (ractive, array, keypath) {\n  		return new ArrayWrapper(ractive, array, keypath);\n  	}\n  };\n\n  ArrayWrapper = function (ractive, array, keypath) {\n  	this.root = ractive;\n  	this.value = array;\n  	this.keypath = getKeypath(keypath);\n\n  	// if this array hasn\'t already been ractified, ractify it\n  	if (!array._ractive) {\n\n  		// define a non-enumerable _ractive property to store the wrappers\n  		defineProperty(array, "_ractive", {\n  			value: {\n  				wrappers: [],\n  				instances: [],\n  				setting: false\n  			},\n  			configurable: true\n  		});\n\n  		patch(array);\n  	}\n\n  	// store the ractive instance, so we can handle transitions later\n  	if (!array._ractive.instances[ractive._guid]) {\n  		array._ractive.instances[ractive._guid] = 0;\n  		array._ractive.instances.push(ractive);\n  	}\n\n  	array._ractive.instances[ractive._guid] += 1;\n  	array._ractive.wrappers.push(this);\n  };\n\n  ArrayWrapper.prototype = {\n  	get: function () {\n  		return this.value;\n  	},\n  	teardown: function () {\n  		var array, storage, wrappers, instances, index;\n\n  		array = this.value;\n  		storage = array._ractive;\n  		wrappers = storage.wrappers;\n  		instances = storage.instances;\n\n  		// if teardown() was invoked because we\'re clearing the cache as a result of\n  		// a change that the array itself triggered, we can save ourselves the teardown\n  		// and immediate setup\n  		if (storage.setting) {\n  			return false; // so that we don\'t remove it from this.root.viewmodel.wrapped\n  		}\n\n  		index = wrappers.indexOf(this);\n  		if (index === -1) {\n  			throw new Error(array_index__errorMessage);\n  		}\n\n  		wrappers.splice(index, 1);\n\n  		// if nothing else depends on this array, we can revert it to its\n  		// natural state\n  		if (!wrappers.length) {\n  			delete array._ractive;\n  			patch.unpatch(this.value);\n  		} else {\n  			// remove ractive instance if possible\n  			instances[this.root._guid] -= 1;\n  			if (!instances[this.root._guid]) {\n  				index = instances.indexOf(this.root);\n\n  				if (index === -1) {\n  					throw new Error(array_index__errorMessage);\n  				}\n\n  				instances.splice(index, 1);\n  			}\n  		}\n  	}\n  };\n\n  array_index__errorMessage = "Something went wrong in a rather interesting way";\n  var array_index = arrayAdaptor;\n\n  var numeric = /^\\s*[0-9]+\\s*$/;\n\n  var createBranch = function (key) {\n  	return numeric.test(key) ? [] : {};\n  };\n\n  var magicAdaptor, MagicWrapper;\n\n  try {\n  	Object.defineProperty({}, "test", { value: 0 });\n\n  	magicAdaptor = {\n  		filter: function (object, keypath, ractive) {\n  			var parentWrapper, parentValue;\n\n  			if (!keypath) {\n  				return false;\n  			}\n\n  			keypath = getKeypath(keypath);\n\n  			// If the parent value is a wrapper, other than a magic wrapper,\n  			// we shouldn\'t wrap this property\n  			if ((parentWrapper = ractive.viewmodel.wrapped[keypath.parent.str]) && !parentWrapper.magic) {\n  				return false;\n  			}\n\n  			parentValue = ractive.viewmodel.get(keypath.parent);\n\n  			// if parentValue is an array that doesn\'t include this member,\n  			// we should return false otherwise lengths will get messed up\n  			if (isArray(parentValue) && /^[0-9]+$/.test(keypath.lastKey)) {\n  				return false;\n  			}\n\n  			return parentValue && (typeof parentValue === "object" || typeof parentValue === "function");\n  		},\n  		wrap: function (ractive, property, keypath) {\n  			return new MagicWrapper(ractive, property, keypath);\n  		}\n  	};\n\n  	MagicWrapper = function (ractive, value, keypath) {\n  		var objKeypath, template, siblings;\n\n  		keypath = getKeypath(keypath);\n\n  		this.magic = true;\n\n  		this.ractive = ractive;\n  		this.keypath = keypath;\n  		this.value = value;\n\n  		this.prop = keypath.lastKey;\n\n  		objKeypath = keypath.parent;\n  		this.obj = objKeypath.isRoot ? ractive.viewmodel.data : ractive.viewmodel.get(objKeypath);\n\n  		template = this.originalDescriptor = Object.getOwnPropertyDescriptor(this.obj, this.prop);\n\n  		// Has this property already been wrapped?\n  		if (template && template.set && (siblings = template.set._ractiveWrappers)) {\n\n  			// Yes. Register this wrapper to this property, if it hasn\'t been already\n  			if (siblings.indexOf(this) === -1) {\n  				siblings.push(this);\n  			}\n\n  			return; // already wrapped\n  		}\n\n  		// No, it hasn\'t been wrapped\n  		createAccessors(this, value, template);\n  	};\n\n  	MagicWrapper.prototype = {\n  		get: function () {\n  			return this.value;\n  		},\n  		reset: function (value) {\n  			if (this.updating) {\n  				return;\n  			}\n\n  			this.updating = true;\n  			this.obj[this.prop] = value; // trigger set() accessor\n  			global_runloop.addRactive(this.ractive);\n  			this.ractive.viewmodel.mark(this.keypath, { keepExistingWrapper: true });\n  			this.updating = false;\n  			return true;\n  		},\n  		set: function (key, value) {\n  			if (this.updating) {\n  				return;\n  			}\n\n  			if (!this.obj[this.prop]) {\n  				this.updating = true;\n  				this.obj[this.prop] = createBranch(key);\n  				this.updating = false;\n  			}\n\n  			this.obj[this.prop][key] = value;\n  		},\n  		teardown: function () {\n  			var template, set, value, wrappers, index;\n\n  			// If this method was called because the cache was being cleared as a\n  			// result of a set()/update() call made by this wrapper, we return false\n  			// so that it doesn\'t get torn down\n  			if (this.updating) {\n  				return false;\n  			}\n\n  			template = Object.getOwnPropertyDescriptor(this.obj, this.prop);\n  			set = template && template.set;\n\n  			if (!set) {\n  				// most likely, this was an array member that was spliced out\n  				return;\n  			}\n\n  			wrappers = set._ractiveWrappers;\n\n  			index = wrappers.indexOf(this);\n  			if (index !== -1) {\n  				wrappers.splice(index, 1);\n  			}\n\n  			// Last one out, turn off the lights\n  			if (!wrappers.length) {\n  				value = this.obj[this.prop];\n\n  				Object.defineProperty(this.obj, this.prop, this.originalDescriptor || {\n  					writable: true,\n  					enumerable: true,\n  					configurable: true\n  				});\n\n  				this.obj[this.prop] = value;\n  			}\n  		}\n  	};\n  } catch (err) {\n  	magicAdaptor = false; // no magic in this browser\n  }\n\n  var adaptors_magic = magicAdaptor;\n\n  function createAccessors(originalWrapper, value, template) {\n\n  	var object, property, oldGet, oldSet, get, set;\n\n  	object = originalWrapper.obj;\n  	property = originalWrapper.prop;\n\n  	// Is this template configurable?\n  	if (template && !template.configurable) {\n  		// Special case - array length\n  		if (property === "length") {\n  			return;\n  		}\n\n  		throw new Error("Cannot use magic mode with property \\"" + property + "\\" - object is not configurable");\n  	}\n\n  	// Time to wrap this property\n  	if (template) {\n  		oldGet = template.get;\n  		oldSet = template.set;\n  	}\n\n  	get = oldGet || function () {\n  		return value;\n  	};\n\n  	set = function (v) {\n  		if (oldSet) {\n  			oldSet(v);\n  		}\n\n  		value = oldGet ? oldGet() : v;\n  		set._ractiveWrappers.forEach(updateWrapper);\n  	};\n\n  	function updateWrapper(wrapper) {\n  		var keypath, ractive;\n\n  		wrapper.value = value;\n\n  		if (wrapper.updating) {\n  			return;\n  		}\n\n  		ractive = wrapper.ractive;\n  		keypath = wrapper.keypath;\n\n  		wrapper.updating = true;\n  		global_runloop.start(ractive);\n\n  		ractive.viewmodel.mark(keypath);\n\n  		global_runloop.end();\n  		wrapper.updating = false;\n  	}\n\n  	// Create an array of wrappers, in case other keypaths/ractives depend on this property.\n  	// Handily, we can store them as a property of the set function. Yay JavaScript.\n  	set._ractiveWrappers = [originalWrapper];\n  	Object.defineProperty(object, property, { get: get, set: set, enumerable: true, configurable: true });\n  }\n\n  var magicArrayAdaptor, MagicArrayWrapper;\n\n  if (adaptors_magic) {\n  	magicArrayAdaptor = {\n  		filter: function (object, keypath, ractive) {\n  			return adaptors_magic.filter(object, keypath, ractive) && array_index.filter(object);\n  		},\n\n  		wrap: function (ractive, array, keypath) {\n  			return new MagicArrayWrapper(ractive, array, keypath);\n  		}\n  	};\n\n  	MagicArrayWrapper = function (ractive, array, keypath) {\n  		this.value = array;\n\n  		this.magic = true;\n\n  		this.magicWrapper = adaptors_magic.wrap(ractive, array, keypath);\n  		this.arrayWrapper = array_index.wrap(ractive, array, keypath);\n  	};\n\n  	MagicArrayWrapper.prototype = {\n  		get: function () {\n  			return this.value;\n  		},\n  		teardown: function () {\n  			this.arrayWrapper.teardown();\n  			this.magicWrapper.teardown();\n  		},\n  		reset: function (value) {\n  			return this.magicWrapper.reset(value);\n  		}\n  	};\n  }\n\n  var magicArray = magicArrayAdaptor;\n\n  var prototype_adapt = Viewmodel$adapt;\n\n  var prefixers = {};\n  function Viewmodel$adapt(keypath, value) {\n  	var len, i, adaptor, wrapped;\n\n  	if (!this.adaptors) return;\n\n  	// Do we have an adaptor for this value?\n  	len = this.adaptors.length;\n  	for (i = 0; i < len; i += 1) {\n  		adaptor = this.adaptors[i];\n\n  		if (adaptor.filter(value, keypath, this.ractive)) {\n  			wrapped = this.wrapped[keypath] = adaptor.wrap(this.ractive, value, keypath, getPrefixer(keypath));\n  			wrapped.value = value;\n  			return;\n  		}\n  	}\n  }\n\n  function prefixKeypath(obj, prefix) {\n  	var prefixed = {},\n  	    key;\n\n  	if (!prefix) {\n  		return obj;\n  	}\n\n  	prefix += ".";\n\n  	for (key in obj) {\n  		if (obj.hasOwnProperty(key)) {\n  			prefixed[prefix + key] = obj[key];\n  		}\n  	}\n\n  	return prefixed;\n  }\n\n  function getPrefixer(rootKeypath) {\n  	var rootDot;\n\n  	if (!prefixers[rootKeypath]) {\n  		rootDot = rootKeypath ? rootKeypath + "." : "";\n\n  		prefixers[rootKeypath] = function (relativeKeypath, value) {\n  			var obj;\n\n  			if (typeof relativeKeypath === "string") {\n  				obj = {};\n  				obj[rootDot + relativeKeypath] = value;\n  				return obj;\n  			}\n\n  			if (typeof relativeKeypath === "object") {\n  				// \'relativeKeypath\' is in fact a hash, not a keypath\n  				return rootDot ? prefixKeypath(relativeKeypath, rootKeypath) : relativeKeypath;\n  			}\n  		};\n  	}\n\n  	return prefixers[rootKeypath];\n  }\n\n  // TEMP\n\n  var helpers_getUpstreamChanges = getUpstreamChanges;\n  function getUpstreamChanges(changes) {\n  	var upstreamChanges = [rootKeypath],\n  	    i,\n  	    keypath;\n\n  	i = changes.length;\n  	while (i--) {\n  		keypath = changes[i].parent;\n\n  		while (keypath && !keypath.isRoot) {\n  			if (changes.indexOf(keypath) === -1) {\n  				addToArray(upstreamChanges, keypath);\n  			}\n  			keypath = keypath.parent;\n  		}\n  	}\n\n  	return upstreamChanges;\n  }\n\n  var applyChanges_notifyPatternObservers = notifyPatternObservers;\n\n  function notifyPatternObservers(viewmodel, keypath, onlyDirect) {\n  	var potentialWildcardMatches;\n\n  	updateMatchingPatternObservers(viewmodel, keypath);\n\n  	if (onlyDirect) {\n  		return;\n  	}\n\n  	potentialWildcardMatches = keypath.wildcardMatches();\n  	potentialWildcardMatches.forEach(function (upstreamPattern) {\n  		cascade(viewmodel, upstreamPattern, keypath);\n  	});\n  }\n\n  function cascade(viewmodel, upstreamPattern, keypath) {\n  	var group, map, actualChildKeypath;\n\n  	// TODO should be one or the other\n  	upstreamPattern = upstreamPattern.str || upstreamPattern;\n\n  	group = viewmodel.depsMap.patternObservers;\n  	map = group && group[upstreamPattern];\n\n  	if (!map) {\n  		return;\n  	}\n\n  	map.forEach(function (childKeypath) {\n  		actualChildKeypath = keypath.join(childKeypath.lastKey); // \'foo.bar.baz\'\n\n  		updateMatchingPatternObservers(viewmodel, actualChildKeypath);\n  		cascade(viewmodel, childKeypath, actualChildKeypath);\n  	});\n  }\n\n  function updateMatchingPatternObservers(viewmodel, keypath) {\n  	viewmodel.patternObservers.forEach(function (observer) {\n  		if (observer.regex.test(keypath.str)) {\n  			observer.update(keypath);\n  		}\n  	});\n  }\n\n  var applyChanges = Viewmodel$applyChanges;\n\n  function Viewmodel$applyChanges() {\n  	var _this = this;\n\n  	var self = this,\n  	    changes,\n  	    upstreamChanges,\n  	    hash = {},\n  	    bindings;\n\n  	changes = this.changes;\n\n  	if (!changes.length) {\n  		// TODO we end up here on initial render. Perhaps we shouldn\'t?\n  		return;\n  	}\n\n  	function invalidateComputation(computation) {\n  		var key = computation.key;\n\n  		if (computation.viewmodel === self) {\n  			self.clearCache(key.str);\n  			computation.invalidate();\n\n  			changes.push(key);\n  			cascade(key);\n  		} else {\n  			computation.viewmodel.mark(key);\n  		}\n  	}\n\n  	function cascade(keypath) {\n  		var map, computations;\n\n  		if (self.noCascade.hasOwnProperty(keypath.str)) {\n  			return;\n  		}\n\n  		if (computations = self.deps.computed[keypath.str]) {\n  			computations.forEach(invalidateComputation);\n  		}\n\n  		if (map = self.depsMap.computed[keypath.str]) {\n  			map.forEach(cascade);\n  		}\n  	}\n\n  	changes.slice().forEach(cascade);\n\n  	upstreamChanges = helpers_getUpstreamChanges(changes);\n  	upstreamChanges.forEach(function (keypath) {\n  		var computations;\n\n  		// make sure we haven\'t already been down this particular keypath in this turn\n  		if (changes.indexOf(keypath) === -1 && (computations = self.deps.computed[keypath.str])) {\n  			computations.forEach(invalidateComputation);\n  		}\n  	});\n\n  	this.changes = [];\n\n  	// Pattern observers are a weird special case\n  	if (this.patternObservers.length) {\n  		upstreamChanges.forEach(function (keypath) {\n  			return applyChanges_notifyPatternObservers(_this, keypath, true);\n  		});\n  		changes.forEach(function (keypath) {\n  			return applyChanges_notifyPatternObservers(_this, keypath);\n  		});\n  	}\n\n  	if (this.deps.observers) {\n  		upstreamChanges.forEach(function (keypath) {\n  			return notifyUpstreamDependants(_this, null, keypath, "observers");\n  		});\n  		notifyAllDependants(this, changes, "observers");\n  	}\n\n  	if (this.deps["default"]) {\n  		bindings = [];\n  		upstreamChanges.forEach(function (keypath) {\n  			return notifyUpstreamDependants(_this, bindings, keypath, "default");\n  		});\n\n  		if (bindings.length) {\n  			notifyBindings(this, bindings, changes);\n  		}\n\n  		notifyAllDependants(this, changes, "default");\n  	}\n\n  	// Return a hash of keypaths to updated values\n  	changes.forEach(function (keypath) {\n  		hash[keypath.str] = _this.get(keypath);\n  	});\n\n  	this.implicitChanges = {};\n  	this.noCascade = {};\n\n  	return hash;\n  }\n\n  function notifyUpstreamDependants(viewmodel, bindings, keypath, groupName) {\n  	var dependants, value;\n\n  	if (dependants = findDependants(viewmodel, keypath, groupName)) {\n  		value = viewmodel.get(keypath);\n\n  		dependants.forEach(function (d) {\n  			// don\'t "set" the parent value, refine it\n  			// i.e. not data = value, but data[foo] = fooValue\n  			if (bindings && d.refineValue) {\n  				bindings.push(d);\n  			} else {\n  				d.setValue(value);\n  			}\n  		});\n  	}\n  }\n\n  function notifyBindings(viewmodel, bindings, changes) {\n\n  	bindings.forEach(function (binding) {\n  		var useSet = false,\n  		    i = 0,\n  		    length = changes.length,\n  		    refinements = [];\n\n  		while (i < length) {\n  			var keypath = changes[i];\n\n  			if (keypath === binding.keypath) {\n  				useSet = true;\n  				break;\n  			}\n\n  			if (keypath.slice(0, binding.keypath.length) === binding.keypath) {\n  				refinements.push(keypath);\n  			}\n\n  			i++;\n  		}\n\n  		if (useSet) {\n  			binding.setValue(viewmodel.get(binding.keypath));\n  		}\n\n  		if (refinements.length) {\n  			binding.refineValue(refinements);\n  		}\n  	});\n  }\n\n  function notifyAllDependants(viewmodel, keypaths, groupName) {\n  	var queue = [];\n\n  	addKeypaths(keypaths);\n  	queue.forEach(dispatch);\n\n  	function addKeypaths(keypaths) {\n  		keypaths.forEach(addKeypath);\n  		keypaths.forEach(cascade);\n  	}\n\n  	function addKeypath(keypath) {\n  		var deps = findDependants(viewmodel, keypath, groupName);\n\n  		if (deps) {\n  			queue.push({\n  				keypath: keypath,\n  				deps: deps\n  			});\n  		}\n  	}\n\n  	function cascade(keypath) {\n  		var childDeps;\n\n  		if (childDeps = viewmodel.depsMap[groupName][keypath.str]) {\n  			addKeypaths(childDeps);\n  		}\n  	}\n\n  	function dispatch(set) {\n  		var value = viewmodel.get(set.keypath);\n  		set.deps.forEach(function (d) {\n  			return d.setValue(value);\n  		});\n  	}\n  }\n\n  function findDependants(viewmodel, keypath, groupName) {\n  	var group = viewmodel.deps[groupName];\n  	return group ? group[keypath.str] : null;\n  }\n\n  var capture = Viewmodel$capture;\n\n  function Viewmodel$capture() {\n  	this.captureGroups.push([]);\n  }\n\n  var clearCache = Viewmodel$clearCache;\n\n  function Viewmodel$clearCache(keypath, keepExistingWrapper) {\n  	var cacheMap, wrapper;\n\n  	if (!keepExistingWrapper) {\n  		// Is there a wrapped property at this keypath?\n  		if (wrapper = this.wrapped[keypath]) {\n  			// Did we unwrap it?\n  			if (wrapper.teardown() !== false) {\n  				// Is this right?\n  				// What\'s the meaning of returning false from teardown?\n  				// Could there be a GC ramification if this is a "real" ractive.teardown()?\n  				this.wrapped[keypath] = null;\n  			}\n  		}\n  	}\n\n  	this.cache[keypath] = undefined;\n\n  	if (cacheMap = this.cacheMap[keypath]) {\n  		while (cacheMap.length) {\n  			this.clearCache(cacheMap.pop());\n  		}\n  	}\n  }\n\n  var UnresolvedDependency = function (computation, ref) {\n  	this.computation = computation;\n  	this.viewmodel = computation.viewmodel;\n  	this.ref = ref;\n\n  	// TODO this seems like a red flag!\n  	this.root = this.viewmodel.ractive;\n  	this.parentFragment = this.root.component && this.root.component.parentFragment;\n  };\n\n  UnresolvedDependency.prototype = {\n  	resolve: function (keypath) {\n  		this.computation.softDeps.push(keypath);\n  		this.computation.unresolvedDeps[keypath.str] = null;\n  		this.viewmodel.register(keypath, this.computation, "computed");\n  	}\n  };\n\n  var Computation_UnresolvedDependency = UnresolvedDependency;\n\n  var Computation = function (key, signature) {\n  	this.key = key;\n\n  	this.getter = signature.getter;\n  	this.setter = signature.setter;\n\n  	this.hardDeps = signature.deps || [];\n  	this.softDeps = [];\n  	this.unresolvedDeps = {};\n\n  	this.depValues = {};\n\n  	this._dirty = this._firstRun = true;\n  };\n\n  Computation.prototype = {\n  	constructor: Computation,\n\n  	init: function (viewmodel) {\n  		var _this = this;\n\n  		var initial;\n\n  		this.viewmodel = viewmodel;\n  		this.bypass = true;\n\n  		initial = viewmodel.get(this.key);\n  		viewmodel.clearCache(this.key.str);\n\n  		this.bypass = false;\n\n  		if (this.setter && initial !== undefined) {\n  			this.set(initial);\n  		}\n\n  		if (this.hardDeps) {\n  			this.hardDeps.forEach(function (d) {\n  				return viewmodel.register(d, _this, "computed");\n  			});\n  		}\n  	},\n\n  	invalidate: function () {\n  		this._dirty = true;\n  	},\n\n  	get: function () {\n  		var _this = this;\n\n  		var newDeps,\n  		    dependenciesChanged,\n  		    dependencyValuesChanged = false;\n\n  		if (this.getting) {\n  			// prevent double-computation (e.g. caused by array mutation inside computation)\n  			var msg = "The " + this.key.str + " computation indirectly called itself. This probably indicates a bug in the computation. It is commonly caused by `array.sort(...)` - if that\'s the case, clone the array first with `array.slice().sort(...)`";\n  			warnOnce(msg);\n  			return this.value;\n  		}\n\n  		this.getting = true;\n\n  		if (this._dirty) {\n  			// determine whether the inputs have changed, in case this depends on\n  			// other computed values\n  			if (this._firstRun || !this.hardDeps.length && !this.softDeps.length) {\n  				dependencyValuesChanged = true;\n  			} else {\n  				[this.hardDeps, this.softDeps].forEach(function (deps) {\n  					var keypath, value, i;\n\n  					if (dependencyValuesChanged) {\n  						return;\n  					}\n\n  					i = deps.length;\n  					while (i--) {\n  						keypath = deps[i];\n  						value = _this.viewmodel.get(keypath);\n\n  						if (!isEqual(value, _this.depValues[keypath.str])) {\n  							_this.depValues[keypath.str] = value;\n  							dependencyValuesChanged = true;\n\n  							return;\n  						}\n  					}\n  				});\n  			}\n\n  			if (dependencyValuesChanged) {\n  				this.viewmodel.capture();\n\n  				try {\n  					this.value = this.getter();\n  				} catch (err) {\n  					warnIfDebug("Failed to compute \\"%s\\"", this.key.str);\n  					logIfDebug(err.stack || err);\n\n  					this.value = void 0;\n  				}\n\n  				newDeps = this.viewmodel.release();\n  				dependenciesChanged = this.updateDependencies(newDeps);\n\n  				if (dependenciesChanged) {\n  					[this.hardDeps, this.softDeps].forEach(function (deps) {\n  						deps.forEach(function (keypath) {\n  							_this.depValues[keypath.str] = _this.viewmodel.get(keypath);\n  						});\n  					});\n  				}\n  			}\n\n  			this._dirty = false;\n  		}\n\n  		this.getting = this._firstRun = false;\n  		return this.value;\n  	},\n\n  	set: function (value) {\n  		if (this.setting) {\n  			this.value = value;\n  			return;\n  		}\n\n  		if (!this.setter) {\n  			throw new Error("Computed properties without setters are read-only. (This may change in a future version of Ractive!)");\n  		}\n\n  		this.setter(value);\n  	},\n\n  	updateDependencies: function (newDeps) {\n  		var i, oldDeps, keypath, dependenciesChanged, unresolved;\n\n  		oldDeps = this.softDeps;\n\n  		// remove dependencies that are no longer used\n  		i = oldDeps.length;\n  		while (i--) {\n  			keypath = oldDeps[i];\n\n  			if (newDeps.indexOf(keypath) === -1) {\n  				dependenciesChanged = true;\n  				this.viewmodel.unregister(keypath, this, "computed");\n  			}\n  		}\n\n  		// create references for any new dependencies\n  		i = newDeps.length;\n  		while (i--) {\n  			keypath = newDeps[i];\n\n  			if (oldDeps.indexOf(keypath) === -1 && (!this.hardDeps || this.hardDeps.indexOf(keypath) === -1)) {\n  				dependenciesChanged = true;\n\n  				// if this keypath is currently unresolved, we need to mark\n  				// it as such. TODO this is a bit muddy...\n  				if (isUnresolved(this.viewmodel, keypath) && !this.unresolvedDeps[keypath.str]) {\n  					unresolved = new Computation_UnresolvedDependency(this, keypath.str);\n  					newDeps.splice(i, 1);\n\n  					this.unresolvedDeps[keypath.str] = unresolved;\n  					global_runloop.addUnresolved(unresolved);\n  				} else {\n  					this.viewmodel.register(keypath, this, "computed");\n  				}\n  			}\n  		}\n\n  		if (dependenciesChanged) {\n  			this.softDeps = newDeps.slice();\n  		}\n\n  		return dependenciesChanged;\n  	}\n  };\n\n  function isUnresolved(viewmodel, keypath) {\n  	var key = keypath.firstKey;\n\n  	return !(key in viewmodel.data) && !(key in viewmodel.computations) && !(key in viewmodel.mappings);\n  }\n\n  var Computation_Computation = Computation;\n\n  var compute = Viewmodel$compute;\n  function Viewmodel$compute(key, signature) {\n  	var computation = new Computation_Computation(key, signature);\n\n  	if (this.ready) {\n  		computation.init(this);\n  	}\n\n  	return this.computations[key.str] = computation;\n  }\n\n  var FAILED_LOOKUP = { FAILED_LOOKUP: true };\n\n  var viewmodel_prototype_get = Viewmodel$get;\n\n  var viewmodel_prototype_get__empty = {};\n  function Viewmodel$get(keypath, options) {\n  	var cache = this.cache,\n  	    value,\n  	    computation,\n  	    wrapped,\n  	    captureGroup,\n  	    keypathStr = keypath.str,\n  	    key;\n\n  	options = options || viewmodel_prototype_get__empty;\n\n  	// capture the keypath, if we\'re inside a computation\n  	if (options.capture && (captureGroup = lastItem(this.captureGroups))) {\n  		if (! ~captureGroup.indexOf(keypath)) {\n  			captureGroup.push(keypath);\n  		}\n  	}\n\n  	if (hasOwn.call(this.mappings, keypath.firstKey)) {\n  		return this.mappings[keypath.firstKey].get(keypath, options);\n  	}\n\n  	if (keypath.isSpecial) {\n  		return keypath.value;\n  	}\n\n  	if (cache[keypathStr] === undefined) {\n\n  		// Is this a computed property?\n  		if ((computation = this.computations[keypathStr]) && !computation.bypass) {\n  			value = computation.get();\n  			this.adapt(keypathStr, value);\n  		}\n\n  		// Is this a wrapped property?\n  		else if (wrapped = this.wrapped[keypathStr]) {\n  			value = wrapped.value;\n  		}\n\n  		// Is it the root?\n  		else if (keypath.isRoot) {\n  			this.adapt("", this.data);\n  			value = this.data;\n  		}\n\n  		// No? Then we need to retrieve the value one key at a time\n  		else {\n  			value = retrieve(this, keypath);\n  		}\n\n  		cache[keypathStr] = value;\n  	} else {\n  		value = cache[keypathStr];\n  	}\n\n  	if (!options.noUnwrap && (wrapped = this.wrapped[keypathStr])) {\n  		value = wrapped.get();\n  	}\n\n  	if (keypath.isRoot && options.fullRootGet) {\n  		for (key in this.mappings) {\n  			value[key] = this.mappings[key].getValue();\n  		}\n  	}\n\n  	return value === FAILED_LOOKUP ? void 0 : value;\n  }\n\n  function retrieve(viewmodel, keypath) {\n\n  	var parentValue, cacheMap, value, wrapped;\n\n  	parentValue = viewmodel.get(keypath.parent);\n\n  	if (wrapped = viewmodel.wrapped[keypath.parent.str]) {\n  		parentValue = wrapped.get();\n  	}\n\n  	if (parentValue === null || parentValue === undefined) {\n  		return;\n  	}\n\n  	// update cache map\n  	if (!(cacheMap = viewmodel.cacheMap[keypath.parent.str])) {\n  		viewmodel.cacheMap[keypath.parent.str] = [keypath.str];\n  	} else {\n  		if (cacheMap.indexOf(keypath.str) === -1) {\n  			cacheMap.push(keypath.str);\n  		}\n  	}\n\n  	// If this property doesn\'t exist, we return a sentinel value\n  	// so that we know to query parent scope (if such there be)\n  	if (typeof parentValue === "object" && !(keypath.lastKey in parentValue)) {\n  		return viewmodel.cache[keypath.str] = FAILED_LOOKUP;\n  	}\n\n  	value = parentValue[keypath.lastKey];\n\n  	// Do we have an adaptor for this value?\n  	viewmodel.adapt(keypath.str, value, false);\n\n  	// Update cache\n  	viewmodel.cache[keypath.str] = value;\n  	return value;\n  }\n\n  var viewmodel_prototype_init = Viewmodel$init;\n\n  function Viewmodel$init() {\n  	var key;\n\n  	for (key in this.computations) {\n  		this.computations[key].init(this);\n  	}\n  }\n\n  var prototype_map = Viewmodel$map;\n\n  function Viewmodel$map(key, options) {\n  	var mapping = this.mappings[key.str] = new Mapping(key, options);\n  	mapping.initViewmodel(this);\n  	return mapping;\n  }\n\n  var Mapping = function (localKey, options) {\n  	this.localKey = localKey;\n  	this.keypath = options.keypath;\n  	this.origin = options.origin;\n\n  	this.deps = [];\n  	this.unresolved = [];\n\n  	this.resolved = false;\n  };\n\n  Mapping.prototype = {\n  	forceResolution: function () {\n  		// TODO warn, as per #1692?\n  		this.keypath = this.localKey;\n  		this.setup();\n  	},\n\n  	get: function (keypath, options) {\n  		if (!this.resolved) {\n  			return undefined;\n  		}\n  		return this.origin.get(this.map(keypath), options);\n  	},\n\n  	getValue: function () {\n  		if (!this.keypath) {\n  			return undefined;\n  		}\n  		return this.origin.get(this.keypath);\n  	},\n\n  	initViewmodel: function (viewmodel) {\n  		this.local = viewmodel;\n  		this.setup();\n  	},\n\n  	map: function (keypath) {\n  		if (typeof this.keypath === undefined) {\n  			return this.localKey;\n  		}\n  		return keypath.replace(this.localKey, this.keypath);\n  	},\n\n  	register: function (keypath, dependant, group) {\n  		this.deps.push({ keypath: keypath, dep: dependant, group: group });\n\n  		if (this.resolved) {\n  			this.origin.register(this.map(keypath), dependant, group);\n  		}\n  	},\n\n  	resolve: function (keypath) {\n  		if (this.keypath !== undefined) {\n  			this.unbind(true);\n  		}\n\n  		this.keypath = keypath;\n  		this.setup();\n  	},\n\n  	set: function (keypath, value) {\n  		if (!this.resolved) {\n  			this.forceResolution();\n  		}\n\n  		this.origin.set(this.map(keypath), value);\n  	},\n\n  	setup: function () {\n  		var _this = this;\n\n  		if (this.keypath === undefined) {\n  			return;\n  		}\n\n  		this.resolved = true;\n\n  		// accumulated dependants can now be registered\n  		if (this.deps.length) {\n  			this.deps.forEach(function (d) {\n  				var keypath = _this.map(d.keypath);\n  				_this.origin.register(keypath, d.dep, d.group);\n\n  				// TODO this is a bit of a red flag... all deps should be the same?\n  				if (d.dep.setValue) {\n  					d.dep.setValue(_this.origin.get(keypath));\n  				} else if (d.dep.invalidate) {\n  					d.dep.invalidate();\n  				} else {\n  					throw new Error("An unexpected error occurred. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!");\n  				}\n  			});\n\n  			this.origin.mark(this.keypath);\n  		}\n  	},\n\n  	setValue: function (value) {\n  		if (!this.keypath) {\n  			throw new Error("Mapping does not have keypath, cannot set value. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!");\n  		}\n\n  		this.origin.set(this.keypath, value);\n  	},\n\n  	unbind: function (keepLocal) {\n  		var _this = this;\n\n  		if (!keepLocal) {\n  			delete this.local.mappings[this.localKey];\n  		}\n\n  		if (!this.resolved) {\n  			return;\n  		}\n\n  		this.deps.forEach(function (d) {\n  			_this.origin.unregister(_this.map(d.keypath), d.dep, d.group);\n  		});\n\n  		if (this.tracker) {\n  			this.origin.unregister(this.keypath, this.tracker);\n  		}\n  	},\n\n  	unregister: function (keypath, dependant, group) {\n  		var deps, i;\n\n  		if (!this.resolved) {\n  			return;\n  		}\n\n  		deps = this.deps;\n  		i = deps.length;\n\n  		while (i--) {\n  			if (deps[i].dep === dependant) {\n  				deps.splice(i, 1);\n  				break;\n  			}\n  		}\n  		this.origin.unregister(this.map(keypath), dependant, group);\n  	}\n  };\n\n  var mark = Viewmodel$mark;\n\n  function Viewmodel$mark(keypath, options) {\n  	var computation,\n  	    keypathStr = keypath.str;\n\n  	// implicit changes (i.e. `foo.length` on `ractive.push(\'foo\',42)`)\n  	// should not be picked up by pattern observers\n  	if (options) {\n  		if (options.implicit) {\n  			this.implicitChanges[keypathStr] = true;\n  		}\n  		if (options.noCascade) {\n  			this.noCascade[keypathStr] = true;\n  		}\n  	}\n\n  	if (computation = this.computations[keypathStr]) {\n  		computation.invalidate();\n  	}\n\n  	if (this.changes.indexOf(keypath) === -1) {\n  		this.changes.push(keypath);\n  	}\n\n  	// pass on keepExistingWrapper, if we can\n  	var keepExistingWrapper = options ? options.keepExistingWrapper : false;\n\n  	this.clearCache(keypathStr, keepExistingWrapper);\n\n  	if (this.ready) {\n  		this.onchange();\n  	}\n  }\n\n  var mapOldToNewIndex = function (oldArray, newArray) {\n  	var usedIndices, firstUnusedIndex, newIndices, changed;\n\n  	usedIndices = {};\n  	firstUnusedIndex = 0;\n\n  	newIndices = oldArray.map(function (item, i) {\n  		var index, start, len;\n\n  		start = firstUnusedIndex;\n  		len = newArray.length;\n\n  		do {\n  			index = newArray.indexOf(item, start);\n\n  			if (index === -1) {\n  				changed = true;\n  				return -1;\n  			}\n\n  			start = index + 1;\n  		} while (usedIndices[index] && start < len);\n\n  		// keep track of the first unused index, so we don\'t search\n  		// the whole of newArray for each item in oldArray unnecessarily\n  		if (index === firstUnusedIndex) {\n  			firstUnusedIndex += 1;\n  		}\n\n  		if (index !== i) {\n  			changed = true;\n  		}\n\n  		usedIndices[index] = true;\n  		return index;\n  	});\n\n  	return newIndices;\n  };\n\n  var merge = Viewmodel$merge;\n\n  var comparators = {};\n  function Viewmodel$merge(keypath, currentArray, array, options) {\n  	var oldArray, newArray, comparator, newIndices;\n\n  	this.mark(keypath);\n\n  	if (options && options.compare) {\n\n  		comparator = getComparatorFunction(options.compare);\n\n  		try {\n  			oldArray = currentArray.map(comparator);\n  			newArray = array.map(comparator);\n  		} catch (err) {\n  			// fallback to an identity check - worst case scenario we have\n  			// to do more DOM manipulation than we thought...\n  			warnIfDebug("merge(): \\"%s\\" comparison failed. Falling back to identity checking", keypath);\n\n  			oldArray = currentArray;\n  			newArray = array;\n  		}\n  	} else {\n  		oldArray = currentArray;\n  		newArray = array;\n  	}\n\n  	// find new indices for members of oldArray\n  	newIndices = mapOldToNewIndex(oldArray, newArray);\n\n  	this.smartUpdate(keypath, array, newIndices, currentArray.length !== array.length);\n  }\n\n  function stringify(item) {\n  	return JSON.stringify(item);\n  }\n\n  function getComparatorFunction(comparator) {\n  	// If `compare` is `true`, we use JSON.stringify to compare\n  	// objects that are the same shape, but non-identical - i.e.\n  	// { foo: \'bar\' } !== { foo: \'bar\' }\n  	if (comparator === true) {\n  		return stringify;\n  	}\n\n  	if (typeof comparator === "string") {\n  		if (!comparators[comparator]) {\n  			comparators[comparator] = function (item) {\n  				return item[comparator];\n  			};\n  		}\n\n  		return comparators[comparator];\n  	}\n\n  	if (typeof comparator === "function") {\n  		return comparator;\n  	}\n\n  	throw new Error("The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)");\n  }\n\n  var register = Viewmodel$register;\n\n  function Viewmodel$register(keypath, dependant) {\n  	var group = arguments[2] === undefined ? "default" : arguments[2];\n\n  	var mapping, depsByKeypath, deps;\n\n  	if (dependant.isStatic) {\n  		return; // TODO we should never get here if a dependant is static...\n  	}\n\n  	if (mapping = this.mappings[keypath.firstKey]) {\n  		mapping.register(keypath, dependant, group);\n  	} else {\n  		depsByKeypath = this.deps[group] || (this.deps[group] = {});\n  		deps = depsByKeypath[keypath.str] || (depsByKeypath[keypath.str] = []);\n\n  		deps.push(dependant);\n\n  		if (!this.depsMap[group]) {\n  			this.depsMap[group] = {};\n  		}\n\n  		if (!keypath.isRoot) {\n  			register__updateDependantsMap(this, keypath, group);\n  		}\n  	}\n  }\n\n  function register__updateDependantsMap(viewmodel, keypath, group) {\n  	var map, parent, keypathStr;\n\n  	// update dependants map\n  	while (!keypath.isRoot) {\n  		map = viewmodel.depsMap[group];\n  		parent = map[keypath.parent.str] || (map[keypath.parent.str] = []);\n\n  		keypathStr = keypath.str;\n\n  		// TODO find an alternative to this nasty approach\n  		if (parent["_" + keypathStr] === undefined) {\n  			parent["_" + keypathStr] = 0;\n  			parent.push(keypath);\n  		}\n\n  		parent["_" + keypathStr] += 1;\n  		keypath = keypath.parent;\n  	}\n  }\n\n  var release = Viewmodel$release;\n\n  function Viewmodel$release() {\n  	return this.captureGroups.pop();\n  }\n\n  var reset = Viewmodel$reset;\n\n  function Viewmodel$reset(data) {\n  	this.data = data;\n  	this.clearCache("");\n  }\n\n  var prototype_set = Viewmodel$set;\n\n  function Viewmodel$set(keypath, value) {\n  	var options = arguments[2] === undefined ? {} : arguments[2];\n\n  	var mapping, computation, wrapper, keepExistingWrapper;\n\n  	// unless data is being set for data tracking purposes\n  	if (!options.noMapping) {\n  		// If this data belongs to a different viewmodel,\n  		// pass the change along\n  		if (mapping = this.mappings[keypath.firstKey]) {\n  			return mapping.set(keypath, value);\n  		}\n  	}\n\n  	computation = this.computations[keypath.str];\n  	if (computation) {\n  		if (computation.setting) {\n  			// let the other computation set() handle things...\n  			return;\n  		}\n  		computation.set(value);\n  		value = computation.get();\n  	}\n\n  	if (isEqual(this.cache[keypath.str], value)) {\n  		return;\n  	}\n\n  	wrapper = this.wrapped[keypath.str];\n\n  	// If we have a wrapper with a `reset()` method, we try and use it. If the\n  	// `reset()` method returns false, the wrapper should be torn down, and\n  	// (most likely) a new one should be created later\n  	if (wrapper && wrapper.reset) {\n  		keepExistingWrapper = wrapper.reset(value) !== false;\n\n  		if (keepExistingWrapper) {\n  			value = wrapper.get();\n  		}\n  	}\n\n  	if (!computation && !keepExistingWrapper) {\n  		resolveSet(this, keypath, value);\n  	}\n\n  	if (!options.silent) {\n  		this.mark(keypath);\n  	} else {\n  		// We\'re setting a parent of the original target keypath (i.e.\n  		// creating a fresh branch) - we need to clear the cache, but\n  		// not mark it as a change\n  		this.clearCache(keypath.str);\n  	}\n  }\n\n  function resolveSet(viewmodel, keypath, value) {\n  	var wrapper, parentValue, wrapperSet, valueSet;\n\n  	wrapperSet = function () {\n  		if (wrapper.set) {\n  			wrapper.set(keypath.lastKey, value);\n  		} else {\n  			parentValue = wrapper.get();\n  			valueSet();\n  		}\n  	};\n\n  	valueSet = function () {\n  		if (!parentValue) {\n  			parentValue = createBranch(keypath.lastKey);\n  			viewmodel.set(keypath.parent, parentValue, { silent: true });\n  		}\n  		parentValue[keypath.lastKey] = value;\n  	};\n\n  	wrapper = viewmodel.wrapped[keypath.parent.str];\n\n  	if (wrapper) {\n  		wrapperSet();\n  	} else {\n  		parentValue = viewmodel.get(keypath.parent);\n\n  		// may have been wrapped via the above .get()\n  		// call on viewmodel if this is first access via .set()!\n  		if (wrapper = viewmodel.wrapped[keypath.parent.str]) {\n  			wrapperSet();\n  		} else {\n  			valueSet();\n  		}\n  	}\n  }\n\n  var smartUpdate = Viewmodel$smartUpdate;\n\n  var implicitOption = { implicit: true },\n      noCascadeOption = { noCascade: true };\n  function Viewmodel$smartUpdate(keypath, array, newIndices) {\n  	var _this = this;\n\n  	var dependants, oldLength, i;\n\n  	oldLength = newIndices.length;\n\n  	// Indices that are being removed should be marked as dirty\n  	newIndices.forEach(function (newIndex, oldIndex) {\n  		if (newIndex === -1) {\n  			_this.mark(keypath.join(oldIndex), noCascadeOption);\n  		}\n  	});\n\n  	// Update the model\n  	// TODO allow existing array to be updated in place, rather than replaced?\n  	this.set(keypath, array, { silent: true });\n\n  	if (dependants = this.deps["default"][keypath.str]) {\n  		dependants.filter(canShuffle).forEach(function (d) {\n  			return d.shuffle(newIndices, array);\n  		});\n  	}\n\n  	if (oldLength !== array.length) {\n  		this.mark(keypath.join("length"), implicitOption);\n\n  		for (i = newIndices.touchedFrom; i < array.length; i += 1) {\n  			this.mark(keypath.join(i));\n  		}\n\n  		// don\'t allow removed indexes beyond end of new array to trigger recomputations\n  		// TODO is this still necessary, now that computations are lazy?\n  		for (i = array.length; i < oldLength; i += 1) {\n  			this.mark(keypath.join(i), noCascadeOption);\n  		}\n  	}\n  }\n\n  function canShuffle(dependant) {\n  	return typeof dependant.shuffle === "function";\n  }\n\n  var prototype_teardown = Viewmodel$teardown;\n\n  function Viewmodel$teardown() {\n  	var _this = this;\n\n  	var unresolvedImplicitDependency;\n\n  	// Clear entire cache - this has the desired side-effect\n  	// of unwrapping adapted values (e.g. arrays)\n  	Object.keys(this.cache).forEach(function (keypath) {\n  		return _this.clearCache(keypath);\n  	});\n\n  	// Teardown any failed lookups - we don\'t need them to resolve any more\n  	while (unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop()) {\n  		unresolvedImplicitDependency.teardown();\n  	}\n  }\n\n  var unregister = Viewmodel$unregister;\n\n  function Viewmodel$unregister(keypath, dependant) {\n  	var group = arguments[2] === undefined ? "default" : arguments[2];\n\n  	var mapping, deps, index;\n\n  	if (dependant.isStatic) {\n  		return;\n  	}\n\n  	if (mapping = this.mappings[keypath.firstKey]) {\n  		return mapping.unregister(keypath, dependant, group);\n  	}\n\n  	deps = this.deps[group][keypath.str];\n  	index = deps.indexOf(dependant);\n\n  	if (index === -1) {\n  		throw new Error("Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks");\n  	}\n\n  	deps.splice(index, 1);\n\n  	if (keypath.isRoot) {\n  		return;\n  	}\n\n  	unregister__updateDependantsMap(this, keypath, group);\n  }\n\n  function unregister__updateDependantsMap(viewmodel, keypath, group) {\n  	var map, parent;\n\n  	// update dependants map\n  	while (!keypath.isRoot) {\n  		map = viewmodel.depsMap[group];\n  		parent = map[keypath.parent.str];\n\n  		parent["_" + keypath.str] -= 1;\n\n  		if (!parent["_" + keypath.str]) {\n  			// remove from parent deps map\n  			removeFromArray(parent, keypath);\n  			parent["_" + keypath.str] = undefined;\n  		}\n\n  		keypath = keypath.parent;\n  	}\n  }\n\n  var Viewmodel = function (options) {\n  	var adapt = options.adapt;\n  	var data = options.data;\n  	var ractive = options.ractive;\n  	var computed = options.computed;\n  	var mappings = options.mappings;\n  	var key;\n  	var mapping;\n\n  	// TODO is it possible to remove this reference?\n  	this.ractive = ractive;\n\n  	this.adaptors = adapt;\n  	this.onchange = options.onchange;\n\n  	this.cache = {}; // we need to be able to use hasOwnProperty, so can\'t inherit from null\n  	this.cacheMap = create(null);\n\n  	this.deps = {\n  		computed: create(null),\n  		"default": create(null)\n  	};\n  	this.depsMap = {\n  		computed: create(null),\n  		"default": create(null)\n  	};\n\n  	this.patternObservers = [];\n\n  	this.specials = create(null);\n\n  	this.wrapped = create(null);\n  	this.computations = create(null);\n\n  	this.captureGroups = [];\n  	this.unresolvedImplicitDependencies = [];\n\n  	this.changes = [];\n  	this.implicitChanges = {};\n  	this.noCascade = {};\n\n  	this.data = data;\n\n  	// set up explicit mappings\n  	this.mappings = create(null);\n  	for (key in mappings) {\n  		this.map(getKeypath(key), mappings[key]);\n  	}\n\n  	if (data) {\n  		// if data exists locally, but is missing on the parent,\n  		// we transfer ownership to the parent\n  		for (key in data) {\n  			if ((mapping = this.mappings[key]) && mapping.getValue() === undefined) {\n  				mapping.setValue(data[key]);\n  			}\n  		}\n  	}\n\n  	for (key in computed) {\n  		if (mappings && key in mappings) {\n  			fatal("Cannot map to a computed property (\'%s\')", key);\n  		}\n\n  		this.compute(getKeypath(key), computed[key]);\n  	}\n\n  	this.ready = true;\n  };\n\n  Viewmodel.prototype = {\n  	adapt: prototype_adapt,\n  	applyChanges: applyChanges,\n  	capture: capture,\n  	clearCache: clearCache,\n  	compute: compute,\n  	get: viewmodel_prototype_get,\n  	init: viewmodel_prototype_init,\n  	map: prototype_map,\n  	mark: mark,\n  	merge: merge,\n  	register: register,\n  	release: release,\n  	reset: reset,\n  	set: prototype_set,\n  	smartUpdate: smartUpdate,\n  	teardown: prototype_teardown,\n  	unregister: unregister\n  };\n\n  var viewmodel_Viewmodel = Viewmodel;\n\n  function HookQueue(event) {\n  	this.hook = new hooks_Hook(event);\n  	this.inProcess = {};\n  	this.queue = {};\n  }\n\n  HookQueue.prototype = {\n\n  	constructor: HookQueue,\n\n  	begin: function (ractive) {\n  		this.inProcess[ractive._guid] = true;\n  	},\n\n  	end: function (ractive) {\n\n  		var parent = ractive.parent;\n\n  		// If this is *isn\'t* a child of a component that\'s in process,\n  		// it should call methods or fire at this point\n  		if (!parent || !this.inProcess[parent._guid]) {\n  			fire(this, ractive);\n  		}\n  		// elsewise, handoff to parent to fire when ready\n  		else {\n  			getChildQueue(this.queue, parent).push(ractive);\n  		}\n\n  		delete this.inProcess[ractive._guid];\n  	}\n  };\n\n  function getChildQueue(queue, ractive) {\n  	return queue[ractive._guid] || (queue[ractive._guid] = []);\n  }\n\n  function fire(hookQueue, ractive) {\n\n  	var childQueue = getChildQueue(hookQueue.queue, ractive);\n\n  	hookQueue.hook.fire(ractive);\n\n  	// queue is "live" because components can end up being\n  	// added while hooks fire on parents that modify data values.\n  	while (childQueue.length) {\n  		fire(hookQueue, childQueue.shift());\n  	}\n\n  	delete hookQueue.queue[ractive._guid];\n  }\n\n  var hooks_HookQueue = HookQueue;\n\n  var helpers_getComputationSignatures = getComputationSignatures;\n\n  var helpers_getComputationSignatures__pattern = /\\$\\{([^\\}]+)\\}/g;\n  function getComputationSignatures(ractive, computed) {\n  	var signatures = {},\n  	    key;\n\n  	for (key in computed) {\n  		signatures[key] = getComputationSignature(ractive, key, computed[key]);\n  	}\n\n  	return signatures;\n  }\n\n  function getComputationSignature(ractive, key, signature) {\n  	var getter, setter;\n\n  	if (typeof signature === "function") {\n  		getter = helpers_getComputationSignatures__bind(signature, ractive);\n  	}\n\n  	if (typeof signature === "string") {\n  		getter = createFunctionFromString(ractive, signature);\n  	}\n\n  	if (typeof signature === "object") {\n  		if (typeof signature.get === "string") {\n  			getter = createFunctionFromString(ractive, signature.get);\n  		} else if (typeof signature.get === "function") {\n  			getter = helpers_getComputationSignatures__bind(signature.get, ractive);\n  		} else {\n  			fatal("`%s` computation must have a `get()` method", key);\n  		}\n\n  		if (typeof signature.set === "function") {\n  			setter = helpers_getComputationSignatures__bind(signature.set, ractive);\n  		}\n  	}\n\n  	return { getter: getter, setter: setter };\n  }\n\n  function createFunctionFromString(ractive, str) {\n  	var functionBody, hasThis, fn;\n\n  	functionBody = "return (" + str.replace(helpers_getComputationSignatures__pattern, function (match, keypath) {\n  		hasThis = true;\n  		return "__ractive.get(\\"" + keypath + "\\")";\n  	}) + ");";\n\n  	if (hasThis) {\n  		functionBody = "var __ractive = this; " + functionBody;\n  	}\n\n  	fn = new Function(functionBody);\n  	return hasThis ? fn.bind(ractive) : fn;\n  }\n\n  function helpers_getComputationSignatures__bind(fn, context) {\n  	return /this/.test(fn.toString()) ? fn.bind(context) : fn;\n  }\n\n  var constructHook = new hooks_Hook("construct");\n  var configHook = new hooks_Hook("config");\n  var initHook = new hooks_HookQueue("init");\n  var initialise__uid = 0;\n\n  var initialise__registryNames = ["adaptors", "components", "decorators", "easing", "events", "interpolators", "partials", "transitions"];\n\n  var initialise = initialiseRactiveInstance;\n\n  function initialiseRactiveInstance(ractive) {\n  	var userOptions = arguments[1] === undefined ? {} : arguments[1];\n  	var options = arguments[2] === undefined ? {} : arguments[2];\n\n  	var el, viewmodel;\n\n  	if (_Ractive.DEBUG) {\n  		welcome();\n  	}\n\n  	initialiseProperties(ractive, options);\n\n  	// TODO remove this, eventually\n  	defineProperty(ractive, "data", { get: deprecateRactiveData });\n\n  	// TODO don\'t allow `onconstruct` with `new Ractive()`, there\'s no need for it\n  	constructHook.fire(ractive, userOptions);\n\n  	// Add registries\n  	initialise__registryNames.forEach(function (name) {\n  		ractive[name] = utils_object__extend(create(ractive.constructor[name] || null), userOptions[name]);\n  	});\n\n  	// Create a viewmodel\n  	viewmodel = new viewmodel_Viewmodel({\n  		adapt: getAdaptors(ractive, ractive.adapt, userOptions),\n  		data: custom_data.init(ractive.constructor, ractive, userOptions),\n  		computed: helpers_getComputationSignatures(ractive, utils_object__extend(create(ractive.constructor.prototype.computed), userOptions.computed)),\n  		mappings: options.mappings,\n  		ractive: ractive,\n  		onchange: function () {\n  			return global_runloop.addRactive(ractive);\n  		}\n  	});\n\n  	ractive.viewmodel = viewmodel;\n\n  	// This can\'t happen earlier, because computed properties may call `ractive.get()`, etc\n  	viewmodel.init();\n\n  	// init config from Parent and options\n  	config_config.init(ractive.constructor, ractive, userOptions);\n\n  	configHook.fire(ractive);\n  	initHook.begin(ractive);\n\n  	// // If this is a component with a function `data` property, call the function\n  	// // with `ractive` as context (unless the child was also a function)\n  	// if ( typeof ractive.constructor.prototype.data === \'function\' && typeof userOptions.data !== \'function\' ) {\n  	// 	viewmodel.reset( ractive.constructor.prototype.data.call( ractive ) || fatal( \'`data` functions must return a data object\' ) );\n  	// }\n\n  	// Render virtual DOM\n  	if (ractive.template) {\n  		var cssIds = undefined;\n\n  		if (options.cssIds || ractive.cssId) {\n  			cssIds = options.cssIds ? options.cssIds.slice() : [];\n\n  			if (ractive.cssId) {\n  				cssIds.push(ractive.cssId);\n  			}\n  		}\n\n  		ractive.fragment = new virtualdom_Fragment({\n  			template: ractive.template,\n  			root: ractive,\n  			owner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on\n  			cssIds: cssIds\n  		});\n  	}\n\n  	initHook.end(ractive);\n\n  	// render automatically ( if `el` is specified )\n  	if (el = getElement(ractive.el)) {\n  		var promise = ractive.render(el, ractive.append);\n\n  		if (_Ractive.DEBUG_PROMISES) {\n  			promise["catch"](function (err) {\n  				warnOnceIfDebug("Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;");\n  				warnIfDebug("An error happened during rendering", { ractive: ractive });\n  				err.stack && logIfDebug(err.stack);\n\n  				throw err;\n  			});\n  		}\n  	}\n  }\n\n  function getAdaptors(ractive, protoAdapt, userOptions) {\n  	var adapt, magic, modifyArrays;\n\n  	protoAdapt = protoAdapt.map(lookup);\n  	adapt = ensureArray(userOptions.adapt).map(lookup);\n\n  	adapt = initialise__combine(protoAdapt, adapt);\n\n  	magic = "magic" in userOptions ? userOptions.magic : ractive.magic;\n  	modifyArrays = "modifyArrays" in userOptions ? userOptions.modifyArrays : ractive.modifyArrays;\n\n  	if (magic) {\n  		if (!environment__magic) {\n  			throw new Error("Getters and setters (magic mode) are not supported in this browser");\n  		}\n\n  		if (modifyArrays) {\n  			adapt.push(magicArray);\n  		}\n\n  		adapt.push(adaptors_magic);\n  	}\n\n  	if (modifyArrays) {\n  		adapt.push(array_index);\n  	}\n\n  	return adapt;\n\n  	function lookup(adaptor) {\n  		if (typeof adaptor === "string") {\n  			adaptor = findInViewHierarchy("adaptors", ractive, adaptor);\n\n  			if (!adaptor) {\n  				fatal(missingPlugin(adaptor, "adaptor"));\n  			}\n  		}\n\n  		return adaptor;\n  	}\n  }\n\n  function initialise__combine(a, b) {\n  	var c = a.slice(),\n  	    i = b.length;\n\n  	while (i--) {\n  		if (! ~c.indexOf(b[i])) {\n  			c.push(b[i]);\n  		}\n  	}\n\n  	return c;\n  }\n\n  function initialiseProperties(ractive, options) {\n  	// Generate a unique identifier, for places where you\'d use a weak map if it\n  	// existed\n  	ractive._guid = "r-" + initialise__uid++;\n\n  	// events\n  	ractive._subs = create(null);\n\n  	// storage for item configuration from instantiation to reset,\n  	// like dynamic functions or original values\n  	ractive._config = {};\n\n  	// two-way bindings\n  	ractive._twowayBindings = create(null);\n\n  	// animations (so we can stop any in progress at teardown)\n  	ractive._animations = [];\n\n  	// nodes registry\n  	ractive.nodes = {};\n\n  	// live queries\n  	ractive._liveQueries = [];\n  	ractive._liveComponentQueries = [];\n\n  	// bound data functions\n  	ractive._boundFunctions = [];\n\n  	// observers\n  	ractive._observers = [];\n\n  	// properties specific to inline components\n  	if (options.component) {\n  		ractive.parent = options.parent;\n  		ractive.container = options.container || null;\n  		ractive.root = ractive.parent.root;\n\n  		ractive.component = options.component;\n  		options.component.instance = ractive;\n\n  		// for hackability, this could be an open option\n  		// for any ractive instance, but for now, just\n  		// for components and just for ractive...\n  		ractive._inlinePartials = options.inlinePartials;\n  	} else {\n  		ractive.root = ractive;\n  		ractive.parent = ractive.container = null;\n  	}\n  }\n\n  function deprecateRactiveData() {\n  	throw new Error("Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead");\n  }\n\n  function ComplexParameter(component, template, callback) {\n  	this.parentFragment = component.parentFragment;\n  	this.callback = callback;\n\n  	this.fragment = new virtualdom_Fragment({\n  		template: template,\n  		root: component.root,\n  		owner: this\n  	});\n\n  	this.update();\n  }\n\n  var initialise_ComplexParameter = ComplexParameter;\n\n  ComplexParameter.prototype = {\n  	bubble: function () {\n  		if (!this.dirty) {\n  			this.dirty = true;\n  			global_runloop.addView(this);\n  		}\n  	},\n\n  	update: function () {\n  		this.callback(this.fragment.getValue());\n  		this.dirty = false;\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		this.fragment.rebind(oldKeypath, newKeypath);\n  	},\n\n  	unbind: function () {\n  		this.fragment.unbind();\n  	}\n  };\n\n  var createInstance = function (component, Component, attributes, yieldTemplate, partials) {\n  	var instance,\n  	    parentFragment,\n  	    ractive,\n  	    fragment,\n  	    container,\n  	    inlinePartials = {},\n  	    data = {},\n  	    mappings = {},\n  	    ready,\n  	    resolvers = [];\n\n  	parentFragment = component.parentFragment;\n  	ractive = component.root;\n\n  	partials = partials || {};\n  	utils_object__extend(inlinePartials, partials);\n\n  	// Make contents available as a {{>content}} partial\n  	partials.content = yieldTemplate || [];\n\n  	// set a default partial for yields with no name\n  	inlinePartials[""] = partials.content;\n\n  	if (Component.defaults.el) {\n  		warnIfDebug("The <%s/> component has a default `el` property; it has been disregarded", component.name);\n  	}\n\n  	// find container\n  	fragment = parentFragment;\n  	while (fragment) {\n  		if (fragment.owner.type === YIELDER) {\n  			container = fragment.owner.container;\n  			break;\n  		}\n\n  		fragment = fragment.parent;\n  	}\n\n  	// each attribute represents either a) data or b) a mapping\n  	if (attributes) {\n  		Object.keys(attributes).forEach(function (key) {\n  			var attribute = attributes[key],\n  			    parsed,\n  			    resolver;\n\n  			if (typeof attribute === "string") {\n  				// it\'s static data\n  				parsed = parseJSON(attribute);\n  				data[key] = parsed ? parsed.value : attribute;\n  			} else if (attribute === 0) {\n  				// it had no \'=\', so we\'ll call it true\n  				data[key] = true;\n  			} else if (isArray(attribute)) {\n  				// this represents dynamic data\n  				if (isSingleInterpolator(attribute)) {\n  					mappings[key] = {\n  						origin: component.root.viewmodel,\n  						keypath: undefined\n  					};\n\n  					resolver = createResolver(component, attribute[0], function (keypath) {\n  						if (keypath.isSpecial) {\n  							if (ready) {\n  								instance.set(key, keypath.value); // TODO use viewmodel?\n  							} else {\n  								data[key] = keypath.value;\n\n  								// TODO errr.... would be better if we didn\'t have to do this\n  								delete mappings[key];\n  							}\n  						} else {\n  							if (ready) {\n  								instance.viewmodel.mappings[key].resolve(keypath);\n  							} else {\n  								// resolved immediately\n  								mappings[key].keypath = keypath;\n  							}\n  						}\n  					});\n  				} else {\n  					resolver = new initialise_ComplexParameter(component, attribute, function (value) {\n  						if (ready) {\n  							instance.set(key, value); // TODO use viewmodel?\n  						} else {\n  							data[key] = value;\n  						}\n  					});\n  				}\n\n  				resolvers.push(resolver);\n  			} else {\n  				throw new Error("erm wut");\n  			}\n  		});\n  	}\n\n  	instance = create(Component.prototype);\n\n  	initialise(instance, {\n  		el: null,\n  		append: true,\n  		data: data,\n  		partials: partials,\n  		magic: ractive.magic || Component.defaults.magic,\n  		modifyArrays: ractive.modifyArrays,\n  		// need to inherit runtime parent adaptors\n  		adapt: ractive.adapt\n  	}, {\n  		parent: ractive,\n  		component: component,\n  		container: container,\n  		mappings: mappings,\n  		inlinePartials: inlinePartials,\n  		cssIds: parentFragment.cssIds\n  	});\n\n  	ready = true;\n  	component.resolvers = resolvers;\n\n  	return instance;\n  };\n\n  function createResolver(component, template, callback) {\n  	var resolver;\n\n  	if (template.r) {\n  		resolver = Resolvers_createReferenceResolver(component, template.r, callback);\n  	} else if (template.x) {\n  		resolver = new Resolvers_ExpressionResolver(component, component.parentFragment, template.x, callback);\n  	} else if (template.rx) {\n  		resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(component, template.rx, callback);\n  	}\n\n  	return resolver;\n  }\n\n  function isSingleInterpolator(template) {\n  	return template.length === 1 && template[0].t === INTERPOLATOR;\n  }\n\n  // TODO how should event arguments be handled? e.g.\n  // <widget on-foo=\'bar:1,2,3\'/>\n  // The event \'bar\' will be fired on the parent instance\n  // when \'foo\' fires on the child, but the 1,2,3 arguments\n  // will be lost\n\n  var initialise_propagateEvents = propagateEvents;\n\n  function propagateEvents(component, eventsDescriptor) {\n  	var eventName;\n\n  	for (eventName in eventsDescriptor) {\n  		if (eventsDescriptor.hasOwnProperty(eventName)) {\n  			propagateEvent(component.instance, component.root, eventName, eventsDescriptor[eventName]);\n  		}\n  	}\n  }\n\n  function propagateEvent(childInstance, parentInstance, eventName, proxyEventName) {\n  	if (typeof proxyEventName !== "string") {\n  		fatal("Components currently only support simple events - you cannot include arguments. Sorry!");\n  	}\n\n  	childInstance.on(eventName, function () {\n  		var event, args;\n\n  		// semi-weak test, but what else? tag the event obj ._isEvent ?\n  		if (arguments.length && arguments[0] && arguments[0].node) {\n  			event = Array.prototype.shift.call(arguments);\n  		}\n\n  		args = Array.prototype.slice.call(arguments);\n\n  		shared_fireEvent(parentInstance, proxyEventName, { event: event, args: args });\n\n  		// cancel bubbling\n  		return false;\n  	});\n  }\n\n  var initialise_updateLiveQueries = function (component) {\n  	var ancestor, query;\n\n  	// If there\'s a live query for this component type, add it\n  	ancestor = component.root;\n  	while (ancestor) {\n  		if (query = ancestor._liveComponentQueries["_" + component.name]) {\n  			query.push(component.instance);\n  		}\n\n  		ancestor = ancestor.parent;\n  	}\n  };\n\n  var Component_prototype_init = Component$init;\n  function Component$init(options, Component) {\n  	var parentFragment, root;\n\n  	if (!Component) {\n  		throw new Error("Component \\"" + this.name + "\\" not found");\n  	}\n\n  	parentFragment = this.parentFragment = options.parentFragment;\n  	root = parentFragment.root;\n\n  	this.root = root;\n  	this.type = COMPONENT;\n  	this.name = options.template.e;\n  	this.index = options.index;\n  	this.indexRefBindings = {};\n  	this.yielders = {};\n  	this.resolvers = [];\n\n  	createInstance(this, Component, options.template.a, options.template.f, options.template.p);\n  	initialise_propagateEvents(this, options.template.v);\n\n  	// intro, outro and decorator directives have no effect\n  	if (options.template.t0 || options.template.t1 || options.template.t2 || options.template.o) {\n  		warnIfDebug("The \\"intro\\", \\"outro\\" and \\"decorator\\" directives have no effect on components", { ractive: this.instance });\n  	}\n\n  	initialise_updateLiveQueries(this);\n  }\n\n  var Component_prototype_rebind = Component$rebind;\n\n  function Component$rebind(oldKeypath, newKeypath) {\n  	var query;\n\n  	this.resolvers.forEach(rebind);\n\n  	for (var k in this.yielders) {\n  		if (this.yielders[k][0]) {\n  			rebind(this.yielders[k][0]);\n  		}\n  	}\n\n  	if (query = this.root._liveComponentQueries["_" + this.name]) {\n  		query._makeDirty();\n  	}\n\n  	function rebind(x) {\n  		x.rebind(oldKeypath, newKeypath);\n  	}\n  }\n\n  var Component_prototype_render = Component$render;\n\n  function Component$render() {\n  	var instance = this.instance;\n\n  	instance.render(this.parentFragment.getNode());\n\n  	this.rendered = true;\n  	return instance.fragment.detach();\n  }\n\n  var Component_prototype_toString = Component$toString;\n\n  function Component$toString() {\n  	return this.instance.fragment.toString();\n  }\n\n  var Component_prototype_unbind = Component$unbind;\n\n  var Component_prototype_unbind__teardownHook = new hooks_Hook("teardown");\n  function Component$unbind() {\n  	var instance = this.instance;\n\n  	this.resolvers.forEach(methodCallers__unbind);\n\n  	removeFromLiveComponentQueries(this);\n\n  	instance._observers.forEach(cancel);\n\n  	// teardown the instance\n  	instance.fragment.unbind();\n  	instance.viewmodel.teardown();\n\n  	if (instance.fragment.rendered && instance.el.__ractive_instances__) {\n  		removeFromArray(instance.el.__ractive_instances__, instance);\n  	}\n\n  	Component_prototype_unbind__teardownHook.fire(instance);\n  }\n\n  function removeFromLiveComponentQueries(component) {\n  	var instance, query;\n\n  	instance = component.root;\n\n  	do {\n  		if (query = instance._liveComponentQueries["_" + component.name]) {\n  			query._remove(component);\n  		}\n  	} while (instance = instance.parent);\n  }\n\n  var Component_prototype_unrender = Component$unrender;\n\n  function Component$unrender(shouldDestroy) {\n  	this.shouldDestroy = shouldDestroy;\n  	this.instance.unrender();\n  }\n\n  var Component = function (options, Constructor) {\n  	this.init(options, Constructor);\n  };\n\n  Component.prototype = {\n  	detach: Component_prototype_detach,\n  	find: Component_prototype_find,\n  	findAll: Component_prototype_findAll,\n  	findAllComponents: Component_prototype_findAllComponents,\n  	findComponent: Component_prototype_findComponent,\n  	findNextNode: Component_prototype_findNextNode,\n  	firstNode: Component_prototype_firstNode,\n  	init: Component_prototype_init,\n  	rebind: Component_prototype_rebind,\n  	render: Component_prototype_render,\n  	toString: Component_prototype_toString,\n  	unbind: Component_prototype_unbind,\n  	unrender: Component_prototype_unrender\n  };\n\n  var _Component = Component;\n\n  var Comment = function (options) {\n  	this.type = COMMENT;\n  	this.value = options.template.c;\n  };\n\n  Comment.prototype = {\n  	detach: shared_detach,\n\n  	firstNode: function () {\n  		return this.node;\n  	},\n\n  	render: function () {\n  		if (!this.node) {\n  			this.node = document.createComment(this.value);\n  		}\n\n  		return this.node;\n  	},\n\n  	toString: function () {\n  		return "<!--" + this.value + "-->";\n  	},\n\n  	unrender: function (shouldDestroy) {\n  		if (shouldDestroy) {\n  			this.node.parentNode.removeChild(this.node);\n  		}\n  	}\n  };\n\n  var items_Comment = Comment;\n\n  var Yielder = function (options) {\n  	var container, component;\n\n  	this.type = YIELDER;\n\n  	this.container = container = options.parentFragment.root;\n  	this.component = component = container.component;\n\n  	this.container = container;\n  	this.containerFragment = options.parentFragment;\n  	this.parentFragment = component.parentFragment;\n\n  	var name = this.name = options.template.n || "";\n\n  	var template = container._inlinePartials[name];\n\n  	if (!template) {\n  		warnIfDebug("Could not find template for partial \\"" + name + "\\"", { ractive: options.root });\n  		template = [];\n  	}\n\n  	this.fragment = new virtualdom_Fragment({\n  		owner: this,\n  		root: container.parent,\n  		template: template,\n  		pElement: this.containerFragment.pElement\n  	});\n\n  	// even though only one yielder is allowed, we need to have an array of them\n  	// as it\'s possible to cause a yielder to be created before the last one\n  	// was destroyed in the same turn of the runloop\n  	if (!isArray(component.yielders[name])) {\n  		component.yielders[name] = [this];\n  	} else {\n  		component.yielders[name].push(this);\n  	}\n\n  	global_runloop.scheduleTask(function () {\n  		if (component.yielders[name].length > 1) {\n  			throw new Error("A component template can only have one {{yield" + (name ? " " + name : "") + "}} declaration at a time");\n  		}\n  	});\n  };\n\n  Yielder.prototype = {\n  	detach: function () {\n  		return this.fragment.detach();\n  	},\n\n  	find: function (selector) {\n  		return this.fragment.find(selector);\n  	},\n\n  	findAll: function (selector, query) {\n  		return this.fragment.findAll(selector, query);\n  	},\n\n  	findComponent: function (selector) {\n  		return this.fragment.findComponent(selector);\n  	},\n\n  	findAllComponents: function (selector, query) {\n  		return this.fragment.findAllComponents(selector, query);\n  	},\n\n  	findNextNode: function () {\n  		return this.containerFragment.findNextNode(this);\n  	},\n\n  	firstNode: function () {\n  		return this.fragment.firstNode();\n  	},\n\n  	getValue: function (options) {\n  		return this.fragment.getValue(options);\n  	},\n\n  	render: function () {\n  		return this.fragment.render();\n  	},\n\n  	unbind: function () {\n  		this.fragment.unbind();\n  	},\n\n  	unrender: function (shouldDestroy) {\n  		this.fragment.unrender(shouldDestroy);\n  		removeFromArray(this.component.yielders[this.name], this);\n  	},\n\n  	rebind: function (oldKeypath, newKeypath) {\n  		this.fragment.rebind(oldKeypath, newKeypath);\n  	},\n\n  	toString: function () {\n  		return this.fragment.toString();\n  	}\n  };\n\n  var items_Yielder = Yielder;\n\n  var Doctype = function (options) {\n  	this.declaration = options.template.a;\n  };\n\n  Doctype.prototype = {\n  	init: noop,\n  	render: noop,\n  	unrender: noop,\n  	teardown: noop,\n  	toString: function () {\n  		return "<!DOCTYPE" + this.declaration + ">";\n  	}\n  };\n\n  var items_Doctype = Doctype;\n\n  var Fragment_prototype_init = Fragment$init;\n\n  function Fragment$init(options) {\n  	var _this = this;\n\n  	this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n  	this.parent = this.owner.parentFragment;\n\n  	// inherited properties\n  	this.root = options.root;\n  	this.pElement = options.pElement;\n  	this.context = options.context;\n  	this.index = options.index;\n  	this.key = options.key;\n  	this.registeredIndexRefs = [];\n\n  	// encapsulated styles should be inherited until they get applied by an element\n  	this.cssIds = "cssIds" in options ? options.cssIds : this.parent ? this.parent.cssIds : null;\n\n  	this.items = options.template.map(function (template, i) {\n  		return createItem({\n  			parentFragment: _this,\n  			pElement: options.pElement,\n  			template: template,\n  			index: i\n  		});\n  	});\n\n  	this.value = this.argsList = null;\n  	this.dirtyArgs = this.dirtyValue = true;\n\n  	this.bound = true;\n  }\n\n  function createItem(options) {\n  	if (typeof options.template === "string") {\n  		return new items_Text(options);\n  	}\n\n  	switch (options.template.t) {\n  		case YIELDER:\n  			return new items_Yielder(options);\n  		case INTERPOLATOR:\n  			return new items_Interpolator(options);\n  		case SECTION:\n  			return new _Section(options);\n  		case TRIPLE:\n  			return new _Triple(options);\n  		case ELEMENT:\n  			var constructor = undefined;\n  			if (constructor = Component_getComponent(options.parentFragment.root, options.template.e)) {\n  				return new _Component(options, constructor);\n  			}\n  			return new _Element(options);\n  		case PARTIAL:\n  			return new _Partial(options);\n  		case COMMENT:\n  			return new items_Comment(options);\n  		case DOCTYPE:\n  			return new items_Doctype(options);\n\n  		default:\n  			throw new Error("Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!");\n  	}\n  }\n\n  var Fragment_prototype_rebind = Fragment$rebind;\n  function Fragment$rebind(oldKeypath, newKeypath) {\n\n  	// assign new context keypath if needed\n  	if (!this.owner || this.owner.hasContext) {\n  		assignNewKeypath(this, "context", oldKeypath, newKeypath);\n  	}\n\n  	this.items.forEach(function (item) {\n  		if (item.rebind) {\n  			item.rebind(oldKeypath, newKeypath);\n  		}\n  	});\n  }\n\n  var Fragment_prototype_render = Fragment$render;\n\n  function Fragment$render() {\n  	var result;\n\n  	if (this.items.length === 1) {\n  		result = this.items[0].render();\n  	} else {\n  		result = document.createDocumentFragment();\n\n  		this.items.forEach(function (item) {\n  			result.appendChild(item.render());\n  		});\n  	}\n\n  	this.rendered = true;\n  	return result;\n  }\n\n  var Fragment_prototype_toString = Fragment$toString;\n\n  function Fragment$toString(escape) {\n  	if (!this.items) {\n  		return "";\n  	}\n\n  	return this.items.map(escape ? toEscapedString : Fragment_prototype_toString__toString).join("");\n  }\n\n  function Fragment_prototype_toString__toString(item) {\n  	return item.toString();\n  }\n\n  function toEscapedString(item) {\n  	return item.toString(true);\n  }\n\n  var Fragment_prototype_unbind = Fragment$unbind;\n\n  function Fragment$unbind() {\n  	if (!this.bound) {\n  		return;\n  	}\n\n  	this.items.forEach(unbindItem);\n  	this.bound = false;\n  }\n\n  function unbindItem(item) {\n  	if (item.unbind) {\n  		item.unbind();\n  	}\n  }\n\n  var Fragment_prototype_unrender = Fragment$unrender;\n\n  function Fragment$unrender(shouldDestroy) {\n  	if (!this.rendered) {\n  		throw new Error("Attempted to unrender a fragment that was not rendered");\n  	}\n\n  	this.items.forEach(function (i) {\n  		return i.unrender(shouldDestroy);\n  	});\n  	this.rendered = false;\n  }\n\n  var Fragment = function (options) {\n  	this.init(options);\n  };\n\n  Fragment.prototype = {\n  	bubble: prototype_bubble,\n  	detach: Fragment_prototype_detach,\n  	find: Fragment_prototype_find,\n  	findAll: Fragment_prototype_findAll,\n  	findAllComponents: Fragment_prototype_findAllComponents,\n  	findComponent: Fragment_prototype_findComponent,\n  	findNextNode: prototype_findNextNode,\n  	firstNode: prototype_firstNode,\n  	getArgsList: getArgsList,\n  	getNode: getNode,\n  	getValue: prototype_getValue,\n  	init: Fragment_prototype_init,\n  	rebind: Fragment_prototype_rebind,\n  	registerIndexRef: function (idx) {\n  		var idxs = this.registeredIndexRefs;\n  		if (idxs.indexOf(idx) === -1) {\n  			idxs.push(idx);\n  		}\n  	},\n  	render: Fragment_prototype_render,\n  	toString: Fragment_prototype_toString,\n  	unbind: Fragment_prototype_unbind,\n  	unregisterIndexRef: function (idx) {\n  		var idxs = this.registeredIndexRefs;\n  		idxs.splice(idxs.indexOf(idx), 1);\n  	},\n  	unrender: Fragment_prototype_unrender\n  };\n\n  var virtualdom_Fragment = Fragment;\n\n  var prototype_reset = Ractive$reset;\n  var shouldRerender = ["template", "partials", "components", "decorators", "events"],\n      resetHook = new hooks_Hook("reset");\n  function Ractive$reset(data) {\n  	var promise, wrapper, changes, i, rerender;\n\n  	data = data || {};\n\n  	if (typeof data !== "object") {\n  		throw new Error("The reset method takes either no arguments, or an object containing new data");\n  	}\n\n  	// If the root object is wrapped, try and use the wrapper\'s reset value\n  	if ((wrapper = this.viewmodel.wrapped[""]) && wrapper.reset) {\n  		if (wrapper.reset(data) === false) {\n  			// reset was rejected, we need to replace the object\n  			this.viewmodel.reset(data);\n  		}\n  	} else {\n  		this.viewmodel.reset(data);\n  	}\n\n  	// reset config items and track if need to rerender\n  	changes = config_config.reset(this);\n\n  	i = changes.length;\n  	while (i--) {\n  		if (shouldRerender.indexOf(changes[i]) > -1) {\n  			rerender = true;\n  			break;\n  		}\n  	}\n\n  	if (rerender) {\n  		var component = undefined;\n\n  		this.viewmodel.mark(rootKeypath);\n\n  		// Is this is a component, we need to set the `shouldDestroy`\n  		// flag, otherwise it will assume by default that a parent node\n  		// will be detached, and therefore it doesn\'t need to bother\n  		// detaching its own nodes\n  		if (component = this.component) {\n  			component.shouldDestroy = true;\n  		}\n\n  		this.unrender();\n\n  		if (component) {\n  			component.shouldDestroy = false;\n  		}\n\n  		// If the template changed, we need to destroy the parallel DOM\n  		// TODO if we\'re here, presumably it did?\n  		if (this.fragment.template !== this.template) {\n  			this.fragment.unbind();\n\n  			this.fragment = new virtualdom_Fragment({\n  				template: this.template,\n  				root: this,\n  				owner: this\n  			});\n  		}\n\n  		promise = this.render(this.el, this.anchor);\n  	} else {\n  		promise = global_runloop.start(this, true);\n  		this.viewmodel.mark(rootKeypath);\n  		global_runloop.end();\n  	}\n\n  	resetHook.fire(this, data);\n\n  	return promise;\n  }\n\n  var resetPartial = function (name, partial) {\n  	var promise,\n  	    collection = [];\n\n  	function collect(source, dest, ractive) {\n  		// if this is a component and it has its own partial, bail\n  		if (ractive && ractive.partials[name]) return;\n\n  		source.forEach(function (item) {\n  			// queue to rerender if the item is a partial and the current name matches\n  			if (item.type === PARTIAL && item.getPartialName() === name) {\n  				dest.push(item);\n  			}\n\n  			// if it has a fragment, process its items\n  			if (item.fragment) {\n  				collect(item.fragment.items, dest, ractive);\n  			}\n\n  			// or if it has fragments\n  			if (isArray(item.fragments)) {\n  				collect(item.fragments, dest, ractive);\n  			}\n\n  			// or if it is itself a fragment, process its items\n  			else if (isArray(item.items)) {\n  				collect(item.items, dest, ractive);\n  			}\n\n  			// or if it is a component, step in and process its items\n  			else if (item.type === COMPONENT && item.instance) {\n  				collect(item.instance.fragment.items, dest, item.instance);\n  			}\n\n  			// if the item is an element, process its attributes too\n  			if (item.type === ELEMENT) {\n  				if (isArray(item.attributes)) {\n  					collect(item.attributes, dest, ractive);\n  				}\n\n  				if (isArray(item.conditionalAttributes)) {\n  					collect(item.conditionalAttributes, dest, ractive);\n  				}\n  			}\n  		});\n  	}\n\n  	collect(this.fragment.items, collection);\n  	this.partials[name] = partial;\n\n  	promise = global_runloop.start(this, true);\n\n  	collection.forEach(function (item) {\n  		item.value = undefined;\n  		item.setValue(name);\n  	});\n\n  	global_runloop.end();\n\n  	return promise;\n  };\n\n  // TODO should resetTemplate be asynchronous? i.e. should it be a case\n  // of outro, update template, intro? I reckon probably not, since that\n  // could be achieved with unrender-resetTemplate-render. Also, it should\n  // conceptually be similar to resetPartial, which couldn\'t be async\n\n  var resetTemplate = Ractive$resetTemplate;\n  function Ractive$resetTemplate(template) {\n  	var transitionsEnabled, component;\n\n  	template_template.init(null, this, { template: template });\n\n  	transitionsEnabled = this.transitionsEnabled;\n  	this.transitionsEnabled = false;\n\n  	// Is this is a component, we need to set the `shouldDestroy`\n  	// flag, otherwise it will assume by default that a parent node\n  	// will be detached, and therefore it doesn\'t need to bother\n  	// detaching its own nodes\n  	if (component = this.component) {\n  		component.shouldDestroy = true;\n  	}\n\n  	this.unrender();\n\n  	if (component) {\n  		component.shouldDestroy = false;\n  	}\n\n  	// remove existing fragment and create new one\n  	this.fragment.unbind();\n  	this.fragment = new virtualdom_Fragment({\n  		template: this.template,\n  		root: this,\n  		owner: this\n  	});\n\n  	this.render(this.el, this.anchor);\n\n  	this.transitionsEnabled = transitionsEnabled;\n  }\n\n  var reverse = makeArrayMethod("reverse");\n\n  var Ractive_prototype_set = Ractive$set;\n\n  function Ractive$set(keypath, value) {\n  	var map, promise;\n\n  	promise = global_runloop.start(this, true);\n\n  	// Set multiple keypaths in one go\n  	if (isObject(keypath)) {\n  		map = keypath;\n\n  		for (keypath in map) {\n  			if (map.hasOwnProperty(keypath)) {\n  				value = map[keypath];\n  				set(this, keypath, value);\n  			}\n  		}\n  	}\n\n  	// Set a single keypath\n  	else {\n  		set(this, keypath, value);\n  	}\n\n  	global_runloop.end();\n\n  	return promise;\n  }\n\n  function set(ractive, keypath, value) {\n  	keypath = getKeypath(normalise(keypath));\n\n  	if (keypath.isPattern) {\n  		getMatchingKeypaths(ractive, keypath).forEach(function (keypath) {\n  			ractive.viewmodel.set(keypath, value);\n  		});\n  	} else {\n  		ractive.viewmodel.set(keypath, value);\n  	}\n  }\n\n  var shift = makeArrayMethod("shift");\n\n  var prototype_sort = makeArrayMethod("sort");\n\n  var splice = makeArrayMethod("splice");\n\n  var subtract = Ractive$subtract;\n  function Ractive$subtract(keypath, d) {\n  	return shared_add(this, keypath, d === undefined ? -1 : -d);\n  }\n\n  // Teardown. This goes through the root fragment and all its children, removing observers\n  // and generally cleaning up after itself\n\n  var Ractive_prototype_teardown = Ractive$teardown;\n\n  var Ractive_prototype_teardown__teardownHook = new hooks_Hook("teardown");\n  function Ractive$teardown() {\n  	var promise;\n\n  	this.fragment.unbind();\n  	this.viewmodel.teardown();\n\n  	this._observers.forEach(cancel);\n\n  	if (this.fragment.rendered && this.el.__ractive_instances__) {\n  		removeFromArray(this.el.__ractive_instances__, this);\n  	}\n\n  	this.shouldDestroy = true;\n  	promise = this.fragment.rendered ? this.unrender() : utils_Promise.resolve();\n\n  	Ractive_prototype_teardown__teardownHook.fire(this);\n\n  	this._boundFunctions.forEach(deleteFunctionCopy);\n\n  	return promise;\n  }\n\n  function deleteFunctionCopy(bound) {\n  	delete bound.fn[bound.prop];\n  }\n\n  var toggle = Ractive$toggle;\n  function Ractive$toggle(keypath) {\n  	var _this = this;\n\n  	if (typeof keypath !== "string") {\n  		throw new TypeError(badArguments);\n  	}\n\n  	var changes = undefined;\n\n  	if (/\\*/.test(keypath)) {\n  		changes = {};\n\n  		getMatchingKeypaths(this, getKeypath(normalise(keypath))).forEach(function (keypath) {\n  			changes[keypath.str] = !_this.viewmodel.get(keypath);\n  		});\n\n  		return this.set(changes);\n  	}\n\n  	return this.set(keypath, !this.get(keypath));\n  }\n\n  var toHTML = Ractive$toHTML;\n\n  function Ractive$toHTML() {\n  	return this.fragment.toString(true);\n  }\n\n  var Ractive_prototype_unrender = Ractive$unrender;\n  var unrenderHook = new hooks_Hook("unrender");\n  function Ractive$unrender() {\n  	var promise, shouldDestroy;\n\n  	if (!this.fragment.rendered) {\n  		warnIfDebug("ractive.unrender() was called on a Ractive instance that was not rendered");\n  		return utils_Promise.resolve();\n  	}\n\n  	promise = global_runloop.start(this, true);\n\n  	// If this is a component, and the component isn\'t marked for destruction,\n  	// don\'t detach nodes from the DOM unnecessarily\n  	shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\n  	// Cancel any animations in progress\n  	while (this._animations[0]) {\n  		this._animations[0].stop(); // it will remove itself from the index\n  	}\n\n  	this.fragment.unrender(shouldDestroy);\n\n  	removeFromArray(this.el.__ractive_instances__, this);\n\n  	unrenderHook.fire(this);\n\n  	global_runloop.end();\n  	return promise;\n  }\n\n  var unshift = makeArrayMethod("unshift");\n\n  var Ractive_prototype_update = Ractive$update;\n  var updateHook = new hooks_Hook("update");\n  function Ractive$update(keypath) {\n  	var promise;\n\n  	keypath = getKeypath(keypath) || rootKeypath;\n\n  	promise = global_runloop.start(this, true);\n  	this.viewmodel.mark(keypath);\n  	global_runloop.end();\n\n  	updateHook.fire(this, keypath);\n\n  	return promise;\n  }\n\n  var prototype_updateModel = Ractive$updateModel;\n\n  function Ractive$updateModel(keypath, cascade) {\n  	var values, key, bindings;\n\n  	if (typeof keypath === "string" && !cascade) {\n  		bindings = this._twowayBindings[keypath];\n  	} else {\n  		bindings = [];\n\n  		for (key in this._twowayBindings) {\n  			if (!keypath || getKeypath(key).equalsOrStartsWith(keypath)) {\n  				// TODO is this right?\n  				bindings.push.apply(bindings, this._twowayBindings[key]);\n  			}\n  		}\n  	}\n\n  	values = consolidate(this, bindings);\n  	return this.set(values);\n  }\n\n  function consolidate(ractive, bindings) {\n  	var values = {},\n  	    checkboxGroups = [];\n\n  	bindings.forEach(function (b) {\n  		var oldValue, newValue;\n\n  		// special case - radio name bindings\n  		if (b.radioName && !b.element.node.checked) {\n  			return;\n  		}\n\n  		// special case - checkbox name bindings come in groups, so\n  		// we want to get the value once at most\n  		if (b.checkboxName) {\n  			if (!checkboxGroups[b.keypath.str] && !b.changed()) {\n  				checkboxGroups.push(b.keypath);\n  				checkboxGroups[b.keypath.str] = b;\n  			}\n\n  			return;\n  		}\n\n  		oldValue = b.attribute.value;\n  		newValue = b.getValue();\n\n  		if (arrayContentsMatch(oldValue, newValue)) {\n  			return;\n  		}\n\n  		if (!isEqual(oldValue, newValue)) {\n  			values[b.keypath.str] = newValue;\n  		}\n  	});\n\n  	// Handle groups of `<input type=\'checkbox\' name=\'{{foo}}\' ...>`\n  	if (checkboxGroups.length) {\n  		checkboxGroups.forEach(function (keypath) {\n  			var binding, oldValue, newValue;\n\n  			binding = checkboxGroups[keypath.str]; // one to represent the entire group\n  			oldValue = binding.attribute.value;\n  			newValue = binding.getValue();\n\n  			if (!arrayContentsMatch(oldValue, newValue)) {\n  				values[keypath.str] = newValue;\n  			}\n  		});\n  	}\n\n  	return values;\n  }\n\n  var prototype = {\n  	add: prototype_add,\n  	animate: prototype_animate,\n  	detach: prototype_detach,\n  	find: prototype_find,\n  	findAll: prototype_findAll,\n  	findAllComponents: prototype_findAllComponents,\n  	findComponent: prototype_findComponent,\n  	findContainer: findContainer,\n  	findParent: findParent,\n  	fire: prototype_fire,\n  	get: prototype_get,\n  	insert: insert,\n  	merge: prototype_merge,\n  	observe: observe,\n  	observeOnce: observeOnce,\n  	off: off,\n  	on: on,\n  	once: once,\n  	pop: pop,\n  	push: push,\n  	render: prototype_render,\n  	reset: prototype_reset,\n  	resetPartial: resetPartial,\n  	resetTemplate: resetTemplate,\n  	reverse: reverse,\n  	set: Ractive_prototype_set,\n  	shift: shift,\n  	sort: prototype_sort,\n  	splice: splice,\n  	subtract: subtract,\n  	teardown: Ractive_prototype_teardown,\n  	toggle: toggle,\n  	toHTML: toHTML,\n  	toHtml: toHTML,\n  	unrender: Ractive_prototype_unrender,\n  	unshift: unshift,\n  	update: Ractive_prototype_update,\n  	updateModel: prototype_updateModel\n  };\n\n  var wrapMethod = function (method, superMethod, force) {\n\n  	if (force || needsSuper(method, superMethod)) {\n\n  		return function () {\n\n  			var hasSuper = ("_super" in this),\n  			    _super = this._super,\n  			    result;\n\n  			this._super = superMethod;\n\n  			result = method.apply(this, arguments);\n\n  			if (hasSuper) {\n  				this._super = _super;\n  			}\n\n  			return result;\n  		};\n  	} else {\n  		return method;\n  	}\n  };\n\n  function needsSuper(method, superMethod) {\n  	return typeof superMethod === "function" && /_super/.test(method);\n  }\n\n  var unwrapExtended = unwrap;\n\n  function unwrap(Child) {\n  	var options = {};\n\n  	while (Child) {\n  		addRegistries(Child, options);\n  		addOtherOptions(Child, options);\n\n  		if (Child._Parent !== _Ractive) {\n  			Child = Child._Parent;\n  		} else {\n  			Child = false;\n  		}\n  	}\n\n  	return options;\n  }\n\n  function addRegistries(Child, options) {\n  	config_registries.forEach(function (r) {\n  		addRegistry(r.useDefaults ? Child.prototype : Child, options, r.name);\n  	});\n  }\n\n  function addRegistry(target, options, name) {\n  	var registry,\n  	    keys = Object.keys(target[name]);\n\n  	if (!keys.length) {\n  		return;\n  	}\n\n  	if (!(registry = options[name])) {\n  		registry = options[name] = {};\n  	}\n\n  	keys.filter(function (key) {\n  		return !(key in registry);\n  	}).forEach(function (key) {\n  		return registry[key] = target[name][key];\n  	});\n  }\n\n  function addOtherOptions(Child, options) {\n  	Object.keys(Child.prototype).forEach(function (key) {\n  		if (key === "computed") {\n  			return;\n  		}\n\n  		var value = Child.prototype[key];\n\n  		if (!(key in options)) {\n  			options[key] = value._method ? value._method : value;\n  		}\n\n  		// is it a wrapped function?\n  		else if (typeof options[key] === "function" && typeof value === "function" && options[key]._method) {\n\n  			var result = undefined,\n  			    needsSuper = value._method;\n\n  			if (needsSuper) {\n  				value = value._method;\n  			}\n\n  			// rewrap bound directly to parent fn\n  			result = wrapMethod(options[key]._method, value);\n\n  			if (needsSuper) {\n  				result._method = result;\n  			}\n\n  			options[key] = result;\n  		}\n  	});\n  }\n\n  var _extend = _extend__extend;\n\n  function _extend__extend() {\n  	for (var _len = arguments.length, options = Array(_len), _key = 0; _key < _len; _key++) {\n  		options[_key] = arguments[_key];\n  	}\n\n  	if (!options.length) {\n  		return extendOne(this);\n  	} else {\n  		return options.reduce(extendOne, this);\n  	}\n  }\n\n  function extendOne(Parent) {\n  	var options = arguments[1] === undefined ? {} : arguments[1];\n\n  	var Child, proto;\n\n  	// if we\'re extending with another Ractive instance...\n  	//\n  	//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);\n  	//   var Spiderman = Human.extend( Spider );\n  	//\n  	// ...inherit prototype methods and default options as well\n  	if (options.prototype instanceof _Ractive) {\n  		options = unwrapExtended(options);\n  	}\n\n  	Child = function (options) {\n  		if (!(this instanceof Child)) return new Child(options);\n  		initialise(this, options);\n  	};\n\n  	proto = create(Parent.prototype);\n  	proto.constructor = Child;\n\n  	// Static properties\n  	defineProperties(Child, {\n  		// alias prototype as defaults\n  		defaults: { value: proto },\n\n  		// extendable\n  		extend: { value: _extend__extend, writable: true, configurable: true },\n\n  		// Parent - for IE8, can\'t use Object.getPrototypeOf\n  		_Parent: { value: Parent }\n  	});\n\n  	// extend configuration\n  	config_config.extend(Parent, proto, options);\n\n  	custom_data.extend(Parent, proto, options);\n\n  	if (options.computed) {\n  		proto.computed = utils_object__extend(create(Parent.prototype.computed), options.computed);\n  	}\n\n  	Child.prototype = proto;\n\n  	return Child;\n  }\n\n  var getNodeInfo = function (node) {\n  	var info = {},\n  	    priv,\n  	    indices;\n\n  	if (!node || !(priv = node._ractive)) {\n  		return info;\n  	}\n\n  	info.ractive = priv.root;\n  	info.keypath = priv.keypath.str;\n  	info.index = {};\n\n  	// find all index references and resolve them\n  	if (indices = Resolvers_findIndexRefs(priv.proxy.parentFragment)) {\n  		info.index = Resolvers_findIndexRefs.resolve(indices);\n  	}\n\n  	return info;\n  };\n\n  var Ractive, properties;\n\n  // Main Ractive required object\n  Ractive = function (options) {\n  	if (!(this instanceof Ractive)) return new Ractive(options);\n  	initialise(this, options);\n  };\n\n  // Ractive properties\n  properties = {\n\n  	// debug flag\n  	DEBUG: { writable: true, value: true },\n  	DEBUG_PROMISES: { writable: true, value: true },\n\n  	// static methods:\n  	extend: { value: _extend },\n  	getNodeInfo: { value: getNodeInfo },\n  	parse: { value: _parse },\n\n  	// Namespaced constructors\n  	Promise: { value: utils_Promise },\n\n  	// support\n  	svg: { value: svg },\n  	magic: { value: environment__magic },\n\n  	// version\n  	VERSION: { value: "0.7.2" },\n\n  	// Plugins\n  	adaptors: { writable: true, value: {} },\n  	components: { writable: true, value: {} },\n  	decorators: { writable: true, value: {} },\n  	easing: { writable: true, value: static_easing },\n  	events: { writable: true, value: {} },\n  	interpolators: { writable: true, value: static_interpolators },\n  	partials: { writable: true, value: {} },\n  	transitions: { writable: true, value: {} }\n  };\n\n  // Ractive properties\n  defineProperties(Ractive, properties);\n\n  Ractive.prototype = utils_object__extend(prototype, config_defaults);\n\n  Ractive.prototype.constructor = Ractive;\n\n  // alias prototype as defaults\n  Ractive.defaults = Ractive.prototype;\n\n  // Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n  // older browsers, these are made available via a shim - here, we do a quick\n  // pre-flight check to make sure that either a) we\'re not in a shit browser,\n  // or b) we\'re using a Ractive-legacy.js build\n  var FUNCTION = "function";\n\n  if (typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== "undefined" && typeof window.addEventListener !== FUNCTION) {\n  	throw new Error("It looks like you\'re attempting to use Ractive.js in an older browser. You\'ll need to use one of the \'legacy builds\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.");\n  }\n\n  var _Ractive = Ractive;\n\n  return _Ractive;\n\n}));\n//# sourceMappingURL=ractive.js.map\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JhY3RpdmUvcmFjdGl2ZS5qcz9mMGIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjs7QUFFckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyw2QkFBNkI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekIsMEJBQTBCLE9BQU87QUFDakM7O0FBRUE7QUFDQSxXQUFXO0FBQ1gsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCLFdBQVcsV0FBVztBQUNqRDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsV0FBVyxXQUFXOztBQUVqRDtBQUNBLGtFQUFrRSxXQUFXO0FBQzdFOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLEdBQUcsUUFBUSxXQUFXLEVBQUU7QUFDdEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxRQUFRLFdBQVcsRUFBRTtBQUN4RTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSx3RkFBd0YsYUFBYTtBQUNyRztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3RkFBd0YsYUFBYTtBQUNyRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxR0FBcUcscUJBQXFCLDJCQUEyQixxQkFBcUIsMkJBQTJCLHFCQUFxQiw2QkFBNkIscUJBQXFCLDRCQUE0QjtBQUN4UyxrUUFBa1EsdUhBQXVILGVBQWUsRUFBRTs7QUFFMVk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRkFBMEYsMkJBQTJCO0FBQ3JIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxxRkFBcUYsYUFBYTtBQUNsRztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUZBQXFGLGFBQWE7QUFDbEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRkFBcUYsYUFBYTtBQUNsRztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBOztBQUVBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHFEQUFxRDtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVTtBQUNWLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0wsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7O0FBRUEsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsa0JBQWtCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBLGlCQUFpQjtBQUNqQixJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxXQUFXLGNBQWM7O0FBRXpCLHdCQUF3QiwwQkFBMEI7QUFDbEQsWUFBWTtBQUNaLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSwwQkFBMEI7O0FBRXZDLFlBQVksaUJBQWlCO0FBQzdCLFlBQVksY0FBYztBQUMxQixpQkFBaUIseUJBQXlCO0FBQzFDLGNBQWMsZ0JBQWdCOztBQUU5QixhQUFhO0FBQ2IsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhCQUE4QixRQUFRO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEdBQUcsK0NBQStDOztBQUV0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNENBQTRDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBOztBQUVBLFNBQVMsZUFBZTtBQUN4QjtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNGQUFzRixhQUFhO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLGNBQWMsd0JBQXdCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUUsRUFBRSxjQUFjLEVBQUU7O0FBRXZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpREFBaUQ7QUFDakQ7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx3REFBd0Q7O0FBRXZFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYiw4Q0FBOEM7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYiw4Q0FBOEM7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLCtDQUErQzs7QUFFL0M7O0FBRUEsOENBQThDLFVBQVU7QUFDeEQseUJBQXlCLGFBQWEsUUFBUSxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixvREFBb0Q7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxHQUFHO0FBQ3pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksRUFBRTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksRUFBRTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUssS0FBSztBQUN0QyxvQ0FBb0MsS0FBSyxLQUFLO0FBQzlD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QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbURBQW1ELGNBQWM7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxzQkFBc0I7QUFDcEMsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQsY0FBYywrQkFBK0I7QUFDN0MsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCxvQ0FBb0M7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNFQUFzRTtBQUM5Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7O0FBRUE7O0FBRUEsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHdEQUF3RDtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0Msd0JBQXdCLHVCQUF1QjtBQUNuRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCLG1CQUFtQjs7QUFFM0U7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixTQUFTOztBQUVqQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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SUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3SEFBd0gsd0JBQXdCO0FBQ2hKOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCxrQ0FBa0M7QUFDcEY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsMkJBQTJCO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFELGtCQUFrQjtBQUN2RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSkFBMEosZUFBZTtBQUN6SyxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxJQUFJO0FBQ0o7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMLGVBQWU7QUFDZixLQUFLO0FBQ0wsZUFBZTtBQUNmO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkZBQTZGLHFCQUFxQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxnQkFBZ0I7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVFQUF1RSxtQkFBbUI7QUFDMUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSyxpREFBaUQsbUJBQW1CO0FBQ3ZHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxvREFBb0Qsb0RBQW9EO0FBQ3hHLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZFQUE2RSxtQkFBbUI7O0FBRWhHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsV0FBVyxXQUFXOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxnREFBZ0QsNEJBQTRCO0FBQzVFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCO0FBQ3hCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJEQUEyRDtBQUN2Rzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLG9CQUFvQixpREFBaUQ7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxhQUFhLE1BQU07QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSiw4REFBOEQ7QUFDOUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUFnRDs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxlQUFlO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QixpQkFBaUI7QUFDekMseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLDZCQUE2QixlQUFlOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVEQUF1RCxLQUFLLEtBQUs7QUFDakU7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QWtDO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzREFBc0QsMkJBQTJCOztBQUVqRjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUdBQXVHLHlCQUF5QjtBQUNoSTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EseUVBQXlFLHdCQUF3QjtBQUNqRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStELHVDQUF1QztBQUN0RztBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMscUJBQXFCOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosdURBQXVELEtBQUs7QUFDNUQ7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0EscUVBQXFFLGFBQWE7QUFDbEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlOztBQUU5QjtBQUNBLGFBQWEsNkRBQTZEOztBQUUxRTtBQUNBLGNBQWM7QUFDZCxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyw4QkFBOEI7QUFDekMsb0JBQW9CLDhCQUE4Qjs7QUFFbEQ7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixpQkFBaUIscUJBQXFCO0FBQ3RDLFdBQVcsZ0JBQWdCOztBQUUzQjtBQUNBLGFBQWEsdUJBQXVCOztBQUVwQztBQUNBLFNBQVMsYUFBYTtBQUN0QixXQUFXLDRCQUE0Qjs7QUFFdkM7QUFDQSxhQUFhLGlCQUFpQjs7QUFFOUI7QUFDQSxjQUFjLDBCQUEwQixFQUFFO0FBQzFDLGdCQUFnQiwwQkFBMEIsRUFBRTtBQUM1QyxnQkFBZ0IsMEJBQTBCLEVBQUU7QUFDNUMsWUFBWSx1Q0FBdUM7QUFDbkQsWUFBWSwwQkFBMEIsRUFBRTtBQUN4QyxtQkFBbUIsOENBQThDO0FBQ2pFLGNBQWMsMEJBQTBCLEVBQUU7QUFDMUMsaUJBQWlCLDBCQUEwQjtBQUMzQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRSYWN0aXZlLmpzIHYwLjcuMlxuXHRUaHUgQXByIDAyIDIwMTUgMTM6NTM6NTYgR01ULTA0MDAgKEVEVCkgLSBjb21taXQgOGJhZTQ2ODlkYjFiYjU0Y2UwODA0Njk3YjY2YzY1ODYzOWE1M2U5M1xuXG5cdGh0dHA6Ly9yYWN0aXZlanMub3JnXG5cdGh0dHA6Ly90d2l0dGVyLmNvbS9SYWN0aXZlSlNcblxuXHRSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIGdsb2JhbC5SYWN0aXZlID0gZmFjdG9yeSgpXG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBURU1QTEFURV9WRVJTSU9OID0gMztcblxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cbiAgXHQvLyByZW5kZXIgcGxhY2VtZW50OlxuICBcdGVsOiB2b2lkIDAsXG4gIFx0YXBwZW5kOiBmYWxzZSxcblxuICBcdC8vIHRlbXBsYXRlOlxuICBcdHRlbXBsYXRlOiB7IHY6IFRFTVBMQVRFX1ZFUlNJT04sIHQ6IFtdIH0sXG5cbiAgXHQvLyBwYXJzZTogICAgIC8vIFRPRE8gc3RhdGljIGRlbGltaXRlcnM/XG4gIFx0cHJlc2VydmVXaGl0ZXNwYWNlOiBmYWxzZSxcbiAgXHRzYW5pdGl6ZTogZmFsc2UsXG4gIFx0c3RyaXBDb21tZW50czogdHJ1ZSxcbiAgXHRkZWxpbWl0ZXJzOiBbXCJ7e1wiLCBcIn19XCJdLFxuICBcdHRyaXBsZURlbGltaXRlcnM6IFtcInt7e1wiLCBcIn19fVwiXSxcbiAgXHRpbnRlcnBvbGF0ZTogZmFsc2UsXG5cbiAgXHQvLyBkYXRhICYgYmluZGluZzpcbiAgXHRkYXRhOiB7fSxcbiAgXHRjb21wdXRlZDoge30sXG4gIFx0bWFnaWM6IGZhbHNlLFxuICBcdG1vZGlmeUFycmF5czogdHJ1ZSxcbiAgXHRhZGFwdDogW10sXG4gIFx0aXNvbGF0ZWQ6IGZhbHNlLFxuICBcdHR3b3dheTogdHJ1ZSxcbiAgXHRsYXp5OiBmYWxzZSxcblxuICBcdC8vIHRyYW5zaXRpb25zOlxuICBcdG5vSW50cm86IGZhbHNlLFxuICBcdHRyYW5zaXRpb25zRW5hYmxlZDogdHJ1ZSxcbiAgXHRjb21wbGV0ZTogdm9pZCAwLFxuXG4gIFx0Ly8gY3NzOlxuICBcdGNzczogbnVsbCxcbiAgXHRub0Nzc1RyYW5zZm9ybTogZmFsc2VcbiAgfTtcblxuICB2YXIgY29uZmlnX2RlZmF1bHRzID0gZGVmYXVsdE9wdGlvbnM7XG5cbiAgLy8gVGhlc2UgYXJlIGEgc3Vic2V0IG9mIHRoZSBlYXNpbmcgZXF1YXRpb25zIGZvdW5kIGF0XG4gIC8vIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZGFucm8vZWFzaW5nLWpzIC0gbGljZW5zZSBpbmZvXG4gIC8vIGZvbGxvd3M6XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gZWFzaW5nLmpzIHYwLjUuNFxuICAvLyBHZW5lcmljIHNldCBvZiBlYXNpbmcgZnVuY3Rpb25zIHdpdGggQU1EIHN1cHBvcnRcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RhbnJvL2Vhc2luZy1qc1xuICAvLyBUaGlzIGNvZGUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAgLy8gaHR0cDovL2RhbnJvLm1pdC1saWNlbnNlLm9yZy9cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQWxsIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb20gVGhvbWFzIEZ1Y2hzICYgSmVyZW15IEthaG5cbiAgLy8gRWFzaW5nIEVxdWF0aW9ucyAoYykgMjAwMyBSb2JlcnQgUGVubmVyLCBCU0QgbGljZW5zZVxuICAvLyBodHRwczovL3Jhdy5naXRodWIuY29tL2RhbnJvL2Vhc2luZy1qcy9tYXN0ZXIvTElDRU5TRVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEluIHRoYXQgbGlicmFyeSwgdGhlIGZ1bmN0aW9ucyBuYW1lZCBlYXNlSW4sIGVhc2VPdXQsIGFuZFxuICAvLyBlYXNlSW5PdXQgYmVsb3cgYXJlIG5hbWVkIGVhc2VJbkN1YmljLCBlYXNlT3V0Q3ViaWMsIGFuZFxuICAvLyAoeW91IGd1ZXNzZWQgaXQpIGVhc2VJbk91dEN1YmljLlxuICAvL1xuICAvLyBZb3UgY2FuIGFkZCBhZGRpdGlvbmFsIGVhc2luZyBmdW5jdGlvbnMgdG8gdGhpcyBsaXN0LCBhbmQgdGhleVxuICAvLyB3aWxsIGJlIGdsb2JhbGx5IGF2YWlsYWJsZS5cblxuICB2YXIgc3RhdGljX2Vhc2luZyA9IHtcbiAgXHRsaW5lYXI6IGZ1bmN0aW9uIChwb3MpIHtcbiAgXHRcdHJldHVybiBwb3M7XG4gIFx0fSxcbiAgXHRlYXNlSW46IGZ1bmN0aW9uIChwb3MpIHtcbiAgXHRcdHJldHVybiBNYXRoLnBvdyhwb3MsIDMpO1xuICBcdH0sXG4gIFx0ZWFzZU91dDogZnVuY3Rpb24gKHBvcykge1xuICBcdFx0cmV0dXJuIE1hdGgucG93KHBvcyAtIDEsIDMpICsgMTtcbiAgXHR9LFxuICBcdGVhc2VJbk91dDogZnVuY3Rpb24gKHBvcykge1xuICBcdFx0aWYgKChwb3MgLz0gMC41KSA8IDEpIHtcbiAgXHRcdFx0cmV0dXJuIDAuNSAqIE1hdGgucG93KHBvcywgMyk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gMC41ICogKE1hdGgucG93KHBvcyAtIDIsIDMpICsgMik7XG4gIFx0fVxuICB9O1xuXG4gIC8qZ2xvYmFsIGNvbnNvbGUsIG5hdmlnYXRvciAqL1xuICB2YXIgaXNDbGllbnQsIGlzSnNkb20sIGhhc0NvbnNvbGUsIGVudmlyb25tZW50X19tYWdpYywgbmFtZXNwYWNlcywgc3ZnLCB2ZW5kb3JzO1xuXG4gIGlzQ2xpZW50ID0gdHlwZW9mIGRvY3VtZW50ID09PSBcIm9iamVjdFwiO1xuXG4gIGlzSnNkb20gPSB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIC9qc0RvbS8udGVzdChuYXZpZ2F0b3IuYXBwTmFtZSk7XG5cbiAgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgY29uc29sZS53YXJuLmFwcGx5ID09PSBcImZ1bmN0aW9uXCI7XG5cbiAgdHJ5IHtcbiAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwidGVzdFwiLCB7IHZhbHVlOiAwIH0pO1xuICBcdGVudmlyb25tZW50X19tYWdpYyA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgXHRlbnZpcm9ubWVudF9fbWFnaWMgPSBmYWxzZTtcbiAgfVxuXG4gIG5hbWVzcGFjZXMgPSB7XG4gIFx0aHRtbDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsXG4gIFx0bWF0aG1sOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIixcbiAgXHRzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgXHR4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gIFx0eG1sOiBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICBcdHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbiAgfTtcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIFx0c3ZnID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gIFx0c3ZnID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcImh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmVcIiwgXCIxLjFcIik7XG4gIH1cblxuICB2ZW5kb3JzID0gW1wib1wiLCBcIm1zXCIsIFwibW96XCIsIFwid2Via2l0XCJdO1xuXG4gIHZhciBjcmVhdGVFbGVtZW50LCBtYXRjaGVzLCBkb21fX2RpdiwgbWV0aG9kTmFtZXMsIHVucHJlZml4ZWQsIHByZWZpeGVkLCBkb21fX2ksIGosIG1ha2VGdW5jdGlvbjtcblxuICAvLyBUZXN0IGZvciBTVkcgc3VwcG9ydFxuICBpZiAoIXN2Zykge1xuICBcdGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgbnMpIHtcbiAgXHRcdGlmIChucyAmJiBucyAhPT0gbmFtZXNwYWNlcy5odG1sKSB7XG4gIFx0XHRcdHRocm93IFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbmFtZXNwYWNlcyBvdGhlciB0aGFuIGh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwuIFRoZSBtb3N0IGxpa2VseSBjYXVzZSBvZiB0aGlzIGVycm9yIGlzIHRoYXQgeW91J3JlIHRyeWluZyB0byByZW5kZXIgU1ZHIGluIGFuIG9sZGVyIGJyb3dzZXIuIFNlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9zdmctYW5kLW9sZGVyLWJyb3dzZXJzIGZvciBtb3JlIGluZm9ybWF0aW9uXCI7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICBcdH07XG4gIH0gZWxzZSB7XG4gIFx0Y3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBucykge1xuICBcdFx0aWYgKCFucyB8fCBucyA9PT0gbmFtZXNwYWNlcy5odG1sKSB7XG4gIFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0eXBlKTtcbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudChpbnB1dCkge1xuICBcdHZhciBvdXRwdXQ7XG5cbiAgXHRpZiAoIWlucHV0IHx8IHR5cGVvZiBpbnB1dCA9PT0gXCJib29sZWFuXCIpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhZG9jdW1lbnQgfHwgIWlucHV0KSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBXZSBhbHJlYWR5IGhhdmUgYSBET00gbm9kZSAtIG5vIHdvcmsgdG8gZG8uIChEdWNrIHR5cGluZyBhbGVydCEpXG4gIFx0aWYgKGlucHV0Lm5vZGVUeXBlKSB7XG4gIFx0XHRyZXR1cm4gaW5wdXQ7XG4gIFx0fVxuXG4gIFx0Ly8gR2V0IG5vZGUgZnJvbSBzdHJpbmdcbiAgXHRpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHQvLyB0cnkgSUQgZmlyc3RcbiAgXHRcdG91dHB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlucHV0KTtcblxuICBcdFx0Ly8gdGhlbiBhcyBzZWxlY3RvciwgaWYgcG9zc2libGVcbiAgXHRcdGlmICghb3V0cHV0ICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IpIHtcbiAgXHRcdFx0b3V0cHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihpbnB1dCk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGRpZCBpdCB3b3JrP1xuICBcdFx0aWYgKG91dHB1dCAmJiBvdXRwdXQubm9kZVR5cGUpIHtcbiAgXHRcdFx0cmV0dXJuIG91dHB1dDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBJZiB3ZSd2ZSBiZWVuIGdpdmVuIGEgY29sbGVjdGlvbiAoalF1ZXJ5LCBaZXB0byBldGMpLCBleHRyYWN0IHRoZSBmaXJzdCBpdGVtXG4gIFx0aWYgKGlucHV0WzBdICYmIGlucHV0WzBdLm5vZGVUeXBlKSB7XG4gIFx0XHRyZXR1cm4gaW5wdXRbMF07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIWlzQ2xpZW50KSB7XG4gIFx0bWF0Y2hlcyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gIFx0ZG9tX19kaXYgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBcdG1ldGhvZE5hbWVzID0gW1wibWF0Y2hlc1wiLCBcIm1hdGNoZXNTZWxlY3RvclwiXTtcblxuICBcdG1ha2VGdW5jdGlvbiA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKG5vZGUsIHNlbGVjdG9yKSB7XG4gIFx0XHRcdHJldHVybiBub2RlW21ldGhvZE5hbWVdKHNlbGVjdG9yKTtcbiAgXHRcdH07XG4gIFx0fTtcblxuICBcdGRvbV9faSA9IG1ldGhvZE5hbWVzLmxlbmd0aDtcblxuICBcdHdoaWxlIChkb21fX2ktLSAmJiAhbWF0Y2hlcykge1xuICBcdFx0dW5wcmVmaXhlZCA9IG1ldGhvZE5hbWVzW2RvbV9faV07XG5cbiAgXHRcdGlmIChkb21fX2Rpdlt1bnByZWZpeGVkXSkge1xuICBcdFx0XHRtYXRjaGVzID0gbWFrZUZ1bmN0aW9uKHVucHJlZml4ZWQpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0aiA9IHZlbmRvcnMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoai0tKSB7XG4gIFx0XHRcdFx0cHJlZml4ZWQgPSB2ZW5kb3JzW2RvbV9faV0gKyB1bnByZWZpeGVkLnN1YnN0cigwLCAxKS50b1VwcGVyQ2FzZSgpICsgdW5wcmVmaXhlZC5zdWJzdHJpbmcoMSk7XG5cbiAgXHRcdFx0XHRpZiAoZG9tX19kaXZbcHJlZml4ZWRdKSB7XG4gIFx0XHRcdFx0XHRtYXRjaGVzID0gbWFrZUZ1bmN0aW9uKHByZWZpeGVkKTtcbiAgXHRcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIElFOC4uLlxuICBcdGlmICghbWF0Y2hlcykge1xuICBcdFx0bWF0Y2hlcyA9IGZ1bmN0aW9uIChub2RlLCBzZWxlY3Rvcikge1xuICBcdFx0XHR2YXIgbm9kZXMsIHBhcmVudE5vZGUsIGk7XG5cbiAgXHRcdFx0cGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblxuICBcdFx0XHRpZiAoIXBhcmVudE5vZGUpIHtcbiAgXHRcdFx0XHQvLyBlbXB0eSBkdW1teSA8ZGl2PlxuICBcdFx0XHRcdGRvbV9fZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cbiAgXHRcdFx0XHRwYXJlbnROb2RlID0gZG9tX19kaXY7XG4gIFx0XHRcdFx0bm9kZSA9IG5vZGUuY2xvbmVOb2RlKCk7XG5cbiAgXHRcdFx0XHRkb21fX2Rpdi5hcHBlbmRDaGlsZChub2RlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdG5vZGVzID0gcGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICBcdFx0XHRpID0gbm9kZXMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0aWYgKG5vZGVzW2ldID09PSBub2RlKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9O1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRldGFjaE5vZGUobm9kZSkge1xuICBcdGlmIChub2RlICYmIHR5cGVvZiBub2RlLnBhcmVudE5vZGUgIT09IFwidW5rbm93blwiICYmIG5vZGUucGFyZW50Tm9kZSkge1xuICBcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICBcdH1cblxuICBcdHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2FmZVRvU3RyaW5nVmFsdWUodmFsdWUpIHtcbiAgXHRyZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCAhdmFsdWUudG9TdHJpbmcgPyBcIlwiIDogdmFsdWU7XG4gIH1cblxuICB2YXIgbGVnYWN5ID0gbnVsbDtcblxuICB2YXIgY3JlYXRlLCBkZWZpbmVQcm9wZXJ0eSwgZGVmaW5lUHJvcGVydGllcztcblxuICB0cnkge1xuICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJ0ZXN0XCIsIHsgdmFsdWU6IDAgfSk7XG5cbiAgXHRpZiAoaXNDbGllbnQpIHtcbiAgXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBcInRlc3RcIiwgeyB2YWx1ZTogMCB9KTtcbiAgXHR9XG5cbiAgXHRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIFx0Ly8gT2JqZWN0LmRlZmluZVByb3BlcnR5IGRvZXNuJ3QgZXhpc3QsIG9yIHdlJ3JlIGluIElFOCB3aGVyZSB5b3UgY2FuXG4gIFx0Ly8gb25seSB1c2UgaXQgd2l0aCBET00gb2JqZWN0cyAod2hhdCB3ZXJlIHlvdSBzbW9raW5nLCBNU0ZUPylcbiAgXHRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIGRlc2MpIHtcbiAgXHRcdG9ialtwcm9wXSA9IGRlc2MudmFsdWU7XG4gIFx0fTtcbiAgfVxuXG4gIHRyeSB7XG4gIFx0dHJ5IHtcbiAgXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHt9LCB7IHRlc3Q6IHsgdmFsdWU6IDAgfSB9KTtcbiAgXHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdC8vIFRPRE8gaG93IGRvIHdlIGFjY291bnQgZm9yIHRoaXM/IG5vTWFnaWMgPSB0cnVlO1xuICBcdFx0dGhyb3cgZXJyO1xuICBcdH1cblxuICBcdGlmIChpc0NsaWVudCkge1xuICBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY3JlYXRlRWxlbWVudChcImRpdlwiKSwgeyB0ZXN0OiB7IHZhbHVlOiAwIH0gfSk7XG4gIFx0fVxuXG4gIFx0ZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgXHRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaiwgcHJvcHMpIHtcbiAgXHRcdHZhciBwcm9wO1xuXG4gIFx0XHRmb3IgKHByb3AgaW4gcHJvcHMpIHtcbiAgXHRcdFx0aWYgKHByb3BzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gIFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBwcm9wc1twcm9wXSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgdHJ5IHtcbiAgXHRPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIFx0Y3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIFx0Ly8gc2lnaFxuICBcdGNyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgRiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvLCBwcm9wcykge1xuICBcdFx0XHR2YXIgb2JqO1xuXG4gIFx0XHRcdGlmIChwcm90byA9PT0gbnVsbCkge1xuICBcdFx0XHRcdHJldHVybiB7fTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdEYucHJvdG90eXBlID0gcHJvdG87XG4gIFx0XHRcdG9iaiA9IG5ldyBGKCk7XG5cbiAgXHRcdFx0aWYgKHByb3BzKSB7XG4gIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqLCBwcm9wcyk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gb2JqO1xuICBcdFx0fTtcbiAgXHR9KSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXRpbHNfb2JqZWN0X19leHRlbmQodGFyZ2V0KSB7XG4gIFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRzb3VyY2VzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHR9XG5cbiAgXHR2YXIgcHJvcCwgc291cmNlO1xuXG4gIFx0d2hpbGUgKHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKSkge1xuICBcdFx0Zm9yIChwcm9wIGluIHNvdXJjZSkge1xuICBcdFx0XHRpZiAoaGFzT3duLmNhbGwoc291cmNlLCBwcm9wKSkge1xuICBcdFx0XHRcdHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxsR2Fwcyh0YXJnZXQpIHtcbiAgXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdHNvdXJjZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICBcdFx0Zm9yICh2YXIga2V5IGluIHMpIHtcbiAgXHRcdFx0aWYgKHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gIFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBzW2tleV07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyB0aGFua3MsIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2luc3RhbmNlb2YtY29uc2lkZXJlZC1oYXJtZnVsLW9yLWhvdy10by13cml0ZS1hLXJvYnVzdC1pc2FycmF5L1xuICB2YXIgaXNfX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgIGFycmF5TGlrZVBhdHRlcm4gPSAvXlxcW29iamVjdCAoPzpBcnJheXxGaWxlTGlzdClcXF0kLztcbiAgZnVuY3Rpb24gaXNBcnJheSh0aGluZykge1xuICBcdHJldHVybiBpc19fdG9TdHJpbmcuY2FsbCh0aGluZykgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKG9iaikge1xuICBcdHJldHVybiBhcnJheUxpa2VQYXR0ZXJuLnRlc3QoaXNfX3RvU3RyaW5nLmNhbGwob2JqKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgXHRpZiAoYSA9PT0gbnVsbCAmJiBiID09PSBudWxsKSB7XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIGEgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGIgPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYSA9PT0gYjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzX19pc051bWVyaWModGhpbmcpIHtcbiAgXHRyZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQodGhpbmcpKSAmJiBpc0Zpbml0ZSh0aGluZyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc09iamVjdCh0aGluZykge1xuICBcdHJldHVybiB0aGluZyAmJiBpc19fdG9TdHJpbmcuY2FsbCh0aGluZykgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gIH1cblxuICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIC8qIGdsb2JhbCBjb25zb2xlICovXG4gIHZhciBhbHJlYWR5V2FybmVkID0ge30sXG4gICAgICBsb2csXG4gICAgICBwcmludFdhcm5pbmcsXG4gICAgICB3ZWxjb21lO1xuXG4gIGlmIChoYXNDb25zb2xlKSB7XG4gIFx0KGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciB3ZWxjb21lSW50cm8gPSBbXCIlY1JhY3RpdmUuanMgJWMwLjcuMiAlY2luIGRlYnVnIG1vZGUsICVjbW9yZS4uLlwiLCBcImNvbG9yOiByZ2IoMTE0LCAxNTcsIDUyKTsgZm9udC13ZWlnaHQ6IG5vcm1hbDtcIiwgXCJjb2xvcjogcmdiKDg1LCA4NSwgODUpOyBmb250LXdlaWdodDogbm9ybWFsO1wiLCBcImNvbG9yOiByZ2IoODUsIDg1LCA4NSk7IGZvbnQtd2VpZ2h0OiBub3JtYWw7XCIsIFwiY29sb3I6IHJnYig4MiwgMTQwLCAyMjQpOyBmb250LXdlaWdodDogbm9ybWFsOyB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcIl07XG4gIFx0XHR2YXIgd2VsY29tZU1lc3NhZ2UgPSBcIllvdSdyZSBydW5uaW5nIFJhY3RpdmUgMC43LjIgaW4gZGVidWcgbW9kZSAtIG1lc3NhZ2VzIHdpbGwgYmUgcHJpbnRlZCB0byB0aGUgY29uc29sZSB0byBoZWxwIHlvdSBmaXggcHJvYmxlbXMgYW5kIG9wdGltaXNlIHlvdXIgYXBwbGljYXRpb24uXFxuXFxuVG8gZGlzYWJsZSBkZWJ1ZyBtb2RlLCBhZGQgdGhpcyBsaW5lIGF0IHRoZSBzdGFydCBvZiB5b3VyIGFwcDpcXG4gIFJhY3RpdmUuREVCVUcgPSBmYWxzZTtcXG5cXG5UbyBkaXNhYmxlIGRlYnVnIG1vZGUgd2hlbiB5b3VyIGFwcCBpcyBtaW5pZmllZCwgYWRkIHRoaXMgc25pcHBldDpcXG4gIFJhY3RpdmUuREVCVUcgPSAvdW5taW5pZmllZC8udGVzdChmdW5jdGlvbigpey8qdW5taW5pZmllZCovfSk7XFxuXFxuR2V0IGhlbHAgYW5kIHN1cHBvcnQ6XFxuICBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnXFxuICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zL3RhZ2dlZC9yYWN0aXZlanNcXG4gIGh0dHA6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIWZvcnVtL3JhY3RpdmUtanNcXG4gIGh0dHA6Ly90d2l0dGVyLmNvbS9yYWN0aXZlanNcXG5cXG5Gb3VuZCBhIGJ1Zz8gUmFpc2UgYW4gaXNzdWU6XFxuICBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzXFxuXFxuXCI7XG5cbiAgXHRcdHdlbGNvbWUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHZhciBoYXNHcm91cCA9ICEhY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgXHRcdFx0Y29uc29sZVtoYXNHcm91cCA/IFwiZ3JvdXBDb2xsYXBzZWRcIiA6IFwibG9nXCJdLmFwcGx5KGNvbnNvbGUsIHdlbGNvbWVJbnRybyk7XG4gIFx0XHRcdGNvbnNvbGUubG9nKHdlbGNvbWVNZXNzYWdlKTtcbiAgXHRcdFx0aWYgKGhhc0dyb3VwKSB7XG4gIFx0XHRcdFx0Y29uc29sZS5ncm91cEVuZCh3ZWxjb21lSW50cm8pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0d2VsY29tZSA9IG5vb3A7XG4gIFx0XHR9O1xuXG4gIFx0XHRwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAobWVzc2FnZSwgYXJncykge1xuICBcdFx0XHR3ZWxjb21lKCk7XG5cbiAgXHRcdFx0Ly8gZXh0cmFjdCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5zdGFuY2UgdGhpcyBtZXNzYWdlIHBlcnRhaW5zIHRvLCBpZiBhcHBsaWNhYmxlXG4gIFx0XHRcdGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRcdFx0dmFyIG9wdGlvbnMgPSBhcmdzLnBvcCgpO1xuICBcdFx0XHRcdHZhciByYWN0aXZlID0gb3B0aW9ucyA/IG9wdGlvbnMucmFjdGl2ZSA6IG51bGw7XG5cbiAgXHRcdFx0XHRpZiAocmFjdGl2ZSkge1xuICBcdFx0XHRcdFx0Ly8gaWYgdGhpcyBpcyBhbiBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCB0aGF0IHdlIGtub3cgdGhlIG5hbWUgb2YsIGFkZFxuICBcdFx0XHRcdFx0Ly8gaXQgdG8gdGhlIG1lc3NhZ2VcbiAgXHRcdFx0XHRcdHZhciBfbmFtZSA9IHVuZGVmaW5lZDtcbiAgXHRcdFx0XHRcdGlmIChyYWN0aXZlLmNvbXBvbmVudCAmJiAoX25hbWUgPSByYWN0aXZlLmNvbXBvbmVudC5uYW1lKSkge1xuICBcdFx0XHRcdFx0XHRtZXNzYWdlID0gXCI8XCIgKyBfbmFtZSArIFwiPiBcIiArIG1lc3NhZ2U7XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdHZhciBub2RlID0gdW5kZWZpbmVkO1xuICBcdFx0XHRcdFx0aWYgKG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgcmFjdGl2ZS5mcmFnbWVudCAmJiByYWN0aXZlLmZyYWdtZW50LnJlbmRlcmVkICYmIHJhY3RpdmUuZmluZChcIipcIikpIHtcbiAgXHRcdFx0XHRcdFx0YXJncy5wdXNoKG5vZGUpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBbXCIlY1JhY3RpdmUuanM6ICVjXCIgKyBtZXNzYWdlLCBcImNvbG9yOiByZ2IoMTE0LCAxNTcsIDUyKTtcIiwgXCJjb2xvcjogcmdiKDg1LCA4NSwgODUpO1wiXS5jb25jYXQoYXJncykpO1xuICBcdFx0fTtcblxuICBcdFx0bG9nID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHRjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICBcdFx0fTtcbiAgXHR9KSgpO1xuICB9IGVsc2Uge1xuICBcdHByaW50V2FybmluZyA9IGxvZyA9IHdlbGNvbWUgPSBub29wO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpIHtcbiAgXHRyZXR1cm4gbWVzc2FnZS5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gYXJncy5zaGlmdCgpO1xuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZmF0YWwobWVzc2FnZSkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0YXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIFx0fVxuXG4gIFx0bWVzc2FnZSA9IGZvcm1hdChtZXNzYWdlLCBhcmdzKTtcbiAgXHR0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cblxuICBmdW5jdGlvbiBsb2dJZkRlYnVnKCkge1xuICBcdGlmIChfUmFjdGl2ZS5ERUJVRykge1xuICBcdFx0bG9nLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XG4gIFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHR9XG5cbiAgXHRtZXNzYWdlID0gZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpO1xuICBcdHByaW50V2FybmluZyhtZXNzYWdlLCBhcmdzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlKG1lc3NhZ2UpIHtcbiAgXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdG1lc3NhZ2UgPSBmb3JtYXQobWVzc2FnZSwgYXJncyk7XG5cbiAgXHRpZiAoYWxyZWFkeVdhcm5lZFttZXNzYWdlXSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGFscmVhZHlXYXJuZWRbbWVzc2FnZV0gPSB0cnVlO1xuICBcdHByaW50V2FybmluZyhtZXNzYWdlLCBhcmdzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm5JZkRlYnVnKCkge1xuICBcdGlmIChfUmFjdGl2ZS5ERUJVRykge1xuICBcdFx0d2Fybi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlSWZEZWJ1ZygpIHtcbiAgXHRpZiAoX1JhY3RpdmUuREVCVUcpIHtcbiAgXHRcdHdhcm5PbmNlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIFx0fVxuICB9XG5cbiAgLy8gRXJyb3IgbWVzc2FnZXMgdGhhdCBhcmUgdXNlZCAob3IgY291bGQgYmUpIGluIG11bHRpcGxlIHBsYWNlc1xuICB2YXIgYmFkQXJndW1lbnRzID0gXCJCYWQgYXJndW1lbnRzXCI7XG4gIHZhciBub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm4gPSBcIkEgZnVuY3Rpb24gd2FzIHNwZWNpZmllZCBmb3IgXFxcIiVzXFxcIiAlcywgYnV0IG5vICVzIHdhcyByZXR1cm5lZFwiO1xuICB2YXIgbWlzc2luZ1BsdWdpbiA9IGZ1bmN0aW9uIChuYW1lLCB0eXBlKSB7XG4gICAgcmV0dXJuIFwiTWlzc2luZyBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIFwiICsgdHlwZSArIFwiIHBsdWdpbi4gWW91IG1heSBuZWVkIHRvIGRvd25sb2FkIGEgcGx1Z2luIHZpYSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9wbHVnaW5zI1wiICsgdHlwZSArIFwic1wiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZpbmRJblZpZXdIaWVyYXJjaHkocmVnaXN0cnlOYW1lLCByYWN0aXZlLCBuYW1lKSB7XG4gIFx0dmFyIGluc3RhbmNlID0gZmluZEluc3RhbmNlKHJlZ2lzdHJ5TmFtZSwgcmFjdGl2ZSwgbmFtZSk7XG4gIFx0cmV0dXJuIGluc3RhbmNlID8gaW5zdGFuY2VbcmVnaXN0cnlOYW1lXVtuYW1lXSA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSW5zdGFuY2UocmVnaXN0cnlOYW1lLCByYWN0aXZlLCBuYW1lKSB7XG4gIFx0d2hpbGUgKHJhY3RpdmUpIHtcbiAgXHRcdGlmIChuYW1lIGluIHJhY3RpdmVbcmVnaXN0cnlOYW1lXSkge1xuICBcdFx0XHRyZXR1cm4gcmFjdGl2ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHJhY3RpdmUuaXNvbGF0ZWQpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJhY3RpdmUgPSByYWN0aXZlLnBhcmVudDtcbiAgXHR9XG4gIH1cblxuICB2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHJhY3RpdmUsIHR5cGUpIHtcbiAgXHRpZiAoZnJvbSA9PT0gdG8pIHtcbiAgXHRcdHJldHVybiBzbmFwKHRvKTtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZSkge1xuXG4gIFx0XHR2YXIgaW50ZXJwb2wgPSBmaW5kSW5WaWV3SGllcmFyY2h5KFwiaW50ZXJwb2xhdG9yc1wiLCByYWN0aXZlLCB0eXBlKTtcbiAgXHRcdGlmIChpbnRlcnBvbCkge1xuICBcdFx0XHRyZXR1cm4gaW50ZXJwb2woZnJvbSwgdG8pIHx8IHNuYXAodG8pO1xuICBcdFx0fVxuXG4gIFx0XHRmYXRhbChtaXNzaW5nUGx1Z2luKHR5cGUsIFwiaW50ZXJwb2xhdG9yXCIpKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3RhdGljX2ludGVycG9sYXRvcnMubnVtYmVyKGZyb20sIHRvKSB8fCBzdGF0aWNfaW50ZXJwb2xhdG9ycy5hcnJheShmcm9tLCB0bykgfHwgc3RhdGljX2ludGVycG9sYXRvcnMub2JqZWN0KGZyb20sIHRvKSB8fCBzbmFwKHRvKTtcbiAgfTtcblxuICB2YXIgc2hhcmVkX2ludGVycG9sYXRlID0gaW50ZXJwb2xhdGU7XG5cbiAgZnVuY3Rpb24gc25hcCh0bykge1xuICBcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdG87XG4gIFx0fTtcbiAgfVxuXG4gIHZhciBpbnRlcnBvbGF0b3JzID0ge1xuICBcdG51bWJlcjogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIFx0XHR2YXIgZGVsdGE7XG5cbiAgXHRcdGlmICghaXNfX2lzTnVtZXJpYyhmcm9tKSB8fCAhaXNfX2lzTnVtZXJpYyh0bykpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdGZyb20gPSArZnJvbTtcbiAgXHRcdHRvID0gK3RvO1xuXG4gIFx0XHRkZWx0YSA9IHRvIC0gZnJvbTtcblxuICBcdFx0aWYgKCFkZWx0YSkge1xuICBcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdHJldHVybiBmcm9tO1xuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0cmV0dXJuIGZyb20gKyB0ICogZGVsdGE7XG4gIFx0XHR9O1xuICBcdH0sXG5cbiAgXHRhcnJheTogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIFx0XHR2YXIgaW50ZXJtZWRpYXRlLCBpbnRlcnBvbGF0b3JzLCBsZW4sIGk7XG5cbiAgXHRcdGlmICghaXNBcnJheShmcm9tKSB8fCAhaXNBcnJheSh0bykpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdGludGVybWVkaWF0ZSA9IFtdO1xuICBcdFx0aW50ZXJwb2xhdG9ycyA9IFtdO1xuXG4gIFx0XHRpID0gbGVuID0gTWF0aC5taW4oZnJvbS5sZW5ndGgsIHRvLmxlbmd0aCk7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGludGVycG9sYXRvcnNbaV0gPSBzaGFyZWRfaW50ZXJwb2xhdGUoZnJvbVtpXSwgdG9baV0pO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzdXJwbHVzIHZhbHVlcyAtIGRvbid0IGludGVycG9sYXRlLCBidXQgZG9uJ3QgZXhjbHVkZSB0aGVtIGVpdGhlclxuICBcdFx0Zm9yIChpID0gbGVuOyBpIDwgZnJvbS5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0XHRpbnRlcm1lZGlhdGVbaV0gPSBmcm9tW2ldO1xuICBcdFx0fVxuXG4gIFx0XHRmb3IgKGkgPSBsZW47IGkgPCB0by5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0XHRpbnRlcm1lZGlhdGVbaV0gPSB0b1tpXTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdHZhciBpID0gbGVuO1xuXG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRpbnRlcm1lZGlhdGVbaV0gPSBpbnRlcnBvbGF0b3JzW2ldKHQpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIGludGVybWVkaWF0ZTtcbiAgXHRcdH07XG4gIFx0fSxcblxuICBcdG9iamVjdDogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIFx0XHR2YXIgcHJvcGVydGllcywgbGVuLCBpbnRlcnBvbGF0b3JzLCBpbnRlcm1lZGlhdGUsIHByb3A7XG5cbiAgXHRcdGlmICghaXNPYmplY3QoZnJvbSkgfHwgIWlzT2JqZWN0KHRvKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cHJvcGVydGllcyA9IFtdO1xuICBcdFx0aW50ZXJtZWRpYXRlID0ge307XG4gIFx0XHRpbnRlcnBvbGF0b3JzID0ge307XG5cbiAgXHRcdGZvciAocHJvcCBpbiBmcm9tKSB7XG4gIFx0XHRcdGlmIChoYXNPd24uY2FsbChmcm9tLCBwcm9wKSkge1xuICBcdFx0XHRcdGlmIChoYXNPd24uY2FsbCh0bywgcHJvcCkpIHtcbiAgXHRcdFx0XHRcdHByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgXHRcdFx0XHRcdGludGVycG9sYXRvcnNbcHJvcF0gPSBzaGFyZWRfaW50ZXJwb2xhdGUoZnJvbVtwcm9wXSwgdG9bcHJvcF0pO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbcHJvcF0gPSBmcm9tW3Byb3BdO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRmb3IgKHByb3AgaW4gdG8pIHtcbiAgXHRcdFx0aWYgKGhhc093bi5jYWxsKHRvLCBwcm9wKSAmJiAhaGFzT3duLmNhbGwoZnJvbSwgcHJvcCkpIHtcbiAgXHRcdFx0XHRpbnRlcm1lZGlhdGVbcHJvcF0gPSB0b1twcm9wXTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRsZW4gPSBwcm9wZXJ0aWVzLmxlbmd0aDtcblxuICBcdFx0cmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdHZhciBpID0gbGVuLFxuICBcdFx0XHQgICAgcHJvcDtcblxuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0cHJvcCA9IHByb3BlcnRpZXNbaV07XG5cbiAgXHRcdFx0XHRpbnRlcm1lZGlhdGVbcHJvcF0gPSBpbnRlcnBvbGF0b3JzW3Byb3BdKHQpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIGludGVybWVkaWF0ZTtcbiAgXHRcdH07XG4gIFx0fVxuICB9O1xuXG4gIHZhciBzdGF0aWNfaW50ZXJwb2xhdG9ycyA9IGludGVycG9sYXRvcnM7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIGtleXBhdGggc3VjaCBhcyAnZm9vLmJhci5iYXonLCBhbmQgcmV0dXJuc1xuICAvLyBhbGwgdGhlIHZhcmlhbnRzIG9mIHRoYXQga2V5cGF0aCB0aGF0IGluY2x1ZGUgYSB3aWxkY2FyZCBpbiBwbGFjZVxuICAvLyBvZiBhIGtleSwgc3VjaCBhcyAnZm9vLmJhci4qJywgJ2Zvby4qLmJheicsICdmb28uKi4qJyBhbmQgc28gb24uXG4gIC8vIFRoZXNlIGFyZSB0aGVuIGNoZWNrZWQgYWdhaW5zdCB0aGUgZGVwZW5kYW50cyBtYXAgKHJhY3RpdmUudmlld21vZGVsLmRlcHNNYXApXG4gIC8vIHRvIHNlZSBpZiBhbnkgcGF0dGVybiBvYnNlcnZlcnMgYXJlIGRvd25zdHJlYW0gb2Ygb25lIG9yIG1vcmUgb2ZcbiAgLy8gdGhlc2Ugd2lsZGNhcmQga2V5cGF0aHMgKGUuZy4gJ2Zvby5iYXIuKi5zdGF0dXMnKVxuICB2YXIgdXRpbHNfZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzID0gZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzO1xuXG4gIHZhciBzdGFyTWFwcyA9IHt9O1xuICBmdW5jdGlvbiBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMoa2V5cGF0aCkge1xuICBcdHZhciBrZXlzLCBzdGFyTWFwLCBtYXBwZXIsIGksIHJlc3VsdCwgd2lsZGNhcmRLZXlwYXRoO1xuXG4gIFx0a2V5cyA9IGtleXBhdGguc3BsaXQoXCIuXCIpO1xuICBcdGlmICghKHN0YXJNYXAgPSBzdGFyTWFwc1trZXlzLmxlbmd0aF0pKSB7XG4gIFx0XHRzdGFyTWFwID0gZ2V0U3Rhck1hcChrZXlzLmxlbmd0aCk7XG4gIFx0fVxuXG4gIFx0cmVzdWx0ID0gW107XG5cbiAgXHRtYXBwZXIgPSBmdW5jdGlvbiAoc3RhciwgaSkge1xuICBcdFx0cmV0dXJuIHN0YXIgPyBcIipcIiA6IGtleXNbaV07XG4gIFx0fTtcblxuICBcdGkgPSBzdGFyTWFwLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHR3aWxkY2FyZEtleXBhdGggPSBzdGFyTWFwW2ldLm1hcChtYXBwZXIpLmpvaW4oXCIuXCIpO1xuXG4gIFx0XHRpZiAoIXJlc3VsdC5oYXNPd25Qcm9wZXJ0eSh3aWxkY2FyZEtleXBhdGgpKSB7XG4gIFx0XHRcdHJlc3VsdC5wdXNoKHdpbGRjYXJkS2V5cGF0aCk7XG4gIFx0XHRcdHJlc3VsdFt3aWxkY2FyZEtleXBhdGhdID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFsbCB0aGUgcG9zc2libGUgdHJ1ZS9mYWxzZSBjb21iaW5hdGlvbnMgZm9yXG4gIC8vIGEgZ2l2ZW4gbnVtYmVyIC0gZS5nLiBmb3IgdHdvLCB0aGUgcG9zc2libGUgY29tYmluYXRpb25zIGFyZVxuICAvLyBbIHRydWUsIHRydWUgXSwgWyB0cnVlLCBmYWxzZSBdLCBbIGZhbHNlLCB0cnVlIF0sIFsgZmFsc2UsIGZhbHNlIF0uXG4gIC8vIEl0IGRvZXMgc28gYnkgZ2V0dGluZyBhbGwgdGhlIGJpbmFyeSB2YWx1ZXMgYmV0d2VlbiAwIGFuZCBlLmcuIDExXG4gIGZ1bmN0aW9uIGdldFN0YXJNYXAobnVtKSB7XG4gIFx0dmFyIG9uZXMgPSBcIlwiLFxuICBcdCAgICBtYXgsXG4gIFx0ICAgIGJpbmFyeSxcbiAgXHQgICAgc3Rhck1hcCxcbiAgXHQgICAgbWFwcGVyLFxuICBcdCAgICBpLFxuICBcdCAgICBqLFxuICBcdCAgICBsLFxuICBcdCAgICBtYXA7XG5cbiAgXHRpZiAoIXN0YXJNYXBzW251bV0pIHtcbiAgXHRcdHN0YXJNYXAgPSBbXTtcblxuICBcdFx0d2hpbGUgKG9uZXMubGVuZ3RoIDwgbnVtKSB7XG4gIFx0XHRcdG9uZXMgKz0gMTtcbiAgXHRcdH1cblxuICBcdFx0bWF4ID0gcGFyc2VJbnQob25lcywgMik7XG5cbiAgXHRcdG1hcHBlciA9IGZ1bmN0aW9uIChkaWdpdCkge1xuICBcdFx0XHRyZXR1cm4gZGlnaXQgPT09IFwiMVwiO1xuICBcdFx0fTtcblxuICBcdFx0Zm9yIChpID0gMDsgaSA8PSBtYXg7IGkgKz0gMSkge1xuICBcdFx0XHRiaW5hcnkgPSBpLnRvU3RyaW5nKDIpO1xuICBcdFx0XHR3aGlsZSAoYmluYXJ5Lmxlbmd0aCA8IG51bSkge1xuICBcdFx0XHRcdGJpbmFyeSA9IFwiMFwiICsgYmluYXJ5O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0bWFwID0gW107XG4gIFx0XHRcdGwgPSBiaW5hcnkubGVuZ3RoO1xuICBcdFx0XHRmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gIFx0XHRcdFx0bWFwLnB1c2gobWFwcGVyKGJpbmFyeVtqXSkpO1xuICBcdFx0XHR9XG4gIFx0XHRcdHN0YXJNYXBbaV0gPSBtYXA7XG4gIFx0XHR9XG5cbiAgXHRcdHN0YXJNYXBzW251bV0gPSBzdGFyTWFwO1xuICBcdH1cblxuICBcdHJldHVybiBzdGFyTWFwc1tudW1dO1xuICB9XG5cbiAgdmFyIHJlZlBhdHRlcm4gPSAvXFxbXFxzKihcXCp8WzAtOV18WzEtOV1bMC05XSspXFxzKlxcXS9nO1xuICB2YXIgcGF0dGVyblBhdHRlcm4gPSAvXFwqLztcbiAgdmFyIGtleXBhdGhDYWNoZSA9IHt9O1xuXG4gIHZhciBLZXlwYXRoID0gZnVuY3Rpb24gKHN0cikge1xuICBcdHZhciBrZXlzID0gc3RyLnNwbGl0KFwiLlwiKTtcblxuICBcdHRoaXMuc3RyID0gc3RyO1xuXG4gIFx0aWYgKHN0clswXSA9PT0gXCJAXCIpIHtcbiAgXHRcdHRoaXMuaXNTcGVjaWFsID0gdHJ1ZTtcbiAgXHRcdHRoaXMudmFsdWUgPSBkZWNvZGVLZXlwYXRoKHN0cik7XG4gIFx0fVxuXG4gIFx0dGhpcy5maXJzdEtleSA9IGtleXNbMF07XG4gIFx0dGhpcy5sYXN0S2V5ID0ga2V5cy5wb3AoKTtcblxuICBcdHRoaXMuaXNQYXR0ZXJuID0gcGF0dGVyblBhdHRlcm4udGVzdChzdHIpO1xuXG4gIFx0dGhpcy5wYXJlbnQgPSBzdHIgPT09IFwiXCIgPyBudWxsIDogZ2V0S2V5cGF0aChrZXlzLmpvaW4oXCIuXCIpKTtcbiAgXHR0aGlzLmlzUm9vdCA9ICFzdHI7XG4gIH07XG5cbiAgS2V5cGF0aC5wcm90b3R5cGUgPSB7XG4gIFx0ZXF1YWxzT3JTdGFydHNXaXRoOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0cmV0dXJuIGtleXBhdGggPT09IHRoaXMgfHwgdGhpcy5zdGFydHNXaXRoKGtleXBhdGgpO1xuICBcdH0sXG5cbiAgXHRqb2luOiBmdW5jdGlvbiAoc3RyKSB7XG4gIFx0XHRyZXR1cm4gZ2V0S2V5cGF0aCh0aGlzLmlzUm9vdCA/IFN0cmluZyhzdHIpIDogdGhpcy5zdHIgKyBcIi5cIiArIHN0cik7XG4gIFx0fSxcblxuICBcdHJlcGxhY2U6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHRpZiAodGhpcyA9PT0gb2xkS2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gbmV3S2V5cGF0aDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuc3RhcnRzV2l0aChvbGRLZXlwYXRoKSkge1xuICBcdFx0XHRyZXR1cm4gbmV3S2V5cGF0aCA9PT0gbnVsbCA/IG5ld0tleXBhdGggOiBnZXRLZXlwYXRoKHRoaXMuc3RyLnJlcGxhY2Uob2xkS2V5cGF0aC5zdHIgKyBcIi5cIiwgbmV3S2V5cGF0aC5zdHIgKyBcIi5cIikpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRzdGFydHNXaXRoOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0aWYgKCFrZXlwYXRoKSB7XG4gIFx0XHRcdC8vIFRPRE8gdW5kZXIgd2hhdCBjaXJjdW1zdGFuY2VzIGRvZXMgdGhpcyBoYXBwZW4/XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGtleXBhdGggJiYgdGhpcy5zdHIuc3Vic3RyKDAsIGtleXBhdGguc3RyLmxlbmd0aCArIDEpID09PSBrZXlwYXRoLnN0ciArIFwiLlwiO1xuICBcdH0sXG5cbiAgXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQmFkIGNvZXJjaW9uXCIpO1xuICBcdH0sXG5cbiAgXHR2YWx1ZU9mOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJCYWQgY29lcmNpb25cIik7XG4gIFx0fSxcblxuICBcdHdpbGRjYXJkTWF0Y2hlczogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuX3dpbGRjYXJkTWF0Y2hlcyB8fCAodGhpcy5fd2lsZGNhcmRNYXRjaGVzID0gdXRpbHNfZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzKHRoaXMuc3RyKSk7XG4gIFx0fVxuICB9O1xuICBmdW5jdGlvbiBhc3NpZ25OZXdLZXlwYXRoKHRhcmdldCwgcHJvcGVydHksIG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHR2YXIgZXhpc3RpbmdLZXlwYXRoID0gdGFyZ2V0W3Byb3BlcnR5XTtcblxuICBcdGlmIChleGlzdGluZ0tleXBhdGggJiYgKGV4aXN0aW5nS2V5cGF0aC5lcXVhbHNPclN0YXJ0c1dpdGgobmV3S2V5cGF0aCkgfHwgIWV4aXN0aW5nS2V5cGF0aC5lcXVhbHNPclN0YXJ0c1dpdGgob2xkS2V5cGF0aCkpKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dGFyZ2V0W3Byb3BlcnR5XSA9IGV4aXN0aW5nS2V5cGF0aCA/IGV4aXN0aW5nS2V5cGF0aC5yZXBsYWNlKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIDogbmV3S2V5cGF0aDtcbiAgXHRyZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZUtleXBhdGgoa2V5cGF0aCkge1xuICBcdHZhciB2YWx1ZSA9IGtleXBhdGguc2xpY2UoMik7XG5cbiAgXHRpZiAoa2V5cGF0aFsxXSA9PT0gXCJpXCIpIHtcbiAgXHRcdHJldHVybiBpc19faXNOdW1lcmljKHZhbHVlKSA/ICt2YWx1ZSA6IHZhbHVlO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0S2V5cGF0aChzdHIpIHtcbiAgXHRpZiAoc3RyID09IG51bGwpIHtcbiAgXHRcdHJldHVybiBzdHI7XG4gIFx0fVxuXG4gIFx0Ly8gVE9ETyBpdCAqbWF5KiBiZSB3b3J0aCBoYXZpbmcgdHdvIHZlcnNpb25zIG9mIHRoaXMgZnVuY3Rpb24gLSBvbmUgd2hlcmVcbiAgXHQvLyBrZXlwYXRoQ2FjaGUgaW5oZXJpdHMgZnJvbSBudWxsLCBhbmQgb25lIGZvciBJRTguIERlcGVuZHMgb24gaG93XG4gIFx0Ly8gbXVjaCBvZiBhbiBvdmVyaGVhZCBoYXNPd25Qcm9wZXJ0eSBpcyAtIHByb2JhYmx5IG5lZ2xpZ2libGVcbiAgXHRpZiAoIWtleXBhdGhDYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHIpKSB7XG4gIFx0XHRrZXlwYXRoQ2FjaGVbc3RyXSA9IG5ldyBLZXlwYXRoKHN0cik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGtleXBhdGhDYWNoZVtzdHJdO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWF0Y2hpbmdLZXlwYXRocyhyYWN0aXZlLCBrZXlwYXRoKSB7XG4gIFx0dmFyIGtleXMsIGtleSwgbWF0Y2hpbmdLZXlwYXRocztcblxuICBcdGtleXMgPSBrZXlwYXRoLnN0ci5zcGxpdChcIi5cIik7XG4gIFx0bWF0Y2hpbmdLZXlwYXRocyA9IFtyb290S2V5cGF0aF07XG5cbiAgXHR3aGlsZSAoa2V5ID0ga2V5cy5zaGlmdCgpKSB7XG4gIFx0XHRpZiAoa2V5ID09PSBcIipcIikge1xuICBcdFx0XHQvLyBleHBhbmQgdG8gZmluZCBhbGwgdmFsaWQgY2hpbGQga2V5cGF0aHNcbiAgXHRcdFx0bWF0Y2hpbmdLZXlwYXRocyA9IG1hdGNoaW5nS2V5cGF0aHMucmVkdWNlKGV4cGFuZCwgW10pO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0aWYgKG1hdGNoaW5nS2V5cGF0aHNbMF0gPT09IHJvb3RLZXlwYXRoKSB7XG4gIFx0XHRcdFx0Ly8gZmlyc3Qga2V5XG4gIFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRoc1swXSA9IGdldEtleXBhdGgoa2V5KTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gbWF0Y2hpbmdLZXlwYXRocy5tYXAoY29uY2F0ZW5hdGUoa2V5KSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbWF0Y2hpbmdLZXlwYXRocztcblxuICBcdGZ1bmN0aW9uIGV4cGFuZChtYXRjaGluZ0tleXBhdGhzLCBrZXlwYXRoKSB7XG4gIFx0XHR2YXIgd3JhcHBlciwgdmFsdWUsIGtleXM7XG5cbiAgXHRcdGlmIChrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0XHRrZXlzID0gW10uY29uY2F0KE9iamVjdC5rZXlzKHJhY3RpdmUudmlld21vZGVsLmRhdGEpLCBPYmplY3Qua2V5cyhyYWN0aXZlLnZpZXdtb2RlbC5tYXBwaW5ncyksIE9iamVjdC5rZXlzKHJhY3RpdmUudmlld21vZGVsLmNvbXB1dGF0aW9ucykpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0d3JhcHBlciA9IHJhY3RpdmUudmlld21vZGVsLndyYXBwZWRba2V5cGF0aC5zdHJdO1xuICBcdFx0XHR2YWx1ZSA9IHdyYXBwZXIgPyB3cmFwcGVyLmdldCgpIDogcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0XHRcdGtleXMgPSB2YWx1ZSA/IE9iamVjdC5rZXlzKHZhbHVlKSA6IG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChrZXlzKSB7XG4gIFx0XHRcdGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFx0XHRcdFx0aWYgKGtleSAhPT0gXCJfcmFjdGl2ZVwiIHx8ICFpc0FycmF5KHZhbHVlKSkge1xuICBcdFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRocy5wdXNoKGtleXBhdGguam9pbihrZXkpKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbWF0Y2hpbmdLZXlwYXRocztcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBjb25jYXRlbmF0ZShrZXkpIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHJldHVybiBrZXlwYXRoLmpvaW4oa2V5KTtcbiAgXHR9O1xuICB9XG4gIGZ1bmN0aW9uIG5vcm1hbGlzZShyZWYpIHtcbiAgXHRyZXR1cm4gcmVmID8gcmVmLnJlcGxhY2UocmVmUGF0dGVybiwgXCIuJDFcIikgOiBcIlwiO1xuICB9XG5cbiAgdmFyIHJvb3RLZXlwYXRoID0gZ2V0S2V5cGF0aChcIlwiKTtcblxuICB2YXIgc2hhcmVkX2FkZCA9IGFkZDtcbiAgdmFyIHNoYXJlZF9hZGRfX2Vycm9yTWVzc2FnZSA9IFwiQ2Fubm90IGFkZCB0byBhIG5vbi1udW1lcmljIHZhbHVlXCI7XG4gIGZ1bmN0aW9uIGFkZChyb290LCBrZXlwYXRoLCBkKSB7XG4gIFx0aWYgKHR5cGVvZiBrZXlwYXRoICE9PSBcInN0cmluZ1wiIHx8ICFpc19faXNOdW1lcmljKGQpKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJCYWQgYXJndW1lbnRzXCIpO1xuICBcdH1cblxuICBcdHZhciB2YWx1ZSA9IHVuZGVmaW5lZCxcbiAgXHQgICAgY2hhbmdlcyA9IHVuZGVmaW5lZDtcblxuICBcdGlmICgvXFwqLy50ZXN0KGtleXBhdGgpKSB7XG4gIFx0XHRjaGFuZ2VzID0ge307XG5cbiAgXHRcdGdldE1hdGNoaW5nS2V5cGF0aHMocm9vdCwgZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdHZhciB2YWx1ZSA9IHJvb3Qudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdFx0XHRpZiAoIWlzX19pc051bWVyaWModmFsdWUpKSB7XG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKHNoYXJlZF9hZGRfX2Vycm9yTWVzc2FnZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjaGFuZ2VzW2tleXBhdGguc3RyXSA9IHZhbHVlICsgZDtcbiAgXHRcdH0pO1xuXG4gIFx0XHRyZXR1cm4gcm9vdC5zZXQoY2hhbmdlcyk7XG4gIFx0fVxuXG4gIFx0dmFsdWUgPSByb290LmdldChrZXlwYXRoKTtcblxuICBcdGlmICghaXNfX2lzTnVtZXJpYyh2YWx1ZSkpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihzaGFyZWRfYWRkX19lcnJvck1lc3NhZ2UpO1xuICBcdH1cblxuICBcdHJldHVybiByb290LnNldChrZXlwYXRoLCArdmFsdWUgKyBkKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfYWRkID0gUmFjdGl2ZSRhZGQ7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkYWRkKGtleXBhdGgsIGQpIHtcbiAgXHRyZXR1cm4gc2hhcmVkX2FkZCh0aGlzLCBrZXlwYXRoLCBkID09PSB1bmRlZmluZWQgPyAxIDogK2QpO1xuICB9XG5cbiAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblxuICAvLyBJZiB3aW5kb3cgZG9lc24ndCBleGlzdCwgd2UgZG9uJ3QgbmVlZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgXHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxXG4gIFx0KGZ1bmN0aW9uICh2ZW5kb3JzLCBsYXN0VGltZSwgd2luZG93KSB7XG5cbiAgXHRcdHZhciB4LCBzZXRUaW1lb3V0O1xuXG4gIFx0XHRpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XG4gIFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSArIFwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgXHRcdFx0c2V0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0O1xuXG4gIFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgXHRcdFx0XHR2YXIgY3VyclRpbWUsIHRpbWVUb0NhbGwsIGlkO1xuXG4gIFx0XHRcdFx0Y3VyclRpbWUgPSBEYXRlLm5vdygpO1xuICBcdFx0XHRcdHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XG4gIFx0XHRcdFx0aWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XG4gIFx0XHRcdFx0fSwgdGltZVRvQ2FsbCk7XG5cbiAgXHRcdFx0XHRsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgXHRcdFx0XHRyZXR1cm4gaWQ7XG4gIFx0XHRcdH07XG4gIFx0XHR9XG4gIFx0fSkodmVuZG9ycywgMCwgd2luZG93KTtcblxuICBcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gIH1cblxuICB2YXIgckFGID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG4gIHZhciBnZXRUaW1lO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB0eXBlb2Ygd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0Z2V0VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gIFx0fTtcbiAgfSBlbHNlIHtcbiAgXHRnZXRUaW1lID0gZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIERhdGUubm93KCk7XG4gIFx0fTtcbiAgfVxuXG4gIHZhciB1dGlsc19nZXRUaW1lID0gZ2V0VGltZTtcblxuICB2YXIgZGVwcmVjYXRpb25zID0ge1xuICBcdGNvbnN0cnVjdDoge1xuICBcdFx0ZGVwcmVjYXRlZDogXCJiZWZvcmVJbml0XCIsXG4gIFx0XHRyZXBsYWNlbWVudDogXCJvbmNvbnN0cnVjdFwiXG4gIFx0fSxcbiAgXHRyZW5kZXI6IHtcbiAgXHRcdGRlcHJlY2F0ZWQ6IFwiaW5pdFwiLFxuICBcdFx0bWVzc2FnZTogXCJUaGUgXFxcImluaXRcXFwiIG1ldGhvZCBoYXMgYmVlbiBkZXByZWNhdGVkIFwiICsgXCJhbmQgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiBcIiArIFwiWW91IGNhbiBlaXRoZXIgdXNlIHRoZSBcXFwib25pbml0XFxcIiBtZXRob2Qgd2hpY2ggd2lsbCBmaXJlIFwiICsgXCJvbmx5IG9uY2UgcHJpb3IgdG8sIGFuZCByZWdhcmRsZXNzIG9mLCBhbnkgZXZlbnR1YWwgcmFjdGl2ZSBcIiArIFwiaW5zdGFuY2UgYmVpbmcgcmVuZGVyZWQsIG9yIGlmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgXCIgKyBcInJlbmRlcmVkIERPTSwgdXNlIFxcXCJvbnJlbmRlclxcXCIgaW5zdGVhZC4gXCIgKyBcIlNlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9taWdyYXRpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgXHR9LFxuICBcdGNvbXBsZXRlOiB7XG4gIFx0XHRkZXByZWNhdGVkOiBcImNvbXBsZXRlXCIsXG4gIFx0XHRyZXBsYWNlbWVudDogXCJvbmNvbXBsZXRlXCJcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gSG9vayhldmVudCkge1xuICBcdHRoaXMuZXZlbnQgPSBldmVudDtcbiAgXHR0aGlzLm1ldGhvZCA9IFwib25cIiArIGV2ZW50O1xuICBcdHRoaXMuZGVwcmVjYXRlID0gZGVwcmVjYXRpb25zW2V2ZW50XTtcbiAgfVxuXG4gIEhvb2sucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbiAocmFjdGl2ZSwgYXJnKSB7XG4gIFx0ZnVuY3Rpb24gY2FsbChtZXRob2QpIHtcbiAgXHRcdGlmIChyYWN0aXZlW21ldGhvZF0pIHtcbiAgXHRcdFx0YXJnID8gcmFjdGl2ZVttZXRob2RdKGFyZykgOiByYWN0aXZlW21ldGhvZF0oKTtcbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Y2FsbCh0aGlzLm1ldGhvZCk7XG5cbiAgXHRpZiAoIXJhY3RpdmVbdGhpcy5tZXRob2RdICYmIHRoaXMuZGVwcmVjYXRlICYmIGNhbGwodGhpcy5kZXByZWNhdGUuZGVwcmVjYXRlZCkpIHtcbiAgXHRcdGlmICh0aGlzLmRlcHJlY2F0ZS5tZXNzYWdlKSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKHRoaXMuZGVwcmVjYXRlLm1lc3NhZ2UpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0d2FybklmRGVidWcoXCJUaGUgbWV0aG9kIFxcXCIlc1xcXCIgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBcXFwiJXNcXFwiIGFuZCB3aWxsIGxpa2VseSBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuIFNlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9taWdyYXRpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIsIHRoaXMuZGVwcmVjYXRlLmRlcHJlY2F0ZWQsIHRoaXMuZGVwcmVjYXRlLnJlcGxhY2VtZW50KTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRhcmcgPyByYWN0aXZlLmZpcmUodGhpcy5ldmVudCwgYXJnKSA6IHJhY3RpdmUuZmlyZSh0aGlzLmV2ZW50KTtcbiAgfTtcblxuICB2YXIgaG9va3NfSG9vayA9IEhvb2s7XG5cbiAgZnVuY3Rpb24gYWRkVG9BcnJheShhcnJheSwgdmFsdWUpIHtcbiAgXHR2YXIgaW5kZXggPSBhcnJheS5pbmRleE9mKHZhbHVlKTtcblxuICBcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdGFycmF5LnB1c2godmFsdWUpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5Q29udGFpbnMoYXJyYXksIHZhbHVlKSB7XG4gIFx0Zm9yICh2YXIgaSA9IDAsIGMgPSBhcnJheS5sZW5ndGg7IGkgPCBjOyBpKyspIHtcbiAgXHRcdGlmIChhcnJheVtpXSA9PSB2YWx1ZSkge1xuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUNvbnRlbnRzTWF0Y2goYSwgYikge1xuICBcdHZhciBpO1xuXG4gIFx0aWYgKCFpc0FycmF5KGEpIHx8ICFpc0FycmF5KGIpKSB7XG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuXG4gIFx0aWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdGkgPSBhLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoYVtpXSAhPT0gYltpXSkge1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVBcnJheSh4KSB7XG4gIFx0aWYgKHR5cGVvZiB4ID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRyZXR1cm4gW3hdO1xuICBcdH1cblxuICBcdGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdHJldHVybiBbXTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4geDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxhc3RJdGVtKGFycmF5KSB7XG4gIFx0cmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRnJvbUFycmF5KGFycmF5LCBtZW1iZXIpIHtcbiAgXHR2YXIgaW5kZXggPSBhcnJheS5pbmRleE9mKG1lbWJlcik7XG5cbiAgXHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvQXJyYXkoYXJyYXlMaWtlKSB7XG4gIFx0dmFyIGFycmF5ID0gW10sXG4gIFx0ICAgIGkgPSBhcnJheUxpa2UubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGFycmF5W2ldID0gYXJyYXlMaWtlW2ldO1xuICBcdH1cblxuICBcdHJldHVybiBhcnJheTtcbiAgfVxuXG4gIHZhciBfUHJvbWlzZSxcbiAgICAgIFBFTkRJTkcgPSB7fSxcbiAgICAgIEZVTEZJTExFRCA9IHt9LFxuICAgICAgUkVKRUNURUQgPSB7fTtcblxuICBpZiAodHlwZW9mIFByb21pc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdC8vIHVzZSBuYXRpdmUgUHJvbWlzZVxuICBcdF9Qcm9taXNlID0gUHJvbWlzZTtcbiAgfSBlbHNlIHtcbiAgXHRfUHJvbWlzZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBcdFx0dmFyIGZ1bGZpbGxlZEhhbmRsZXJzID0gW10sXG4gIFx0XHQgICAgcmVqZWN0ZWRIYW5kbGVycyA9IFtdLFxuICBcdFx0ICAgIHN0YXRlID0gUEVORElORyxcbiAgXHRcdCAgICByZXN1bHQsXG4gIFx0XHQgICAgZGlzcGF0Y2hIYW5kbGVycyxcbiAgXHRcdCAgICBtYWtlUmVzb2x2ZXIsXG4gIFx0XHQgICAgZnVsZmlsLFxuICBcdFx0ICAgIHJlamVjdCxcbiAgXHRcdCAgICBwcm9taXNlO1xuXG4gIFx0XHRtYWtlUmVzb2x2ZXIgPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0XHRcdGlmIChzdGF0ZSAhPT0gUEVORElORykge1xuICBcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdHJlc3VsdCA9IHZhbHVlO1xuICBcdFx0XHRcdHN0YXRlID0gbmV3U3RhdGU7XG5cbiAgXHRcdFx0XHRkaXNwYXRjaEhhbmRsZXJzID0gbWFrZURpc3BhdGNoZXIoc3RhdGUgPT09IEZVTEZJTExFRCA/IGZ1bGZpbGxlZEhhbmRsZXJzIDogcmVqZWN0ZWRIYW5kbGVycywgcmVzdWx0KTtcblxuICBcdFx0XHRcdC8vIGRpc3BhdGNoIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGhhbmRsZXJzIGFzeW5jaHJvbm91c2x5XG4gIFx0XHRcdFx0d2FpdChkaXNwYXRjaEhhbmRsZXJzKTtcbiAgXHRcdFx0fTtcbiAgXHRcdH07XG5cbiAgXHRcdGZ1bGZpbCA9IG1ha2VSZXNvbHZlcihGVUxGSUxMRUQpO1xuICBcdFx0cmVqZWN0ID0gbWFrZVJlc29sdmVyKFJFSkVDVEVEKTtcblxuICBcdFx0dHJ5IHtcbiAgXHRcdFx0Y2FsbGJhY2soZnVsZmlsLCByZWplY3QpO1xuICBcdFx0fSBjYXRjaCAoZXJyKSB7XG4gIFx0XHRcdHJlamVjdChlcnIpO1xuICBcdFx0fVxuXG4gIFx0XHRwcm9taXNlID0ge1xuICBcdFx0XHQvLyBgdGhlbigpYCByZXR1cm5zIGEgUHJvbWlzZSAtIDIuMi43XG4gIFx0XHRcdHRoZW46IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBcdFx0XHRcdHZhciBwcm9taXNlMiA9IG5ldyBfUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsLCByZWplY3QpIHtcblxuICBcdFx0XHRcdFx0dmFyIHByb2Nlc3NSZXNvbHV0aW9uSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyLCBoYW5kbGVycywgZm9yd2FyZCkge1xuXG4gIFx0XHRcdFx0XHRcdC8vIDIuMi4xLjFcbiAgXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHRcdFx0XHRoYW5kbGVycy5wdXNoKGZ1bmN0aW9uIChwMXJlc3VsdCkge1xuICBcdFx0XHRcdFx0XHRcdFx0dmFyIHg7XG5cbiAgXHRcdFx0XHRcdFx0XHRcdHRyeSB7XG4gIFx0XHRcdFx0XHRcdFx0XHRcdHggPSBoYW5kbGVyKHAxcmVzdWx0KTtcbiAgXHRcdFx0XHRcdFx0XHRcdFx0dXRpbHNfUHJvbWlzZV9fcmVzb2x2ZShwcm9taXNlMiwgeCwgZnVsZmlsLCByZWplY3QpO1xuICBcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG4gIFx0XHRcdFx0XHRcdFx0XHRcdHJlamVjdChlcnIpO1xuICBcdFx0XHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0XHRcdC8vIEZvcndhcmQgdGhlIHJlc3VsdCBvZiBwcm9taXNlMSB0byBwcm9taXNlMiwgaWYgcmVzb2x1dGlvbiBoYW5kbGVyc1xuICBcdFx0XHRcdFx0XHRcdC8vIGFyZSBub3QgZ2l2ZW5cbiAgXHRcdFx0XHRcdFx0XHRoYW5kbGVycy5wdXNoKGZvcndhcmQpO1xuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9O1xuXG4gIFx0XHRcdFx0XHQvLyAyLjJcbiAgXHRcdFx0XHRcdHByb2Nlc3NSZXNvbHV0aW9uSGFuZGxlcihvbkZ1bGZpbGxlZCwgZnVsZmlsbGVkSGFuZGxlcnMsIGZ1bGZpbCk7XG4gIFx0XHRcdFx0XHRwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIob25SZWplY3RlZCwgcmVqZWN0ZWRIYW5kbGVycywgcmVqZWN0KTtcblxuICBcdFx0XHRcdFx0aWYgKHN0YXRlICE9PSBQRU5ESU5HKSB7XG4gIFx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcm9taXNlIGhhcyByZXNvbHZlZCBhbHJlYWR5LCBkaXNwYXRjaCB0aGUgYXBwcm9wcmlhdGUgaGFuZGxlcnMgYXN5bmNocm9ub3VzbHlcbiAgXHRcdFx0XHRcdFx0d2FpdChkaXNwYXRjaEhhbmRsZXJzKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9KTtcblxuICBcdFx0XHRcdHJldHVybiBwcm9taXNlMjtcbiAgXHRcdFx0fVxuICBcdFx0fTtcblxuICBcdFx0cHJvbWlzZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbiAgXHRcdH07XG5cbiAgXHRcdHJldHVybiBwcm9taXNlO1xuICBcdH07XG5cbiAgXHRfUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgXHRcdHJldHVybiBuZXcgX1Byb21pc2UoZnVuY3Rpb24gKGZ1bGZpbCwgcmVqZWN0KSB7XG4gIFx0XHRcdHZhciByZXN1bHQgPSBbXSxcbiAgXHRcdFx0ICAgIHBlbmRpbmcsXG4gIFx0XHRcdCAgICBpLFxuICBcdFx0XHQgICAgcHJvY2Vzc1Byb21pc2U7XG5cbiAgXHRcdFx0aWYgKCFwcm9taXNlcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRmdWxmaWwocmVzdWx0KTtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwcm9jZXNzUHJvbWlzZSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpKSB7XG4gIFx0XHRcdFx0aWYgKHByb21pc2UgJiYgdHlwZW9mIHByb21pc2UudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdFx0XHRwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRcdFx0XHRcdHJlc3VsdFtpXSA9IHZhbHVlO1xuICBcdFx0XHRcdFx0XHQtLXBlbmRpbmcgfHwgZnVsZmlsKHJlc3VsdCk7XG4gIFx0XHRcdFx0XHR9LCByZWplY3QpO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRyZXN1bHRbaV0gPSBwcm9taXNlO1xuICBcdFx0XHRcdFx0LS1wZW5kaW5nIHx8IGZ1bGZpbChyZXN1bHQpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fTtcblxuICBcdFx0XHRwZW5kaW5nID0gaSA9IHByb21pc2VzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdHByb2Nlc3NQcm9taXNlKHByb21pc2VzW2ldLCBpKTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fTtcblxuICBcdF9Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdHJldHVybiBuZXcgX1Byb21pc2UoZnVuY3Rpb24gKGZ1bGZpbCkge1xuICBcdFx0XHRmdWxmaWwodmFsdWUpO1xuICBcdFx0fSk7XG4gIFx0fTtcblxuICBcdF9Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgXHRcdHJldHVybiBuZXcgX1Byb21pc2UoZnVuY3Rpb24gKGZ1bGZpbCwgcmVqZWN0KSB7XG4gIFx0XHRcdHJlamVjdChyZWFzb24pO1xuICBcdFx0fSk7XG4gIFx0fTtcbiAgfVxuXG4gIHZhciB1dGlsc19Qcm9taXNlID0gX1Byb21pc2U7XG5cbiAgLy8gVE9ETyB1c2UgTXV0YXRpb25PYnNlcnZlcnMgb3Igc29tZXRoaW5nIHRvIHNpbXVsYXRlIHNldEltbWVkaWF0ZVxuICBmdW5jdGlvbiB3YWl0KGNhbGxiYWNrKSB7XG4gIFx0c2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlRGlzcGF0Y2hlcihoYW5kbGVycywgcmVzdWx0KSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBoYW5kbGVyO1xuXG4gIFx0XHR3aGlsZSAoaGFuZGxlciA9IGhhbmRsZXJzLnNoaWZ0KCkpIHtcbiAgXHRcdFx0aGFuZGxlcihyZXN1bHQpO1xuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICBmdW5jdGlvbiB1dGlsc19Qcm9taXNlX19yZXNvbHZlKHByb21pc2UsIHgsIGZ1bGZpbCwgcmVqZWN0KSB7XG4gIFx0Ly8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZVxuICBcdHZhciB0aGVuO1xuXG4gIFx0Ly8gMi4zLjFcbiAgXHRpZiAoeCA9PT0gcHJvbWlzZSkge1xuICBcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgcHJvbWlzZSdzIGZ1bGZpbGxtZW50IGhhbmRsZXIgY2Fubm90IHJldHVybiB0aGUgc2FtZSBwcm9taXNlXCIpO1xuICBcdH1cblxuICBcdC8vIDIuMy4yXG4gIFx0aWYgKHggaW5zdGFuY2VvZiBfUHJvbWlzZSkge1xuICBcdFx0eC50aGVuKGZ1bGZpbCwgcmVqZWN0KTtcbiAgXHR9XG5cbiAgXHQvLyAyLjMuM1xuICBcdGVsc2UgaWYgKHggJiYgKHR5cGVvZiB4ID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gIFx0XHR0cnkge1xuICBcdFx0XHR0aGVuID0geC50aGVuOyAvLyAyLjMuMy4xXG4gIFx0XHR9IGNhdGNoIChlKSB7XG4gIFx0XHRcdHJlamVjdChlKTsgLy8gMi4zLjMuMlxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdC8vIDIuMy4zLjNcbiAgXHRcdGlmICh0eXBlb2YgdGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdHZhciBjYWxsZWQsIHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlO1xuXG4gIFx0XHRcdHJlc29sdmVQcm9taXNlID0gZnVuY3Rpb24gKHkpIHtcbiAgXHRcdFx0XHRpZiAoY2FsbGVkKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuICBcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG4gIFx0XHRcdFx0dXRpbHNfUHJvbWlzZV9fcmVzb2x2ZShwcm9taXNlLCB5LCBmdWxmaWwsIHJlamVjdCk7XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0cmVqZWN0UHJvbWlzZSA9IGZ1bmN0aW9uIChyKSB7XG4gIFx0XHRcdFx0aWYgKGNhbGxlZCkge1xuICBcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHRjYWxsZWQgPSB0cnVlO1xuICBcdFx0XHRcdHJlamVjdChyKTtcbiAgXHRcdFx0fTtcblxuICBcdFx0XHR0cnkge1xuICBcdFx0XHRcdHRoZW4uY2FsbCh4LCByZXNvbHZlUHJvbWlzZSwgcmVqZWN0UHJvbWlzZSk7XG4gIFx0XHRcdH0gY2F0Y2ggKGUpIHtcbiAgXHRcdFx0XHRpZiAoIWNhbGxlZCkge1xuICBcdFx0XHRcdFx0Ly8gMi4zLjMuMy40LjFcbiAgXHRcdFx0XHRcdHJlamVjdChlKTsgLy8gMi4zLjMuMy40LjJcbiAgXHRcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmdWxmaWwoeCk7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGZ1bGZpbCh4KTtcbiAgXHR9XG4gIH1cblxuICB2YXIgZ2V0SW5uZXJDb250ZXh0ID0gZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gIFx0ZG8ge1xuICBcdFx0aWYgKGZyYWdtZW50LmNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm4gZnJhZ21lbnQuY29udGV4dDtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlIChmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudCk7XG5cbiAgXHRyZXR1cm4gcm9vdEtleXBhdGg7XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9yZXNvbHZlUmVmID0gcmVzb2x2ZVJlZjtcblxuICBmdW5jdGlvbiByZXNvbHZlUmVmKHJhY3RpdmUsIHJlZiwgZnJhZ21lbnQpIHtcbiAgXHR2YXIga2V5cGF0aDtcblxuICBcdHJlZiA9IG5vcm1hbGlzZShyZWYpO1xuXG4gIFx0Ly8gSWYgYSByZWZlcmVuY2UgYmVnaW5zICd+LycsIGl0J3MgYSB0b3AtbGV2ZWwgcmVmZXJlbmNlXG4gIFx0aWYgKHJlZi5zdWJzdHIoMCwgMikgPT09IFwifi9cIikge1xuICBcdFx0a2V5cGF0aCA9IGdldEtleXBhdGgocmVmLnN1YnN0cmluZygyKSk7XG4gIFx0XHRjcmVhdGVNYXBwaW5nSWZOZWNlc3NhcnkocmFjdGl2ZSwga2V5cGF0aC5maXJzdEtleSwgZnJhZ21lbnQpO1xuICBcdH1cblxuICBcdC8vIElmIGEgcmVmZXJlbmNlIGJlZ2lucyB3aXRoICcuJywgaXQncyBlaXRoZXIgYSByZXN0cmljdGVkIHJlZmVyZW5jZSBvclxuICBcdC8vIGFuIGFuY2VzdG9yIHJlZmVyZW5jZS4uLlxuICBcdGVsc2UgaWYgKHJlZlswXSA9PT0gXCIuXCIpIHtcbiAgXHRcdGtleXBhdGggPSByZXNvbHZlQW5jZXN0b3JSZWYoZ2V0SW5uZXJDb250ZXh0KGZyYWdtZW50KSwgcmVmKTtcblxuICBcdFx0aWYgKGtleXBhdGgpIHtcbiAgXHRcdFx0Y3JlYXRlTWFwcGluZ0lmTmVjZXNzYXJ5KHJhY3RpdmUsIGtleXBhdGguZmlyc3RLZXksIGZyYWdtZW50KTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyAuLi5vdGhlcndpc2Ugd2UgbmVlZCB0byBmaWd1cmUgb3V0IHRoZSBrZXlwYXRoIGJhc2VkIG9uIGNvbnRleHRcbiAgXHRlbHNlIHtcbiAgXHRcdGtleXBhdGggPSByZXNvbHZlQW1iaWd1b3VzUmVmZXJlbmNlKHJhY3RpdmUsIGdldEtleXBhdGgocmVmKSwgZnJhZ21lbnQpO1xuICBcdH1cblxuICBcdHJldHVybiBrZXlwYXRoO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUFuY2VzdG9yUmVmKGJhc2VDb250ZXh0LCByZWYpIHtcbiAgXHR2YXIgY29udGV4dEtleXM7XG5cbiAgXHQvLyBUT0RPLi4uXG4gIFx0aWYgKGJhc2VDb250ZXh0ICE9IHVuZGVmaW5lZCAmJiB0eXBlb2YgYmFzZUNvbnRleHQgIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGJhc2VDb250ZXh0ID0gYmFzZUNvbnRleHQuc3RyO1xuICBcdH1cblxuICBcdC8vIHt7Ln19IG1lYW5zICdjdXJyZW50IGNvbnRleHQnXG4gIFx0aWYgKHJlZiA9PT0gXCIuXCIpIHJldHVybiBnZXRLZXlwYXRoKGJhc2VDb250ZXh0KTtcblxuICBcdGNvbnRleHRLZXlzID0gYmFzZUNvbnRleHQgPyBiYXNlQ29udGV4dC5zcGxpdChcIi5cIikgOiBbXTtcblxuICBcdC8vIGFuY2VzdG9yIHJlZmVyZW5jZXMgKHN0YXJ0aW5nIFwiLi4vXCIpIGdvIHVwIHRoZSB0cmVlXG4gIFx0aWYgKHJlZi5zdWJzdHIoMCwgMykgPT09IFwiLi4vXCIpIHtcbiAgXHRcdHdoaWxlIChyZWYuc3Vic3RyKDAsIDMpID09PSBcIi4uL1wiKSB7XG4gIFx0XHRcdGlmICghY29udGV4dEtleXMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgcmVmZXJlbmNlIC0gdG9vIG1hbnkgXFxcIi4uL1xcXCIgcHJlZml4ZXNcIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb250ZXh0S2V5cy5wb3AoKTtcbiAgXHRcdFx0cmVmID0gcmVmLnN1YnN0cmluZygzKTtcbiAgXHRcdH1cblxuICBcdFx0Y29udGV4dEtleXMucHVzaChyZWYpO1xuICBcdFx0cmV0dXJuIGdldEtleXBhdGgoY29udGV4dEtleXMuam9pbihcIi5cIikpO1xuICBcdH1cblxuICBcdC8vIG5vdCBhbiBhbmNlc3RvciByZWZlcmVuY2UgLSBtdXN0IGJlIGEgcmVzdHJpY3RlZCByZWZlcmVuY2UgKHByZXBlbmRlZCB3aXRoIFwiLlwiIG9yIFwiLi9cIilcbiAgXHRpZiAoIWJhc2VDb250ZXh0KSB7XG4gIFx0XHRyZXR1cm4gZ2V0S2V5cGF0aChyZWYucmVwbGFjZSgvXlxcLlxcLz8vLCBcIlwiKSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGdldEtleXBhdGgoYmFzZUNvbnRleHQgKyByZWYucmVwbGFjZSgvXlxcLlxcLy8sIFwiLlwiKSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlQW1iaWd1b3VzUmVmZXJlbmNlKHJhY3RpdmUsIHJlZiwgZnJhZ21lbnQsIGlzUGFyZW50TG9va3VwKSB7XG4gIFx0dmFyIGNvbnRleHQsIGtleSwgcGFyZW50VmFsdWUsIGhhc0NvbnRleHRDaGFpbiwgcGFyZW50S2V5cGF0aDtcblxuICBcdGlmIChyZWYuaXNSb290KSB7XG4gIFx0XHRyZXR1cm4gcmVmO1xuICBcdH1cblxuICBcdGtleSA9IHJlZi5maXJzdEtleTtcblxuICBcdHdoaWxlIChmcmFnbWVudCkge1xuICBcdFx0Y29udGV4dCA9IGZyYWdtZW50LmNvbnRleHQ7XG4gIFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudDtcblxuICBcdFx0aWYgKCFjb250ZXh0KSB7XG4gIFx0XHRcdGNvbnRpbnVlO1xuICBcdFx0fVxuXG4gIFx0XHRoYXNDb250ZXh0Q2hhaW4gPSB0cnVlO1xuICBcdFx0cGFyZW50VmFsdWUgPSByYWN0aXZlLnZpZXdtb2RlbC5nZXQoY29udGV4dCk7XG5cbiAgXHRcdGlmIChwYXJlbnRWYWx1ZSAmJiAodHlwZW9mIHBhcmVudFZhbHVlID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSAmJiBrZXkgaW4gcGFyZW50VmFsdWUpIHtcbiAgXHRcdFx0cmV0dXJuIGNvbnRleHQuam9pbihyZWYuc3RyKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBSb290L2NvbXB1dGVkL21hcHBlZCBwcm9wZXJ0eT9cbiAgXHRpZiAoaXNSb290UHJvcGVydHkocmFjdGl2ZS52aWV3bW9kZWwsIGtleSkpIHtcbiAgXHRcdHJldHVybiByZWY7XG4gIFx0fVxuXG4gIFx0Ly8gSWYgdGhpcyBpcyBhbiBpbmxpbmUgY29tcG9uZW50LCBhbmQgaXQncyBub3QgaXNvbGF0ZWQsIHdlXG4gIFx0Ly8gY2FuIHRyeSBnb2luZyB1cCB0aGUgc2NvcGUgY2hhaW5cbiAgXHRpZiAocmFjdGl2ZS5wYXJlbnQgJiYgIXJhY3RpdmUuaXNvbGF0ZWQpIHtcbiAgXHRcdGhhc0NvbnRleHRDaGFpbiA9IHRydWU7XG4gIFx0XHRmcmFnbWVudCA9IHJhY3RpdmUuY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXG4gIFx0XHRrZXkgPSBnZXRLZXlwYXRoKGtleSk7XG5cbiAgXHRcdGlmIChwYXJlbnRLZXlwYXRoID0gcmVzb2x2ZUFtYmlndW91c1JlZmVyZW5jZShyYWN0aXZlLnBhcmVudCwga2V5LCBmcmFnbWVudCwgdHJ1ZSkpIHtcbiAgXHRcdFx0Ly8gV2UgbmVlZCB0byBjcmVhdGUgYW4gaW50ZXItY29tcG9uZW50IGJpbmRpbmdcbiAgXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwubWFwKGtleSwge1xuICBcdFx0XHRcdG9yaWdpbjogcmFjdGl2ZS5wYXJlbnQudmlld21vZGVsLFxuICBcdFx0XHRcdGtleXBhdGg6IHBhcmVudEtleXBhdGhcbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0cmV0dXJuIHJlZjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGVyZSdzIG5vIGNvbnRleHQgY2hhaW4sIGFuZCB0aGUgaW5zdGFuY2UgaXMgZWl0aGVyIGEpIGlzb2xhdGVkIG9yXG4gIFx0Ly8gYikgYW4gb3JwaGFuLCB0aGVuIHdlIGtub3cgdGhhdCB0aGUga2V5cGF0aCBpcyBpZGVudGljYWwgdG8gdGhlIHJlZmVyZW5jZVxuICBcdGlmICghaXNQYXJlbnRMb29rdXAgJiYgIWhhc0NvbnRleHRDaGFpbikge1xuICBcdFx0Ly8gdGhlIGRhdGEgb2JqZWN0IG5lZWRzIHRvIGhhdmUgYSBwcm9wZXJ0eSBieSB0aGlzIG5hbWUsXG4gIFx0XHQvLyB0byBwcmV2ZW50IGZ1dHVyZSBmYWlsZWQgbG9va3Vwc1xuICBcdFx0cmFjdGl2ZS52aWV3bW9kZWwuc2V0KHJlZiwgdW5kZWZpbmVkKTtcbiAgXHRcdHJldHVybiByZWY7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTWFwcGluZ0lmTmVjZXNzYXJ5KHJhY3RpdmUsIGtleSkge1xuICBcdHZhciBwYXJlbnRLZXlwYXRoO1xuXG4gIFx0aWYgKCFyYWN0aXZlLnBhcmVudCB8fCByYWN0aXZlLmlzb2xhdGVkIHx8IGlzUm9vdFByb3BlcnR5KHJhY3RpdmUudmlld21vZGVsLCBrZXkpKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0a2V5ID0gZ2V0S2V5cGF0aChrZXkpO1xuXG4gIFx0aWYgKHBhcmVudEtleXBhdGggPSByZXNvbHZlQW1iaWd1b3VzUmVmZXJlbmNlKHJhY3RpdmUucGFyZW50LCBrZXksIHJhY3RpdmUuY29tcG9uZW50LnBhcmVudEZyYWdtZW50LCB0cnVlKSkge1xuICBcdFx0cmFjdGl2ZS52aWV3bW9kZWwubWFwKGtleSwge1xuICBcdFx0XHRvcmlnaW46IHJhY3RpdmUucGFyZW50LnZpZXdtb2RlbCxcbiAgXHRcdFx0a2V5cGF0aDogcGFyZW50S2V5cGF0aFxuICBcdFx0fSk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gaXNSb290UHJvcGVydHkodmlld21vZGVsLCBrZXkpIHtcbiAgXHQvLyBzcGVjaWFsIGNhc2UgZm9yIHJlZmVyZW5jZSB0byByb290XG4gIFx0cmV0dXJuIGtleSA9PT0gXCJcIiB8fCBrZXkgaW4gdmlld21vZGVsLmRhdGEgfHwga2V5IGluIHZpZXdtb2RlbC5jb21wdXRhdGlvbnMgfHwga2V5IGluIHZpZXdtb2RlbC5tYXBwaW5ncztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlYXJkb3duKHgpIHtcbiAgICB4LnRlYXJkb3duKCk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXRob2RDYWxsZXJzX191bmJpbmQoeCkge1xuICAgIHgudW5iaW5kKCk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXRob2RDYWxsZXJzX191bnJlbmRlcih4KSB7XG4gICAgeC51bnJlbmRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKHgpIHtcbiAgICB4LmNhbmNlbCgpO1xuICB9XG5cbiAgdmFyIFRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBwYXJlbnQpIHtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIFx0dGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgXHR0aGlzLmludHJvcyA9IFtdO1xuICBcdHRoaXMub3V0cm9zID0gW107XG5cbiAgXHR0aGlzLmNoaWxkcmVuID0gW107XG4gIFx0dGhpcy50b3RhbENoaWxkcmVuID0gdGhpcy5vdXRyb0NoaWxkcmVuID0gMDtcblxuICBcdHRoaXMuZGV0YWNoUXVldWUgPSBbXTtcbiAgXHR0aGlzLmRlY29yYXRvclF1ZXVlID0gW107XG4gIFx0dGhpcy5vdXRyb3NDb21wbGV0ZSA9IGZhbHNlO1xuXG4gIFx0aWYgKHBhcmVudCkge1xuICBcdFx0cGFyZW50LmFkZENoaWxkKHRoaXMpO1xuICBcdH1cbiAgfTtcblxuICBUcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gIFx0YWRkQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICBcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICBcdFx0dGhpcy50b3RhbENoaWxkcmVuICs9IDE7XG4gIFx0XHR0aGlzLm91dHJvQ2hpbGRyZW4gKz0gMTtcbiAgXHR9LFxuXG4gIFx0ZGVjcmVtZW50T3V0cm9zOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLm91dHJvQ2hpbGRyZW4gLT0gMTtcbiAgXHRcdGNoZWNrKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRkZWNyZW1lbnRUb3RhbDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy50b3RhbENoaWxkcmVuIC09IDE7XG4gIFx0XHRjaGVjayh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0YWRkOiBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICBcdFx0dmFyIGxpc3QgPSB0cmFuc2l0aW9uLmlzSW50cm8gPyB0aGlzLmludHJvcyA6IHRoaXMub3V0cm9zO1xuICBcdFx0bGlzdC5wdXNoKHRyYW5zaXRpb24pO1xuICBcdH0sXG5cbiAgXHRhZGREZWNvcmF0b3I6IGZ1bmN0aW9uIChkZWNvcmF0b3IpIHtcbiAgXHRcdHRoaXMuZGVjb3JhdG9yUXVldWUucHVzaChkZWNvcmF0b3IpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmU6IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gIFx0XHR2YXIgbGlzdCA9IHRyYW5zaXRpb24uaXNJbnRybyA/IHRoaXMuaW50cm9zIDogdGhpcy5vdXRyb3M7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkobGlzdCwgdHJhbnNpdGlvbik7XG4gIFx0XHRjaGVjayh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5yZWFkeSA9IHRydWU7XG4gIFx0XHRjaGVjayh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0ZGV0YWNoTm9kZXM6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZGVjb3JhdG9yUXVldWUuZm9yRWFjaCh0ZWFyZG93bik7XG4gIFx0XHR0aGlzLmRldGFjaFF1ZXVlLmZvckVhY2goZGV0YWNoKTtcbiAgXHRcdHRoaXMuY2hpbGRyZW4uZm9yRWFjaChkZXRhY2hOb2Rlcyk7XG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRldGFjaChlbGVtZW50KSB7XG4gIFx0ZWxlbWVudC5kZXRhY2goKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRldGFjaE5vZGVzKHRtKSB7XG4gIFx0dG0uZGV0YWNoTm9kZXMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrKHRtKSB7XG4gIFx0aWYgKCF0bS5yZWFkeSB8fCB0bS5vdXRyb3MubGVuZ3RoIHx8IHRtLm91dHJvQ2hpbGRyZW4pIHJldHVybjtcblxuICBcdC8vIElmIGFsbCBvdXRyb3MgYXJlIGNvbXBsZXRlLCBhbmQgd2UgaGF2ZW4ndCBhbHJlYWR5IGRvbmUgdGhpcyxcbiAgXHQvLyB3ZSBub3RpZnkgdGhlIHBhcmVudCBpZiB0aGVyZSBpcyBvbmUsIG90aGVyd2lzZVxuICBcdC8vIHN0YXJ0IGRldGFjaGluZyBub2Rlc1xuICBcdGlmICghdG0ub3V0cm9zQ29tcGxldGUpIHtcbiAgXHRcdGlmICh0bS5wYXJlbnQpIHtcbiAgXHRcdFx0dG0ucGFyZW50LmRlY3JlbWVudE91dHJvcyh0bSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0bS5kZXRhY2hOb2RlcygpO1xuICBcdFx0fVxuXG4gIFx0XHR0bS5vdXRyb3NDb21wbGV0ZSA9IHRydWU7XG4gIFx0fVxuXG4gIFx0Ly8gT25jZSBldmVyeXRoaW5nIGlzIGRvbmUsIHdlIGNhbiBub3RpZnkgcGFyZW50IHRyYW5zaXRpb25cbiAgXHQvLyBtYW5hZ2VyIGFuZCBjYWxsIHRoZSBjYWxsYmFja1xuICBcdGlmICghdG0uaW50cm9zLmxlbmd0aCAmJiAhdG0udG90YWxDaGlsZHJlbikge1xuICBcdFx0aWYgKHR5cGVvZiB0bS5jYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdHRtLmNhbGxiYWNrKCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0bS5wYXJlbnQpIHtcbiAgXHRcdFx0dG0ucGFyZW50LmRlY3JlbWVudFRvdGFsKCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIGdsb2JhbF9UcmFuc2l0aW9uTWFuYWdlciA9IFRyYW5zaXRpb25NYW5hZ2VyO1xuXG4gIHZhciBiYXRjaCxcbiAgICAgIHJ1bmxvb3AsXG4gICAgICB1bnJlc29sdmVkID0gW10sXG4gICAgICBjaGFuZ2VIb29rID0gbmV3IGhvb2tzX0hvb2soXCJjaGFuZ2VcIik7XG5cbiAgcnVubG9vcCA9IHtcbiAgXHRzdGFydDogZnVuY3Rpb24gKGluc3RhbmNlLCByZXR1cm5Qcm9taXNlKSB7XG4gIFx0XHR2YXIgcHJvbWlzZSwgZnVsZmlsUHJvbWlzZTtcblxuICBcdFx0aWYgKHJldHVyblByb21pc2UpIHtcbiAgXHRcdFx0cHJvbWlzZSA9IG5ldyB1dGlsc19Qcm9taXNlKGZ1bmN0aW9uIChmKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZ1bGZpbFByb21pc2UgPSBmO1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0YmF0Y2ggPSB7XG4gIFx0XHRcdHByZXZpb3VzQmF0Y2g6IGJhdGNoLFxuICBcdFx0XHR0cmFuc2l0aW9uTWFuYWdlcjogbmV3IGdsb2JhbF9UcmFuc2l0aW9uTWFuYWdlcihmdWxmaWxQcm9taXNlLCBiYXRjaCAmJiBiYXRjaC50cmFuc2l0aW9uTWFuYWdlciksXG4gIFx0XHRcdHZpZXdzOiBbXSxcbiAgXHRcdFx0dGFza3M6IFtdLFxuICBcdFx0XHRyYWN0aXZlczogW10sXG4gIFx0XHRcdGluc3RhbmNlOiBpbnN0YW5jZVxuICBcdFx0fTtcblxuICBcdFx0aWYgKGluc3RhbmNlKSB7XG4gIFx0XHRcdGJhdGNoLnJhY3RpdmVzLnB1c2goaW5zdGFuY2UpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gcHJvbWlzZTtcbiAgXHR9LFxuXG4gIFx0ZW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRmbHVzaENoYW5nZXMoKTtcblxuICBcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuaW5pdCgpO1xuICBcdFx0aWYgKCFiYXRjaC5wcmV2aW91c0JhdGNoICYmICEhYmF0Y2guaW5zdGFuY2UpIGJhdGNoLmluc3RhbmNlLnZpZXdtb2RlbC5jaGFuZ2VzID0gW107XG4gIFx0XHRiYXRjaCA9IGJhdGNoLnByZXZpb3VzQmF0Y2g7XG4gIFx0fSxcblxuICBcdGFkZFJhY3RpdmU6IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG4gIFx0XHRpZiAoYmF0Y2gpIHtcbiAgXHRcdFx0YWRkVG9BcnJheShiYXRjaC5yYWN0aXZlcywgcmFjdGl2ZSk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlZ2lzdGVyVHJhbnNpdGlvbjogZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgXHRcdHRyYW5zaXRpb24uX21hbmFnZXIgPSBiYXRjaC50cmFuc2l0aW9uTWFuYWdlcjtcbiAgXHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmFkZCh0cmFuc2l0aW9uKTtcbiAgXHR9LFxuXG4gIFx0cmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uIChkZWNvcmF0b3IpIHtcbiAgXHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmFkZERlY29yYXRvcihkZWNvcmF0b3IpO1xuICBcdH0sXG5cbiAgXHRhZGRWaWV3OiBmdW5jdGlvbiAodmlldykge1xuICBcdFx0YmF0Y2gudmlld3MucHVzaCh2aWV3KTtcbiAgXHR9LFxuXG4gIFx0YWRkVW5yZXNvbHZlZDogZnVuY3Rpb24gKHRoaW5nKSB7XG4gIFx0XHR1bnJlc29sdmVkLnB1c2godGhpbmcpO1xuICBcdH0sXG5cbiAgXHRyZW1vdmVVbnJlc29sdmVkOiBmdW5jdGlvbiAodGhpbmcpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh1bnJlc29sdmVkLCB0aGluZyk7XG4gIFx0fSxcblxuICBcdC8vIHN5bmNocm9uaXNlIG5vZGUgZGV0YWNobWVudHMgd2l0aCB0cmFuc2l0aW9uIGVuZHNcbiAgXHRkZXRhY2hXaGVuUmVhZHk6IGZ1bmN0aW9uICh0aGluZykge1xuICBcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuZGV0YWNoUXVldWUucHVzaCh0aGluZyk7XG4gIFx0fSxcblxuICBcdHNjaGVkdWxlVGFzazogZnVuY3Rpb24gKHRhc2ssIHBvc3RSZW5kZXIpIHtcbiAgXHRcdHZhciBfYmF0Y2g7XG5cbiAgXHRcdGlmICghYmF0Y2gpIHtcbiAgXHRcdFx0dGFzaygpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0X2JhdGNoID0gYmF0Y2g7XG4gIFx0XHRcdHdoaWxlIChwb3N0UmVuZGVyICYmIF9iYXRjaC5wcmV2aW91c0JhdGNoKSB7XG4gIFx0XHRcdFx0Ly8gdGhpcyBjYW4ndCBoYXBwZW4gdW50aWwgdGhlIERPTSBoYXMgYmVlbiBmdWxseSB1cGRhdGVkXG4gIFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIGluIHNvbWUgc2l0dWF0aW9ucyAod2l0aCBjb21wb25lbnRzIGluc2lkZSBlbGVtZW50cylcbiAgXHRcdFx0XHQvLyB0cmFuc2l0aW9ucyBhbmQgZGVjb3JhdG9ycyB3aWxsIGluaXRpYWxpc2UgcHJlbWF0dXJlbHlcbiAgXHRcdFx0XHRfYmF0Y2ggPSBfYmF0Y2gucHJldmlvdXNCYXRjaDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdF9iYXRjaC50YXNrcy5wdXNoKHRhc2spO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgZ2xvYmFsX3J1bmxvb3AgPSBydW5sb29wO1xuXG4gIGZ1bmN0aW9uIGZsdXNoQ2hhbmdlcygpIHtcbiAgXHR2YXIgaSwgdGhpbmcsIGNoYW5nZUhhc2g7XG5cbiAgXHR3aGlsZSAoYmF0Y2gucmFjdGl2ZXMubGVuZ3RoKSB7XG4gIFx0XHR0aGluZyA9IGJhdGNoLnJhY3RpdmVzLnBvcCgpO1xuICBcdFx0Y2hhbmdlSGFzaCA9IHRoaW5nLnZpZXdtb2RlbC5hcHBseUNoYW5nZXMoKTtcblxuICBcdFx0aWYgKGNoYW5nZUhhc2gpIHtcbiAgXHRcdFx0Y2hhbmdlSG9vay5maXJlKHRoaW5nLCBjaGFuZ2VIYXNoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRhdHRlbXB0S2V5cGF0aFJlc29sdXRpb24oKTtcblxuICBcdC8vIE5vdyB0aGF0IGNoYW5nZXMgaGF2ZSBiZWVuIGZ1bGx5IHByb3BhZ2F0ZWQsIHdlIGNhbiB1cGRhdGUgdGhlIERPTVxuICBcdC8vIGFuZCBjb21wbGV0ZSBvdGhlciB0YXNrc1xuICBcdGZvciAoaSA9IDA7IGkgPCBiYXRjaC52aWV3cy5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0YmF0Y2gudmlld3NbaV0udXBkYXRlKCk7XG4gIFx0fVxuICBcdGJhdGNoLnZpZXdzLmxlbmd0aCA9IDA7XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgYmF0Y2gudGFza3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdGJhdGNoLnRhc2tzW2ldKCk7XG4gIFx0fVxuICBcdGJhdGNoLnRhc2tzLmxlbmd0aCA9IDA7XG5cbiAgXHQvLyBJZiB1cGRhdGluZyB0aGUgdmlldyBjYXVzZWQgc29tZSBtb2RlbCBibG93YmFjayAtIGUuZy4gYSB0cmlwbGVcbiAgXHQvLyBjb250YWluaW5nIDxvcHRpb24+IGVsZW1lbnRzIGNhdXNlZCB0aGUgYmluZGluZyBvbiB0aGUgPHNlbGVjdD5cbiAgXHQvLyB0byB1cGRhdGUgLSB0aGVuIHdlIHN0YXJ0IG92ZXJcbiAgXHRpZiAoYmF0Y2gucmFjdGl2ZXMubGVuZ3RoKSByZXR1cm4gZmx1c2hDaGFuZ2VzKCk7XG4gIH1cblxuICBmdW5jdGlvbiBhdHRlbXB0S2V5cGF0aFJlc29sdXRpb24oKSB7XG4gIFx0dmFyIGksIGl0ZW0sIGtleXBhdGgsIHJlc29sdmVkO1xuXG4gIFx0aSA9IHVucmVzb2x2ZWQubGVuZ3RoO1xuXG4gIFx0Ly8gc2VlIGlmIHdlIGNhbiByZXNvbHZlIGFueSB1bnJlc29sdmVkIHJlZmVyZW5jZXNcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpdGVtID0gdW5yZXNvbHZlZFtpXTtcblxuICBcdFx0aWYgKGl0ZW0ua2V5cGF0aCkge1xuICBcdFx0XHQvLyBpdCByZXNvbHZlZCBzb21lIG90aGVyIHdheS4gVE9ETyBob3c/IHR3by13YXkgYmluZGluZz8gU2VlbXNcbiAgXHRcdFx0Ly8gd2VpcmQgdGhhdCB3ZSdkIHN0aWxsIGVuZCB1cCBoZXJlXG4gIFx0XHRcdHVucmVzb2x2ZWQuc3BsaWNlKGksIDEpO1xuICBcdFx0XHRjb250aW51ZTsgLy8gYXZvaWQgcmVtb3ZpbmcgdGhlIHdyb25nIHRoaW5nIHNob3VsZCB0aGUgbmV4dCBjb25kaXRpb24gYmUgdHJ1ZVxuICBcdFx0fVxuXG4gIFx0XHRpZiAoa2V5cGF0aCA9IHNoYXJlZF9yZXNvbHZlUmVmKGl0ZW0ucm9vdCwgaXRlbS5yZWYsIGl0ZW0ucGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHRcdChyZXNvbHZlZCB8fCAocmVzb2x2ZWQgPSBbXSkpLnB1c2goe1xuICBcdFx0XHRcdGl0ZW06IGl0ZW0sXG4gIFx0XHRcdFx0a2V5cGF0aDoga2V5cGF0aFxuICBcdFx0XHR9KTtcblxuICBcdFx0XHR1bnJlc29sdmVkLnNwbGljZShpLCAxKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAocmVzb2x2ZWQpIHtcbiAgXHRcdHJlc29sdmVkLmZvckVhY2goZ2xvYmFsX3J1bmxvb3BfX3Jlc29sdmUpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdsb2JhbF9ydW5sb29wX19yZXNvbHZlKHJlc29sdmVkKSB7XG4gIFx0cmVzb2x2ZWQuaXRlbS5yZXNvbHZlKHJlc29sdmVkLmtleXBhdGgpO1xuICB9XG5cbiAgdmFyIHF1ZXVlID0gW107XG5cbiAgdmFyIGFuaW1hdGlvbnMgPSB7XG4gIFx0dGljazogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGksIGFuaW1hdGlvbiwgbm93O1xuXG4gIFx0XHRub3cgPSB1dGlsc19nZXRUaW1lKCk7XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KCk7XG5cbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0XHRhbmltYXRpb24gPSBxdWV1ZVtpXTtcblxuICBcdFx0XHRpZiAoIWFuaW1hdGlvbi50aWNrKG5vdykpIHtcbiAgXHRcdFx0XHQvLyBhbmltYXRpb24gaXMgY29tcGxldGUsIHJlbW92ZSBpdCBmcm9tIHRoZSBzdGFjaywgYW5kIGRlY3JlbWVudCBpIHNvIHdlIGRvbid0IG1pc3Mgb25lXG4gIFx0XHRcdFx0cXVldWUuc3BsaWNlKGktLSwgMSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHRcdGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgXHRcdFx0ckFGKGFuaW1hdGlvbnMudGljayk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRhbmltYXRpb25zLnJ1bm5pbmcgPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0YWRkOiBmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gIFx0XHRxdWV1ZS5wdXNoKGFuaW1hdGlvbik7XG5cbiAgXHRcdGlmICghYW5pbWF0aW9ucy5ydW5uaW5nKSB7XG4gIFx0XHRcdGFuaW1hdGlvbnMucnVubmluZyA9IHRydWU7XG4gIFx0XHRcdHJBRihhbmltYXRpb25zLnRpY2spO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHQvLyBUT0RPIG9wdGltaXNlIHRoaXNcbiAgXHRhYm9ydDogZnVuY3Rpb24gKGtleXBhdGgsIHJvb3QpIHtcbiAgXHRcdHZhciBpID0gcXVldWUubGVuZ3RoLFxuICBcdFx0ICAgIGFuaW1hdGlvbjtcblxuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRhbmltYXRpb24gPSBxdWV1ZVtpXTtcblxuICBcdFx0XHRpZiAoYW5pbWF0aW9uLnJvb3QgPT09IHJvb3QgJiYgYW5pbWF0aW9uLmtleXBhdGggPT09IGtleXBhdGgpIHtcbiAgXHRcdFx0XHRhbmltYXRpb24uc3RvcCgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBzaGFyZWRfYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG5cbiAgdmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dmFyIGtleTtcblxuICBcdHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICBcdC8vIGZyb20gYW5kIHRvXG4gIFx0Zm9yIChrZXkgaW4gb3B0aW9ucykge1xuICBcdFx0aWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBcdFx0XHR0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0dGhpcy5pbnRlcnBvbGF0b3IgPSBzaGFyZWRfaW50ZXJwb2xhdGUodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLnJvb3QsIHRoaXMuaW50ZXJwb2xhdG9yKTtcbiAgXHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXG4gIFx0dGhpcy50aWNrKCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcbiAgXHR0aWNrOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgZWxhcHNlZCwgdCwgdmFsdWUsIHRpbWVOb3csIGluZGV4LCBrZXlwYXRoO1xuXG4gIFx0XHRrZXlwYXRoID0gdGhpcy5rZXlwYXRoO1xuXG4gIFx0XHRpZiAodGhpcy5ydW5uaW5nKSB7XG4gIFx0XHRcdHRpbWVOb3cgPSBEYXRlLm5vdygpO1xuICBcdFx0XHRlbGFwc2VkID0gdGltZU5vdyAtIHRoaXMuc3RhcnRUaW1lO1xuXG4gIFx0XHRcdGlmIChlbGFwc2VkID49IHRoaXMuZHVyYXRpb24pIHtcbiAgXHRcdFx0XHRpZiAoa2V5cGF0aCAhPT0gbnVsbCkge1xuICBcdFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcy5yb290KTtcbiAgXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KGtleXBhdGgsIHRoaXMudG8pO1xuICBcdFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKHRoaXMuc3RlcCkge1xuICBcdFx0XHRcdFx0dGhpcy5zdGVwKDEsIHRoaXMudG8pO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdHRoaXMuY29tcGxldGUodGhpcy50byk7XG5cbiAgXHRcdFx0XHRpbmRleCA9IHRoaXMucm9vdC5fYW5pbWF0aW9ucy5pbmRleE9mKHRoaXMpO1xuXG4gIFx0XHRcdFx0Ly8gVE9ETyBpbnZlc3RpZ2F0ZSB3aHkgdGhpcyBoYXBwZW5zXG4gIFx0XHRcdFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0XHRcdFx0d2FybklmRGVidWcoXCJBbmltYXRpb24gd2FzIG5vdCBmb3VuZFwiKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHR0aGlzLnJvb3QuX2FuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcblxuICBcdFx0XHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuICBcdFx0XHRcdHJldHVybiBmYWxzZTsgLy8gcmVtb3ZlIGZyb20gdGhlIHN0YWNrXG4gIFx0XHRcdH1cblxuICBcdFx0XHR0ID0gdGhpcy5lYXNpbmcgPyB0aGlzLmVhc2luZyhlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbikgOiBlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbjtcblxuICBcdFx0XHRpZiAoa2V5cGF0aCAhPT0gbnVsbCkge1xuICBcdFx0XHRcdHZhbHVlID0gdGhpcy5pbnRlcnBvbGF0b3IodCk7XG4gIFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcy5yb290KTtcbiAgXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldChrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAodGhpcy5zdGVwKSB7XG4gIFx0XHRcdFx0dGhpcy5zdGVwKHQsIHZhbHVlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiB0cnVlOyAvLyBrZWVwIGluIHRoZSBzdGFja1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZmFsc2U7IC8vIHJlbW92ZSBmcm9tIHRoZSBzdGFja1xuICBcdH0sXG5cbiAgXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgaW5kZXg7XG5cbiAgXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG4gIFx0XHRpbmRleCA9IHRoaXMucm9vdC5fYW5pbWF0aW9ucy5pbmRleE9mKHRoaXMpO1xuXG4gIFx0XHQvLyBUT0RPIGludmVzdGlnYXRlIHdoeSB0aGlzIGhhcHBlbnNcbiAgXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0d2FybklmRGVidWcoXCJBbmltYXRpb24gd2FzIG5vdCBmb3VuZFwiKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5yb290Ll9hbmltYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBhbmltYXRlX0FuaW1hdGlvbiA9IEFuaW1hdGlvbjtcblxuICB2YXIgcHJvdG90eXBlX2FuaW1hdGUgPSBSYWN0aXZlJGFuaW1hdGU7XG5cbiAgdmFyIG5vQW5pbWF0aW9uID0geyBzdG9wOiBub29wIH07XG4gIGZ1bmN0aW9uIFJhY3RpdmUkYW5pbWF0ZShrZXlwYXRoLCB0bywgb3B0aW9ucykge1xuICBcdHZhciBwcm9taXNlLCBmdWxmaWxQcm9taXNlLCBrLCBhbmltYXRpb24sIGFuaW1hdGlvbnMsIGVhc2luZywgZHVyYXRpb24sIHN0ZXAsIGNvbXBsZXRlLCBtYWtlVmFsdWVDb2xsZWN0b3IsIGN1cnJlbnRWYWx1ZXMsIGNvbGxlY3RWYWx1ZSwgZHVtbXksIGR1bW15T3B0aW9ucztcblxuICBcdHByb21pc2UgPSBuZXcgdXRpbHNfUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsKSB7XG4gIFx0XHRyZXR1cm4gZnVsZmlsUHJvbWlzZSA9IGZ1bGZpbDtcbiAgXHR9KTtcblxuICBcdC8vIGFuaW1hdGUgbXVsdGlwbGUga2V5cGF0aHNcbiAgXHRpZiAodHlwZW9mIGtleXBhdGggPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdG9wdGlvbnMgPSB0byB8fCB7fTtcbiAgXHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xuICBcdFx0ZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuXG4gIFx0XHRhbmltYXRpb25zID0gW107XG5cbiAgXHRcdC8vIHdlIGRvbid0IHdhbnQgdG8gcGFzcyB0aGUgYHN0ZXBgIGFuZCBgY29tcGxldGVgIGhhbmRsZXJzLCBhcyB0aGV5IHdpbGxcbiAgXHRcdC8vIHJ1biBmb3IgZWFjaCBhbmltYXRpb24hIFNvIGluc3RlYWQgd2UnbGwgc3RvcmUgdGhlIGhhbmRsZXJzIGFuZCBjcmVhdGVcbiAgXHRcdC8vIG91ciBvd24uLi5cbiAgXHRcdHN0ZXAgPSBvcHRpb25zLnN0ZXA7XG4gIFx0XHRjb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XG5cbiAgXHRcdGlmIChzdGVwIHx8IGNvbXBsZXRlKSB7XG4gIFx0XHRcdGN1cnJlbnRWYWx1ZXMgPSB7fTtcblxuICBcdFx0XHRvcHRpb25zLnN0ZXAgPSBudWxsO1xuICBcdFx0XHRvcHRpb25zLmNvbXBsZXRlID0gbnVsbDtcblxuICBcdFx0XHRtYWtlVmFsdWVDb2xsZWN0b3IgPSBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRcdHJldHVybiBmdW5jdGlvbiAodCwgdmFsdWUpIHtcbiAgXHRcdFx0XHRcdGN1cnJlbnRWYWx1ZXNba2V5cGF0aF0gPSB2YWx1ZTtcbiAgXHRcdFx0XHR9O1xuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRmb3IgKGsgaW4ga2V5cGF0aCkge1xuICBcdFx0XHRpZiAoa2V5cGF0aC5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICBcdFx0XHRcdGlmIChzdGVwIHx8IGNvbXBsZXRlKSB7XG4gIFx0XHRcdFx0XHRjb2xsZWN0VmFsdWUgPSBtYWtlVmFsdWVDb2xsZWN0b3Ioayk7XG4gIFx0XHRcdFx0XHRvcHRpb25zID0geyBlYXNpbmc6IGVhc2luZywgZHVyYXRpb246IGR1cmF0aW9uIH07XG5cbiAgXHRcdFx0XHRcdGlmIChzdGVwKSB7XG4gIFx0XHRcdFx0XHRcdG9wdGlvbnMuc3RlcCA9IGNvbGxlY3RWYWx1ZTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlID0gY29tcGxldGUgPyBjb2xsZWN0VmFsdWUgOiBub29wO1xuICBcdFx0XHRcdGFuaW1hdGlvbnMucHVzaChhbmltYXRlKHRoaXMsIGssIGtleXBhdGhba10sIG9wdGlvbnMpKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBDcmVhdGUgYSBkdW1teSBhbmltYXRpb24sIHRvIGZhY2lsaXRhdGUgc3RlcC9jb21wbGV0ZVxuICBcdFx0Ly8gY2FsbGJhY2tzLCBhbmQgUHJvbWlzZSBmdWxmaWxtZW50XG4gIFx0XHRkdW1teU9wdGlvbnMgPSB7IGVhc2luZzogZWFzaW5nLCBkdXJhdGlvbjogZHVyYXRpb24gfTtcblxuICBcdFx0aWYgKHN0ZXApIHtcbiAgXHRcdFx0ZHVtbXlPcHRpb25zLnN0ZXAgPSBmdW5jdGlvbiAodCkge1xuICBcdFx0XHRcdHJldHVybiBzdGVwKHQsIGN1cnJlbnRWYWx1ZXMpO1xuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoY29tcGxldGUpIHtcbiAgXHRcdFx0cHJvbWlzZS50aGVuKGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlKHQsIGN1cnJlbnRWYWx1ZXMpO1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0ZHVtbXlPcHRpb25zLmNvbXBsZXRlID0gZnVsZmlsUHJvbWlzZTtcblxuICBcdFx0ZHVtbXkgPSBhbmltYXRlKHRoaXMsIG51bGwsIG51bGwsIGR1bW15T3B0aW9ucyk7XG4gIFx0XHRhbmltYXRpb25zLnB1c2goZHVtbXkpO1xuXG4gIFx0XHRwcm9taXNlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHZhciBhbmltYXRpb247XG5cbiAgXHRcdFx0d2hpbGUgKGFuaW1hdGlvbiA9IGFuaW1hdGlvbnMucG9wKCkpIHtcbiAgXHRcdFx0XHRhbmltYXRpb24uc3RvcCgpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGR1bW15KSB7XG4gIFx0XHRcdFx0ZHVtbXkuc3RvcCgpO1xuICBcdFx0XHR9XG4gIFx0XHR9O1xuXG4gIFx0XHRyZXR1cm4gcHJvbWlzZTtcbiAgXHR9XG5cbiAgXHQvLyBhbmltYXRlIGEgc2luZ2xlIGtleXBhdGhcbiAgXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBcdGlmIChvcHRpb25zLmNvbXBsZXRlKSB7XG4gIFx0XHRwcm9taXNlLnRoZW4ob3B0aW9ucy5jb21wbGV0ZSk7XG4gIFx0fVxuXG4gIFx0b3B0aW9ucy5jb21wbGV0ZSA9IGZ1bGZpbFByb21pc2U7XG4gIFx0YW5pbWF0aW9uID0gYW5pbWF0ZSh0aGlzLCBrZXlwYXRoLCB0bywgb3B0aW9ucyk7XG5cbiAgXHRwcm9taXNlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gYW5pbWF0aW9uLnN0b3AoKTtcbiAgXHR9O1xuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gYW5pbWF0ZShyb290LCBrZXlwYXRoLCB0bywgb3B0aW9ucykge1xuICBcdHZhciBlYXNpbmcsIGR1cmF0aW9uLCBhbmltYXRpb24sIGZyb207XG5cbiAgXHRpZiAoa2V5cGF0aCkge1xuICBcdFx0a2V5cGF0aCA9IGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKTtcbiAgXHR9XG5cbiAgXHRpZiAoa2V5cGF0aCAhPT0gbnVsbCkge1xuICBcdFx0ZnJvbSA9IHJvb3Qudmlld21vZGVsLmdldChrZXlwYXRoKTtcbiAgXHR9XG5cbiAgXHQvLyBjYW5jZWwgYW55IGV4aXN0aW5nIGFuaW1hdGlvblxuICBcdC8vIFRPRE8gd2hhdCBhYm91dCB1cHN0cmVhbS9kb3duc3RyZWFtIGtleXBhdGhzP1xuICBcdHNoYXJlZF9hbmltYXRpb25zLmFib3J0KGtleXBhdGgsIHJvb3QpO1xuXG4gIFx0Ly8gZG9uJ3QgYm90aGVyIGFuaW1hdGluZyB2YWx1ZXMgdGhhdCBzdGF5IHRoZSBzYW1lXG4gIFx0aWYgKGlzRXF1YWwoZnJvbSwgdG8pKSB7XG4gIFx0XHRpZiAob3B0aW9ucy5jb21wbGV0ZSkge1xuICBcdFx0XHRvcHRpb25zLmNvbXBsZXRlKG9wdGlvbnMudG8pO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbm9BbmltYXRpb247XG4gIFx0fVxuXG4gIFx0Ly8gZWFzaW5nIGZ1bmN0aW9uXG4gIFx0aWYgKG9wdGlvbnMuZWFzaW5nKSB7XG4gIFx0XHRpZiAodHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRlYXNpbmcgPSByb290LmVhc2luZ1tvcHRpb25zLmVhc2luZ107XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0eXBlb2YgZWFzaW5nICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0ZWFzaW5nID0gbnVsbDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBkdXJhdGlvblxuICBcdGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkID8gNDAwIDogb3B0aW9ucy5kdXJhdGlvbjtcblxuICBcdC8vIFRPRE8gc3RvcmUga2V5cywgdXNlIGFuIGludGVybmFsIHNldCBtZXRob2RcbiAgXHRhbmltYXRpb24gPSBuZXcgYW5pbWF0ZV9BbmltYXRpb24oe1xuICBcdFx0a2V5cGF0aDoga2V5cGF0aCxcbiAgXHRcdGZyb206IGZyb20sXG4gIFx0XHR0bzogdG8sXG4gIFx0XHRyb290OiByb290LFxuICBcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuICBcdFx0ZWFzaW5nOiBlYXNpbmcsXG4gIFx0XHRpbnRlcnBvbGF0b3I6IG9wdGlvbnMuaW50ZXJwb2xhdG9yLFxuXG4gIFx0XHQvLyBUT0RPIHdyYXAgY2FsbGJhY2tzIGlmIG5lY2Vzc2FyeSwgdG8gdXNlIGluc3RhbmNlIGFzIGNvbnRleHRcbiAgXHRcdHN0ZXA6IG9wdGlvbnMuc3RlcCxcbiAgXHRcdGNvbXBsZXRlOiBvcHRpb25zLmNvbXBsZXRlXG4gIFx0fSk7XG5cbiAgXHRzaGFyZWRfYW5pbWF0aW9ucy5hZGQoYW5pbWF0aW9uKTtcbiAgXHRyb290Ll9hbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcblxuICBcdHJldHVybiBhbmltYXRpb247XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2RldGFjaCA9IFJhY3RpdmUkZGV0YWNoO1xuICB2YXIgcHJvdG90eXBlX2RldGFjaF9fZGV0YWNoSG9vayA9IG5ldyBob29rc19Ib29rKFwiZGV0YWNoXCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJGRldGFjaCgpIHtcbiAgXHRpZiAodGhpcy5kZXRhY2hlZCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZGV0YWNoZWQ7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZWwpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgdGhpcyk7XG4gIFx0fVxuICBcdHRoaXMuZGV0YWNoZWQgPSB0aGlzLmZyYWdtZW50LmRldGFjaCgpO1xuICBcdHByb3RvdHlwZV9kZXRhY2hfX2RldGFjaEhvb2suZmlyZSh0aGlzKTtcbiAgXHRyZXR1cm4gdGhpcy5kZXRhY2hlZDtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmluZCA9IFJhY3RpdmUkZmluZDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJGZpbmQoc2VsZWN0b3IpIHtcbiAgXHRpZiAoIXRoaXMuZWwpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoc2VsZWN0b3IpO1xuICB9XG5cbiAgdmFyIHRlc3QgPSBRdWVyeSR0ZXN0O1xuICBmdW5jdGlvbiBRdWVyeSR0ZXN0KGl0ZW0sIG5vRGlydHkpIHtcbiAgXHR2YXIgaXRlbU1hdGNoZXM7XG5cbiAgXHRpZiAodGhpcy5faXNDb21wb25lbnRRdWVyeSkge1xuICBcdFx0aXRlbU1hdGNoZXMgPSAhdGhpcy5zZWxlY3RvciB8fCBpdGVtLm5hbWUgPT09IHRoaXMuc2VsZWN0b3I7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGl0ZW1NYXRjaGVzID0gaXRlbS5ub2RlID8gbWF0Y2hlcyhpdGVtLm5vZGUsIHRoaXMuc2VsZWN0b3IpIDogbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoaXRlbU1hdGNoZXMpIHtcbiAgXHRcdHRoaXMucHVzaChpdGVtLm5vZGUgfHwgaXRlbS5pbnN0YW5jZSk7XG5cbiAgXHRcdGlmICghbm9EaXJ0eSkge1xuICBcdFx0XHR0aGlzLl9tYWtlRGlydHkoKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuICB9XG5cbiAgdmFyIG1ha2VRdWVyeV9jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gIFx0dmFyIGxpdmVRdWVyaWVzLCBzZWxlY3RvciwgaW5kZXg7XG5cbiAgXHRsaXZlUXVlcmllcyA9IHRoaXMuX3Jvb3RbdGhpcy5faXNDb21wb25lbnRRdWVyeSA/IFwibGl2ZUNvbXBvbmVudFF1ZXJpZXNcIiA6IFwibGl2ZVF1ZXJpZXNcIl07XG4gIFx0c2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuXG4gIFx0aW5kZXggPSBsaXZlUXVlcmllcy5pbmRleE9mKHNlbGVjdG9yKTtcblxuICBcdGlmIChpbmRleCAhPT0gLTEpIHtcbiAgXHRcdGxpdmVRdWVyaWVzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRsaXZlUXVlcmllc1tzZWxlY3Rvcl0gPSBudWxsO1xuICBcdH1cbiAgfTtcblxuICB2YXIgc29ydEJ5SXRlbVBvc2l0aW9uID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgXHR2YXIgYW5jZXN0cnlBLCBhbmNlc3RyeUIsIG9sZGVzdEEsIG9sZGVzdEIsIG11dHVhbEFuY2VzdG9yLCBpbmRleEEsIGluZGV4QiwgZnJhZ21lbnRzLCBmcmFnbWVudEEsIGZyYWdtZW50QjtcblxuICBcdGFuY2VzdHJ5QSA9IGdldEFuY2VzdHJ5KGEuY29tcG9uZW50IHx8IGEuX3JhY3RpdmUucHJveHkpO1xuICBcdGFuY2VzdHJ5QiA9IGdldEFuY2VzdHJ5KGIuY29tcG9uZW50IHx8IGIuX3JhY3RpdmUucHJveHkpO1xuXG4gIFx0b2xkZXN0QSA9IGxhc3RJdGVtKGFuY2VzdHJ5QSk7XG4gIFx0b2xkZXN0QiA9IGxhc3RJdGVtKGFuY2VzdHJ5Qik7XG5cbiAgXHQvLyByZW1vdmUgaXRlbXMgZnJvbSB0aGUgZW5kIG9mIGJvdGggYW5jZXN0cmllcyBhcyBsb25nIGFzIHRoZXkgYXJlIGlkZW50aWNhbFxuICBcdC8vIC0gdGhlIGZpbmFsIG9uZSByZW1vdmVkIGlzIHRoZSBjbG9zZXN0IG11dHVhbCBhbmNlc3RvclxuICBcdHdoaWxlIChvbGRlc3RBICYmIG9sZGVzdEEgPT09IG9sZGVzdEIpIHtcbiAgXHRcdGFuY2VzdHJ5QS5wb3AoKTtcbiAgXHRcdGFuY2VzdHJ5Qi5wb3AoKTtcblxuICBcdFx0bXV0dWFsQW5jZXN0b3IgPSBvbGRlc3RBO1xuXG4gIFx0XHRvbGRlc3RBID0gbGFzdEl0ZW0oYW5jZXN0cnlBKTtcbiAgXHRcdG9sZGVzdEIgPSBsYXN0SXRlbShhbmNlc3RyeUIpO1xuICBcdH1cblxuICBcdC8vIG5vdyB0aGF0IHdlIGhhdmUgdGhlIG11dHVhbCBhbmNlc3Rvciwgd2UgY2FuIGZpbmQgd2hpY2ggaXMgZWFybGllc3RcbiAgXHRvbGRlc3RBID0gb2xkZXN0QS5jb21wb25lbnQgfHwgb2xkZXN0QTtcbiAgXHRvbGRlc3RCID0gb2xkZXN0Qi5jb21wb25lbnQgfHwgb2xkZXN0QjtcblxuICBcdGZyYWdtZW50QSA9IG9sZGVzdEEucGFyZW50RnJhZ21lbnQ7XG4gIFx0ZnJhZ21lbnRCID0gb2xkZXN0Qi5wYXJlbnRGcmFnbWVudDtcblxuICBcdC8vIGlmIGJvdGggaXRlbXMgc2hhcmUgYSBwYXJlbnQgZnJhZ21lbnQsIG91ciBqb2IgaXMgZWFzeVxuICBcdGlmIChmcmFnbWVudEEgPT09IGZyYWdtZW50Qikge1xuICBcdFx0aW5kZXhBID0gZnJhZ21lbnRBLml0ZW1zLmluZGV4T2Yob2xkZXN0QSk7XG4gIFx0XHRpbmRleEIgPSBmcmFnbWVudEIuaXRlbXMuaW5kZXhPZihvbGRlc3RCKTtcblxuICBcdFx0Ly8gaWYgaXQncyB0aGUgc2FtZSBpbmRleCwgaXQgbWVhbnMgb25lIGNvbnRhaW5zIHRoZSBvdGhlcixcbiAgXHRcdC8vIHNvIHdlIHNlZSB3aGljaCBoYXMgdGhlIGxvbmdlc3QgYW5jZXN0cnlcbiAgXHRcdHJldHVybiBpbmRleEEgLSBpbmRleEIgfHwgYW5jZXN0cnlBLmxlbmd0aCAtIGFuY2VzdHJ5Qi5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgbXV0dWFsIGFuY2VzdG9yIGlzIGEgc2VjdGlvbiwgd2UgZmlyc3QgdGVzdCB0byBzZWUgd2hpY2ggc2VjdGlvblxuICBcdC8vIGZyYWdtZW50IGNvbWVzIGZpcnN0XG4gIFx0aWYgKGZyYWdtZW50cyA9IG11dHVhbEFuY2VzdG9yLmZyYWdtZW50cykge1xuICBcdFx0aW5kZXhBID0gZnJhZ21lbnRzLmluZGV4T2YoZnJhZ21lbnRBKTtcbiAgXHRcdGluZGV4QiA9IGZyYWdtZW50cy5pbmRleE9mKGZyYWdtZW50Qik7XG5cbiAgXHRcdHJldHVybiBpbmRleEEgLSBpbmRleEIgfHwgYW5jZXN0cnlBLmxlbmd0aCAtIGFuY2VzdHJ5Qi5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0dGhyb3cgbmV3IEVycm9yKFwiQW4gdW5leHBlY3RlZCBjb25kaXRpb24gd2FzIG1ldCB3aGlsZSBjb21wYXJpbmcgdGhlIHBvc2l0aW9uIG9mIHR3byBjb21wb25lbnRzLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vUmFjdGl2ZUpTL1JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIVwiKTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRQYXJlbnQoaXRlbSkge1xuICBcdHZhciBwYXJlbnRGcmFnbWVudDtcblxuICBcdGlmIChwYXJlbnRGcmFnbWVudCA9IGl0ZW0ucGFyZW50RnJhZ21lbnQpIHtcbiAgXHRcdHJldHVybiBwYXJlbnRGcmFnbWVudC5vd25lcjtcbiAgXHR9XG5cbiAgXHRpZiAoaXRlbS5jb21wb25lbnQgJiYgKHBhcmVudEZyYWdtZW50ID0gaXRlbS5jb21wb25lbnQucGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHRyZXR1cm4gcGFyZW50RnJhZ21lbnQub3duZXI7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QW5jZXN0cnkoaXRlbSkge1xuICBcdHZhciBhbmNlc3RyeSwgYW5jZXN0b3I7XG5cbiAgXHRhbmNlc3RyeSA9IFtpdGVtXTtcblxuICBcdGFuY2VzdG9yID0gZ2V0UGFyZW50KGl0ZW0pO1xuXG4gIFx0d2hpbGUgKGFuY2VzdG9yKSB7XG4gIFx0XHRhbmNlc3RyeS5wdXNoKGFuY2VzdG9yKTtcbiAgXHRcdGFuY2VzdG9yID0gZ2V0UGFyZW50KGFuY2VzdG9yKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYW5jZXN0cnk7XG4gIH1cblxuICB2YXIgc29ydEJ5RG9jdW1lbnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBvdGhlck5vZGUpIHtcbiAgXHR2YXIgYml0bWFzaztcblxuICBcdGlmIChub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gIFx0XHRiaXRtYXNrID0gbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihvdGhlck5vZGUpO1xuICBcdFx0cmV0dXJuIGJpdG1hc2sgJiAyID8gMSA6IC0xO1xuICBcdH1cblxuICBcdC8vIEluIG9sZCBJRSwgd2UgY2FuIHBpZ2d5IGJhY2sgb24gdGhlIG1lY2hhbmlzbSBmb3JcbiAgXHQvLyBjb21wYXJpbmcgY29tcG9uZW50IHBvc2l0aW9uc1xuICBcdHJldHVybiBzb3J0QnlJdGVtUG9zaXRpb24obm9kZSwgb3RoZXJOb2RlKTtcbiAgfTtcblxuICB2YXIgc29ydCA9IGZ1bmN0aW9uICgpIHtcbiAgXHR0aGlzLnNvcnQodGhpcy5faXNDb21wb25lbnRRdWVyeSA/IHNvcnRCeUl0ZW1Qb3NpdGlvbiA6IHNvcnRCeURvY3VtZW50UG9zaXRpb24pO1xuICBcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gIH07XG5cbiAgdmFyIG1ha2VRdWVyeV9kaXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0aWYgKCF0aGlzLl9kaXJ0eSkge1xuICBcdFx0dGhpcy5fZGlydHkgPSB0cnVlO1xuXG4gIFx0XHQvLyBPbmNlIHRoZSBET00gaGFzIGJlZW4gdXBkYXRlZCwgZW5zdXJlIHRoZSBxdWVyeVxuICBcdFx0Ly8gaXMgY29ycmVjdGx5IG9yZGVyZWRcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdF90aGlzLl9zb3J0KCk7XG4gIFx0XHR9KTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIHJlbW92ZSA9IGZ1bmN0aW9uIChub2RlT3JDb21wb25lbnQpIHtcbiAgXHR2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YodGhpcy5faXNDb21wb25lbnRRdWVyeSA/IG5vZGVPckNvbXBvbmVudC5pbnN0YW5jZSA6IG5vZGVPckNvbXBvbmVudCk7XG5cbiAgXHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHR0aGlzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBfbWFrZVF1ZXJ5ID0gbWFrZVF1ZXJ5O1xuICBmdW5jdGlvbiBtYWtlUXVlcnkocmFjdGl2ZSwgc2VsZWN0b3IsIGxpdmUsIGlzQ29tcG9uZW50UXVlcnkpIHtcbiAgXHR2YXIgcXVlcnkgPSBbXTtcblxuICBcdGRlZmluZVByb3BlcnRpZXMocXVlcnksIHtcbiAgXHRcdHNlbGVjdG9yOiB7IHZhbHVlOiBzZWxlY3RvciB9LFxuICBcdFx0bGl2ZTogeyB2YWx1ZTogbGl2ZSB9LFxuXG4gIFx0XHRfaXNDb21wb25lbnRRdWVyeTogeyB2YWx1ZTogaXNDb21wb25lbnRRdWVyeSB9LFxuICBcdFx0X3Rlc3Q6IHsgdmFsdWU6IHRlc3QgfVxuICBcdH0pO1xuXG4gIFx0aWYgKCFsaXZlKSB7XG4gIFx0XHRyZXR1cm4gcXVlcnk7XG4gIFx0fVxuXG4gIFx0ZGVmaW5lUHJvcGVydGllcyhxdWVyeSwge1xuICBcdFx0Y2FuY2VsOiB7IHZhbHVlOiBtYWtlUXVlcnlfY2FuY2VsIH0sXG5cbiAgXHRcdF9yb290OiB7IHZhbHVlOiByYWN0aXZlIH0sXG4gIFx0XHRfc29ydDogeyB2YWx1ZTogc29ydCB9LFxuICBcdFx0X21ha2VEaXJ0eTogeyB2YWx1ZTogbWFrZVF1ZXJ5X2RpcnR5IH0sXG4gIFx0XHRfcmVtb3ZlOiB7IHZhbHVlOiByZW1vdmUgfSxcblxuICBcdFx0X2RpcnR5OiB7IHZhbHVlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUgfVxuICBcdH0pO1xuXG4gIFx0cmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maW5kQWxsID0gUmFjdGl2ZSRmaW5kQWxsO1xuICBmdW5jdGlvbiBSYWN0aXZlJGZpbmRBbGwoc2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgXHR2YXIgbGl2ZVF1ZXJpZXMsIHF1ZXJ5O1xuXG4gIFx0aWYgKCF0aGlzLmVsKSB7XG4gIFx0XHRyZXR1cm4gW107XG4gIFx0fVxuXG4gIFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFx0bGl2ZVF1ZXJpZXMgPSB0aGlzLl9saXZlUXVlcmllcztcblxuICBcdC8vIFNob3J0Y3V0OiBpZiB3ZSdyZSBtYWludGFpbmluZyBhIGxpdmUgcXVlcnkgd2l0aCB0aGlzXG4gIFx0Ly8gc2VsZWN0b3IsIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHBhcmFsbGVsIERPTVxuICBcdGlmIChxdWVyeSA9IGxpdmVRdWVyaWVzW3NlbGVjdG9yXSkge1xuXG4gIFx0XHQvLyBFaXRoZXIgcmV0dXJuIHRoZSBleGFjdCBzYW1lIHF1ZXJ5LCBvciAoaWYgbm90IGxpdmUpIGEgc25hcHNob3RcbiAgXHRcdHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMubGl2ZSA/IHF1ZXJ5IDogcXVlcnkuc2xpY2UoKTtcbiAgXHR9XG5cbiAgXHRxdWVyeSA9IF9tYWtlUXVlcnkodGhpcywgc2VsZWN0b3IsICEhb3B0aW9ucy5saXZlLCBmYWxzZSk7XG5cbiAgXHQvLyBBZGQgdGhpcyB0byB0aGUgbGlzdCBvZiBsaXZlIHF1ZXJpZXMgUmFjdGl2ZSBuZWVkcyB0byBtYWludGFpbixcbiAgXHQvLyBpZiBhcHBsaWNhYmxlXG4gIFx0aWYgKHF1ZXJ5LmxpdmUpIHtcbiAgXHRcdGxpdmVRdWVyaWVzLnB1c2goc2VsZWN0b3IpO1xuICBcdFx0bGl2ZVF1ZXJpZXNbXCJfXCIgKyBzZWxlY3Rvcl0gPSBxdWVyeTtcbiAgXHR9XG5cbiAgXHR0aGlzLmZyYWdtZW50LmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHRyZXR1cm4gcXVlcnk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzID0gUmFjdGl2ZSRmaW5kQWxsQ29tcG9uZW50cztcbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQWxsQ29tcG9uZW50cyhzZWxlY3Rvciwgb3B0aW9ucykge1xuICBcdHZhciBsaXZlUXVlcmllcywgcXVlcnk7XG5cbiAgXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgXHRsaXZlUXVlcmllcyA9IHRoaXMuX2xpdmVDb21wb25lbnRRdWVyaWVzO1xuXG4gIFx0Ly8gU2hvcnRjdXQ6IGlmIHdlJ3JlIG1haW50YWluaW5nIGEgbGl2ZSBxdWVyeSB3aXRoIHRoaXNcbiAgXHQvLyBzZWxlY3Rvciwgd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSB0aGUgcGFyYWxsZWwgRE9NXG4gIFx0aWYgKHF1ZXJ5ID0gbGl2ZVF1ZXJpZXNbc2VsZWN0b3JdKSB7XG5cbiAgXHRcdC8vIEVpdGhlciByZXR1cm4gdGhlIGV4YWN0IHNhbWUgcXVlcnksIG9yIChpZiBub3QgbGl2ZSkgYSBzbmFwc2hvdFxuICBcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5saXZlID8gcXVlcnkgOiBxdWVyeS5zbGljZSgpO1xuICBcdH1cblxuICBcdHF1ZXJ5ID0gX21ha2VRdWVyeSh0aGlzLCBzZWxlY3RvciwgISFvcHRpb25zLmxpdmUsIHRydWUpO1xuXG4gIFx0Ly8gQWRkIHRoaXMgdG8gdGhlIGxpc3Qgb2YgbGl2ZSBxdWVyaWVzIFJhY3RpdmUgbmVlZHMgdG8gbWFpbnRhaW4sXG4gIFx0Ly8gaWYgYXBwbGljYWJsZVxuICBcdGlmIChxdWVyeS5saXZlKSB7XG4gIFx0XHRsaXZlUXVlcmllcy5wdXNoKHNlbGVjdG9yKTtcbiAgXHRcdGxpdmVRdWVyaWVzW1wiX1wiICsgc2VsZWN0b3JdID0gcXVlcnk7XG4gIFx0fVxuXG4gIFx0dGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmluZENvbXBvbmVudCA9IFJhY3RpdmUkZmluZENvbXBvbmVudDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJGZpbmRDb21wb25lbnQoc2VsZWN0b3IpIHtcbiAgXHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KHNlbGVjdG9yKTtcbiAgfVxuXG4gIHZhciBmaW5kQ29udGFpbmVyID0gUmFjdGl2ZSRmaW5kQ29udGFpbmVyO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZENvbnRhaW5lcihzZWxlY3Rvcikge1xuICBcdGlmICh0aGlzLmNvbnRhaW5lcikge1xuICBcdFx0aWYgKHRoaXMuY29udGFpbmVyLmNvbXBvbmVudCAmJiB0aGlzLmNvbnRhaW5lci5jb21wb25lbnQubmFtZSA9PT0gc2VsZWN0b3IpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyLmZpbmRDb250YWluZXIoc2VsZWN0b3IpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGZpbmRQYXJlbnQgPSBSYWN0aXZlJGZpbmRQYXJlbnQ7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kUGFyZW50KHNlbGVjdG9yKSB7XG5cbiAgXHRpZiAodGhpcy5wYXJlbnQpIHtcbiAgXHRcdGlmICh0aGlzLnBhcmVudC5jb21wb25lbnQgJiYgdGhpcy5wYXJlbnQuY29tcG9uZW50Lm5hbWUgPT09IHNlbGVjdG9yKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLnBhcmVudDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLnBhcmVudC5maW5kUGFyZW50KHNlbGVjdG9yKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBldmVudFN0YWNrID0ge1xuICBcdGVucXVldWU6IGZ1bmN0aW9uIChyYWN0aXZlLCBldmVudCkge1xuICBcdFx0aWYgKHJhY3RpdmUuZXZlbnQpIHtcbiAgXHRcdFx0cmFjdGl2ZS5fZXZlbnRRdWV1ZSA9IHJhY3RpdmUuX2V2ZW50UXVldWUgfHwgW107XG4gIFx0XHRcdHJhY3RpdmUuX2V2ZW50UXVldWUucHVzaChyYWN0aXZlLmV2ZW50KTtcbiAgXHRcdH1cbiAgXHRcdHJhY3RpdmUuZXZlbnQgPSBldmVudDtcbiAgXHR9LFxuICBcdGRlcXVldWU6IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG4gIFx0XHRpZiAocmFjdGl2ZS5fZXZlbnRRdWV1ZSAmJiByYWN0aXZlLl9ldmVudFF1ZXVlLmxlbmd0aCkge1xuICBcdFx0XHRyYWN0aXZlLmV2ZW50ID0gcmFjdGl2ZS5fZXZlbnRRdWV1ZS5wb3AoKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGRlbGV0ZSByYWN0aXZlLmV2ZW50O1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgc2hhcmVkX2V2ZW50U3RhY2sgPSBldmVudFN0YWNrO1xuXG4gIHZhciBzaGFyZWRfZmlyZUV2ZW50ID0gZmlyZUV2ZW50O1xuXG4gIGZ1bmN0aW9uIGZpcmVFdmVudChyYWN0aXZlLCBldmVudE5hbWUpIHtcbiAgXHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cbiAgXHRpZiAoIWV2ZW50TmFtZSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmICghb3B0aW9ucy5ldmVudCkge1xuICBcdFx0b3B0aW9ucy5ldmVudCA9IHtcbiAgXHRcdFx0bmFtZTogZXZlbnROYW1lLFxuICBcdFx0XHQvLyB1bnRpbCBldmVudCBub3QgaW5jbHVkZWQgYXMgYXJndW1lbnQgZGVmYXVsdFxuICBcdFx0XHRfbm9Bcmc6IHRydWVcbiAgXHRcdH07XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG9wdGlvbnMuZXZlbnQubmFtZSA9IGV2ZW50TmFtZTtcbiAgXHR9XG5cbiAgXHR2YXIgZXZlbnROYW1lcyA9IGdldEtleXBhdGgoZXZlbnROYW1lKS53aWxkY2FyZE1hdGNoZXMoKTtcbiAgXHRmaXJlRXZlbnRBcyhyYWN0aXZlLCBldmVudE5hbWVzLCBvcHRpb25zLmV2ZW50LCBvcHRpb25zLmFyZ3MsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUV2ZW50QXMocmFjdGl2ZSwgZXZlbnROYW1lcywgZXZlbnQsIGFyZ3MpIHtcbiAgXHR2YXIgaW5pdGlhbEZpcmUgPSBhcmd1bWVudHNbNF0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzRdO1xuXG4gIFx0dmFyIHN1YnNjcmliZXJzLFxuICBcdCAgICBpLFxuICBcdCAgICBidWJibGUgPSB0cnVlO1xuXG4gIFx0c2hhcmVkX2V2ZW50U3RhY2suZW5xdWV1ZShyYWN0aXZlLCBldmVudCk7XG5cbiAgXHRmb3IgKGkgPSBldmVudE5hbWVzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgXHRcdHN1YnNjcmliZXJzID0gcmFjdGl2ZS5fc3Vic1tldmVudE5hbWVzW2ldXTtcblxuICBcdFx0aWYgKHN1YnNjcmliZXJzKSB7XG4gIFx0XHRcdGJ1YmJsZSA9IG5vdGlmeVN1YnNjcmliZXJzKHJhY3RpdmUsIHN1YnNjcmliZXJzLCBldmVudCwgYXJncykgJiYgYnViYmxlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHNoYXJlZF9ldmVudFN0YWNrLmRlcXVldWUocmFjdGl2ZSk7XG5cbiAgXHRpZiAocmFjdGl2ZS5wYXJlbnQgJiYgYnViYmxlKSB7XG5cbiAgXHRcdGlmIChpbml0aWFsRmlyZSAmJiByYWN0aXZlLmNvbXBvbmVudCkge1xuICBcdFx0XHR2YXIgZnVsbE5hbWUgPSByYWN0aXZlLmNvbXBvbmVudC5uYW1lICsgXCIuXCIgKyBldmVudE5hbWVzW2V2ZW50TmFtZXMubGVuZ3RoIC0gMV07XG4gIFx0XHRcdGV2ZW50TmFtZXMgPSBnZXRLZXlwYXRoKGZ1bGxOYW1lKS53aWxkY2FyZE1hdGNoZXMoKTtcblxuICBcdFx0XHRpZiAoZXZlbnQpIHtcbiAgXHRcdFx0XHRldmVudC5jb21wb25lbnQgPSByYWN0aXZlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGZpcmVFdmVudEFzKHJhY3RpdmUucGFyZW50LCBldmVudE5hbWVzLCBldmVudCwgYXJncyk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5U3Vic2NyaWJlcnMocmFjdGl2ZSwgc3Vic2NyaWJlcnMsIGV2ZW50LCBhcmdzKSB7XG4gIFx0dmFyIG9yaWdpbmFsRXZlbnQgPSBudWxsLFxuICBcdCAgICBzdG9wRXZlbnQgPSBmYWxzZTtcblxuICBcdGlmIChldmVudCAmJiAhZXZlbnQuX25vQXJnKSB7XG4gIFx0XHRhcmdzID0gW2V2ZW50XS5jb25jYXQoYXJncyk7XG4gIFx0fVxuXG4gIFx0Ly8gc3Vic2NyaWJlcnMgY2FuIGJlIG1vZGlmaWVkIGluZmxpZ2h0LCBlLmcuIFwib25jZVwiIGZ1bmN0aW9uYWxpdHlcbiAgXHQvLyBzbyB3ZSBuZWVkIHRvIGNvcHkgdG8gbWFrZSBzdXJlIGV2ZXJ5b25lIGdldHMgY2FsbGVkXG4gIFx0c3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5zbGljZSgpO1xuXG4gIFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHN1YnNjcmliZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRpZiAoc3Vic2NyaWJlcnNbaV0uYXBwbHkocmFjdGl2ZSwgYXJncykgPT09IGZhbHNlKSB7XG4gIFx0XHRcdHN0b3BFdmVudCA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKGV2ZW50ICYmICFldmVudC5fbm9BcmcgJiYgc3RvcEV2ZW50ICYmIChvcmlnaW5hbEV2ZW50ID0gZXZlbnQub3JpZ2luYWwpKSB7XG4gIFx0XHRvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0ICYmIG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgXHRcdG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uICYmIG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuICFzdG9wRXZlbnQ7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2ZpcmUgPSBSYWN0aXZlJGZpcmU7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmlyZShldmVudE5hbWUpIHtcblxuICBcdHZhciBvcHRpb25zID0ge1xuICBcdFx0YXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICBcdH07XG5cbiAgXHRzaGFyZWRfZmlyZUV2ZW50KHRoaXMsIGV2ZW50TmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX2dldCA9IFJhY3RpdmUkZ2V0O1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgXHRjYXB0dXJlOiB0cnVlLCAvLyB0b3AtbGV2ZWwgY2FsbHMgc2hvdWxkIGJlIGludGVyY2VwdGVkXG4gIFx0bm9VbndyYXA6IHRydWUsIC8vIHdyYXBwZWQgdmFsdWVzIHNob3VsZCBOT1QgYmUgdW53cmFwcGVkXG4gIFx0ZnVsbFJvb3RHZXQ6IHRydWUgLy8gcm9vdCBnZXQgc2hvdWxkIHJldHVybiBtYXBwaW5nc1xuICB9O1xuICBmdW5jdGlvbiBSYWN0aXZlJGdldChrZXlwYXRoKSB7XG4gIFx0dmFyIHZhbHVlO1xuXG4gIFx0a2V5cGF0aCA9IGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKTtcbiAgXHR2YWx1ZSA9IHRoaXMudmlld21vZGVsLmdldChrZXlwYXRoLCBvcHRpb25zKTtcblxuICBcdC8vIENyZWF0ZSBpbnRlci1jb21wb25lbnQgYmluZGluZywgaWYgbmVjZXNzYXJ5XG4gIFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgdGhpcy5wYXJlbnQgJiYgIXRoaXMuaXNvbGF0ZWQpIHtcbiAgXHRcdGlmIChzaGFyZWRfcmVzb2x2ZVJlZih0aGlzLCBrZXlwYXRoLnN0ciwgdGhpcy5jb21wb25lbnQucGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHRcdC8vIGNyZWF0ZXMgYmluZGluZyBhcyBzaWRlLWVmZmVjdCwgaWYgYXBwcm9wcmlhdGVcbiAgXHRcdFx0dmFsdWUgPSB0aGlzLnZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdmFyIGluc2VydCA9IFJhY3RpdmUkaW5zZXJ0O1xuXG4gIHZhciBpbnNlcnRIb29rID0gbmV3IGhvb2tzX0hvb2soXCJpbnNlcnRcIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkaW5zZXJ0KHRhcmdldCwgYW5jaG9yKSB7XG4gIFx0aWYgKCF0aGlzLmZyYWdtZW50LnJlbmRlcmVkKSB7XG4gIFx0XHQvLyBUT0RPIGNyZWF0ZSwgYW5kIGxpbmsgdG8sIGRvY3VtZW50YXRpb24gZXhwbGFpbmluZyB0aGlzXG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUaGUgQVBJIGhhcyBjaGFuZ2VkIC0geW91IG11c3QgY2FsbCBgcmFjdGl2ZS5yZW5kZXIodGFyZ2V0WywgYW5jaG9yXSlgIHRvIHJlbmRlciB5b3VyIFJhY3RpdmUgaW5zdGFuY2UuIE9uY2UgcmVuZGVyZWQgeW91IGNhbiB1c2UgYHJhY3RpdmUuaW5zZXJ0KClgLlwiKTtcbiAgXHR9XG5cbiAgXHR0YXJnZXQgPSBnZXRFbGVtZW50KHRhcmdldCk7XG4gIFx0YW5jaG9yID0gZ2V0RWxlbWVudChhbmNob3IpIHx8IG51bGw7XG5cbiAgXHRpZiAoIXRhcmdldCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3Qgc3BlY2lmeSBhIHZhbGlkIHRhcmdldCB0byBpbnNlcnQgaW50b1wiKTtcbiAgXHR9XG5cbiAgXHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuZGV0YWNoKCksIGFuY2hvcik7XG4gIFx0dGhpcy5lbCA9IHRhcmdldDtcblxuICBcdCh0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fIHx8ICh0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fID0gW10pKS5wdXNoKHRoaXMpO1xuICBcdHRoaXMuZGV0YWNoZWQgPSBudWxsO1xuXG4gIFx0ZmlyZUluc2VydEhvb2sodGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlSW5zZXJ0SG9vayhyYWN0aXZlKSB7XG4gIFx0aW5zZXJ0SG9vay5maXJlKHJhY3RpdmUpO1xuXG4gIFx0cmFjdGl2ZS5maW5kQWxsQ29tcG9uZW50cyhcIipcIikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgXHRcdGZpcmVJbnNlcnRIb29rKGNoaWxkLmluc3RhbmNlKTtcbiAgXHR9KTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfbWVyZ2UgPSBSYWN0aXZlJG1lcmdlO1xuICBmdW5jdGlvbiBSYWN0aXZlJG1lcmdlKGtleXBhdGgsIGFycmF5LCBvcHRpb25zKSB7XG4gIFx0dmFyIGN1cnJlbnRBcnJheSwgcHJvbWlzZTtcblxuICBcdGtleXBhdGggPSBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSk7XG4gIFx0Y3VycmVudEFycmF5ID0gdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0Ly8gSWYgZWl0aGVyIHRoZSBleGlzdGluZyB2YWx1ZSBvciB0aGUgbmV3IHZhbHVlIGlzbid0IGFuXG4gIFx0Ly8gYXJyYXksIGp1c3QgZG8gYSByZWd1bGFyIHNldFxuICBcdGlmICghaXNBcnJheShjdXJyZW50QXJyYXkpIHx8ICFpc0FycmF5KGFycmF5KSkge1xuICBcdFx0cmV0dXJuIHRoaXMuc2V0KGtleXBhdGgsIGFycmF5LCBvcHRpb25zICYmIG9wdGlvbnMuY29tcGxldGUpO1xuICBcdH1cblxuICBcdC8vIE1hbmFnZSB0cmFuc2l0aW9uc1xuICBcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcbiAgXHR0aGlzLnZpZXdtb2RlbC5tZXJnZShrZXlwYXRoLCBjdXJyZW50QXJyYXksIGFycmF5LCBvcHRpb25zKTtcbiAgXHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgdmFyIE9ic2VydmVyID0gZnVuY3Rpb24gKHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcbiAgXHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgXHR0aGlzLmRlZmVyID0gb3B0aW9ucy5kZWZlcjtcblxuICBcdC8vIGRlZmF1bHQgdG8gcm9vdCBhcyBjb250ZXh0LCBidXQgYWxsb3cgaXQgdG8gYmUgb3ZlcnJpZGRlblxuICBcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID8gb3B0aW9ucy5jb250ZXh0IDogcmFjdGl2ZTtcbiAgfTtcblxuICBPYnNlcnZlci5wcm90b3R5cGUgPSB7XG4gIFx0aW5pdDogZnVuY3Rpb24gKGltbWVkaWF0ZSkge1xuICBcdFx0dGhpcy52YWx1ZSA9IHRoaXMucm9vdC5nZXQodGhpcy5rZXlwYXRoLnN0cik7XG5cbiAgXHRcdGlmIChpbW1lZGlhdGUgIT09IGZhbHNlKSB7XG4gIFx0XHRcdHRoaXMudXBkYXRlKCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLm9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0aWYgKCFpc0VxdWFsKHZhbHVlLCB0aGlzLnZhbHVlKSkge1xuICBcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdFx0aWYgKHRoaXMuZGVmZXIgJiYgdGhpcy5yZWFkeSkge1xuICBcdFx0XHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gX3RoaXMudXBkYXRlKCk7XG4gIFx0XHRcdFx0fSk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAgXHRcdGlmICh0aGlzLnVwZGF0aW5nKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cbiAgXHRcdHRoaXMuY2FsbGJhY2suY2FsbCh0aGlzLmNvbnRleHQsIHRoaXMudmFsdWUsIHRoaXMub2xkVmFsdWUsIHRoaXMua2V5cGF0aC5zdHIpO1xuICBcdFx0dGhpcy5vbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG5cbiAgXHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIG9ic2VydmVfT2JzZXJ2ZXIgPSBPYnNlcnZlcjtcblxuICB2YXIgb2JzZXJ2ZV9nZXRQYXR0ZXJuID0gZ2V0UGF0dGVybjtcbiAgZnVuY3Rpb24gZ2V0UGF0dGVybihyYWN0aXZlLCBwYXR0ZXJuKSB7XG4gIFx0dmFyIG1hdGNoaW5nS2V5cGF0aHMsIHZhbHVlcztcblxuICBcdG1hdGNoaW5nS2V5cGF0aHMgPSBnZXRNYXRjaGluZ0tleXBhdGhzKHJhY3RpdmUsIHBhdHRlcm4pO1xuXG4gIFx0dmFsdWVzID0ge307XG4gIFx0bWF0Y2hpbmdLZXlwYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YWx1ZXNba2V5cGF0aC5zdHJdID0gcmFjdGl2ZS5nZXQoa2V5cGF0aC5zdHIpO1xuICBcdH0pO1xuXG4gIFx0cmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIHZhciBQYXR0ZXJuT2JzZXJ2ZXIsXG4gICAgICBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICBQYXR0ZXJuT2JzZXJ2ZXIgPSBmdW5jdGlvbiAocmFjdGl2ZSwga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuXG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICBcdHRoaXMuZGVmZXIgPSBvcHRpb25zLmRlZmVyO1xuXG4gIFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcbiAgXHR0aGlzLnJlZ2V4ID0gbmV3IFJlZ0V4cChcIl5cIiArIGtleXBhdGguc3RyLnJlcGxhY2UoL1xcLi9nLCBcIlxcXFwuXCIpLnJlcGxhY2UoL1xcKi9nLCBcIihbXlxcXFwuXSspXCIpICsgXCIkXCIpO1xuICBcdHRoaXMudmFsdWVzID0ge307XG5cbiAgXHRpZiAodGhpcy5kZWZlcikge1xuICBcdFx0dGhpcy5wcm94aWVzID0gW107XG4gIFx0fVxuXG4gIFx0Ly8gZGVmYXVsdCB0byByb290IGFzIGNvbnRleHQsIGJ1dCBhbGxvdyBpdCB0byBiZSBvdmVycmlkZGVuXG4gIFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPyBvcHRpb25zLmNvbnRleHQgOiByYWN0aXZlO1xuICB9O1xuXG4gIFBhdHRlcm5PYnNlcnZlci5wcm90b3R5cGUgPSB7XG4gIFx0aW5pdDogZnVuY3Rpb24gKGltbWVkaWF0ZSkge1xuICBcdFx0dmFyIHZhbHVlcywga2V5cGF0aDtcblxuICBcdFx0dmFsdWVzID0gb2JzZXJ2ZV9nZXRQYXR0ZXJuKHRoaXMucm9vdCwgdGhpcy5rZXlwYXRoKTtcblxuICBcdFx0aWYgKGltbWVkaWF0ZSAhPT0gZmFsc2UpIHtcbiAgXHRcdFx0Zm9yIChrZXlwYXRoIGluIHZhbHVlcykge1xuICBcdFx0XHRcdGlmICh2YWx1ZXMuaGFzT3duUHJvcGVydHkoa2V5cGF0aCkpIHtcbiAgXHRcdFx0XHRcdHRoaXMudXBkYXRlKGdldEtleXBhdGgoa2V5cGF0aCkpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciB2YWx1ZXM7XG5cbiAgXHRcdGlmIChrZXlwYXRoLmlzUGF0dGVybikge1xuICBcdFx0XHR2YWx1ZXMgPSBvYnNlcnZlX2dldFBhdHRlcm4odGhpcy5yb290LCBrZXlwYXRoKTtcblxuICBcdFx0XHRmb3IgKGtleXBhdGggaW4gdmFsdWVzKSB7XG4gIFx0XHRcdFx0aWYgKHZhbHVlcy5oYXNPd25Qcm9wZXJ0eShrZXlwYXRoKSkge1xuICBcdFx0XHRcdFx0dGhpcy51cGRhdGUoZ2V0S2V5cGF0aChrZXlwYXRoKSk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBhcnJheSBtdXRhdGlvbiBzaG91bGQgbm90IHRyaWdnZXIgYGFycmF5LipgXG4gIFx0XHQvLyBwYXR0ZXJuIG9ic2VydmVyIHdpdGggYGFycmF5Lmxlbmd0aGBcbiAgXHRcdGlmICh0aGlzLnJvb3Qudmlld21vZGVsLmltcGxpY2l0Q2hhbmdlc1trZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5kZWZlciAmJiB0aGlzLnJlYWR5KSB7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIF90aGlzLmdldFByb3h5KGtleXBhdGgpLnVwZGF0ZSgpO1xuICBcdFx0XHR9KTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnJlYWxseVVwZGF0ZShrZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0cmVhbGx5VXBkYXRlOiBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFyIGtleXBhdGhTdHIsIHZhbHVlLCBrZXlzLCBhcmdzO1xuXG4gIFx0XHRrZXlwYXRoU3RyID0ga2V5cGF0aC5zdHI7XG4gIFx0XHR2YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuXG4gIFx0XHQvLyBQcmV2ZW50IGluZmluaXRlIGxvb3BzXG4gIFx0XHRpZiAodGhpcy51cGRhdGluZykge1xuICBcdFx0XHR0aGlzLnZhbHVlc1trZXlwYXRoU3RyXSA9IHZhbHVlO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXG4gIFx0XHRpZiAoIWlzRXF1YWwodmFsdWUsIHRoaXMudmFsdWVzW2tleXBhdGhTdHJdKSB8fCAhdGhpcy5yZWFkeSkge1xuICBcdFx0XHRrZXlzID0gc2xpY2UuY2FsbCh0aGlzLnJlZ2V4LmV4ZWMoa2V5cGF0aFN0ciksIDEpO1xuICBcdFx0XHRhcmdzID0gW3ZhbHVlLCB0aGlzLnZhbHVlc1trZXlwYXRoU3RyXSwga2V5cGF0aFN0cl0uY29uY2F0KGtleXMpO1xuXG4gIFx0XHRcdHRoaXMudmFsdWVzW2tleXBhdGhTdHJdID0gdmFsdWU7XG4gIFx0XHRcdHRoaXMuY2FsbGJhY2suYXBwbHkodGhpcy5jb250ZXh0LCBhcmdzKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuICBcdH0sXG5cbiAgXHRnZXRQcm94eTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdGlmICghdGhpcy5wcm94aWVzW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHR0aGlzLnByb3hpZXNba2V5cGF0aC5zdHJdID0ge1xuICBcdFx0XHRcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0cmV0dXJuIF90aGlzLnJlYWxseVVwZGF0ZShrZXlwYXRoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLnByb3hpZXNba2V5cGF0aC5zdHJdO1xuICBcdH1cbiAgfTtcblxuICB2YXIgb2JzZXJ2ZV9QYXR0ZXJuT2JzZXJ2ZXIgPSBQYXR0ZXJuT2JzZXJ2ZXI7XG5cbiAgdmFyIG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUgPSBnZXRPYnNlcnZlckZhY2FkZTtcbiAgdmFyIGVtcHR5T2JqZWN0ID0ge307XG4gIGZ1bmN0aW9uIGdldE9ic2VydmVyRmFjYWRlKHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIFx0dmFyIG9ic2VydmVyLCBpc1BhdHRlcm5PYnNlcnZlciwgY2FuY2VsbGVkO1xuXG4gIFx0a2V5cGF0aCA9IGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKTtcbiAgXHRvcHRpb25zID0gb3B0aW9ucyB8fCBlbXB0eU9iamVjdDtcblxuICBcdC8vIHBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSB0cmVhdGVkIGRpZmZlcmVudGx5XG4gIFx0aWYgKGtleXBhdGguaXNQYXR0ZXJuKSB7XG4gIFx0XHRvYnNlcnZlciA9IG5ldyBvYnNlcnZlX1BhdHRlcm5PYnNlcnZlcihyYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICBcdFx0aXNQYXR0ZXJuT2JzZXJ2ZXIgPSB0cnVlO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRvYnNlcnZlciA9IG5ldyBvYnNlcnZlX09ic2VydmVyKHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHRvYnNlcnZlci5pbml0KG9wdGlvbnMuaW5pdCk7XG4gIFx0cmFjdGl2ZS52aWV3bW9kZWwucmVnaXN0ZXIoa2V5cGF0aCwgb2JzZXJ2ZXIsIGlzUGF0dGVybk9ic2VydmVyID8gXCJwYXR0ZXJuT2JzZXJ2ZXJzXCIgOiBcIm9ic2VydmVyc1wiKTtcblxuICBcdC8vIFRoaXMgZmxhZyBhbGxvd3Mgb2JzZXJ2ZXJzIHRvIGluaXRpYWxpc2UgZXZlbiB3aXRoIHVuZGVmaW5lZCB2YWx1ZXNcbiAgXHRvYnNlcnZlci5yZWFkeSA9IHRydWU7XG5cbiAgXHR2YXIgZmFjYWRlID0ge1xuICBcdFx0Y2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHZhciBpbmRleDtcblxuICBcdFx0XHRpZiAoY2FuY2VsbGVkKSB7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGlzUGF0dGVybk9ic2VydmVyKSB7XG4gIFx0XHRcdFx0aW5kZXggPSByYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xuXG4gIFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwucGF0dGVybk9ic2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnVucmVnaXN0ZXIoa2V5cGF0aCwgb2JzZXJ2ZXIsIFwicGF0dGVybk9ic2VydmVyc1wiKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC51bnJlZ2lzdGVyKGtleXBhdGgsIG9ic2VydmVyLCBcIm9ic2VydmVyc1wiKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRjYW5jZWxsZWQgPSB0cnVlO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRyYWN0aXZlLl9vYnNlcnZlcnMucHVzaChmYWNhZGUpO1xuICBcdHJldHVybiBmYWNhZGU7XG4gIH1cblxuICB2YXIgb2JzZXJ2ZSA9IFJhY3RpdmUkb2JzZXJ2ZTtcbiAgZnVuY3Rpb24gUmFjdGl2ZSRvYnNlcnZlKGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG5cbiAgXHR2YXIgb2JzZXJ2ZXJzLCBtYXAsIGtleXBhdGhzLCBpO1xuXG4gIFx0Ly8gQWxsb3cgYSBtYXAgb2Yga2V5cGF0aHMgdG8gaGFuZGxlcnNcbiAgXHRpZiAoaXNPYmplY3Qoa2V5cGF0aCkpIHtcbiAgXHRcdG9wdGlvbnMgPSBjYWxsYmFjaztcbiAgXHRcdG1hcCA9IGtleXBhdGg7XG5cbiAgXHRcdG9ic2VydmVycyA9IFtdO1xuXG4gIFx0XHRmb3IgKGtleXBhdGggaW4gbWFwKSB7XG4gIFx0XHRcdGlmIChtYXAuaGFzT3duUHJvcGVydHkoa2V5cGF0aCkpIHtcbiAgXHRcdFx0XHRjYWxsYmFjayA9IG1hcFtrZXlwYXRoXTtcbiAgXHRcdFx0XHRvYnNlcnZlcnMucHVzaCh0aGlzLm9ic2VydmUoa2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMpKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHRjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHR3aGlsZSAob2JzZXJ2ZXJzLmxlbmd0aCkge1xuICBcdFx0XHRcdFx0b2JzZXJ2ZXJzLnBvcCgpLmNhbmNlbCgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHQvLyBBbGxvdyBgcmFjdGl2ZS5vYnNlcnZlKCBjYWxsYmFjayApYCAtIGkuZS4gb2JzZXJ2ZSBlbnRpcmUgbW9kZWxcbiAgXHRpZiAodHlwZW9mIGtleXBhdGggPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0b3B0aW9ucyA9IGNhbGxiYWNrO1xuICBcdFx0Y2FsbGJhY2sgPSBrZXlwYXRoO1xuICBcdFx0a2V5cGF0aCA9IFwiXCI7XG5cbiAgXHRcdHJldHVybiBvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlKHRoaXMsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHRrZXlwYXRocyA9IGtleXBhdGguc3BsaXQoXCIgXCIpO1xuXG4gIFx0Ly8gU2luZ2xlIGtleXBhdGhcbiAgXHRpZiAoa2V5cGF0aHMubGVuZ3RoID09PSAxKSB7XG4gIFx0XHRyZXR1cm4gb2JzZXJ2ZV9nZXRPYnNlcnZlckZhY2FkZSh0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIFx0fVxuXG4gIFx0Ly8gTXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGtleXBhdGhzXG4gIFx0b2JzZXJ2ZXJzID0gW107XG5cbiAgXHRpID0ga2V5cGF0aHMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGtleXBhdGggPSBrZXlwYXRoc1tpXTtcblxuICBcdFx0aWYgKGtleXBhdGgpIHtcbiAgXHRcdFx0b2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZV9nZXRPYnNlcnZlckZhY2FkZSh0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucykpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHRjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0d2hpbGUgKG9ic2VydmVycy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRvYnNlcnZlcnMucG9wKCkuY2FuY2VsKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgdmFyIG9ic2VydmVPbmNlID0gUmFjdGl2ZSRvYnNlcnZlT25jZTtcblxuICBmdW5jdGlvbiBSYWN0aXZlJG9ic2VydmVPbmNlKHByb3BlcnR5LCBjYWxsYmFjaywgb3B0aW9ucykge1xuXG4gIFx0dmFyIG9ic2VydmVyID0gdGhpcy5vYnNlcnZlKHByb3BlcnR5LCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBcdFx0b2JzZXJ2ZXIuY2FuY2VsKCk7XG4gIFx0fSwgeyBpbml0OiBmYWxzZSwgZGVmZXI6IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWZlciB9KTtcblxuICBcdHJldHVybiBvYnNlcnZlcjtcbiAgfVxuXG4gIHZhciBzaGFyZWRfdHJpbSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKTtcbiAgfTtcblxuICB2YXIgbm90RW1wdHlTdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ciAhPT0gXCJcIjtcbiAgfTtcblxuICB2YXIgb2ZmID0gUmFjdGl2ZSRvZmY7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkb2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIGV2ZW50TmFtZXM7XG5cbiAgXHQvLyBpZiBubyBhcmd1bWVudHMgc3BlY2lmaWVkLCByZW1vdmUgYWxsIGNhbGxiYWNrc1xuICBcdGlmICghZXZlbnROYW1lKSB7XG4gIFx0XHQvLyBUT0RPIHVzZSB0aGlzIGNvZGUgaW5zdGVhZCwgb25jZSB0aGUgZm9sbG93aW5nIGlzc3VlIGhhcyBiZWVuIHJlc29sdmVkXG4gIFx0XHQvLyBpbiBQaGFudG9tSlMgKHRlc3RzIGFyZSB1bnBhc3NhYmxlIG90aGVyd2lzZSEpXG4gIFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTg1NlxuICBcdFx0Ly8gZGVmaW5lUHJvcGVydHkoIHRoaXMsICdfc3VicycsIHsgdmFsdWU6IGNyZWF0ZSggbnVsbCApLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIFx0XHRmb3IgKGV2ZW50TmFtZSBpbiB0aGlzLl9zdWJzKSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9zdWJzW2V2ZW50TmFtZV07XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgbmFtZXNcbiAgXHRcdGV2ZW50TmFtZXMgPSBldmVudE5hbWUuc3BsaXQoXCIgXCIpLm1hcChzaGFyZWRfdHJpbSkuZmlsdGVyKG5vdEVtcHR5U3RyaW5nKTtcblxuICBcdFx0ZXZlbnROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgXHRcdFx0dmFyIHN1YnNjcmliZXJzLCBpbmRleDtcblxuICBcdFx0XHQvLyBJZiB3ZSBoYXZlIHN1YnNjcmliZXJzIGZvciB0aGlzIGV2ZW50Li4uXG4gIFx0XHRcdGlmIChzdWJzY3JpYmVycyA9IF90aGlzLl9zdWJzW2V2ZW50TmFtZV0pIHtcbiAgXHRcdFx0XHQvLyAuLi5pZiBhIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIG9ubHkgcmVtb3ZlIHRoYXRcbiAgXHRcdFx0XHRpZiAoY2FsbGJhY2spIHtcbiAgXHRcdFx0XHRcdGluZGV4ID0gc3Vic2NyaWJlcnMuaW5kZXhPZihjYWxsYmFjayk7XG4gIFx0XHRcdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRcdFx0XHRcdHN1YnNjcmliZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHJlbW92ZSBhbGwgY2FsbGJhY2tzXG4gIFx0XHRcdFx0ZWxzZSB7XG4gIFx0XHRcdFx0XHRfdGhpcy5fc3Vic1tldmVudE5hbWVdID0gW107XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBvbiA9IFJhY3RpdmUkb247XG4gIGZ1bmN0aW9uIFJhY3RpdmUkb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgbGlzdGVuZXJzLCBuLCBldmVudE5hbWVzO1xuXG4gIFx0Ly8gYWxsb3cgbXV0bGlwbGUgbGlzdGVuZXJzIHRvIGJlIGJvdW5kIGluIG9uZSBnb1xuICBcdGlmICh0eXBlb2YgZXZlbnROYW1lID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRsaXN0ZW5lcnMgPSBbXTtcblxuICBcdFx0Zm9yIChuIGluIGV2ZW50TmFtZSkge1xuICBcdFx0XHRpZiAoZXZlbnROYW1lLmhhc093blByb3BlcnR5KG4pKSB7XG4gIFx0XHRcdFx0bGlzdGVuZXJzLnB1c2godGhpcy5vbihuLCBldmVudE5hbWVbbl0pKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHRjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHR2YXIgbGlzdGVuZXI7XG5cbiAgXHRcdFx0XHR3aGlsZSAobGlzdGVuZXIgPSBsaXN0ZW5lcnMucG9wKCkpIHtcbiAgXHRcdFx0XHRcdGxpc3RlbmVyLmNhbmNlbCgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHQvLyBIYW5kbGUgbXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGV2ZW50IG5hbWVzXG4gIFx0ZXZlbnROYW1lcyA9IGV2ZW50TmFtZS5zcGxpdChcIiBcIikubWFwKHNoYXJlZF90cmltKS5maWx0ZXIobm90RW1wdHlTdHJpbmcpO1xuXG4gIFx0ZXZlbnROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgXHRcdChfdGhpcy5fc3Vic1tldmVudE5hbWVdIHx8IChfdGhpcy5fc3Vic1tldmVudE5hbWVdID0gW10pKS5wdXNoKGNhbGxiYWNrKTtcbiAgXHR9KTtcblxuICBcdHJldHVybiB7XG4gIFx0XHRjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIF90aGlzLm9mZihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgdmFyIG9uY2UgPSBSYWN0aXZlJG9uY2U7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRvbmNlKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuXG4gIFx0dmFyIGxpc3RlbmVyID0gdGhpcy5vbihldmVudE5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgXHRcdGhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXHRcdGxpc3RlbmVyLmNhbmNlbCgpO1xuICBcdH0pO1xuXG4gIFx0Ly8gc28gd2UgY2FuIHN0aWxsIGRvIGxpc3RlbmVyLmNhbmNlbCgpIG1hbnVhbGx5XG4gIFx0cmV0dXJuIGxpc3RlbmVyO1xuICB9XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBhcnJheSwgdGhlIG5hbWUgb2YgYSBtdXRhdG9yIG1ldGhvZCwgYW5kIHRoZVxuICAvLyBhcmd1bWVudHMgdG8gY2FsbCB0aGF0IG11dGF0b3IgbWV0aG9kIHdpdGgsIGFuZCByZXR1cm5zIGFuIGFycmF5IHRoYXRcbiAgLy8gbWFwcyB0aGUgb2xkIGluZGljZXMgdG8gdGhlaXIgbmV3IGluZGljZXMuXG5cbiAgLy8gU28gaWYgeW91IGhhZCBzb21ldGhpbmcgbGlrZSB0aGlzLi4uXG4gIC8vXG4gIC8vICAgICBhcnJheSA9IFsgJ2EnLCAnYicsICdjJywgJ2QnIF07XG4gIC8vICAgICBhcnJheS5wdXNoKCAnZScgKTtcbiAgLy9cbiAgLy8gLi4ueW91J2QgZ2V0IGBbIDAsIDEsIDIsIDMgXWAgLSBpbiBvdGhlciB3b3Jkcywgbm9uZSBvZiB0aGUgb2xkIGluZGljZXNcbiAgLy8gaGF2ZSBjaGFuZ2VkLiBJZiB5b3UgdGhlbiBkaWQgdGhpcy4uLlxuICAvL1xuICAvLyAgICAgYXJyYXkudW5zaGlmdCggJ3onICk7XG4gIC8vXG4gIC8vIC4uLnRoZSBpbmRpY2VzIHdvdWxkIGJlIGBbIDEsIDIsIDMsIDQsIDUgXWAgLSBldmVyeSBpdGVtIGhhcyBiZWVuIG1vdmVkXG4gIC8vIG9uZSBoaWdoZXIgdG8gbWFrZSByb29tIGZvciB0aGUgJ3onLiBJZiB5b3UgcmVtb3ZlZCBhbiBpdGVtLCB0aGUgbmV3IGluZGV4XG4gIC8vIHdvdWxkIGJlIC0xLi4uXG4gIC8vXG4gIC8vICAgICBhcnJheS5zcGxpY2UoIDIsIDIgKTtcbiAgLy9cbiAgLy8gLi4udGhpcyB3b3VsZCByZXN1bHQgaW4gWyAwLCAxLCAtMSwgLTEsIDIsIDMgXS5cbiAgLy9cbiAgLy8gVGhpcyBpbmZvcm1hdGlvbiBpcyB1c2VkIHRvIGVuYWJsZSBmYXN0LCBub24tZGVzdHJ1Y3RpdmUgc2h1ZmZsaW5nIG9mIGxpc3RcbiAgLy8gc2VjdGlvbnMgd2hlbiB5b3UgZG8gZS5nLiBgcmFjdGl2ZS5zcGxpY2UoICdpdGVtcycsIDIsIDIgKTtcblxuICB2YXIgc2hhcmVkX2dldE5ld0luZGljZXMgPSBnZXROZXdJbmRpY2VzO1xuXG4gIGZ1bmN0aW9uIGdldE5ld0luZGljZXMoYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MpIHtcbiAgXHR2YXIgc3BsaWNlQXJndW1lbnRzLFxuICBcdCAgICBsZW4sXG4gIFx0ICAgIG5ld0luZGljZXMgPSBbXSxcbiAgXHQgICAgcmVtb3ZlU3RhcnQsXG4gIFx0ICAgIHJlbW92ZUVuZCxcbiAgXHQgICAgYmFsYW5jZSxcbiAgXHQgICAgaTtcblxuICBcdHNwbGljZUFyZ3VtZW50cyA9IGdldFNwbGljZUVxdWl2YWxlbnQoYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MpO1xuXG4gIFx0aWYgKCFzcGxpY2VBcmd1bWVudHMpIHtcbiAgXHRcdHJldHVybiBudWxsOyAvLyBUT0RPIHN1cHBvcnQgcmV2ZXJzZSBhbmQgc29ydD9cbiAgXHR9XG5cbiAgXHRsZW4gPSBhcnJheS5sZW5ndGg7XG4gIFx0YmFsYW5jZSA9IHNwbGljZUFyZ3VtZW50cy5sZW5ndGggLSAyIC0gc3BsaWNlQXJndW1lbnRzWzFdO1xuXG4gIFx0cmVtb3ZlU3RhcnQgPSBNYXRoLm1pbihsZW4sIHNwbGljZUFyZ3VtZW50c1swXSk7XG4gIFx0cmVtb3ZlRW5kID0gcmVtb3ZlU3RhcnQgKyBzcGxpY2VBcmd1bWVudHNbMV07XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlU3RhcnQ7IGkgKz0gMSkge1xuICBcdFx0bmV3SW5kaWNlcy5wdXNoKGkpO1xuICBcdH1cblxuICBcdGZvciAoOyBpIDwgcmVtb3ZlRW5kOyBpICs9IDEpIHtcbiAgXHRcdG5ld0luZGljZXMucHVzaCgtMSk7XG4gIFx0fVxuXG4gIFx0Zm9yICg7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0bmV3SW5kaWNlcy5wdXNoKGkgKyBiYWxhbmNlKTtcbiAgXHR9XG5cbiAgXHQvLyB0aGVyZSBpcyBhIG5ldCBzaGlmdCBmb3IgdGhlIHJlc3Qgb2YgdGhlIGFycmF5IHN0YXJ0aW5nIHdpdGggaW5kZXggKyBiYWxhbmNlXG4gIFx0aWYgKGJhbGFuY2UgIT09IDApIHtcbiAgXHRcdG5ld0luZGljZXMudG91Y2hlZEZyb20gPSBzcGxpY2VBcmd1bWVudHNbMF07XG4gIFx0fSBlbHNlIHtcbiAgXHRcdG5ld0luZGljZXMudG91Y2hlZEZyb20gPSBhcnJheS5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG5ld0luZGljZXM7XG4gIH1cblxuICAvLyBUaGUgcG9wLCBwdXNoLCBzaGlmdCBhbiB1bnNoaWZ0IG1ldGhvZHMgY2FuIGFsbCBiZSByZXByZXNlbnRlZFxuICAvLyBhcyBhbiBlcXVpdmFsZW50IHNwbGljZVxuICBmdW5jdGlvbiBnZXRTcGxpY2VFcXVpdmFsZW50KGFycmF5LCBtZXRob2ROYW1lLCBhcmdzKSB7XG4gIFx0c3dpdGNoIChtZXRob2ROYW1lKSB7XG4gIFx0XHRjYXNlIFwic3BsaWNlXCI6XG4gIFx0XHRcdGlmIChhcmdzWzBdICE9PSB1bmRlZmluZWQgJiYgYXJnc1swXSA8IDApIHtcbiAgXHRcdFx0XHRhcmdzWzBdID0gYXJyYXkubGVuZ3RoICsgTWF0aC5tYXgoYXJnc1swXSwgLWFycmF5Lmxlbmd0aCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR3aGlsZSAoYXJncy5sZW5ndGggPCAyKSB7XG4gIFx0XHRcdFx0YXJncy5wdXNoKDApO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gZW5zdXJlIHdlIG9ubHkgcmVtb3ZlIGVsZW1lbnRzIHRoYXQgZXhpc3RcbiAgXHRcdFx0YXJnc1sxXSA9IE1hdGgubWluKGFyZ3NbMV0sIGFycmF5Lmxlbmd0aCAtIGFyZ3NbMF0pO1xuXG4gIFx0XHRcdHJldHVybiBhcmdzO1xuXG4gIFx0XHRjYXNlIFwic29ydFwiOlxuICBcdFx0Y2FzZSBcInJldmVyc2VcIjpcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG5cbiAgXHRcdGNhc2UgXCJwb3BcIjpcbiAgXHRcdFx0aWYgKGFycmF5Lmxlbmd0aCkge1xuICBcdFx0XHRcdHJldHVybiBbYXJyYXkubGVuZ3RoIC0gMSwgMV07XG4gIFx0XHRcdH1cbiAgXHRcdFx0cmV0dXJuIFswLCAwXTtcblxuICBcdFx0Y2FzZSBcInB1c2hcIjpcbiAgXHRcdFx0cmV0dXJuIFthcnJheS5sZW5ndGgsIDBdLmNvbmNhdChhcmdzKTtcblxuICBcdFx0Y2FzZSBcInNoaWZ0XCI6XG4gIFx0XHRcdHJldHVybiBbMCwgYXJyYXkubGVuZ3RoID8gMSA6IDBdO1xuXG4gIFx0XHRjYXNlIFwidW5zaGlmdFwiOlxuICBcdFx0XHRyZXR1cm4gWzAsIDBdLmNvbmNhdChhcmdzKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuICB2YXIgbWFrZUFycmF5TWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICBcdFx0XHRhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIGFycmF5LFxuICBcdFx0ICAgIG5ld0luZGljZXMgPSBbXSxcbiAgXHRcdCAgICBsZW4sXG4gIFx0XHQgICAgcHJvbWlzZSxcbiAgXHRcdCAgICByZXN1bHQ7XG5cbiAgXHRcdGtleXBhdGggPSBnZXRLZXlwYXRoKG5vcm1hbGlzZShrZXlwYXRoKSk7XG5cbiAgXHRcdGFycmF5ID0gdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0bGVuID0gYXJyYXkubGVuZ3RoO1xuXG4gIFx0XHRpZiAoIWlzQXJyYXkoYXJyYXkpKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNhbGxlZCByYWN0aXZlLlwiICsgbWV0aG9kTmFtZSArIFwiKCdcIiArIGtleXBhdGguc3RyICsgXCInKSwgYnV0ICdcIiArIGtleXBhdGguc3RyICsgXCInIGRvZXMgbm90IHJlZmVyIHRvIGFuIGFycmF5XCIpO1xuICBcdFx0fVxuXG4gIFx0XHRuZXdJbmRpY2VzID0gc2hhcmVkX2dldE5ld0luZGljZXMoYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MpO1xuXG4gIFx0XHRyZXN1bHQgPSBhcnJheVByb3RvW21ldGhvZE5hbWVdLmFwcGx5KGFycmF5LCBhcmdzKTtcbiAgXHRcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHRcdH0pO1xuXG4gIFx0XHRpZiAoISFuZXdJbmRpY2VzKSB7XG4gIFx0XHRcdHRoaXMudmlld21vZGVsLnNtYXJ0VXBkYXRlKGtleXBhdGgsIGFycmF5LCBuZXdJbmRpY2VzKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMudmlld21vZGVsLm1hcmsoa2V5cGF0aCk7XG4gIFx0XHR9XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0XHRyZXR1cm4gcHJvbWlzZTtcbiAgXHR9O1xuICB9O1xuXG4gIHZhciBwb3AgPSBtYWtlQXJyYXlNZXRob2QoXCJwb3BcIik7XG5cbiAgdmFyIHB1c2ggPSBtYWtlQXJyYXlNZXRob2QoXCJwdXNoXCIpO1xuXG4gIHZhciBjc3MsXG4gICAgICB1cGRhdGUsXG4gICAgICBzdHlsZUVsZW1lbnQsXG4gICAgICBoZWFkLFxuICAgICAgc3R5bGVTaGVldCxcbiAgICAgIGluRG9tLFxuICAgICAgZ2xvYmFsX2Nzc19fcHJlZml4ID0gXCIvKiBSYWN0aXZlLmpzIGNvbXBvbmVudCBzdHlsZXMgKi9cXG5cIixcbiAgICAgIHN0eWxlcyA9IFtdLFxuICAgICAgZGlydHkgPSBmYWxzZTtcblxuICBpZiAoIWlzQ2xpZW50KSB7XG4gIFx0Y3NzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHRzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIFx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XG5cbiAgXHRoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuXG4gIFx0aW5Eb20gPSBmYWxzZTtcblxuICBcdC8vIEludGVybmV0IEV4cGxvZGVyIHdvbid0IGxldCB5b3UgdXNlIHN0eWxlU2hlZXQuaW5uZXJIVE1MIC0gd2UgaGF2ZSB0b1xuICBcdC8vIHVzZSBzdHlsZVNoZWV0LmNzc1RleHQgaW5zdGVhZFxuICBcdHN0eWxlU2hlZXQgPSBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldDtcblxuICBcdHVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBjc3MgPSBnbG9iYWxfY3NzX19wcmVmaXggKyBzdHlsZXMubWFwKGZ1bmN0aW9uIChzKSB7XG4gIFx0XHRcdHJldHVybiBcIlxcbi8qIHtcIiArIHMuaWQgKyBcIn0gKi9cXG5cIiArIHMuc3R5bGVzO1xuICBcdFx0fSkuam9pbihcIlxcblwiKTtcblxuICBcdFx0aWYgKHN0eWxlU2hlZXQpIHtcbiAgXHRcdFx0c3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0c3R5bGVFbGVtZW50LmlubmVySFRNTCA9IGNzcztcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFpbkRvbSkge1xuICBcdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG4gIFx0XHRcdGluRG9tID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0Y3NzID0ge1xuICBcdFx0YWRkOiBmdW5jdGlvbiAocykge1xuICBcdFx0XHRzdHlsZXMucHVzaChzKTtcbiAgXHRcdFx0ZGlydHkgPSB0cnVlO1xuICBcdFx0fSxcblxuICBcdFx0YXBwbHk6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0aWYgKGRpcnR5KSB7XG4gIFx0XHRcdFx0dXBkYXRlKCk7XG4gIFx0XHRcdFx0ZGlydHkgPSBmYWxzZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICB2YXIgZ2xvYmFsX2NzcyA9IGNzcztcblxuICB2YXIgcHJvdG90eXBlX3JlbmRlciA9IFJhY3RpdmUkcmVuZGVyO1xuXG4gIHZhciByZW5kZXJIb29rID0gbmV3IGhvb2tzX0hvb2soXCJyZW5kZXJcIiksXG4gICAgICBjb21wbGV0ZUhvb2sgPSBuZXcgaG9va3NfSG9vayhcImNvbXBsZXRlXCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHJlbmRlcih0YXJnZXQsIGFuY2hvcikge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgcHJvbWlzZSwgaW5zdGFuY2VzLCB0cmFuc2l0aW9uc0VuYWJsZWQ7XG5cbiAgXHQvLyBpZiBgbm9JbnRyb2AgaXMgYHRydWVgLCB0ZW1wb3JhcmlseSBkaXNhYmxlIHRyYW5zaXRpb25zXG4gIFx0dHJhbnNpdGlvbnNFbmFibGVkID0gdGhpcy50cmFuc2l0aW9uc0VuYWJsZWQ7XG4gIFx0aWYgKHRoaXMubm9JbnRybykge1xuICBcdFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHRwcm9taXNlID0gZ2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcywgdHJ1ZSk7XG4gIFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiByZW5kZXJIb29rLmZpcmUoX3RoaXMpO1xuICBcdH0sIHRydWUpO1xuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQucmVuZGVyZWQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3QgY2FsbCByYWN0aXZlLnJlbmRlcigpIG9uIGFuIGFscmVhZHkgcmVuZGVyZWQgaW5zdGFuY2UhIENhbGwgcmFjdGl2ZS51bnJlbmRlcigpIGZpcnN0XCIpO1xuICBcdH1cblxuICBcdHRhcmdldCA9IGdldEVsZW1lbnQodGFyZ2V0KSB8fCB0aGlzLmVsO1xuICBcdGFuY2hvciA9IGdldEVsZW1lbnQoYW5jaG9yKSB8fCB0aGlzLmFuY2hvcjtcblxuICBcdHRoaXMuZWwgPSB0YXJnZXQ7XG4gIFx0dGhpcy5hbmNob3IgPSBhbmNob3I7XG5cbiAgXHRpZiAoIXRoaXMuYXBwZW5kICYmIHRhcmdldCkge1xuICBcdFx0Ly8gVGVhcmRvd24gYW55IGV4aXN0aW5nIGluc3RhbmNlcyAqYmVmb3JlKiB0cnlpbmcgdG8gc2V0IHVwIHRoZSBuZXcgb25lIC1cbiAgXHRcdC8vIGF2b2lkcyBjZXJ0YWluIHdlaXJkIGJ1Z3NcbiAgXHRcdHZhciBvdGhlcnMgPSB0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fO1xuICBcdFx0aWYgKG90aGVycyAmJiBvdGhlcnMubGVuZ3RoKSB7XG4gIFx0XHRcdHJlbW92ZU90aGVySW5zdGFuY2VzKG90aGVycyk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIG1ha2Ugc3VyZSB3ZSBhcmUgdGhlIG9ubHkgb2NjdXBhbnRzXG4gIFx0XHR0YXJnZXQuaW5uZXJIVE1MID0gXCJcIjsgLy8gVE9ETyBpcyB0aGlzIHF1aWNrZXIgdGhhbiByZW1vdmVDaGlsZD8gSW5pdGlhbCByZXNlYXJjaCBpbmNvbmNsdXNpdmVcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5jc3NJZCkge1xuICBcdFx0Ly8gZW5zdXJlIGVuY2Fwc3VsYXRlZCBDU1MgaXMgdXAtdG8tZGF0ZVxuICBcdFx0Z2xvYmFsX2Nzcy5hcHBseSgpO1xuICBcdH1cblxuICBcdGlmICh0YXJnZXQpIHtcbiAgXHRcdGlmICghKGluc3RhbmNlcyA9IHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18pKSB7XG4gIFx0XHRcdHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gPSBbdGhpc107XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpbnN0YW5jZXMucHVzaCh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGFuY2hvcikge1xuICBcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuZnJhZ21lbnQucmVuZGVyKCksIGFuY2hvcik7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQodGhpcy5mcmFnbWVudC5yZW5kZXIoKSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG5cbiAgXHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IHRyYW5zaXRpb25zRW5hYmxlZDtcblxuICBcdHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIGNvbXBsZXRlSG9vay5maXJlKF90aGlzKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU90aGVySW5zdGFuY2VzKG90aGVycykge1xuICBcdG90aGVycy5zcGxpY2UoMCwgb3RoZXJzLmxlbmd0aCkuZm9yRWFjaCh0ZWFyZG93bik7XG4gIH1cblxuICB2YXIgYWRhcHRDb25maWd1cmF0b3IgPSB7XG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAoUGFyZW50LCBwcm90bywgb3B0aW9ucykge1xuICBcdFx0cHJvdG8uYWRhcHQgPSBjdXN0b21fYWRhcHRfX2NvbWJpbmUocHJvdG8uYWRhcHQsIGVuc3VyZUFycmF5KG9wdGlvbnMuYWRhcHQpKTtcbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge31cbiAgfTtcblxuICB2YXIgY3VzdG9tX2FkYXB0ID0gYWRhcHRDb25maWd1cmF0b3I7XG5cbiAgZnVuY3Rpb24gY3VzdG9tX2FkYXB0X19jb21iaW5lKGEsIGIpIHtcbiAgXHR2YXIgYyA9IGEuc2xpY2UoKSxcbiAgXHQgICAgaSA9IGIubGVuZ3RoO1xuXG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKCEgfmMuaW5kZXhPZihiW2ldKSkge1xuICBcdFx0XHRjLnB1c2goYltpXSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGM7XG4gIH1cblxuICB2YXIgdHJhbnNmb3JtID0gdHJhbnNmb3JtQ3NzO1xuXG4gIHZhciBzZWxlY3RvcnNQYXR0ZXJuID0gLyg/Ol58XFx9KT9cXHMqKFteXFx7XFx9XSspXFxzKlxcey9nLFxuICAgICAgY29tbWVudHNQYXR0ZXJuID0gL1xcL1xcKi4qP1xcKlxcLy9nLFxuICAgICAgc2VsZWN0b3JVbml0UGF0dGVybiA9IC8oKD86KD86XFxbW15cXF0rXVxcXSl8KD86W15cXHNcXCtcXD5cXH46XSkpKykoKD86OlteXFxzXFwrXFw+XFx+XFwoXSsoPzpcXChbXlxcKV0rXFwpKT8pP1xccypbXFxzXFwrXFw+XFx+XT8pXFxzKi9nLFxuICAgICAgbWVkaWFRdWVyeVBhdHRlcm4gPSAvXkBtZWRpYS8sXG4gICAgICBkYXRhUnZjR3VpZFBhdHRlcm4gPSAvXFxbZGF0YS1yYWN0aXZlLWNzc349XCJcXHtbYS16MC05LV0rXFx9XCJdL2c7XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUNzcyhjc3MsIGlkKSB7XG4gIFx0dmFyIHRyYW5zZm9ybWVkLCBkYXRhQXR0ciwgYWRkR3VpZDtcblxuICBcdGRhdGFBdHRyID0gXCJbZGF0YS1yYWN0aXZlLWNzc349XFxcIntcIiArIGlkICsgXCJ9XFxcIl1cIjtcblxuICBcdGFkZEd1aWQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRcdHZhciBzZWxlY3RvclVuaXRzLFxuICBcdFx0ICAgIG1hdGNoLFxuICBcdFx0ICAgIHVuaXQsXG4gIFx0XHQgICAgYmFzZSxcbiAgXHRcdCAgICBwcmVwZW5kZWQsXG4gIFx0XHQgICAgYXBwZW5kZWQsXG4gIFx0XHQgICAgaSxcbiAgXHRcdCAgICB0cmFuc2Zvcm1lZCA9IFtdO1xuXG4gIFx0XHRzZWxlY3RvclVuaXRzID0gW107XG5cbiAgXHRcdHdoaWxlIChtYXRjaCA9IHNlbGVjdG9yVW5pdFBhdHRlcm4uZXhlYyhzZWxlY3RvcikpIHtcbiAgXHRcdFx0c2VsZWN0b3JVbml0cy5wdXNoKHtcbiAgXHRcdFx0XHRzdHI6IG1hdGNoWzBdLFxuICBcdFx0XHRcdGJhc2U6IG1hdGNoWzFdLFxuICBcdFx0XHRcdG1vZGlmaWVyczogbWF0Y2hbMl1cbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIEZvciBlYWNoIHNpbXBsZSBzZWxlY3RvciB3aXRoaW4gdGhlIHNlbGVjdG9yLCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHZlcnNpb25cbiAgXHRcdC8vIHRoYXQgYSkgY29tYmluZXMgd2l0aCB0aGUgaWQsIGFuZCBiKSBpcyBpbnNpZGUgdGhlIGlkXG4gIFx0XHRiYXNlID0gc2VsZWN0b3JVbml0cy5tYXAoZXh0cmFjdFN0cmluZyk7XG5cbiAgXHRcdGkgPSBzZWxlY3RvclVuaXRzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0YXBwZW5kZWQgPSBiYXNlLnNsaWNlKCk7XG5cbiAgXHRcdFx0Ly8gUHNldWRvLXNlbGVjdG9ycyBzaG91bGQgZ28gYWZ0ZXIgdGhlIGF0dHJpYnV0ZSBzZWxlY3RvclxuICBcdFx0XHR1bml0ID0gc2VsZWN0b3JVbml0c1tpXTtcbiAgXHRcdFx0YXBwZW5kZWRbaV0gPSB1bml0LmJhc2UgKyBkYXRhQXR0ciArIHVuaXQubW9kaWZpZXJzIHx8IFwiXCI7XG5cbiAgXHRcdFx0cHJlcGVuZGVkID0gYmFzZS5zbGljZSgpO1xuICBcdFx0XHRwcmVwZW5kZWRbaV0gPSBkYXRhQXR0ciArIFwiIFwiICsgcHJlcGVuZGVkW2ldO1xuXG4gIFx0XHRcdHRyYW5zZm9ybWVkLnB1c2goYXBwZW5kZWQuam9pbihcIiBcIiksIHByZXBlbmRlZC5qb2luKFwiIFwiKSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0cmFuc2Zvcm1lZC5qb2luKFwiLCBcIik7XG4gIFx0fTtcblxuICBcdGlmIChkYXRhUnZjR3VpZFBhdHRlcm4udGVzdChjc3MpKSB7XG4gIFx0XHR0cmFuc2Zvcm1lZCA9IGNzcy5yZXBsYWNlKGRhdGFSdmNHdWlkUGF0dGVybiwgZGF0YUF0dHIpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR0cmFuc2Zvcm1lZCA9IGNzcy5yZXBsYWNlKGNvbW1lbnRzUGF0dGVybiwgXCJcIikucmVwbGFjZShzZWxlY3RvcnNQYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gIFx0XHRcdHZhciBzZWxlY3RvcnMsIHRyYW5zZm9ybWVkO1xuXG4gIFx0XHRcdC8vIGRvbid0IHRyYW5zZm9ybSBtZWRpYSBxdWVyaWVzIVxuICBcdFx0XHRpZiAobWVkaWFRdWVyeVBhdHRlcm4udGVzdCgkMSkpIHJldHVybiBtYXRjaDtcblxuICBcdFx0XHRzZWxlY3RvcnMgPSAkMS5zcGxpdChcIixcIikubWFwKHRyaW0pO1xuICBcdFx0XHR0cmFuc2Zvcm1lZCA9IHNlbGVjdG9ycy5tYXAoYWRkR3VpZCkuam9pbihcIiwgXCIpICsgXCIgXCI7XG5cbiAgXHRcdFx0cmV0dXJuIG1hdGNoLnJlcGxhY2UoJDEsIHRyYW5zZm9ybWVkKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIFx0aWYgKHN0ci50cmltKSB7XG4gIFx0XHRyZXR1cm4gc3RyLnRyaW0oKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrLywgXCJcIikucmVwbGFjZSgvXFxzKyQvLCBcIlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RTdHJpbmcodW5pdCkge1xuICBcdHJldHVybiB1bml0LnN0cjtcbiAgfVxuXG4gIHZhciBjc3NfY3NzX191aWQgPSAxO1xuXG4gIHZhciBjc3NDb25maWd1cmF0b3IgPSB7XG4gIFx0bmFtZTogXCJjc3NcIixcblxuICBcdGV4dGVuZDogZnVuY3Rpb24gKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdGlmIChvcHRpb25zLmNzcykge1xuICBcdFx0XHR2YXIgaWQgPSBjc3NfY3NzX191aWQrKztcbiAgXHRcdFx0dmFyIHN0eWxlcyA9IG9wdGlvbnMubm9Dc3NUcmFuc2Zvcm0gPyBvcHRpb25zLmNzcyA6IHRyYW5zZm9ybShvcHRpb25zLmNzcywgaWQpO1xuXG4gIFx0XHRcdHByb3RvLmNzc0lkID0gaWQ7XG4gIFx0XHRcdGdsb2JhbF9jc3MuYWRkKHsgaWQ6IGlkLCBzdHlsZXM6IHN0eWxlcyB9KTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCkge31cbiAgfTtcblxuICB2YXIgY3NzX2NzcyA9IGNzc0NvbmZpZ3VyYXRvcjtcblxuICBmdW5jdGlvbiB2YWxpZGF0ZShkYXRhKSB7XG4gIFx0Ly8gV2FybiBpZiB1c2VyT3B0aW9ucy5kYXRhIGlzIGEgbm9uLVBPSk9cbiAgXHRpZiAoZGF0YSAmJiBkYXRhLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgXHRcdGlmICh0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7fSBlbHNlIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICBcdFx0XHRmYXRhbChcImRhdGEgb3B0aW9uIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGBcIiArIGRhdGEgKyBcImAgaXMgbm90IHZhbGlkXCIpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0d2FybklmRGVidWcoXCJJZiBzdXBwbGllZCwgb3B0aW9ucy5kYXRhIHNob3VsZCBiZSBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IC0gdXNpbmcgYSBub24tUE9KTyBhcyB0aGUgcm9vdCBvYmplY3QgbWF5IHdvcmssIGJ1dCBpcyBkaXNjb3VyYWdlZFwiKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgZGF0YUNvbmZpZ3VyYXRvciA9IHtcbiAgXHRuYW1lOiBcImRhdGFcIixcblxuICBcdGV4dGVuZDogZnVuY3Rpb24gKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdHZhciBrZXkgPSB1bmRlZmluZWQsXG4gIFx0XHQgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdC8vIGNoZWNrIGZvciBub24tcHJpbWl0aXZlcywgd2hpY2ggY291bGQgY2F1c2UgbXV0YXRpb24tcmVsYXRlZCBidWdzXG4gIFx0XHRpZiAob3B0aW9ucy5kYXRhICYmIGlzT2JqZWN0KG9wdGlvbnMuZGF0YSkpIHtcbiAgXHRcdFx0Zm9yIChrZXkgaW4gb3B0aW9ucy5kYXRhKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zLmRhdGFba2V5XTtcblxuICBcdFx0XHRcdGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdFx0XHRcdGlmIChpc09iamVjdCh2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSkpIHtcbiAgXHRcdFx0XHRcdFx0d2FybklmRGVidWcoXCJQYXNzaW5nIGEgYGRhdGFgIG9wdGlvbiB3aXRoIG9iamVjdCBhbmQgYXJyYXkgcHJvcGVydGllcyB0byBSYWN0aXZlLmV4dGVuZCgpIGlzIGRpc2NvdXJhZ2VkLCBhcyBtdXRhdGluZyB0aGVtIGlzIGxpa2VseSB0byBjYXVzZSBidWdzLiBDb25zaWRlciB1c2luZyBhIGRhdGEgZnVuY3Rpb24gaW5zdGVhZDpcXG5cXG4gIC8vIHRoaXMuLi5cXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBteU9iamVjdDoge31cXG4gICAgfTtcXG4gIH0pXFxuXFxuICAvLyBpbnN0ZWFkIG9mIHRoaXM6XFxuICBkYXRhOiB7XFxuICAgIG15T2JqZWN0OiB7fVxcbiAgfVwiKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cHJvdG8uZGF0YSA9IGN1c3RvbV9kYXRhX19jb21iaW5lKHByb3RvLmRhdGEsIG9wdGlvbnMuZGF0YSk7XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uIChQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMpIHtcbiAgXHRcdHZhciByZXN1bHQgPSBjdXN0b21fZGF0YV9fY29tYmluZShQYXJlbnQucHJvdG90eXBlLmRhdGEsIG9wdGlvbnMuZGF0YSk7XG5cbiAgXHRcdGlmICh0eXBlb2YgcmVzdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0cmVzdWx0ID0gcmVzdWx0LmNhbGwocmFjdGl2ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiByZXN1bHQgfHwge307XG4gIFx0fSxcblxuICBcdHJlc2V0OiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0dmFyIHJlc3VsdCA9IHRoaXMuaW5pdChyYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCByYWN0aXZlLnZpZXdtb2RlbCk7XG5cbiAgXHRcdHJhY3RpdmUudmlld21vZGVsLnJlc2V0KHJlc3VsdCk7XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGN1c3RvbV9kYXRhID0gZGF0YUNvbmZpZ3VyYXRvcjtcblxuICBmdW5jdGlvbiBjdXN0b21fZGF0YV9fY29tYmluZShwYXJlbnRWYWx1ZSwgY2hpbGRWYWx1ZSkge1xuICBcdHZhbGlkYXRlKGNoaWxkVmFsdWUpO1xuXG4gIFx0dmFyIHBhcmVudElzRm4gPSB0eXBlb2YgcGFyZW50VmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbiAgXHR2YXIgY2hpbGRJc0ZuID0gdHlwZW9mIGNoaWxkVmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcblxuICBcdC8vIFZlcnkgaW1wb3J0YW50LCBvdGhlcndpc2UgY2hpbGQgaW5zdGFuY2UgY2FuIGJlY29tZVxuICBcdC8vIHRoZSBkZWZhdWx0IGRhdGEgb2JqZWN0IG9uIFJhY3RpdmUgb3IgYSBjb21wb25lbnQuXG4gIFx0Ly8gdGhlbiByYWN0aXZlLnNldCgpIGVuZHMgdXAgc2V0dGluZyBvbiB0aGUgcHJvdG90eXBlIVxuICBcdGlmICghY2hpbGRWYWx1ZSAmJiAhcGFyZW50SXNGbikge1xuICBcdFx0Y2hpbGRWYWx1ZSA9IHt9O1xuICBcdH1cblxuICBcdC8vIEZhc3QgcGF0aCwgd2hlcmUgd2UganVzdCBuZWVkIHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gIFx0Ly8gcGFyZW50IHRvIGNoaWxkXG4gIFx0aWYgKCFwYXJlbnRJc0ZuICYmICFjaGlsZElzRm4pIHtcbiAgXHRcdHJldHVybiBmcm9tUHJvcGVydGllcyhjaGlsZFZhbHVlLCBwYXJlbnRWYWx1ZSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBjaGlsZCA9IGNoaWxkSXNGbiA/IGNhbGxEYXRhRnVuY3Rpb24oY2hpbGRWYWx1ZSwgdGhpcykgOiBjaGlsZFZhbHVlO1xuICBcdFx0dmFyIHBhcmVudCA9IHBhcmVudElzRm4gPyBjYWxsRGF0YUZ1bmN0aW9uKHBhcmVudFZhbHVlLCB0aGlzKSA6IHBhcmVudFZhbHVlO1xuXG4gIFx0XHRyZXR1cm4gZnJvbVByb3BlcnRpZXMoY2hpbGQsIHBhcmVudCk7XG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxEYXRhRnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgXHR2YXIgZGF0YSA9IGZuLmNhbGwoY29udGV4dCk7XG5cbiAgXHRpZiAoIWRhdGEpIHJldHVybjtcblxuICBcdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICBcdFx0ZmF0YWwoXCJEYXRhIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGFuIG9iamVjdFwiKTtcbiAgXHR9XG5cbiAgXHRpZiAoZGF0YS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gIFx0XHR3YXJuT25jZUlmRGVidWcoXCJEYXRhIGZ1bmN0aW9uIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QuIFRoaXMgbWlnaHQgd29yaywgYnV0IGlzIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkXCIpO1xuICBcdH1cblxuICBcdHJldHVybiBkYXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbVByb3BlcnRpZXMocHJpbWFyeSwgc2Vjb25kYXJ5KSB7XG4gIFx0aWYgKHByaW1hcnkgJiYgc2Vjb25kYXJ5KSB7XG4gIFx0XHRmb3IgKHZhciBrZXkgaW4gc2Vjb25kYXJ5KSB7XG4gIFx0XHRcdGlmICghKGtleSBpbiBwcmltYXJ5KSkge1xuICBcdFx0XHRcdHByaW1hcnlba2V5XSA9IHNlY29uZGFyeVtrZXldO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwcmltYXJ5O1xuICBcdH1cblxuICBcdHJldHVybiBwcmltYXJ5IHx8IHNlY29uZGFyeTtcbiAgfVxuXG4gIC8vIFRPRE8gZG8gd2UgbmVlZCB0byBzdXBwb3J0IHRoaXMgaW4gdGhlIG5ldyBSYWN0aXZlKCkgY2FzZT9cblxuICB2YXIgUGFyc2VyLFxuICAgICAgUGFyc2VFcnJvcixcbiAgICAgIHBhcnNlX1BhcnNlcl9fbGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccysvO1xuXG4gIFBhcnNlRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICBcdHRoaXMubmFtZSA9IFwiUGFyc2VFcnJvclwiO1xuICBcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIFx0dHJ5IHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgXHR9IGNhdGNoIChlKSB7XG4gIFx0XHR0aGlzLnN0YWNrID0gZS5zdGFjaztcbiAgXHR9XG4gIH07XG5cbiAgUGFyc2VFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgUGFyc2VyID0gZnVuY3Rpb24gKHN0ciwgb3B0aW9ucykge1xuICBcdHZhciBpdGVtcyxcbiAgXHQgICAgaXRlbSxcbiAgXHQgICAgbGluZVN0YXJ0ID0gMDtcblxuICBcdHRoaXMuc3RyID0gc3RyO1xuICBcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFx0dGhpcy5wb3MgPSAwO1xuXG4gIFx0dGhpcy5saW5lcyA9IHRoaXMuc3RyLnNwbGl0KFwiXFxuXCIpO1xuICBcdHRoaXMubGluZUVuZHMgPSB0aGlzLmxpbmVzLm1hcChmdW5jdGlvbiAobGluZSkge1xuICBcdFx0dmFyIGxpbmVFbmQgPSBsaW5lU3RhcnQgKyBsaW5lLmxlbmd0aCArIDE7IC8vICsxIGZvciB0aGUgbmV3bGluZVxuXG4gIFx0XHRsaW5lU3RhcnQgPSBsaW5lRW5kO1xuICBcdFx0cmV0dXJuIGxpbmVFbmQ7XG4gIFx0fSwgMCk7XG5cbiAgXHQvLyBDdXN0b20gaW5pdCBsb2dpY1xuICBcdGlmICh0aGlzLmluaXQpIHRoaXMuaW5pdChzdHIsIG9wdGlvbnMpO1xuXG4gIFx0aXRlbXMgPSBbXTtcblxuICBcdHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuc3RyLmxlbmd0aCAmJiAoaXRlbSA9IHRoaXMucmVhZCgpKSkge1xuICBcdFx0aXRlbXMucHVzaChpdGVtKTtcbiAgXHR9XG5cbiAgXHR0aGlzLmxlZnRvdmVyID0gdGhpcy5yZW1haW5pbmcoKTtcbiAgXHR0aGlzLnJlc3VsdCA9IHRoaXMucG9zdFByb2Nlc3MgPyB0aGlzLnBvc3RQcm9jZXNzKGl0ZW1zLCBvcHRpb25zKSA6IGl0ZW1zO1xuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUgPSB7XG4gIFx0cmVhZDogZnVuY3Rpb24gKGNvbnZlcnRlcnMpIHtcbiAgXHRcdHZhciBwb3MsIGksIGxlbiwgaXRlbTtcblxuICBcdFx0aWYgKCFjb252ZXJ0ZXJzKSBjb252ZXJ0ZXJzID0gdGhpcy5jb252ZXJ0ZXJzO1xuXG4gIFx0XHRwb3MgPSB0aGlzLnBvcztcblxuICBcdFx0bGVuID0gY29udmVydGVycy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0dGhpcy5wb3MgPSBwb3M7IC8vIHJlc2V0IGZvciBlYWNoIGF0dGVtcHRcblxuICBcdFx0XHRpZiAoaXRlbSA9IGNvbnZlcnRlcnNbaV0odGhpcykpIHtcbiAgXHRcdFx0XHRyZXR1cm4gaXRlbTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9LFxuXG4gIFx0Z2V0TGluZVBvczogZnVuY3Rpb24gKGNoYXIpIHtcbiAgXHRcdHZhciBsaW5lTnVtID0gMCxcbiAgXHRcdCAgICBsaW5lU3RhcnQgPSAwLFxuICBcdFx0ICAgIGNvbHVtbk51bTtcblxuICBcdFx0d2hpbGUgKGNoYXIgPj0gdGhpcy5saW5lRW5kc1tsaW5lTnVtXSkge1xuICBcdFx0XHRsaW5lU3RhcnQgPSB0aGlzLmxpbmVFbmRzW2xpbmVOdW1dO1xuICBcdFx0XHRsaW5lTnVtICs9IDE7XG4gIFx0XHR9XG5cbiAgXHRcdGNvbHVtbk51bSA9IGNoYXIgLSBsaW5lU3RhcnQ7XG4gIFx0XHRyZXR1cm4gW2xpbmVOdW0gKyAxLCBjb2x1bW5OdW0gKyAxLCBjaGFyXTsgLy8gbGluZS9jb2wgc2hvdWxkIGJlIG9uZS1iYXNlZCwgbm90IHplcm8tYmFzZWQhXG4gIFx0fSxcblxuICBcdGVycm9yOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICBcdFx0dmFyIHBvcyA9IHRoaXMuZ2V0TGluZVBvcyh0aGlzLnBvcyk7XG4gIFx0XHR2YXIgbGluZU51bSA9IHBvc1swXTtcbiAgXHRcdHZhciBjb2x1bW5OdW0gPSBwb3NbMV07XG5cbiAgXHRcdHZhciBsaW5lID0gdGhpcy5saW5lc1twb3NbMF0gLSAxXTtcbiAgXHRcdHZhciBudW1UYWJzID0gMDtcbiAgXHRcdHZhciBhbm5vdGF0aW9uID0gbGluZS5yZXBsYWNlKC9cXHQvZywgZnVuY3Rpb24gKG1hdGNoLCBjaGFyKSB7XG4gIFx0XHRcdGlmIChjaGFyIDwgcG9zWzFdKSB7XG4gIFx0XHRcdFx0bnVtVGFicyArPSAxO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIFwiICBcIjtcbiAgXHRcdH0pICsgXCJcXG5cIiArIG5ldyBBcnJheShwb3NbMV0gKyBudW1UYWJzKS5qb2luKFwiIFwiKSArIFwiXi0tLS1cIjtcblxuICBcdFx0dmFyIGVycm9yID0gbmV3IFBhcnNlRXJyb3IoXCJcIiArIG1lc3NhZ2UgKyBcIiBhdCBsaW5lIFwiICsgbGluZU51bSArIFwiIGNoYXJhY3RlciBcIiArIGNvbHVtbk51bSArIFwiOlxcblwiICsgYW5ub3RhdGlvbik7XG5cbiAgXHRcdGVycm9yLmxpbmUgPSBwb3NbMF07XG4gIFx0XHRlcnJvci5jaGFyYWN0ZXIgPSBwb3NbMV07XG4gIFx0XHRlcnJvci5zaG9ydE1lc3NhZ2UgPSBtZXNzYWdlO1xuXG4gIFx0XHR0aHJvdyBlcnJvcjtcbiAgXHR9LFxuXG4gIFx0bWF0Y2hTdHJpbmc6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgXHRcdGlmICh0aGlzLnN0ci5zdWJzdHIodGhpcy5wb3MsIHN0cmluZy5sZW5ndGgpID09PSBzdHJpbmcpIHtcbiAgXHRcdFx0dGhpcy5wb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgXHRcdFx0cmV0dXJuIHN0cmluZztcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0bWF0Y2hQYXR0ZXJuOiBmdW5jdGlvbiAocGF0dGVybikge1xuICBcdFx0dmFyIG1hdGNoO1xuXG4gIFx0XHRpZiAobWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGhpcy5yZW1haW5pbmcoKSkpIHtcbiAgXHRcdFx0dGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICBcdFx0XHRyZXR1cm4gbWF0Y2hbMV0gfHwgbWF0Y2hbMF07XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGFsbG93V2hpdGVzcGFjZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5tYXRjaFBhdHRlcm4ocGFyc2VfUGFyc2VyX19sZWFkaW5nV2hpdGVzcGFjZSk7XG4gIFx0fSxcblxuICBcdHJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuc3RyLnN1YnN0cmluZyh0aGlzLnBvcyk7XG4gIFx0fSxcblxuICBcdG5leHRDaGFyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zdHIuY2hhckF0KHRoaXMucG9zKTtcbiAgXHR9XG4gIH07XG5cbiAgUGFyc2VyLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm90bykge1xuICBcdHZhciBQYXJlbnQgPSB0aGlzLFxuICBcdCAgICBDaGlsZCxcbiAgXHQgICAga2V5O1xuXG4gIFx0Q2hpbGQgPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG4gIFx0XHRQYXJzZXIuY2FsbCh0aGlzLCBzdHIsIG9wdGlvbnMpO1xuICBcdH07XG5cbiAgXHRDaGlsZC5wcm90b3R5cGUgPSBjcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG5cbiAgXHRmb3IgKGtleSBpbiBwcm90bykge1xuICBcdFx0aWYgKGhhc093bi5jYWxsKHByb3RvLCBrZXkpKSB7XG4gIFx0XHRcdENoaWxkLnByb3RvdHlwZVtrZXldID0gcHJvdG9ba2V5XTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRDaGlsZC5leHRlbmQgPSBQYXJzZXIuZXh0ZW5kO1xuICBcdHJldHVybiBDaGlsZDtcbiAgfTtcblxuICB2YXIgcGFyc2VfUGFyc2VyID0gUGFyc2VyO1xuXG4gIHZhciBURVhUID0gMTtcbiAgdmFyIElOVEVSUE9MQVRPUiA9IDI7XG4gIHZhciBUUklQTEUgPSAzO1xuICB2YXIgU0VDVElPTiA9IDQ7XG4gIHZhciBJTlZFUlRFRCA9IDU7XG4gIHZhciBDTE9TSU5HID0gNjtcbiAgdmFyIEVMRU1FTlQgPSA3O1xuICB2YXIgUEFSVElBTCA9IDg7XG4gIHZhciBDT01NRU5UID0gOTtcbiAgdmFyIERFTElNQ0hBTkdFID0gMTA7XG4gIHZhciBBVFRSSUJVVEUgPSAxMztcbiAgdmFyIENMT1NJTkdfVEFHID0gMTQ7XG4gIHZhciBDT01QT05FTlQgPSAxNTtcbiAgdmFyIFlJRUxERVIgPSAxNjtcbiAgdmFyIElOTElORV9QQVJUSUFMID0gMTc7XG4gIHZhciBET0NUWVBFID0gMTg7XG5cbiAgdmFyIE5VTUJFUl9MSVRFUkFMID0gMjA7XG4gIHZhciBTVFJJTkdfTElURVJBTCA9IDIxO1xuICB2YXIgQVJSQVlfTElURVJBTCA9IDIyO1xuICB2YXIgT0JKRUNUX0xJVEVSQUwgPSAyMztcbiAgdmFyIEJPT0xFQU5fTElURVJBTCA9IDI0O1xuICB2YXIgUkVHRVhQX0xJVEVSQUwgPSAyNTtcblxuICB2YXIgR0xPQkFMID0gMjY7XG4gIHZhciBLRVlfVkFMVUVfUEFJUiA9IDI3O1xuXG4gIHZhciBSRUZFUkVOQ0UgPSAzMDtcbiAgdmFyIFJFRklORU1FTlQgPSAzMTtcbiAgdmFyIE1FTUJFUiA9IDMyO1xuICB2YXIgUFJFRklYX09QRVJBVE9SID0gMzM7XG4gIHZhciBCUkFDS0VURUQgPSAzNDtcbiAgdmFyIENPTkRJVElPTkFMID0gMzU7XG4gIHZhciBJTkZJWF9PUEVSQVRPUiA9IDM2O1xuXG4gIHZhciBJTlZPQ0FUSU9OID0gNDA7XG5cbiAgdmFyIFNFQ1RJT05fSUYgPSA1MDtcbiAgdmFyIFNFQ1RJT05fVU5MRVNTID0gNTE7XG4gIHZhciBTRUNUSU9OX0VBQ0ggPSA1MjtcbiAgdmFyIFNFQ1RJT05fV0lUSCA9IDUzO1xuICB2YXIgU0VDVElPTl9JRl9XSVRIID0gNTQ7XG5cbiAgdmFyIEVMU0UgPSA2MDtcbiAgdmFyIEVMU0VJRiA9IDYxO1xuXG4gIHZhciBtdXN0YWNoZV9yZWFkRGVsaW1pdGVyQ2hhbmdlID0gcmVhZERlbGltaXRlckNoYW5nZTtcbiAgdmFyIGRlbGltaXRlckNoYW5nZVBhdHRlcm4gPSAvXlteXFxzPV0rLyxcbiAgICAgIHdoaXRlc3BhY2VQYXR0ZXJuID0gL15cXHMrLztcbiAgZnVuY3Rpb24gcmVhZERlbGltaXRlckNoYW5nZShwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIG9wZW5pbmcsIGNsb3Npbmc7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj1cIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIG5ldyBvcGVuaW5nIGRlbGltaXRlclxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdG9wZW5pbmcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGRlbGltaXRlckNoYW5nZVBhdHRlcm4pO1xuICBcdGlmICghb3BlbmluZykge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSAoaW4gZmFjdCwgaXQncyBuZWNlc3NhcnkuLi4pXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKHdoaXRlc3BhY2VQYXR0ZXJuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Y2xvc2luZyA9IHBhcnNlci5tYXRjaFBhdHRlcm4oZGVsaW1pdGVyQ2hhbmdlUGF0dGVybik7XG4gIFx0aWYgKCFjbG9zaW5nKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBjbG9zaW5nICc9J1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPVwiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIFtvcGVuaW5nLCBjbG9zaW5nXTtcbiAgfVxuXG4gIHZhciByZWFkUmVnZXhwTGl0ZXJhbCA9IHJlYWRSZWdleHBMaXRlcmFsX19yZWFkTnVtYmVyTGl0ZXJhbDtcbiAgdmFyIHJlZ2V4cFBhdHRlcm4gPSAvXihcXC8oPzpbXlxcblxcclxcdTIwMjhcXHUyMDI5L1xcXFxbXXxcXFxcLnxcXFsoPzpbXlxcblxcclxcdTIwMjhcXHUyMDI5XFxdXFxcXF18XFxcXC4pKl0pK1xcLyg/OihbZ2ltdXldKSg/IVthLXpdKlxcMikpKig/IVthLXpBLVpfJDAtOV0pKS87XG4gIGZ1bmN0aW9uIHJlYWRSZWdleHBMaXRlcmFsX19yZWFkTnVtYmVyTGl0ZXJhbChwYXJzZXIpIHtcbiAgXHR2YXIgcmVzdWx0O1xuXG4gIFx0aWYgKHJlc3VsdCA9IHBhcnNlci5tYXRjaFBhdHRlcm4ocmVnZXhwUGF0dGVybikpIHtcbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IFJFR0VYUF9MSVRFUkFMLFxuICBcdFx0XHR2OiByZXN1bHRcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkTXVzdGFjaGUgPSByZWFkTXVzdGFjaGU7XG5cbiAgdmFyIGRlbGltaXRlckNoYW5nZVRva2VuID0geyB0OiBERUxJTUNIQU5HRSwgZXhjbHVkZTogdHJ1ZSB9O1xuICBmdW5jdGlvbiByZWFkTXVzdGFjaGUocGFyc2VyKSB7XG4gIFx0dmFyIG11c3RhY2hlLCBpO1xuXG4gIFx0Ly8gSWYgd2UncmUgaW5zaWRlIGEgPHNjcmlwdD4gb3IgPHN0eWxlPiB0YWcsIGFuZCB3ZSdyZSBub3RcbiAgXHQvLyBpbnRlcnBvbGF0aW5nLCBidWcgb3V0XG4gIFx0aWYgKHBhcnNlci5pbnRlcnBvbGF0ZVtwYXJzZXIuaW5zaWRlXSA9PT0gZmFsc2UpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGZvciAoaSA9IDA7IGkgPCBwYXJzZXIudGFncy5sZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0aWYgKG11c3RhY2hlID0gcmVhZE11c3RhY2hlT2ZUeXBlKHBhcnNlciwgcGFyc2VyLnRhZ3NbaV0pKSB7XG4gIFx0XHRcdHJldHVybiBtdXN0YWNoZTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkTXVzdGFjaGVPZlR5cGUocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIG11c3RhY2hlLCByZWFkZXIsIGk7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiXFxcXFwiICsgdGFnLm9wZW4pKSB7XG4gIFx0XHRpZiAoc3RhcnQgPT09IDAgfHwgcGFyc2VyLnN0cltzdGFydCAtIDFdICE9PSBcIlxcXFxcIikge1xuICBcdFx0XHRyZXR1cm4gdGFnLm9wZW47XG4gIFx0XHR9XG4gIFx0fSBlbHNlIGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5vcGVuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gZGVsaW1pdGVyIGNoYW5nZT9cbiAgXHRpZiAobXVzdGFjaGUgPSBtdXN0YWNoZV9yZWFkRGVsaW1pdGVyQ2hhbmdlKHBhcnNlcikpIHtcbiAgXHRcdC8vIGZpbmQgY2xvc2luZyBkZWxpbWl0ZXIgb3IgYWJvcnQuLi5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIC4uLnRoZW4gbWFrZSB0aGUgc3dpdGNoXG4gIFx0XHR0YWcub3BlbiA9IG11c3RhY2hlWzBdO1xuICBcdFx0dGFnLmNsb3NlID0gbXVzdGFjaGVbMV07XG4gIFx0XHRwYXJzZXIuc29ydE11c3RhY2hlVGFncygpO1xuXG4gIFx0XHRyZXR1cm4gZGVsaW1pdGVyQ2hhbmdlVG9rZW47XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gaWxsZWdhbCBzZWN0aW9uIGNsb3NlclxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIvXCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zIC09IDE7XG4gIFx0XHR2YXIgcmV3aW5kID0gcGFyc2VyLnBvcztcbiAgXHRcdGlmICghcmVhZFJlZ2V4cExpdGVyYWwocGFyc2VyKSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gcmV3aW5kIC0gdGFnLmNsb3NlLmxlbmd0aDtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiQXR0ZW1wdGVkIHRvIGNsb3NlIGEgc2VjdGlvbiB0aGF0IHdhc24ndCBvcGVuXCIpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHJld2luZDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgdGFnLnJlYWRlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdHJlYWRlciA9IHRhZy5yZWFkZXJzW2ldO1xuXG4gIFx0XHRpZiAobXVzdGFjaGUgPSByZWFkZXIocGFyc2VyLCB0YWcpKSB7XG4gIFx0XHRcdGlmICh0YWcuaXNTdGF0aWMpIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS5zID0gdHJ1ZTsgLy8gVE9ETyBtYWtlIHRoaXMgYDFgIGluc3RlYWQgLSBtb3JlIGNvbXBhY3RcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmIChwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMpIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS5wID0gcGFyc2VyLmdldExpbmVQb3Moc3RhcnQpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBleHBlY3RlZEV4cHJlc3Npb24gPSBcIkV4cGVjdGVkIGEgSmF2YVNjcmlwdCBleHByZXNzaW9uXCI7XG4gIHZhciBleHBlY3RlZFBhcmVuID0gXCJFeHBlY3RlZCBjbG9zaW5nIHBhcmVuXCI7XG5cbiAgdmFyIGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWwgPSBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsX19yZWFkTnVtYmVyTGl0ZXJhbDtcbiAgdmFyIGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWxfX251bWJlclBhdHRlcm4gPSAvXig/OlsrLV0/KTAqKD86KD86KD86WzEtOV1cXGQqKT9cXC5cXGQrKXwoPzooPzowfFsxLTldXFxkKilcXC4pfCg/OjB8WzEtOV1cXGQqKSkoPzpbZUVdWystXT9cXGQrKT8vO1xuICBmdW5jdGlvbiBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsX19yZWFkTnVtYmVyTGl0ZXJhbChwYXJzZXIpIHtcbiAgXHR2YXIgcmVzdWx0O1xuXG4gIFx0aWYgKHJlc3VsdCA9IHBhcnNlci5tYXRjaFBhdHRlcm4obGl0ZXJhbF9yZWFkTnVtYmVyTGl0ZXJhbF9fbnVtYmVyUGF0dGVybikpIHtcbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IE5VTUJFUl9MSVRFUkFMLFxuICBcdFx0XHR2OiByZXN1bHRcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGl0ZXJhbF9yZWFkQm9vbGVhbkxpdGVyYWwgPSByZWFkQm9vbGVhbkxpdGVyYWw7XG4gIGZ1bmN0aW9uIHJlYWRCb29sZWFuTGl0ZXJhbChwYXJzZXIpIHtcbiAgXHR2YXIgcmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXG4gIFx0aWYgKHJlbWFpbmluZy5zdWJzdHIoMCwgNCkgPT09IFwidHJ1ZVwiKSB7XG4gIFx0XHRwYXJzZXIucG9zICs9IDQ7XG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBCT09MRUFOX0xJVEVSQUwsXG4gIFx0XHRcdHY6IFwidHJ1ZVwiXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdGlmIChyZW1haW5pbmcuc3Vic3RyKDAsIDUpID09PSBcImZhbHNlXCIpIHtcbiAgXHRcdHBhcnNlci5wb3MgKz0gNTtcbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IEJPT0xFQU5fTElURVJBTCxcbiAgXHRcdFx0djogXCJmYWxzZVwiXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHN0cmluZ01pZGRsZVBhdHRlcm4sIGVzY2FwZVNlcXVlbmNlUGF0dGVybiwgbGluZUNvbnRpbnVhdGlvblBhdHRlcm47XG5cbiAgLy8gTWF0Y2ggb25lIG9yIG1vcmUgY2hhcmFjdGVycyB1bnRpbDogXCIsICcsIFxcLCBvciBFT0wvRU9GLlxuICAvLyBFT0wvRU9GIGlzIHdyaXR0ZW4gYXMgKD8hLikgKG1lYW5pbmcgdGhlcmUncyBubyBub24tbmV3bGluZSBjaGFyIG5leHQpLlxuICBzdHJpbmdNaWRkbGVQYXR0ZXJuID0gL14oPz0uKVteXCInXFxcXF0rPyg/Oig/IS4pfCg/PVtcIidcXFxcXSkpLztcblxuICAvLyBNYXRjaCBvbmUgZXNjYXBlIHNlcXVlbmNlLCBpbmNsdWRpbmcgdGhlIGJhY2tzbGFzaC5cbiAgZXNjYXBlU2VxdWVuY2VQYXR0ZXJuID0gL15cXFxcKD86WydcIlxcXFxiZm5ydF18MCg/IVswLTldKXx4WzAtOWEtZkEtRl17Mn18dVswLTlhLWZBLUZdezR9fCg/PS4pW151eDAtOV0pLztcblxuICAvLyBNYXRjaCBvbmUgRVM1IGxpbmUgY29udGludWF0aW9uIChiYWNrc2xhc2ggKyBsaW5lIHRlcm1pbmF0b3IpLlxuICBsaW5lQ29udGludWF0aW9uUGF0dGVybiA9IC9eXFxcXCg/OlxcclxcbnxbXFx1MDAwQVxcdTAwMERcXHUyMDI4XFx1MjAyOV0pLztcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIGdldERvdWJsZVF1b3RlZFN0cmluZyBhbmQgZ2V0U2luZ2xlUXVvdGVkU3RyaW5nLlxuICB2YXIgbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIgPSBmdW5jdGlvbiAob2tRdW90ZSkge1xuICBcdHJldHVybiBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0XHR2YXIgc3RhcnQsIGxpdGVyYWwsIGRvbmUsIG5leHQ7XG5cbiAgXHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRcdGxpdGVyYWwgPSBcIlxcXCJcIjtcbiAgXHRcdGRvbmUgPSBmYWxzZTtcblxuICBcdFx0d2hpbGUgKCFkb25lKSB7XG4gIFx0XHRcdG5leHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHN0cmluZ01pZGRsZVBhdHRlcm4pIHx8IHBhcnNlci5tYXRjaFBhdHRlcm4oZXNjYXBlU2VxdWVuY2VQYXR0ZXJuKSB8fCBwYXJzZXIubWF0Y2hTdHJpbmcob2tRdW90ZSk7XG4gIFx0XHRcdGlmIChuZXh0KSB7XG4gIFx0XHRcdFx0aWYgKG5leHQgPT09IFwiXFxcIlwiKSB7XG4gIFx0XHRcdFx0XHRsaXRlcmFsICs9IFwiXFxcXFxcXCJcIjtcbiAgXHRcdFx0XHR9IGVsc2UgaWYgKG5leHQgPT09IFwiXFxcXCdcIikge1xuICBcdFx0XHRcdFx0bGl0ZXJhbCArPSBcIidcIjtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0bGl0ZXJhbCArPSBuZXh0O1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRuZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybihsaW5lQ29udGludWF0aW9uUGF0dGVybik7XG4gIFx0XHRcdFx0aWYgKG5leHQpIHtcbiAgXHRcdFx0XHRcdC8vIGNvbnZlcnQgXFwobmV3bGluZS1saWtlKSBpbnRvIGEgXFx1IGVzY2FwZSwgd2hpY2ggaXMgYWxsb3dlZCBpbiBKU09OXG4gIFx0XHRcdFx0XHRsaXRlcmFsICs9IFwiXFxcXHVcIiArIChcIjAwMFwiICsgbmV4dC5jaGFyQ29kZUF0KDEpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0bGl0ZXJhbCArPSBcIlxcXCJcIjtcblxuICBcdFx0Ly8gdXNlIEpTT04ucGFyc2UgdG8gaW50ZXJwcmV0IGVzY2FwZXNcbiAgXHRcdHJldHVybiBKU09OLnBhcnNlKGxpdGVyYWwpO1xuICBcdH07XG4gIH07XG5cbiAgdmFyIGdldFNpbmdsZVF1b3RlZFN0cmluZyA9IG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKFwiXFxcIlwiKTtcbiAgdmFyIGdldERvdWJsZVF1b3RlZFN0cmluZyA9IG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKFwiJ1wiKTtcblxuICB2YXIgcmVhZFN0cmluZ0xpdGVyYWwgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBzdHJpbmc7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiXFxcIlwiKSkge1xuICBcdFx0c3RyaW5nID0gZ2V0RG91YmxlUXVvdGVkU3RyaW5nKHBhcnNlcik7XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiXFxcIlwiKSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBTVFJJTkdfTElURVJBTCxcbiAgXHRcdFx0djogc3RyaW5nXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCInXCIpKSB7XG4gIFx0XHRzdHJpbmcgPSBnZXRTaW5nbGVRdW90ZWRTdHJpbmcocGFyc2VyKTtcblxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCInXCIpKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IFNUUklOR19MSVRFUkFMLFxuICBcdFx0XHR2OiBzdHJpbmdcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIHBhdHRlcm5zX19uYW1lID0gL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSovO1xuXG4gIC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtcHJvcGVydGllc1xuICAvLyBjYW4gYmUgYW55IG5hbWUsIHN0cmluZyBsaXRlcmFsLCBvciBudW1iZXIgbGl0ZXJhbFxuICB2YXIgc2hhcmVkX3JlYWRLZXkgPSByZWFkS2V5O1xuICB2YXIgaWRlbnRpZmllciA9IC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qJC87XG4gIGZ1bmN0aW9uIHJlYWRLZXkocGFyc2VyKSB7XG4gIFx0dmFyIHRva2VuO1xuXG4gIFx0aWYgKHRva2VuID0gcmVhZFN0cmluZ0xpdGVyYWwocGFyc2VyKSkge1xuICBcdFx0cmV0dXJuIGlkZW50aWZpZXIudGVzdCh0b2tlbi52KSA/IHRva2VuLnYgOiBcIlxcXCJcIiArIHRva2VuLnYucmVwbGFjZSgvXCIvZywgXCJcXFxcXFxcIlwiKSArIFwiXFxcIlwiO1xuICBcdH1cblxuICBcdGlmICh0b2tlbiA9IGxpdGVyYWxfcmVhZE51bWJlckxpdGVyYWwocGFyc2VyKSkge1xuICBcdFx0cmV0dXJuIHRva2VuLnY7XG4gIFx0fVxuXG4gIFx0aWYgKHRva2VuID0gcGFyc2VyLm1hdGNoUGF0dGVybihwYXR0ZXJuc19fbmFtZSkpIHtcbiAgXHRcdHJldHVybiB0b2tlbjtcbiAgXHR9XG4gIH1cblxuICB2YXIga2V5VmFsdWVQYWlyID0gcmVhZEtleVZhbHVlUGFpcjtcbiAgZnVuY3Rpb24gcmVhZEtleVZhbHVlUGFpcihwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGtleSwgdmFsdWU7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJ3snIGFuZCBrZXlcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRrZXkgPSBzaGFyZWRfcmVhZEtleShwYXJzZXIpO1xuICBcdGlmIChrZXkgPT09IG51bGwpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBrZXkgYW5kICc6J1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIG5leHQgY2hhcmFjdGVyIG11c3QgYmUgJzonXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI6XCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJzonIGFuZCB2YWx1ZVxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIG5leHQgZXhwcmVzc2lvbiBtdXN0IGJlIGEsIHdlbGwuLi4gZXhwcmVzc2lvblxuICBcdHZhbHVlID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICBcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IEtFWV9WQUxVRV9QQUlSLFxuICBcdFx0azoga2V5LFxuICBcdFx0djogdmFsdWVcbiAgXHR9O1xuICB9XG5cbiAgdmFyIG9iamVjdExpdGVyYWxfa2V5VmFsdWVQYWlycyA9IHJlYWRLZXlWYWx1ZVBhaXJzO1xuICBmdW5jdGlvbiByZWFkS2V5VmFsdWVQYWlycyhwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIHBhaXJzLCBwYWlyLCBrZXlWYWx1ZVBhaXJzO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0cGFpciA9IGtleVZhbHVlUGFpcihwYXJzZXIpO1xuICBcdGlmIChwYWlyID09PSBudWxsKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYWlycyA9IFtwYWlyXTtcblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIsXCIpKSB7XG4gIFx0XHRrZXlWYWx1ZVBhaXJzID0gcmVhZEtleVZhbHVlUGFpcnMocGFyc2VyKTtcblxuICBcdFx0aWYgKCFrZXlWYWx1ZVBhaXJzKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwYWlycy5jb25jYXQoa2V5VmFsdWVQYWlycyk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHBhaXJzO1xuICB9XG5cbiAgdmFyIHJlYWRPYmplY3RMaXRlcmFsID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwga2V5VmFsdWVQYWlycztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2VcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIntcIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGtleVZhbHVlUGFpcnMgPSBvYmplY3RMaXRlcmFsX2tleVZhbHVlUGFpcnMocGFyc2VyKTtcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBmaW5hbCB2YWx1ZSBhbmQgJ30nXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJ9XCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogT0JKRUNUX0xJVEVSQUwsXG4gIFx0XHRtOiBrZXlWYWx1ZVBhaXJzXG4gIFx0fTtcbiAgfTtcblxuICB2YXIgc2hhcmVkX3JlYWRFeHByZXNzaW9uTGlzdCA9IHJlYWRFeHByZXNzaW9uTGlzdDtcbiAgZnVuY3Rpb24gcmVhZEV4cHJlc3Npb25MaXN0KHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbnMsIGV4cHIsIG5leHQ7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRleHByID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuXG4gIFx0aWYgKGV4cHIgPT09IG51bGwpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGV4cHJlc3Npb25zID0gW2V4cHJdO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuIGV4cHJlc3Npb24gYW5kICcsJ1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIsXCIpKSB7XG4gIFx0XHRuZXh0ID0gcmVhZEV4cHJlc3Npb25MaXN0KHBhcnNlcik7XG4gIFx0XHRpZiAobmV4dCA9PT0gbnVsbCkge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHRcdH1cblxuICBcdFx0bmV4dC5mb3JFYWNoKGFwcGVuZCk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gYXBwZW5kKGV4cHJlc3Npb24pIHtcbiAgXHRcdGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGV4cHJlc3Npb25zO1xuICB9XG5cbiAgdmFyIHJlYWRBcnJheUxpdGVyYWwgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uTGlzdDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlICdbJ1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiW1wiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0ZXhwcmVzc2lvbkxpc3QgPSBzaGFyZWRfcmVhZEV4cHJlc3Npb25MaXN0KHBhcnNlcik7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIl1cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBBUlJBWV9MSVRFUkFMLFxuICBcdFx0bTogZXhwcmVzc2lvbkxpc3RcbiAgXHR9O1xuICB9O1xuXG4gIHZhciBwcmltYXJ5X3JlYWRMaXRlcmFsID0gcmVhZExpdGVyYWw7XG4gIGZ1bmN0aW9uIHJlYWRMaXRlcmFsKHBhcnNlcikge1xuICBcdHJldHVybiBsaXRlcmFsX3JlYWROdW1iZXJMaXRlcmFsKHBhcnNlcikgfHwgbGl0ZXJhbF9yZWFkQm9vbGVhbkxpdGVyYWwocGFyc2VyKSB8fCByZWFkU3RyaW5nTGl0ZXJhbChwYXJzZXIpIHx8IHJlYWRPYmplY3RMaXRlcmFsKHBhcnNlcikgfHwgcmVhZEFycmF5TGl0ZXJhbChwYXJzZXIpIHx8IHJlYWRSZWdleHBMaXRlcmFsKHBhcnNlcik7XG4gIH1cblxuICB2YXIgcHJpbWFyeV9yZWFkUmVmZXJlbmNlID0gcmVhZFJlZmVyZW5jZTtcbiAgdmFyIHByZWZpeFBhdHRlcm4gPSAvXig/On5cXC98KD86XFwuXFwuXFwvKSt8XFwuXFwvKD86XFwuXFwuXFwvKSp8XFwuKS8sXG4gICAgICBnbG9iYWxzLFxuICAgICAga2V5d29yZHM7XG5cbiAgLy8gaWYgYSByZWZlcmVuY2UgaXMgYSBicm93c2VyIGdsb2JhbCwgd2UgZG9uJ3QgZGVmZXJlbmNlIGl0IGxhdGVyLCBzbyBpdCBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudFxuICBnbG9iYWxzID0gL14oPzpBcnJheXxjb25zb2xlfERhdGV8UmVnRXhwfGRlY29kZVVSSUNvbXBvbmVudHxkZWNvZGVVUkl8ZW5jb2RlVVJJQ29tcG9uZW50fGVuY29kZVVSSXxpc0Zpbml0ZXxpc05hTnxwYXJzZUZsb2F0fHBhcnNlSW50fEpTT058TWF0aHxOYU58dW5kZWZpbmVkfG51bGwpXFxiLztcblxuICAvLyBrZXl3b3JkcyBhcmUgbm90IHZhbGlkIHJlZmVyZW5jZXMsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBgdGhpc2BcbiAga2V5d29yZHMgPSAvXig/OmJyZWFrfGNhc2V8Y2F0Y2h8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxmaW5hbGx5fGZvcnxmdW5jdGlvbnxpZnxpbnxpbnN0YW5jZW9mfG5ld3xyZXR1cm58c3dpdGNofHRocm93fHRyeXx0eXBlb2Z8dmFyfHZvaWR8d2hpbGV8d2l0aCkkLztcblxuICB2YXIgbGVnYWxSZWZlcmVuY2UgPSAvXlthLXpBLVokXzAtOV0rKD86KD86XFwuW2EtekEtWiRfMC05XSspfCg/OlxcW1swLTldK1xcXSkpKi87XG4gIHZhciByZWxheGVkTmFtZSA9IC9eW2EtekEtWl8kXVstYS16QS1aXyQwLTldKi87XG4gIGZ1bmN0aW9uIHJlYWRSZWZlcmVuY2UocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0UG9zLCBwcmVmaXgsIG5hbWUsIGdsb2JhbCwgcmVmZXJlbmNlLCBsYXN0RG90SW5kZXg7XG5cbiAgXHRzdGFydFBvcyA9IHBhcnNlci5wb3M7XG5cbiAgXHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybigvXkAoPzprZXlwYXRofGluZGV4fGtleSkvKTtcblxuICBcdGlmICghbmFtZSkge1xuICBcdFx0cHJlZml4ID0gcGFyc2VyLm1hdGNoUGF0dGVybihwcmVmaXhQYXR0ZXJuKSB8fCBcIlwiO1xuICBcdFx0bmFtZSA9ICFwcmVmaXggJiYgcGFyc2VyLnJlbGF4ZWROYW1lcyAmJiBwYXJzZXIubWF0Y2hQYXR0ZXJuKHJlbGF4ZWROYW1lKSB8fCBwYXJzZXIubWF0Y2hQYXR0ZXJuKGxlZ2FsUmVmZXJlbmNlKTtcblxuICBcdFx0aWYgKCFuYW1lICYmIHByZWZpeCA9PT0gXCIuXCIpIHtcbiAgXHRcdFx0cHJlZml4ID0gXCJcIjtcbiAgXHRcdFx0bmFtZSA9IFwiLlwiO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICghbmFtZSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gYnVnIG91dCBpZiBpdCdzIGEga2V5d29yZCAoZXhjZXB0aW9uIGZvciBhbmNlc3Rvci9yZXN0cmljdGVkIHJlZnMgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy8xNDk3KVxuICBcdGlmICghcHJlZml4ICYmICFwYXJzZXIucmVsYXhlZE5hbWVzICYmIGtleXdvcmRzLnRlc3QobmFtZSkpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydFBvcztcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGlmIHRoaXMgaXMgYSBicm93c2VyIGdsb2JhbCwgc3RvcCBoZXJlXG4gIFx0aWYgKCFwcmVmaXggJiYgZ2xvYmFscy50ZXN0KG5hbWUpKSB7XG4gIFx0XHRnbG9iYWwgPSBnbG9iYWxzLmV4ZWMobmFtZSlbMF07XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3MgKyBnbG9iYWwubGVuZ3RoO1xuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBHTE9CQUwsXG4gIFx0XHRcdHY6IGdsb2JhbFxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZWZlcmVuY2UgPSAocHJlZml4IHx8IFwiXCIpICsgbm9ybWFsaXNlKG5hbWUpO1xuXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIihcIikpIHtcbiAgXHRcdC8vIGlmIHRoaXMgaXMgYSBtZXRob2QgaW52b2NhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIGZ1bmN0aW9uKSB3ZSBuZWVkXG4gIFx0XHQvLyB0byBzdHJpcCB0aGUgbWV0aG9kIG5hbWUgZnJvbSB0aGUgcmVmZXJlbmNlIGNvbWJvLCBlbHNlIHRoZSBjb250ZXh0XG4gIFx0XHQvLyB3aWxsIGJlIHdyb25nXG4gIFx0XHRsYXN0RG90SW5kZXggPSByZWZlcmVuY2UubGFzdEluZGV4T2YoXCIuXCIpO1xuICBcdFx0aWYgKGxhc3REb3RJbmRleCAhPT0gLTEpIHtcbiAgXHRcdFx0cmVmZXJlbmNlID0gcmVmZXJlbmNlLnN1YnN0cigwLCBsYXN0RG90SW5kZXgpO1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3MgKyByZWZlcmVuY2UubGVuZ3RoO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyAtPSAxO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBSRUZFUkVOQ0UsXG4gIFx0XHRuOiByZWZlcmVuY2UucmVwbGFjZSgvXnRoaXNcXC4vLCBcIi4vXCIpLnJlcGxhY2UoL150aGlzJC8sIFwiLlwiKVxuICBcdH07XG4gIH1cblxuICB2YXIgcHJpbWFyeV9yZWFkQnJhY2tldGVkRXhwcmVzc2lvbiA9IHJlYWRCcmFja2V0ZWRFeHByZXNzaW9uO1xuICBmdW5jdGlvbiByZWFkQnJhY2tldGVkRXhwcmVzc2lvbihwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHI7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIihcIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGV4cHIgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0aWYgKCFleHByKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIilcIikpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihleHBlY3RlZFBhcmVuKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogQlJBQ0tFVEVELFxuICBcdFx0eDogZXhwclxuICBcdH07XG4gIH1cblxuICB2YXIgcmVhZFByaW1hcnkgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIFx0cmV0dXJuIHByaW1hcnlfcmVhZExpdGVyYWwocGFyc2VyKSB8fCBwcmltYXJ5X3JlYWRSZWZlcmVuY2UocGFyc2VyKSB8fCBwcmltYXJ5X3JlYWRCcmFja2V0ZWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIH07XG5cbiAgdmFyIHNoYXJlZF9yZWFkUmVmaW5lbWVudCA9IHJlYWRSZWZpbmVtZW50O1xuICBmdW5jdGlvbiByZWFkUmVmaW5lbWVudChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIG5hbWUsIGV4cHI7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBcIi5cIiBuYW1lXG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIi5cIikpIHtcbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0aWYgKG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHBhdHRlcm5zX19uYW1lKSkge1xuICBcdFx0XHRyZXR1cm4ge1xuICBcdFx0XHRcdHQ6IFJFRklORU1FTlQsXG4gIFx0XHRcdFx0bjogbmFtZVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBhIHByb3BlcnR5IG5hbWVcIik7XG4gIFx0fVxuXG4gIFx0Ly8gXCJbXCIgZXhwcmVzc2lvbiBcIl1cIlxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJbXCIpKSB7XG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdGV4cHIgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0XHRpZiAoIWV4cHIpIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkRXhwcmVzc2lvbik7XG4gIFx0XHR9XG5cbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCJdXCIpKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkICddJ1wiKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogUkVGSU5FTUVOVCxcbiAgXHRcdFx0eDogZXhwclxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciByZWFkTWVtYmVyT3JJbnZvY2F0aW9uID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdHZhciBjdXJyZW50LCBleHByZXNzaW9uLCByZWZpbmVtZW50LCBleHByZXNzaW9uTGlzdDtcblxuICBcdGV4cHJlc3Npb24gPSByZWFkUHJpbWFyeShwYXJzZXIpO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHR3aGlsZSAoZXhwcmVzc2lvbikge1xuICBcdFx0Y3VycmVudCA9IHBhcnNlci5wb3M7XG5cbiAgXHRcdGlmIChyZWZpbmVtZW50ID0gc2hhcmVkX3JlYWRSZWZpbmVtZW50KHBhcnNlcikpIHtcbiAgXHRcdFx0ZXhwcmVzc2lvbiA9IHtcbiAgXHRcdFx0XHR0OiBNRU1CRVIsXG4gIFx0XHRcdFx0eDogZXhwcmVzc2lvbixcbiAgXHRcdFx0XHRyOiByZWZpbmVtZW50XG4gIFx0XHRcdH07XG4gIFx0XHR9IGVsc2UgaWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIihcIikpIHtcbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdFx0XHRleHByZXNzaW9uTGlzdCA9IHNoYXJlZF9yZWFkRXhwcmVzc2lvbkxpc3QocGFyc2VyKTtcblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIpXCIpKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkUGFyZW4pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0ZXhwcmVzc2lvbiA9IHtcbiAgXHRcdFx0XHR0OiBJTlZPQ0FUSU9OLFxuICBcdFx0XHRcdHg6IGV4cHJlc3Npb25cbiAgXHRcdFx0fTtcblxuICBcdFx0XHRpZiAoZXhwcmVzc2lvbkxpc3QpIHtcbiAgXHRcdFx0XHRleHByZXNzaW9uLm8gPSBleHByZXNzaW9uTGlzdDtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0YnJlYWs7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGV4cHJlc3Npb247XG4gIH07XG5cbiAgdmFyIHJlYWRUeXBlT2YsIG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXI7XG5cbiAgbWFrZVByZWZpeFNlcXVlbmNlTWF0Y2hlciA9IGZ1bmN0aW9uIChzeW1ib2wsIGZhbGx0aHJvdWdoKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgXHRcdHZhciBleHByZXNzaW9uO1xuXG4gIFx0XHRpZiAoZXhwcmVzc2lvbiA9IGZhbGx0aHJvdWdoKHBhcnNlcikpIHtcbiAgXHRcdFx0cmV0dXJuIGV4cHJlc3Npb247XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHN5bWJvbCkpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0ZXhwcmVzc2lvbiA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRcdGlmICghZXhwcmVzc2lvbikge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoZXhwZWN0ZWRFeHByZXNzaW9uKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0czogc3ltYm9sLFxuICBcdFx0XHRvOiBleHByZXNzaW9uLFxuICBcdFx0XHR0OiBQUkVGSVhfT1BFUkFUT1JcbiAgXHRcdH07XG4gIFx0fTtcbiAgfTtcblxuICAvLyBjcmVhdGUgYWxsIHByZWZpeCBzZXF1ZW5jZSBtYXRjaGVycywgcmV0dXJuIHJlYWRUeXBlT2ZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgaSwgbGVuLCBtYXRjaGVyLCBwcmVmaXhPcGVyYXRvcnMsIGZhbGx0aHJvdWdoO1xuXG4gIFx0cHJlZml4T3BlcmF0b3JzID0gXCIhIH4gKyAtIHR5cGVvZlwiLnNwbGl0KFwiIFwiKTtcblxuICBcdGZhbGx0aHJvdWdoID0gcmVhZE1lbWJlck9ySW52b2NhdGlvbjtcbiAgXHRmb3IgKGkgPSAwLCBsZW4gPSBwcmVmaXhPcGVyYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG1hdGNoZXIgPSBtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyKHByZWZpeE9wZXJhdG9yc1tpXSwgZmFsbHRocm91Z2gpO1xuICBcdFx0ZmFsbHRocm91Z2ggPSBtYXRjaGVyO1xuICBcdH1cblxuICBcdC8vIHR5cGVvZiBvcGVyYXRvciBpcyBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuIG11bHRpcGxpY2F0aW9uLCBzbyBwcm92aWRlcyB0aGVcbiAgXHQvLyBmYWxsdGhyb3VnaCBmb3IgdGhlIG11bHRpcGxpY2F0aW9uIHNlcXVlbmNlIG1hdGNoZXIgd2UncmUgYWJvdXQgdG8gY3JlYXRlXG4gIFx0Ly8gKHdlJ3JlIHNraXBwaW5nIHZvaWQgYW5kIGRlbGV0ZSlcbiAgXHRyZWFkVHlwZU9mID0gZmFsbHRocm91Z2g7XG4gIH0pKCk7XG5cbiAgdmFyIHJlYWRUeXBlb2YgPSByZWFkVHlwZU9mO1xuXG4gIHZhciByZWFkTG9naWNhbE9yLCBtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXI7XG5cbiAgbWFrZUluZml4U2VxdWVuY2VNYXRjaGVyID0gZnVuY3Rpb24gKHN5bWJvbCwgZmFsbHRocm91Z2gpIHtcbiAgXHRyZXR1cm4gZnVuY3Rpb24gKHBhcnNlcikge1xuICBcdFx0dmFyIHN0YXJ0LCBsZWZ0LCByaWdodDtcblxuICBcdFx0bGVmdCA9IGZhbGx0aHJvdWdoKHBhcnNlcik7XG4gIFx0XHRpZiAoIWxlZnQpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIExvb3AgdG8gaGFuZGxlIGxlZnQtcmVjdXJzaW9uIGluIGEgY2FzZSBsaWtlIGBhICogYiAqIGNgIGFuZCBwcm9kdWNlXG4gIFx0XHQvLyBsZWZ0IGFzc29jaWF0aW9uLCBpLmUuIGAoYSAqIGIpICogY2AuICBUaGUgbWF0Y2hlciBjYW4ndCBjYWxsIGl0c2VsZlxuICBcdFx0Ly8gdG8gcGFyc2UgYGxlZnRgIGJlY2F1c2UgdGhhdCB3b3VsZCBiZSBpbmZpbml0ZSByZWdyZXNzLlxuICBcdFx0d2hpbGUgKHRydWUpIHtcbiAgXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhzeW1ib2wpKSB7XG4gIFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRcdHJldHVybiBsZWZ0O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gaW4gb3BlcmF0b3IgbXVzdCBub3QgYmUgZm9sbG93ZWQgYnkgW2EtekEtWl8kMC05XVxuICBcdFx0XHRpZiAoc3ltYm9sID09PSBcImluXCIgJiYgL1thLXpBLVpfJDAtOV0vLnRlc3QocGFyc2VyLnJlbWFpbmluZygpLmNoYXJBdCgwKSkpIHtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0Ly8gcmlnaHQgb3BlcmFuZCBtdXN0IGFsc28gY29uc2lzdCBvZiBvbmx5IGhpZ2hlci1wcmVjZWRlbmNlIG9wZXJhdG9yc1xuICBcdFx0XHRyaWdodCA9IGZhbGx0aHJvdWdoKHBhcnNlcik7XG4gIFx0XHRcdGlmICghcmlnaHQpIHtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRsZWZ0ID0ge1xuICBcdFx0XHRcdHQ6IElORklYX09QRVJBVE9SLFxuICBcdFx0XHRcdHM6IHN5bWJvbCxcbiAgXHRcdFx0XHRvOiBbbGVmdCwgcmlnaHRdXG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0Ly8gTG9vcCBiYWNrIGFyb3VuZC4gIElmIHdlIGRvbid0IHNlZSBhbm90aGVyIG9jY3VycmVuY2Ugb2YgdGhlIHN5bWJvbCxcbiAgXHRcdFx0Ly8gd2UnbGwgcmV0dXJuIGxlZnQuXG4gIFx0XHR9XG4gIFx0fTtcbiAgfTtcblxuICAvLyBjcmVhdGUgYWxsIGluZml4IHNlcXVlbmNlIG1hdGNoZXJzLCBhbmQgcmV0dXJuIHJlYWRMb2dpY2FsT3JcbiAgKGZ1bmN0aW9uICgpIHtcbiAgXHR2YXIgaSwgbGVuLCBtYXRjaGVyLCBpbmZpeE9wZXJhdG9ycywgZmFsbHRocm91Z2g7XG5cbiAgXHQvLyBBbGwgdGhlIGluZml4IG9wZXJhdG9ycyBvbiBvcmRlciBvZiBwcmVjZWRlbmNlIChzb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL09wZXJhdG9yX1ByZWNlZGVuY2UpXG4gIFx0Ly8gRWFjaCBzZXF1ZW5jZSBtYXRjaGVyIHdpbGwgaW5pdGlhbGx5IGZhbGwgdGhyb3VnaCB0byBpdHMgaGlnaGVyIHByZWNlZGVuY2VcbiAgXHQvLyBuZWlnaGJvdXIsIGFuZCBvbmx5IGF0dGVtcHQgdG8gbWF0Y2ggaWYgb25lIG9mIHRoZSBoaWdoZXIgcHJlY2VkZW5jZSBvcGVyYXRvcnNcbiAgXHQvLyAob3IsIHVsdGltYXRlbHksIGEgbGl0ZXJhbCwgcmVmZXJlbmNlLCBvciBicmFja2V0ZWQgZXhwcmVzc2lvbikgYWxyZWFkeSBtYXRjaGVkXG4gIFx0aW5maXhPcGVyYXRvcnMgPSBcIiogLyAlICsgLSA8PCA+PiA+Pj4gPCA8PSA+ID49IGluIGluc3RhbmNlb2YgPT0gIT0gPT09ICE9PSAmIF4gfCAmJiB8fFwiLnNwbGl0KFwiIFwiKTtcblxuICBcdC8vIEEgdHlwZW9mIG9wZXJhdG9yIGlzIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gbXVsdGlwbGljYXRpb25cbiAgXHRmYWxsdGhyb3VnaCA9IHJlYWRUeXBlb2Y7XG4gIFx0Zm9yIChpID0gMCwgbGVuID0gaW5maXhPcGVyYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdG1hdGNoZXIgPSBtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXIoaW5maXhPcGVyYXRvcnNbaV0sIGZhbGx0aHJvdWdoKTtcbiAgXHRcdGZhbGx0aHJvdWdoID0gbWF0Y2hlcjtcbiAgXHR9XG5cbiAgXHQvLyBMb2dpY2FsIE9SIGlzIHRoZSBmYWxsdGhyb3VnaCBmb3IgdGhlIGNvbmRpdGlvbmFsIG1hdGNoZXJcbiAgXHRyZWFkTG9naWNhbE9yID0gZmFsbHRocm91Z2g7XG4gIH0pKCk7XG5cbiAgdmFyIGV4cHJlc3Npb25zX3JlYWRMb2dpY2FsT3IgPSByZWFkTG9naWNhbE9yO1xuXG4gIC8vIFRoZSBjb25kaXRpb25hbCBvcGVyYXRvciBpcyB0aGUgbG93ZXN0IHByZWNlZGVuY2Ugb3BlcmF0b3IsIHNvIHdlIHN0YXJ0IGhlcmVcbiAgdmFyIHJlYWRDb25kaXRpb25hbCA9IGdldENvbmRpdGlvbmFsO1xuICBmdW5jdGlvbiBnZXRDb25kaXRpb25hbChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb24sIGlmVHJ1ZSwgaWZGYWxzZTtcblxuICBcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uc19yZWFkTG9naWNhbE9yKHBhcnNlcik7XG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj9cIikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBleHByZXNzaW9uO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmVHJ1ZSA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRpZiAoIWlmVHJ1ZSkge1xuICBcdFx0cGFyc2VyLmVycm9yKGV4cGVjdGVkRXhwcmVzc2lvbik7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI6XCIpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBcXFwiOlxcXCJcIik7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWZGYWxzZSA9IGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgXHRpZiAoIWlmRmFsc2UpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihleHBlY3RlZEV4cHJlc3Npb24pO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBDT05ESVRJT05BTCxcbiAgXHRcdG86IFtleHByZXNzaW9uLCBpZlRydWUsIGlmRmFsc2VdXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uID0gcmVhZEV4cHJlc3Npb247XG4gIGZ1bmN0aW9uIHJlYWRFeHByZXNzaW9uKHBhcnNlcikge1xuICBcdC8vIFRoZSBjb25kaXRpb25hbCBvcGVyYXRvciBpcyB0aGUgbG93ZXN0IHByZWNlZGVuY2Ugb3BlcmF0b3IgKGV4Y2VwdCB5aWVsZCxcbiAgXHQvLyBhc3NpZ25tZW50IG9wZXJhdG9ycywgYW5kIGNvbW1hcywgbm9uZSBvZiB3aGljaCBhcmUgc3VwcG9ydGVkKSwgc28gd2VcbiAgXHQvLyBzdGFydCB0aGVyZS4gSWYgaXQgZG9lc24ndCBtYXRjaCwgaXQgJ2ZhbGxzIHRocm91Z2gnIHRvIHByb2dyZXNzaXZlbHlcbiAgXHQvLyBoaWdoZXIgcHJlY2VkZW5jZSBvcGVyYXRvcnMsIHVudGlsIGl0IGV2ZW50dWFsbHkgbWF0Y2hlcyAob3IgZmFpbHMgdG9cbiAgXHQvLyBtYXRjaCkgYSAncHJpbWFyeScgLSBhIGxpdGVyYWwgb3IgYSByZWZlcmVuY2UuIFRoaXMgd2F5LCB0aGUgYWJzdHJhY3Qgc3ludGF4XG4gIFx0Ly8gdHJlZSBoYXMgZXZlcnl0aGluZyBpbiBpdHMgcHJvcGVyIHBsYWNlLCBpLmUuIDIgKyAzICogNCA9PT0gMTQsIG5vdCAyMC5cbiAgXHRyZXR1cm4gcmVhZENvbmRpdGlvbmFsKHBhcnNlcik7XG4gIH1cblxuICB2YXIgdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24gPSBmbGF0dGVuRXhwcmVzc2lvbjtcblxuICBmdW5jdGlvbiBmbGF0dGVuRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gIFx0dmFyIHJlZnM7XG5cbiAgXHRleHRyYWN0UmVmcyhleHByZXNzaW9uLCByZWZzID0gW10pO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHI6IHJlZnMsXG4gIFx0XHRzOiBzdHJpbmdpZnkoZXhwcmVzc2lvbilcbiAgXHR9O1xuXG4gIFx0ZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUpIHtcbiAgXHRcdHN3aXRjaCAobm9kZS50KSB7XG4gIFx0XHRcdGNhc2UgQk9PTEVBTl9MSVRFUkFMOlxuICBcdFx0XHRjYXNlIEdMT0JBTDpcbiAgXHRcdFx0Y2FzZSBOVU1CRVJfTElURVJBTDpcbiAgXHRcdFx0Y2FzZSBSRUdFWFBfTElURVJBTDpcbiAgXHRcdFx0XHRyZXR1cm4gbm9kZS52O1xuXG4gIFx0XHRcdGNhc2UgU1RSSU5HX0xJVEVSQUw6XG4gIFx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KFN0cmluZyhub2RlLnYpKTtcblxuICBcdFx0XHRjYXNlIEFSUkFZX0xJVEVSQUw6XG4gIFx0XHRcdFx0cmV0dXJuIFwiW1wiICsgKG5vZGUubSA/IG5vZGUubS5tYXAoc3RyaW5naWZ5KS5qb2luKFwiLFwiKSA6IFwiXCIpICsgXCJdXCI7XG5cbiAgXHRcdFx0Y2FzZSBPQkpFQ1RfTElURVJBTDpcbiAgXHRcdFx0XHRyZXR1cm4gXCJ7XCIgKyAobm9kZS5tID8gbm9kZS5tLm1hcChzdHJpbmdpZnkpLmpvaW4oXCIsXCIpIDogXCJcIikgKyBcIn1cIjtcblxuICBcdFx0XHRjYXNlIEtFWV9WQUxVRV9QQUlSOlxuICBcdFx0XHRcdHJldHVybiBub2RlLmsgKyBcIjpcIiArIHN0cmluZ2lmeShub2RlLnYpO1xuXG4gIFx0XHRcdGNhc2UgUFJFRklYX09QRVJBVE9SOlxuICBcdFx0XHRcdHJldHVybiAobm9kZS5zID09PSBcInR5cGVvZlwiID8gXCJ0eXBlb2YgXCIgOiBub2RlLnMpICsgc3RyaW5naWZ5KG5vZGUubyk7XG5cbiAgXHRcdFx0Y2FzZSBJTkZJWF9PUEVSQVRPUjpcbiAgXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KG5vZGUub1swXSkgKyAobm9kZS5zLnN1YnN0cigwLCAyKSA9PT0gXCJpblwiID8gXCIgXCIgKyBub2RlLnMgKyBcIiBcIiA6IG5vZGUucykgKyBzdHJpbmdpZnkobm9kZS5vWzFdKTtcblxuICBcdFx0XHRjYXNlIElOVk9DQVRJT046XG4gIFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeShub2RlLngpICsgXCIoXCIgKyAobm9kZS5vID8gbm9kZS5vLm1hcChzdHJpbmdpZnkpLmpvaW4oXCIsXCIpIDogXCJcIikgKyBcIilcIjtcblxuICBcdFx0XHRjYXNlIEJSQUNLRVRFRDpcbiAgXHRcdFx0XHRyZXR1cm4gXCIoXCIgKyBzdHJpbmdpZnkobm9kZS54KSArIFwiKVwiO1xuXG4gIFx0XHRcdGNhc2UgTUVNQkVSOlxuICBcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkobm9kZS54KSArIHN0cmluZ2lmeShub2RlLnIpO1xuXG4gIFx0XHRcdGNhc2UgUkVGSU5FTUVOVDpcbiAgXHRcdFx0XHRyZXR1cm4gbm9kZS5uID8gXCIuXCIgKyBub2RlLm4gOiBcIltcIiArIHN0cmluZ2lmeShub2RlLngpICsgXCJdXCI7XG5cbiAgXHRcdFx0Y2FzZSBDT05ESVRJT05BTDpcbiAgXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KG5vZGUub1swXSkgKyBcIj9cIiArIHN0cmluZ2lmeShub2RlLm9bMV0pICsgXCI6XCIgKyBzdHJpbmdpZnkobm9kZS5vWzJdKTtcblxuICBcdFx0XHRjYXNlIFJFRkVSRU5DRTpcbiAgXHRcdFx0XHRyZXR1cm4gXCJfXCIgKyByZWZzLmluZGV4T2Yobm9kZS5uKTtcblxuICBcdFx0XHRkZWZhdWx0OlxuICBcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGxlZ2FsIEphdmFTY3JpcHRcIik7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgLy8gVE9ETyBtYXliZSByZWZhY3RvciB0aGlzP1xuICBmdW5jdGlvbiBleHRyYWN0UmVmcyhub2RlLCByZWZzKSB7XG4gIFx0dmFyIGksIGxpc3Q7XG5cbiAgXHRpZiAobm9kZS50ID09PSBSRUZFUkVOQ0UpIHtcbiAgXHRcdGlmIChyZWZzLmluZGV4T2Yobm9kZS5uKSA9PT0gLTEpIHtcbiAgXHRcdFx0cmVmcy51bnNoaWZ0KG5vZGUubik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0bGlzdCA9IG5vZGUubyB8fCBub2RlLm07XG4gIFx0aWYgKGxpc3QpIHtcbiAgXHRcdGlmIChpc09iamVjdChsaXN0KSkge1xuICBcdFx0XHRleHRyYWN0UmVmcyhsaXN0LCByZWZzKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGV4dHJhY3RSZWZzKGxpc3RbaV0sIHJlZnMpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKG5vZGUueCkge1xuICBcdFx0ZXh0cmFjdFJlZnMobm9kZS54LCByZWZzKTtcbiAgXHR9XG5cbiAgXHRpZiAobm9kZS5yKSB7XG4gIFx0XHRleHRyYWN0UmVmcyhub2RlLnIsIHJlZnMpO1xuICBcdH1cblxuICBcdGlmIChub2RlLnYpIHtcbiAgXHRcdGV4dHJhY3RSZWZzKG5vZGUudiwgcmVmcyk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHV0aWxzX3JlZmluZUV4cHJlc3Npb24gPSByZWZpbmVFeHByZXNzaW9uO1xuXG4gIHZhciBhcnJheU1lbWJlclBhdHRlcm4gPSAvXlswLTldWzEtOV0qJC87XG4gIGZ1bmN0aW9uIHJlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgbXVzdGFjaGUpIHtcbiAgXHR2YXIgcmVmZXJlbmNlRXhwcmVzc2lvbjtcblxuICBcdGlmIChleHByZXNzaW9uKSB7XG4gIFx0XHR3aGlsZSAoZXhwcmVzc2lvbi50ID09PSBCUkFDS0VURUQgJiYgZXhwcmVzc2lvbi54KSB7XG4gIFx0XHRcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uLng7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGludGVnZXJzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGFycmF5IG1lbWJlcnMgcmVmZXJlbmNlcyxcbiAgXHRcdC8vIHJhdGhlciB0aGFuIGFzIGV4cHJlc3Npb25zIGluIHRoZWlyIG93biByaWdodFxuICBcdFx0aWYgKGV4cHJlc3Npb24udCA9PT0gUkVGRVJFTkNFKSB7XG4gIFx0XHRcdG11c3RhY2hlLnIgPSBleHByZXNzaW9uLm47XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpZiAoZXhwcmVzc2lvbi50ID09PSBOVU1CRVJfTElURVJBTCAmJiBhcnJheU1lbWJlclBhdHRlcm4udGVzdChleHByZXNzaW9uLnYpKSB7XG4gIFx0XHRcdFx0bXVzdGFjaGUuciA9IGV4cHJlc3Npb24udjtcbiAgXHRcdFx0fSBlbHNlIGlmIChyZWZlcmVuY2VFeHByZXNzaW9uID0gZ2V0UmVmZXJlbmNlRXhwcmVzc2lvbihleHByZXNzaW9uKSkge1xuICBcdFx0XHRcdG11c3RhY2hlLnJ4ID0gcmVmZXJlbmNlRXhwcmVzc2lvbjtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS54ID0gdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG11c3RhY2hlO1xuICBcdH1cbiAgfVxuXG4gIC8vIFRPRE8gcmVmYWN0b3IgdGhpcyEgaXQncyBiZXdpbGRlcmluZ1xuICBmdW5jdGlvbiBnZXRSZWZlcmVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgXHR2YXIgbWVtYmVycyA9IFtdLFxuICBcdCAgICByZWZpbmVtZW50O1xuXG4gIFx0d2hpbGUgKGV4cHJlc3Npb24udCA9PT0gTUVNQkVSICYmIGV4cHJlc3Npb24uci50ID09PSBSRUZJTkVNRU5UKSB7XG4gIFx0XHRyZWZpbmVtZW50ID0gZXhwcmVzc2lvbi5yO1xuXG4gIFx0XHRpZiAocmVmaW5lbWVudC54KSB7XG4gIFx0XHRcdGlmIChyZWZpbmVtZW50LngudCA9PT0gUkVGRVJFTkNFKSB7XG4gIFx0XHRcdFx0bWVtYmVycy51bnNoaWZ0KHJlZmluZW1lbnQueCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0bWVtYmVycy51bnNoaWZ0KHV0aWxzX2ZsYXR0ZW5FeHByZXNzaW9uKHJlZmluZW1lbnQueCkpO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRtZW1iZXJzLnVuc2hpZnQocmVmaW5lbWVudC5uKTtcbiAgXHRcdH1cblxuICBcdFx0ZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ueDtcbiAgXHR9XG5cbiAgXHRpZiAoZXhwcmVzc2lvbi50ICE9PSBSRUZFUkVOQ0UpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHRyOiBleHByZXNzaW9uLm4sXG4gIFx0XHRtOiBtZW1iZXJzXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBtdXN0YWNoZV9yZWFkVHJpcGxlID0gcmVhZFRyaXBsZTtcbiAgZnVuY3Rpb24gcmVhZFRyaXBsZShwYXJzZXIsIHRhZykge1xuICBcdHZhciBleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpLFxuICBcdCAgICB0cmlwbGU7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHR0cmlwbGUgPSB7IHQ6IFRSSVBMRSB9O1xuICBcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgdHJpcGxlKTsgLy8gVE9ETyBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseSAtIGl0J3MgbXlzdGVyaW91c1xuXG4gIFx0cmV0dXJuIHRyaXBsZTtcbiAgfVxuXG4gIHZhciBtdXN0YWNoZV9yZWFkVW5lc2NhcGVkID0gcmVhZFVuZXNjYXBlZDtcbiAgZnVuY3Rpb24gcmVhZFVuZXNjYXBlZChwYXJzZXIsIHRhZykge1xuICBcdHZhciBleHByZXNzaW9uLCB0cmlwbGU7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIiZcIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHR0cmlwbGUgPSB7IHQ6IFRSSVBMRSB9O1xuICBcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgdHJpcGxlKTsgLy8gVE9ETyBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseSAtIGl0J3MgbXlzdGVyaW91c1xuXG4gIFx0cmV0dXJuIHRyaXBsZTtcbiAgfVxuXG4gIHZhciBtdXN0YWNoZV9yZWFkUGFydGlhbCA9IHJlYWRQYXJ0aWFsO1xuICBmdW5jdGlvbiByZWFkUGFydGlhbChwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCwgbmFtZVN0YXJ0LCBleHByZXNzaW9uLCBjb250ZXh0LCBwYXJ0aWFsO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI+XCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0bmFtZVN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIFBhcnRpYWwgbmFtZXMgY2FuIGluY2x1ZGUgaHlwaGVucywgc28gd2UgY2FuJ3QgdXNlIHJlYWRFeHByZXNzaW9uXG4gIFx0Ly8gYmxpbmRseS4gSW5zdGVhZCwgd2UgdXNlIHRoZSBgcmVsYXhlZE5hbWVzYCBmbGFnIHRvIGluZGljYXRlIHRoYXRcbiAgXHQvLyBgZm9vLWJhcmAgc2hvdWxkIGJlIHJlYWQgYXMgYSBzaW5nbGUgbmFtZSwgcmF0aGVyIHRoYW4gJ3N1YnRyYWN0XG4gIFx0Ly8gYmFyIGZyb20gZm9vJ1xuICBcdHBhcnNlci5yZWxheGVkTmFtZXMgPSB0cnVlO1xuICBcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0cGFyc2VyLnJlbGF4ZWROYW1lcyA9IGZhbHNlO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdGNvbnRleHQgPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJ0aWFsID0geyB0OiBQQVJUSUFMIH07XG4gIFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCBwYXJ0aWFsKTsgLy8gVE9ETy4uLlxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gaWYgd2UgaGF2ZSBhbm90aGVyIGV4cHJlc3Npb24gLSBlLmcuIGB7ez5mb28gYmFyfX1gIC0gdGhlblxuICBcdC8vIHdlIHR1cm4gaXQgaW50byBge3sjd2l0aCBiYXJ9fXt7PmZvb319e3svd2l0aH19YFxuICBcdGlmIChjb250ZXh0KSB7XG4gIFx0XHRwYXJ0aWFsID0ge1xuICBcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRuOiBTRUNUSU9OX1dJVEgsXG4gIFx0XHRcdGY6IFtwYXJ0aWFsXVxuICBcdFx0fTtcblxuICBcdFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihjb250ZXh0LCBwYXJ0aWFsKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHBhcnRpYWw7XG4gIH1cblxuICB2YXIgcmVhZE11c3RhY2hlQ29tbWVudCA9IHJlYWRDb21tZW50O1xuICBmdW5jdGlvbiByZWFkQ29tbWVudChwYXJzZXIsIHRhZykge1xuICBcdHZhciBpbmRleDtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiIVwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aW5kZXggPSBwYXJzZXIucmVtYWluaW5nKCkuaW5kZXhPZih0YWcuY2xvc2UpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0cGFyc2VyLnBvcyArPSBpbmRleCArIHRhZy5jbG9zZS5sZW5ndGg7XG4gIFx0XHRyZXR1cm4geyB0OiBDT01NRU5UIH07XG4gIFx0fVxuICB9XG5cbiAgdmFyIGNvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb25PclJlZmVyZW5jZSA9IHJlYWRFeHByZXNzaW9uT3JSZWZlcmVuY2U7XG4gIGZ1bmN0aW9uIHJlYWRFeHByZXNzaW9uT3JSZWZlcmVuY2UocGFyc2VyLCBleHBlY3RlZEZvbGxvd2Vycykge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbiwgaTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuXG4gIFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRmb3IgKGkgPSAwOyBpIDwgZXhwZWN0ZWRGb2xsb3dlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdGlmIChwYXJzZXIucmVtYWluaW5nKCkuc3Vic3RyKDAsIGV4cGVjdGVkRm9sbG93ZXJzW2ldLmxlbmd0aCkgPT09IGV4cGVjdGVkRm9sbG93ZXJzW2ldKSB7XG4gIFx0XHRcdHJldHVybiBleHByZXNzaW9uO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRyZXR1cm4gcHJpbWFyeV9yZWFkUmVmZXJlbmNlKHBhcnNlcik7XG4gIH1cblxuICB2YXIgbXVzdGFjaGVfcmVhZEludGVycG9sYXRvciA9IHJlYWRJbnRlcnBvbGF0b3I7XG4gIGZ1bmN0aW9uIHJlYWRJbnRlcnBvbGF0b3IocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb24sIGludGVycG9sYXRvciwgZXJyO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gVE9ETyB3b3VsZCBiZSBnb29kIGZvciBwZXJmIGlmIHdlIGNvdWxkIGRvIGF3YXkgd2l0aCB0aGUgdHJ5LWNhdGNoXG4gIFx0dHJ5IHtcbiAgXHRcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uT3JSZWZlcmVuY2UocGFyc2VyLCBbdGFnLmNsb3NlXSk7XG4gIFx0fSBjYXRjaCAoZSkge1xuICBcdFx0ZXJyID0gZTtcbiAgXHR9XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdGlmIChwYXJzZXIuc3RyLmNoYXJBdChzdGFydCkgPT09IFwiIVwiKSB7XG4gIFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGNvbW1lbnRcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGVycikge1xuICBcdFx0XHR0aHJvdyBlcnI7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInIGFmdGVyIHJlZmVyZW5jZVwiKTtcblxuICBcdFx0aWYgKCFleHByZXNzaW9uKSB7XG4gIFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGNvbW1lbnRcbiAgXHRcdFx0aWYgKHBhcnNlci5uZXh0Q2hhcigpID09PSBcIiFcIikge1xuICBcdFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgZXhwcmVzc2lvbiBvciBsZWdhbCByZWZlcmVuY2VcIik7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aW50ZXJwb2xhdG9yID0geyB0OiBJTlRFUlBPTEFUT1IgfTtcbiAgXHR1dGlsc19yZWZpbmVFeHByZXNzaW9uKGV4cHJlc3Npb24sIGludGVycG9sYXRvcik7IC8vIFRPRE8gaGFuZGxlIHRoaXMgZGlmZmVyZW50bHkgLSBpdCdzIG15c3RlcmlvdXNcblxuICBcdHJldHVybiBpbnRlcnBvbGF0b3I7XG4gIH1cblxuICB2YXIgbXVzdGFjaGVfcmVhZFlpZWxkZXIgPSByZWFkWWllbGRlcjtcbiAgdmFyIHlpZWxkUGF0dGVybiA9IC9eeWllbGRcXHMqLztcbiAgZnVuY3Rpb24gcmVhZFlpZWxkZXIocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIG5hbWUsIHlpZWxkZXI7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4oeWllbGRQYXR0ZXJuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuICBcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOVxcLV0qLyk7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJleHBlY3RlZCBsZWdhbCBwYXJ0aWFsIG5hbWVcIik7XG4gIFx0fVxuXG4gIFx0eWllbGRlciA9IHsgdDogWUlFTERFUiB9O1xuXG4gIFx0aWYgKG5hbWUpIHtcbiAgXHRcdHlpZWxkZXIubiA9IG5hbWU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHlpZWxkZXI7XG4gIH1cblxuICB2YXIgc2VjdGlvbl9yZWFkQ2xvc2luZyA9IHJlYWRDbG9zaW5nO1xuICBmdW5jdGlvbiByZWFkQ2xvc2luZyhwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCwgcmVtYWluaW5nLCBpbmRleCwgY2xvc2luZztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5vcGVuKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIvXCIpKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG4gIFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZih0YWcuY2xvc2UpO1xuXG4gIFx0aWYgKGluZGV4ICE9PSAtMSkge1xuICBcdFx0Y2xvc2luZyA9IHtcbiAgXHRcdFx0dDogQ0xPU0lORyxcbiAgXHRcdFx0cjogcmVtYWluaW5nLnN1YnN0cigwLCBpbmRleCkuc3BsaXQoXCIgXCIpWzBdXG4gIFx0XHR9O1xuXG4gIFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXG4gIFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGNsb3Npbmc7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNlY3Rpb25fcmVhZEVsc2UgPSBzZWN0aW9uX3JlYWRFbHNlX19yZWFkRWxzZTtcbiAgdmFyIHNlY3Rpb25fcmVhZEVsc2VfX2Vsc2VQYXR0ZXJuID0gL15cXHMqZWxzZVxccyovO1xuICBmdW5jdGlvbiBzZWN0aW9uX3JlYWRFbHNlX19yZWFkRWxzZShwYXJzZXIsIHRhZykge1xuICBcdHZhciBzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcub3BlbikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoUGF0dGVybihzZWN0aW9uX3JlYWRFbHNlX19lbHNlUGF0dGVybikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHRhZy5jbG9zZSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArIHRhZy5jbG9zZSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogRUxTRVxuICBcdH07XG4gIH1cblxuICB2YXIgcmVhZEVsc2VJZiA9IHJlYWRFbHNlSWZfX3JlYWRFbHNlO1xuICB2YXIgcmVhZEVsc2VJZl9fZWxzZVBhdHRlcm4gPSAvXlxccyplbHNlaWZcXHMrLztcbiAgZnVuY3Rpb24gcmVhZEVsc2VJZl9fcmVhZEVsc2UocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQgPSBwYXJzZXIucG9zLFxuICBcdCAgICBleHByZXNzaW9uO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLm9wZW4pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4ocmVhZEVsc2VJZl9fZWxzZVBhdHRlcm4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRleHByZXNzaW9uID0gY29udmVydGVyc19yZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcodGFnLmNsb3NlKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgdGFnLmNsb3NlICsgXCInXCIpO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBFTFNFSUYsXG4gIFx0XHR4OiBleHByZXNzaW9uXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBoYW5kbGViYXJzQmxvY2tDb2RlcyA9IHtcbiAgXHRlYWNoOiBTRUNUSU9OX0VBQ0gsXG4gIFx0XCJpZlwiOiBTRUNUSU9OX0lGLFxuICBcdFwiaWYtd2l0aFwiOiBTRUNUSU9OX0lGX1dJVEgsXG4gIFx0XCJ3aXRoXCI6IFNFQ1RJT05fV0lUSCxcbiAgXHR1bmxlc3M6IFNFQ1RJT05fVU5MRVNTXG4gIH07XG5cbiAgdmFyIG11c3RhY2hlX3JlYWRTZWN0aW9uID0gcmVhZFNlY3Rpb247XG5cbiAgdmFyIGluZGV4UmVmUGF0dGVybiA9IC9eXFxzKjpcXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKikvLFxuICAgICAga2V5SW5kZXhSZWZQYXR0ZXJuID0gL15cXHMqLFxccyooW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKS8sXG4gICAgICBoYW5kbGViYXJzQmxvY2tQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBPYmplY3Qua2V5cyhoYW5kbGViYXJzQmxvY2tDb2Rlcykuam9pbihcInxcIikgKyBcIilcXFxcYlwiKTtcbiAgZnVuY3Rpb24gcmVhZFNlY3Rpb24ocGFyc2VyLCB0YWcpIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb24sIHNlY3Rpb24sIGNoaWxkLCBjaGlsZHJlbiwgaGFzRWxzZSwgYmxvY2ssIHVubGVzc0Jsb2NrLCBjb25kaXRpb25zLCBjbG9zZWQsIGksIGV4cGVjdGVkQ2xvc2U7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiXlwiKSkge1xuICBcdFx0c2VjdGlvbiA9IHsgdDogU0VDVElPTiwgZjogW10sIG46IFNFQ1RJT05fVU5MRVNTIH07XG4gIFx0fSBlbHNlIGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIjXCIpKSB7XG4gIFx0XHRzZWN0aW9uID0geyB0OiBTRUNUSU9OLCBmOiBbXSB9O1xuXG4gIFx0XHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwicGFydGlhbFwiKSkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQgLSBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzBdLmxlbmd0aDtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiUGFydGlhbCBkZWZpbml0aW9ucyBjYW4gb25seSBiZSBhdCB0aGUgdG9wIGxldmVsIG9mIHRoZSB0ZW1wbGF0ZSwgb3IgaW1tZWRpYXRlbHkgaW5zaWRlIGNvbXBvbmVudHNcIik7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChibG9jayA9IHBhcnNlci5tYXRjaFBhdHRlcm4oaGFuZGxlYmFyc0Jsb2NrUGF0dGVybikpIHtcbiAgXHRcdFx0ZXhwZWN0ZWRDbG9zZSA9IGJsb2NrO1xuICBcdFx0XHRzZWN0aW9uLm4gPSBoYW5kbGViYXJzQmxvY2tDb2Rlc1tibG9ja107XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGV4cHJlc3Npb24gPSBjb252ZXJ0ZXJzX3JlYWRFeHByZXNzaW9uKHBhcnNlcik7XG5cbiAgXHRpZiAoIWV4cHJlc3Npb24pIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGV4cHJlc3Npb25cIik7XG4gIFx0fVxuXG4gIFx0Ly8gb3B0aW9uYWwgaW5kZXggYW5kIGtleSByZWZlcmVuY2VzXG4gIFx0aWYgKGkgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGluZGV4UmVmUGF0dGVybikpIHtcbiAgXHRcdHZhciBleHRyYSA9IHVuZGVmaW5lZDtcblxuICBcdFx0aWYgKGV4dHJhID0gcGFyc2VyLm1hdGNoUGF0dGVybihrZXlJbmRleFJlZlBhdHRlcm4pKSB7XG4gIFx0XHRcdHNlY3Rpb24uaSA9IGkgKyBcIixcIiArIGV4dHJhO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0c2VjdGlvbi5pID0gaTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyh0YWcuY2xvc2UpKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyB0YWcuY2xvc2UgKyBcIidcIik7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnNlY3Rpb25EZXB0aCArPSAxO1xuICBcdGNoaWxkcmVuID0gc2VjdGlvbi5mO1xuXG4gIFx0Y29uZGl0aW9ucyA9IFtdO1xuXG4gIFx0ZG8ge1xuICBcdFx0aWYgKGNoaWxkID0gc2VjdGlvbl9yZWFkQ2xvc2luZyhwYXJzZXIsIHRhZykpIHtcbiAgXHRcdFx0aWYgKGV4cGVjdGVkQ2xvc2UgJiYgY2hpbGQuciAhPT0gZXhwZWN0ZWRDbG9zZSkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIFwiICsgdGFnLm9wZW4gKyBcIi9cIiArIGV4cGVjdGVkQ2xvc2UgKyBcIlwiICsgdGFnLmNsb3NlKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHBhcnNlci5zZWN0aW9uRGVwdGggLT0gMTtcbiAgXHRcdFx0Y2xvc2VkID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSBpZiAoY2hpbGQgPSByZWFkRWxzZUlmKHBhcnNlciwgdGFnKSkge1xuICBcdFx0XHRpZiAoc2VjdGlvbi5uID09PSBTRUNUSU9OX1VOTEVTUykge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcInt7ZWxzZX19IG5vdCBhbGxvd2VkIGluIHt7I3VubGVzc319XCIpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGhhc0Vsc2UpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJpbGxlZ2FsIHt7ZWxzZWlmLi4ufX0gYWZ0ZXIge3tlbHNlfX1cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXVubGVzc0Jsb2NrKSB7XG4gIFx0XHRcdFx0dW5sZXNzQmxvY2sgPSBjcmVhdGVVbmxlc3NCbG9jayhleHByZXNzaW9uLCBzZWN0aW9uLm4pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dW5sZXNzQmxvY2suZi5wdXNoKHtcbiAgXHRcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRcdG46IFNFQ1RJT05fSUYsXG4gIFx0XHRcdFx0eDogdXRpbHNfZmxhdHRlbkV4cHJlc3Npb24obXVzdGFjaGVfcmVhZFNlY3Rpb25fX2NvbWJpbmUoY29uZGl0aW9ucy5jb25jYXQoY2hpbGQueCkpKSxcbiAgXHRcdFx0XHRmOiBjaGlsZHJlbiA9IFtdXG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdGNvbmRpdGlvbnMucHVzaChpbnZlcnQoY2hpbGQueCkpO1xuICBcdFx0fSBlbHNlIGlmIChjaGlsZCA9IHNlY3Rpb25fcmVhZEVsc2UocGFyc2VyLCB0YWcpKSB7XG4gIFx0XHRcdGlmIChzZWN0aW9uLm4gPT09IFNFQ1RJT05fVU5MRVNTKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwie3tlbHNlfX0gbm90IGFsbG93ZWQgaW4ge3sjdW5sZXNzfX1cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoaGFzRWxzZSkge1xuICBcdFx0XHRcdHBhcnNlci5lcnJvcihcInRoZXJlIGNhbiBvbmx5IGJlIG9uZSB7e2Vsc2V9fSBibG9jaywgYXQgdGhlIGVuZCBvZiBhIHNlY3Rpb25cIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRoYXNFbHNlID0gdHJ1ZTtcblxuICBcdFx0XHQvLyB1c2UgYW4gdW5sZXNzIGJsb2NrIGlmIHRoZXJlJ3Mgbm8gZWxzZWlmXG4gIFx0XHRcdGlmICghdW5sZXNzQmxvY2spIHtcbiAgXHRcdFx0XHR1bmxlc3NCbG9jayA9IGNyZWF0ZVVubGVzc0Jsb2NrKGV4cHJlc3Npb24sIHNlY3Rpb24ubik7XG4gIFx0XHRcdFx0Y2hpbGRyZW4gPSB1bmxlc3NCbG9jay5mO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHVubGVzc0Jsb2NrLmYucHVzaCh7XG4gIFx0XHRcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRcdFx0bjogU0VDVElPTl9JRixcbiAgXHRcdFx0XHRcdHg6IHV0aWxzX2ZsYXR0ZW5FeHByZXNzaW9uKG11c3RhY2hlX3JlYWRTZWN0aW9uX19jb21iaW5lKGNvbmRpdGlvbnMpKSxcbiAgXHRcdFx0XHRcdGY6IGNoaWxkcmVuID0gW11cbiAgXHRcdFx0XHR9KTtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y2hpbGQgPSBwYXJzZXIucmVhZChSRUFERVJTKTtcblxuICBcdFx0XHRpZiAoIWNoaWxkKSB7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlICghY2xvc2VkKTtcblxuICBcdGlmICh1bmxlc3NCbG9jaykge1xuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gYHdpdGhgIHNob3VsZCBiZWNvbWUgYGlmLXdpdGhgIChUT0RPIGlzIHRoaXMgcmlnaHQ/XG4gIFx0XHQvLyBzZWVtcyB0byBtZSB0aGF0IGB3aXRoYCBvdWdodCB0byBiZWhhdmUgY29uc2lzdGVudGx5LCByZWdhcmRsZXNzXG4gIFx0XHQvLyBvZiB0aGUgcHJlc2VuY2UvYWJzZW5jZSBvZiBgZWxzZWAuIEluIG90aGVyIHdvcmRzIHNob3VsZCBhbHdheXNcbiAgXHRcdC8vIGJlIGBpZi13aXRoYFxuICBcdFx0aWYgKHNlY3Rpb24ubiA9PT0gU0VDVElPTl9XSVRIKSB7XG4gIFx0XHRcdHNlY3Rpb24ubiA9IFNFQ1RJT05fSUZfV0lUSDtcbiAgXHRcdH1cblxuICBcdFx0c2VjdGlvbi5sID0gdW5sZXNzQmxvY2s7XG4gIFx0fVxuXG4gIFx0dXRpbHNfcmVmaW5lRXhwcmVzc2lvbihleHByZXNzaW9uLCBzZWN0aW9uKTtcblxuICBcdC8vIFRPRE8gaWYgYSBzZWN0aW9uIGlzIGVtcHR5IGl0IHNob3VsZCBiZSBkaXNjYXJkZWQuIERvbid0IGRvXG4gIFx0Ly8gdGhhdCBoZXJlIHRob3VnaCAtIHdlIG5lZWQgdG8gY2xlYW4gZXZlcnl0aGluZyB1cCBmaXJzdCwgYXNcbiAgXHQvLyBpdCBtYXkgY29udGFpbiByZW1vdmVhYmxlIHdoaXRlc3BhY2UuIEFzIGEgdGVtcG9yYXJ5IG1lYXN1cmUsXG4gIFx0Ly8gdG8gcGFzcyB0aGUgZXhpc3RpbmcgdGVzdHMsIHJlbW92ZSBlbXB0eSBgZmAgYXJyYXlzXG4gIFx0aWYgKCFzZWN0aW9uLmYubGVuZ3RoKSB7XG4gIFx0XHRkZWxldGUgc2VjdGlvbi5mO1xuICBcdH1cblxuICBcdHJldHVybiBzZWN0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5sZXNzQmxvY2soZXhwcmVzc2lvbiwgc2VjdGlvblR5cGUpIHtcbiAgXHR2YXIgdW5sZXNzQmxvY2s7XG5cbiAgXHRpZiAoc2VjdGlvblR5cGUgPT09IFNFQ1RJT05fV0lUSCkge1xuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gYSBge3sjd2l0aCBmb299fWAgc2VjdGlvbiB3aWxsIHJlbmRlciBpZiBgZm9vYCBpc1xuICBcdFx0Ly8gdHJ1dGh5LCBzbyB0aGUgYHt7ZWxzZX19YCBzZWN0aW9uIG5lZWRzIHRvIHJlbmRlciBpZiBgZm9vYCBpcyBmYWxzeSxcbiAgXHRcdC8vIHJhdGhlciB0aGFuIGFkaGVyaW5nIHRvIHRoZSBub3JtYWwgYHt7I3VubGVzcyBmb299fWAgbG9naWMgKHdoaWNoXG4gIFx0XHQvLyB0cmVhdHMgZW1wdHkgYXJyYXlzL29iamVjdHMgYXMgZmFsc3kpXG4gIFx0XHR1bmxlc3NCbG9jayA9IHtcbiAgXHRcdFx0dDogU0VDVElPTixcbiAgXHRcdFx0bjogU0VDVElPTl9JRixcbiAgXHRcdFx0ZjogW11cbiAgXHRcdH07XG5cbiAgXHRcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oaW52ZXJ0KGV4cHJlc3Npb24pLCB1bmxlc3NCbG9jayk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHVubGVzc0Jsb2NrID0ge1xuICBcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRuOiBTRUNUSU9OX1VOTEVTUyxcbiAgXHRcdFx0ZjogW11cbiAgXHRcdH07XG5cbiAgXHRcdHV0aWxzX3JlZmluZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgdW5sZXNzQmxvY2spO1xuICBcdH1cblxuICBcdHJldHVybiB1bmxlc3NCbG9jaztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmVydChleHByZXNzaW9uKSB7XG4gIFx0aWYgKGV4cHJlc3Npb24udCA9PT0gUFJFRklYX09QRVJBVE9SICYmIGV4cHJlc3Npb24ucyA9PT0gXCIhXCIpIHtcbiAgXHRcdHJldHVybiBleHByZXNzaW9uLm87XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IFBSRUZJWF9PUEVSQVRPUixcbiAgXHRcdHM6IFwiIVwiLFxuICBcdFx0bzogcGFyZW5zSWZOZWNlc3NhcnkoZXhwcmVzc2lvbilcbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gbXVzdGFjaGVfcmVhZFNlY3Rpb25fX2NvbWJpbmUoZXhwcmVzc2lvbnMpIHtcbiAgXHRpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID09PSAxKSB7XG4gIFx0XHRyZXR1cm4gZXhwcmVzc2lvbnNbMF07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IElORklYX09QRVJBVE9SLFxuICBcdFx0czogXCImJlwiLFxuICBcdFx0bzogW3BhcmVuc0lmTmVjZXNzYXJ5KGV4cHJlc3Npb25zWzBdKSwgcGFyZW5zSWZOZWNlc3NhcnkobXVzdGFjaGVfcmVhZFNlY3Rpb25fX2NvbWJpbmUoZXhwcmVzc2lvbnMuc2xpY2UoMSkpKV1cbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyZW5zSWZOZWNlc3NhcnkoZXhwcmVzc2lvbikge1xuICBcdC8vIFRPRE8gb25seSB3cmFwIGlmIG5lY2Vzc2FyeVxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBCUkFDS0VURUQsXG4gIFx0XHR4OiBleHByZXNzaW9uXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRIdG1sQ29tbWVudCA9IHJlYWRIdG1sQ29tbWVudDtcbiAgdmFyIE9QRU5fQ09NTUVOVCA9IFwiPCEtLVwiLFxuICAgICAgQ0xPU0VfQ09NTUVOVCA9IFwiLS0+XCI7XG4gIGZ1bmN0aW9uIHJlYWRIdG1sQ29tbWVudChwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIGNvbnRlbnQsIHJlbWFpbmluZywgZW5kSW5kZXgsIGNvbW1lbnQ7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhPUEVOX0NPTU1FTlQpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG4gIFx0ZW5kSW5kZXggPSByZW1haW5pbmcuaW5kZXhPZihDTE9TRV9DT01NRU5UKTtcblxuICBcdGlmIChlbmRJbmRleCA9PT0gLTEpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIklsbGVnYWwgSFRNTCAtIGV4cGVjdGVkIGNsb3NpbmcgY29tbWVudCBzZXF1ZW5jZSAoJy0tPicpXCIpO1xuICBcdH1cblxuICBcdGNvbnRlbnQgPSByZW1haW5pbmcuc3Vic3RyKDAsIGVuZEluZGV4KTtcbiAgXHRwYXJzZXIucG9zICs9IGVuZEluZGV4ICsgMztcblxuICBcdGNvbW1lbnQgPSB7XG4gIFx0XHR0OiBDT01NRU5ULFxuICBcdFx0YzogY29udGVudFxuICBcdH07XG5cbiAgXHRpZiAocGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zKSB7XG4gIFx0XHRjb21tZW50LnAgPSBwYXJzZXIuZ2V0TGluZVBvcyhzdGFydCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGNvbW1lbnQ7XG4gIH1cblxuICB2YXIgYm9vbGVhbkF0dHJpYnV0ZXMsIHZvaWRFbGVtZW50TmFtZXMsIGh0bWxFbnRpdGllcywgY29udHJvbENoYXJhY3RlcnMsIGVudGl0eVBhdHRlcm4sIGxlc3NUaGFuLCBncmVhdGVyVGhhbiwgYW1wO1xuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5nYXgvaHRtbC1taW5pZmllci9pc3N1ZXMvNjMjaXNzdWVjb21tZW50LTM3NzYzMzE2XG4gIGJvb2xlYW5BdHRyaWJ1dGVzID0gL14oYWxsb3dGdWxsc2NyZWVufGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjaGVja2VkfGNvbXBhY3R8Y29udHJvbHN8ZGVjbGFyZXxkZWZhdWx0fGRlZmF1bHRDaGVja2VkfGRlZmF1bHRNdXRlZHxkZWZhdWx0U2VsZWN0ZWR8ZGVmZXJ8ZGlzYWJsZWR8ZW5hYmxlZHxmb3JtTm9WYWxpZGF0ZXxoaWRkZW58aW5kZXRlcm1pbmF0ZXxpbmVydHxpc01hcHxpdGVtU2NvcGV8bG9vcHxtdWx0aXBsZXxtdXRlZHxub0hyZWZ8bm9SZXNpemV8bm9TaGFkZXxub1ZhbGlkYXRlfG5vV3JhcHxvcGVufHBhdXNlT25FeGl0fHJlYWRPbmx5fHJlcXVpcmVkfHJldmVyc2VkfHNjb3BlZHxzZWFtbGVzc3xzZWxlY3RlZHxzb3J0YWJsZXx0cmFuc2xhdGV8dHJ1ZVNwZWVkfHR5cGVNdXN0TWF0Y2h8dmlzaWJsZSkkL2k7XG4gIHZvaWRFbGVtZW50TmFtZXMgPSAvXig/OmFyZWF8YmFzZXxicnxjb2x8Y29tbWFuZHxkb2N0eXBlfGVtYmVkfGhyfGltZ3xpbnB1dHxrZXlnZW58bGlua3xtZXRhfHBhcmFtfHNvdXJjZXx0cmFja3x3YnIpJC9pO1xuXG4gIGh0bWxFbnRpdGllcyA9IHsgcXVvdDogMzQsIGFtcDogMzgsIGFwb3M6IDM5LCBsdDogNjAsIGd0OiA2MiwgbmJzcDogMTYwLCBpZXhjbDogMTYxLCBjZW50OiAxNjIsIHBvdW5kOiAxNjMsIGN1cnJlbjogMTY0LCB5ZW46IDE2NSwgYnJ2YmFyOiAxNjYsIHNlY3Q6IDE2NywgdW1sOiAxNjgsIGNvcHk6IDE2OSwgb3JkZjogMTcwLCBsYXF1bzogMTcxLCBub3Q6IDE3Miwgc2h5OiAxNzMsIHJlZzogMTc0LCBtYWNyOiAxNzUsIGRlZzogMTc2LCBwbHVzbW46IDE3Nywgc3VwMjogMTc4LCBzdXAzOiAxNzksIGFjdXRlOiAxODAsIG1pY3JvOiAxODEsIHBhcmE6IDE4MiwgbWlkZG90OiAxODMsIGNlZGlsOiAxODQsIHN1cDE6IDE4NSwgb3JkbTogMTg2LCByYXF1bzogMTg3LCBmcmFjMTQ6IDE4OCwgZnJhYzEyOiAxODksIGZyYWMzNDogMTkwLCBpcXVlc3Q6IDE5MSwgQWdyYXZlOiAxOTIsIEFhY3V0ZTogMTkzLCBBY2lyYzogMTk0LCBBdGlsZGU6IDE5NSwgQXVtbDogMTk2LCBBcmluZzogMTk3LCBBRWxpZzogMTk4LCBDY2VkaWw6IDE5OSwgRWdyYXZlOiAyMDAsIEVhY3V0ZTogMjAxLCBFY2lyYzogMjAyLCBFdW1sOiAyMDMsIElncmF2ZTogMjA0LCBJYWN1dGU6IDIwNSwgSWNpcmM6IDIwNiwgSXVtbDogMjA3LCBFVEg6IDIwOCwgTnRpbGRlOiAyMDksIE9ncmF2ZTogMjEwLCBPYWN1dGU6IDIxMSwgT2NpcmM6IDIxMiwgT3RpbGRlOiAyMTMsIE91bWw6IDIxNCwgdGltZXM6IDIxNSwgT3NsYXNoOiAyMTYsIFVncmF2ZTogMjE3LCBVYWN1dGU6IDIxOCwgVWNpcmM6IDIxOSwgVXVtbDogMjIwLCBZYWN1dGU6IDIyMSwgVEhPUk46IDIyMiwgc3psaWc6IDIyMywgYWdyYXZlOiAyMjQsIGFhY3V0ZTogMjI1LCBhY2lyYzogMjI2LCBhdGlsZGU6IDIyNywgYXVtbDogMjI4LCBhcmluZzogMjI5LCBhZWxpZzogMjMwLCBjY2VkaWw6IDIzMSwgZWdyYXZlOiAyMzIsIGVhY3V0ZTogMjMzLCBlY2lyYzogMjM0LCBldW1sOiAyMzUsIGlncmF2ZTogMjM2LCBpYWN1dGU6IDIzNywgaWNpcmM6IDIzOCwgaXVtbDogMjM5LCBldGg6IDI0MCwgbnRpbGRlOiAyNDEsIG9ncmF2ZTogMjQyLCBvYWN1dGU6IDI0Mywgb2NpcmM6IDI0NCwgb3RpbGRlOiAyNDUsIG91bWw6IDI0NiwgZGl2aWRlOiAyNDcsIG9zbGFzaDogMjQ4LCB1Z3JhdmU6IDI0OSwgdWFjdXRlOiAyNTAsIHVjaXJjOiAyNTEsIHV1bWw6IDI1MiwgeWFjdXRlOiAyNTMsIHRob3JuOiAyNTQsIHl1bWw6IDI1NSwgT0VsaWc6IDMzOCwgb2VsaWc6IDMzOSwgU2Nhcm9uOiAzNTIsIHNjYXJvbjogMzUzLCBZdW1sOiAzNzYsIGZub2Y6IDQwMiwgY2lyYzogNzEwLCB0aWxkZTogNzMyLCBBbHBoYTogOTEzLCBCZXRhOiA5MTQsIEdhbW1hOiA5MTUsIERlbHRhOiA5MTYsIEVwc2lsb246IDkxNywgWmV0YTogOTE4LCBFdGE6IDkxOSwgVGhldGE6IDkyMCwgSW90YTogOTIxLCBLYXBwYTogOTIyLCBMYW1iZGE6IDkyMywgTXU6IDkyNCwgTnU6IDkyNSwgWGk6IDkyNiwgT21pY3JvbjogOTI3LCBQaTogOTI4LCBSaG86IDkyOSwgU2lnbWE6IDkzMSwgVGF1OiA5MzIsIFVwc2lsb246IDkzMywgUGhpOiA5MzQsIENoaTogOTM1LCBQc2k6IDkzNiwgT21lZ2E6IDkzNywgYWxwaGE6IDk0NSwgYmV0YTogOTQ2LCBnYW1tYTogOTQ3LCBkZWx0YTogOTQ4LCBlcHNpbG9uOiA5NDksIHpldGE6IDk1MCwgZXRhOiA5NTEsIHRoZXRhOiA5NTIsIGlvdGE6IDk1Mywga2FwcGE6IDk1NCwgbGFtYmRhOiA5NTUsIG11OiA5NTYsIG51OiA5NTcsIHhpOiA5NTgsIG9taWNyb246IDk1OSwgcGk6IDk2MCwgcmhvOiA5NjEsIHNpZ21hZjogOTYyLCBzaWdtYTogOTYzLCB0YXU6IDk2NCwgdXBzaWxvbjogOTY1LCBwaGk6IDk2NiwgY2hpOiA5NjcsIHBzaTogOTY4LCBvbWVnYTogOTY5LCB0aGV0YXN5bTogOTc3LCB1cHNpaDogOTc4LCBwaXY6IDk4MiwgZW5zcDogODE5NCwgZW1zcDogODE5NSwgdGhpbnNwOiA4MjAxLCB6d25qOiA4MjA0LCB6d2o6IDgyMDUsIGxybTogODIwNiwgcmxtOiA4MjA3LCBuZGFzaDogODIxMSwgbWRhc2g6IDgyMTIsIGxzcXVvOiA4MjE2LCByc3F1bzogODIxNywgc2JxdW86IDgyMTgsIGxkcXVvOiA4MjIwLCByZHF1bzogODIyMSwgYmRxdW86IDgyMjIsIGRhZ2dlcjogODIyNCwgRGFnZ2VyOiA4MjI1LCBidWxsOiA4MjI2LCBoZWxsaXA6IDgyMzAsIHBlcm1pbDogODI0MCwgcHJpbWU6IDgyNDIsIFByaW1lOiA4MjQzLCBsc2FxdW86IDgyNDksIHJzYXF1bzogODI1MCwgb2xpbmU6IDgyNTQsIGZyYXNsOiA4MjYwLCBldXJvOiA4MzY0LCBpbWFnZTogODQ2NSwgd2VpZXJwOiA4NDcyLCByZWFsOiA4NDc2LCB0cmFkZTogODQ4MiwgYWxlZnN5bTogODUwMSwgbGFycjogODU5MiwgdWFycjogODU5MywgcmFycjogODU5NCwgZGFycjogODU5NSwgaGFycjogODU5NiwgY3JhcnI6IDg2MjksIGxBcnI6IDg2NTYsIHVBcnI6IDg2NTcsIHJBcnI6IDg2NTgsIGRBcnI6IDg2NTksIGhBcnI6IDg2NjAsIGZvcmFsbDogODcwNCwgcGFydDogODcwNiwgZXhpc3Q6IDg3MDcsIGVtcHR5OiA4NzA5LCBuYWJsYTogODcxMSwgaXNpbjogODcxMiwgbm90aW46IDg3MTMsIG5pOiA4NzE1LCBwcm9kOiA4NzE5LCBzdW06IDg3MjEsIG1pbnVzOiA4NzIyLCBsb3dhc3Q6IDg3MjcsIHJhZGljOiA4NzMwLCBwcm9wOiA4NzMzLCBpbmZpbjogODczNCwgYW5nOiA4NzM2LCBhbmQ6IDg3NDMsIG9yOiA4NzQ0LCBjYXA6IDg3NDUsIGN1cDogODc0NiwgaW50OiA4NzQ3LCB0aGVyZTQ6IDg3NTYsIHNpbTogODc2NCwgY29uZzogODc3MywgYXN5bXA6IDg3NzYsIG5lOiA4ODAwLCBlcXVpdjogODgwMSwgbGU6IDg4MDQsIGdlOiA4ODA1LCBzdWI6IDg4MzQsIHN1cDogODgzNSwgbnN1YjogODgzNiwgc3ViZTogODgzOCwgc3VwZTogODgzOSwgb3BsdXM6IDg4NTMsIG90aW1lczogODg1NSwgcGVycDogODg2OSwgc2RvdDogODkwMSwgbGNlaWw6IDg5NjgsIHJjZWlsOiA4OTY5LCBsZmxvb3I6IDg5NzAsIHJmbG9vcjogODk3MSwgbGFuZzogOTAwMSwgcmFuZzogOTAwMiwgbG96OiA5Njc0LCBzcGFkZXM6IDk4MjQsIGNsdWJzOiA5ODI3LCBoZWFydHM6IDk4MjksIGRpYW1zOiA5ODMwIH07XG4gIGNvbnRyb2xDaGFyYWN0ZXJzID0gWzgzNjQsIDEyOSwgODIxOCwgNDAyLCA4MjIyLCA4MjMwLCA4MjI0LCA4MjI1LCA3MTAsIDgyNDAsIDM1MiwgODI0OSwgMzM4LCAxNDEsIDM4MSwgMTQzLCAxNDQsIDgyMTYsIDgyMTcsIDgyMjAsIDgyMjEsIDgyMjYsIDgyMTEsIDgyMTIsIDczMiwgODQ4MiwgMzUzLCA4MjUwLCAzMzksIDE1NywgMzgyLCAzNzZdO1xuICBlbnRpdHlQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIiYoIz8oPzp4W1xcXFx3XFxcXGRdK3xcXFxcZCt8XCIgKyBPYmplY3Qua2V5cyhodG1sRW50aXRpZXMpLmpvaW4oXCJ8XCIpICsgXCIpKTs/XCIsIFwiZ1wiKTtcblxuICBmdW5jdGlvbiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKGh0bWwpIHtcbiAgXHRyZXR1cm4gaHRtbC5yZXBsYWNlKGVudGl0eVBhdHRlcm4sIGZ1bmN0aW9uIChtYXRjaCwgZW50aXR5KSB7XG4gIFx0XHR2YXIgY29kZTtcblxuICBcdFx0Ly8gSGFuZGxlIG5hbWVkIGVudGl0aWVzXG4gIFx0XHRpZiAoZW50aXR5WzBdICE9PSBcIiNcIikge1xuICBcdFx0XHRjb2RlID0gaHRtbEVudGl0aWVzW2VudGl0eV07XG4gIFx0XHR9IGVsc2UgaWYgKGVudGl0eVsxXSA9PT0gXCJ4XCIpIHtcbiAgXHRcdFx0Y29kZSA9IHBhcnNlSW50KGVudGl0eS5zdWJzdHJpbmcoMiksIDE2KTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNvZGUgPSBwYXJzZUludChlbnRpdHkuc3Vic3RyaW5nKDEpLCAxMCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghY29kZSkge1xuICBcdFx0XHRyZXR1cm4gbWF0Y2g7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbGlkYXRlQ29kZShjb2RlKSk7XG4gIFx0fSk7XG4gIH1cblxuICAvLyBzb21lIGNvZGUgcG9pbnRzIGFyZSB2ZXJib3Rlbi4gSWYgd2Ugd2VyZSBpbnNlcnRpbmcgSFRNTCwgdGhlIGJyb3dzZXIgd291bGQgcmVwbGFjZSB0aGUgaWxsZWdhbFxuICAvLyBjb2RlIHBvaW50cyB3aXRoIGFsdGVybmF0aXZlcyBpbiBzb21lIGNhc2VzIC0gc2luY2Ugd2UncmUgYnlwYXNzaW5nIHRoYXQgbWVjaGFuaXNtLCB3ZSBuZWVkXG4gIC8vIHRvIHJlcGxhY2UgdGhlbSBvdXJzZWx2ZXNcbiAgLy9cbiAgLy8gU291cmNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NoYXJhY3Rlcl9lbmNvZGluZ3NfaW5fSFRNTCNJbGxlZ2FsX2NoYXJhY3RlcnNcbiAgZnVuY3Rpb24gdmFsaWRhdGVDb2RlKGNvZGUpIHtcbiAgXHRpZiAoIWNvZGUpIHtcbiAgXHRcdHJldHVybiA2NTUzMztcbiAgXHR9XG5cbiAgXHQvLyBsaW5lIGZlZWQgYmVjb21lcyBnZW5lcmljIHdoaXRlc3BhY2VcbiAgXHRpZiAoY29kZSA9PT0gMTApIHtcbiAgXHRcdHJldHVybiAzMjtcbiAgXHR9XG5cbiAgXHQvLyBBU0NJSSByYW5nZS4gKFdoeSBzb21lb25lIHdvdWxkIHVzZSBIVE1MIGVudGl0aWVzIGZvciBBU0NJSSBjaGFyYWN0ZXJzIEkgZG9uJ3Qga25vdywgYnV0Li4uKVxuICBcdGlmIChjb2RlIDwgMTI4KSB7XG4gIFx0XHRyZXR1cm4gY29kZTtcbiAgXHR9XG5cbiAgXHQvLyBjb2RlIHBvaW50cyAxMjgtMTU5IGFyZSBkZWFsdCB3aXRoIGxlbmllbnRseSBieSBicm93c2VycywgYnV0IHRoZXkncmUgaW5jb3JyZWN0LiBXZSBuZWVkXG4gIFx0Ly8gdG8gY29ycmVjdCB0aGUgbWlzdGFrZSBvciB3ZSdsbCBlbmQgdXAgd2l0aCBtaXNzaW5nIOKCrCBzaWducyBhbmQgc28gb25cbiAgXHRpZiAoY29kZSA8PSAxNTkpIHtcbiAgXHRcdHJldHVybiBjb250cm9sQ2hhcmFjdGVyc1tjb2RlIC0gMTI4XTtcbiAgXHR9XG5cbiAgXHQvLyBiYXNpYyBtdWx0aWxpbmd1YWwgcGxhbmVcbiAgXHRpZiAoY29kZSA8IDU1Mjk2KSB7XG4gIFx0XHRyZXR1cm4gY29kZTtcbiAgXHR9XG5cbiAgXHQvLyBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICBcdGlmIChjb2RlIDw9IDU3MzQzKSB7XG4gIFx0XHRyZXR1cm4gNjU1MzM7XG4gIFx0fVxuXG4gIFx0Ly8gcmVzdCBvZiB0aGUgYmFzaWMgbXVsdGlsaW5ndWFsIHBsYW5lXG4gIFx0aWYgKGNvZGUgPD0gNjU1MzUpIHtcbiAgXHRcdHJldHVybiBjb2RlO1xuICBcdH1cblxuICBcdHJldHVybiA2NTUzMztcbiAgfVxuXG4gIGxlc3NUaGFuID0gLzwvZztcbiAgZ3JlYXRlclRoYW4gPSAvPi9nO1xuICBhbXAgPSAvJi9nO1xuXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyKSB7XG4gIFx0cmV0dXJuIHN0ci5yZXBsYWNlKGFtcCwgXCImYW1wO1wiKS5yZXBsYWNlKGxlc3NUaGFuLCBcIiZsdDtcIikucmVwbGFjZShncmVhdGVyVGhhbiwgXCImZ3Q7XCIpO1xuICB9XG5cbiAgdmFyIGxlYWRpbmdMaW5lYnJlYWsgPSAvXlxccypcXHI/XFxuLyxcbiAgICAgIHRyYWlsaW5nTGluZWJyZWFrID0gL1xccj9cXG5cXHMqJC87XG5cbiAgdmFyIHN0cmlwU3RhbmRhbG9uZXMgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgXHR2YXIgaSwgY3VycmVudCwgYmFja09uZSwgYmFja1R3bywgbGFzdFNlY3Rpb25JdGVtO1xuXG4gIFx0Zm9yIChpID0gMTsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRjdXJyZW50ID0gaXRlbXNbaV07XG4gIFx0XHRiYWNrT25lID0gaXRlbXNbaSAtIDFdO1xuICBcdFx0YmFja1R3byA9IGl0ZW1zW2kgLSAyXTtcblxuICBcdFx0Ly8gaWYgd2UncmUgYXQgdGhlIGVuZCBvZiBhIFt0ZXh0XVtjb21tZW50XVt0ZXh0XSBzZXF1ZW5jZS4uLlxuICBcdFx0aWYgKGlzU3RyaW5nKGN1cnJlbnQpICYmIGlzQ29tbWVudChiYWNrT25lKSAmJiBpc1N0cmluZyhiYWNrVHdvKSkge1xuXG4gIFx0XHRcdC8vIC4uLiBhbmQgdGhlIGNvbW1lbnQgaXMgYSBzdGFuZGFsb25lIChpLmUuIGxpbmUgYnJlYWtzIGVpdGhlciBzaWRlKS4uLlxuICBcdFx0XHRpZiAodHJhaWxpbmdMaW5lYnJlYWsudGVzdChiYWNrVHdvKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoY3VycmVudCkpIHtcblxuICBcdFx0XHRcdC8vIC4uLiB0aGVuIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIGFmdGVyIHRoZSBmaXJzdCBsaW5lIGJyZWFrXG4gIFx0XHRcdFx0aXRlbXNbaSAtIDJdID0gYmFja1R3by5yZXBsYWNlKHRyYWlsaW5nTGluZWJyZWFrLCBcIlxcblwiKTtcblxuICBcdFx0XHRcdC8vIGFuZCB0aGUgbGVhZGluZyBsaW5lIGJyZWFrIG9mIHRoZSBzZWNvbmQgdGV4dCB0b2tlblxuICBcdFx0XHRcdGl0ZW1zW2ldID0gY3VycmVudC5yZXBsYWNlKGxlYWRpbmdMaW5lYnJlYWssIFwiXCIpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlmIHRoZSBjdXJyZW50IGl0ZW0gaXMgYSBzZWN0aW9uLCBhbmQgaXQgaXMgcHJlY2VkZWQgYnkgYSBsaW5lYnJlYWssIGFuZFxuICBcdFx0Ly8gaXRzIGZpcnN0IGl0ZW0gaXMgYSBsaW5lYnJlYWsuLi5cbiAgXHRcdGlmIChpc1NlY3Rpb24oY3VycmVudCkgJiYgaXNTdHJpbmcoYmFja09uZSkpIHtcbiAgXHRcdFx0aWYgKHRyYWlsaW5nTGluZWJyZWFrLnRlc3QoYmFja09uZSkgJiYgaXNTdHJpbmcoY3VycmVudC5mWzBdKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoY3VycmVudC5mWzBdKSkge1xuICBcdFx0XHRcdGl0ZW1zW2kgLSAxXSA9IGJhY2tPbmUucmVwbGFjZSh0cmFpbGluZ0xpbmVicmVhaywgXCJcXG5cIik7XG4gIFx0XHRcdFx0Y3VycmVudC5mWzBdID0gY3VycmVudC5mWzBdLnJlcGxhY2UobGVhZGluZ0xpbmVicmVhaywgXCJcIik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gaWYgdGhlIGxhc3QgaXRlbSB3YXMgYSBzZWN0aW9uLCBhbmQgaXQgaXMgZm9sbG93ZWQgYnkgYSBsaW5lYnJlYWssIGFuZFxuICBcdFx0Ly8gaXRzIGxhc3QgaXRlbSBpcyBhIGxpbmVicmVhay4uLlxuICBcdFx0aWYgKGlzU3RyaW5nKGN1cnJlbnQpICYmIGlzU2VjdGlvbihiYWNrT25lKSkge1xuICBcdFx0XHRsYXN0U2VjdGlvbkl0ZW0gPSBsYXN0SXRlbShiYWNrT25lLmYpO1xuXG4gIFx0XHRcdGlmIChpc1N0cmluZyhsYXN0U2VjdGlvbkl0ZW0pICYmIHRyYWlsaW5nTGluZWJyZWFrLnRlc3QobGFzdFNlY3Rpb25JdGVtKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoY3VycmVudCkpIHtcbiAgXHRcdFx0XHRiYWNrT25lLmZbYmFja09uZS5mLmxlbmd0aCAtIDFdID0gbGFzdFNlY3Rpb25JdGVtLnJlcGxhY2UodHJhaWxpbmdMaW5lYnJlYWssIFwiXFxuXCIpO1xuICBcdFx0XHRcdGl0ZW1zW2ldID0gY3VycmVudC5yZXBsYWNlKGxlYWRpbmdMaW5lYnJlYWssIFwiXCIpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGlzU3RyaW5nKGl0ZW0pIHtcbiAgXHRyZXR1cm4gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc0NvbW1lbnQoaXRlbSkge1xuICBcdHJldHVybiBpdGVtLnQgPT09IENPTU1FTlQgfHwgaXRlbS50ID09PSBERUxJTUNIQU5HRTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2VjdGlvbihpdGVtKSB7XG4gIFx0cmV0dXJuIChpdGVtLnQgPT09IFNFQ1RJT04gfHwgaXRlbS50ID09PSBJTlZFUlRFRCkgJiYgaXRlbS5mO1xuICB9XG5cbiAgdmFyIHRyaW1XaGl0ZXNwYWNlX19sZWFkaW5nV2hpdGVzcGFjZSA9IC9eWyBcXHRcXGZcXHJcXG5dKy8sXG4gICAgICB0cmltV2hpdGVzcGFjZV9fdHJhaWxpbmdXaGl0ZXNwYWNlID0gL1sgXFx0XFxmXFxyXFxuXSskLztcblxuICB2YXIgdHJpbVdoaXRlc3BhY2UgPSBmdW5jdGlvbiAoaXRlbXMsIGxlYWRpbmcsIHRyYWlsaW5nKSB7XG4gIFx0dmFyIGl0ZW07XG5cbiAgXHRpZiAobGVhZGluZykge1xuICBcdFx0aXRlbSA9IGl0ZW1zWzBdO1xuICBcdFx0aWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdGl0ZW0gPSBpdGVtLnJlcGxhY2UodHJpbVdoaXRlc3BhY2VfX2xlYWRpbmdXaGl0ZXNwYWNlLCBcIlwiKTtcblxuICBcdFx0XHRpZiAoIWl0ZW0pIHtcbiAgXHRcdFx0XHRpdGVtcy5zaGlmdCgpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGl0ZW1zWzBdID0gaXRlbTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICh0cmFpbGluZykge1xuICBcdFx0aXRlbSA9IGxhc3RJdGVtKGl0ZW1zKTtcbiAgXHRcdGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRpdGVtID0gaXRlbS5yZXBsYWNlKHRyaW1XaGl0ZXNwYWNlX190cmFpbGluZ1doaXRlc3BhY2UsIFwiXCIpO1xuXG4gIFx0XHRcdGlmICghaXRlbSkge1xuICBcdFx0XHRcdGl0ZW1zLnBvcCgpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdID0gaXRlbTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgdXRpbHNfY2xlYW51cCA9IGNsZWFudXA7XG4gIHZhciBjb250aWd1b3VzV2hpdGVzcGFjZSA9IC9bIFxcdFxcZlxcclxcbl0rL2c7XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50cyA9IC9eKD86cHJlfHNjcmlwdHxzdHlsZXx0ZXh0YXJlYSkkL2k7XG4gIHZhciB1dGlsc19jbGVhbnVwX19sZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKy87XG4gIHZhciB1dGlsc19jbGVhbnVwX190cmFpbGluZ1doaXRlc3BhY2UgPSAvXFxzKyQvO1xuICBmdW5jdGlvbiBjbGVhbnVwKGl0ZW1zLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlLCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2UpIHtcbiAgXHR2YXIgaSwgaXRlbSwgcHJldmlvdXNJdGVtLCBuZXh0SXRlbSwgcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCBrZXk7XG5cbiAgXHQvLyBGaXJzdCBwYXNzIC0gcmVtb3ZlIHN0YW5kYWxvbmVzIGFuZCBjb21tZW50cyBldGNcbiAgXHRzdHJpcFN0YW5kYWxvbmVzKGl0ZW1zKTtcblxuICBcdGkgPSBpdGVtcy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aXRlbSA9IGl0ZW1zW2ldO1xuXG4gIFx0XHQvLyBSZW1vdmUgZGVsaW1pdGVyIGNoYW5nZXMsIHVuc2FmZSBlbGVtZW50cyBldGNcbiAgXHRcdGlmIChpdGVtLmV4Y2x1ZGUpIHtcbiAgXHRcdFx0aXRlbXMuc3BsaWNlKGksIDEpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBSZW1vdmUgY29tbWVudHMsIHVubGVzcyB3ZSB3YW50IHRvIGtlZXAgdGhlbVxuICBcdFx0ZWxzZSBpZiAoc3RyaXBDb21tZW50cyAmJiBpdGVtLnQgPT09IENPTU1FTlQpIHtcbiAgXHRcdFx0aXRlbXMuc3BsaWNlKGksIDEpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIElmIG5lY2Vzc2FyeSwgcmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgXHR0cmltV2hpdGVzcGFjZShpdGVtcywgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2UsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZSk7XG5cbiAgXHRpID0gaXRlbXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGl0ZW0gPSBpdGVtc1tpXTtcblxuICBcdFx0Ly8gUmVjdXJzZVxuICBcdFx0aWYgKGl0ZW0uZikge1xuICBcdFx0XHRwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCA9IHByZXNlcnZlV2hpdGVzcGFjZSB8fCBpdGVtLnQgPT09IEVMRU1FTlQgJiYgcHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudHMudGVzdChpdGVtLmUpO1xuXG4gIFx0XHRcdGlmICghcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpIHtcbiAgXHRcdFx0XHRwcmV2aW91c0l0ZW0gPSBpdGVtc1tpIC0gMV07XG4gIFx0XHRcdFx0bmV4dEl0ZW0gPSBpdGVtc1tpICsgMV07XG5cbiAgXHRcdFx0XHQvLyBpZiB0aGUgcHJldmlvdXMgaXRlbSB3YXMgYSB0ZXh0IGl0ZW0gd2l0aCB0cmFpbGluZyB3aGl0ZXNwYWNlLFxuICBcdFx0XHRcdC8vIHJlbW92ZSBsZWFkaW5nIHdoaXRlc3BhY2UgaW5zaWRlIHRoZSBmcmFnbWVudFxuICBcdFx0XHRcdGlmICghcHJldmlvdXNJdGVtIHx8IHR5cGVvZiBwcmV2aW91c0l0ZW0gPT09IFwic3RyaW5nXCIgJiYgdXRpbHNfY2xlYW51cF9fdHJhaWxpbmdXaGl0ZXNwYWNlLnRlc3QocHJldmlvdXNJdGVtKSkge1xuICBcdFx0XHRcdFx0cmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCA9IHRydWU7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gYW5kIHZpY2UgdmVyc2FcbiAgXHRcdFx0XHRpZiAoIW5leHRJdGVtIHx8IHR5cGVvZiBuZXh0SXRlbSA9PT0gXCJzdHJpbmdcIiAmJiB1dGlsc19jbGVhbnVwX19sZWFkaW5nV2hpdGVzcGFjZS50ZXN0KG5leHRJdGVtKSkge1xuICBcdFx0XHRcdFx0cmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSB0cnVlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNsZWFudXAoaXRlbS5mLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBTcGxpdCBpZi1lbHNlIGJsb2NrcyBpbnRvIHR3byAoYW4gaWYsIGFuZCBhbiB1bmxlc3MpXG4gIFx0XHRpZiAoaXRlbS5sKSB7XG4gIFx0XHRcdGNsZWFudXAoaXRlbS5sLmYsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuXG4gIFx0XHRcdGl0ZW1zLnNwbGljZShpICsgMSwgMCwgaXRlbS5sKTtcbiAgXHRcdFx0ZGVsZXRlIGl0ZW0ubDsgLy8gVE9ETyB3b3VsZCBiZSBuaWNlIGlmIHRoZXJlIHdhcyBhIHdheSBhcm91bmQgdGhpc1xuICBcdFx0fVxuXG4gIFx0XHQvLyBDbGVhbiB1cCBlbGVtZW50IGF0dHJpYnV0ZXNcbiAgXHRcdGlmIChpdGVtLmEpIHtcbiAgXHRcdFx0Zm9yIChrZXkgaW4gaXRlbS5hKSB7XG4gIFx0XHRcdFx0aWYgKGl0ZW0uYS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHR5cGVvZiBpdGVtLmFba2V5XSAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRcdFx0Y2xlYW51cChpdGVtLmFba2V5XSwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIENsZWFuIHVwIGNvbmRpdGlvbmFsIGF0dHJpYnV0ZXNcbiAgXHRcdGlmIChpdGVtLm0pIHtcbiAgXHRcdFx0Y2xlYW51cChpdGVtLm0sIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBDbGVhbiB1cCBldmVudCBoYW5kbGVyc1xuICBcdFx0aWYgKGl0ZW0udikge1xuICBcdFx0XHRmb3IgKGtleSBpbiBpdGVtLnYpIHtcbiAgXHRcdFx0XHRpZiAoaXRlbS52Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgXHRcdFx0XHRcdC8vIGNsZWFuIHVwIG5hbWVzXG4gIFx0XHRcdFx0XHRpZiAoaXNBcnJheShpdGVtLnZba2V5XS5uKSkge1xuICBcdFx0XHRcdFx0XHRjbGVhbnVwKGl0ZW0udltrZXldLm4sIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQpO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHQvLyBjbGVhbiB1cCBwYXJhbXNcbiAgXHRcdFx0XHRcdGlmIChpc0FycmF5KGl0ZW0udltrZXldLmQpKSB7XG4gIFx0XHRcdFx0XHRcdGNsZWFudXAoaXRlbS52W2tleV0uZCwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gZmluYWwgcGFzcyAtIGZ1c2UgdGV4dCBub2RlcyB0b2dldGhlclxuICBcdGkgPSBpdGVtcy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKHR5cGVvZiBpdGVtc1tpXSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRpZiAodHlwZW9mIGl0ZW1zW2kgKyAxXSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRcdGl0ZW1zW2ldID0gaXRlbXNbaV0gKyBpdGVtc1tpICsgMV07XG4gIFx0XHRcdFx0aXRlbXMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICghcHJlc2VydmVXaGl0ZXNwYWNlKSB7XG4gIFx0XHRcdFx0aXRlbXNbaV0gPSBpdGVtc1tpXS5yZXBsYWNlKGNvbnRpZ3VvdXNXaGl0ZXNwYWNlLCBcIiBcIik7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoaXRlbXNbaV0gPT09IFwiXCIpIHtcbiAgXHRcdFx0XHRpdGVtcy5zcGxpY2UoaSwgMSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgZWxlbWVudF9yZWFkQ2xvc2luZ1RhZyA9IHJlYWRDbG9zaW5nVGFnO1xuICB2YXIgY2xvc2luZ1RhZ1BhdHRlcm4gPSAvXihbYS16QS1aXXsxLH06P1thLXpBLVowLTlcXC1dKilcXHMqXFw+LztcbiAgZnVuY3Rpb24gcmVhZENsb3NpbmdUYWcocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCB0YWc7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBhcmUgd2UgbG9va2luZyBhdCBhIGNsb3NpbmcgdGFnP1xuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPC9cIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICh0YWcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKGNsb3NpbmdUYWdQYXR0ZXJuKSkge1xuICBcdFx0aWYgKHBhcnNlci5pbnNpZGUgJiYgdGFnICE9PSBwYXJzZXIuaW5zaWRlKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IENMT1NJTkdfVEFHLFxuICBcdFx0XHRlOiB0YWdcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0Ly8gV2UgaGF2ZSBhbiBpbGxlZ2FsIGNsb3NpbmcgdGFnLCByZXBvcnQgaXRcbiAgXHRwYXJzZXIucG9zIC09IDI7XG4gIFx0cGFyc2VyLmVycm9yKFwiSWxsZWdhbCBjbG9zaW5nIHRhZ1wiKTtcbiAgfVxuXG4gIHZhciBnZXRMb3dlc3RJbmRleCA9IGZ1bmN0aW9uIChoYXlzdGFjaywgbmVlZGxlcykge1xuICBcdHZhciBpLCBpbmRleCwgbG93ZXN0O1xuXG4gIFx0aSA9IG5lZWRsZXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGluZGV4ID0gaGF5c3RhY2suaW5kZXhPZihuZWVkbGVzW2ldKTtcblxuICBcdFx0Ly8gc2hvcnQgY2lyY3VpdFxuICBcdFx0aWYgKCFpbmRleCkge1xuICBcdFx0XHRyZXR1cm4gMDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0XHRjb250aW51ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFsb3dlc3QgfHwgaW5kZXggPCBsb3dlc3QpIHtcbiAgXHRcdFx0bG93ZXN0ID0gaW5kZXg7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGxvd2VzdCB8fCAtMTtcbiAgfTtcblxuICB2YXIgZWxlbWVudF9yZWFkQXR0cmlidXRlID0gcmVhZEF0dHJpYnV0ZTtcblxuICB2YXIgYXR0cmlidXRlTmFtZVBhdHRlcm4gPSAvXlteXFxzXCInPlxcLz1dKy8sXG4gICAgICB1bnF1b3RlZEF0dHJpYnV0ZVZhbHVlVGV4dFBhdHRlcm4gPSAvXlteXFxzXCInPTw+YF0rLztcbiAgZnVuY3Rpb24gcmVhZEF0dHJpYnV0ZShwYXJzZXIpIHtcbiAgXHR2YXIgYXR0ciwgbmFtZSwgdmFsdWU7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybihhdHRyaWJ1dGVOYW1lUGF0dGVybik7XG4gIFx0aWYgKCFuYW1lKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRhdHRyID0geyBuYW1lOiBuYW1lIH07XG5cbiAgXHR2YWx1ZSA9IHJlYWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIpO1xuICBcdGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gIFx0XHQvLyBub3QgbnVsbC91bmRlZmluZWRcbiAgXHRcdGF0dHIudmFsdWUgPSB2YWx1ZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYXR0cjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIpIHtcbiAgXHR2YXIgc3RhcnQsIHZhbHVlU3RhcnQsIHN0YXJ0RGVwdGgsIHZhbHVlO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gbmV4dCBjaGFyYWN0ZXIgbXVzdCBiZSBgPWAsIGAvYCwgYD5gIG9yIHdoaXRlc3BhY2VcbiAgXHRpZiAoIS9bPVxcLz5cXHNdLy50ZXN0KHBhcnNlci5uZXh0Q2hhcigpKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgYD1gLCBgL2AsIGA+YCBvciB3aGl0ZXNwYWNlXCIpO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiPVwiKSkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0dmFsdWVTdGFydCA9IHBhcnNlci5wb3M7XG4gIFx0c3RhcnREZXB0aCA9IHBhcnNlci5zZWN0aW9uRGVwdGg7XG5cbiAgXHR2YWx1ZSA9IHJlYWRRdW90ZWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIsIFwiJ1wiKSB8fCByZWFkUXVvdGVkQXR0cmlidXRlVmFsdWUocGFyc2VyLCBcIlxcXCJcIikgfHwgcmVhZFVucXVvdGVkQXR0cmlidXRlVmFsdWUocGFyc2VyKTtcblxuICBcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgdmFsaWQgYXR0cmlidXRlIHZhbHVlXCIpO1xuICBcdH1cblxuICBcdGlmIChwYXJzZXIuc2VjdGlvbkRlcHRoICE9PSBzdGFydERlcHRoKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gdmFsdWVTdGFydDtcbiAgXHRcdHBhcnNlci5lcnJvcihcIkFuIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGNvbnRhaW4gYXMgbWFueSBvcGVuaW5nIHNlY3Rpb24gdGFncyBhcyBjbG9zaW5nIHNlY3Rpb24gdGFnc1wiKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXZhbHVlLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuIFwiXCI7XG4gIFx0fVxuXG4gIFx0aWYgKHZhbHVlLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgdmFsdWVbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHJldHVybiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKHZhbHVlWzBdKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgdGV4dCwgaGF5c3RhY2ssIG5lZWRsZXMsIGluZGV4O1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0dGV4dCA9IHBhcnNlci5tYXRjaFBhdHRlcm4odW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRleHRQYXR0ZXJuKTtcblxuICBcdGlmICghdGV4dCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aGF5c3RhY2sgPSB0ZXh0O1xuICBcdG5lZWRsZXMgPSBwYXJzZXIudGFncy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgXHRcdHJldHVybiB0Lm9wZW47XG4gIFx0fSk7IC8vIFRPRE8gcmVmYWN0b3IuLi4gd2UgZG8gdGhpcyBpbiByZWFkVGV4dC5qcyBhcyB3ZWxsXG5cbiAgXHRpZiAoKGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgoaGF5c3RhY2ssIG5lZWRsZXMpKSAhPT0gLTEpIHtcbiAgXHRcdHRleHQgPSB0ZXh0LnN1YnN0cigwLCBpbmRleCk7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQgKyB0ZXh0Lmxlbmd0aDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKHBhcnNlcikge1xuICBcdHZhciB0b2tlbnMsIHRva2VuO1xuXG4gIFx0cGFyc2VyLmluQXR0cmlidXRlID0gdHJ1ZTtcblxuICBcdHRva2VucyA9IFtdO1xuXG4gIFx0dG9rZW4gPSBjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZShwYXJzZXIpIHx8IHJlYWRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlVG9rZW4ocGFyc2VyKTtcbiAgXHR3aGlsZSAodG9rZW4gIT09IG51bGwpIHtcbiAgXHRcdHRva2Vucy5wdXNoKHRva2VuKTtcbiAgXHRcdHRva2VuID0gY29udmVydGVyc19yZWFkTXVzdGFjaGUocGFyc2VyKSB8fCByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKHBhcnNlcik7XG4gIFx0fVxuXG4gIFx0aWYgKCF0b2tlbnMubGVuZ3RoKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSBmYWxzZTtcbiAgXHRyZXR1cm4gdG9rZW5zO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFF1b3RlZEF0dHJpYnV0ZVZhbHVlKHBhcnNlciwgcXVvdGVNYXJrKSB7XG4gIFx0dmFyIHN0YXJ0LCB0b2tlbnMsIHRva2VuO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcocXVvdGVNYXJrKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmluQXR0cmlidXRlID0gcXVvdGVNYXJrO1xuXG4gIFx0dG9rZW5zID0gW107XG5cbiAgXHR0b2tlbiA9IGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlKHBhcnNlcikgfHwgcmVhZFF1b3RlZFN0cmluZ1Rva2VuKHBhcnNlciwgcXVvdGVNYXJrKTtcbiAgXHR3aGlsZSAodG9rZW4gIT09IG51bGwpIHtcbiAgXHRcdHRva2Vucy5wdXNoKHRva2VuKTtcbiAgXHRcdHRva2VuID0gY29udmVydGVyc19yZWFkTXVzdGFjaGUocGFyc2VyKSB8fCByZWFkUXVvdGVkU3RyaW5nVG9rZW4ocGFyc2VyLCBxdW90ZU1hcmspO1xuICBcdH1cblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKHF1b3RlTWFyaykpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IGZhbHNlO1xuXG4gIFx0cmV0dXJuIHRva2VucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRRdW90ZWRTdHJpbmdUb2tlbihwYXJzZXIsIHF1b3RlTWFyaykge1xuICBcdHZhciBzdGFydCwgaW5kZXgsIGhheXN0YWNrLCBuZWVkbGVzO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuICBcdGhheXN0YWNrID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXG4gIFx0bmVlZGxlcyA9IHBhcnNlci50YWdzLm1hcChmdW5jdGlvbiAodCkge1xuICBcdFx0cmV0dXJuIHQub3BlbjtcbiAgXHR9KTsgLy8gVE9ETyByZWZhY3Rvci4uLiB3ZSBkbyB0aGlzIGluIHJlYWRUZXh0LmpzIGFzIHdlbGxcbiAgXHRuZWVkbGVzLnB1c2gocXVvdGVNYXJrKTtcblxuICBcdGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgoaGF5c3RhY2ssIG5lZWRsZXMpO1xuXG4gIFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiUXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGhhdmUgYSBjbG9zaW5nIHF1b3RlXCIpO1xuICBcdH1cblxuICBcdGlmICghaW5kZXgpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG4gIFx0cmV0dXJuIGhheXN0YWNrLnN1YnN0cigwLCBpbmRleCk7XG4gIH1cblxuICB2YXIgSnNvblBhcnNlciwgc3BlY2lhbHMsIHNwZWNpYWxzUGF0dGVybiwgcGFyc2VKU09OX19udW1iZXJQYXR0ZXJuLCBwbGFjZWhvbGRlclBhdHRlcm4sIHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4sIG9ubHlXaGl0ZXNwYWNlO1xuXG4gIHNwZWNpYWxzID0ge1xuICBcdFwidHJ1ZVwiOiB0cnVlLFxuICBcdFwiZmFsc2VcIjogZmFsc2UsXG4gIFx0dW5kZWZpbmVkOiB1bmRlZmluZWQsXG4gIFx0XCJudWxsXCI6IG51bGxcbiAgfTtcblxuICBzcGVjaWFsc1BhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgT2JqZWN0LmtleXMoc3BlY2lhbHMpLmpvaW4oXCJ8XCIpICsgXCIpXCIpO1xuICBwYXJzZUpTT05fX251bWJlclBhdHRlcm4gPSAvXig/OlsrLV0/KSg/Oig/Oig/OjB8WzEtOV1cXGQqKT9cXC5cXGQrKXwoPzooPzowfFsxLTldXFxkKilcXC4pfCg/OjB8WzEtOV1cXGQqKSkoPzpbZUVdWystXT9cXGQrKT8vO1xuICBwbGFjZWhvbGRlclBhdHRlcm4gPSAvXFwkXFx7KFteXFx9XSspXFx9L2c7XG4gIHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4gPSAvXlxcJFxceyhbXlxcfV0rKVxcfS87XG4gIG9ubHlXaGl0ZXNwYWNlID0gL15cXHMqJC87XG5cbiAgSnNvblBhcnNlciA9IHBhcnNlX1BhcnNlci5leHRlbmQoe1xuICBcdGluaXQ6IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcbiAgXHRcdHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gIFx0XHR0aGlzLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdH0sXG5cbiAgXHRwb3N0UHJvY2VzczogZnVuY3Rpb24gKHJlc3VsdCkge1xuICBcdFx0aWYgKHJlc3VsdC5sZW5ndGggIT09IDEgfHwgIW9ubHlXaGl0ZXNwYWNlLnRlc3QodGhpcy5sZWZ0b3ZlcikpIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7IHZhbHVlOiByZXN1bHRbMF0udiB9O1xuICBcdH0sXG5cbiAgXHRjb252ZXJ0ZXJzOiBbZnVuY3Rpb24gZ2V0UGxhY2Vob2xkZXIocGFyc2VyKSB7XG4gIFx0XHR2YXIgcGxhY2Vob2xkZXI7XG5cbiAgXHRcdGlmICghcGFyc2VyLnZhbHVlcykge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cGxhY2Vob2xkZXIgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4pO1xuXG4gIFx0XHRpZiAocGxhY2Vob2xkZXIgJiYgcGFyc2VyLnZhbHVlcy5oYXNPd25Qcm9wZXJ0eShwbGFjZWhvbGRlcikpIHtcbiAgXHRcdFx0cmV0dXJuIHsgdjogcGFyc2VyLnZhbHVlc1twbGFjZWhvbGRlcl0gfTtcbiAgXHRcdH1cbiAgXHR9LCBmdW5jdGlvbiBnZXRTcGVjaWFsKHBhcnNlcikge1xuICBcdFx0dmFyIHNwZWNpYWw7XG5cbiAgXHRcdGlmIChzcGVjaWFsID0gcGFyc2VyLm1hdGNoUGF0dGVybihzcGVjaWFsc1BhdHRlcm4pKSB7XG4gIFx0XHRcdHJldHVybiB7IHY6IHNwZWNpYWxzW3NwZWNpYWxdIH07XG4gIFx0XHR9XG4gIFx0fSwgZnVuY3Rpb24gZ2V0TnVtYmVyKHBhcnNlcikge1xuICBcdFx0dmFyIG51bWJlcjtcblxuICBcdFx0aWYgKG51bWJlciA9IHBhcnNlci5tYXRjaFBhdHRlcm4ocGFyc2VKU09OX19udW1iZXJQYXR0ZXJuKSkge1xuICBcdFx0XHRyZXR1cm4geyB2OiArbnVtYmVyIH07XG4gIFx0XHR9XG4gIFx0fSwgZnVuY3Rpb24gZ2V0U3RyaW5nKHBhcnNlcikge1xuICBcdFx0dmFyIHN0cmluZ0xpdGVyYWwgPSByZWFkU3RyaW5nTGl0ZXJhbChwYXJzZXIpLFxuICBcdFx0ICAgIHZhbHVlcztcblxuICBcdFx0aWYgKHN0cmluZ0xpdGVyYWwgJiYgKHZhbHVlcyA9IHBhcnNlci52YWx1ZXMpKSB7XG4gIFx0XHRcdHJldHVybiB7XG4gIFx0XHRcdFx0djogc3RyaW5nTGl0ZXJhbC52LnJlcGxhY2UocGxhY2Vob2xkZXJQYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gJDEgaW4gdmFsdWVzID8gdmFsdWVzWyQxXSA6ICQxO1xuICBcdFx0XHRcdH0pXG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBzdHJpbmdMaXRlcmFsO1xuICBcdH0sIGZ1bmN0aW9uIGdldE9iamVjdChwYXJzZXIpIHtcbiAgXHRcdHZhciByZXN1bHQsIHBhaXI7XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwie1wiKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmVzdWx0ID0ge307XG5cbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIn1cIikpIHtcbiAgXHRcdFx0cmV0dXJuIHsgdjogcmVzdWx0IH07XG4gIFx0XHR9XG5cbiAgXHRcdHdoaWxlIChwYWlyID0gZ2V0S2V5VmFsdWVQYWlyKHBhcnNlcikpIHtcbiAgXHRcdFx0cmVzdWx0W3BhaXIua2V5XSA9IHBhaXIudmFsdWU7XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCJ9XCIpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHsgdjogcmVzdWx0IH07XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIixcIikpIHtcbiAgXHRcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9LCBmdW5jdGlvbiBnZXRBcnJheShwYXJzZXIpIHtcbiAgXHRcdHZhciByZXN1bHQsIHZhbHVlVG9rZW47XG5cbiAgXHRcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiW1wiKSkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmVzdWx0ID0gW107XG5cbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIl1cIikpIHtcbiAgXHRcdFx0cmV0dXJuIHsgdjogcmVzdWx0IH07XG4gIFx0XHR9XG5cbiAgXHRcdHdoaWxlICh2YWx1ZVRva2VuID0gcGFyc2VyLnJlYWQoKSkge1xuICBcdFx0XHRyZXN1bHQucHVzaCh2YWx1ZVRva2VuLnYpO1xuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHRpZiAocGFyc2VyLm1hdGNoU3RyaW5nKFwiXVwiKSkge1xuICBcdFx0XHRcdHJldHVybiB7IHY6IHJlc3VsdCB9O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCIsXCIpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1dXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGdldEtleVZhbHVlUGFpcihwYXJzZXIpIHtcbiAgXHR2YXIga2V5LCB2YWx1ZVRva2VuLCBwYWlyO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0a2V5ID0gc2hhcmVkX3JlYWRLZXkocGFyc2VyKTtcblxuICBcdGlmICgha2V5KSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYWlyID0geyBrZXk6IGtleSB9O1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKFwiOlwiKSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdHZhbHVlVG9rZW4gPSBwYXJzZXIucmVhZCgpO1xuICBcdGlmICghdmFsdWVUb2tlbikge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFpci52YWx1ZSA9IHZhbHVlVG9rZW4udjtcblxuICBcdHJldHVybiBwYWlyO1xuICB9XG5cbiAgdmFyIHBhcnNlSlNPTiA9IGZ1bmN0aW9uIChzdHIsIHZhbHVlcykge1xuICBcdHZhciBwYXJzZXIgPSBuZXcgSnNvblBhcnNlcihzdHIsIHtcbiAgXHRcdHZhbHVlczogdmFsdWVzXG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gcGFyc2VyLnJlc3VsdDtcbiAgfTtcblxuICAvLyBUT0RPIGNsZWFuIHRoaXMgdXAsIGl0J3Mgc2hvY2tpbmdcbiAgdmFyIGVsZW1lbnRfcHJvY2Vzc0RpcmVjdGl2ZSA9IHByb2Nlc3NEaXJlY3RpdmU7XG4gIHZhciBtZXRob2RDYWxsUGF0dGVybiA9IC9eKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKilcXCgvLFxuICAgICAgbWV0aG9kQ2FsbEV4Y2Vzc1BhdHRlcm4gPSAvXFwpXFxzKiQvLFxuICAgICAgRXhwcmVzc2lvblBhcnNlcjtcblxuICBFeHByZXNzaW9uUGFyc2VyID0gcGFyc2VfUGFyc2VyLmV4dGVuZCh7XG4gIFx0Y29udmVydGVyczogW2NvbnZlcnRlcnNfcmVhZEV4cHJlc3Npb25dXG4gIH0pO1xuICBmdW5jdGlvbiBwcm9jZXNzRGlyZWN0aXZlKHRva2VucywgcGFyZW50UGFyc2VyKSB7XG4gIFx0dmFyIHJlc3VsdCwgbWF0Y2gsIHBhcnNlciwgYXJncywgdG9rZW4sIGNvbG9uSW5kZXgsIGRpcmVjdGl2ZU5hbWUsIGRpcmVjdGl2ZUFyZ3MsIHBhcnNlZDtcblxuICBcdGlmICh0eXBlb2YgdG9rZW5zID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRpZiAobWF0Y2ggPSBtZXRob2RDYWxsUGF0dGVybi5leGVjKHRva2VucykpIHtcbiAgXHRcdFx0dmFyIGVuZCA9IHRva2Vucy5sYXN0SW5kZXhPZihcIilcIik7XG5cbiAgXHRcdFx0Ly8gY2hlY2sgZm9yIGludmFsaWQgbWV0aG9kIGNhbGxzXG4gIFx0XHRcdGlmICghbWV0aG9kQ2FsbEV4Y2Vzc1BhdHRlcm4udGVzdCh0b2tlbnMpKSB7XG4gIFx0XHRcdFx0cGFyZW50UGFyc2VyLmVycm9yKFwiSW52YWxpZCBpbnB1dCBhZnRlciBtZXRob2QgY2FsbCBleHByZXNzaW9uICdcIiArIHRva2Vucy5zbGljZShlbmQgKyAxKSArIFwiJ1wiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJlc3VsdCA9IHsgbTogbWF0Y2hbMV0gfTtcbiAgXHRcdFx0YXJncyA9IFwiW1wiICsgdG9rZW5zLnNsaWNlKHJlc3VsdC5tLmxlbmd0aCArIDEsIGVuZCkgKyBcIl1cIjtcblxuICBcdFx0XHRwYXJzZXIgPSBuZXcgRXhwcmVzc2lvblBhcnNlcihhcmdzKTtcbiAgXHRcdFx0cmVzdWx0LmEgPSB1dGlsc19mbGF0dGVuRXhwcmVzc2lvbihwYXJzZXIucmVzdWx0WzBdKTtcblxuICBcdFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodG9rZW5zLmluZGV4T2YoXCI6XCIpID09PSAtMSkge1xuICBcdFx0XHRyZXR1cm4gdG9rZW5zLnRyaW0oKTtcbiAgXHRcdH1cblxuICBcdFx0dG9rZW5zID0gW3Rva2Vuc107XG4gIFx0fVxuXG4gIFx0cmVzdWx0ID0ge307XG5cbiAgXHRkaXJlY3RpdmVOYW1lID0gW107XG4gIFx0ZGlyZWN0aXZlQXJncyA9IFtdO1xuXG4gIFx0aWYgKHRva2Vucykge1xuICBcdFx0d2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgXHRcdFx0dG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblxuICBcdFx0XHRpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdFx0Y29sb25JbmRleCA9IHRva2VuLmluZGV4T2YoXCI6XCIpO1xuXG4gIFx0XHRcdFx0aWYgKGNvbG9uSW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdFx0XHRkaXJlY3RpdmVOYW1lLnB1c2godG9rZW4pO1xuICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgXHRcdFx0XHRcdC8vIGlzIHRoZSBjb2xvbiB0aGUgZmlyc3QgY2hhcmFjdGVyP1xuICBcdFx0XHRcdFx0aWYgKGNvbG9uSW5kZXgpIHtcbiAgXHRcdFx0XHRcdFx0Ly8gbm9cbiAgXHRcdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKHRva2VuLnN1YnN0cigwLCBjb2xvbkluZGV4KSk7XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdC8vIGlmIHRoZXJlIGlzIGFueXRoaW5nIGFmdGVyIHRoZSBjb2xvbiBpbiB0aGlzIHRva2VuLCB0cmVhdFxuICBcdFx0XHRcdFx0Ly8gaXQgYXMgdGhlIGZpcnN0IHRva2VuIG9mIHRoZSBkaXJlY3RpdmVBcmdzIGZyYWdtZW50XG4gIFx0XHRcdFx0XHRpZiAodG9rZW4ubGVuZ3RoID4gY29sb25JbmRleCArIDEpIHtcbiAgXHRcdFx0XHRcdFx0ZGlyZWN0aXZlQXJnc1swXSA9IHRva2VuLnN1YnN0cmluZyhjb2xvbkluZGV4ICsgMSk7XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRkaXJlY3RpdmVOYW1lLnB1c2godG9rZW4pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGRpcmVjdGl2ZUFyZ3MgPSBkaXJlY3RpdmVBcmdzLmNvbmNhdCh0b2tlbnMpO1xuICBcdH1cblxuICBcdGlmICghZGlyZWN0aXZlTmFtZS5sZW5ndGgpIHtcbiAgXHRcdHJlc3VsdCA9IFwiXCI7XG4gIFx0fSBlbHNlIGlmIChkaXJlY3RpdmVBcmdzLmxlbmd0aCB8fCB0eXBlb2YgZGlyZWN0aXZlTmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0cmVzdWx0ID0ge1xuICBcdFx0XHQvLyBUT0RPIGlzIHRoaXMgcmVhbGx5IG5lY2Vzc2FyeT8ganVzdCB1c2UgdGhlIGFycmF5XG4gIFx0XHRcdG46IGRpcmVjdGl2ZU5hbWUubGVuZ3RoID09PSAxICYmIHR5cGVvZiBkaXJlY3RpdmVOYW1lWzBdID09PSBcInN0cmluZ1wiID8gZGlyZWN0aXZlTmFtZVswXSA6IGRpcmVjdGl2ZU5hbWVcbiAgXHRcdH07XG5cbiAgXHRcdGlmIChkaXJlY3RpdmVBcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGlyZWN0aXZlQXJnc1swXSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRwYXJzZWQgPSBwYXJzZUpTT04oXCJbXCIgKyBkaXJlY3RpdmVBcmdzWzBdICsgXCJdXCIpO1xuICBcdFx0XHRyZXN1bHQuYSA9IHBhcnNlZCA/IHBhcnNlZC52YWx1ZSA6IGRpcmVjdGl2ZUFyZ3NbMF0udHJpbSgpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmVzdWx0LmQgPSBkaXJlY3RpdmVBcmdzO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXN1bHQgPSBkaXJlY3RpdmVOYW1lO1xuICBcdH1cblxuICBcdHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgdGFnTmFtZVBhdHRlcm4gPSAvXlthLXpBLVpdezEsfTo/W2EtekEtWjAtOVxcLV0qLyxcbiAgICAgIHZhbGlkVGFnTmFtZUZvbGxvd2VyID0gL15bXFxzXFxuXFwvPl0vLFxuICAgICAgb25QYXR0ZXJuID0gL15vbi8sXG4gICAgICBwcm94eUV2ZW50UGF0dGVybiA9IC9eb24tKFthLXpBLVpcXFxcKlxcXFwuJF9dW2EtekEtWlxcXFwqXFxcXC4kXzAtOVxcLV0rKSQvLFxuICAgICAgcmVzZXJ2ZWRFdmVudE5hbWVzID0gL14oPzpjaGFuZ2V8cmVzZXR8dGVhcmRvd258dXBkYXRlfGNvbnN0cnVjdHxjb25maWd8aW5pdHxyZW5kZXJ8dW5yZW5kZXJ8ZGV0YWNofGluc2VydCkkLyxcbiAgICAgIGRpcmVjdGl2ZXMgPSB7IFwiaW50cm8tb3V0cm9cIjogXCJ0MFwiLCBpbnRybzogXCJ0MVwiLCBvdXRybzogXCJ0MlwiLCBkZWNvcmF0b3I6IFwib1wiIH0sXG4gICAgICBleGNsdWRlID0geyBleGNsdWRlOiB0cnVlIH0sXG4gICAgICBkaXNhbGxvd2VkQ29udGVudHM7XG5cbiAgLy8gYmFzZWQgb24gaHR0cDovL2RldmVsb3BlcnMud2hhdHdnLm9yZy9zeW50YXguaHRtbCNzeW50YXgtdGFnLW9taXNzaW9uXG4gIGRpc2FsbG93ZWRDb250ZW50cyA9IHtcbiAgXHRsaTogW1wibGlcIl0sXG4gIFx0ZHQ6IFtcImR0XCIsIFwiZGRcIl0sXG4gIFx0ZGQ6IFtcImR0XCIsIFwiZGRcIl0sXG4gIFx0cDogXCJhZGRyZXNzIGFydGljbGUgYXNpZGUgYmxvY2txdW90ZSBkaXYgZGwgZmllbGRzZXQgZm9vdGVyIGZvcm0gaDEgaDIgaDMgaDQgaDUgaDYgaGVhZGVyIGhncm91cCBociBtYWluIG1lbnUgbmF2IG9sIHAgcHJlIHNlY3Rpb24gdGFibGUgdWxcIi5zcGxpdChcIiBcIiksXG4gIFx0cnQ6IFtcInJ0XCIsIFwicnBcIl0sXG4gIFx0cnA6IFtcInJ0XCIsIFwicnBcIl0sXG4gIFx0b3B0Z3JvdXA6IFtcIm9wdGdyb3VwXCJdLFxuICBcdG9wdGlvbjogW1wib3B0aW9uXCIsIFwib3B0Z3JvdXBcIl0sXG4gIFx0dGhlYWQ6IFtcInRib2R5XCIsIFwidGZvb3RcIl0sXG4gIFx0dGJvZHk6IFtcInRib2R5XCIsIFwidGZvb3RcIl0sXG4gIFx0dGZvb3Q6IFtcInRib2R5XCJdLFxuICBcdHRyOiBbXCJ0clwiLCBcInRib2R5XCJdLFxuICBcdHRkOiBbXCJ0ZFwiLCBcInRoXCIsIFwidHJcIl0sXG4gIFx0dGg6IFtcInRkXCIsIFwidGhcIiwgXCJ0clwiXVxuICB9O1xuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRFbGVtZW50ID0gcmVhZEVsZW1lbnQ7XG5cbiAgZnVuY3Rpb24gcmVhZEVsZW1lbnQocGFyc2VyKSB7XG4gIFx0dmFyIHN0YXJ0LCBlbGVtZW50LCBkaXJlY3RpdmVOYW1lLCBtYXRjaCwgYWRkUHJveHlFdmVudCwgYXR0cmlidXRlLCBkaXJlY3RpdmUsIHNlbGZDbG9zaW5nLCBjaGlsZHJlbiwgcGFydGlhbHMsIGhhc1BhcnRpYWxzLCBjaGlsZCwgY2xvc2VkLCBwb3MsIHJlbWFpbmluZywgY2xvc2luZ1RhZztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmIChwYXJzZXIuaW5zaWRlIHx8IHBhcnNlci5pbkF0dHJpYnV0ZSkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCFwYXJzZXIubWF0Y2hTdHJpbmcoXCI8XCIpKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBpZiB0aGlzIGlzIGEgY2xvc2luZyB0YWcsIGFib3J0IHN0cmFpZ2h0IGF3YXlcbiAgXHRpZiAocGFyc2VyLm5leHRDaGFyKCkgPT09IFwiL1wiKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRlbGVtZW50ID0ge307XG4gIFx0aWYgKHBhcnNlci5pbmNsdWRlTGluZVBvc2l0aW9ucykge1xuICBcdFx0ZWxlbWVudC5wID0gcGFyc2VyLmdldExpbmVQb3Moc3RhcnQpO1xuICBcdH1cblxuICBcdGlmIChwYXJzZXIubWF0Y2hTdHJpbmcoXCIhXCIpKSB7XG4gIFx0XHRlbGVtZW50LnQgPSBET0NUWVBFO1xuICBcdFx0aWYgKCFwYXJzZXIubWF0Y2hQYXR0ZXJuKC9eZG9jdHlwZS9pKSkge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBET0NUWVBFIGRlY2xhcmF0aW9uXCIpO1xuICBcdFx0fVxuXG4gIFx0XHRlbGVtZW50LmEgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKC9eKC4rPyk+Lyk7XG4gIFx0XHRyZXR1cm4gZWxlbWVudDtcbiAgXHR9XG5cbiAgXHRlbGVtZW50LnQgPSBFTEVNRU5UO1xuXG4gIFx0Ly8gZWxlbWVudCBuYW1lXG4gIFx0ZWxlbWVudC5lID0gcGFyc2VyLm1hdGNoUGF0dGVybih0YWdOYW1lUGF0dGVybik7XG4gIFx0aWYgKCFlbGVtZW50LmUpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIG5leHQgY2hhcmFjdGVyIG11c3QgYmUgd2hpdGVzcGFjZSwgY2xvc2luZyBzb2xpZHVzIG9yICc+J1xuICBcdGlmICghdmFsaWRUYWdOYW1lRm9sbG93ZXIudGVzdChwYXJzZXIubmV4dENoYXIoKSkpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcIklsbGVnYWwgdGFnIG5hbWVcIik7XG4gIFx0fVxuXG4gIFx0YWRkUHJveHlFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBkaXJlY3RpdmUpIHtcbiAgXHRcdHZhciBkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlLm4gfHwgZGlyZWN0aXZlO1xuXG4gIFx0XHRpZiAocmVzZXJ2ZWRFdmVudE5hbWVzLnRlc3QoZGlyZWN0aXZlTmFtZSkpIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyAtPSBkaXJlY3RpdmVOYW1lLmxlbmd0aDtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiQ2Fubm90IHVzZSByZXNlcnZlZCBldmVudCBuYW1lcyAoY2hhbmdlLCByZXNldCwgdGVhcmRvd24sIHVwZGF0ZSwgY29uc3RydWN0LCBjb25maWcsIGluaXQsIHJlbmRlciwgdW5yZW5kZXIsIGRldGFjaCwgaW5zZXJ0KVwiKTtcbiAgXHRcdH1cblxuICBcdFx0ZWxlbWVudC52W25hbWVdID0gZGlyZWN0aXZlO1xuICBcdH07XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBkaXJlY3RpdmVzIGFuZCBhdHRyaWJ1dGVzXG4gIFx0d2hpbGUgKGF0dHJpYnV0ZSA9IGNvbnZlcnRlcnNfcmVhZE11c3RhY2hlKHBhcnNlcikgfHwgZWxlbWVudF9yZWFkQXR0cmlidXRlKHBhcnNlcikpIHtcbiAgXHRcdC8vIHJlZ3VsYXIgYXR0cmlidXRlc1xuICBcdFx0aWYgKGF0dHJpYnV0ZS5uYW1lKSB7XG4gIFx0XHRcdC8vIGludHJvLCBvdXRybywgZGVjb3JhdG9yXG4gIFx0XHRcdGlmIChkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlc1thdHRyaWJ1dGUubmFtZV0pIHtcbiAgXHRcdFx0XHRlbGVtZW50W2RpcmVjdGl2ZU5hbWVdID0gZWxlbWVudF9wcm9jZXNzRGlyZWN0aXZlKGF0dHJpYnV0ZS52YWx1ZSwgcGFyc2VyKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIG9uLWNsaWNrIGV0Y1xuICBcdFx0XHRlbHNlIGlmIChtYXRjaCA9IHByb3h5RXZlbnRQYXR0ZXJuLmV4ZWMoYXR0cmlidXRlLm5hbWUpKSB7XG4gIFx0XHRcdFx0aWYgKCFlbGVtZW50LnYpIGVsZW1lbnQudiA9IHt9O1xuICBcdFx0XHRcdGRpcmVjdGl2ZSA9IGVsZW1lbnRfcHJvY2Vzc0RpcmVjdGl2ZShhdHRyaWJ1dGUudmFsdWUsIHBhcnNlcik7XG4gIFx0XHRcdFx0YWRkUHJveHlFdmVudChtYXRjaFsxXSwgZGlyZWN0aXZlKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRpZiAoIXBhcnNlci5zYW5pdGl6ZUV2ZW50QXR0cmlidXRlcyB8fCAhb25QYXR0ZXJuLnRlc3QoYXR0cmlidXRlLm5hbWUpKSB7XG4gIFx0XHRcdFx0XHRpZiAoIWVsZW1lbnQuYSkgZWxlbWVudC5hID0ge307XG4gIFx0XHRcdFx0XHRlbGVtZW50LmFbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlIHx8IChhdHRyaWJ1dGUudmFsdWUgPT09IFwiXCIgPyBcIlwiIDogMCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHt7I2lmIGZvb319Y2xhc3M9J2Zvbyd7ey9pZn19XG4gIFx0XHRlbHNlIHtcbiAgXHRcdFx0aWYgKCFlbGVtZW50Lm0pIGVsZW1lbnQubSA9IFtdO1xuICBcdFx0XHRlbGVtZW50Lm0ucHVzaChhdHRyaWJ1dGUpO1xuICBcdFx0fVxuXG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0fVxuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgY2xvc2luZyBzb2xpZHVzXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gc2VsZi1jbG9zaW5nIHNvbGlkdXM/XG4gIFx0aWYgKHBhcnNlci5tYXRjaFN0cmluZyhcIi9cIikpIHtcbiAgXHRcdHNlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHQvLyBjbG9zaW5nIGFuZ2xlIGJyYWNrZXRcbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhcIj5cIikpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHZhciBsb3dlckNhc2VOYW1lID0gZWxlbWVudC5lLnRvTG93ZXJDYXNlKCk7XG4gIFx0dmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IHBhcnNlci5wcmVzZXJ2ZVdoaXRlc3BhY2U7XG5cbiAgXHRpZiAoIXNlbGZDbG9zaW5nICYmICF2b2lkRWxlbWVudE5hbWVzLnRlc3QoZWxlbWVudC5lKSkge1xuICBcdFx0cGFyc2VyLmVsZW1lbnRTdGFjay5wdXNoKGxvd2VyQ2FzZU5hbWUpO1xuXG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBpZiB3ZSBvcGVuIGEgc2NyaXB0IGVsZW1lbnQsIGZ1cnRoZXIgdGFncyBzaG91bGRcbiAgXHRcdC8vIGJlIGlnbm9yZWQgdW5sZXNzIHRoZXkncmUgYSBjbG9zaW5nIHNjcmlwdCBlbGVtZW50XG4gIFx0XHRpZiAobG93ZXJDYXNlTmFtZSA9PT0gXCJzY3JpcHRcIiB8fCBsb3dlckNhc2VOYW1lID09PSBcInN0eWxlXCIpIHtcbiAgXHRcdFx0cGFyc2VyLmluc2lkZSA9IGxvd2VyQ2FzZU5hbWU7XG4gIFx0XHR9XG5cbiAgXHRcdGNoaWxkcmVuID0gW107XG4gIFx0XHRwYXJ0aWFscyA9IGNyZWF0ZShudWxsKTtcblxuICBcdFx0ZG8ge1xuICBcdFx0XHRwb3MgPSBwYXJzZXIucG9zO1xuICBcdFx0XHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cbiAgXHRcdFx0Ly8gaWYgZm9yIGV4YW1wbGUgd2UncmUgaW4gYW4gPGxpPiBlbGVtZW50LCBhbmQgd2Ugc2VlIGFub3RoZXJcbiAgXHRcdFx0Ly8gPGxpPiB0YWcsIGNsb3NlIHRoZSBmaXJzdCBzbyB0aGV5IGJlY29tZSBzaWJsaW5nc1xuICBcdFx0XHRpZiAoIWNhbkNvbnRhaW4obG93ZXJDYXNlTmFtZSwgcmVtYWluaW5nKSkge1xuICBcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBjbG9zaW5nIHRhZ1xuICBcdFx0XHRlbHNlIGlmIChjbG9zaW5nVGFnID0gZWxlbWVudF9yZWFkQ2xvc2luZ1RhZyhwYXJzZXIpKSB7XG4gIFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcblxuICBcdFx0XHRcdHZhciBjbG9zaW5nVGFnTmFtZSA9IGNsb3NpbmdUYWcuZS50b0xvd2VyQ2FzZSgpO1xuXG4gIFx0XHRcdFx0Ly8gaWYgdGhpcyAqaXNuJ3QqIHRoZSBjbG9zaW5nIHRhZyBmb3IgdGhlIGN1cnJlbnQgZWxlbWVudC4uLlxuICBcdFx0XHRcdGlmIChjbG9zaW5nVGFnTmFtZSAhPT0gbG93ZXJDYXNlTmFtZSkge1xuICBcdFx0XHRcdFx0Ly8gcmV3aW5kIHBhcnNlclxuICBcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcblxuICBcdFx0XHRcdFx0Ly8gaWYgaXQgZG9lc24ndCBjbG9zZSBhIHBhcmVudCB0YWcsIGVycm9yXG4gIFx0XHRcdFx0XHRpZiAoISB+cGFyc2VyLmVsZW1lbnRTdGFjay5pbmRleE9mKGNsb3NpbmdUYWdOYW1lKSkge1xuICBcdFx0XHRcdFx0XHR2YXIgZXJyb3JNZXNzYWdlID0gXCJVbmV4cGVjdGVkIGNsb3NpbmcgdGFnXCI7XG5cbiAgXHRcdFx0XHRcdFx0Ly8gYWRkIGFkZGl0aW9uYWwgaGVscCBmb3Igdm9pZCBlbGVtZW50cywgc2luY2UgY29tcG9uZW50IG5hbWVzXG4gIFx0XHRcdFx0XHRcdC8vIG1pZ2h0IGNsYXNoIHdpdGggdGhlbVxuICBcdFx0XHRcdFx0XHRpZiAodm9pZEVsZW1lbnROYW1lcy50ZXN0KGNsb3NpbmdUYWdOYW1lKSkge1xuICBcdFx0XHRcdFx0XHRcdGVycm9yTWVzc2FnZSArPSBcIiAoPFwiICsgY2xvc2luZ1RhZ05hbWUgKyBcIj4gaXMgYSB2b2lkIGVsZW1lbnQgLSBpdCBjYW5ub3QgY29udGFpbiBjaGlsZHJlbilcIjtcbiAgXHRcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRcdHBhcnNlci5lcnJvcihlcnJvck1lc3NhZ2UpO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGltcGxpY2l0IGNsb3NlIGJ5IGNsb3Npbmcgc2VjdGlvbiB0YWcuIFRPRE8gY2xlYW4gdGhpcyB1cFxuICBcdFx0XHRlbHNlIGlmIChjaGlsZCA9IHNlY3Rpb25fcmVhZENsb3NpbmcocGFyc2VyLCB7IG9wZW46IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMF0sIGNsb3NlOiBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzFdIH0pKSB7XG4gIFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gcG9zO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdGlmIChjaGlsZCA9IHBhcnNlci5yZWFkKFBBUlRJQUxfUkVBREVSUykpIHtcbiAgXHRcdFx0XHRcdGlmIChwYXJ0aWFsc1tjaGlsZC5uXSkge1xuICBcdFx0XHRcdFx0XHRwYXJzZXIucG9zID0gcG9zO1xuICBcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJEdXBsaWNhdGUgcGFydGlhbCBkZWZpbml0aW9uXCIpO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHR1dGlsc19jbGVhbnVwKGNoaWxkLmYsIHBhcnNlci5zdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsICFwcmVzZXJ2ZVdoaXRlc3BhY2UsICFwcmVzZXJ2ZVdoaXRlc3BhY2UpO1xuXG4gIFx0XHRcdFx0XHRwYXJ0aWFsc1tjaGlsZC5uXSA9IGNoaWxkLmY7XG4gIFx0XHRcdFx0XHRoYXNQYXJ0aWFscyA9IHRydWU7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGlmIChjaGlsZCA9IHBhcnNlci5yZWFkKFJFQURFUlMpKSB7XG4gIFx0XHRcdFx0XHRcdGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICBcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gd2hpbGUgKCFjbG9zZWQpO1xuXG4gIFx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gIFx0XHRcdGVsZW1lbnQuZiA9IGNoaWxkcmVuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoaGFzUGFydGlhbHMpIHtcbiAgXHRcdFx0ZWxlbWVudC5wID0gcGFydGlhbHM7XG4gIFx0XHR9XG5cbiAgXHRcdHBhcnNlci5lbGVtZW50U3RhY2sucG9wKCk7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmluc2lkZSA9IG51bGw7XG5cbiAgXHRpZiAocGFyc2VyLnNhbml0aXplRWxlbWVudHMgJiYgcGFyc2VyLnNhbml0aXplRWxlbWVudHMuaW5kZXhPZihsb3dlckNhc2VOYW1lKSAhPT0gLTEpIHtcbiAgXHRcdHJldHVybiBleGNsdWRlO1xuICBcdH1cblxuICBcdHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuQ29udGFpbihuYW1lLCByZW1haW5pbmcpIHtcbiAgXHR2YXIgbWF0Y2gsIGRpc2FsbG93ZWQ7XG5cbiAgXHRtYXRjaCA9IC9ePChbYS16QS1aXVthLXpBLVowLTldKikvLmV4ZWMocmVtYWluaW5nKTtcbiAgXHRkaXNhbGxvd2VkID0gZGlzYWxsb3dlZENvbnRlbnRzW25hbWVdO1xuXG4gIFx0aWYgKCFtYXRjaCB8fCAhZGlzYWxsb3dlZCkge1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuXG4gIFx0cmV0dXJuICEgfmRpc2FsbG93ZWQuaW5kZXhPZihtYXRjaFsxXS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIHZhciBjb252ZXJ0ZXJzX3JlYWRUZXh0ID0gcmVhZFRleHQ7XG4gIGZ1bmN0aW9uIHJlYWRUZXh0KHBhcnNlcikge1xuICBcdHZhciBpbmRleCwgcmVtYWluaW5nLCBkaXNhbGxvd2VkLCBiYXJyaWVyO1xuXG4gIFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXG4gIFx0YmFycmllciA9IHBhcnNlci5pbnNpZGUgPyBcIjwvXCIgKyBwYXJzZXIuaW5zaWRlIDogXCI8XCI7XG5cbiAgXHRpZiAocGFyc2VyLmluc2lkZSAmJiAhcGFyc2VyLmludGVycG9sYXRlW3BhcnNlci5pbnNpZGVdKSB7XG4gIFx0XHRpbmRleCA9IHJlbWFpbmluZy5pbmRleE9mKGJhcnJpZXIpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRkaXNhbGxvd2VkID0gcGFyc2VyLnRhZ3MubWFwKGZ1bmN0aW9uICh0KSB7XG4gIFx0XHRcdHJldHVybiB0Lm9wZW47XG4gIFx0XHR9KTtcbiAgXHRcdGRpc2FsbG93ZWQgPSBkaXNhbGxvd2VkLmNvbmNhdChwYXJzZXIudGFncy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgXHRcdFx0cmV0dXJuIFwiXFxcXFwiICsgdC5vcGVuO1xuICBcdFx0fSkpO1xuXG4gIFx0XHQvLyBodHRwOi8vZGV2ZWxvcGVycy53aGF0d2cub3JnL3N5bnRheC5odG1sI3N5bnRheC1hdHRyaWJ1dGVzXG4gIFx0XHRpZiAocGFyc2VyLmluQXR0cmlidXRlID09PSB0cnVlKSB7XG4gIFx0XHRcdC8vIHdlJ3JlIGluc2lkZSBhbiB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVcbiAgXHRcdFx0ZGlzYWxsb3dlZC5wdXNoKFwiXFxcIlwiLCBcIidcIiwgXCI9XCIsIFwiPFwiLCBcIj5cIiwgXCJgXCIpO1xuICBcdFx0fSBlbHNlIGlmIChwYXJzZXIuaW5BdHRyaWJ1dGUpIHtcbiAgXHRcdFx0Ly8gcXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZVxuICBcdFx0XHRkaXNhbGxvd2VkLnB1c2gocGFyc2VyLmluQXR0cmlidXRlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGRpc2FsbG93ZWQucHVzaChiYXJyaWVyKTtcbiAgXHRcdH1cblxuICBcdFx0aW5kZXggPSBnZXRMb3dlc3RJbmRleChyZW1haW5pbmcsIGRpc2FsbG93ZWQpO1xuICBcdH1cblxuICBcdGlmICghaW5kZXgpIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdGluZGV4ID0gcmVtYWluaW5nLmxlbmd0aDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIucG9zICs9IGluZGV4O1xuXG4gIFx0cmV0dXJuIHBhcnNlci5pbnNpZGUgPyByZW1haW5pbmcuc3Vic3RyKDAsIGluZGV4KSA6IGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMocmVtYWluaW5nLnN1YnN0cigwLCBpbmRleCkpO1xuICB9XG5cbiAgdmFyIHV0aWxzX2VzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcbiAgdmFyIHV0aWxzX2VzY2FwZVJlZ0V4cF9fcGF0dGVybiA9IC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nO1xuICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gIFx0cmV0dXJuIHN0ci5yZXBsYWNlKHV0aWxzX2VzY2FwZVJlZ0V4cF9fcGF0dGVybiwgXCJcXFxcJCZcIik7XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkUGFydGlhbERlZmluaXRpb25Db21tZW50ID0gcmVhZFBhcnRpYWxEZWZpbml0aW9uQ29tbWVudDtcblxuICB2YXIgc3RhcnRQYXR0ZXJuID0gL148IS0tXFxzKi8sXG4gICAgICBuYW1lUGF0dGVybiA9IC9zKj5cXHMqKFthLXpBLVpfJF1bLWEtekEtWl8kMC05XSopXFxzKi8sXG4gICAgICBmaW5pc2hQYXR0ZXJuID0gL1xccyotLT4vLFxuICAgICAgY2hpbGQ7XG5cbiAgZnVuY3Rpb24gcmVhZFBhcnRpYWxEZWZpbml0aW9uQ29tbWVudChwYXJzZXIpIHtcbiAgXHR2YXIgZmlyc3RQb3MgPSBwYXJzZXIucG9zLFxuICBcdCAgICBvcGVuID0gcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1swXSxcbiAgXHQgICAgY2xvc2UgPSBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzFdLFxuICBcdCAgICBjb250ZW50ID0gdW5kZWZpbmVkLFxuICBcdCAgICBjbG9zZWQgPSB1bmRlZmluZWQ7XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4oc3RhcnRQYXR0ZXJuKSB8fCAhcGFyc2VyLm1hdGNoU3RyaW5nKG9wZW4pKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gZmlyc3RQb3M7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHR2YXIgbmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4obmFtZVBhdHRlcm4pO1xuXG4gIFx0d2Fybk9uY2VJZkRlYnVnKFwiSW5saW5lIHBhcnRpYWwgY29tbWVudHMgYXJlIGRlcHJlY2F0ZWQuXFxuVXNlIHRoaXMuLi5cXG4gIHt7I3BhcnRpYWwgXCIgKyBuYW1lICsgXCJ9fSAuLi4ge3svcGFydGlhbH19XFxuXFxuLi4uaW5zdGVhZCBvZiB0aGlzOlxcbiAgPCEtLSB7ez5cIiArIG5hbWUgKyBcIn19IC0tPiAuLi4gPCEtLSB7ey9cIiArIG5hbWUgKyBcIn19IC0tPidcIik7XG5cbiAgXHQvLyBtYWtlIHN1cmUgdGhlIHJlc3Qgb2YgdGhlIGNvbW1lbnQgaXMgaW4gdGhlIGNvcnJlY3QgcGxhY2VcbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhjbG9zZSkgfHwgIXBhcnNlci5tYXRjaFBhdHRlcm4oZmluaXNoUGF0dGVybikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBmaXJzdFBvcztcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGNvbnRlbnQgPSBbXTtcblxuICBcdHZhciBlbmRQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl48IS0tXFxcXHMqXCIgKyB1dGlsc19lc2NhcGVSZWdFeHAob3BlbikgKyBcIlxcXFxzKlxcXFwvXFxcXHMqXCIgKyBuYW1lICsgXCJcXFxccypcIiArIHV0aWxzX2VzY2FwZVJlZ0V4cChjbG9zZSkgKyBcIlxcXFxzKi0tPlwiKTtcblxuICBcdGRvIHtcbiAgXHRcdGlmIChwYXJzZXIubWF0Y2hQYXR0ZXJuKGVuZFBhdHRlcm4pKSB7XG4gIFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjaGlsZCA9IHBhcnNlci5yZWFkKFJFQURFUlMpO1xuICBcdFx0XHRpZiAoIWNoaWxkKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKFwiZXhwZWN0ZWQgY2xvc2luZyBjb21tZW50ICgnPCEtLSBcIiArIG9wZW4gKyBcIi9cIiArIG5hbWUgKyBcIlwiICsgY2xvc2UgKyBcIiAtLT4nKVwiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNvbnRlbnQucHVzaChjaGlsZCk7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoIWNsb3NlZCk7XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogSU5MSU5FX1BBUlRJQUwsXG4gIFx0XHRmOiBjb250ZW50LFxuICBcdFx0bjogbmFtZVxuICBcdH07XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkUGFydGlhbERlZmluaXRpb25TZWN0aW9uID0gcmVhZFBhcnRpYWxEZWZpbml0aW9uU2VjdGlvbjtcbiAgdmFyIHBhcnRpYWxEZWZpbml0aW9uU2VjdGlvblBhdHRlcm4gPSAvXiNcXHMqcGFydGlhbFxccysvO1xuICBmdW5jdGlvbiByZWFkUGFydGlhbERlZmluaXRpb25TZWN0aW9uKHBhcnNlcikge1xuICBcdHZhciBzdGFydCwgbmFtZSwgY29udGVudCwgY2hpbGQsIGNsb3NlZDtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdHZhciBkZWxpbWl0ZXJzID0gcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVycztcblxuICBcdGlmICghcGFyc2VyLm1hdGNoU3RyaW5nKGRlbGltaXRlcnNbMF0pKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFBhdHRlcm4ocGFydGlhbERlZmluaXRpb25TZWN0aW9uUGF0dGVybikpIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOVxcLV0qLyk7XG5cbiAgXHRpZiAoIW5hbWUpIHtcbiAgXHRcdHBhcnNlci5lcnJvcihcImV4cGVjdGVkIGxlZ2FsIHBhcnRpYWwgbmFtZVwiKTtcbiAgXHR9XG5cbiAgXHRpZiAoIXBhcnNlci5tYXRjaFN0cmluZyhkZWxpbWl0ZXJzWzFdKSkge1xuICBcdFx0cGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgZGVsaW1pdGVyc1sxXSArIFwiJ1wiKTtcbiAgXHR9XG5cbiAgXHRjb250ZW50ID0gW107XG5cbiAgXHRkbyB7XG4gIFx0XHQvLyBUT0RPIGNsZWFuIHRoaXMgdXBcbiAgXHRcdGlmIChjaGlsZCA9IHNlY3Rpb25fcmVhZENsb3NpbmcocGFyc2VyLCB7IG9wZW46IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMF0sIGNsb3NlOiBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzFdIH0pKSB7XG4gIFx0XHRcdGlmICghY2hpbGQuciA9PT0gXCJwYXJ0aWFsXCIpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBcIiArIGRlbGltaXRlcnNbMF0gKyBcIi9wYXJ0aWFsXCIgKyBkZWxpbWl0ZXJzWzFdKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjaGlsZCA9IHBhcnNlci5yZWFkKFJFQURFUlMpO1xuXG4gIFx0XHRcdGlmICghY2hpbGQpIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBcIiArIGRlbGltaXRlcnNbMF0gKyBcIi9wYXJ0aWFsXCIgKyBkZWxpbWl0ZXJzWzFdKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNvbnRlbnQucHVzaChjaGlsZCk7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoIWNsb3NlZCk7XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogSU5MSU5FX1BBUlRJQUwsXG4gIFx0XHRuOiBuYW1lLFxuICBcdFx0ZjogY29udGVudFxuICBcdH07XG4gIH1cblxuICB2YXIgY29udmVydGVyc19yZWFkVGVtcGxhdGUgPSByZWFkVGVtcGxhdGU7XG4gIGZ1bmN0aW9uIHJlYWRUZW1wbGF0ZShwYXJzZXIpIHtcbiAgXHR2YXIgZnJhZ21lbnQgPSBbXTtcbiAgXHR2YXIgcGFydGlhbHMgPSBjcmVhdGUobnVsbCk7XG4gIFx0dmFyIGhhc1BhcnRpYWxzID0gZmFsc2U7XG5cbiAgXHR2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gcGFyc2VyLnByZXNlcnZlV2hpdGVzcGFjZTtcblxuICBcdHdoaWxlIChwYXJzZXIucG9zIDwgcGFyc2VyLnN0ci5sZW5ndGgpIHtcbiAgXHRcdHZhciBwb3MgPSBwYXJzZXIucG9zLFxuICBcdFx0ICAgIGl0ZW0gPSB1bmRlZmluZWQsXG4gIFx0XHQgICAgcGFydGlhbCA9IHVuZGVmaW5lZDtcblxuICBcdFx0aWYgKHBhcnRpYWwgPSBwYXJzZXIucmVhZChQQVJUSUFMX1JFQURFUlMpKSB7XG4gIFx0XHRcdGlmIChwYXJ0aWFsc1twYXJ0aWFsLm5dKSB7XG4gIFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoXCJEdXBsaWNhdGVkIHBhcnRpYWwgZGVmaW5pdGlvblwiKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHV0aWxzX2NsZWFudXAocGFydGlhbC5mLCBwYXJzZXIuc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCAhcHJlc2VydmVXaGl0ZXNwYWNlLCAhcHJlc2VydmVXaGl0ZXNwYWNlKTtcblxuICBcdFx0XHRwYXJ0aWFsc1twYXJ0aWFsLm5dID0gcGFydGlhbC5mO1xuICBcdFx0XHRoYXNQYXJ0aWFscyA9IHRydWU7XG4gIFx0XHR9IGVsc2UgaWYgKGl0ZW0gPSBwYXJzZXIucmVhZChSRUFERVJTKSkge1xuICBcdFx0XHRmcmFnbWVudC5wdXNoKGl0ZW0pO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKFwiVW5leHBlY3RlZCB0ZW1wbGF0ZSBjb250ZW50XCIpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHZhciByZXN1bHQgPSB7XG4gIFx0XHR2OiBURU1QTEFURV9WRVJTSU9OLFxuICBcdFx0dDogZnJhZ21lbnRcbiAgXHR9O1xuXG4gIFx0aWYgKGhhc1BhcnRpYWxzKSB7XG4gIFx0XHRyZXN1bHQucCA9IHBhcnRpYWxzO1xuICBcdH1cblxuICBcdHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgX3BhcnNlID0gcGFyc2U7XG5cbiAgdmFyIFNUQU5EQVJEX1JFQURFUlMgPSBbbXVzdGFjaGVfcmVhZFBhcnRpYWwsIG11c3RhY2hlX3JlYWRVbmVzY2FwZWQsIG11c3RhY2hlX3JlYWRTZWN0aW9uLCBtdXN0YWNoZV9yZWFkWWllbGRlciwgbXVzdGFjaGVfcmVhZEludGVycG9sYXRvciwgcmVhZE11c3RhY2hlQ29tbWVudF07XG4gIHZhciBUUklQTEVfUkVBREVSUyA9IFttdXN0YWNoZV9yZWFkVHJpcGxlXTtcbiAgdmFyIFNUQVRJQ19SRUFERVJTID0gW211c3RhY2hlX3JlYWRVbmVzY2FwZWQsIG11c3RhY2hlX3JlYWRTZWN0aW9uLCBtdXN0YWNoZV9yZWFkSW50ZXJwb2xhdG9yXTsgLy8gVE9ETyBkb2VzIGl0IG1ha2Ugc2Vuc2UgdG8gaGF2ZSBhIHN0YXRpYyBzZWN0aW9uP1xuXG4gIHZhciBTdGFuZGFyZFBhcnNlciA9IHVuZGVmaW5lZDtcbiAgZnVuY3Rpb24gcGFyc2UodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgXHRyZXR1cm4gbmV3IFN0YW5kYXJkUGFyc2VyKHRlbXBsYXRlLCBvcHRpb25zIHx8IHt9KS5yZXN1bHQ7XG4gIH1cblxuICB2YXIgUkVBREVSUyA9IFtjb252ZXJ0ZXJzX3JlYWRNdXN0YWNoZSwgY29udmVydGVyc19yZWFkSHRtbENvbW1lbnQsIGNvbnZlcnRlcnNfcmVhZEVsZW1lbnQsIGNvbnZlcnRlcnNfcmVhZFRleHRdO1xuICB2YXIgUEFSVElBTF9SRUFERVJTID0gW2NvbnZlcnRlcnNfcmVhZFBhcnRpYWxEZWZpbml0aW9uQ29tbWVudCwgY29udmVydGVyc19yZWFkUGFydGlhbERlZmluaXRpb25TZWN0aW9uXTtcblxuICBTdGFuZGFyZFBhcnNlciA9IHBhcnNlX1BhcnNlci5leHRlbmQoe1xuICBcdGluaXQ6IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcbiAgXHRcdHZhciB0cmlwbGVEZWxpbWl0ZXJzID0gb3B0aW9ucy50cmlwbGVEZWxpbWl0ZXJzIHx8IFtcInt7e1wiLCBcIn19fVwiXSxcbiAgXHRcdCAgICBzdGF0aWNEZWxpbWl0ZXJzID0gb3B0aW9ucy5zdGF0aWNEZWxpbWl0ZXJzIHx8IFtcIltbXCIsIFwiXV1cIl0sXG4gIFx0XHQgICAgc3RhdGljVHJpcGxlRGVsaW1pdGVycyA9IG9wdGlvbnMuc3RhdGljVHJpcGxlRGVsaW1pdGVycyB8fCBbXCJbW1tcIiwgXCJdXV1cIl07XG5cbiAgXHRcdHRoaXMuc3RhbmRhcmREZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzIHx8IFtcInt7XCIsIFwifX1cIl07XG5cbiAgXHRcdHRoaXMudGFncyA9IFt7IGlzU3RhdGljOiBmYWxzZSwgaXNUcmlwbGU6IGZhbHNlLCBvcGVuOiB0aGlzLnN0YW5kYXJkRGVsaW1pdGVyc1swXSwgY2xvc2U6IHRoaXMuc3RhbmRhcmREZWxpbWl0ZXJzWzFdLCByZWFkZXJzOiBTVEFOREFSRF9SRUFERVJTIH0sIHsgaXNTdGF0aWM6IGZhbHNlLCBpc1RyaXBsZTogdHJ1ZSwgb3BlbjogdHJpcGxlRGVsaW1pdGVyc1swXSwgY2xvc2U6IHRyaXBsZURlbGltaXRlcnNbMV0sIHJlYWRlcnM6IFRSSVBMRV9SRUFERVJTIH0sIHsgaXNTdGF0aWM6IHRydWUsIGlzVHJpcGxlOiBmYWxzZSwgb3Blbjogc3RhdGljRGVsaW1pdGVyc1swXSwgY2xvc2U6IHN0YXRpY0RlbGltaXRlcnNbMV0sIHJlYWRlcnM6IFNUQVRJQ19SRUFERVJTIH0sIHsgaXNTdGF0aWM6IHRydWUsIGlzVHJpcGxlOiB0cnVlLCBvcGVuOiBzdGF0aWNUcmlwbGVEZWxpbWl0ZXJzWzBdLCBjbG9zZTogc3RhdGljVHJpcGxlRGVsaW1pdGVyc1sxXSwgcmVhZGVyczogVFJJUExFX1JFQURFUlMgfV07XG5cbiAgXHRcdHRoaXMuc29ydE11c3RhY2hlVGFncygpO1xuXG4gIFx0XHR0aGlzLnNlY3Rpb25EZXB0aCA9IDA7XG4gIFx0XHR0aGlzLmVsZW1lbnRTdGFjayA9IFtdO1xuXG4gIFx0XHR0aGlzLmludGVycG9sYXRlID0ge1xuICBcdFx0XHRzY3JpcHQ6ICFvcHRpb25zLmludGVycG9sYXRlIHx8IG9wdGlvbnMuaW50ZXJwb2xhdGUuc2NyaXB0ICE9PSBmYWxzZSxcbiAgXHRcdFx0c3R5bGU6ICFvcHRpb25zLmludGVycG9sYXRlIHx8IG9wdGlvbnMuaW50ZXJwb2xhdGUuc3R5bGUgIT09IGZhbHNlXG4gIFx0XHR9O1xuXG4gIFx0XHRpZiAob3B0aW9ucy5zYW5pdGl6ZSA9PT0gdHJ1ZSkge1xuICBcdFx0XHRvcHRpb25zLnNhbml0aXplID0ge1xuICBcdFx0XHRcdC8vIGJsYWNrbGlzdCBmcm9tIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWNhamEvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9jYWphL2xhbmcvaHRtbC9odG1sNC1lbGVtZW50cy13aGl0ZWxpc3QuanNvblxuICBcdFx0XHRcdGVsZW1lbnRzOiBcImFwcGxldCBiYXNlIGJhc2Vmb250IGJvZHkgZnJhbWUgZnJhbWVzZXQgaGVhZCBodG1sIGlzaW5kZXggbGluayBtZXRhIG5vZnJhbWVzIG5vc2NyaXB0IG9iamVjdCBwYXJhbSBzY3JpcHQgc3R5bGUgdGl0bGVcIi5zcGxpdChcIiBcIiksXG4gIFx0XHRcdFx0ZXZlbnRBdHRyaWJ1dGVzOiB0cnVlXG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuc3RyaXBDb21tZW50cyA9IG9wdGlvbnMuc3RyaXBDb21tZW50cyAhPT0gZmFsc2U7XG4gIFx0XHR0aGlzLnByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlO1xuICBcdFx0dGhpcy5zYW5pdGl6ZUVsZW1lbnRzID0gb3B0aW9ucy5zYW5pdGl6ZSAmJiBvcHRpb25zLnNhbml0aXplLmVsZW1lbnRzO1xuICBcdFx0dGhpcy5zYW5pdGl6ZUV2ZW50QXR0cmlidXRlcyA9IG9wdGlvbnMuc2FuaXRpemUgJiYgb3B0aW9ucy5zYW5pdGl6ZS5ldmVudEF0dHJpYnV0ZXM7XG4gIFx0XHR0aGlzLmluY2x1ZGVMaW5lUG9zaXRpb25zID0gb3B0aW9ucy5pbmNsdWRlTGluZVBvc2l0aW9ucztcbiAgXHR9LFxuXG4gIFx0cG9zdFByb2Nlc3M6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGVtcHR5IHN0cmluZ1xuICBcdFx0aWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gIFx0XHRcdHJldHVybiB7IHQ6IFtdLCB2OiBURU1QTEFURV9WRVJTSU9OIH07XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLnNlY3Rpb25EZXB0aCA+IDApIHtcbiAgXHRcdFx0dGhpcy5lcnJvcihcIkEgc2VjdGlvbiB3YXMgbGVmdCBvcGVuXCIpO1xuICBcdFx0fVxuXG4gIFx0XHR1dGlsc19jbGVhbnVwKHJlc3VsdFswXS50LCB0aGlzLnN0cmlwQ29tbWVudHMsIHRoaXMucHJlc2VydmVXaGl0ZXNwYWNlLCAhdGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2UsICF0aGlzLnByZXNlcnZlV2hpdGVzcGFjZSk7XG5cbiAgXHRcdHJldHVybiByZXN1bHRbMF07XG4gIFx0fSxcblxuICBcdGNvbnZlcnRlcnM6IFtjb252ZXJ0ZXJzX3JlYWRUZW1wbGF0ZV0sXG5cbiAgXHRzb3J0TXVzdGFjaGVUYWdzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBTb3J0IGluIG9yZGVyIG9mIGRlc2NlbmRpbmcgb3BlbmluZyBkZWxpbWl0ZXIgbGVuZ3RoIChsb25nZXIgZmlyc3QpLFxuICBcdFx0Ly8gdG8gcHJvdGVjdCBhZ2FpbnN0IG9wZW5pbmcgZGVsaW1pdGVycyBiZWluZyBzdWJzdHJpbmdzIG9mIGVhY2ggb3RoZXJcbiAgXHRcdHRoaXMudGFncy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gIFx0XHRcdHJldHVybiBiLm9wZW4ubGVuZ3RoIC0gYS5vcGVuLmxlbmd0aDtcbiAgXHRcdH0pO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIHBhcnNlT3B0aW9ucyA9IFtcInByZXNlcnZlV2hpdGVzcGFjZVwiLCBcInNhbml0aXplXCIsIFwic3RyaXBDb21tZW50c1wiLCBcImRlbGltaXRlcnNcIiwgXCJ0cmlwbGVEZWxpbWl0ZXJzXCIsIFwiaW50ZXJwb2xhdGVcIl07XG5cbiAgdmFyIHBhcnNlciA9IHtcbiAgXHRwYXJzZTogZG9QYXJzZSxcbiAgXHRmcm9tSWQ6IGZyb21JZCxcbiAgXHRpc0hhc2hlZElkOiBpc0hhc2hlZElkLFxuICBcdGlzUGFyc2VkOiBpc1BhcnNlZCxcbiAgXHRnZXRQYXJzZU9wdGlvbnM6IGdldFBhcnNlT3B0aW9ucyxcbiAgXHRjcmVhdGVIZWxwZXI6IHRlbXBsYXRlX3BhcnNlcl9fY3JlYXRlSGVscGVyXG4gIH07XG5cbiAgZnVuY3Rpb24gdGVtcGxhdGVfcGFyc2VyX19jcmVhdGVIZWxwZXIocGFyc2VPcHRpb25zKSB7XG4gIFx0dmFyIGhlbHBlciA9IGNyZWF0ZShwYXJzZXIpO1xuICBcdGhlbHBlci5wYXJzZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgb3B0aW9ucykge1xuICBcdFx0cmV0dXJuIGRvUGFyc2UodGVtcGxhdGUsIG9wdGlvbnMgfHwgcGFyc2VPcHRpb25zKTtcbiAgXHR9O1xuICBcdHJldHVybiBoZWxwZXI7XG4gIH1cblxuICBmdW5jdGlvbiBkb1BhcnNlKHRlbXBsYXRlLCBwYXJzZU9wdGlvbnMpIHtcbiAgXHRpZiAoIV9wYXJzZSkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBSYWN0aXZlLnBhcnNlIC0gY2Fubm90IHBhcnNlIHRlbXBsYXRlLiBFaXRoZXIgcHJlcGFyc2Ugb3IgdXNlIHRoZSB2ZXJzaW9uIHRoYXQgaW5jbHVkZXMgdGhlIHBhcnNlclwiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gX3BhcnNlKHRlbXBsYXRlLCBwYXJzZU9wdGlvbnMgfHwgdGhpcy5vcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21JZChpZCwgb3B0aW9ucykge1xuICBcdHZhciB0ZW1wbGF0ZTtcblxuICBcdGlmICghaXNDbGllbnQpIHtcbiAgXHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9UaHJvdykge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmV0cmlldmUgdGVtcGxhdGUgI1wiICsgaWQgKyBcIiBhcyBSYWN0aXZlIGlzIG5vdCBydW5uaW5nIGluIGEgYnJvd3Nlci5cIik7XG4gIFx0fVxuXG4gIFx0aWYgKGlzSGFzaGVkSWQoaWQpKSB7XG4gIFx0XHRpZCA9IGlkLnN1YnN0cmluZygxKTtcbiAgXHR9XG5cbiAgXHRpZiAoISh0ZW1wbGF0ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSkpIHtcbiAgXHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9UaHJvdykge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCB0ZW1wbGF0ZSBlbGVtZW50IHdpdGggaWQgI1wiICsgaWQpO1xuICBcdH1cblxuICBcdGlmICh0ZW1wbGF0ZS50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09IFwiU0NSSVBUXCIpIHtcbiAgXHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9UaHJvdykge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUZW1wbGF0ZSBlbGVtZW50IHdpdGggaWQgI1wiICsgaWQgKyBcIiwgbXVzdCBiZSBhIDxzY3JpcHQ+IGVsZW1lbnRcIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRlbXBsYXRlLnRleHRDb250ZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNIYXNoZWRJZChpZCkge1xuICBcdHJldHVybiBpZCAmJiBpZC5jaGFyQXQoMCkgPT09IFwiI1wiOyAvLyBUT0RPIHdoYXQgYWJvdXQgYGlkWzBdYCwgZG9lcyB0aGF0IHdvcmsgZXZlcnl3aGVyZT9cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGFyc2VkKHRlbXBsYXRlKSB7XG4gIFx0cmV0dXJuICEodHlwZW9mIHRlbXBsYXRlID09PSBcInN0cmluZ1wiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhcnNlT3B0aW9ucyhyYWN0aXZlKSB7XG4gIFx0Ly8gQ291bGQgYmUgUmFjdGl2ZSBvciBhIENvbXBvbmVudFxuICBcdGlmIChyYWN0aXZlLmRlZmF1bHRzKSB7XG4gIFx0XHRyYWN0aXZlID0gcmFjdGl2ZS5kZWZhdWx0cztcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcGFyc2VPcHRpb25zLnJlZHVjZShmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgXHRcdHZhbFtrZXldID0gcmFjdGl2ZVtrZXldO1xuICBcdFx0cmV0dXJuIHZhbDtcbiAgXHR9LCB7fSk7XG4gIH1cblxuICB2YXIgdGVtcGxhdGVfcGFyc2VyID0gcGFyc2VyO1xuXG4gIHZhciB0ZW1wbGF0ZUNvbmZpZ3VyYXRvciA9IHtcbiAgXHRuYW1lOiBcInRlbXBsYXRlXCIsXG5cbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChQYXJlbnQsIHByb3RvLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgdGVtcGxhdGU7XG5cbiAgXHRcdC8vIG9ubHkgYXNzaWduIGlmIGV4aXN0c1xuICBcdFx0aWYgKFwidGVtcGxhdGVcIiBpbiBvcHRpb25zKSB7XG4gIFx0XHRcdHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblxuICBcdFx0XHRpZiAodHlwZW9mIHRlbXBsYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHRwcm90by50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHByb3RvLnRlbXBsYXRlID0gcGFyc2VJZlN0cmluZyh0ZW1wbGF0ZSwgcHJvdG8pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uIGluaXQoUGFyZW50LCByYWN0aXZlLCBvcHRpb25zKSB7XG4gIFx0XHR2YXIgdGVtcGxhdGUsIGZuO1xuXG4gIFx0XHQvLyBUT0RPIGJlY2F1c2Ugb2YgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgd2UgbWlnaHQganVzdCBiZSBhYmxlIHRvIHVzZVxuICBcdFx0Ly8gcmFjdGl2ZS50ZW1wbGF0ZSwgYW5kIG5vdCBib3RoZXIgcGFzc2luZyB0aHJvdWdoIHRoZSBQYXJlbnQgb2JqZWN0LlxuICBcdFx0Ly8gQXQgcHJlc2VudCB0aGF0IGJyZWFrcyB0aGUgdGVzdCBtb2NrcycgZXhwZWN0YXRpb25zXG4gIFx0XHR0ZW1wbGF0ZSA9IFwidGVtcGxhdGVcIiBpbiBvcHRpb25zID8gb3B0aW9ucy50ZW1wbGF0ZSA6IFBhcmVudC5wcm90b3R5cGUudGVtcGxhdGU7XG5cbiAgXHRcdGlmICh0eXBlb2YgdGVtcGxhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRmbiA9IHRlbXBsYXRlO1xuICBcdFx0XHR0ZW1wbGF0ZSA9IGdldER5bmFtaWNUZW1wbGF0ZShyYWN0aXZlLCBmbik7XG5cbiAgXHRcdFx0cmFjdGl2ZS5fY29uZmlnLnRlbXBsYXRlID0ge1xuICBcdFx0XHRcdGZuOiBmbixcbiAgXHRcdFx0XHRyZXN1bHQ6IHRlbXBsYXRlXG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHRlbXBsYXRlID0gcGFyc2VJZlN0cmluZyh0ZW1wbGF0ZSwgcmFjdGl2ZSk7XG5cbiAgXHRcdC8vIFRPRE8gdGhlIG5hbWluZyBvZiB0aGlzIGlzIGNvbmZ1c2luZyAtIHJhY3RpdmUudGVtcGxhdGUgcmVmZXJzIHRvIFsuLi5dLFxuICBcdFx0Ly8gYnV0IENvbXBvbmVudC5wcm90b3R5cGUudGVtcGxhdGUgcmVmZXJzIHRvIHt2OjEsdDpbXSxwOltdfS4uLlxuICBcdFx0Ly8gaXQncyB1bm5lY2Vzc2FyeSwgYmVjYXVzZSB0aGUgZGV2ZWxvcGVyIG5ldmVyIG5lZWRzIHRvIGFjY2Vzc1xuICBcdFx0Ly8gcmFjdGl2ZS50ZW1wbGF0ZVxuICBcdFx0cmFjdGl2ZS50ZW1wbGF0ZSA9IHRlbXBsYXRlLnQ7XG5cbiAgXHRcdGlmICh0ZW1wbGF0ZS5wKSB7XG4gIFx0XHRcdGV4dGVuZFBhcnRpYWxzKHJhY3RpdmUucGFydGlhbHMsIHRlbXBsYXRlLnApO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZXNldDogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdHZhciByZXN1bHQgPSByZXNldFZhbHVlKHJhY3RpdmUpLFxuICBcdFx0ICAgIHBhcnNlZDtcblxuICBcdFx0aWYgKHJlc3VsdCkge1xuICBcdFx0XHRwYXJzZWQgPSBwYXJzZUlmU3RyaW5nKHJlc3VsdCwgcmFjdGl2ZSk7XG5cbiAgXHRcdFx0cmFjdGl2ZS50ZW1wbGF0ZSA9IHBhcnNlZC50O1xuICBcdFx0XHRleHRlbmRQYXJ0aWFscyhyYWN0aXZlLnBhcnRpYWxzLCBwYXJzZWQucCwgdHJ1ZSk7XG5cbiAgXHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIHJlc2V0VmFsdWUocmFjdGl2ZSkge1xuICBcdHZhciBpbml0aWFsID0gcmFjdGl2ZS5fY29uZmlnLnRlbXBsYXRlLFxuICBcdCAgICByZXN1bHQ7XG5cbiAgXHQvLyBJZiB0aGlzIGlzbid0IGEgZHluYW1pYyB0ZW1wbGF0ZSwgdGhlcmUncyBub3RoaW5nIHRvIGRvXG4gIFx0aWYgKCFpbml0aWFsIHx8ICFpbml0aWFsLmZuKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0cmVzdWx0ID0gZ2V0RHluYW1pY1RlbXBsYXRlKHJhY3RpdmUsIGluaXRpYWwuZm4pO1xuXG4gIFx0Ly8gVE9ETyBkZWVwIGVxdWFsaXR5IGNoZWNrIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmUtcmVuZGVyaW5nXG4gIFx0Ly8gaW4gdGhlIGNhc2Ugb2YgYWxyZWFkeS1wYXJzZWQgdGVtcGxhdGVzXG4gIFx0aWYgKHJlc3VsdCAhPT0gaW5pdGlhbC5yZXN1bHQpIHtcbiAgXHRcdGluaXRpYWwucmVzdWx0ID0gcmVzdWx0O1xuICBcdFx0cmVzdWx0ID0gcGFyc2VJZlN0cmluZyhyZXN1bHQsIHJhY3RpdmUpO1xuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXREeW5hbWljVGVtcGxhdGUocmFjdGl2ZSwgZm4pIHtcbiAgXHR2YXIgaGVscGVyID0gdGVtcGxhdGVfdGVtcGxhdGVfX2NyZWF0ZUhlbHBlcih0ZW1wbGF0ZV9wYXJzZXIuZ2V0UGFyc2VPcHRpb25zKHJhY3RpdmUpKTtcbiAgXHRyZXR1cm4gZm4uY2FsbChyYWN0aXZlLCBoZWxwZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGVtcGxhdGVfdGVtcGxhdGVfX2NyZWF0ZUhlbHBlcihwYXJzZU9wdGlvbnMpIHtcbiAgXHR2YXIgaGVscGVyID0gY3JlYXRlKHRlbXBsYXRlX3BhcnNlcik7XG4gIFx0aGVscGVyLnBhcnNlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gIFx0XHRyZXR1cm4gdGVtcGxhdGVfcGFyc2VyLnBhcnNlKHRlbXBsYXRlLCBvcHRpb25zIHx8IHBhcnNlT3B0aW9ucyk7XG4gIFx0fTtcbiAgXHRyZXR1cm4gaGVscGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VJZlN0cmluZyh0ZW1wbGF0ZSwgcmFjdGl2ZSkge1xuICBcdGlmICh0eXBlb2YgdGVtcGxhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdC8vIElEIG9mIGFuIGVsZW1lbnQgY29udGFpbmluZyB0aGUgdGVtcGxhdGU/XG4gIFx0XHRpZiAodGVtcGxhdGVbMF0gPT09IFwiI1wiKSB7XG4gIFx0XHRcdHRlbXBsYXRlID0gdGVtcGxhdGVfcGFyc2VyLmZyb21JZCh0ZW1wbGF0ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRlbXBsYXRlID0gX3BhcnNlKHRlbXBsYXRlLCB0ZW1wbGF0ZV9wYXJzZXIuZ2V0UGFyc2VPcHRpb25zKHJhY3RpdmUpKTtcbiAgXHR9XG5cbiAgXHQvLyBDaGVjayB0aGUgcGFyc2VkIHRlbXBsYXRlIGhhcyBhIHZlcnNpb24gYXQgYWxsXG4gIFx0ZWxzZSBpZiAodHlwZW9mIHRlbXBsYXRlLnYgIT09IFwibnVtYmVyXCIpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIlRoZSB0ZW1wbGF0ZSBwYXJzZXIgd2FzIHBhc3NlZCBhIG5vbi1zdHJpbmcgdGVtcGxhdGUsIGJ1dCB0aGUgdGVtcGxhdGUgZG9lc24ndCBoYXZlIGEgdmVyc2lvbi4gIE1ha2Ugc3VyZSB5b3UncmUgcGFzc2luZyBpbiB0aGUgdGVtcGxhdGUgeW91IHRoaW5rIHlvdSBhcmUuXCIpO1xuICBcdH1cblxuICBcdC8vIENoZWNrIHdlJ3JlIHVzaW5nIHRoZSBjb3JyZWN0IHZlcnNpb25cbiAgXHRlbHNlIGlmICh0ZW1wbGF0ZS52ICE9PSBURU1QTEFURV9WRVJTSU9OKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIHRlbXBsYXRlIHZlcnNpb24gKGV4cGVjdGVkIFwiICsgVEVNUExBVEVfVkVSU0lPTiArIFwiLCBnb3QgXCIgKyB0ZW1wbGF0ZS52ICsgXCIpIFBsZWFzZSBlbnN1cmUgeW91IGFyZSB1c2luZyB0aGUgbGF0ZXN0IHZlcnNpb24gb2YgUmFjdGl2ZS5qcyBpbiB5b3VyIGJ1aWxkIHByb2Nlc3MgYXMgd2VsbCBhcyBpbiB5b3VyIGFwcFwiKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGVtcGxhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmRQYXJ0aWFscyhleGlzdGluZ1BhcnRpYWxzLCBuZXdQYXJ0aWFscywgb3ZlcndyaXRlKSB7XG4gIFx0aWYgKCFuZXdQYXJ0aWFscykgcmV0dXJuO1xuXG4gIFx0Ly8gVE9ETyB0aGVyZSdzIGFuIGFtYmlndWl0eSBoZXJlIC0gd2UgbmVlZCB0byBvdmVyd3JpdGUgaW4gdGhlIGByZXNldCgpYFxuICBcdC8vIGNhc2UsIGJ1dCBub3QgaW5pdGlhbGx5Li4uXG5cbiAgXHRmb3IgKHZhciBrZXkgaW4gbmV3UGFydGlhbHMpIHtcbiAgXHRcdGlmIChvdmVyd3JpdGUgfHwgIWV4aXN0aW5nUGFydGlhbHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBcdFx0XHRleGlzdGluZ1BhcnRpYWxzW2tleV0gPSBuZXdQYXJ0aWFsc1trZXldO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciB0ZW1wbGF0ZV90ZW1wbGF0ZSA9IHRlbXBsYXRlQ29uZmlndXJhdG9yO1xuXG4gIHZhciBjb25maWdfcmVnaXN0cmllc19fcmVnaXN0cnlOYW1lcywgUmVnaXN0cnksIHJlZ2lzdHJpZXM7XG5cbiAgY29uZmlnX3JlZ2lzdHJpZXNfX3JlZ2lzdHJ5TmFtZXMgPSBbXCJhZGFwdG9yc1wiLCBcImNvbXBvbmVudHNcIiwgXCJjb21wdXRlZFwiLCBcImRlY29yYXRvcnNcIiwgXCJlYXNpbmdcIiwgXCJldmVudHNcIiwgXCJpbnRlcnBvbGF0b3JzXCIsIFwicGFydGlhbHNcIiwgXCJ0cmFuc2l0aW9uc1wiXTtcblxuICBSZWdpc3RyeSA9IGZ1bmN0aW9uIChuYW1lLCB1c2VEZWZhdWx0cykge1xuICBcdHRoaXMubmFtZSA9IG5hbWU7XG4gIFx0dGhpcy51c2VEZWZhdWx0cyA9IHVzZURlZmF1bHRzO1xuICB9O1xuXG4gIFJlZ2lzdHJ5LnByb3RvdHlwZSA9IHtcbiAgXHRjb25zdHJ1Y3RvcjogUmVnaXN0cnksXG5cbiAgXHRleHRlbmQ6IGZ1bmN0aW9uIChQYXJlbnQsIHByb3RvLCBvcHRpb25zKSB7XG4gIFx0XHR0aGlzLmNvbmZpZ3VyZSh0aGlzLnVzZURlZmF1bHRzID8gUGFyZW50LmRlZmF1bHRzIDogUGFyZW50LCB0aGlzLnVzZURlZmF1bHRzID8gcHJvdG8gOiBwcm90by5jb25zdHJ1Y3Rvciwgb3B0aW9ucyk7XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIFx0Y29uZmlndXJlOiBmdW5jdGlvbiAoUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgXHRcdHZhciBuYW1lID0gdGhpcy5uYW1lLFxuICBcdFx0ICAgIG9wdGlvbiA9IG9wdGlvbnNbbmFtZV0sXG4gIFx0XHQgICAgcmVnaXN0cnk7XG5cbiAgXHRcdHJlZ2lzdHJ5ID0gY3JlYXRlKFBhcmVudFtuYW1lXSk7XG5cbiAgXHRcdGZvciAodmFyIGtleSBpbiBvcHRpb24pIHtcbiAgXHRcdFx0cmVnaXN0cnlba2V5XSA9IG9wdGlvbltrZXldO1xuICBcdFx0fVxuXG4gIFx0XHR0YXJnZXRbbmFtZV0gPSByZWdpc3RyeTtcbiAgXHR9LFxuXG4gIFx0cmVzZXQ6IGZ1bmN0aW9uIChyYWN0aXZlKSB7XG4gIFx0XHR2YXIgcmVnaXN0cnkgPSByYWN0aXZlW3RoaXMubmFtZV07XG4gIFx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICBcdFx0T2JqZWN0LmtleXMocmVnaXN0cnkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBcdFx0XHR2YXIgaXRlbSA9IHJlZ2lzdHJ5W2tleV07XG4gIFx0XHRcdGlmIChpdGVtLl9mbikge1xuICBcdFx0XHRcdGlmIChpdGVtLl9mbi5pc093bmVyKSB7XG4gIFx0XHRcdFx0XHRyZWdpc3RyeVtrZXldID0gaXRlbS5fZm47XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdGRlbGV0ZSByZWdpc3RyeVtrZXldO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0XHRyZXR1cm4gY2hhbmdlZDtcbiAgXHR9XG4gIH07XG5cbiAgcmVnaXN0cmllcyA9IGNvbmZpZ19yZWdpc3RyaWVzX19yZWdpc3RyeU5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICBcdHJldHVybiBuZXcgUmVnaXN0cnkobmFtZSwgbmFtZSA9PT0gXCJjb21wdXRlZFwiKTtcbiAgfSk7XG5cbiAgdmFyIGNvbmZpZ19yZWdpc3RyaWVzID0gcmVnaXN0cmllcztcblxuICAvKnRoaXMuY29uZmlndXJlKFxuICBcdHRoaXMudXNlRGVmYXVsdHMgPyBQYXJlbnQuZGVmYXVsdHMgOiBQYXJlbnQsXG4gIFx0cmFjdGl2ZSxcbiAgXHRvcHRpb25zICk7Ki9cblxuICB2YXIgd3JhcFByb3RvdHlwZSA9IHdyYXA7XG5cbiAgZnVuY3Rpb24gd3JhcChwYXJlbnQsIG5hbWUsIG1ldGhvZCkge1xuICBcdGlmICghL19zdXBlci8udGVzdChtZXRob2QpKSB7XG4gIFx0XHRyZXR1cm4gbWV0aG9kO1xuICBcdH1cblxuICBcdHZhciB3cmFwcGVyID0gZnVuY3Rpb24gd3JhcFN1cGVyKCkge1xuICBcdFx0dmFyIHN1cGVyTWV0aG9kID0gZ2V0U3VwZXJNZXRob2Qod3JhcHBlci5fcGFyZW50LCBuYW1lKSxcbiAgXHRcdCAgICBoYXNTdXBlciA9IChcIl9zdXBlclwiIGluIHRoaXMpLFxuICBcdFx0ICAgIG9sZFN1cGVyID0gdGhpcy5fc3VwZXIsXG4gIFx0XHQgICAgcmVzdWx0O1xuXG4gIFx0XHR0aGlzLl9zdXBlciA9IHN1cGVyTWV0aG9kO1xuXG4gIFx0XHRyZXN1bHQgPSBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBcdFx0aWYgKGhhc1N1cGVyKSB7XG4gIFx0XHRcdHRoaXMuX3N1cGVyID0gb2xkU3VwZXI7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRkZWxldGUgdGhpcy5fc3VwZXI7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fTtcblxuICBcdHdyYXBwZXIuX3BhcmVudCA9IHBhcmVudDtcbiAgXHR3cmFwcGVyLl9tZXRob2QgPSBtZXRob2Q7XG5cbiAgXHRyZXR1cm4gd3JhcHBlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFN1cGVyTWV0aG9kKHBhcmVudCwgbmFtZSkge1xuICBcdHZhciB2YWx1ZSwgbWV0aG9kO1xuXG4gIFx0aWYgKG5hbWUgaW4gcGFyZW50KSB7XG4gIFx0XHR2YWx1ZSA9IHBhcmVudFtuYW1lXTtcblxuICBcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdG1ldGhvZCA9IHZhbHVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bWV0aG9kID0gZnVuY3Rpb24gcmV0dXJuVmFsdWUoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuICBcdFx0XHR9O1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRtZXRob2QgPSBub29wO1xuICBcdH1cblxuICBcdHJldHVybiBtZXRob2Q7XG4gIH1cblxuICB2YXIgY29uZmlnX2RlcHJlY2F0ZSA9IGRlcHJlY2F0ZTtcbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShkZXByZWNhdGVkLCBjb3JyZWN0LCBpc0Vycm9yKSB7XG4gIFx0cmV0dXJuIFwib3B0aW9ucy5cIiArIGRlcHJlY2F0ZWQgKyBcIiBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBvcHRpb25zLlwiICsgY29ycmVjdCArIFwiLlwiICsgKGlzRXJyb3IgPyBcIiBZb3UgY2Fubm90IHNwZWNpZnkgYm90aCBvcHRpb25zLCBwbGVhc2UgdXNlIG9wdGlvbnMuXCIgKyBjb3JyZWN0ICsgXCIuXCIgOiBcIlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZU9wdGlvbihvcHRpb25zLCBkZXByZWNhdGVkT3B0aW9uLCBjb3JyZWN0KSB7XG4gIFx0aWYgKGRlcHJlY2F0ZWRPcHRpb24gaW4gb3B0aW9ucykge1xuICBcdFx0aWYgKCEoY29ycmVjdCBpbiBvcHRpb25zKSkge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyhnZXRNZXNzYWdlKGRlcHJlY2F0ZWRPcHRpb24sIGNvcnJlY3QpKTtcbiAgXHRcdFx0b3B0aW9uc1tjb3JyZWN0XSA9IG9wdGlvbnNbZGVwcmVjYXRlZE9wdGlvbl07XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoZ2V0TWVzc2FnZShkZXByZWNhdGVkT3B0aW9uLCBjb3JyZWN0LCB0cnVlKSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZShvcHRpb25zKSB7XG4gIFx0ZGVwcmVjYXRlT3B0aW9uKG9wdGlvbnMsIFwiYmVmb3JlSW5pdFwiLCBcIm9uY29uc3RydWN0XCIpO1xuICBcdGRlcHJlY2F0ZU9wdGlvbihvcHRpb25zLCBcImluaXRcIiwgXCJvbnJlbmRlclwiKTtcbiAgXHRkZXByZWNhdGVPcHRpb24ob3B0aW9ucywgXCJjb21wbGV0ZVwiLCBcIm9uY29tcGxldGVcIik7XG4gIFx0ZGVwcmVjYXRlT3B0aW9uKG9wdGlvbnMsIFwiZXZlbnREZWZpbml0aW9uc1wiLCBcImV2ZW50c1wiKTtcblxuICBcdC8vIFVzaW5nIGV4dGVuZCB3aXRoIENvbXBvbmVudCBpbnN0ZWFkIG9mIG9wdGlvbnMsXG4gIFx0Ly8gbGlrZSBIdW1hbi5leHRlbmQoIFNwaWRlciApIG1lYW5zIGFkYXB0b3JzIGFzIGEgcmVnaXN0cnlcbiAgXHQvLyBnZXRzIGNvcGllZCB0byBvcHRpb25zLiBTbyB3ZSBoYXZlIHRvIGNoZWNrIGlmIGFjdHVhbGx5IGFuIGFycmF5XG4gIFx0aWYgKGlzQXJyYXkob3B0aW9ucy5hZGFwdG9ycykpIHtcbiAgXHRcdGRlcHJlY2F0ZU9wdGlvbihvcHRpb25zLCBcImFkYXB0b3JzXCIsIFwiYWRhcHRcIik7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGNvbmZpZywgb3JkZXIsIGRlZmF1bHRLZXlzLCBjdXN0b20sIGlzQmxhY2tsaXN0ZWQsIGlzU3RhbmRhcmRLZXk7XG5cbiAgY3VzdG9tID0ge1xuICBcdGFkYXB0OiBjdXN0b21fYWRhcHQsXG4gIFx0Y3NzOiBjc3NfY3NzLFxuICBcdGRhdGE6IGN1c3RvbV9kYXRhLFxuICBcdHRlbXBsYXRlOiB0ZW1wbGF0ZV90ZW1wbGF0ZVxuICB9O1xuXG4gIGRlZmF1bHRLZXlzID0gT2JqZWN0LmtleXMoY29uZmlnX2RlZmF1bHRzKTtcblxuICBpc1N0YW5kYXJkS2V5ID0gbWFrZU9iaihkZWZhdWx0S2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICBcdHJldHVybiAhY3VzdG9tW2tleV07XG4gIH0pKTtcblxuICAvLyBibGFja2xpc3RlZCBrZXlzIHRoYXQgd2UgZG9uJ3QgZG91YmxlIGV4dGVuZFxuICBpc0JsYWNrbGlzdGVkID0gbWFrZU9iaihkZWZhdWx0S2V5cy5jb25jYXQoY29uZmlnX3JlZ2lzdHJpZXMubWFwKGZ1bmN0aW9uIChyKSB7XG4gIFx0cmV0dXJuIHIubmFtZTtcbiAgfSkpKTtcblxuICBvcmRlciA9IFtdLmNvbmNhdChkZWZhdWx0S2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICBcdHJldHVybiAhY29uZmlnX3JlZ2lzdHJpZXNba2V5XSAmJiAhY3VzdG9tW2tleV07XG4gIH0pLCBjb25maWdfcmVnaXN0cmllcywgY3VzdG9tLmRhdGEsIGN1c3RvbS50ZW1wbGF0ZSwgY3VzdG9tLmNzcyk7XG5cbiAgY29uZmlnID0ge1xuICBcdGV4dGVuZDogZnVuY3Rpb24gKFBhcmVudCwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgXHRcdHJldHVybiBjb25maWd1cmUoXCJleHRlbmRcIiwgUGFyZW50LCBwcm90bywgb3B0aW9ucyk7XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uIChQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMpIHtcbiAgXHRcdHJldHVybiBjb25maWd1cmUoXCJpbml0XCIsIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyk7XG4gIFx0fSxcblxuICBcdHJlc2V0OiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuICBcdFx0cmV0dXJuIG9yZGVyLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICBcdFx0XHRyZXR1cm4gYy5yZXNldCAmJiBjLnJlc2V0KHJhY3RpdmUpO1xuICBcdFx0fSkubWFwKGZ1bmN0aW9uIChjKSB7XG4gIFx0XHRcdHJldHVybiBjLm5hbWU7XG4gIFx0XHR9KTtcbiAgXHR9LFxuXG4gIFx0Ly8gdGhpcyBkZWZpbmVzIHRoZSBvcmRlci4gVE9ETyB0aGlzIGlzbid0IHVzZWQgYW55d2hlcmUgaW4gdGhlIGNvZGViYXNlLFxuICBcdC8vIG9ubHkgaW4gdGhlIHRlc3Qgc3VpdGUgLSBzaG91bGQgZ2V0IHJpZCBvZiBpdFxuICBcdG9yZGVyOiBvcmRlciB9O1xuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZShtZXRob2QsIFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gIFx0Y29uZmlnX2RlcHJlY2F0ZShvcHRpb25zKTtcblxuICBcdGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gIFx0XHRpZiAoaXNTdGFuZGFyZEtleS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gIFx0XHRcdHZhciB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcblxuICBcdFx0XHQvLyB3YXJuIHRoZSBkZXZlbG9wZXIgaWYgdGhleSBwYXNzZWQgYSBmdW5jdGlvbiBhbmQgaWdub3JlIGl0cyB2YWx1ZVxuXG4gIFx0XHRcdC8vIE5PVEU6IHdlIGFsbG93IHNvbWUgZnVuY3Rpb25zIG9uIFwiZWxcIiBiZWNhdXNlIHdlIGR1Y2sgdHlwZSBlbGVtZW50IGxpc3RzXG4gIFx0XHRcdC8vIGFuZCBzb21lIGxpYnJhcmllcyBvciBlZidlZC11cCB2aXJ0dWFsIGJyb3dzZXJzIChwaGFudG9tSlMpIHJldHVybiBhXG4gIFx0XHRcdC8vIGZ1bmN0aW9uIG9iamVjdCBhcyB0aGUgcmVzdWx0IG9mIHF1ZXJ5U2VsZWN0b3IgbWV0aG9kc1xuICBcdFx0XHRpZiAoa2V5ICE9PSBcImVsXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0XHR3YXJuSWZEZWJ1ZyhcIlwiICsga2V5ICsgXCIgaXMgYSBSYWN0aXZlIG9wdGlvbiB0aGF0IGRvZXMgbm90IGV4cGVjdCBhIGZ1bmN0aW9uIGFuZCB3aWxsIGJlIGlnbm9yZWRcIiwgbWV0aG9kID09PSBcImluaXRcIiA/IHRhcmdldCA6IG51bGwpO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHRhcmdldFtrZXldID0gdmFsdWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRjb25maWdfcmVnaXN0cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWdpc3RyeSkge1xuICBcdFx0cmVnaXN0cnlbbWV0aG9kXShQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyk7XG4gIFx0fSk7XG5cbiAgXHRjdXN0b21fYWRhcHRbbWV0aG9kXShQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyk7XG4gIFx0dGVtcGxhdGVfdGVtcGxhdGVbbWV0aG9kXShQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyk7XG4gIFx0Y3NzX2Nzc1ttZXRob2RdKFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKTtcblxuICBcdGV4dGVuZE90aGVyTWV0aG9kcyhQYXJlbnQucHJvdG90eXBlLCB0YXJnZXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kT3RoZXJNZXRob2RzKHBhcmVudCwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gIFx0Zm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgXHRcdGlmICghaXNCbGFja2xpc3RlZFtrZXldICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBcdFx0XHR2YXIgbWVtYmVyID0gb3B0aW9uc1trZXldO1xuXG4gIFx0XHRcdC8vIGlmIHRoaXMgaXMgYSBtZXRob2QgdGhhdCBvdmVyd3JpdGVzIGEgbWV0aG9kLCB3cmFwIGl0OlxuICBcdFx0XHRpZiAodHlwZW9mIG1lbWJlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRcdFx0bWVtYmVyID0gd3JhcFByb3RvdHlwZShwYXJlbnQsIGtleSwgbWVtYmVyKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRhcmdldFtrZXldID0gbWVtYmVyO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VPYmooYXJyYXkpIHtcbiAgXHR2YXIgb2JqID0ge307XG4gIFx0YXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICBcdFx0cmV0dXJuIG9ialt4XSA9IHRydWU7XG4gIFx0fSk7XG4gIFx0cmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciBjb25maWdfY29uZmlnID0gY29uZmlnO1xuXG4gIHZhciBwcm90b3R5cGVfYnViYmxlID0gRnJhZ21lbnQkYnViYmxlO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGJ1YmJsZSgpIHtcbiAgXHR0aGlzLmRpcnR5VmFsdWUgPSB0aGlzLmRpcnR5QXJncyA9IHRydWU7XG5cbiAgXHRpZiAodGhpcy5ib3VuZCAmJiB0eXBlb2YgdGhpcy5vd25lci5idWJibGUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0dGhpcy5vd25lci5idWJibGUoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX2RldGFjaCA9IEZyYWdtZW50JGRldGFjaDtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRkZXRhY2goKSB7XG4gIFx0dmFyIGRvY0ZyYWc7XG5cbiAgXHRpZiAodGhpcy5pdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgXHRcdHJldHVybiB0aGlzLml0ZW1zWzBdLmRldGFjaCgpO1xuICBcdH1cblxuICBcdGRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgXHR0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgXHRcdHZhciBub2RlID0gaXRlbS5kZXRhY2goKTtcblxuICBcdFx0Ly8gVE9ETyBUaGUgaWYgey4uLn0gd2Fzbid0IHByZXZpb3VzbHkgcmVxdWlyZWQgLSBpdCBpcyBub3csIGJlY2F1c2Ugd2UncmVcbiAgXHRcdC8vIGZvcmNpYmx5IGRldGFjaGluZyBldmVyeXRoaW5nIHRvIHJlb3JkZXIgc2VjdGlvbnMgYWZ0ZXIgYW4gdXBkYXRlLiBUaGF0J3NcbiAgXHRcdC8vIGEgbm9uLWlkZWFsIGJydXRlIGZvcmNlIGFwcHJvYWNoLCBpbXBsZW1lbnRlZCB0byBnZXQgYWxsIHRoZSB0ZXN0cyB0byBwYXNzXG4gIFx0XHQvLyAtIGFzIHNvb24gYXMgaXQncyByZXBsYWNlZCB3aXRoIHNvbWV0aGluZyBtb3JlIGVsZWdhbnQsIHRoaXMgc2hvdWxkXG4gIFx0XHQvLyByZXZlcnQgdG8gYGRvY0ZyYWcuYXBwZW5kQ2hpbGQoIGl0ZW0uZGV0YWNoKCkgKWBcbiAgXHRcdGlmIChub2RlKSB7XG4gIFx0XHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gZG9jRnJhZztcbiAgfVxuXG4gIHZhciBGcmFnbWVudF9wcm90b3R5cGVfZmluZCA9IEZyYWdtZW50JGZpbmQ7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZmluZChzZWxlY3Rvcikge1xuICBcdHZhciBpLCBsZW4sIGl0ZW0sIHF1ZXJ5UmVzdWx0O1xuXG4gIFx0aWYgKHRoaXMuaXRlbXMpIHtcbiAgXHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuXG4gIFx0XHRcdGlmIChpdGVtLmZpbmQgJiYgKHF1ZXJ5UmVzdWx0ID0gaXRlbS5maW5kKHNlbGVjdG9yKSkpIHtcbiAgXHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9maW5kQWxsID0gRnJhZ21lbnQkZmluZEFsbDtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRmaW5kQWxsKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdHZhciBpLCBsZW4sIGl0ZW07XG5cbiAgXHRpZiAodGhpcy5pdGVtcykge1xuICBcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbaV07XG5cbiAgXHRcdFx0aWYgKGl0ZW0uZmluZEFsbCkge1xuICBcdFx0XHRcdGl0ZW0uZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyA9IEZyYWdtZW50JGZpbmRBbGxDb21wb25lbnRzO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdHZhciBpLCBsZW4sIGl0ZW07XG5cbiAgXHRpZiAodGhpcy5pdGVtcykge1xuICBcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gIFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbaV07XG5cbiAgXHRcdFx0aWYgKGl0ZW0uZmluZEFsbENvbXBvbmVudHMpIHtcbiAgXHRcdFx0XHRpdGVtLmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gcXVlcnk7XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQgPSBGcmFnbWVudCRmaW5kQ29tcG9uZW50O1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRDb21wb25lbnQoc2VsZWN0b3IpIHtcbiAgXHR2YXIgbGVuLCBpLCBpdGVtLCBxdWVyeVJlc3VsdDtcblxuICBcdGlmICh0aGlzLml0ZW1zKSB7XG4gIFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1tpXTtcblxuICBcdFx0XHRpZiAoaXRlbS5maW5kQ29tcG9uZW50ICYmIChxdWVyeVJlc3VsdCA9IGl0ZW0uZmluZENvbXBvbmVudChzZWxlY3RvcikpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZmluZE5leHROb2RlID0gRnJhZ21lbnQkZmluZE5leHROb2RlO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGZpbmROZXh0Tm9kZShpdGVtKSB7XG4gIFx0dmFyIGluZGV4ID0gaXRlbS5pbmRleCxcbiAgXHQgICAgbm9kZTtcblxuICBcdGlmICh0aGlzLml0ZW1zW2luZGV4ICsgMV0pIHtcbiAgXHRcdG5vZGUgPSB0aGlzLml0ZW1zW2luZGV4ICsgMV0uZmlyc3ROb2RlKCk7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgdGhpcyBpcyB0aGUgcm9vdCBmcmFnbWVudCwgYW5kIHRoZXJlIGFyZSBubyBtb3JlIGl0ZW1zLFxuICBcdC8vIGl0IG1lYW5zIHdlJ3JlIGF0IHRoZSBlbmQuLi5cbiAgXHRlbHNlIGlmICh0aGlzLm93bmVyID09PSB0aGlzLnJvb3QpIHtcbiAgXHRcdGlmICghdGhpcy5vd25lci5jb21wb25lbnQpIHtcbiAgXHRcdFx0Ly8gVE9ETyBidXQgc29tZXRoaW5nIGVsc2UgY291bGQgaGF2ZSBiZWVuIGFwcGVuZGVkIHRvXG4gIFx0XHRcdC8vIHRoaXMucm9vdC5lbCwgbm8/XG4gIFx0XHRcdG5vZGUgPSBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHQvLyAuLi51bmxlc3MgdGhpcyBpcyBhIGNvbXBvbmVudFxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdG5vZGUgPSB0aGlzLm93bmVyLmNvbXBvbmVudC5maW5kTmV4dE5vZGUoKTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0bm9kZSA9IHRoaXMub3duZXIuZmluZE5leHROb2RlKHRoaXMpO1xuICBcdH1cblxuICBcdHJldHVybiBub2RlO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9maXJzdE5vZGUgPSBGcmFnbWVudCRmaXJzdE5vZGU7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkZmlyc3ROb2RlKCkge1xuICBcdGlmICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXNbMF0pIHtcbiAgXHRcdHJldHVybiB0aGlzLml0ZW1zWzBdLmZpcnN0Tm9kZSgpO1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNoYXJlZF9wcm9jZXNzSXRlbXMgPSBwcm9jZXNzSXRlbXM7XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0l0ZW1zKGl0ZW1zLCB2YWx1ZXMsIGd1aWQsIGNvdW50ZXIpIHtcbiAgXHRjb3VudGVyID0gY291bnRlciB8fCAwO1xuXG4gIFx0cmV0dXJuIGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0dmFyIHBsYWNlaG9sZGVySWQsIHdyYXBwZWQsIHZhbHVlO1xuXG4gIFx0XHRpZiAoaXRlbS50ZXh0KSB7XG4gIFx0XHRcdHJldHVybiBpdGVtLnRleHQ7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChpdGVtLmZyYWdtZW50cykge1xuICBcdFx0XHRyZXR1cm4gaXRlbS5mcmFnbWVudHMubWFwKGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICBcdFx0XHRcdHJldHVybiBwcm9jZXNzSXRlbXMoZnJhZ21lbnQuaXRlbXMsIHZhbHVlcywgZ3VpZCwgY291bnRlcik7XG4gIFx0XHRcdH0pLmpvaW4oXCJcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHBsYWNlaG9sZGVySWQgPSBndWlkICsgXCItXCIgKyBjb3VudGVyKys7XG5cbiAgXHRcdGlmIChpdGVtLmtleXBhdGggJiYgKHdyYXBwZWQgPSBpdGVtLnJvb3Qudmlld21vZGVsLndyYXBwZWRbaXRlbS5rZXlwYXRoLnN0cl0pKSB7XG4gIFx0XHRcdHZhbHVlID0gd3JhcHBlZC52YWx1ZTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHZhbHVlID0gaXRlbS5nZXRWYWx1ZSgpO1xuICBcdFx0fVxuXG4gIFx0XHR2YWx1ZXNbcGxhY2Vob2xkZXJJZF0gPSB2YWx1ZTtcblxuICBcdFx0cmV0dXJuIFwiJHtcIiArIHBsYWNlaG9sZGVySWQgKyBcIn1cIjtcbiAgXHR9KS5qb2luKFwiXCIpO1xuICB9XG5cbiAgdmFyIGdldEFyZ3NMaXN0ID0gRnJhZ21lbnQkZ2V0QXJnc0xpc3Q7XG4gIGZ1bmN0aW9uIEZyYWdtZW50JGdldEFyZ3NMaXN0KCkge1xuICBcdHZhciB2YWx1ZXMsIHNvdXJjZSwgcGFyc2VkLCByZXN1bHQ7XG5cbiAgXHRpZiAodGhpcy5kaXJ0eUFyZ3MpIHtcbiAgXHRcdHNvdXJjZSA9IHNoYXJlZF9wcm9jZXNzSXRlbXModGhpcy5pdGVtcywgdmFsdWVzID0ge30sIHRoaXMucm9vdC5fZ3VpZCk7XG4gIFx0XHRwYXJzZWQgPSBwYXJzZUpTT04oXCJbXCIgKyBzb3VyY2UgKyBcIl1cIiwgdmFsdWVzKTtcblxuICBcdFx0aWYgKCFwYXJzZWQpIHtcbiAgXHRcdFx0cmVzdWx0ID0gW3RoaXMudG9TdHJpbmcoKV07XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXN1bHQgPSBwYXJzZWQudmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuYXJnc0xpc3QgPSByZXN1bHQ7XG4gIFx0XHR0aGlzLmRpcnR5QXJncyA9IGZhbHNlO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLmFyZ3NMaXN0O1xuICB9XG5cbiAgdmFyIGdldE5vZGUgPSBGcmFnbWVudCRnZXROb2RlO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JGdldE5vZGUoKSB7XG4gIFx0dmFyIGZyYWdtZW50ID0gdGhpcztcblxuICBcdGRvIHtcbiAgXHRcdGlmIChmcmFnbWVudC5wRWxlbWVudCkge1xuICBcdFx0XHRyZXR1cm4gZnJhZ21lbnQucEVsZW1lbnQubm9kZTtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlIChmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudCk7XG5cbiAgXHRyZXR1cm4gdGhpcy5yb290LmRldGFjaGVkIHx8IHRoaXMucm9vdC5lbDtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfZ2V0VmFsdWUgPSBGcmFnbWVudCRnZXRWYWx1ZTtcbiAgZnVuY3Rpb24gRnJhZ21lbnQkZ2V0VmFsdWUoKSB7XG4gIFx0dmFyIHZhbHVlcywgc291cmNlLCBwYXJzZWQsIHJlc3VsdDtcblxuICBcdGlmICh0aGlzLmRpcnR5VmFsdWUpIHtcbiAgXHRcdHNvdXJjZSA9IHNoYXJlZF9wcm9jZXNzSXRlbXModGhpcy5pdGVtcywgdmFsdWVzID0ge30sIHRoaXMucm9vdC5fZ3VpZCk7XG4gIFx0XHRwYXJzZWQgPSBwYXJzZUpTT04oc291cmNlLCB2YWx1ZXMpO1xuXG4gIFx0XHRpZiAoIXBhcnNlZCkge1xuICBcdFx0XHRyZXN1bHQgPSB0aGlzLnRvU3RyaW5nKCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXN1bHQgPSBwYXJzZWQudmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMudmFsdWUgPSByZXN1bHQ7XG4gIFx0XHR0aGlzLmRpcnR5VmFsdWUgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIHZhciBzaGFyZWRfZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICBcdHJldHVybiBkZXRhY2hOb2RlKHRoaXMubm9kZSk7XG4gIH07XG5cbiAgdmFyIFRleHQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMudHlwZSA9IFRFWFQ7XG4gIFx0dGhpcy50ZXh0ID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgfTtcblxuICBUZXh0LnByb3RvdHlwZSA9IHtcbiAgXHRkZXRhY2g6IHNoYXJlZF9kZXRhY2gsXG5cbiAgXHRmaXJzdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLm5vZGUpIHtcbiAgXHRcdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50ZXh0KTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uIChlc2NhcGUpIHtcbiAgXHRcdHJldHVybiBlc2NhcGUgPyBlc2NhcGVIdG1sKHRoaXMudGV4dCkgOiB0aGlzLnRleHQ7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0aWYgKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuZGV0YWNoKCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBpdGVtc19UZXh0ID0gVGV4dDtcblxuICB2YXIgc2hhcmVkX3VuYmluZCA9IHNoYXJlZF91bmJpbmRfX3VuYmluZDtcblxuICBmdW5jdGlvbiBzaGFyZWRfdW5iaW5kX191bmJpbmQoKSB7XG4gIFx0aWYgKHRoaXMucmVnaXN0ZXJlZCkge1xuICBcdFx0Ly8gdGhpcyB3YXMgcmVnaXN0ZXJlZCBhcyBhIGRlcGVuZGFudFxuICBcdFx0dGhpcy5yb290LnZpZXdtb2RlbC51bnJlZ2lzdGVyKHRoaXMua2V5cGF0aCwgdGhpcyk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMucmVzb2x2ZXIpIHtcbiAgXHRcdHRoaXMucmVzb2x2ZXIudW5iaW5kKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIE11c3RhY2hlX2dldFZhbHVlID0gTXVzdGFjaGUkZ2V0VmFsdWU7XG5cbiAgZnVuY3Rpb24gTXVzdGFjaGUkZ2V0VmFsdWUoKSB7XG4gIFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICB2YXIgUmVmZXJlbmNlUmVzb2x2ZXIgPSBmdW5jdGlvbiAob3duZXIsIHJlZiwgY2FsbGJhY2spIHtcbiAgXHR2YXIga2V5cGF0aDtcblxuICBcdHRoaXMucmVmID0gcmVmO1xuICBcdHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcblxuICBcdHRoaXMucm9vdCA9IG93bmVyLnJvb3Q7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IG93bmVyLnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBcdGtleXBhdGggPSBzaGFyZWRfcmVzb2x2ZVJlZihvd25lci5yb290LCByZWYsIG93bmVyLnBhcmVudEZyYWdtZW50KTtcbiAgXHRpZiAoa2V5cGF0aCAhPSB1bmRlZmluZWQpIHtcbiAgXHRcdHRoaXMucmVzb2x2ZShrZXlwYXRoKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVW5yZXNvbHZlZCh0aGlzKTtcbiAgXHR9XG4gIH07XG5cbiAgUmVmZXJlbmNlUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuICBcdHJlc29sdmU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoICYmICFrZXlwYXRoKSB7XG4gIFx0XHRcdC8vIGl0IHdhcyByZXNvbHZlZCwgYW5kIG5vdyBpdCdzIG5vdC4gQ2FuIGhhcHBlbiBpZiBlLmcuIGBiYXJgIGluXG4gIFx0XHRcdC8vIGB7e2Zvb1tiYXJdfX1gIGJlY29tZXMgdW5kZWZpbmVkXG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFVucmVzb2x2ZWQodGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMucmVzb2x2ZWQgPSB0cnVlO1xuXG4gIFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdFx0dGhpcy5jYWxsYmFjayhrZXlwYXRoKTtcbiAgXHR9LFxuXG4gIFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnJlc29sdmUoZ2V0S2V5cGF0aCh0aGlzLnJlZikpO1xuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHR2YXIga2V5cGF0aDtcblxuICBcdFx0aWYgKHRoaXMua2V5cGF0aCAhPSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0a2V5cGF0aCA9IHRoaXMua2V5cGF0aC5yZXBsYWNlKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0XHQvLyB3YXMgYSBuZXcga2V5cGF0aCBjcmVhdGVkP1xuICBcdFx0XHRpZiAoa2V5cGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0Ly8gcmVzb2x2ZSBpdFxuICBcdFx0XHRcdHRoaXMucmVzb2x2ZShrZXlwYXRoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5yZXNvbHZlZCkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5yZW1vdmVVbnJlc29sdmVkKHRoaXMpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgUmVzb2x2ZXJzX1JlZmVyZW5jZVJlc29sdmVyID0gUmVmZXJlbmNlUmVzb2x2ZXI7XG5cbiAgdmFyIFNwZWNpYWxSZXNvbHZlciA9IGZ1bmN0aW9uIChvd25lciwgcmVmLCBjYWxsYmFjaykge1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvd25lci5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLnJlZiA9IHJlZjtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHR0aGlzLnJlYmluZCgpO1xuICB9O1xuXG4gIHZhciBwcm9wcyA9IHtcbiAgXHRcIkBrZXlwYXRoXCI6IHsgcHJlZml4OiBcImNcIiwgcHJvcDogW1wiY29udGV4dFwiXSB9LFxuICBcdFwiQGluZGV4XCI6IHsgcHJlZml4OiBcImlcIiwgcHJvcDogW1wiaW5kZXhcIl0gfSxcbiAgXHRcIkBrZXlcIjogeyBwcmVmaXg6IFwia1wiLCBwcm9wOiBbXCJrZXlcIiwgXCJpbmRleFwiXSB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0UHJvcCh0YXJnZXQsIHByb3ApIHtcbiAgXHR2YXIgdmFsdWU7XG4gIFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wLnByb3AubGVuZ3RoOyBpKyspIHtcbiAgXHRcdGlmICgodmFsdWUgPSB0YXJnZXRbcHJvcC5wcm9wW2ldXSkgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgU3BlY2lhbFJlc29sdmVyLnByb3RvdHlwZSA9IHtcbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciByZWYgPSB0aGlzLnJlZixcbiAgXHRcdCAgICBmcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQsXG4gIFx0XHQgICAgcHJvcCA9IHByb3BzW3JlZl0sXG4gIFx0XHQgICAgdmFsdWU7XG5cbiAgXHRcdGlmICghcHJvcCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHNwZWNpYWwgcmVmZXJlbmNlIFxcXCJcIiArIHJlZiArIFwiXFxcIiAtIHZhbGlkIHJlZmVyZW5jZXMgYXJlIEBpbmRleCwgQGtleSBhbmQgQGtleXBhdGhcIik7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGhhdmUgd2UgYWxyZWFkeSBmb3VuZCB0aGUgbmVhcmVzdCBwYXJlbnQ/XG4gIFx0XHRpZiAodGhpcy5jYWNoZWQpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuY2FsbGJhY2soZ2V0S2V5cGF0aChcIkBcIiArIHByb3AucHJlZml4ICsgZ2V0UHJvcCh0aGlzLmNhY2hlZCwgcHJvcCkpKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIGZvciBpbmRpY2VzLCB3aGljaCBtYXkgY3Jvc3MgY29tcG9uZW50IGJvdW5kYXJpZXNcbiAgXHRcdGlmIChwcm9wLnByb3AuaW5kZXhPZihcImluZGV4XCIpICE9PSAtMSB8fCBwcm9wLnByb3AuaW5kZXhPZihcImtleVwiKSAhPT0gLTEpIHtcbiAgXHRcdFx0d2hpbGUgKGZyYWdtZW50KSB7XG4gIFx0XHRcdFx0aWYgKGZyYWdtZW50Lm93bmVyLmN1cnJlbnRTdWJ0eXBlID09PSBTRUNUSU9OX0VBQ0ggJiYgKHZhbHVlID0gZ2V0UHJvcChmcmFnbWVudCwgcHJvcCkpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRcdHRoaXMuY2FjaGVkID0gZnJhZ21lbnQ7XG5cbiAgXHRcdFx0XHRcdGZyYWdtZW50LnJlZ2lzdGVySW5kZXhSZWYodGhpcyk7XG5cbiAgXHRcdFx0XHRcdHJldHVybiB0aGlzLmNhbGxiYWNrKGdldEtleXBhdGgoXCJAXCIgKyBwcm9wLnByZWZpeCArIHZhbHVlKSk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gd2F0Y2ggZm9yIGNvbXBvbmVudCBib3VuZGFyaWVzXG4gIFx0XHRcdFx0aWYgKCFmcmFnbWVudC5wYXJlbnQgJiYgZnJhZ21lbnQub3duZXIgJiYgZnJhZ21lbnQub3duZXIuY29tcG9uZW50ICYmIGZyYWdtZW50Lm93bmVyLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCAmJiAhZnJhZ21lbnQub3duZXIuY29tcG9uZW50Lmluc3RhbmNlLmlzb2xhdGVkKSB7XG4gIFx0XHRcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50Lm93bmVyLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3aGlsZSAoZnJhZ21lbnQpIHtcbiAgXHRcdFx0XHRpZiAoKHZhbHVlID0gZ2V0UHJvcChmcmFnbWVudCwgcHJvcCkpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0XHRcdHJldHVybiB0aGlzLmNhbGxiYWNrKGdldEtleXBhdGgoXCJAXCIgKyBwcm9wLnByZWZpeCArIHZhbHVlLnN0cikpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuY2FjaGVkKSB7XG4gIFx0XHRcdHRoaXMuY2FjaGVkLnVucmVnaXN0ZXJJbmRleFJlZih0aGlzKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIFJlc29sdmVyc19TcGVjaWFsUmVzb2x2ZXIgPSBTcGVjaWFsUmVzb2x2ZXI7XG5cbiAgdmFyIEluZGV4UmVzb2x2ZXIgPSBmdW5jdGlvbiAob3duZXIsIHJlZiwgY2FsbGJhY2spIHtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gb3duZXIucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5yZWYgPSByZWY7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIFx0cmVmLnJlZi5mcmFnbWVudC5yZWdpc3RlckluZGV4UmVmKHRoaXMpO1xuXG4gIFx0dGhpcy5yZWJpbmQoKTtcbiAgfTtcblxuICBJbmRleFJlc29sdmVyLnByb3RvdHlwZSA9IHtcbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBpbmRleCxcbiAgXHRcdCAgICByZWYgPSB0aGlzLnJlZi5yZWY7XG5cbiAgXHRcdGlmIChyZWYucmVmLnQgPT09IFwia1wiKSB7XG4gIFx0XHRcdGluZGV4ID0gXCJrXCIgKyByZWYuZnJhZ21lbnQua2V5O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0aW5kZXggPSBcImlcIiArIHJlZi5mcmFnbWVudC5pbmRleDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5jYWxsYmFjayhnZXRLZXlwYXRoKFwiQFwiICsgaW5kZXgpKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnJlZi5yZWYuZnJhZ21lbnQudW5yZWdpc3RlckluZGV4UmVmKHRoaXMpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgUmVzb2x2ZXJzX0luZGV4UmVzb2x2ZXIgPSBJbmRleFJlc29sdmVyO1xuXG4gIHZhciBSZXNvbHZlcnNfZmluZEluZGV4UmVmcyA9IGZpbmRJbmRleFJlZnM7XG5cbiAgZnVuY3Rpb24gZmluZEluZGV4UmVmcyhmcmFnbWVudCwgcmVmTmFtZSkge1xuICBcdHZhciByZXN1bHQgPSB7fSxcbiAgXHQgICAgcmVmcyxcbiAgXHQgICAgZnJhZ1JlZnMsXG4gIFx0ICAgIHJlZixcbiAgXHQgICAgaSxcbiAgXHQgICAgb3duZXIsXG4gIFx0ICAgIGhpdCA9IGZhbHNlO1xuXG4gIFx0aWYgKCFyZWZOYW1lKSB7XG4gIFx0XHRyZXN1bHQucmVmcyA9IHJlZnMgPSB7fTtcbiAgXHR9XG5cbiAgXHR3aGlsZSAoZnJhZ21lbnQpIHtcbiAgXHRcdGlmICgob3duZXIgPSBmcmFnbWVudC5vd25lcikgJiYgKGZyYWdSZWZzID0gb3duZXIuaW5kZXhSZWZzKSkge1xuXG4gIFx0XHRcdC8vIHdlJ3JlIGxvb2tpbmcgZm9yIGEgcGFydGljdWxhciByZWYsIGFuZCBpdCdzIGhlcmVcbiAgXHRcdFx0aWYgKHJlZk5hbWUgJiYgKHJlZiA9IG93bmVyLmdldEluZGV4UmVmKHJlZk5hbWUpKSkge1xuICBcdFx0XHRcdHJlc3VsdC5yZWYgPSB7XG4gIFx0XHRcdFx0XHRmcmFnbWVudDogZnJhZ21lbnQsXG4gIFx0XHRcdFx0XHRyZWY6IHJlZlxuICBcdFx0XHRcdH07XG4gIFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIHdlJ3JlIGNvbGxlY3RpbmcgcmVmcyB1cC10cmVlXG4gIFx0XHRcdGVsc2UgaWYgKCFyZWZOYW1lKSB7XG4gIFx0XHRcdFx0Zm9yIChpIGluIGZyYWdSZWZzKSB7XG4gIFx0XHRcdFx0XHRyZWYgPSBmcmFnUmVmc1tpXTtcblxuICBcdFx0XHRcdFx0Ly8gZG9uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIHJlZnMgLSB0aGV5IHNob3VsZCBzaGFkb3cgcGFyZW50c1xuICBcdFx0XHRcdFx0aWYgKCFyZWZzW3JlZi5uXSkge1xuICBcdFx0XHRcdFx0XHRoaXQgPSB0cnVlO1xuICBcdFx0XHRcdFx0XHRyZWZzW3JlZi5uXSA9IHtcbiAgXHRcdFx0XHRcdFx0XHRmcmFnbWVudDogZnJhZ21lbnQsXG4gIFx0XHRcdFx0XHRcdFx0cmVmOiByZWZcbiAgXHRcdFx0XHRcdFx0fTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gd2F0Y2ggZm9yIGNvbXBvbmVudCBib3VuZGFyaWVzXG4gIFx0XHRpZiAoIWZyYWdtZW50LnBhcmVudCAmJiBmcmFnbWVudC5vd25lciAmJiBmcmFnbWVudC5vd25lci5jb21wb25lbnQgJiYgZnJhZ21lbnQub3duZXIuY29tcG9uZW50LnBhcmVudEZyYWdtZW50ICYmICFmcmFnbWVudC5vd25lci5jb21wb25lbnQuaW5zdGFuY2UuaXNvbGF0ZWQpIHtcbiAgXHRcdFx0cmVzdWx0LmNvbXBvbmVudEJvdW5kYXJ5ID0gdHJ1ZTtcbiAgXHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5vd25lci5jb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoIWhpdCkge1xuICBcdFx0cmV0dXJuIHVuZGVmaW5lZDtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9XG4gIH1cblxuICBmaW5kSW5kZXhSZWZzLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKGluZGljZXMpIHtcbiAgXHR2YXIgcmVmcyA9IHt9LFxuICBcdCAgICBrLFxuICBcdCAgICByZWY7XG5cbiAgXHRmb3IgKGsgaW4gaW5kaWNlcy5yZWZzKSB7XG4gIFx0XHRyZWYgPSBpbmRpY2VzLnJlZnNba107XG4gIFx0XHRyZWZzW3JlZi5yZWYubl0gPSByZWYucmVmLnQgPT09IFwia1wiID8gcmVmLmZyYWdtZW50LmtleSA6IHJlZi5mcmFnbWVudC5pbmRleDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVmcztcbiAgfTtcblxuICB2YXIgUmVzb2x2ZXJzX2NyZWF0ZVJlZmVyZW5jZVJlc29sdmVyID0gY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXI7XG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKG93bmVyLCByZWYsIGNhbGxiYWNrKSB7XG4gIFx0dmFyIGluZGV4UmVmO1xuXG4gIFx0aWYgKHJlZi5jaGFyQXQoMCkgPT09IFwiQFwiKSB7XG4gIFx0XHRyZXR1cm4gbmV3IFJlc29sdmVyc19TcGVjaWFsUmVzb2x2ZXIob3duZXIsIHJlZiwgY2FsbGJhY2spO1xuICBcdH1cblxuICBcdGlmIChpbmRleFJlZiA9IFJlc29sdmVyc19maW5kSW5kZXhSZWZzKG93bmVyLnBhcmVudEZyYWdtZW50LCByZWYpKSB7XG4gIFx0XHRyZXR1cm4gbmV3IFJlc29sdmVyc19JbmRleFJlc29sdmVyKG93bmVyLCBpbmRleFJlZiwgY2FsbGJhY2spO1xuICBcdH1cblxuICBcdHJldHVybiBuZXcgUmVzb2x2ZXJzX1JlZmVyZW5jZVJlc29sdmVyKG93bmVyLCByZWYsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBzaGFyZWRfZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nID0gZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nO1xuICB2YXIgY2FjaGUgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nKHN0ciwgaSkge1xuICBcdHZhciBmbiwgYXJncztcblxuICBcdGlmIChjYWNoZVtzdHJdKSB7XG4gIFx0XHRyZXR1cm4gY2FjaGVbc3RyXTtcbiAgXHR9XG5cbiAgXHRhcmdzID0gW107XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0YXJnc1tpXSA9IFwiX1wiICsgaTtcbiAgXHR9XG5cbiAgXHRmbiA9IG5ldyBGdW5jdGlvbihhcmdzLmpvaW4oXCIsXCIpLCBcInJldHVybihcIiArIHN0ciArIFwiKVwiKTtcblxuICBcdGNhY2hlW3N0cl0gPSBmbjtcbiAgXHRyZXR1cm4gZm47XG4gIH1cblxuICB2YXIgRXhwcmVzc2lvblJlc29sdmVyLFxuICAgICAgUmVzb2x2ZXJzX0V4cHJlc3Npb25SZXNvbHZlcl9fYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuXG4gIEV4cHJlc3Npb25SZXNvbHZlciA9IGZ1bmN0aW9uIChvd25lciwgcGFyZW50RnJhZ21lbnQsIGV4cHJlc3Npb24sIGNhbGxiYWNrKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciByYWN0aXZlO1xuXG4gIFx0cmFjdGl2ZSA9IG93bmVyLnJvb3Q7XG5cbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIFx0dGhpcy5vd25lciA9IG93bmVyO1xuICBcdHRoaXMuc3RyID0gZXhwcmVzc2lvbi5zO1xuICBcdHRoaXMua2V5cGF0aHMgPSBbXTtcblxuICBcdC8vIENyZWF0ZSByZXNvbHZlcnMgZm9yIGVhY2ggcmVmZXJlbmNlXG4gIFx0dGhpcy5wZW5kaW5nID0gZXhwcmVzc2lvbi5yLmxlbmd0aDtcbiAgXHR0aGlzLnJlZlJlc29sdmVycyA9IGV4cHJlc3Npb24uci5tYXAoZnVuY3Rpb24gKHJlZiwgaSkge1xuICBcdFx0cmV0dXJuIFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlcihfdGhpcywgcmVmLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRfdGhpcy5yZXNvbHZlKGksIGtleXBhdGgpO1xuICBcdFx0fSk7XG4gIFx0fSk7XG5cbiAgXHR0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgXHR0aGlzLmJ1YmJsZSgpO1xuICB9O1xuXG4gIEV4cHJlc3Npb25SZXNvbHZlci5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMucmVhZHkpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnVuaXF1ZVN0cmluZyA9IGdldFVuaXF1ZVN0cmluZyh0aGlzLnN0ciwgdGhpcy5rZXlwYXRocyk7XG4gIFx0XHR0aGlzLmtleXBhdGggPSBjcmVhdGVFeHByZXNzaW9uS2V5cGF0aCh0aGlzLnVuaXF1ZVN0cmluZyk7XG5cbiAgXHRcdHRoaXMuY3JlYXRlRXZhbHVhdG9yKCk7XG4gIFx0XHR0aGlzLmNhbGxiYWNrKHRoaXMua2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHJlc29sdmVyO1xuXG4gIFx0XHR3aGlsZSAocmVzb2x2ZXIgPSB0aGlzLnJlZlJlc29sdmVycy5wb3AoKSkge1xuICBcdFx0XHRyZXNvbHZlci51bmJpbmQoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVzb2x2ZTogZnVuY3Rpb24gKGluZGV4LCBrZXlwYXRoKSB7XG4gIFx0XHR0aGlzLmtleXBhdGhzW2luZGV4XSA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLmJ1YmJsZSgpO1xuICBcdH0sXG5cbiAgXHRjcmVhdGVFdmFsdWF0b3I6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciBjb21wdXRhdGlvbiwgdmFsdWVHZXR0ZXJzLCBzaWduYXR1cmUsIGtleXBhdGgsIGZuO1xuXG4gIFx0XHRrZXlwYXRoID0gdGhpcy5rZXlwYXRoO1xuICBcdFx0Y29tcHV0YXRpb24gPSB0aGlzLnJvb3Qudmlld21vZGVsLmNvbXB1dGF0aW9uc1trZXlwYXRoLnN0cl07XG5cbiAgXHRcdC8vIG9ubHkgaWYgaXQgZG9lc24ndCBleGlzdCB5ZXQhXG4gIFx0XHRpZiAoIWNvbXB1dGF0aW9uKSB7XG4gIFx0XHRcdGZuID0gc2hhcmVkX2dldEZ1bmN0aW9uRnJvbVN0cmluZyh0aGlzLnN0ciwgdGhpcy5yZWZSZXNvbHZlcnMubGVuZ3RoKTtcblxuICBcdFx0XHR2YWx1ZUdldHRlcnMgPSB0aGlzLmtleXBhdGhzLm1hcChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRcdHZhciB2YWx1ZTtcblxuICBcdFx0XHRcdGlmIChrZXlwYXRoID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuICBcdFx0XHRcdFx0fTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyAnc3BlY2lhbCcga2V5cGF0aHMgZW5jb2RlIGEgdmFsdWVcbiAgXHRcdFx0XHRpZiAoa2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdFx0XHRcdHZhbHVlID0ga2V5cGF0aC52YWx1ZTtcbiAgXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcbiAgXHRcdFx0XHRcdH07XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdHZhciB2YWx1ZSA9IF90aGlzLnJvb3Qudmlld21vZGVsLmdldChrZXlwYXRoLCB7IG5vVW53cmFwOiB0cnVlLCBmdWxsUm9vdEdldDogdHJ1ZSB9KTtcbiAgXHRcdFx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0XHRcdFx0XHR2YWx1ZSA9IHdyYXBGdW5jdGlvbih2YWx1ZSwgX3RoaXMucm9vdCk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0XHRcdFx0fTtcbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0c2lnbmF0dXJlID0ge1xuICBcdFx0XHRcdGRlcHM6IHRoaXMua2V5cGF0aHMuZmlsdGVyKGlzVmFsaWREZXBlbmRlbmN5KSxcbiAgXHRcdFx0XHRnZXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRcdHZhciBhcmdzID0gdmFsdWVHZXR0ZXJzLm1hcChjYWxsKTtcbiAgXHRcdFx0XHRcdHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0Y29tcHV0YXRpb24gPSB0aGlzLnJvb3Qudmlld21vZGVsLmNvbXB1dGUoa2V5cGF0aCwgc2lnbmF0dXJlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwubWFyayhrZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0Ly8gVE9ETyBvbmx5IGJ1YmJsZSBvbmNlLCBubyBtYXR0ZXIgaG93IG1hbnkgcmVmZXJlbmNlcyBhcmUgYWZmZWN0ZWQgYnkgdGhlIHJlYmluZFxuICBcdFx0dGhpcy5yZWZSZXNvbHZlcnMuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICBcdFx0XHRyZXR1cm4gci5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIFJlc29sdmVyc19FeHByZXNzaW9uUmVzb2x2ZXIgPSBFeHByZXNzaW9uUmVzb2x2ZXI7XG5cbiAgZnVuY3Rpb24gY2FsbCh2YWx1ZSkge1xuICBcdHJldHVybiB2YWx1ZS5jYWxsKCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRVbmlxdWVTdHJpbmcoc3RyLCBrZXlwYXRocykge1xuICBcdC8vIGdldCBzdHJpbmcgdGhhdCBpcyB1bmlxdWUgdG8gdGhpcyBleHByZXNzaW9uXG4gIFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9fKFswLTldKykvZywgZnVuY3Rpb24gKG1hdGNoLCAkMSkge1xuICBcdFx0dmFyIGtleXBhdGgsIHZhbHVlO1xuXG4gIFx0XHQvLyBtYWtlIHN1cmUgd2UncmUgbm90IHJlcGxhY2luZyBhIG5vbi1rZXlwYXRoIF9bMC05XVxuICBcdFx0aWYgKCskMSA+PSBrZXlwYXRocy5sZW5ndGgpIHtcbiAgXHRcdFx0cmV0dXJuIFwiX1wiICsgJDE7XG4gIFx0XHR9XG5cbiAgXHRcdGtleXBhdGggPSBrZXlwYXRoc1skMV07XG5cbiAgXHRcdGlmIChrZXlwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChrZXlwYXRoLmlzU3BlY2lhbCkge1xuICBcdFx0XHR2YWx1ZSA9IGtleXBhdGgudmFsdWU7XG4gIFx0XHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgPyB2YWx1ZSA6IFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIjtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGtleXBhdGguc3RyO1xuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRXhwcmVzc2lvbktleXBhdGgodW5pcXVlU3RyaW5nKSB7XG4gIFx0Ly8gU2FuaXRpemUgYnkgcmVtb3ZpbmcgYW55IHBlcmlvZHMgb3Igc3F1YXJlIGJyYWNrZXRzLiBPdGhlcndpc2VcbiAgXHQvLyB3ZSBjYW4ndCBzcGxpdCB0aGUga2V5cGF0aCBpbnRvIGtleXMhXG4gIFx0Ly8gUmVtb3ZlIGFzdGVyaXNrcyB0b28sIHNpbmNlIHRoZXkgbWVzcyB3aXRoIHBhdHRlcm4gb2JzZXJ2ZXJzXG4gIFx0cmV0dXJuIGdldEtleXBhdGgoXCIke1wiICsgdW5pcXVlU3RyaW5nLnJlcGxhY2UoL1tcXC5cXFtcXF1dL2csIFwiLVwiKS5yZXBsYWNlKC9cXCovLCBcIiNNVUwjXCIpICsgXCJ9XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNWYWxpZERlcGVuZGVuY3koa2V5cGF0aCkge1xuICBcdHJldHVybiBrZXlwYXRoICE9PSB1bmRlZmluZWQgJiYga2V5cGF0aFswXSAhPT0gXCJAXCI7XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwRnVuY3Rpb24oZm4sIHJhY3RpdmUpIHtcbiAgXHR2YXIgd3JhcHBlZCwgcHJvcCwga2V5O1xuXG4gIFx0aWYgKGZuLl9fcmFjdGl2ZV9ub3dyYXApIHtcbiAgXHRcdHJldHVybiBmbjtcbiAgXHR9XG5cbiAgXHRwcm9wID0gXCJfX3JhY3RpdmVfXCIgKyByYWN0aXZlLl9ndWlkO1xuICBcdHdyYXBwZWQgPSBmbltwcm9wXTtcblxuICBcdGlmICh3cmFwcGVkKSB7XG4gIFx0XHRyZXR1cm4gd3JhcHBlZDtcbiAgXHR9IGVsc2UgaWYgKC90aGlzLy50ZXN0KGZuLnRvU3RyaW5nKCkpKSB7XG4gIFx0XHRkZWZpbmVQcm9wZXJ0eShmbiwgcHJvcCwge1xuICBcdFx0XHR2YWx1ZTogUmVzb2x2ZXJzX0V4cHJlc3Npb25SZXNvbHZlcl9fYmluZC5jYWxsKGZuLCByYWN0aXZlKSxcbiAgXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG4gIFx0XHR9KTtcblxuICBcdFx0Ly8gQWRkIHByb3BlcnRpZXMvbWV0aG9kcyB0byB3cmFwcGVkIGZ1bmN0aW9uXG4gIFx0XHRmb3IgKGtleSBpbiBmbikge1xuICBcdFx0XHRpZiAoZm4uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBcdFx0XHRcdGZuW3Byb3BdW2tleV0gPSBmbltrZXldO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJhY3RpdmUuX2JvdW5kRnVuY3Rpb25zLnB1c2goe1xuICBcdFx0XHRmbjogZm4sXG4gIFx0XHRcdHByb3A6IHByb3BcbiAgXHRcdH0pO1xuXG4gIFx0XHRyZXR1cm4gZm5bcHJvcF07XG4gIFx0fVxuXG4gIFx0ZGVmaW5lUHJvcGVydHkoZm4sIFwiX19yYWN0aXZlX25vd3JhcFwiLCB7XG4gIFx0XHR2YWx1ZTogZm5cbiAgXHR9KTtcblxuICBcdHJldHVybiBmbi5fX3JhY3RpdmVfbm93cmFwO1xuICB9XG5cbiAgdmFyIE1lbWJlclJlc29sdmVyID0gZnVuY3Rpb24gKHRlbXBsYXRlLCByZXNvbHZlciwgcGFyZW50RnJhZ21lbnQpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dGhpcy5yZXNvbHZlciA9IHJlc29sdmVyO1xuICBcdHRoaXMucm9vdCA9IHJlc29sdmVyLnJvb3Q7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMudmlld21vZGVsID0gcmVzb2x2ZXIucm9vdC52aWV3bW9kZWw7XG5cbiAgXHRpZiAodHlwZW9mIHRlbXBsYXRlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHR0aGlzLnZhbHVlID0gdGVtcGxhdGU7XG4gIFx0fVxuXG4gIFx0Ly8gU2ltcGxlIHJlZmVyZW5jZT9cbiAgXHRlbHNlIGlmICh0ZW1wbGF0ZS50ID09PSBSRUZFUkVOQ0UpIHtcbiAgXHRcdHRoaXMucmVmUmVzb2x2ZXIgPSBSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIodGhpcywgdGVtcGxhdGUubiwgZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0X3RoaXMucmVzb2x2ZShrZXlwYXRoKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdC8vIE90aGVyd2lzZSB3ZSBoYXZlIGFuIGV4cHJlc3Npb24gaW4gaXRzIG93biByaWdodFxuICBcdGVsc2Uge1xuICBcdFx0bmV3IFJlc29sdmVyc19FeHByZXNzaW9uUmVzb2x2ZXIocmVzb2x2ZXIsIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZSwgZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0X3RoaXMucmVzb2x2ZShrZXlwYXRoKTtcbiAgXHRcdH0pO1xuICBcdH1cbiAgfTtcblxuICBNZW1iZXJSZXNvbHZlci5wcm90b3R5cGUgPSB7XG4gIFx0cmVzb2x2ZTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGlmICh0aGlzLmtleXBhdGgpIHtcbiAgXHRcdFx0dGhpcy52aWV3bW9kZWwudW5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdFx0dGhpcy52YWx1ZSA9IHRoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdFx0dGhpcy5iaW5kKCk7XG5cbiAgXHRcdHRoaXMucmVzb2x2ZXIuYnViYmxlKCk7XG4gIFx0fSxcblxuICBcdGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMudmlld21vZGVsLnJlZ2lzdGVyKHRoaXMua2V5cGF0aCwgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdGlmICh0aGlzLnJlZlJlc29sdmVyKSB7XG4gIFx0XHRcdHRoaXMucmVmUmVzb2x2ZXIucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG4gIFx0XHR0aGlzLnJlc29sdmVyLmJ1YmJsZSgpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmtleXBhdGgpIHtcbiAgXHRcdFx0dGhpcy52aWV3bW9kZWwudW5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5yZWZSZXNvbHZlcikge1xuICBcdFx0XHR0aGlzLnJlZlJlc29sdmVyLnVuYmluZCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLnJlZlJlc29sdmVyKSB7XG4gIFx0XHRcdHRoaXMucmVmUmVzb2x2ZXIuZm9yY2VSZXNvbHV0aW9uKCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfTWVtYmVyUmVzb2x2ZXIgPSBNZW1iZXJSZXNvbHZlcjtcblxuICB2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24gKG11c3RhY2hlLCB0ZW1wbGF0ZSwgY2FsbGJhY2spIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHJhY3RpdmUsIHJlZiwga2V5cGF0aCwgcGFyZW50RnJhZ21lbnQ7XG5cbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQgPSBtdXN0YWNoZS5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlID0gbXVzdGFjaGUucm9vdDtcbiAgXHR0aGlzLm11c3RhY2hlID0gbXVzdGFjaGU7XG5cbiAgXHR0aGlzLnJlZiA9IHJlZiA9IHRlbXBsYXRlLnI7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIFx0dGhpcy51bnJlc29sdmVkID0gW107XG5cbiAgXHQvLyBGaW5kIGJhc2Uga2V5cGF0aFxuICBcdGlmIChrZXlwYXRoID0gc2hhcmVkX3Jlc29sdmVSZWYocmFjdGl2ZSwgcmVmLCBwYXJlbnRGcmFnbWVudCkpIHtcbiAgXHRcdHRoaXMuYmFzZSA9IGtleXBhdGg7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHRoaXMuYmFzZVJlc29sdmVyID0gbmV3IFJlc29sdmVyc19SZWZlcmVuY2VSZXNvbHZlcih0aGlzLCByZWYsIGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdF90aGlzLmJhc2UgPSBrZXlwYXRoO1xuICBcdFx0XHRfdGhpcy5iYXNlUmVzb2x2ZXIgPSBudWxsO1xuICBcdFx0XHRfdGhpcy5idWJibGUoKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdC8vIEZpbmQgdmFsdWVzIGZvciBtZW1iZXJzLCBvciBtYXJrIHRoZW0gYXMgdW5yZXNvbHZlZFxuICBcdHRoaXMubWVtYmVycyA9IHRlbXBsYXRlLm0ubWFwKGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICBcdFx0cmV0dXJuIG5ldyBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfTWVtYmVyUmVzb2x2ZXIodGVtcGxhdGUsIF90aGlzLCBwYXJlbnRGcmFnbWVudCk7XG4gIFx0fSk7XG5cbiAgXHR0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgXHR0aGlzLmJ1YmJsZSgpOyAvLyB0cmlnZ2VyIGluaXRpYWwgcmVzb2x1dGlvbiBpZiBwb3NzaWJsZVxuICB9O1xuXG4gIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlci5wcm90b3R5cGUgPSB7XG4gIFx0Z2V0S2V5cGF0aDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHZhbHVlcyA9IHRoaXMubWVtYmVycy5tYXAoUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9fZ2V0VmFsdWUpO1xuXG4gIFx0XHRpZiAoIXZhbHVlcy5ldmVyeShpc0RlZmluZWQpIHx8IHRoaXMuYmFzZVJlc29sdmVyKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5iYXNlLmpvaW4odmFsdWVzLmpvaW4oXCIuXCIpKTtcbiAgXHR9LFxuXG4gIFx0YnViYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMucmVhZHkgfHwgdGhpcy5iYXNlUmVzb2x2ZXIpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmNhbGxiYWNrKHRoaXMuZ2V0S2V5cGF0aCgpKTtcbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdH0sXG5cbiAgXHRyZWJpbmQ6IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0XHR2YXIgY2hhbmdlZDtcblxuICBcdFx0aWYgKHRoaXMuYmFzZSkge1xuICBcdFx0XHR2YXIgbmV3QmFzZSA9IHRoaXMuYmFzZS5yZXBsYWNlKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0XHRpZiAobmV3QmFzZSAmJiBuZXdCYXNlICE9PSB0aGlzLmJhc2UpIHtcbiAgXHRcdFx0XHR0aGlzLmJhc2UgPSBuZXdCYXNlO1xuICBcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMubWVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChtZW1iZXJzKSB7XG4gIFx0XHRcdGlmIChtZW1iZXJzLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSkge1xuICBcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKGNoYW5nZWQpIHtcbiAgXHRcdFx0dGhpcy5idWJibGUoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5iYXNlUmVzb2x2ZXIpIHtcbiAgXHRcdFx0dGhpcy5iYXNlID0gZ2V0S2V5cGF0aCh0aGlzLnJlZik7XG5cbiAgXHRcdFx0dGhpcy5iYXNlUmVzb2x2ZXIudW5iaW5kKCk7XG4gIFx0XHRcdHRoaXMuYmFzZVJlc29sdmVyID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5tZW1iZXJzLmZvckVhY2goZm9yY2VSZXNvbHV0aW9uKTtcbiAgXHRcdHRoaXMuYnViYmxlKCk7XG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcl9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfX2dldFZhbHVlKG1lbWJlcikge1xuICBcdHJldHVybiBtZW1iZXIudmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgXHRyZXR1cm4gdmFsdWUgIT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9yY2VSZXNvbHV0aW9uKG1lbWJlcikge1xuICBcdG1lbWJlci5mb3JjZVJlc29sdXRpb24oKTtcbiAgfVxuXG4gIHZhciBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyID0gUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyO1xuXG4gIHZhciBNdXN0YWNoZV9pbml0aWFsaXNlID0gTXVzdGFjaGUkaW5pdDtcbiAgZnVuY3Rpb24gTXVzdGFjaGUkaW5pdChtdXN0YWNoZSwgb3B0aW9ucykge1xuXG4gIFx0dmFyIHJlZiwgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlO1xuXG4gIFx0cGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuICBcdHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblxuICBcdG11c3RhY2hlLnJvb3QgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuICBcdG11c3RhY2hlLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG4gIFx0bXVzdGFjaGUucEVsZW1lbnQgPSBwYXJlbnRGcmFnbWVudC5wRWxlbWVudDtcblxuICBcdG11c3RhY2hlLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgXHRtdXN0YWNoZS5pbmRleCA9IG9wdGlvbnMuaW5kZXggfHwgMDtcbiAgXHRtdXN0YWNoZS5pc1N0YXRpYyA9IG9wdGlvbnMudGVtcGxhdGUucztcblxuICBcdG11c3RhY2hlLnR5cGUgPSBvcHRpb25zLnRlbXBsYXRlLnQ7XG5cbiAgXHRtdXN0YWNoZS5yZWdpc3RlcmVkID0gZmFsc2U7XG5cbiAgXHQvLyBpZiB0aGlzIGlzIGEgc2ltcGxlIG11c3RhY2hlLCB3aXRoIGEgcmVmZXJlbmNlLCB3ZSBqdXN0IG5lZWQgdG8gcmVzb2x2ZVxuICBcdC8vIHRoZSByZWZlcmVuY2UgdG8gYSBrZXlwYXRoXG4gIFx0aWYgKHJlZiA9IHRlbXBsYXRlLnIpIHtcbiAgXHRcdG11c3RhY2hlLnJlc29sdmVyID0gUmVzb2x2ZXJzX2NyZWF0ZVJlZmVyZW5jZVJlc29sdmVyKG11c3RhY2hlLCByZWYsIHJlc29sdmUpO1xuICBcdH1cblxuICBcdC8vIGlmIGl0J3MgYW4gZXhwcmVzc2lvbiwgd2UgaGF2ZSBhIGJpdCBtb3JlIHdvcmsgdG8gZG9cbiAgXHRpZiAob3B0aW9ucy50ZW1wbGF0ZS54KSB7XG4gIFx0XHRtdXN0YWNoZS5yZXNvbHZlciA9IG5ldyBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyKG11c3RhY2hlLCBwYXJlbnRGcmFnbWVudCwgb3B0aW9ucy50ZW1wbGF0ZS54LCByZXNvbHZlQW5kUmViaW5kQ2hpbGRyZW4pO1xuICBcdH1cblxuICBcdGlmIChvcHRpb25zLnRlbXBsYXRlLnJ4KSB7XG4gIFx0XHRtdXN0YWNoZS5yZXNvbHZlciA9IG5ldyBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXJfUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyKG11c3RhY2hlLCBvcHRpb25zLnRlbXBsYXRlLnJ4LCByZXNvbHZlQW5kUmViaW5kQ2hpbGRyZW4pO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIGludmVydGVkIHNlY3Rpb25zXG4gIFx0aWYgKG11c3RhY2hlLnRlbXBsYXRlLm4gPT09IFNFQ1RJT05fVU5MRVNTICYmICFtdXN0YWNoZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKSB7XG4gIFx0XHRtdXN0YWNoZS5zZXRWYWx1ZSh1bmRlZmluZWQpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIHJlc29sdmUoa2V5cGF0aCkge1xuICBcdFx0bXVzdGFjaGUucmVzb2x2ZShrZXlwYXRoKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiByZXNvbHZlQW5kUmViaW5kQ2hpbGRyZW4obmV3S2V5cGF0aCkge1xuICBcdFx0dmFyIG9sZEtleXBhdGggPSBtdXN0YWNoZS5rZXlwYXRoO1xuXG4gIFx0XHRpZiAobmV3S2V5cGF0aCAhPSBvbGRLZXlwYXRoKSB7XG4gIFx0XHRcdG11c3RhY2hlLnJlc29sdmUobmV3S2V5cGF0aCk7XG5cbiAgXHRcdFx0aWYgKG9sZEtleXBhdGggIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdG11c3RhY2hlLmZyYWdtZW50cyAmJiBtdXN0YWNoZS5mcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICBcdFx0XHRcdFx0Zi5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHRcdFx0fSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgTXVzdGFjaGVfcmVzb2x2ZSA9IE11c3RhY2hlJHJlc29sdmU7XG5cbiAgZnVuY3Rpb24gTXVzdGFjaGUkcmVzb2x2ZShrZXlwYXRoKSB7XG4gIFx0dmFyIHdhc1Jlc29sdmVkLCB2YWx1ZSwgdHdvd2F5QmluZGluZztcblxuICBcdC8vICdTcGVjaWFsJyBrZXlwYXRocywgZS5nLiBAZm9vIG9yIEA3LCBlbmNvZGUgYSB2YWx1ZVxuICBcdGlmIChrZXlwYXRoICYmIGtleXBhdGguaXNTcGVjaWFsKSB7XG4gIFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdFx0dGhpcy5zZXRWYWx1ZShrZXlwYXRoLnZhbHVlKTtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBJZiB3ZSByZXNvbHZlZCBwcmV2aW91c2x5LCB3ZSBuZWVkIHRvIHVucmVnaXN0ZXJcbiAgXHRpZiAodGhpcy5yZWdpc3RlcmVkKSB7XG4gIFx0XHQvLyB1bmRlZmluZWQgb3IgbnVsbFxuICBcdFx0dGhpcy5yb290LnZpZXdtb2RlbC51bnJlZ2lzdGVyKHRoaXMua2V5cGF0aCwgdGhpcyk7XG4gIFx0XHR0aGlzLnJlZ2lzdGVyZWQgPSBmYWxzZTtcblxuICBcdFx0d2FzUmVzb2x2ZWQgPSB0cnVlO1xuICBcdH1cblxuICBcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cbiAgXHQvLyBJZiB0aGUgbmV3IGtleXBhdGggZXhpc3RzLCB3ZSBuZWVkIHRvIHJlZ2lzdGVyXG4gIFx0Ly8gd2l0aCB0aGUgdmlld21vZGVsXG4gIFx0aWYgKGtleXBhdGggIT0gdW5kZWZpbmVkKSB7XG4gIFx0XHQvLyB1bmRlZmluZWQgb3IgbnVsbFxuICBcdFx0dmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldChrZXlwYXRoKTtcbiAgXHRcdHRoaXMucm9vdC52aWV3bW9kZWwucmVnaXN0ZXIoa2V5cGF0aCwgdGhpcyk7XG5cbiAgXHRcdHRoaXMucmVnaXN0ZXJlZCA9IHRydWU7XG4gIFx0fVxuXG4gIFx0Ly8gRWl0aGVyIHdheSB3ZSBuZWVkIHRvIHF1ZXVlIHVwIGEgcmVuZGVyIChgdmFsdWVgXG4gIFx0Ly8gd2lsbCBiZSBgdW5kZWZpbmVkYCBpZiB0aGVyZSdzIG5vIGtleXBhdGgpXG4gIFx0dGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG5cbiAgXHQvLyBUd28td2F5IGJpbmRpbmdzIG5lZWQgdG8gcG9pbnQgdG8gdGhlaXIgbmV3IHRhcmdldCBrZXlwYXRoXG4gIFx0aWYgKHdhc1Jlc29sdmVkICYmICh0d293YXlCaW5kaW5nID0gdGhpcy50d293YXlCaW5kaW5nKSkge1xuICBcdFx0dHdvd2F5QmluZGluZy5yZWJvdW5kKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIE11c3RhY2hlX3JlYmluZCA9IE11c3RhY2hlJHJlYmluZDtcblxuICBmdW5jdGlvbiBNdXN0YWNoZSRyZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdC8vIENoaWxkcmVuIGZpcnN0XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnRzKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gIFx0XHRcdHJldHVybiBmLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdC8vIEV4cHJlc3Npb24gbXVzdGFjaGU/XG4gIFx0aWYgKHRoaXMucmVzb2x2ZXIpIHtcbiAgXHRcdHRoaXMucmVzb2x2ZXIucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBNdXN0YWNoZSA9IHtcbiAgXHRnZXRWYWx1ZTogTXVzdGFjaGVfZ2V0VmFsdWUsXG4gIFx0aW5pdDogTXVzdGFjaGVfaW5pdGlhbGlzZSxcbiAgXHRyZXNvbHZlOiBNdXN0YWNoZV9yZXNvbHZlLFxuICBcdHJlYmluZDogTXVzdGFjaGVfcmViaW5kXG4gIH07XG5cbiAgdmFyIEludGVycG9sYXRvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy50eXBlID0gSU5URVJQT0xBVE9SO1xuICBcdE11c3RhY2hlLmluaXQodGhpcywgb3B0aW9ucyk7XG4gIH07XG5cbiAgSW50ZXJwb2xhdG9yLnByb3RvdHlwZSA9IHtcbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMubm9kZS5kYXRhID0gdGhpcy52YWx1ZSA9PSB1bmRlZmluZWQgPyBcIlwiIDogdGhpcy52YWx1ZTtcbiAgXHR9LFxuICBcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG4gIFx0cmViaW5kOiBNdXN0YWNoZS5yZWJpbmQsXG4gIFx0ZGV0YWNoOiBzaGFyZWRfZGV0YWNoLFxuXG4gIFx0dW5iaW5kOiBzaGFyZWRfdW5iaW5kLFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoIXRoaXMubm9kZSkge1xuICBcdFx0XHR0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzYWZlVG9TdHJpbmdWYWx1ZSh0aGlzLnZhbHVlKSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0aWYgKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdFx0ZGV0YWNoTm9kZSh0aGlzLm5vZGUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG5cbiAgXHQvLyBURU1QXG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0dmFyIHdyYXBwZXI7XG5cbiAgXHRcdC8vIFRPRE8gaXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGFwcHJvYWNoIHRoaXM/XG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoICYmICh3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkW3RoaXMua2V5cGF0aC5zdHJdKSkge1xuICBcdFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghaXNFcXVhbCh2YWx1ZSwgdGhpcy52YWx1ZSkpIHtcbiAgXHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICBcdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXG4gIFx0XHRcdGlmICh0aGlzLm5vZGUpIHtcbiAgXHRcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdGZpcnN0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uIChlc2NhcGUpIHtcbiAgXHRcdHZhciBzdHJpbmcgPSBcIlwiICsgc2FmZVRvU3RyaW5nVmFsdWUodGhpcy52YWx1ZSk7XG4gIFx0XHRyZXR1cm4gZXNjYXBlID8gZXNjYXBlSHRtbChzdHJpbmcpIDogc3RyaW5nO1xuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfSW50ZXJwb2xhdG9yID0gSW50ZXJwb2xhdG9yO1xuXG4gIHZhciBTZWN0aW9uX3Byb3RvdHlwZV9idWJibGUgPSBTZWN0aW9uJGJ1YmJsZTtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGJ1YmJsZSgpIHtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuICB9XG5cbiAgdmFyIFNlY3Rpb25fcHJvdG90eXBlX2RldGFjaCA9IFNlY3Rpb24kZGV0YWNoO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZGV0YWNoKCkge1xuICBcdHZhciBkb2NGcmFnO1xuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA9PT0gMSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnRzWzBdLmRldGFjaCgpO1xuICBcdH1cblxuICBcdGRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgXHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHRkb2NGcmFnLmFwcGVuZENoaWxkKGl0ZW0uZGV0YWNoKCkpO1xuICBcdH0pO1xuXG4gIFx0cmV0dXJuIGRvY0ZyYWc7XG4gIH1cblxuICB2YXIgZmluZCA9IFNlY3Rpb24kZmluZDtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGZpbmQoc2VsZWN0b3IpIHtcbiAgXHR2YXIgaSwgbGVuLCBxdWVyeVJlc3VsdDtcblxuICBcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdGlmIChxdWVyeVJlc3VsdCA9IHRoaXMuZnJhZ21lbnRzW2ldLmZpbmQoc2VsZWN0b3IpKSB7XG4gIFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBmaW5kQWxsID0gU2VjdGlvbiRmaW5kQWxsO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kZmluZEFsbChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHR2YXIgaSwgbGVuO1xuXG4gIFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0dGhpcy5mcmFnbWVudHNbaV0uZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBmaW5kQWxsQ29tcG9uZW50cyA9IFNlY3Rpb24kZmluZEFsbENvbXBvbmVudHM7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRmaW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHR2YXIgaSwgbGVuO1xuXG4gIFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0dGhpcy5mcmFnbWVudHNbaV0uZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9XG4gIH1cblxuICB2YXIgZmluZENvbXBvbmVudCA9IFNlY3Rpb24kZmluZENvbXBvbmVudDtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGZpbmRDb21wb25lbnQoc2VsZWN0b3IpIHtcbiAgXHR2YXIgaSwgbGVuLCBxdWVyeVJlc3VsdDtcblxuICBcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgXHRcdGlmIChxdWVyeVJlc3VsdCA9IHRoaXMuZnJhZ21lbnRzW2ldLmZpbmRDb21wb25lbnQoc2VsZWN0b3IpKSB7XG4gIFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBmaW5kTmV4dE5vZGUgPSBTZWN0aW9uJGZpbmROZXh0Tm9kZTtcblxuICBmdW5jdGlvbiBTZWN0aW9uJGZpbmROZXh0Tm9kZShmcmFnbWVudCkge1xuICBcdGlmICh0aGlzLmZyYWdtZW50c1tmcmFnbWVudC5pbmRleCArIDFdKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudHNbZnJhZ21lbnQuaW5kZXggKyAxXS5maXJzdE5vZGUoKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIH1cblxuICB2YXIgZmlyc3ROb2RlID0gU2VjdGlvbiRmaXJzdE5vZGU7XG5cbiAgZnVuY3Rpb24gU2VjdGlvbiRmaXJzdE5vZGUoKSB7XG4gIFx0dmFyIGxlbiwgaSwgbm9kZTtcblxuICBcdGlmIChsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRpZiAobm9kZSA9IHRoaXMuZnJhZ21lbnRzW2ldLmZpcnN0Tm9kZSgpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIG5vZGU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIH1cblxuICB2YXIgc2h1ZmZsZSA9IFNlY3Rpb24kc2h1ZmZsZTtcblxuICBmdW5jdGlvbiBTZWN0aW9uJHNodWZmbGUobmV3SW5kaWNlcykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgcGFyZW50RnJhZ21lbnQsIGZpcnN0Q2hhbmdlLCBpLCBuZXdMZW5ndGgsIHJlYm91bmRGcmFnbWVudHMsIGZyYWdtZW50T3B0aW9ucywgZnJhZ21lbnQ7XG5cbiAgXHQvLyBzaG9ydCBjaXJjdWl0IGFueSBkb3VibGUtdXBkYXRlcywgYW5kIGVuc3VyZSB0aGF0IHRoaXMgaXNuJ3QgYXBwbGllZCB0b1xuICBcdC8vIG5vbi1saXN0IHNlY3Rpb25zXG4gIFx0aWYgKHRoaXMuc2h1ZmZsaW5nIHx8IHRoaXMudW5ib3VuZCB8fCB0aGlzLmN1cnJlbnRTdWJ0eXBlICE9PSBTRUNUSU9OX0VBQ0gpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHR0aGlzLnNodWZmbGluZyA9IHRydWU7XG4gIFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBfdGhpcy5zaHVmZmxpbmcgPSBmYWxzZTtcbiAgXHR9KTtcblxuICBcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudDtcblxuICBcdHJlYm91bmRGcmFnbWVudHMgPSBbXTtcblxuICBcdC8vIFRPRE86IG5lZWQgdG8gdXBkYXRlIHRoaXNcbiAgXHQvLyBmaXJzdCwgcmViaW5kIGV4aXN0aW5nIGZyYWdtZW50c1xuICBcdG5ld0luZGljZXMuZm9yRWFjaChmdW5jdGlvbiAobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gIFx0XHR2YXIgZnJhZ21lbnQsIGJ5LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoLCBkZXBzO1xuXG4gIFx0XHRpZiAobmV3SW5kZXggPT09IG9sZEluZGV4KSB7XG4gIFx0XHRcdHJlYm91bmRGcmFnbWVudHNbbmV3SW5kZXhdID0gX3RoaXMuZnJhZ21lbnRzW29sZEluZGV4XTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRmcmFnbWVudCA9IF90aGlzLmZyYWdtZW50c1tvbGRJbmRleF07XG5cbiAgXHRcdGlmIChmaXJzdENoYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdGZpcnN0Q2hhbmdlID0gb2xkSW5kZXg7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGRvZXMgdGhpcyBmcmFnbWVudCBuZWVkIHRvIGJlIHRvcm4gZG93bj9cbiAgXHRcdGlmIChuZXdJbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0X3RoaXMuZnJhZ21lbnRzVG9VbnJlbmRlci5wdXNoKGZyYWdtZW50KTtcbiAgXHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gT3RoZXJ3aXNlLCBpdCBuZWVkcyB0byBiZSByZWJvdW5kIHRvIGEgbmV3IGluZGV4XG4gIFx0XHRieSA9IG5ld0luZGV4IC0gb2xkSW5kZXg7XG4gIFx0XHRvbGRLZXlwYXRoID0gX3RoaXMua2V5cGF0aC5qb2luKG9sZEluZGV4KTtcbiAgXHRcdG5ld0tleXBhdGggPSBfdGhpcy5rZXlwYXRoLmpvaW4obmV3SW5kZXgpO1xuXG4gIFx0XHRmcmFnbWVudC5pbmRleCA9IG5ld0luZGV4O1xuXG4gIFx0XHQvLyBub3RpZnkgYW55IHJlZ2lzdGVyZWQgaW5kZXggcmVmcyBkaXJlY3RseVxuICBcdFx0aWYgKGRlcHMgPSBmcmFnbWVudC5yZWdpc3RlcmVkSW5kZXhSZWZzKSB7XG4gIFx0XHRcdGRlcHMuZm9yRWFjaChzaHVmZmxlX19ibGluZFJlYmluZCk7XG4gIFx0XHR9XG5cbiAgXHRcdGZyYWdtZW50LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdHJlYm91bmRGcmFnbWVudHNbbmV3SW5kZXhdID0gZnJhZ21lbnQ7XG4gIFx0fSk7XG5cbiAgXHRuZXdMZW5ndGggPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLmtleXBhdGgpLmxlbmd0aDtcblxuICBcdC8vIElmIG5vdGhpbmcgY2hhbmdlZCB3aXRoIHRoZSBleGlzdGluZyBmcmFnbWVudHMsIHRoZW4gd2Ugc3RhcnQgYWRkaW5nXG4gIFx0Ly8gbmV3IGZyYWdtZW50cyBhdCB0aGUgZW5kLi4uXG4gIFx0aWYgKGZpcnN0Q2hhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdC8vIC4uLnVubGVzcyB0aGVyZSBhcmUgbm8gbmV3IGZyYWdtZW50cyB0byBhZGRcbiAgXHRcdGlmICh0aGlzLmxlbmd0aCA9PT0gbmV3TGVuZ3RoKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Zmlyc3RDaGFuZ2UgPSB0aGlzLmxlbmd0aDtcbiAgXHR9XG5cbiAgXHR0aGlzLmxlbmd0aCA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA9IG5ld0xlbmd0aDtcblxuICBcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdH1cblxuICBcdC8vIFByZXBhcmUgbmV3IGZyYWdtZW50IG9wdGlvbnNcbiAgXHRmcmFnbWVudE9wdGlvbnMgPSB7XG4gIFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZS5mLFxuICBcdFx0cm9vdDogdGhpcy5yb290LFxuICBcdFx0b3duZXI6IHRoaXNcbiAgXHR9O1xuXG4gIFx0Ly8gQWRkIGFzIG1hbnkgbmV3IGZyYWdtZW50cyBhcyB3ZSBuZWVkIHRvLCBvciBhZGQgYmFjayBleGlzdGluZ1xuICBcdC8vIChkZXRhY2hlZCkgZnJhZ21lbnRzXG4gIFx0Zm9yIChpID0gZmlyc3RDaGFuZ2U7IGkgPCBuZXdMZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0ZnJhZ21lbnQgPSByZWJvdW5kRnJhZ21lbnRzW2ldO1xuXG4gIFx0XHRpZiAoIWZyYWdtZW50KSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUucHVzaChpKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5mcmFnbWVudHNbaV0gPSBmcmFnbWVudDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBzaHVmZmxlX19ibGluZFJlYmluZChkZXApIHtcbiAgXHQvLyB0aGUga2V5cGF0aCBkb2Vzbid0IGFjdHVhbGx5IG1hdHRlciBoZXJlIGFzIGl0IHdvbid0IGhhdmUgY2hhbmdlZFxuICBcdGRlcC5yZWJpbmQoXCJcIiwgXCJcIik7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3JlYmluZCA9IGZ1bmN0aW9uIChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0TXVzdGFjaGUucmViaW5kLmNhbGwodGhpcywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIH07XG5cbiAgdmFyIFNlY3Rpb25fcHJvdG90eXBlX3JlbmRlciA9IFNlY3Rpb24kcmVuZGVyO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kcmVuZGVyKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR0aGlzLmRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgXHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gIFx0XHRyZXR1cm4gX3RoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZChmLnJlbmRlcigpKTtcbiAgXHR9KTtcblxuICBcdHRoaXMucmVuZGVyZWRGcmFnbWVudHMgPSB0aGlzLmZyYWdtZW50cy5zbGljZSgpO1xuICBcdHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIgPSBbXTtcblxuICBcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdHJldHVybiB0aGlzLmRvY0ZyYWc7XG4gIH1cblxuICB2YXIgc2V0VmFsdWUgPSBTZWN0aW9uJHNldFZhbHVlO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kc2V0VmFsdWUodmFsdWUpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dmFyIHdyYXBwZXIsIGZyYWdtZW50T3B0aW9ucztcblxuICBcdGlmICh0aGlzLnVwZGF0aW5nKSB7XG4gIFx0XHQvLyBJZiBhIGNoaWxkIG9mIHRoaXMgc2VjdGlvbiBjYXVzZXMgYSByZS1ldmFsdWF0aW9uIC0gZm9yIGV4YW1wbGUsIGFuXG4gIFx0XHQvLyBleHByZXNzaW9uIHJlZmVycyB0byBhIGZ1bmN0aW9uIHRoYXQgbXV0YXRlcyB0aGUgYXJyYXkgdGhhdCB0aGlzXG4gIFx0XHQvLyBzZWN0aW9uIGRlcGVuZHMgb24gLSB3ZSdsbCBlbmQgdXAgd2l0aCBhIGRvdWJsZSByZW5kZXJpbmcgYnVnIChzZWVcbiAgXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMvNzQ4KS4gVGhpcyBwcmV2ZW50cyBpdC5cbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblxuICBcdC8vIHdpdGggc2VjdGlvbnMsIHdlIG5lZWQgdG8gZ2V0IHRoZSBmYWtlIHZhbHVlIGlmIHdlIGhhdmUgYSB3cmFwcGVkIG9iamVjdFxuICBcdGlmICh0aGlzLmtleXBhdGggJiYgKHdyYXBwZXIgPSB0aGlzLnJvb3Qudmlld21vZGVsLndyYXBwZWRbdGhpcy5rZXlwYXRoLnN0cl0pKSB7XG4gIFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG4gIFx0fVxuXG4gIFx0Ly8gSWYgYW55IGZyYWdtZW50cyBhcmUgYXdhaXRpbmcgY3JlYXRpb24gYWZ0ZXIgYSBzcGxpY2UsXG4gIFx0Ly8gdGhpcyBpcyB0aGUgcGxhY2UgdG8gZG8gaXRcbiAgXHRpZiAodGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5sZW5ndGgpIHtcbiAgXHRcdGZyYWdtZW50T3B0aW9ucyA9IHtcbiAgXHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUuZiB8fCBbXSxcbiAgXHRcdFx0cm9vdDogdGhpcy5yb290LFxuICBcdFx0XHRwRWxlbWVudDogdGhpcy5wRWxlbWVudCxcbiAgXHRcdFx0b3duZXI6IHRoaXNcbiAgXHRcdH07XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgXHRcdFx0dmFyIGZyYWdtZW50O1xuXG4gIFx0XHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gX3RoaXMua2V5cGF0aC5qb2luKGluZGV4KTtcbiAgXHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gaW5kZXg7XG5cbiAgXHRcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudChmcmFnbWVudE9wdGlvbnMpO1xuICBcdFx0XHRfdGhpcy5mcmFnbWVudHNUb1JlbmRlci5wdXNoKF90aGlzLmZyYWdtZW50c1tpbmRleF0gPSBmcmFnbWVudCk7XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5sZW5ndGggPSAwO1xuICBcdH0gZWxzZSBpZiAocmVldmFsdWF0ZVNlY3Rpb24odGhpcywgdmFsdWUpKSB7XG4gIFx0XHR0aGlzLmJ1YmJsZSgpO1xuXG4gIFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgXHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjaGFuZ2VDdXJyZW50U3VidHlwZShzZWN0aW9uLCB2YWx1ZSwgb2JqKSB7XG4gIFx0aWYgKHZhbHVlID09PSBTRUNUSU9OX0VBQ0gpIHtcbiAgXHRcdC8vIG1ha2Ugc3VyZSByZWYgdHlwZSBpcyB1cCB0byBkYXRlIGZvciBrZXkgb3IgdmFsdWUgaW5kaWNlc1xuICBcdFx0aWYgKHNlY3Rpb24uaW5kZXhSZWZzICYmIHNlY3Rpb24uaW5kZXhSZWZzWzBdKSB7XG4gIFx0XHRcdHZhciByZWYgPSBzZWN0aW9uLmluZGV4UmVmc1swXTtcblxuICBcdFx0XHQvLyB3aGVuIHN3aXRjaGluZyBmbGF2b3JzLCBtYWtlIHN1cmUgdGhlIHNlY3Rpb24gZ2V0cyB1cGRhdGVkXG4gIFx0XHRcdGlmIChvYmogJiYgcmVmLnQgPT09IFwiaVwiIHx8ICFvYmogJiYgcmVmLnQgPT09IFwia1wiKSB7XG4gIFx0XHRcdFx0Ly8gaWYgc3dpdGNoaW5nIGZyb20gb2JqZWN0IHRvIGxpc3QsIHVuYmluZCBhbGwgb2YgdGhlIG9sZCBmcmFnbWVudHNcbiAgXHRcdFx0XHRpZiAoIW9iaikge1xuICBcdFx0XHRcdFx0c2VjdGlvbi5sZW5ndGggPSAwO1xuICBcdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyID0gc2VjdGlvbi5mcmFnbWVudHMuc2xpY2UoMCk7XG4gIFx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICBcdFx0XHRcdFx0XHRyZXR1cm4gZi51bmJpbmQoKTtcbiAgXHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJlZi50ID0gb2JqID8gXCJrXCIgOiBcImlcIjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRzZWN0aW9uLmN1cnJlbnRTdWJ0eXBlID0gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiByZWV2YWx1YXRlU2VjdGlvbihzZWN0aW9uLCB2YWx1ZSkge1xuICBcdHZhciBmcmFnbWVudE9wdGlvbnMgPSB7XG4gIFx0XHR0ZW1wbGF0ZTogc2VjdGlvbi50ZW1wbGF0ZS5mIHx8IFtdLFxuICBcdFx0cm9vdDogc2VjdGlvbi5yb290LFxuICBcdFx0cEVsZW1lbnQ6IHNlY3Rpb24ucGFyZW50RnJhZ21lbnQucEVsZW1lbnQsXG4gIFx0XHRvd25lcjogc2VjdGlvblxuICBcdH07XG5cbiAgXHRzZWN0aW9uLmhhc0NvbnRleHQgPSB0cnVlO1xuXG4gIFx0Ly8gSWYgd2UgYWxyZWFkeSBrbm93IHRoZSBzZWN0aW9uIHR5cGUsIGdyZWF0XG4gIFx0Ly8gVE9ETyBjYW4gdGhpcyBiZSBvcHRpbWlzZWQ/IGkuZS4gcGljayBhbiByZWV2YWx1YXRlU2VjdGlvbiBmdW5jdGlvbiBkdXJpbmcgaW5pdFxuICBcdC8vIGFuZCBhdm9pZCBkb2luZyB0aGlzIGVhY2ggdGltZT9cbiAgXHRpZiAoc2VjdGlvbi5zdWJ0eXBlKSB7XG4gIFx0XHRzd2l0Y2ggKHNlY3Rpb24uc3VidHlwZSkge1xuICBcdFx0XHRjYXNlIFNFQ1RJT05fSUY6XG4gIFx0XHRcdFx0c2VjdGlvbi5oYXNDb250ZXh0ID0gZmFsc2U7XG4gIFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZhbHNlLCBmcmFnbWVudE9wdGlvbnMpO1xuXG4gIFx0XHRcdGNhc2UgU0VDVElPTl9VTkxFU1M6XG4gIFx0XHRcdFx0c2VjdGlvbi5oYXNDb250ZXh0ID0gZmFsc2U7XG4gIFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIHRydWUsIGZyYWdtZW50T3B0aW9ucyk7XG5cbiAgXHRcdFx0Y2FzZSBTRUNUSU9OX1dJVEg6XG4gIFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbihzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMpO1xuXG4gIFx0XHRcdGNhc2UgU0VDVElPTl9JRl9XSVRIOlxuICBcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxDb250ZXh0U2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zKTtcblxuICBcdFx0XHRjYXNlIFNFQ1RJT05fRUFDSDpcbiAgXHRcdFx0XHRpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gIFx0XHRcdFx0XHRjaGFuZ2VDdXJyZW50U3VidHlwZShzZWN0aW9uLCBzZWN0aW9uLnN1YnR5cGUsIHRydWUpO1xuICBcdFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVMaXN0T2JqZWN0U2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyBGYWxsdGhyb3VnaCAtIGlmIGl0J3MgYSBjb25kaXRpb25hbCBvciBhbiBhcnJheSB3ZSBuZWVkIHRvIGNvbnRpbnVlXG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gd29yayBvdXQgd2hhdCBzb3J0IG9mIHNlY3Rpb24gd2UncmUgZGVhbGluZyB3aXRoXG4gIFx0c2VjdGlvbi5vcmRlcmVkID0gISFpc0FycmF5TGlrZSh2YWx1ZSk7XG5cbiAgXHQvLyBPcmRlcmVkIGxpc3Qgc2VjdGlvblxuICBcdGlmIChzZWN0aW9uLm9yZGVyZWQpIHtcbiAgXHRcdGNoYW5nZUN1cnJlbnRTdWJ0eXBlKHNlY3Rpb24sIFNFQ1RJT05fRUFDSCwgZmFsc2UpO1xuICBcdFx0cmV0dXJuIHJlZXZhbHVhdGVMaXN0U2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zKTtcbiAgXHR9XG5cbiAgXHQvLyBVbm9yZGVyZWQgbGlzdCwgb3IgY29udGV4dFxuICBcdGlmIChpc09iamVjdCh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdC8vIEluZGV4IHJlZmVyZW5jZSBpbmRpY2F0ZXMgc2VjdGlvbiBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIGxpc3RcbiAgXHRcdGlmIChzZWN0aW9uLnRlbXBsYXRlLmkpIHtcbiAgXHRcdFx0Y2hhbmdlQ3VycmVudFN1YnR5cGUoc2VjdGlvbiwgU0VDVElPTl9FQUNILCB0cnVlKTtcbiAgXHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVMaXN0T2JqZWN0U2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gT3RoZXJ3aXNlLCBvYmplY3QgcHJvdmlkZXMgY29udGV4dCBmb3IgY29udGVudHNcbiAgXHRcdGNoYW5nZUN1cnJlbnRTdWJ0eXBlKHNlY3Rpb24sIFNFQ1RJT05fV0lUSCwgZmFsc2UpO1xuICBcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbihzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMpO1xuICBcdH1cblxuICBcdC8vIENvbmRpdGlvbmFsIHNlY3Rpb25cbiAgXHRjaGFuZ2VDdXJyZW50U3VidHlwZShzZWN0aW9uLCBTRUNUSU9OX0lGLCBmYWxzZSk7XG4gIFx0c2VjdGlvbi5oYXNDb250ZXh0ID0gZmFsc2U7XG4gIFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZhbHNlLCBmcmFnbWVudE9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZUxpc3RTZWN0aW9uKHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMpIHtcbiAgXHR2YXIgaSwgbGVuZ3RoLCBmcmFnbWVudDtcblxuICBcdGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICBcdGlmIChsZW5ndGggPT09IHNlY3Rpb24ubGVuZ3RoKSB7XG4gIFx0XHQvLyBOb3RoaW5nIHRvIGRvXG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgdGhlIGFycmF5IGlzIHNob3J0ZXIgdGhhbiBpdCB3YXMgcHJldmlvdXNseSwgcmVtb3ZlIGl0ZW1zXG4gIFx0aWYgKGxlbmd0aCA8IHNlY3Rpb24ubGVuZ3RoKSB7XG4gIFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UobGVuZ3RoLCBzZWN0aW9uLmxlbmd0aCAtIGxlbmd0aCk7XG4gIFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdH1cblxuICBcdC8vIG90aGVyd2lzZS4uLlxuICBcdGVsc2Uge1xuICBcdFx0aWYgKGxlbmd0aCA+IHNlY3Rpb24ubGVuZ3RoKSB7XG4gIFx0XHRcdC8vIGFkZCBhbnkgbmV3IG9uZXNcbiAgXHRcdFx0Zm9yIChpID0gc2VjdGlvbi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICBcdFx0XHRcdC8vIGFwcGVuZCBsaXN0IGl0ZW0gdG8gY29udGV4dCBzdGFja1xuICBcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gc2VjdGlvbi5rZXlwYXRoLmpvaW4oaSk7XG4gIFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gaTtcblxuICBcdFx0XHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoZnJhZ21lbnRPcHRpb25zKTtcbiAgXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goc2VjdGlvbi5mcmFnbWVudHNbaV0gPSBmcmFnbWVudCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRzZWN0aW9uLmxlbmd0aCA9IGxlbmd0aDtcbiAgXHRyZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVMaXN0T2JqZWN0U2VjdGlvbihzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zKSB7XG4gIFx0dmFyIGlkLCBpLCBoYXNLZXksIGZyYWdtZW50LCBjaGFuZ2VkLCBkZXBzO1xuXG4gIFx0aGFzS2V5ID0gc2VjdGlvbi5oYXNLZXkgfHwgKHNlY3Rpb24uaGFzS2V5ID0ge30pO1xuXG4gIFx0Ly8gcmVtb3ZlIGFueSBmcmFnbWVudHMgdGhhdCBzaG91bGQgbm8gbG9uZ2VyIGV4aXN0XG4gIFx0aSA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRmcmFnbWVudCA9IHNlY3Rpb24uZnJhZ21lbnRzW2ldO1xuXG4gIFx0XHRpZiAoIShmcmFnbWVudC5rZXkgaW4gdmFsdWUpKSB7XG4gIFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXG4gIFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuICBcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIucHVzaChmcmFnbWVudCk7XG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZShpLCAxKTtcblxuICBcdFx0XHRoYXNLZXlbZnJhZ21lbnQua2V5XSA9IGZhbHNlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIG5vdGlmeSBhbnkgZGVwZW5kZW50cyBhYm91dCBjaGFuZ2VkIGluZGljZXNcbiAgXHRpID0gc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGZyYWdtZW50ID0gc2VjdGlvbi5mcmFnbWVudHNbaV07XG5cbiAgXHRcdGlmIChmcmFnbWVudC5pbmRleCAhPT0gaSkge1xuICBcdFx0XHRmcmFnbWVudC5pbmRleCA9IGk7XG4gIFx0XHRcdGlmIChkZXBzID0gZnJhZ21lbnQucmVnaXN0ZXJlZEluZGV4UmVmcykge1xuICBcdFx0XHRcdGRlcHMuZm9yRWFjaChzZXRWYWx1ZV9fYmxpbmRSZWJpbmQpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gYWRkIGFueSB0aGF0IGhhdmVuJ3QgYmVlbiBjcmVhdGVkIHlldFxuICBcdGkgPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0Zm9yIChpZCBpbiB2YWx1ZSkge1xuICBcdFx0aWYgKCFoYXNLZXlbaWRdKSB7XG4gIFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXG4gIFx0XHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gc2VjdGlvbi5rZXlwYXRoLmpvaW4oaWQpO1xuICBcdFx0XHRmcmFnbWVudE9wdGlvbnMua2V5ID0gaWQ7XG4gIFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IGkrKztcblxuICBcdFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KGZyYWdtZW50T3B0aW9ucyk7XG5cbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKGZyYWdtZW50KTtcbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHMucHVzaChmcmFnbWVudCk7XG4gIFx0XHRcdGhhc0tleVtpZF0gPSB0cnVlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHNlY3Rpb24ubGVuZ3RoID0gc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoO1xuICBcdHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZUNvbmRpdGlvbmFsQ29udGV4dFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucykge1xuICBcdGlmICh2YWx1ZSkge1xuICBcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbihzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gcmVtb3ZlU2VjdGlvbkZyYWdtZW50cyhzZWN0aW9uKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zKSB7XG4gIFx0dmFyIGZyYWdtZW50O1xuXG4gIFx0Ly8gLi4udGhlbiBpZiBpdCBpc24ndCByZW5kZXJlZCwgcmVuZGVyIGl0LCBhZGRpbmcgc2VjdGlvbi5rZXlwYXRoIHRvIHRoZSBjb250ZXh0IHN0YWNrXG4gIFx0Ly8gKGlmIGl0IGlzIGFscmVhZHkgcmVuZGVyZWQsIHRoZW4gYW55IGNoaWxkcmVuIGRlcGVuZGVudCBvbiB0aGUgY29udGV4dCBzdGFja1xuICBcdC8vIHdpbGwgdXBkYXRlIHRoZW1zZWx2ZXMgd2l0aG91dCBhbnkgcHJvbXB0aW5nKVxuICBcdGlmICghc2VjdGlvbi5sZW5ndGgpIHtcbiAgXHRcdC8vIGFwcGVuZCB0aGlzIHNlY3Rpb24gdG8gdGhlIGNvbnRleHQgc3RhY2tcbiAgXHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gc2VjdGlvbi5rZXlwYXRoO1xuICBcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gMDtcblxuICBcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudChmcmFnbWVudE9wdGlvbnMpO1xuXG4gIFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goc2VjdGlvbi5mcmFnbWVudHNbMF0gPSBmcmFnbWVudCk7XG4gIFx0XHRzZWN0aW9uLmxlbmd0aCA9IDE7XG5cbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oc2VjdGlvbiwgdmFsdWUsIGludmVydGVkLCBmcmFnbWVudE9wdGlvbnMpIHtcbiAgXHR2YXIgZG9SZW5kZXIsIGVtcHR5QXJyYXksIGVtcHR5T2JqZWN0LCBmcmFnbWVudCwgbmFtZTtcblxuICBcdGVtcHR5QXJyYXkgPSBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwO1xuICBcdGVtcHR5T2JqZWN0ID0gZmFsc2U7XG4gIFx0aWYgKCFpc0FycmF5TGlrZSh2YWx1ZSkgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gIFx0XHRlbXB0eU9iamVjdCA9IHRydWU7XG4gIFx0XHRmb3IgKG5hbWUgaW4gdmFsdWUpIHtcbiAgXHRcdFx0ZW1wdHlPYmplY3QgPSBmYWxzZTtcbiAgXHRcdFx0YnJlYWs7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKGludmVydGVkKSB7XG4gIFx0XHRkb1JlbmRlciA9IGVtcHR5QXJyYXkgfHwgZW1wdHlPYmplY3QgfHwgIXZhbHVlO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRkb1JlbmRlciA9IHZhbHVlICYmICFlbXB0eUFycmF5ICYmICFlbXB0eU9iamVjdDtcbiAgXHR9XG5cbiAgXHRpZiAoZG9SZW5kZXIpIHtcbiAgXHRcdGlmICghc2VjdGlvbi5sZW5ndGgpIHtcbiAgXHRcdFx0Ly8gbm8gY2hhbmdlIHRvIGNvbnRleHQgc3RhY2tcbiAgXHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gMDtcblxuICBcdFx0XHRmcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KGZyYWdtZW50T3B0aW9ucyk7XG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaChzZWN0aW9uLmZyYWdtZW50c1swXSA9IGZyYWdtZW50KTtcbiAgXHRcdFx0c2VjdGlvbi5sZW5ndGggPSAxO1xuXG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoc2VjdGlvbi5sZW5ndGggPiAxKSB7XG4gIFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSgxKTtcbiAgXHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcblxuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIHJlbW92ZVNlY3Rpb25GcmFnbWVudHMoc2VjdGlvbik7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlU2VjdGlvbkZyYWdtZW50cyhzZWN0aW9uKSB7XG4gIFx0aWYgKHNlY3Rpb24ubGVuZ3RoKSB7XG4gIFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoMCwgc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoKS5maWx0ZXIoaXNSZW5kZXJlZCk7XG4gIFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdFx0c2VjdGlvbi5sZW5ndGggPSBzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLmxlbmd0aCA9IDA7XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBpc1JlbmRlcmVkKGZyYWdtZW50KSB7XG4gIFx0cmV0dXJuIGZyYWdtZW50LnJlbmRlcmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0VmFsdWVfX2JsaW5kUmViaW5kKGRlcCkge1xuICBcdC8vIHRoZSBrZXlwYXRoIGRvZXNuJ3QgYWN0dWFsbHkgbWF0dGVyIGhlcmUgYXMgaXQgd29uJ3QgaGF2ZSBjaGFuZ2VkXG4gIFx0ZGVwLnJlYmluZChcIlwiLCBcIlwiKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdG9TdHJpbmcgPSBTZWN0aW9uJHRvU3RyaW5nO1xuXG4gIGZ1bmN0aW9uIFNlY3Rpb24kdG9TdHJpbmcoZXNjYXBlKSB7XG4gIFx0dmFyIHN0ciwgaSwgbGVuO1xuXG4gIFx0c3RyID0gXCJcIjtcblxuICBcdGkgPSAwO1xuICBcdGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRzdHIgKz0gdGhpcy5mcmFnbWVudHNbaV0udG9TdHJpbmcoZXNjYXBlKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV91bmJpbmQgPSBTZWN0aW9uJHVuYmluZDtcbiAgZnVuY3Rpb24gU2VjdGlvbiR1bmJpbmQoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2gobWV0aG9kQ2FsbGVyc19fdW5iaW5kKTtcbiAgXHR0aGlzLmZyYWdtZW50c1RvUmVuZGVyLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgXHRcdHJldHVybiByZW1vdmVGcm9tQXJyYXkoX3RoaXMuZnJhZ21lbnRzLCBmKTtcbiAgXHR9KTtcbiAgXHR0aGlzLmZyYWdtZW50c1RvUmVuZGVyID0gW107XG4gIFx0c2hhcmVkX3VuYmluZC5jYWxsKHRoaXMpO1xuXG4gIFx0dGhpcy5sZW5ndGggPSAwO1xuICBcdHRoaXMudW5ib3VuZCA9IHRydWU7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3VucmVuZGVyID0gU2VjdGlvbiR1bnJlbmRlcjtcblxuICBmdW5jdGlvbiBTZWN0aW9uJHVucmVuZGVyKHNob3VsZERlc3Ryb3kpIHtcbiAgXHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKHNob3VsZERlc3Ryb3kgPyB1bnJlbmRlckFuZERlc3Ryb3kgOiBwcm90b3R5cGVfdW5yZW5kZXJfX3VucmVuZGVyKTtcbiAgXHR0aGlzLnJlbmRlcmVkRnJhZ21lbnRzID0gW107XG4gIFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5yZW5kZXJBbmREZXN0cm95KGZyYWdtZW50KSB7XG4gIFx0ZnJhZ21lbnQudW5yZW5kZXIodHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm90b3R5cGVfdW5yZW5kZXJfX3VucmVuZGVyKGZyYWdtZW50KSB7XG4gIFx0ZnJhZ21lbnQudW5yZW5kZXIoZmFsc2UpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV91cGRhdGUgPSBTZWN0aW9uJHVwZGF0ZTtcblxuICBmdW5jdGlvbiBTZWN0aW9uJHVwZGF0ZSgpIHtcbiAgXHR2YXIgZnJhZ21lbnQsIHJlbmRlckluZGV4LCByZW5kZXJlZEZyYWdtZW50cywgYW5jaG9yLCB0YXJnZXQsIGksIGxlbjtcblxuICBcdC8vIGB0aGlzLnJlbmRlcmVkRnJhZ21lbnRzYCBpcyBpbiB0aGUgb3JkZXIgb2YgdGhlIHByZXZpb3VzIHJlbmRlci5cbiAgXHQvLyBJZiBmcmFnbWVudHMgaGF2ZSBzaHVmZmxlZCBhYm91dCwgdGhpcyBhbGxvd3MgdXMgdG8gcXVpY2tseVxuICBcdC8vIHJlaW5zZXJ0IHRoZW0gaW4gdGhlIGNvcnJlY3QgcGxhY2VcbiAgXHRyZW5kZXJlZEZyYWdtZW50cyA9IHRoaXMucmVuZGVyZWRGcmFnbWVudHM7XG5cbiAgXHQvLyBSZW1vdmUgZnJhZ21lbnRzIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZCBmb3IgZGVzdHJ1Y3Rpb25cbiAgXHR3aGlsZSAoZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50c1RvVW5yZW5kZXIucG9wKCkpIHtcbiAgXHRcdGZyYWdtZW50LnVucmVuZGVyKHRydWUpO1xuICBcdFx0cmVuZGVyZWRGcmFnbWVudHMuc3BsaWNlKHJlbmRlcmVkRnJhZ21lbnRzLmluZGV4T2YoZnJhZ21lbnQpLCAxKTtcbiAgXHR9XG5cbiAgXHQvLyBSZW5kZXIgbmV3IGZyYWdtZW50cyAoYnV0IGRvbid0IGluc2VydCB0aGVtIHlldClcbiAgXHR3aGlsZSAoZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50c1RvUmVuZGVyLnNoaWZ0KCkpIHtcbiAgXHRcdGZyYWdtZW50LnJlbmRlcigpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHR0YXJnZXQgPSB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKTtcbiAgXHR9XG5cbiAgXHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzW2ldO1xuICBcdFx0cmVuZGVySW5kZXggPSByZW5kZXJlZEZyYWdtZW50cy5pbmRleE9mKGZyYWdtZW50LCBpKTsgLy8gc2VhcmNoIGZyb20gY3VycmVudCBpbmRleCAtIGl0J3MgZ3VhcmFudGVlZCB0byBiZSB0aGUgc2FtZSBvciBoaWdoZXJcblxuICBcdFx0aWYgKHJlbmRlckluZGV4ID09PSBpKSB7XG4gIFx0XHRcdC8vIGFscmVhZHkgaW4gdGhlIHJpZ2h0IHBsYWNlLiBpbnNlcnQgYWNjdW11bGF0ZWQgbm9kZXMgKGlmIGFueSkgYW5kIGNhcnJ5IG9uXG4gIFx0XHRcdGlmICh0aGlzLmRvY0ZyYWcuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRhbmNob3IgPSBmcmFnbWVudC5maXJzdE5vZGUoKTtcbiAgXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuZG9jRnJhZywgYW5jaG9yKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNvbnRpbnVlO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQoZnJhZ21lbnQuZGV0YWNoKCkpO1xuXG4gIFx0XHQvLyB1cGRhdGUgcmVuZGVyZWRGcmFnbWVudHNcbiAgXHRcdGlmIChyZW5kZXJJbmRleCAhPT0gLTEpIHtcbiAgXHRcdFx0cmVuZGVyZWRGcmFnbWVudHMuc3BsaWNlKHJlbmRlckluZGV4LCAxKTtcbiAgXHRcdH1cbiAgXHRcdHJlbmRlcmVkRnJhZ21lbnRzLnNwbGljZShpLCAwLCBmcmFnbWVudCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMucmVuZGVyZWQgJiYgdGhpcy5kb2NGcmFnLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gIFx0XHRhbmNob3IgPSB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUodGhpcy5kb2NGcmFnLCBhbmNob3IpO1xuICBcdH1cblxuICBcdC8vIFNhdmUgdGhlIHJlbmRlcmluZyBvcmRlciBmb3IgbmV4dCB0aW1lXG4gIFx0dGhpcy5yZW5kZXJlZEZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzLnNsaWNlKCk7XG4gIH1cblxuICB2YXIgU2VjdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy50eXBlID0gU0VDVElPTjtcbiAgXHR0aGlzLnN1YnR5cGUgPSB0aGlzLmN1cnJlbnRTdWJ0eXBlID0gb3B0aW9ucy50ZW1wbGF0ZS5uO1xuICBcdHRoaXMuaW52ZXJ0ZWQgPSB0aGlzLnN1YnR5cGUgPT09IFNFQ1RJT05fVU5MRVNTO1xuXG4gIFx0dGhpcy5wRWxlbWVudCA9IG9wdGlvbnMucEVsZW1lbnQ7XG5cbiAgXHR0aGlzLmZyYWdtZW50cyA9IFtdO1xuICBcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUgPSBbXTtcbiAgXHR0aGlzLmZyYWdtZW50c1RvUmVuZGVyID0gW107XG4gIFx0dGhpcy5mcmFnbWVudHNUb1VucmVuZGVyID0gW107XG5cbiAgXHRpZiAob3B0aW9ucy50ZW1wbGF0ZS5pKSB7XG4gIFx0XHR0aGlzLmluZGV4UmVmcyA9IG9wdGlvbnMudGVtcGxhdGUuaS5zcGxpdChcIixcIikubWFwKGZ1bmN0aW9uIChrLCBpKSB7XG4gIFx0XHRcdHJldHVybiB7IG46IGssIHQ6IGkgPT09IDAgPyBcImtcIiA6IFwiaVwiIH07XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHR0aGlzLnJlbmRlcmVkRnJhZ21lbnRzID0gW107XG5cbiAgXHR0aGlzLmxlbmd0aCA9IDA7IC8vIG51bWJlciBvZiB0aW1lcyB0aGlzIHNlY3Rpb24gaXMgcmVuZGVyZWRcblxuICBcdE11c3RhY2hlLmluaXQodGhpcywgb3B0aW9ucyk7XG4gIH07XG5cbiAgU2VjdGlvbi5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBTZWN0aW9uX3Byb3RvdHlwZV9idWJibGUsXG4gIFx0ZGV0YWNoOiBTZWN0aW9uX3Byb3RvdHlwZV9kZXRhY2gsXG4gIFx0ZmluZDogZmluZCxcbiAgXHRmaW5kQWxsOiBmaW5kQWxsLFxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBmaW5kQWxsQ29tcG9uZW50cyxcbiAgXHRmaW5kQ29tcG9uZW50OiBmaW5kQ29tcG9uZW50LFxuICBcdGZpbmROZXh0Tm9kZTogZmluZE5leHROb2RlLFxuICBcdGZpcnN0Tm9kZTogZmlyc3ROb2RlLFxuICBcdGdldEluZGV4UmVmOiBmdW5jdGlvbiAobmFtZSkge1xuICBcdFx0aWYgKHRoaXMuaW5kZXhSZWZzKSB7XG4gIFx0XHRcdHZhciBpID0gdGhpcy5pbmRleFJlZnMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0dmFyIHJlZiA9IHRoaXMuaW5kZXhSZWZzW2ldO1xuICBcdFx0XHRcdGlmIChyZWYubiA9PT0gbmFtZSkge1xuICBcdFx0XHRcdFx0cmV0dXJuIHJlZjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuICBcdGdldFZhbHVlOiBNdXN0YWNoZS5nZXRWYWx1ZSxcbiAgXHRzaHVmZmxlOiBzaHVmZmxlLFxuICBcdHJlYmluZDogcHJvdG90eXBlX3JlYmluZCxcbiAgXHRyZW5kZXI6IFNlY3Rpb25fcHJvdG90eXBlX3JlbmRlcixcbiAgXHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuICBcdHNldFZhbHVlOiBzZXRWYWx1ZSxcbiAgXHR0b1N0cmluZzogcHJvdG90eXBlX3RvU3RyaW5nLFxuICBcdHVuYmluZDogcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1bnJlbmRlcjogcHJvdG90eXBlX3VucmVuZGVyLFxuICBcdHVwZGF0ZTogcHJvdG90eXBlX3VwZGF0ZVxuICB9O1xuXG4gIHZhciBfU2VjdGlvbiA9IFNlY3Rpb247XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfZGV0YWNoID0gVHJpcGxlJGRldGFjaDtcblxuICBmdW5jdGlvbiBUcmlwbGUkZGV0YWNoKCkge1xuICBcdHZhciBsZW4sIGk7XG5cbiAgXHRpZiAodGhpcy5kb2NGcmFnKSB7XG4gIFx0XHRsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlc1tpXSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLmRvY0ZyYWc7XG4gIFx0fVxuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfZmluZCA9IFRyaXBsZSRmaW5kO1xuICBmdW5jdGlvbiBUcmlwbGUkZmluZChzZWxlY3Rvcikge1xuICBcdHZhciBpLCBsZW4sIG5vZGUsIHF1ZXJ5UmVzdWx0O1xuXG4gIFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gIFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRub2RlID0gdGhpcy5ub2Rlc1tpXTtcblxuICBcdFx0aWYgKG5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChtYXRjaGVzKG5vZGUsIHNlbGVjdG9yKSkge1xuICBcdFx0XHRyZXR1cm4gbm9kZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHF1ZXJ5UmVzdWx0ID0gbm9kZS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSkge1xuICBcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV9maW5kQWxsID0gVHJpcGxlJGZpbmRBbGw7XG4gIGZ1bmN0aW9uIFRyaXBsZSRmaW5kQWxsKHNlbGVjdG9yLCBxdWVyeVJlc3VsdCkge1xuICBcdHZhciBpLCBsZW4sIG5vZGUsIHF1ZXJ5QWxsUmVzdWx0LCBudW1Ob2RlcywgajtcblxuICBcdGxlbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0bm9kZSA9IHRoaXMubm9kZXNbaV07XG5cbiAgXHRcdGlmIChub2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gIFx0XHRcdGNvbnRpbnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobWF0Y2hlcyhub2RlLCBzZWxlY3RvcikpIHtcbiAgXHRcdFx0cXVlcnlSZXN1bHQucHVzaChub2RlKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHF1ZXJ5QWxsUmVzdWx0ID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkge1xuICBcdFx0XHRudW1Ob2RlcyA9IHF1ZXJ5QWxsUmVzdWx0Lmxlbmd0aDtcbiAgXHRcdFx0Zm9yIChqID0gMDsgaiA8IG51bU5vZGVzOyBqICs9IDEpIHtcbiAgXHRcdFx0XHRxdWVyeVJlc3VsdC5wdXNoKHF1ZXJ5QWxsUmVzdWx0W2pdKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBUcmlwbGVfcHJvdG90eXBlX2ZpcnN0Tm9kZSA9IFRyaXBsZSRmaXJzdE5vZGU7XG5cbiAgZnVuY3Rpb24gVHJpcGxlJGZpcnN0Tm9kZSgpIHtcbiAgXHRpZiAodGhpcy5yZW5kZXJlZCAmJiB0aGlzLm5vZGVzWzBdKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5ub2Rlc1swXTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIH1cblxuICB2YXIgZWxlbWVudENhY2hlID0ge30sXG4gICAgICBpZUJ1ZyxcbiAgICAgIGllQmxhY2tsaXN0O1xuXG4gIHRyeSB7XG4gIFx0Y3JlYXRlRWxlbWVudChcInRhYmxlXCIpLmlubmVySFRNTCA9IFwiZm9vXCI7XG4gIH0gY2F0Y2ggKGVycikge1xuICBcdGllQnVnID0gdHJ1ZTtcblxuICBcdGllQmxhY2tsaXN0ID0ge1xuICBcdFx0VEFCTEU6IFtcIjx0YWJsZSBjbGFzcz1cXFwieFxcXCI+XCIsIFwiPC90YWJsZT5cIl0sXG4gIFx0XHRUSEVBRDogW1wiPHRhYmxlPjx0aGVhZCBjbGFzcz1cXFwieFxcXCI+XCIsIFwiPC90aGVhZD48L3RhYmxlPlwiXSxcbiAgXHRcdFRCT0RZOiBbXCI8dGFibGU+PHRib2R5IGNsYXNzPVxcXCJ4XFxcIj5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCJdLFxuICBcdFx0VFI6IFtcIjx0YWJsZT48dHIgY2xhc3M9XFxcInhcXFwiPlwiLCBcIjwvdHI+PC90YWJsZT5cIl0sXG4gIFx0XHRTRUxFQ1Q6IFtcIjxzZWxlY3QgY2xhc3M9XFxcInhcXFwiPlwiLCBcIjwvc2VsZWN0PlwiXVxuICBcdH07XG4gIH1cblxuICB2YXIgaW5zZXJ0SHRtbCA9IGZ1bmN0aW9uIChodG1sLCBub2RlLCBkb2NGcmFnKSB7XG4gIFx0dmFyIGNvbnRhaW5lcixcbiAgXHQgICAgbm9kZXMgPSBbXSxcbiAgXHQgICAgd3JhcHBlcixcbiAgXHQgICAgc2VsZWN0ZWRPcHRpb24sXG4gIFx0ICAgIGNoaWxkLFxuICBcdCAgICBpO1xuXG4gIFx0Ly8gcmVuZGVyIDAgYW5kIGZhbHNlXG4gIFx0aWYgKGh0bWwgIT0gbnVsbCAmJiBodG1sICE9PSBcIlwiKSB7XG4gIFx0XHRpZiAoaWVCdWcgJiYgKHdyYXBwZXIgPSBpZUJsYWNrbGlzdFtub2RlLnRhZ05hbWVdKSkge1xuICBcdFx0XHRjb250YWluZXIgPSBlbGVtZW50KFwiRElWXCIpO1xuICBcdFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gd3JhcHBlclswXSArIGh0bWwgKyB3cmFwcGVyWzFdO1xuICBcdFx0XHRjb250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihcIi54XCIpO1xuXG4gIFx0XHRcdGlmIChjb250YWluZXIudGFnTmFtZSA9PT0gXCJTRUxFQ1RcIikge1xuICBcdFx0XHRcdHNlbGVjdGVkT3B0aW9uID0gY29udGFpbmVyLm9wdGlvbnNbY29udGFpbmVyLnNlbGVjdGVkSW5kZXhdO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2UgaWYgKG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLnN2Zykge1xuICBcdFx0XHRjb250YWluZXIgPSBlbGVtZW50KFwiRElWXCIpO1xuICBcdFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gXCI8c3ZnIGNsYXNzPVxcXCJ4XFxcIj5cIiArIGh0bWwgKyBcIjwvc3ZnPlwiO1xuICBcdFx0XHRjb250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihcIi54XCIpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Y29udGFpbmVyID0gZWxlbWVudChub2RlLnRhZ05hbWUpO1xuICBcdFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcblxuICBcdFx0XHRpZiAoY29udGFpbmVyLnRhZ05hbWUgPT09IFwiU0VMRUNUXCIpIHtcbiAgXHRcdFx0XHRzZWxlY3RlZE9wdGlvbiA9IGNvbnRhaW5lci5vcHRpb25zW2NvbnRhaW5lci5zZWxlY3RlZEluZGV4XTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR3aGlsZSAoY2hpbGQgPSBjb250YWluZXIuZmlyc3RDaGlsZCkge1xuICBcdFx0XHRub2Rlcy5wdXNoKGNoaWxkKTtcbiAgXHRcdFx0ZG9jRnJhZy5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFRoaXMgaXMgcmVhbGx5IGFubm95aW5nLiBFeHRyYWN0aW5nIDxvcHRpb24+IG5vZGVzIGZyb20gdGhlXG4gIFx0XHQvLyB0ZW1wb3JhcnkgY29udGFpbmVyIDxzZWxlY3Q+IGNhdXNlcyB0aGUgcmVtYWluaW5nIG9uZXMgdG9cbiAgXHRcdC8vIGJlY29tZSBzZWxlY3RlZC4gU28gbm93IHdlIGhhdmUgdG8gZGVzZWxlY3QgdGhlbS4gSUU4LCB5b3VcbiAgXHRcdC8vIGFtYXplIG1lLiBZb3UgcmVhbGx5IGRvXG4gIFx0XHQvLyAuLi5hbmQgbm93IENocm9tZSB0b29cbiAgXHRcdGlmIChub2RlLnRhZ05hbWUgPT09IFwiU0VMRUNUXCIpIHtcbiAgXHRcdFx0aSA9IG5vZGVzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdGlmIChub2Rlc1tpXSAhPT0gc2VsZWN0ZWRPcHRpb24pIHtcbiAgXHRcdFx0XHRcdG5vZGVzW2ldLnNlbGVjdGVkID0gZmFsc2U7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG5vZGVzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGVsZW1lbnQodGFnTmFtZSkge1xuICBcdHJldHVybiBlbGVtZW50Q2FjaGVbdGFnTmFtZV0gfHwgKGVsZW1lbnRDYWNoZVt0YWdOYW1lXSA9IGNyZWF0ZUVsZW1lbnQodGFnTmFtZSkpO1xuICB9XG5cbiAgdmFyIGhlbHBlcnNfdXBkYXRlU2VsZWN0ID0gdXBkYXRlU2VsZWN0O1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdChwYXJlbnRFbGVtZW50KSB7XG4gIFx0dmFyIHNlbGVjdGVkT3B0aW9ucywgb3B0aW9uLCB2YWx1ZTtcblxuICBcdGlmICghcGFyZW50RWxlbWVudCB8fCBwYXJlbnRFbGVtZW50Lm5hbWUgIT09IFwic2VsZWN0XCIgfHwgIXBhcmVudEVsZW1lbnQuYmluZGluZykge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHNlbGVjdGVkT3B0aW9ucyA9IHRvQXJyYXkocGFyZW50RWxlbWVudC5ub2RlLm9wdGlvbnMpLmZpbHRlcihpc1NlbGVjdGVkKTtcblxuICBcdC8vIElmIG9uZSBvZiB0aGVtIGhhZCBhIGBzZWxlY3RlZGAgYXR0cmlidXRlLCB3ZSBuZWVkIHRvIHN5bmNcbiAgXHQvLyB0aGUgbW9kZWwgdG8gdGhlIHZpZXdcbiAgXHRpZiAocGFyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSkge1xuICBcdFx0dmFsdWUgPSBzZWxlY3RlZE9wdGlvbnMubWFwKGZ1bmN0aW9uIChvKSB7XG4gIFx0XHRcdHJldHVybiBvLnZhbHVlO1xuICBcdFx0fSk7XG4gIFx0fSBlbHNlIGlmIChvcHRpb24gPSBzZWxlY3RlZE9wdGlvbnNbMF0pIHtcbiAgXHRcdHZhbHVlID0gb3B0aW9uLnZhbHVlO1xuICBcdH1cblxuICBcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRwYXJlbnRFbGVtZW50LmJpbmRpbmcuc2V0VmFsdWUodmFsdWUpO1xuICBcdH1cblxuICBcdHBhcmVudEVsZW1lbnQuYnViYmxlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NlbGVjdGVkKG9wdGlvbikge1xuICBcdHJldHVybiBvcHRpb24uc2VsZWN0ZWQ7XG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV9yZW5kZXIgPSBUcmlwbGUkcmVuZGVyO1xuICBmdW5jdGlvbiBUcmlwbGUkcmVuZGVyKCkge1xuICBcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gcmVuZGVyIGFuIGl0ZW0gdGhhdCB3YXMgYWxyZWFkeSByZW5kZXJlZFwiKTtcbiAgXHR9XG5cbiAgXHR0aGlzLmRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIFx0dGhpcy5ub2RlcyA9IGluc2VydEh0bWwodGhpcy52YWx1ZSwgdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCksIHRoaXMuZG9jRnJhZyk7XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSB3ZSdyZSBpbnNlcnRpbmcgdGhlIGNvbnRlbnRzIG9mIGEgPHNlbGVjdD5cbiAgXHRoZWxwZXJzX3VwZGF0ZVNlbGVjdCh0aGlzLnBFbGVtZW50KTtcblxuICBcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdHJldHVybiB0aGlzLmRvY0ZyYWc7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3NldFZhbHVlID0gVHJpcGxlJHNldFZhbHVlO1xuICBmdW5jdGlvbiBUcmlwbGUkc2V0VmFsdWUodmFsdWUpIHtcbiAgXHR2YXIgd3JhcHBlcjtcblxuICBcdC8vIFRPRE8gaXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGFwcHJvYWNoIHRoaXM/XG4gIFx0aWYgKHdyYXBwZXIgPSB0aGlzLnJvb3Qudmlld21vZGVsLndyYXBwZWRbdGhpcy5rZXlwYXRoLnN0cl0pIHtcbiAgXHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcbiAgXHR9XG5cbiAgXHRpZiAodmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cbiAgXHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFZpZXcodGhpcyk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIFRyaXBsZV9wcm90b3R5cGVfdG9TdHJpbmcgPSBUcmlwbGUkdG9TdHJpbmc7XG4gIGZ1bmN0aW9uIFRyaXBsZSR0b1N0cmluZygpIHtcbiAgXHRyZXR1cm4gdGhpcy52YWx1ZSAhPSB1bmRlZmluZWQgPyBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKFwiXCIgKyB0aGlzLnZhbHVlKSA6IFwiXCI7XG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV91bnJlbmRlciA9IFRyaXBsZSR1bnJlbmRlcjtcbiAgZnVuY3Rpb24gVHJpcGxlJHVucmVuZGVyKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRpZiAodGhpcy5yZW5kZXJlZCAmJiBzaG91bGREZXN0cm95KSB7XG4gIFx0XHR0aGlzLm5vZGVzLmZvckVhY2goZGV0YWNoTm9kZSk7XG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0Ly8gVE9ETyB1cGRhdGUgbGl2ZSBxdWVyaWVzXG4gIH1cblxuICB2YXIgVHJpcGxlX3Byb3RvdHlwZV91cGRhdGUgPSBUcmlwbGUkdXBkYXRlO1xuICBmdW5jdGlvbiBUcmlwbGUkdXBkYXRlKCkge1xuICBcdHZhciBub2RlLCBwYXJlbnROb2RlO1xuXG4gIFx0aWYgKCF0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gUmVtb3ZlIGV4aXN0aW5nIG5vZGVzXG4gIFx0d2hpbGUgKHRoaXMubm9kZXMgJiYgdGhpcy5ub2Rlcy5sZW5ndGgpIHtcbiAgXHRcdG5vZGUgPSB0aGlzLm5vZGVzLnBvcCgpO1xuICBcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICBcdH1cblxuICBcdC8vIEluc2VydCBuZXcgbm9kZXNcbiAgXHRwYXJlbnROb2RlID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG5cbiAgXHR0aGlzLm5vZGVzID0gaW5zZXJ0SHRtbCh0aGlzLnZhbHVlLCBwYXJlbnROb2RlLCB0aGlzLmRvY0ZyYWcpO1xuICBcdHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuZG9jRnJhZywgdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcykpO1xuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gd2UncmUgaW5zZXJ0aW5nIHRoZSBjb250ZW50cyBvZiBhIDxzZWxlY3Q+XG4gIFx0aGVscGVyc191cGRhdGVTZWxlY3QodGhpcy5wRWxlbWVudCk7XG4gIH1cblxuICB2YXIgVHJpcGxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBUUklQTEU7XG4gIFx0TXVzdGFjaGUuaW5pdCh0aGlzLCBvcHRpb25zKTtcbiAgfTtcblxuICBUcmlwbGUucHJvdG90eXBlID0ge1xuICBcdGRldGFjaDogVHJpcGxlX3Byb3RvdHlwZV9kZXRhY2gsXG4gIFx0ZmluZDogVHJpcGxlX3Byb3RvdHlwZV9maW5kLFxuICBcdGZpbmRBbGw6IFRyaXBsZV9wcm90b3R5cGVfZmluZEFsbCxcbiAgXHRmaXJzdE5vZGU6IFRyaXBsZV9wcm90b3R5cGVfZmlyc3ROb2RlLFxuICBcdGdldFZhbHVlOiBNdXN0YWNoZS5nZXRWYWx1ZSxcbiAgXHRyZWJpbmQ6IE11c3RhY2hlLnJlYmluZCxcbiAgXHRyZW5kZXI6IFRyaXBsZV9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG4gIFx0c2V0VmFsdWU6IHByb3RvdHlwZV9zZXRWYWx1ZSxcbiAgXHR0b1N0cmluZzogVHJpcGxlX3Byb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IHNoYXJlZF91bmJpbmQsXG4gIFx0dW5yZW5kZXI6IFRyaXBsZV9wcm90b3R5cGVfdW5yZW5kZXIsXG4gIFx0dXBkYXRlOiBUcmlwbGVfcHJvdG90eXBlX3VwZGF0ZVxuICB9O1xuXG4gIHZhciBfVHJpcGxlID0gVHJpcGxlO1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9idWJibGUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcbiAgfTtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZGV0YWNoID0gRWxlbWVudCRkZXRhY2g7XG5cbiAgZnVuY3Rpb24gRWxlbWVudCRkZXRhY2goKSB7XG4gIFx0dmFyIG5vZGUgPSB0aGlzLm5vZGUsXG4gIFx0ICAgIHBhcmVudE5vZGU7XG5cbiAgXHRpZiAobm9kZSkge1xuICBcdFx0Ly8gbmVlZCB0byBjaGVjayBmb3IgcGFyZW50IG5vZGUgLSBET00gbWF5IGhhdmUgYmVlbiBhbHRlcmVkXG4gIFx0XHQvLyBieSBzb21ldGhpbmcgb3RoZXIgdGhhbiBSYWN0aXZlISBlLmcuIGpRdWVyeSBVSS4uLlxuICBcdFx0aWYgKHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGUpIHtcbiAgXHRcdFx0cGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG5vZGU7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2ZpbmQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRpZiAoIXRoaXMubm9kZSkge1xuICBcdFx0Ly8gdGhpcyBlbGVtZW50IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldFxuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKG1hdGNoZXModGhpcy5ub2RlLCBzZWxlY3RvcikpIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5mcmFnbWVudC5maW5kKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKHNlbGVjdG9yKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2ZpbmRBbGwgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0Ly8gQWRkIHRoaXMgbm9kZSB0byB0aGUgcXVlcnksIGlmIGFwcGxpY2FibGUsIGFuZCByZWdpc3RlciB0aGVcbiAgXHQvLyBxdWVyeSBvbiB0aGlzIGVsZW1lbnRcbiAgXHRpZiAocXVlcnkuX3Rlc3QodGhpcywgdHJ1ZSkgJiYgcXVlcnkubGl2ZSkge1xuICBcdFx0KHRoaXMubGl2ZVF1ZXJpZXMgfHwgKHRoaXMubGl2ZVF1ZXJpZXMgPSBbXSkpLnB1c2gocXVlcnkpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2ZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9maW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoc2VsZWN0b3IpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZmluZE5leHROb2RlID0gRWxlbWVudCRmaW5kTmV4dE5vZGU7XG5cbiAgZnVuY3Rpb24gRWxlbWVudCRmaW5kTmV4dE5vZGUoKSB7XG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgRWxlbWVudF9wcm90b3R5cGVfZmlyc3ROb2RlID0gRWxlbWVudCRmaXJzdE5vZGU7XG5cbiAgZnVuY3Rpb24gRWxlbWVudCRmaXJzdE5vZGUoKSB7XG4gIFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgfVxuXG4gIHZhciBnZXRBdHRyaWJ1dGUgPSBFbGVtZW50JGdldEF0dHJpYnV0ZTtcblxuICBmdW5jdGlvbiBFbGVtZW50JGdldEF0dHJpYnV0ZShuYW1lKSB7XG4gIFx0aWYgKCF0aGlzLmF0dHJpYnV0ZXMgfHwgIXRoaXMuYXR0cmlidXRlc1tuYW1lXSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0udmFsdWU7XG4gIH1cblxuICB2YXIgdHJ1dGh5ID0gL150cnVlfG9ufHllc3wxJC9pO1xuICB2YXIgcHJvY2Vzc0JpbmRpbmdBdHRyaWJ1dGVzX19pc051bWVyaWMgPSAvXlswLTldKyQvO1xuXG4gIHZhciBwcm9jZXNzQmluZGluZ0F0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgdGVtcGxhdGUpIHtcbiAgXHR2YXIgdmFsLCBhdHRycywgYXR0cmlidXRlcztcblxuICBcdGF0dHJpYnV0ZXMgPSB0ZW1wbGF0ZS5hIHx8IHt9O1xuICBcdGF0dHJzID0ge307XG5cbiAgXHQvLyBhdHRyaWJ1dGVzIHRoYXQgYXJlIHByZXNlbnQgYnV0IGRvbid0IGhhdmUgYSB2YWx1ZSAoPSlcbiAgXHQvLyB3aWxsIGJlIHNldCB0byB0aGUgbnVtYmVyIDAsIHdoaWNoIHdlIGNvbmRpZGVyIHRvIGJlIHRydWVcbiAgXHQvLyB0aGUgc3RyaW5nICcwJywgaG93ZXZlciBpcyBmYWxzZVxuXG4gIFx0dmFsID0gYXR0cmlidXRlcy50d293YXk7XG4gIFx0aWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRhdHRycy50d293YXkgPSB2YWwgPT09IDAgfHwgdHJ1dGh5LnRlc3QodmFsKTtcbiAgXHR9XG5cbiAgXHR2YWwgPSBhdHRyaWJ1dGVzLmxhenk7XG4gIFx0aWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHQvLyBjaGVjayBmb3IgdGltZW91dCB2YWx1ZVxuICBcdFx0aWYgKHZhbCAhPT0gMCAmJiBwcm9jZXNzQmluZGluZ0F0dHJpYnV0ZXNfX2lzTnVtZXJpYy50ZXN0KHZhbCkpIHtcbiAgXHRcdFx0YXR0cnMubGF6eSA9IHBhcnNlSW50KHZhbCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRhdHRycy5sYXp5ID0gdmFsID09PSAwIHx8IHRydXRoeS50ZXN0KHZhbCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGF0dHJzO1xuICB9O1xuXG4gIHZhciBBdHRyaWJ1dGVfcHJvdG90eXBlX2J1YmJsZSA9IEF0dHJpYnV0ZSRidWJibGU7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSRidWJibGUoKSB7XG4gIFx0dmFyIHZhbHVlID0gdGhpcy51c2VQcm9wZXJ0eSB8fCAhdGhpcy5yZW5kZXJlZCA/IHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKSA6IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKTtcblxuICBcdC8vIFRPRE8gdGhpcyBjYW4gcmVnaXN0ZXIgdGhlIGF0dHJpYnV0ZSBtdWx0aXBsZSB0aW1lcyAoc2VlIHJlbmRlciB0ZXN0XG4gIFx0Ly8gJ0F0dHJpYnV0ZSB3aXRoIG5lc3RlZCBtdXN0YWNoZXMnKVxuICBcdGlmICghaXNFcXVhbCh2YWx1ZSwgdGhpcy52YWx1ZSkpIHtcblxuICBcdFx0Ly8gTmVlZCB0byBjbGVhciBvbGQgaWQgZnJvbSByYWN0aXZlLm5vZGVzXG4gIFx0XHRpZiAodGhpcy5uYW1lID09PSBcImlkXCIgJiYgdGhpcy52YWx1ZSkge1xuICBcdFx0XHRkZWxldGUgdGhpcy5yb290Lm5vZGVzW3RoaXMudmFsdWVdO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdGlmICh0aGlzLm5hbWUgPT09IFwidmFsdWVcIiAmJiB0aGlzLm5vZGUpIHtcbiAgXHRcdFx0Ly8gV2UgbmVlZCB0byBzdG9yZSB0aGUgdmFsdWUgb24gdGhlIERPTSBsaWtlIHRoaXMgc28gd2VcbiAgXHRcdFx0Ly8gY2FuIHJldHJpZXZlIGl0IGxhdGVyIHdpdGhvdXQgaXQgYmVpbmcgY29lcmNlZCB0byBhIHN0cmluZ1xuICBcdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkVmlldyh0aGlzKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgc3ZnQ2FtZWxDYXNlRWxlbWVudHMsIHN2Z0NhbWVsQ2FzZUF0dHJpYnV0ZXMsIGNyZWF0ZU1hcCwgbWFwO1xuICBzdmdDYW1lbENhc2VFbGVtZW50cyA9IFwiYWx0R2x5cGggYWx0R2x5cGhEZWYgYWx0R2x5cGhJdGVtIGFuaW1hdGVDb2xvciBhbmltYXRlTW90aW9uIGFuaW1hdGVUcmFuc2Zvcm0gY2xpcFBhdGggZmVCbGVuZCBmZUNvbG9yTWF0cml4IGZlQ29tcG9uZW50VHJhbnNmZXIgZmVDb21wb3NpdGUgZmVDb252b2x2ZU1hdHJpeCBmZURpZmZ1c2VMaWdodGluZyBmZURpc3BsYWNlbWVudE1hcCBmZURpc3RhbnRMaWdodCBmZUZsb29kIGZlRnVuY0EgZmVGdW5jQiBmZUZ1bmNHIGZlRnVuY1IgZmVHYXVzc2lhbkJsdXIgZmVJbWFnZSBmZU1lcmdlIGZlTWVyZ2VOb2RlIGZlTW9ycGhvbG9neSBmZU9mZnNldCBmZVBvaW50TGlnaHQgZmVTcGVjdWxhckxpZ2h0aW5nIGZlU3BvdExpZ2h0IGZlVGlsZSBmZVR1cmJ1bGVuY2UgZm9yZWlnbk9iamVjdCBnbHlwaFJlZiBsaW5lYXJHcmFkaWVudCByYWRpYWxHcmFkaWVudCB0ZXh0UGF0aCB2a2VyblwiLnNwbGl0KFwiIFwiKTtcbiAgc3ZnQ2FtZWxDYXNlQXR0cmlidXRlcyA9IFwiYXR0cmlidXRlTmFtZSBhdHRyaWJ1dGVUeXBlIGJhc2VGcmVxdWVuY3kgYmFzZVByb2ZpbGUgY2FsY01vZGUgY2xpcFBhdGhVbml0cyBjb250ZW50U2NyaXB0VHlwZSBjb250ZW50U3R5bGVUeXBlIGRpZmZ1c2VDb25zdGFudCBlZGdlTW9kZSBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkIGZpbHRlclJlcyBmaWx0ZXJVbml0cyBnbHlwaFJlZiBncmFkaWVudFRyYW5zZm9ybSBncmFkaWVudFVuaXRzIGtlcm5lbE1hdHJpeCBrZXJuZWxVbml0TGVuZ3RoIGtleVBvaW50cyBrZXlTcGxpbmVzIGtleVRpbWVzIGxlbmd0aEFkanVzdCBsaW1pdGluZ0NvbmVBbmdsZSBtYXJrZXJIZWlnaHQgbWFya2VyVW5pdHMgbWFya2VyV2lkdGggbWFza0NvbnRlbnRVbml0cyBtYXNrVW5pdHMgbnVtT2N0YXZlcyBwYXRoTGVuZ3RoIHBhdHRlcm5Db250ZW50VW5pdHMgcGF0dGVyblRyYW5zZm9ybSBwYXR0ZXJuVW5pdHMgcG9pbnRzQXRYIHBvaW50c0F0WSBwb2ludHNBdFogcHJlc2VydmVBbHBoYSBwcmVzZXJ2ZUFzcGVjdFJhdGlvIHByaW1pdGl2ZVVuaXRzIHJlZlggcmVmWSByZXBlYXRDb3VudCByZXBlYXREdXIgcmVxdWlyZWRFeHRlbnNpb25zIHJlcXVpcmVkRmVhdHVyZXMgc3BlY3VsYXJDb25zdGFudCBzcGVjdWxhckV4cG9uZW50IHNwcmVhZE1ldGhvZCBzdGFydE9mZnNldCBzdGREZXZpYXRpb24gc3RpdGNoVGlsZXMgc3VyZmFjZVNjYWxlIHN5c3RlbUxhbmd1YWdlIHRhYmxlVmFsdWVzIHRhcmdldFggdGFyZ2V0WSB0ZXh0TGVuZ3RoIHZpZXdCb3ggdmlld1RhcmdldCB4Q2hhbm5lbFNlbGVjdG9yIHlDaGFubmVsU2VsZWN0b3Igem9vbUFuZFBhblwiLnNwbGl0KFwiIFwiKTtcblxuICBjcmVhdGVNYXAgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgXHR2YXIgbWFwID0ge30sXG4gIFx0ICAgIGkgPSBpdGVtcy5sZW5ndGg7XG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0bWFwW2l0ZW1zW2ldLnRvTG93ZXJDYXNlKCldID0gaXRlbXNbaV07XG4gIFx0fVxuICBcdHJldHVybiBtYXA7XG4gIH07XG5cbiAgbWFwID0gY3JlYXRlTWFwKHN2Z0NhbWVsQ2FzZUVsZW1lbnRzLmNvbmNhdChzdmdDYW1lbENhc2VBdHRyaWJ1dGVzKSk7XG5cbiAgdmFyIGVuZm9yY2VDYXNlID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lKSB7XG4gIFx0dmFyIGxvd2VyQ2FzZUVsZW1lbnROYW1lID0gZWxlbWVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgXHRyZXR1cm4gbWFwW2xvd2VyQ2FzZUVsZW1lbnROYW1lXSB8fCBsb3dlckNhc2VFbGVtZW50TmFtZTtcbiAgfTtcblxuICB2YXIgZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIG5hbWUpIHtcbiAgXHR2YXIgY29sb25JbmRleCwgbmFtZXNwYWNlUHJlZml4O1xuXG4gIFx0Ly8gYXJlIHdlIGRlYWxpbmcgd2l0aCBhIG5hbWVzcGFjZWQgYXR0cmlidXRlLCBlLmcuIHhsaW5rOmhyZWY/XG4gIFx0Y29sb25JbmRleCA9IG5hbWUuaW5kZXhPZihcIjpcIik7XG4gIFx0aWYgKGNvbG9uSW5kZXggIT09IC0xKSB7XG5cbiAgXHRcdC8vIGxvb2tzIGxpa2Ugd2UgYXJlLCB5ZXMuLi5cbiAgXHRcdG5hbWVzcGFjZVByZWZpeCA9IG5hbWUuc3Vic3RyKDAsIGNvbG9uSW5kZXgpO1xuXG4gIFx0XHQvLyAuLi51bmxlc3MgaXQncyBhIG5hbWVzcGFjZSAqZGVjbGFyYXRpb24qLCB3aGljaCB3ZSBpZ25vcmUgKG9uIHRoZSBhc3N1bXB0aW9uXG4gIFx0XHQvLyB0aGF0IG9ubHkgdmFsaWQgbmFtZXNwYWNlcyB3aWxsIGJlIHVzZWQpXG4gIFx0XHRpZiAobmFtZXNwYWNlUHJlZml4ICE9PSBcInhtbG5zXCIpIHtcbiAgXHRcdFx0bmFtZSA9IG5hbWUuc3Vic3RyaW5nKGNvbG9uSW5kZXggKyAxKTtcblxuICBcdFx0XHRhdHRyaWJ1dGUubmFtZSA9IGVuZm9yY2VDYXNlKG5hbWUpO1xuICBcdFx0XHRhdHRyaWJ1dGUubmFtZXNwYWNlID0gbmFtZXNwYWNlc1tuYW1lc3BhY2VQcmVmaXgudG9Mb3dlckNhc2UoKV07XG4gIFx0XHRcdGF0dHJpYnV0ZS5uYW1lc3BhY2VQcmVmaXggPSBuYW1lc3BhY2VQcmVmaXg7XG5cbiAgXHRcdFx0aWYgKCFhdHRyaWJ1dGUubmFtZXNwYWNlKSB7XG4gIFx0XHRcdFx0dGhyb3cgXCJVbmtub3duIG5hbWVzcGFjZSAoXFxcIlwiICsgbmFtZXNwYWNlUHJlZml4ICsgXCJcXFwiKVwiO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIFNWRyBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Ugc2Vuc2l0aXZlXG4gIFx0YXR0cmlidXRlLm5hbWUgPSBhdHRyaWJ1dGUuZWxlbWVudC5uYW1lc3BhY2UgIT09IG5hbWVzcGFjZXMuaHRtbCA/IGVuZm9yY2VDYXNlKG5hbWUpIDogbmFtZTtcbiAgfTtcblxuICB2YXIgaGVscGVyc19nZXRJbnRlcnBvbGF0b3IgPSBnZXRJbnRlcnBvbGF0b3I7XG4gIGZ1bmN0aW9uIGdldEludGVycG9sYXRvcihhdHRyaWJ1dGUpIHtcbiAgXHR2YXIgaXRlbXMgPSBhdHRyaWJ1dGUuZnJhZ21lbnQuaXRlbXM7XG5cbiAgXHRpZiAoaXRlbXMubGVuZ3RoICE9PSAxKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKGl0ZW1zWzBdLnR5cGUgPT09IElOVEVSUE9MQVRPUikge1xuICBcdFx0cmV0dXJuIGl0ZW1zWzBdO1xuICBcdH1cbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfaW5pdCA9IEF0dHJpYnV0ZSRpbml0O1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkaW5pdChvcHRpb25zKSB7XG4gIFx0dGhpcy50eXBlID0gQVRUUklCVVRFO1xuICBcdHRoaXMuZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcbiAgXHR0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3Q7XG5cbiAgXHRkZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlKHRoaXMsIG9wdGlvbnMubmFtZSk7XG4gIFx0dGhpcy5pc0Jvb2xlYW4gPSBib29sZWFuQXR0cmlidXRlcy50ZXN0KHRoaXMubmFtZSk7XG5cbiAgXHQvLyBpZiBpdCdzIGFuIGVtcHR5IGF0dHJpYnV0ZSwgb3IganVzdCBhIHN0cmFpZ2h0IGtleS12YWx1ZSBwYWlyLCB3aXRoIG5vXG4gIFx0Ly8gbXVzdGFjaGUgc2hlbmFuaWdhbnMsIHNldCB0aGUgYXR0cmlidXRlIGFjY29yZGluZ2x5IGFuZCBnbyBob21lXG4gIFx0aWYgKCFvcHRpb25zLnZhbHVlIHx8IHR5cGVvZiBvcHRpb25zLnZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHR0aGlzLnZhbHVlID0gdGhpcy5pc0Jvb2xlYW4gPyB0cnVlIDogb3B0aW9ucy52YWx1ZSB8fCBcIlwiO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIG90aGVyd2lzZSB3ZSBuZWVkIHRvIGRvIHNvbWUgd29ya1xuXG4gIFx0Ly8gc2hhcmUgcGFyZW50RnJhZ21lbnQgd2l0aCBwYXJlbnQgZWxlbWVudFxuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0dGVtcGxhdGU6IG9wdGlvbnMudmFsdWUsXG4gIFx0XHRyb290OiB0aGlzLnJvb3QsXG4gIFx0XHRvd25lcjogdGhpc1xuICBcdH0pO1xuXG4gIFx0Ly8gVE9ETyBjYW4gd2UgdXNlIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKSBpbiBzb21lIGNhc2VzPyBJdCdzIHF1aWNrZXJcbiAgXHR0aGlzLnZhbHVlID0gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXG4gIFx0Ly8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhpcyBhdHRyaWJ1dGUncyBpbnRlcnBvbGF0b3IsIGlmIGl0cyBmcmFnbWVudFxuICBcdC8vIHRha2VzIHRoZSBmb3JtIGB7e2Zvb319YC4gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIHR3by13YXkgYmluZGluZyBhbmRcbiAgXHQvLyBmb3IgY29ycmVjdGx5IHJlbmRlcmluZyBIVE1MIGxhdGVyXG4gIFx0dGhpcy5pbnRlcnBvbGF0b3IgPSBoZWxwZXJzX2dldEludGVycG9sYXRvcih0aGlzKTtcbiAgXHR0aGlzLmlzQmluZGFibGUgPSAhIXRoaXMuaW50ZXJwb2xhdG9yICYmICF0aGlzLmludGVycG9sYXRvci5pc1N0YXRpYztcblxuICBcdC8vIG1hcmsgYXMgcmVhZHlcbiAgXHR0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBBdHRyaWJ1dGVfcHJvdG90eXBlX3JlYmluZCA9IEF0dHJpYnV0ZSRyZWJpbmQ7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBBdHRyaWJ1dGVfcHJvdG90eXBlX3JlbmRlciA9IEF0dHJpYnV0ZSRyZW5kZXI7XG4gIHZhciBwcm9wZXJ0eU5hbWVzID0ge1xuICBcdFwiYWNjZXB0LWNoYXJzZXRcIjogXCJhY2NlcHRDaGFyc2V0XCIsXG4gIFx0YWNjZXNza2V5OiBcImFjY2Vzc0tleVwiLFxuICBcdGJnY29sb3I6IFwiYmdDb2xvclwiLFxuICBcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIixcbiAgXHRjb2RlYmFzZTogXCJjb2RlQmFzZVwiLFxuICBcdGNvbHNwYW46IFwiY29sU3BhblwiLFxuICBcdGNvbnRlbnRlZGl0YWJsZTogXCJjb250ZW50RWRpdGFibGVcIixcbiAgXHRkYXRldGltZTogXCJkYXRlVGltZVwiLFxuICBcdGRpcm5hbWU6IFwiZGlyTmFtZVwiLFxuICBcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuICBcdFwiaHR0cC1lcXVpdlwiOiBcImh0dHBFcXVpdlwiLFxuICBcdGlzbWFwOiBcImlzTWFwXCIsXG4gIFx0bWF4bGVuZ3RoOiBcIm1heExlbmd0aFwiLFxuICBcdG5vdmFsaWRhdGU6IFwibm9WYWxpZGF0ZVwiLFxuICBcdHB1YmRhdGU6IFwicHViRGF0ZVwiLFxuICBcdHJlYWRvbmx5OiBcInJlYWRPbmx5XCIsXG4gIFx0cm93c3BhbjogXCJyb3dTcGFuXCIsXG4gIFx0dGFiaW5kZXg6IFwidGFiSW5kZXhcIixcbiAgXHR1c2VtYXA6IFwidXNlTWFwXCJcbiAgfTtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJHJlbmRlcihub2RlKSB7XG4gIFx0dmFyIHByb3BlcnR5TmFtZTtcblxuICBcdHRoaXMubm9kZSA9IG5vZGU7XG5cbiAgXHQvLyBzaG91bGQgd2UgdXNlIGRpcmVjdCBwcm9wZXJ0eSBhY2Nlc3MsIG9yIHNldEF0dHJpYnV0ZT9cbiAgXHRpZiAoIW5vZGUubmFtZXNwYWNlVVJJIHx8IG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLmh0bWwpIHtcbiAgXHRcdHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZXNbdGhpcy5uYW1lXSB8fCB0aGlzLm5hbWU7XG5cbiAgXHRcdGlmIChub2RlW3Byb3BlcnR5TmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gaXMgYXR0cmlidXRlIGEgYm9vbGVhbiBhdHRyaWJ1dGUgb3IgJ3ZhbHVlJz8gSWYgc28gd2UncmUgYmV0dGVyIG9mZiBkb2luZyBlLmcuXG4gIFx0XHQvLyBub2RlLnNlbGVjdGVkID0gdHJ1ZSByYXRoZXIgdGhhbiBub2RlLnNldEF0dHJpYnV0ZSggJ3NlbGVjdGVkJywgJycgKVxuICBcdFx0aWYgKHRoaXMuaXNCb29sZWFuIHx8IHRoaXMuaXNUd293YXkpIHtcbiAgXHRcdFx0dGhpcy51c2VQcm9wZXJ0eSA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChwcm9wZXJ0eU5hbWUgPT09IFwidmFsdWVcIikge1xuICBcdFx0XHRub2RlLl9yYWN0aXZlLnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHR0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgdmFyIEF0dHJpYnV0ZV9wcm90b3R5cGVfdG9TdHJpbmcgPSBBdHRyaWJ1dGUkdG9TdHJpbmc7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHRvU3RyaW5nKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICBcdHZhciBuYW1lc3BhY2VQcmVmaXggPSBfcmVmLm5hbWVzcGFjZVByZWZpeDtcbiAgXHR2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICBcdHZhciBpbnRlcnBvbGF0b3IgPSBfcmVmLmludGVycG9sYXRvcjtcbiAgXHR2YXIgZnJhZ21lbnQgPSBfcmVmLmZyYWdtZW50O1xuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gc2VsZWN0IGFuZCB0ZXh0YXJlYSB2YWx1ZXMgKHNob3VsZCBub3QgYmUgc3RyaW5naWZpZWQpXG4gIFx0aWYgKG5hbWUgPT09IFwidmFsdWVcIiAmJiAodGhpcy5lbGVtZW50Lm5hbWUgPT09IFwic2VsZWN0XCIgfHwgdGhpcy5lbGVtZW50Lm5hbWUgPT09IFwidGV4dGFyZWFcIikpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSBjb250ZW50IGVkaXRhYmxlXG4gIFx0aWYgKG5hbWUgPT09IFwidmFsdWVcIiAmJiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSByYWRpbyBuYW1lc1xuICBcdGlmIChuYW1lID09PSBcIm5hbWVcIiAmJiB0aGlzLmVsZW1lbnQubmFtZSA9PT0gXCJpbnB1dFwiICYmIGludGVycG9sYXRvcikge1xuICBcdFx0cmV0dXJuIFwibmFtZT17e1wiICsgKGludGVycG9sYXRvci5rZXlwYXRoLnN0ciB8fCBpbnRlcnBvbGF0b3IucmVmKSArIFwifX1cIjtcbiAgXHR9XG5cbiAgXHQvLyBCb29sZWFuIGF0dHJpYnV0ZXNcbiAgXHRpZiAodGhpcy5pc0Jvb2xlYW4pIHtcbiAgXHRcdHJldHVybiB2YWx1ZSA/IG5hbWUgOiBcIlwiO1xuICBcdH1cblxuICBcdGlmIChmcmFnbWVudCkge1xuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gdGhpcyBjYXRjaGVzIHVuZGVmaW5lZC9udWxsIHZhbHVlcyAoIzEyMTEpXG4gIFx0XHRpZiAoZnJhZ21lbnQuaXRlbXMubGVuZ3RoID09PSAxICYmIGZyYWdtZW50Lml0ZW1zWzBdLnZhbHVlID09IG51bGwpIHtcbiAgXHRcdFx0cmV0dXJuIFwiXCI7XG4gIFx0XHR9XG5cbiAgXHRcdHZhbHVlID0gZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgXHR9XG5cbiAgXHRpZiAobmFtZXNwYWNlUHJlZml4KSB7XG4gIFx0XHRuYW1lID0gbmFtZXNwYWNlUHJlZml4ICsgXCI6XCIgKyBuYW1lO1xuICBcdH1cblxuICBcdHJldHVybiB2YWx1ZSA/IG5hbWUgKyBcIj1cXFwiXCIgKyBBdHRyaWJ1dGVfcHJvdG90eXBlX3RvU3RyaW5nX19lc2NhcGUodmFsdWUpICsgXCJcXFwiXCIgOiBuYW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlX3Byb3RvdHlwZV90b1N0cmluZ19fZXNjYXBlKHZhbHVlKSB7XG4gIFx0cmV0dXJuIHZhbHVlLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKS5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKS5yZXBsYWNlKC8nL2csIFwiJiMzOTtcIik7XG4gIH1cblxuICB2YXIgQXR0cmlidXRlX3Byb3RvdHlwZV91bmJpbmQgPSBBdHRyaWJ1dGUkdW5iaW5kO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1bmJpbmQoKSB7XG4gIFx0Ly8gaWdub3JlIG5vbi1keW5hbWljIGF0dHJpYnV0ZXNcbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5uYW1lID09PSBcImlkXCIpIHtcbiAgXHRcdGRlbGV0ZSB0aGlzLnJvb3Qubm9kZXNbdGhpcy52YWx1ZV07XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZVNlbGVjdFZhbHVlID0gQXR0cmlidXRlJHVwZGF0ZVNlbGVjdDtcblxuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlU2VsZWN0KCkge1xuICBcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsXG4gIFx0ICAgIG9wdGlvbnMsXG4gIFx0ICAgIG9wdGlvbixcbiAgXHQgICAgb3B0aW9uVmFsdWUsXG4gIFx0ICAgIGk7XG5cbiAgXHRpZiAoIXRoaXMubG9ja2VkKSB7XG4gIFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcblxuICBcdFx0b3B0aW9ucyA9IHRoaXMubm9kZS5vcHRpb25zO1xuICBcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbaV07XG4gIFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlOyAvLyBvcHRpb25zIGluc2VydGVkIHZpYSBhIHRyaXBsZSBkb24ndCBoYXZlIF9yYWN0aXZlXG5cbiAgXHRcdFx0aWYgKG9wdGlvblZhbHVlID09IHZhbHVlKSB7XG4gIFx0XHRcdFx0Ly8gZG91YmxlIGVxdWFscyBhcyB3ZSBtYXkgYmUgY29tcGFyaW5nIG51bWJlcnMgd2l0aCBzdHJpbmdzXG4gIFx0XHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIGlmIHdlJ3JlIHN0aWxsIGhlcmUsIGl0IG1lYW5zIHRoZSBuZXcgdmFsdWUgZGlkbid0IG1hdGNoIGFueSBvZiB0aGUgb3B0aW9ucy4uLlxuICBcdC8vIFRPRE8gZmlndXJlIG91dCB3aGF0IHRvIGRvIGluIHRoaXMgc2l0dWF0aW9uXG4gIH1cblxuICB2YXIgdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSA9IEF0dHJpYnV0ZSR1cGRhdGVNdWx0aXBsZVNlbGVjdDtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZU11bHRpcGxlU2VsZWN0KCkge1xuICBcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsXG4gIFx0ICAgIG9wdGlvbnMsXG4gIFx0ICAgIGksXG4gIFx0ICAgIG9wdGlvbixcbiAgXHQgICAgb3B0aW9uVmFsdWU7XG5cbiAgXHRpZiAoIWlzQXJyYXkodmFsdWUpKSB7XG4gIFx0XHR2YWx1ZSA9IFt2YWx1ZV07XG4gIFx0fVxuXG4gIFx0b3B0aW9ucyA9IHRoaXMubm9kZS5vcHRpb25zO1xuICBcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdG9wdGlvbiA9IG9wdGlvbnNbaV07XG4gIFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTsgLy8gb3B0aW9ucyBpbnNlcnRlZCB2aWEgYSB0cmlwbGUgZG9uJ3QgaGF2ZSBfcmFjdGl2ZVxuICBcdFx0b3B0aW9uLnNlbGVjdGVkID0gYXJyYXlDb250YWlucyh2YWx1ZSwgb3B0aW9uVmFsdWUpO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVSYWRpb05hbWUgPSBBdHRyaWJ1dGUkdXBkYXRlUmFkaW9OYW1lO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVSYWRpb05hbWUoKSB7XG4gIFx0dmFyIF9yZWYgPSB0aGlzO1xuXG4gIFx0dmFyIG5vZGUgPSBfcmVmLm5vZGU7XG4gIFx0dmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcblxuICBcdG5vZGUuY2hlY2tlZCA9IHZhbHVlID09IG5vZGUuX3JhY3RpdmUudmFsdWU7XG4gIH1cblxuICB2YXIgdXBkYXRlUmFkaW9WYWx1ZSA9IEF0dHJpYnV0ZSR1cGRhdGVSYWRpb1ZhbHVlO1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlUmFkaW9WYWx1ZSgpIHtcbiAgXHR2YXIgd2FzQ2hlY2tlZCxcbiAgXHQgICAgbm9kZSA9IHRoaXMubm9kZSxcbiAgXHQgICAgYmluZGluZyxcbiAgXHQgICAgYmluZGluZ3MsXG4gIFx0ICAgIGk7XG5cbiAgXHR3YXNDaGVja2VkID0gbm9kZS5jaGVja2VkO1xuXG4gIFx0bm9kZS52YWx1ZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgXHRub2RlLmNoZWNrZWQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPT09IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpO1xuXG4gIFx0Ly8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSAtIGlmIHRoZSBpbnB1dCB3YXMgY2hlY2tlZCwgYW5kIHRoZSB2YWx1ZVxuICBcdC8vIGNoYW5nZWQgc28gdGhhdCBpdCdzIG5vIGxvbmdlciBjaGVja2VkLCB0aGUgdHdvd2F5IGJpbmRpbmcgaXNcbiAgXHQvLyBtb3N0IGxpa2VseSBvdXQgb2YgZGF0ZS4gVG8gZml4IGl0IHdlIGhhdmUgdG8ganVtcCB0aHJvdWdoIHNvbWVcbiAgXHQvLyBob29wcy4uLiB0aGlzIGlzIGEgbGl0dGxlIGtsdWRneSBidXQgaXQgd29ya3NcbiAgXHRpZiAod2FzQ2hlY2tlZCAmJiAhbm9kZS5jaGVja2VkICYmIHRoaXMuZWxlbWVudC5iaW5kaW5nKSB7XG4gIFx0XHRiaW5kaW5ncyA9IHRoaXMuZWxlbWVudC5iaW5kaW5nLnNpYmxpbmdzO1xuXG4gIFx0XHRpZiAoaSA9IGJpbmRpbmdzLmxlbmd0aCkge1xuICBcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzW2ldO1xuXG4gIFx0XHRcdFx0aWYgKCFiaW5kaW5nLmVsZW1lbnQubm9kZSkge1xuICBcdFx0XHRcdFx0Ly8gdGhpcyBpcyB0aGUgaW5pdGlhbCByZW5kZXIsIHNpYmxpbmdzIGFyZSBzdGlsbCByZW5kZXJpbmchXG4gIFx0XHRcdFx0XHQvLyB3ZSdsbCBjb21lIGJhY2sgbGF0ZXIuLi5cbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoYmluZGluZy5lbGVtZW50Lm5vZGUuY2hlY2tlZCkge1xuICBcdFx0XHRcdFx0Z2xvYmFsX3J1bmxvb3AuYWRkUmFjdGl2ZShiaW5kaW5nLnJvb3QpO1xuICBcdFx0XHRcdFx0cmV0dXJuIGJpbmRpbmcuaGFuZGxlQ2hhbmdlKCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoYmluZGluZy5rZXlwYXRoLCB1bmRlZmluZWQpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVDaGVja2JveE5hbWUgPSBBdHRyaWJ1dGUkdXBkYXRlQ2hlY2tib3hOYW1lO1xuICBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ2hlY2tib3hOYW1lKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBlbGVtZW50ID0gX3JlZi5lbGVtZW50O1xuICBcdHZhciBub2RlID0gX3JlZi5ub2RlO1xuICBcdHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7dmFyIGJpbmRpbmcgPSBlbGVtZW50LmJpbmRpbmc7dmFyIHZhbHVlQXR0cmlidXRlO3ZhciBpO1xuXG4gIFx0dmFsdWVBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIFx0aWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICBcdFx0YmluZGluZy5pc0NoZWNrZWQgPSBub2RlLmNoZWNrZWQgPSB2YWx1ZSA9PSB2YWx1ZUF0dHJpYnV0ZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0aSA9IHZhbHVlLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0aWYgKHZhbHVlQXR0cmlidXRlID09IHZhbHVlW2ldKSB7XG4gIFx0XHRcdFx0YmluZGluZy5pc0NoZWNrZWQgPSBub2RlLmNoZWNrZWQgPSB0cnVlO1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdFx0YmluZGluZy5pc0NoZWNrZWQgPSBub2RlLmNoZWNrZWQgPSBmYWxzZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlQ2xhc3NOYW1lID0gQXR0cmlidXRlJHVwZGF0ZUNsYXNzTmFtZTtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUNsYXNzTmFtZSgpIHtcbiAgXHR0aGlzLm5vZGUuY2xhc3NOYW1lID0gc2FmZVRvU3RyaW5nVmFsdWUodGhpcy52YWx1ZSk7XG4gIH1cblxuICB2YXIgdXBkYXRlSWRBdHRyaWJ1dGUgPSBBdHRyaWJ1dGUkdXBkYXRlSWRBdHRyaWJ1dGU7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUlkQXR0cmlidXRlKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBub2RlID0gX3JlZi5ub2RlO1xuICBcdHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG5cbiAgXHR0aGlzLnJvb3Qubm9kZXNbdmFsdWVdID0gbm9kZTtcbiAgXHRub2RlLmlkID0gdmFsdWU7XG4gIH1cblxuICB2YXIgdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZSA9IEF0dHJpYnV0ZSR1cGRhdGVJRVN0eWxlQXR0cmlidXRlO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVJRVN0eWxlQXR0cmlidXRlKCkge1xuICBcdHZhciBub2RlLCB2YWx1ZTtcblxuICBcdG5vZGUgPSB0aGlzLm5vZGU7XG4gIFx0dmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gIFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdHZhbHVlID0gXCJcIjtcbiAgXHR9XG5cbiAgXHRub2RlLnN0eWxlLnNldEF0dHJpYnV0ZShcImNzc1RleHRcIiwgdmFsdWUpO1xuICB9XG5cbiAgdmFyIHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlID0gQXR0cmlidXRlJHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZSgpIHtcbiAgXHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gIFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdHZhbHVlID0gXCJcIjtcbiAgXHR9XG5cbiAgXHRpZiAoIXRoaXMubG9ja2VkKSB7XG4gIFx0XHR0aGlzLm5vZGUuaW5uZXJIVE1MID0gdmFsdWU7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHVwZGF0ZVZhbHVlID0gQXR0cmlidXRlJHVwZGF0ZVZhbHVlO1xuXG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVWYWx1ZSgpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgbm9kZSA9IF9yZWYubm9kZTtcbiAgXHR2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuXG4gIFx0Ly8gc3RvcmUgYWN0dWFsIHZhbHVlLCBzbyBpdCBkb2Vzbid0IGdldCBjb2VyY2VkIHRvIGEgc3RyaW5nXG4gIFx0bm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0Ly8gd2l0aCB0d28td2F5IGJpbmRpbmcsIG9ubHkgdXBkYXRlIGlmIHRoZSBjaGFuZ2Ugd2Fzbid0IGluaXRpYXRlZCBieSB0aGUgdXNlclxuICBcdC8vIG90aGVyd2lzZSB0aGUgY3Vyc29yIHdpbGwgb2Z0ZW4gYmUgc2VudCB0byB0aGUgd3JvbmcgcGxhY2VcbiAgXHRpZiAoIXRoaXMubG9ja2VkKSB7XG4gIFx0XHRub2RlLnZhbHVlID0gdmFsdWUgPT0gdW5kZWZpbmVkID8gXCJcIiA6IHZhbHVlO1xuICBcdH1cbiAgfVxuXG4gIHZhciB1cGRhdGVCb29sZWFuID0gQXR0cmlidXRlJHVwZGF0ZUJvb2xlYW5BdHRyaWJ1dGU7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUJvb2xlYW5BdHRyaWJ1dGUoKSB7XG4gIFx0Ly8gd2l0aCB0d28td2F5IGJpbmRpbmcsIG9ubHkgdXBkYXRlIGlmIHRoZSBjaGFuZ2Ugd2Fzbid0IGluaXRpYXRlZCBieSB0aGUgdXNlclxuICBcdC8vIG90aGVyd2lzZSB0aGUgY3Vyc29yIHdpbGwgb2Z0ZW4gYmUgc2VudCB0byB0aGUgd3JvbmcgcGxhY2VcbiAgXHRpZiAoIXRoaXMubG9ja2VkKSB7XG4gIFx0XHR0aGlzLm5vZGVbdGhpcy5wcm9wZXJ0eU5hbWVdID0gdGhpcy52YWx1ZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdXBkYXRlRXZlcnl0aGluZ0Vsc2UgPSBBdHRyaWJ1dGUkdXBkYXRlRXZlcnl0aGluZ0Vsc2U7XG5cbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlKCkge1xuICBcdHZhciBfcmVmID0gdGhpcztcblxuICBcdHZhciBub2RlID0gX3JlZi5ub2RlO1xuICBcdHZhciBuYW1lc3BhY2UgPSBfcmVmLm5hbWVzcGFjZTtcbiAgXHR2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgXHR2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICBcdHZhciBmcmFnbWVudCA9IF9yZWYuZnJhZ21lbnQ7XG5cbiAgXHRpZiAobmFtZXNwYWNlKSB7XG4gIFx0XHRub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbmFtZSwgKGZyYWdtZW50IHx8IHZhbHVlKS50b1N0cmluZygpKTtcbiAgXHR9IGVsc2UgaWYgKCF0aGlzLmlzQm9vbGVhbikge1xuICBcdFx0aWYgKHZhbHVlID09IG51bGwpIHtcbiAgXHRcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAoZnJhZ21lbnQgfHwgdmFsdWUpLnRvU3RyaW5nKCkpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyAtIHRydXRoeSBiZWNvbWVzICcnLCBmYWxzeSBtZWFucyAncmVtb3ZlIGF0dHJpYnV0ZSdcbiAgXHRlbHNlIHtcbiAgXHRcdGlmICh2YWx1ZSkge1xuICBcdFx0XHRub2RlLnNldEF0dHJpYnV0ZShuYW1lLCBcIlwiKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIC8vIFRoZXJlIGFyZSBhIGZldyBzcGVjaWFsIGNhc2VzIHdoZW4gaXQgY29tZXMgdG8gdXBkYXRpbmcgYXR0cmlidXRlcy4gRm9yIHRoaXMgcmVhc29uLFxuICAvLyB0aGUgcHJvdG90eXBlIC51cGRhdGUoKSBtZXRob2QgcG9pbnRzIHRvIHRoaXMgbWV0aG9kLCB3aGljaCB3YWl0cyB1bnRpbCB0aGVcbiAgLy8gYXR0cmlidXRlIGhhcyBmaW5pc2hlZCBpbml0aWFsaXNpbmcsIHRoZW4gcmVwbGFjZXMgdGhlIHByb3RvdHlwZSBtZXRob2Qgd2l0aCBhIG1vcmVcbiAgLy8gc3VpdGFibGUgb25lLiBUaGF0IHdheSwgd2Ugc2F2ZSBvdXJzZWx2ZXMgZG9pbmcgYSBidW5jaCBvZiB0ZXN0cyBvbiBlYWNoIGNhbGxcbiAgdmFyIEF0dHJpYnV0ZV9wcm90b3R5cGVfdXBkYXRlID0gQXR0cmlidXRlJHVwZGF0ZTtcbiAgZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZSgpIHtcbiAgXHR2YXIgX3JlZiA9IHRoaXM7XG5cbiAgXHR2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgXHR2YXIgZWxlbWVudCA9IF9yZWYuZWxlbWVudDtcbiAgXHR2YXIgbm9kZSA9IF9yZWYubm9kZTt2YXIgdHlwZTt2YXIgdXBkYXRlTWV0aG9kO1xuXG4gIFx0aWYgKG5hbWUgPT09IFwiaWRcIikge1xuICBcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlSWRBdHRyaWJ1dGU7XG4gIFx0fSBlbHNlIGlmIChuYW1lID09PSBcInZhbHVlXCIpIHtcbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIHNlbGVjdHNcbiAgXHRcdGlmIChlbGVtZW50Lm5hbWUgPT09IFwic2VsZWN0XCIgJiYgbmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gIFx0XHRcdHVwZGF0ZU1ldGhvZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikgPyB1cGRhdGVNdWx0aXBsZVNlbGVjdFZhbHVlIDogdXBkYXRlU2VsZWN0VmFsdWU7XG4gIFx0XHR9IGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gXCJ0ZXh0YXJlYVwiKSB7XG4gIFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBjb250ZW50ZWRpdGFibGVcbiAgXHRcdGVsc2UgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpICE9IG51bGwpIHtcbiAgXHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIDxpbnB1dD5cbiAgXHRcdGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gXCJpbnB1dFwiKSB7XG4gIFx0XHRcdHR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG5cbiAgXHRcdFx0Ly8gdHlwZT0nZmlsZScgdmFsdWU9J3t7ZmlsZUxpc3R9fSc+XG4gIFx0XHRcdGlmICh0eXBlID09PSBcImZpbGVcIikge1xuICBcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IG5vb3A7IC8vIHJlYWQtb25seVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gdHlwZT0ncmFkaW8nIG5hbWU9J3t7dHdvd2F5fX0nXG4gIFx0XHRcdGVsc2UgaWYgKHR5cGUgPT09IFwicmFkaW9cIiAmJiBlbGVtZW50LmJpbmRpbmcgJiYgZWxlbWVudC5iaW5kaW5nLm5hbWUgPT09IFwibmFtZVwiKSB7XG4gIFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlUmFkaW9WYWx1ZTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVWYWx1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIHNwZWNpYWwgY2FzZSAtIDxpbnB1dCB0eXBlPSdyYWRpbycgbmFtZT0ne3t0d293YXl9fScgdmFsdWU9J2Zvbyc+XG4gIFx0ZWxzZSBpZiAodGhpcy5pc1R3b3dheSAmJiBuYW1lID09PSBcIm5hbWVcIikge1xuICBcdFx0aWYgKG5vZGUudHlwZSA9PT0gXCJyYWRpb1wiKSB7XG4gIFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVJhZGlvTmFtZTtcbiAgXHRcdH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgXHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQ2hlY2tib3hOYW1lO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIHNwZWNpYWwgY2FzZSAtIHN0eWxlIGF0dHJpYnV0ZXMgaW4gSW50ZXJuZXQgRXhwbG9kZXJcbiAgXHRlbHNlIGlmIChuYW1lID09PSBcInN0eWxlXCIgJiYgbm9kZS5zdHlsZS5zZXRBdHRyaWJ1dGUpIHtcbiAgXHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGU7XG4gIFx0fVxuXG4gIFx0Ly8gc3BlY2lhbCBjYXNlIC0gY2xhc3MgbmFtZXMuIElFIGZ1Y2tzIHRoaW5ncyB1cCwgYWdhaW5cbiAgXHRlbHNlIGlmIChuYW1lID09PSBcImNsYXNzXCIgJiYgKCFub2RlLm5hbWVzcGFjZVVSSSB8fCBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5odG1sKSkge1xuICBcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQ2xhc3NOYW1lO1xuICBcdH0gZWxzZSBpZiAodGhpcy51c2VQcm9wZXJ0eSkge1xuICBcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQm9vbGVhbjtcbiAgXHR9XG5cbiAgXHRpZiAoIXVwZGF0ZU1ldGhvZCkge1xuICBcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlRXZlcnl0aGluZ0Vsc2U7XG4gIFx0fVxuXG4gIFx0dGhpcy51cGRhdGUgPSB1cGRhdGVNZXRob2Q7XG4gIFx0dGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHZhciBBdHRyaWJ1dGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfTtcblxuICBBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogQXR0cmlidXRlX3Byb3RvdHlwZV9idWJibGUsXG4gIFx0aW5pdDogcHJvdG90eXBlX2luaXQsXG4gIFx0cmViaW5kOiBBdHRyaWJ1dGVfcHJvdG90eXBlX3JlYmluZCxcbiAgXHRyZW5kZXI6IEF0dHJpYnV0ZV9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHRvU3RyaW5nOiBBdHRyaWJ1dGVfcHJvdG90eXBlX3RvU3RyaW5nLFxuICBcdHVuYmluZDogQXR0cmlidXRlX3Byb3RvdHlwZV91bmJpbmQsXG4gIFx0dXBkYXRlOiBBdHRyaWJ1dGVfcHJvdG90eXBlX3VwZGF0ZVxuICB9O1xuXG4gIHZhciBfQXR0cmlidXRlID0gQXR0cmlidXRlO1xuXG4gIHZhciBjcmVhdGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgXHR2YXIgbmFtZSxcbiAgXHQgICAgYXR0cmlidXRlLFxuICBcdCAgICByZXN1bHQgPSBbXTtcblxuICBcdGZvciAobmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gIFx0XHQvLyBza2lwIGJpbmRpbmcgYXR0cmlidXRlc1xuICBcdFx0aWYgKG5hbWUgPT09IFwidHdvd2F5XCIgfHwgbmFtZSA9PT0gXCJsYXp5XCIpIHtcbiAgXHRcdFx0Y29udGludWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gIFx0XHRcdGF0dHJpYnV0ZSA9IG5ldyBfQXR0cmlidXRlKHtcbiAgXHRcdFx0XHRlbGVtZW50OiBlbGVtZW50LFxuICBcdFx0XHRcdG5hbWU6IG5hbWUsXG4gIFx0XHRcdFx0dmFsdWU6IGF0dHJpYnV0ZXNbbmFtZV0sXG4gIFx0XHRcdFx0cm9vdDogZWxlbWVudC5yb290XG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHJlc3VsdFtuYW1lXSA9IGF0dHJpYnV0ZTtcblxuICBcdFx0XHRpZiAobmFtZSAhPT0gXCJ2YWx1ZVwiKSB7XG4gIFx0XHRcdFx0cmVzdWx0LnB1c2goYXR0cmlidXRlKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIHZhbHVlIGF0dHJpYnV0ZSBnb2VzIGxhc3QuIFRoaXMgaXMgYmVjYXVzZSBpdFxuICBcdC8vIG1heSBnZXQgY2xhbXBlZCBvbiByZW5kZXIgb3RoZXJ3aXNlLCBlLmcuIGluXG4gIFx0Ly8gYDxpbnB1dCB0eXBlPSdyYW5nZScgdmFsdWU9Jzk5OScgbWluPScwJyBtYXg9JzEwMDAnPmBcbiAgXHQvLyBzaW5jZSBkZWZhdWx0IG1heCBpcyAxMDBcbiAgXHRpZiAoYXR0cmlidXRlID0gcmVzdWx0LnZhbHVlKSB7XG4gIFx0XHRyZXN1bHQucHVzaChhdHRyaWJ1dGUpO1xuICBcdH1cblxuICBcdHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIF9Db25kaXRpb25hbEF0dHJpYnV0ZV9fZGl2O1xuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgXHRfQ29uZGl0aW9uYWxBdHRyaWJ1dGVfX2RpdiA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIH1cblxuICB2YXIgQ29uZGl0aW9uYWxBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgdGVtcGxhdGUpIHtcbiAgXHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IGVsZW1lbnQucm9vdDtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcblxuICBcdHRoaXMuYXR0cmlidXRlcyA9IFtdO1xuXG4gIFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdHJvb3Q6IGVsZW1lbnQucm9vdCxcbiAgXHRcdG93bmVyOiB0aGlzLFxuICBcdFx0dGVtcGxhdGU6IFt0ZW1wbGF0ZV1cbiAgXHR9KTtcbiAgfTtcblxuICBDb25kaXRpb25hbEF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG4gIFx0YnViYmxlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5ub2RlKSB7XG4gIFx0XHRcdHRoaXMudXBkYXRlKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZWxlbWVudC5idWJibGUoKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgXHRcdHRoaXMubm9kZSA9IG5vZGU7XG4gIFx0XHR0aGlzLmlzU3ZnID0gbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuc3ZnO1xuXG4gIFx0XHR0aGlzLnVwZGF0ZSgpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fSxcblxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIHN0ciwgYXR0cnM7XG5cbiAgXHRcdHN0ciA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgXHRcdGF0dHJzID0gcGFyc2VBdHRyaWJ1dGVzKHN0ciwgdGhpcy5pc1N2Zyk7XG5cbiAgXHRcdC8vIGFueSBhdHRyaWJ1dGVzIHRoYXQgcHJldmlvdXNseSBleGlzdGVkIGJ1dCBubyBsb25nZXIgZG9cbiAgXHRcdC8vIG11c3QgYmUgcmVtb3ZlZFxuICBcdFx0dGhpcy5hdHRyaWJ1dGVzLmZpbHRlcihmdW5jdGlvbiAoYSkge1xuICBcdFx0XHRyZXR1cm4gbm90SW4oYXR0cnMsIGEpO1xuICBcdFx0fSkuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICBcdFx0XHRfdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShhLm5hbWUpO1xuICBcdFx0fSk7XG5cbiAgXHRcdGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgXHRcdFx0X3RoaXMubm9kZS5zZXRBdHRyaWJ1dGUoYS5uYW1lLCBhLnZhbHVlKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBfQ29uZGl0aW9uYWxBdHRyaWJ1dGUgPSBDb25kaXRpb25hbEF0dHJpYnV0ZTtcblxuICBmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoc3RyLCBpc1N2Zykge1xuICBcdHZhciB0YWcgPSBpc1N2ZyA/IFwic3ZnXCIgOiBcImRpdlwiO1xuICBcdF9Db25kaXRpb25hbEF0dHJpYnV0ZV9fZGl2LmlubmVySFRNTCA9IFwiPFwiICsgdGFnICsgXCIgXCIgKyBzdHIgKyBcIj48L1wiICsgdGFnICsgXCI+XCI7XG5cbiAgXHRyZXR1cm4gdG9BcnJheShfQ29uZGl0aW9uYWxBdHRyaWJ1dGVfX2Rpdi5jaGlsZE5vZGVzWzBdLmF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90SW4oaGF5c3RhY2ssIG5lZWRsZSkge1xuICBcdHZhciBpID0gaGF5c3RhY2subGVuZ3RoO1xuXG4gIFx0d2hpbGUgKGktLSkge1xuICBcdFx0aWYgKGhheXN0YWNrW2ldLm5hbWUgPT09IG5lZWRsZS5uYW1lKSB7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBjcmVhdGVDb25kaXRpb25hbEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBcdGlmICghYXR0cmlidXRlcykge1xuICBcdFx0cmV0dXJuIFtdO1xuICBcdH1cblxuICBcdHJldHVybiBhdHRyaWJ1dGVzLm1hcChmdW5jdGlvbiAoYSkge1xuICBcdFx0cmV0dXJuIG5ldyBfQ29uZGl0aW9uYWxBdHRyaWJ1dGUoZWxlbWVudCwgYSk7XG4gIFx0fSk7XG4gIH07XG5cbiAgdmFyIEJpbmRpbmcgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBcdHZhciBpbnRlcnBvbGF0b3IsIGtleXBhdGgsIHZhbHVlLCBwYXJlbnRGb3JtO1xuXG4gIFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgXHR0aGlzLnJvb3QgPSBlbGVtZW50LnJvb3Q7XG4gIFx0dGhpcy5hdHRyaWJ1dGUgPSBlbGVtZW50LmF0dHJpYnV0ZXNbdGhpcy5uYW1lIHx8IFwidmFsdWVcIl07XG5cbiAgXHRpbnRlcnBvbGF0b3IgPSB0aGlzLmF0dHJpYnV0ZS5pbnRlcnBvbGF0b3I7XG4gIFx0aW50ZXJwb2xhdG9yLnR3b3dheUJpbmRpbmcgPSB0aGlzO1xuXG4gIFx0aWYgKGtleXBhdGggPSBpbnRlcnBvbGF0b3Iua2V5cGF0aCkge1xuICBcdFx0aWYgKGtleXBhdGguc3RyLnNsaWNlKC0xKSA9PT0gXCJ9XCIpIHtcbiAgXHRcdFx0d2Fybk9uY2VJZkRlYnVnKFwiVHdvLXdheSBiaW5kaW5nIGRvZXMgbm90IHdvcmsgd2l0aCBleHByZXNzaW9ucyAoYCVzYCBvbiA8JXM+KVwiLCBpbnRlcnBvbGF0b3IucmVzb2x2ZXIudW5pcXVlU3RyaW5nLCBlbGVtZW50Lm5hbWUsIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChrZXlwYXRoLmlzU3BlY2lhbCkge1xuICBcdFx0XHR3YXJuT25jZUlmRGVidWcoXCJUd28td2F5IGJpbmRpbmcgZG9lcyBub3Qgd29yayB3aXRoICVzXCIsIGludGVycG9sYXRvci5yZXNvbHZlci5yZWYsIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIEEgbXVzdGFjaGUgbWF5IGJlICphbWJpZ3VvdXMqLiBMZXQncyBzYXkgd2Ugd2VyZSBnaXZlblxuICBcdFx0Ly8gYHZhbHVlPVwie3tiYXJ9fVwiYC4gSWYgdGhlIGNvbnRleHQgd2FzIGBmb29gLCBhbmQgYGZvby5iYXJgXG4gIFx0XHQvLyAqd2Fzbid0KiBgdW5kZWZpbmVkYCwgdGhlIGtleXBhdGggd291bGQgYmUgYGZvby5iYXJgLlxuICBcdFx0Ly8gVGhlbiwgYW55IHVzZXIgaW5wdXQgd291bGQgcmVzdWx0IGluIGBmb28uYmFyYCBiZWluZyB1cGRhdGVkLlxuICBcdFx0Ly9cbiAgXHRcdC8vIElmLCBob3dldmVyLCBgZm9vLmJhcmAgKndhcyogdW5kZWZpbmVkLCBhbmQgc28gd2FzIGBiYXJgLCB3ZSB3b3VsZCBiZVxuICBcdFx0Ly8gbGVmdCB3aXRoIGFuIHVucmVzb2x2ZWQgcGFydGlhbCBrZXlwYXRoIC0gc28gd2UgYXJlIGZvcmNlZCB0byBtYWtlIGFuXG4gIFx0XHQvLyBhc3N1bXB0aW9uLiBUaGF0IGFzc3VtcHRpb24gaXMgdGhhdCB0aGUgaW5wdXQgaW4gcXVlc3Rpb24gc2hvdWxkXG4gIFx0XHQvLyBiZSBmb3JjZWQgdG8gcmVzb2x2ZSB0byBgYmFyYCwgYW5kIGFueSB1c2VyIGlucHV0IHdvdWxkIGFmZmVjdCBgYmFyYFxuICBcdFx0Ly8gYW5kIG5vdCBgZm9vLmJhcmAuXG4gIFx0XHQvL1xuICBcdFx0Ly8gRGlkIHRoYXQgbWFrZSBhbnkgc2Vuc2U/IE5vPyBPaC4gU29ycnkuIFdlbGwgdGhlIG1vcmFsIG9mIHRoZSBzdG9yeSBpc1xuICBcdFx0Ly8gYmUgZXhwbGljaXQgd2hlbiB1c2luZyB0d28td2F5IGRhdGEtYmluZGluZyBhYm91dCB3aGF0IGtleXBhdGggeW91J3JlXG4gIFx0XHQvLyB1cGRhdGluZy4gVXNpbmcgaXQgaW4gbGlzdHMgaXMgcHJvYmFibHkgYSByZWNpcGUgZm9yIGNvbmZ1c2lvbi4uLlxuICBcdFx0dmFyIHJlZiA9IGludGVycG9sYXRvci50ZW1wbGF0ZS5yID8gXCInXCIgKyBpbnRlcnBvbGF0b3IudGVtcGxhdGUuciArIFwiJyByZWZlcmVuY2VcIiA6IFwiZXhwcmVzc2lvblwiO1xuICBcdFx0d2FybklmRGVidWcoXCJUaGUgJXMgYmVpbmcgdXNlZCBmb3IgdHdvLXdheSBiaW5kaW5nIGlzIGFtYmlndW91cywgYW5kIG1heSBjYXVzZSB1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnNpZGVyIGluaXRpYWxpc2luZyB5b3VyIGRhdGEgdG8gZWxpbWluYXRlIHRoZSBhbWJpZ3VpdHlcIiwgcmVmLCB7IHJhY3RpdmU6IHRoaXMucm9vdCB9KTtcbiAgXHRcdGludGVycG9sYXRvci5yZXNvbHZlci5mb3JjZVJlc29sdXRpb24oKTtcbiAgXHRcdGtleXBhdGggPSBpbnRlcnBvbGF0b3Iua2V5cGF0aDtcbiAgXHR9XG5cbiAgXHR0aGlzLmF0dHJpYnV0ZS5pc1R3b3dheSA9IHRydWU7XG4gIFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblxuICBcdC8vIGluaXRpYWxpc2UgdmFsdWUsIGlmIGl0J3MgdW5kZWZpbmVkXG4gIFx0dmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuZ2V0SW5pdGlhbFZhbHVlKSB7XG4gIFx0XHR2YWx1ZSA9IHRoaXMuZ2V0SW5pdGlhbFZhbHVlKCk7XG5cbiAgXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAocGFyZW50Rm9ybSA9IGZpbmRQYXJlbnRGb3JtKGVsZW1lbnQpKSB7XG4gIFx0XHR0aGlzLnJlc2V0VmFsdWUgPSB2YWx1ZTtcbiAgXHRcdHBhcmVudEZvcm0uZm9ybUJpbmRpbmdzLnB1c2godGhpcyk7XG4gIFx0fVxuICB9O1xuXG4gIEJpbmRpbmcucHJvdG90eXBlID0ge1xuICBcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc3RhcnQodGhpcy5yb290KTtcbiAgXHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG4gIFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCh0aGlzLmtleXBhdGgsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gX3RoaXMuYXR0cmlidXRlLmxvY2tlZCA9IGZhbHNlO1xuICBcdFx0fSk7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcbiAgXHR9LFxuXG4gIFx0cmVib3VuZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGJpbmRpbmdzLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoO1xuXG4gIFx0XHRvbGRLZXlwYXRoID0gdGhpcy5rZXlwYXRoO1xuICBcdFx0bmV3S2V5cGF0aCA9IHRoaXMuYXR0cmlidXRlLmludGVycG9sYXRvci5rZXlwYXRoO1xuXG4gIFx0XHQvLyBUaGUgYXR0cmlidXRlIHRoaXMgYmluZGluZyBpcyBsaW5rZWQgdG8gaGFzIGFscmVhZHkgZG9uZSB0aGUgd29ya1xuICBcdFx0aWYgKG9sZEtleXBhdGggPT09IG5ld0tleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tvbGRLZXlwYXRoLnN0cl0sIHRoaXMpO1xuXG4gIFx0XHR0aGlzLmtleXBhdGggPSBuZXdLZXlwYXRoO1xuXG4gIFx0XHRiaW5kaW5ncyA9IHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbbmV3S2V5cGF0aC5zdHJdIHx8ICh0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzW25ld0tleXBhdGguc3RyXSA9IFtdKTtcbiAgXHRcdGJpbmRpbmdzLnB1c2godGhpcyk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge31cbiAgfTtcblxuICBCaW5kaW5nLmV4dGVuZCA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG4gIFx0dmFyIFBhcmVudCA9IHRoaXMsXG4gIFx0ICAgIFNwZWNpYWxpc2VkQmluZGluZztcblxuICBcdFNwZWNpYWxpc2VkQmluZGluZyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIFx0XHRCaW5kaW5nLmNhbGwodGhpcywgZWxlbWVudCk7XG5cbiAgXHRcdGlmICh0aGlzLmluaXQpIHtcbiAgXHRcdFx0dGhpcy5pbml0KCk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdFNwZWNpYWxpc2VkQmluZGluZy5wcm90b3R5cGUgPSBjcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG4gIFx0dXRpbHNfb2JqZWN0X19leHRlbmQoU3BlY2lhbGlzZWRCaW5kaW5nLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG5cbiAgXHRTcGVjaWFsaXNlZEJpbmRpbmcuZXh0ZW5kID0gQmluZGluZy5leHRlbmQ7XG5cbiAgXHRyZXR1cm4gU3BlY2lhbGlzZWRCaW5kaW5nO1xuICB9O1xuXG4gIHZhciBCaW5kaW5nX0JpbmRpbmcgPSBCaW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGZpbmRQYXJlbnRGb3JtKGVsZW1lbnQpIHtcbiAgXHR3aGlsZSAoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50KSB7XG4gIFx0XHRpZiAoZWxlbWVudC5uYW1lID09PSBcImZvcm1cIikge1xuICBcdFx0XHRyZXR1cm4gZWxlbWVudDtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICAvLyB0aGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBlbGVtZW50IGlzIHVuYm91bmQuXG4gIC8vIFNwZWNpYWxpc2VkIGJpbmRpbmdzIGNhbiBvdmVycmlkZSBpdFxuXG4gIC8vIFRoaXMgaXMgdGhlIGhhbmRsZXIgZm9yIERPTSBldmVudHMgdGhhdCB3b3VsZCBsZWFkIHRvIGEgY2hhbmdlIGluIHRoZSBtb2RlbFxuICAvLyAoaS5lLiBjaGFuZ2UsIHNvbWV0aW1lcywgaW5wdXQsIGFuZCBvY2Nhc2lvbmFsbHkgY2xpY2sgYW5kIGtleXVwKVxuICB2YXIgaGFuZGxlRG9tRXZlbnQgPSBoYW5kbGVDaGFuZ2U7XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKCkge1xuICBcdHRoaXMuX3JhY3RpdmUuYmluZGluZy5oYW5kbGVDaGFuZ2UoKTtcbiAgfVxuXG4gIHZhciBDb250ZW50RWRpdGFibGVCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmZyYWdtZW50ID8gdGhpcy5lbGVtZW50LmZyYWdtZW50LnRvU3RyaW5nKCkgOiBcIlwiO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuXG4gIFx0XHRpZiAoIXRoaXMucm9vdC5sYXp5KSB7XG4gIFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG5cbiAgXHRcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmlubmVySFRNTDtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX0NvbnRlbnRFZGl0YWJsZUJpbmRpbmcgPSBDb250ZW50RWRpdGFibGVCaW5kaW5nO1xuXG4gIHZhciBzaGFyZWRfZ2V0U2libGluZ3MgPSBnZXRTaWJsaW5ncztcbiAgdmFyIHNldHMgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0U2libGluZ3MoaWQsIGdyb3VwLCBrZXlwYXRoKSB7XG4gIFx0dmFyIGhhc2ggPSBpZCArIGdyb3VwICsga2V5cGF0aDtcbiAgXHRyZXR1cm4gc2V0c1toYXNoXSB8fCAoc2V0c1toYXNoXSA9IFtdKTtcbiAgfVxuXG4gIHZhciBSYWRpb0JpbmRpbmcgPSBCaW5kaW5nX0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRuYW1lOiBcImNoZWNrZWRcIixcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuc2libGluZ3MgPSBzaGFyZWRfZ2V0U2libGluZ3ModGhpcy5yb290Ll9ndWlkLCBcInJhZGlvXCIsIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpKTtcbiAgXHRcdHRoaXMuc2libGluZ3MucHVzaCh0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLnJvb3QpO1xuXG4gIFx0XHR0aGlzLnNpYmxpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgXHRcdFx0YmluZGluZy5yb290LnZpZXdtb2RlbC5zZXQoYmluZGluZy5rZXlwYXRoLCBiaW5kaW5nLmdldFZhbHVlKCkpO1xuICBcdFx0fSk7XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuc2libGluZ3MsIHRoaXMpO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfUmFkaW9CaW5kaW5nID0gUmFkaW9CaW5kaW5nO1xuXG4gIHZhciBSYWRpb05hbWVCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0bmFtZTogXCJuYW1lXCIsXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLnNpYmxpbmdzID0gc2hhcmVkX2dldFNpYmxpbmdzKHRoaXMucm9vdC5fZ3VpZCwgXCJyYWRpb25hbWVcIiwgdGhpcy5rZXlwYXRoLnN0cik7XG4gIFx0XHR0aGlzLnNpYmxpbmdzLnB1c2godGhpcyk7XG5cbiAgXHRcdHRoaXMucmFkaW9OYW1lID0gdHJ1ZTsgLy8gc28gdGhhdCByYWN0aXZlLnVwZGF0ZU1vZGVsKCkga25vd3Mgd2hhdCB0byBkbyB3aXRoIHRoaXNcbiAgXHR9LFxuXG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImNoZWNrZWRcIikpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLm5hbWUgPSBcInt7XCIgKyB0aGlzLmtleXBhdGguc3RyICsgXCJ9fVwiO1xuICBcdFx0bm9kZS5jaGVja2VkID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQodGhpcy5rZXlwYXRoKSA9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuXG4gIFx0XHRpZiAobm9kZS5hdHRhY2hFdmVudCkge1xuICBcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcbiAgXHRcdHJldHVybiBub2RlLl9yYWN0aXZlID8gbm9kZS5fcmFjdGl2ZS52YWx1ZSA6IG5vZGUudmFsdWU7XG4gIFx0fSxcblxuICBcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gSWYgdGhpcyA8aW5wdXQ+IGlzIHRoZSBvbmUgdGhhdCdzIGNoZWNrZWQsIHRoZW4gdGhlIHZhbHVlIG9mIGl0c1xuICBcdFx0Ly8gYG5hbWVgIGtleXBhdGggZ2V0cyBzZXQgdG8gaXRzIHZhbHVlXG4gIFx0XHRpZiAodGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZCkge1xuICBcdFx0XHRCaW5kaW5nX0JpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZS5jYWxsKHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZWJvdW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dmFyIG5vZGU7XG5cbiAgXHRcdEJpbmRpbmdfQmluZGluZy5wcm90b3R5cGUucmVib3VuZC5jYWxsKHRoaXMsIG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuXG4gIFx0XHRpZiAobm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlKSB7XG4gIFx0XHRcdG5vZGUubmFtZSA9IFwie3tcIiArIHRoaXMua2V5cGF0aC5zdHIgKyBcIn19XCI7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuc2libGluZ3MsIHRoaXMpO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIEJpbmRpbmdfUmFkaW9OYW1lQmluZGluZyA9IFJhZGlvTmFtZUJpbmRpbmc7XG5cbiAgdmFyIENoZWNrYm94TmFtZUJpbmRpbmcgPSBCaW5kaW5nX0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRuYW1lOiBcIm5hbWVcIixcblxuICBcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0Ly8gVGhpcyBvbmx5IGdldHMgY2FsbGVkIG9uY2UgcGVyIGdyb3VwIChvZiBpbnB1dHMgdGhhdFxuICBcdFx0Ly8gc2hhcmUgYSBuYW1lKSwgYmVjYXVzZSBpdCBvbmx5IGdldHMgY2FsbGVkIGlmIHRoZXJlXG4gIFx0XHQvLyBpc24ndCBhbiBpbml0aWFsIHZhbHVlLiBCeSB0aGUgc2FtZSB0b2tlbiwgd2UgY2FuIG1ha2VcbiAgXHRcdC8vIGEgbm90ZSBvZiB0aGF0IGZhY3QgdGhhdCB0aGVyZSB3YXMgbm8gaW5pdGlhbCB2YWx1ZSxcbiAgXHRcdC8vIGFuZCBwb3B1bGF0ZSBpdCB1c2luZyBhbnkgYGNoZWNrZWRgIGF0dHJpYnV0ZXMgdGhhdFxuICBcdFx0Ly8gZXhpc3QgKHdoaWNoIHVzZXJzIHNob3VsZCBhdm9pZCwgYnV0IHdoaWNoIHdlIHNob3VsZFxuICBcdFx0Ly8gc3VwcG9ydCBhbnl3YXkgdG8gYXZvaWQgYnJlYWtpbmcgZXhwZWN0YXRpb25zKVxuICBcdFx0dGhpcy5ub0luaXRpYWxWYWx1ZSA9IHRydWU7XG4gIFx0XHRyZXR1cm4gW107XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBleGlzdGluZ1ZhbHVlLCBiaW5kaW5nVmFsdWU7XG5cbiAgXHRcdHRoaXMuY2hlY2tib3hOYW1lID0gdHJ1ZTsgLy8gc28gdGhhdCByYWN0aXZlLnVwZGF0ZU1vZGVsKCkga25vd3Mgd2hhdCB0byBkbyB3aXRoIHRoaXNcblxuICBcdFx0Ly8gRWFjaCBpbnB1dCBoYXMgYSByZWZlcmVuY2UgdG8gYW4gYXJyYXkgY29udGFpbmluZyBpdCBhbmQgaXRzXG4gIFx0XHQvLyBzaWJsaW5ncywgYXMgdHdvLXdheSBiaW5kaW5nIGRlcGVuZHMgb24gYmVpbmcgYWJsZSB0byBhc2NlcnRhaW5cbiAgXHRcdC8vIHRoZSBzdGF0dXMgb2YgYWxsIGlucHV0cyB3aXRoaW4gdGhlIGdyb3VwXG4gIFx0XHR0aGlzLnNpYmxpbmdzID0gc2hhcmVkX2dldFNpYmxpbmdzKHRoaXMucm9vdC5fZ3VpZCwgXCJjaGVja2JveGVzXCIsIHRoaXMua2V5cGF0aC5zdHIpO1xuICBcdFx0dGhpcy5zaWJsaW5ncy5wdXNoKHRoaXMpO1xuXG4gIFx0XHRpZiAodGhpcy5ub0luaXRpYWxWYWx1ZSkge1xuICBcdFx0XHR0aGlzLnNpYmxpbmdzLm5vSW5pdGlhbFZhbHVlID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSWYgbm8gaW5pdGlhbCB2YWx1ZSB3YXMgc2V0LCBhbmQgdGhpcyBpbnB1dCBpcyBjaGVja2VkLCB3ZVxuICBcdFx0Ly8gdXBkYXRlIHRoZSBtb2RlbFxuICBcdFx0aWYgKHRoaXMuc2libGluZ3Mubm9Jbml0aWFsVmFsdWUgJiYgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImNoZWNrZWRcIikpIHtcbiAgXHRcdFx0ZXhpc3RpbmdWYWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KHRoaXMua2V5cGF0aCk7XG4gIFx0XHRcdGJpbmRpbmdWYWx1ZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblxuICBcdFx0XHRleGlzdGluZ1ZhbHVlLnB1c2goYmluZGluZ1ZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkodGhpcy5zaWJsaW5ncywgdGhpcyk7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZSxcbiAgXHRcdCAgICBleGlzdGluZ1ZhbHVlLFxuICBcdFx0ICAgIGJpbmRpbmdWYWx1ZTtcblxuICBcdFx0ZXhpc3RpbmdWYWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KHRoaXMua2V5cGF0aCk7XG4gIFx0XHRiaW5kaW5nVmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRcdGlmIChpc0FycmF5KGV4aXN0aW5nVmFsdWUpKSB7XG4gIFx0XHRcdHRoaXMuaXNDaGVja2VkID0gYXJyYXlDb250YWlucyhleGlzdGluZ1ZhbHVlLCBiaW5kaW5nVmFsdWUpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5pc0NoZWNrZWQgPSBleGlzdGluZ1ZhbHVlID09IGJpbmRpbmdWYWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0bm9kZS5uYW1lID0gXCJ7e1wiICsgdGhpcy5rZXlwYXRoLnN0ciArIFwifX1cIjtcbiAgXHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMuaXNDaGVja2VkO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0Ly8gaW4gY2FzZSBvZiBJRSBlbWVyZ2VuY3ksIGJpbmQgdG8gY2xpY2sgZXZlbnQgYXMgd2VsbFxuICBcdFx0aWYgKG5vZGUuYXR0YWNoRXZlbnQpIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHR9LFxuXG4gIFx0Y2hhbmdlZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHdhc0NoZWNrZWQgPSAhIXRoaXMuaXNDaGVja2VkO1xuICBcdFx0dGhpcy5pc0NoZWNrZWQgPSB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuICBcdFx0cmV0dXJuIHRoaXMuaXNDaGVja2VkID09PSB3YXNDaGVja2VkO1xuICBcdH0sXG5cbiAgXHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuaXNDaGVja2VkID0gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcbiAgXHRcdEJpbmRpbmdfQmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwodGhpcyk7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zaWJsaW5ncy5maWx0ZXIoaXNDaGVja2VkKS5tYXAoQmluZGluZ19DaGVja2JveE5hbWVCaW5kaW5nX19nZXRWYWx1ZSk7XG4gIFx0fVxuICB9KTtcblxuICBmdW5jdGlvbiBpc0NoZWNrZWQoYmluZGluZykge1xuICBcdHJldHVybiBiaW5kaW5nLmlzQ2hlY2tlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIEJpbmRpbmdfQ2hlY2tib3hOYW1lQmluZGluZ19fZ2V0VmFsdWUoYmluZGluZykge1xuICBcdHJldHVybiBiaW5kaW5nLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIH1cblxuICB2YXIgQmluZGluZ19DaGVja2JveE5hbWVCaW5kaW5nID0gQ2hlY2tib3hOYW1lQmluZGluZztcblxuICB2YXIgQ2hlY2tib3hCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0bmFtZTogXCJjaGVja2VkXCIsXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuXG4gIFx0XHRpZiAobm9kZS5hdHRhY2hFdmVudCkge1xuICBcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblxuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19DaGVja2JveEJpbmRpbmcgPSBDaGVja2JveEJpbmRpbmc7XG5cbiAgdmFyIFNlbGVjdEJpbmRpbmcgPSBCaW5kaW5nX0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBvcHRpb25zID0gdGhpcy5lbGVtZW50Lm9wdGlvbnMsXG4gIFx0XHQgICAgbGVuLFxuICBcdFx0ICAgIGksXG4gIFx0XHQgICAgdmFsdWUsXG4gIFx0XHQgICAgb3B0aW9uV2FzU2VsZWN0ZWQ7XG5cbiAgXHRcdGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGkgPSBsZW4gPSBvcHRpb25zLmxlbmd0aDtcblxuICBcdFx0aWYgKCFsZW4pIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyB0YWtlIHRoZSBmaW5hbCBzZWxlY3RlZCBvcHRpb24uLi5cbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0aWYgKG9wdGlvbnNbaV0uZ2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIikpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IG9wdGlvbnNbaV0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0XHRcdFx0b3B0aW9uV2FzU2VsZWN0ZWQgPSB0cnVlO1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIG9yIHRoZSBmaXJzdCBub24tZGlzYWJsZWQgb3B0aW9uLCBpZiBub25lIGFyZSBzZWxlY3RlZFxuICBcdFx0aWYgKCFvcHRpb25XYXNTZWxlY3RlZCkge1xuICBcdFx0XHR3aGlsZSAoKytpIDwgbGVuKSB7XG4gIFx0XHRcdFx0aWYgKCFvcHRpb25zW2ldLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpKSB7XG4gIFx0XHRcdFx0XHR2YWx1ZSA9IG9wdGlvbnNbaV0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0XHRcdFx0XHRicmVhaztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gVGhpcyBpcyBhbiBvcHRpbWlzYXRpb24gKGFrYSBoYWNrKSB0aGF0IGFsbG93cyB1cyB0byBmb3JnbyBzb21lXG4gIFx0XHQvLyBvdGhlciBtb3JlIGV4cGVuc2l2ZSB3b3JrXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0aGlzLmVsZW1lbnQuYXR0cmlidXRlcy52YWx1ZS52YWx1ZSA9IHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVEb21FdmVudCwgZmFsc2UpO1xuICBcdH0sXG5cbiAgXHQvLyBUT0RPIHRoaXMgbWV0aG9kIGlzIGFuIGFub21hbHkuLi4gaXMgaXQgbmVjZXNzYXJ5P1xuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KHRoaXMua2V5cGF0aCwgdmFsdWUpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIG9wdGlvbnMsIGksIGxlbiwgb3B0aW9uLCBvcHRpb25WYWx1ZTtcblxuICBcdFx0b3B0aW9ucyA9IHRoaXMuZWxlbWVudC5ub2RlLm9wdGlvbnM7XG4gIFx0XHRsZW4gPSBvcHRpb25zLmxlbmd0aDtcblxuICBcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbaV07XG5cbiAgXHRcdFx0aWYgKG9wdGlvbnNbaV0uc2VsZWN0ZWQpIHtcbiAgXHRcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTtcbiAgXHRcdFx0XHRyZXR1cm4gb3B0aW9uVmFsdWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0Zm9yY2VVcGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICBcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gdHJ1ZTtcbiAgXHRcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRyZXR1cm4gX3RoaXMuYXR0cmlidXRlLmxvY2tlZCA9IGZhbHNlO1xuICBcdFx0XHR9KTtcbiAgXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQodGhpcy5rZXlwYXRoLCB2YWx1ZSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19TZWxlY3RCaW5kaW5nID0gU2VsZWN0QmluZGluZztcblxuICB2YXIgTXVsdGlwbGVTZWxlY3RCaW5kaW5nID0gQmluZGluZ19TZWxlY3RCaW5kaW5nLmV4dGVuZCh7XG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgXHRcdFx0cmV0dXJuIG9wdGlvbi5nZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKTtcbiAgXHRcdH0pLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7XG4gIFx0XHRcdHJldHVybiBvcHRpb24uZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0XHR9KTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgdmFsdWVGcm9tTW9kZWw7XG5cbiAgXHRcdHRoaXMuZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0dmFsdWVGcm9tTW9kZWwgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLmtleXBhdGgpO1xuXG4gIFx0XHRpZiAodmFsdWVGcm9tTW9kZWwgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHQvLyBnZXQgdmFsdWUgZnJvbSBET00sIGlmIHBvc3NpYmxlXG4gIFx0XHRcdHRoaXMuaGFuZGxlQ2hhbmdlKCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdHNldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUT0RPIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgc2VsZWN0ZWRWYWx1ZXMsIG9wdGlvbnMsIGksIGxlbiwgb3B0aW9uLCBvcHRpb25WYWx1ZTtcblxuICBcdFx0c2VsZWN0ZWRWYWx1ZXMgPSBbXTtcbiAgXHRcdG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQubm9kZS5vcHRpb25zO1xuICBcdFx0bGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRvcHRpb24gPSBvcHRpb25zW2ldO1xuXG4gIFx0XHRcdGlmIChvcHRpb24uc2VsZWN0ZWQpIHtcbiAgXHRcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTtcbiAgXHRcdFx0XHRzZWxlY3RlZFZhbHVlcy5wdXNoKG9wdGlvblZhbHVlKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gc2VsZWN0ZWRWYWx1ZXM7XG4gIFx0fSxcblxuICBcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGF0dHJpYnV0ZSwgcHJldmlvdXNWYWx1ZSwgdmFsdWU7XG5cbiAgXHRcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlO1xuICBcdFx0cHJldmlvdXNWYWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcblxuICBcdFx0dmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgXHRcdGlmIChwcmV2aW91c1ZhbHVlID09PSB1bmRlZmluZWQgfHwgIWFycmF5Q29udGVudHNNYXRjaCh2YWx1ZSwgcHJldmlvdXNWYWx1ZSkpIHtcbiAgXHRcdFx0QmluZGluZ19TZWxlY3RCaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UuY2FsbCh0aGlzKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXM7XG4gIFx0fSxcblxuICBcdGZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIF90aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcbiAgXHRcdFx0fSk7XG4gIFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KHRoaXMua2V5cGF0aCwgdmFsdWUpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1cGRhdGVNb2RlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKHRoaXMuYXR0cmlidXRlLnZhbHVlID09PSB1bmRlZmluZWQgfHwgIXRoaXMuYXR0cmlidXRlLnZhbHVlLmxlbmd0aCkge1xuICBcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCh0aGlzLmtleXBhdGgsIHRoaXMuaW5pdGlhbFZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX011bHRpcGxlU2VsZWN0QmluZGluZyA9IE11bHRpcGxlU2VsZWN0QmluZGluZztcblxuICB2YXIgRmlsZUxpc3RCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLmVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuZmlsZXM7XG4gIFx0fVxuICB9KTtcblxuICB2YXIgQmluZGluZ19GaWxlTGlzdEJpbmRpbmcgPSBGaWxlTGlzdEJpbmRpbmc7XG5cbiAgdmFyIEdlbmVyaWNCaW5kaW5nO1xuXG4gIEdlbmVyaWNCaW5kaW5nID0gQmluZGluZ19CaW5kaW5nLmV4dGVuZCh7XG4gIFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gXCJcIjtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS52YWx1ZTtcbiAgXHR9LFxuXG4gIFx0cmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlLFxuICBcdFx0ICAgIGxhenksXG4gIFx0XHQgICAgdGltZW91dCA9IGZhbHNlO1xuICBcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cbiAgXHRcdC8vIGFueSBsYXp5IHNldHRpbmcgZm9yIHRoaXMgZWxlbWVudCBvdmVycmlkZXMgdGhlIHJvb3RcbiAgXHRcdC8vIGlmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciwgaXQncyBhIHRpbWVvdXRcbiAgXHRcdGxhenkgPSB0aGlzLnJvb3QubGF6eTtcbiAgXHRcdGlmICh0aGlzLmVsZW1lbnQubGF6eSA9PT0gdHJ1ZSkge1xuICBcdFx0XHRsYXp5ID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSBpZiAodGhpcy5lbGVtZW50LmxhenkgPT09IGZhbHNlKSB7XG4gIFx0XHRcdGxhenkgPSBmYWxzZTtcbiAgXHRcdH0gZWxzZSBpZiAoaXNfX2lzTnVtZXJpYyh0aGlzLmVsZW1lbnQubGF6eSkpIHtcbiAgXHRcdFx0bGF6eSA9IGZhbHNlO1xuICBcdFx0XHR0aW1lb3V0ID0gK3RoaXMuZWxlbWVudC5sYXp5O1xuICBcdFx0fSBlbHNlIGlmIChpc19faXNOdW1lcmljKGxhenkgfHwgXCJcIikpIHtcbiAgXHRcdFx0dGltZW91dCA9ICtsYXp5O1xuICBcdFx0XHRsYXp5ID0gZmFsc2U7XG5cbiAgXHRcdFx0Ly8gbWFrZSBzdXJlIHRoZSB0aW1lb3V0IGlzIGF2YWlsYWJsZSB0byB0aGUgaGFuZGxlclxuICBcdFx0XHR0aGlzLmVsZW1lbnQubGF6eSA9IHRpbWVvdXQ7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuaGFuZGxlciA9IHRpbWVvdXQgPyBoYW5kbGVEZWxheSA6IGhhbmRsZURvbUV2ZW50O1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcblxuICBcdFx0aWYgKCFsYXp5KSB7XG4gIFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuaGFuZGxlciwgZmFsc2UpO1xuXG4gIFx0XHRcdGlmIChub2RlLmF0dGFjaEV2ZW50KSB7XG4gIFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5oYW5kbGVyLCBmYWxzZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBoYW5kbGVCbHVyLCBmYWxzZSk7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuICBcdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlRG9tRXZlbnQsIGZhbHNlKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuaGFuZGxlciwgZmFsc2UpO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5oYW5kbGVyLCBmYWxzZSk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGhhbmRsZUJsdXIsIGZhbHNlKTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBCaW5kaW5nX0dlbmVyaWNCaW5kaW5nID0gR2VuZXJpY0JpbmRpbmc7XG5cbiAgZnVuY3Rpb24gaGFuZGxlQmx1cigpIHtcbiAgXHR2YXIgdmFsdWU7XG5cbiAgXHRoYW5kbGVEb21FdmVudC5jYWxsKHRoaXMpO1xuXG4gIFx0dmFsdWUgPSB0aGlzLl9yYWN0aXZlLnJvb3Qudmlld21vZGVsLmdldCh0aGlzLl9yYWN0aXZlLmJpbmRpbmcua2V5cGF0aCk7XG4gIFx0dGhpcy52YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/IFwiXCIgOiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZURlbGF5KCkge1xuICBcdHZhciBiaW5kaW5nID0gdGhpcy5fcmFjdGl2ZS5iaW5kaW5nLFxuICBcdCAgICBlbCA9IHRoaXM7XG5cbiAgXHRpZiAoISFiaW5kaW5nLl90aW1lb3V0KSBjbGVhclRpbWVvdXQoYmluZGluZy5fdGltZW91dCk7XG5cbiAgXHRiaW5kaW5nLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoYmluZGluZy5yZW5kZXJlZCkgaGFuZGxlRG9tRXZlbnQuY2FsbChlbCk7XG4gIFx0XHRiaW5kaW5nLl90aW1lb3V0ID0gdW5kZWZpbmVkO1xuICBcdH0sIGJpbmRpbmcuZWxlbWVudC5sYXp5KTtcbiAgfVxuXG4gIHZhciBOdW1lcmljQmluZGluZyA9IEJpbmRpbmdfR2VuZXJpY0JpbmRpbmcuZXh0ZW5kKHtcbiAgXHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0fSxcblxuICBcdGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgdmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuZWxlbWVudC5ub2RlLnZhbHVlKTtcbiAgXHRcdHJldHVybiBpc05hTih2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgXHR9XG4gIH0pO1xuXG4gIHZhciBpbml0X2NyZWF0ZVR3b3dheUJpbmRpbmcgPSBjcmVhdGVUd293YXlCaW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVR3b3dheUJpbmRpbmcoZWxlbWVudCkge1xuICBcdHZhciBhdHRyaWJ1dGVzID0gZWxlbWVudC5hdHRyaWJ1dGVzLFxuICBcdCAgICB0eXBlLFxuICBcdCAgICBCaW5kaW5nLFxuICBcdCAgICBiaW5kTmFtZSxcbiAgXHQgICAgYmluZENoZWNrZWQsXG4gIFx0ICAgIGJpbmRpbmc7XG5cbiAgXHQvLyBpZiB0aGlzIGlzIGEgbGF0ZSBiaW5kaW5nLCBhbmQgdGhlcmUncyBhbHJlYWR5IG9uZSwgaXRcbiAgXHQvLyBuZWVkcyB0byBiZSB0b3JuIGRvd25cbiAgXHRpZiAoZWxlbWVudC5iaW5kaW5nKSB7XG4gIFx0XHRlbGVtZW50LmJpbmRpbmcudGVhcmRvd24oKTtcbiAgXHRcdGVsZW1lbnQuYmluZGluZyA9IG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gY29udGVudGVkaXRhYmxlXG4gIFx0aWYgKFxuICBcdC8vIGlmIHRoZSBjb250ZW50ZWRpdGFibGUgYXR0cmlidXRlIGlzIHRydWUgb3IgaXMgYmluZGFibGUgYW5kIG1heSB0aHVzIGJlY29tZSB0cnVlXG4gIFx0KGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpIHx8ICEhYXR0cmlidXRlcy5jb250ZW50ZWRpdGFibGUgJiYgaXNCaW5kYWJsZShhdHRyaWJ1dGVzLmNvbnRlbnRlZGl0YWJsZSkpICYmIGlzQmluZGFibGUoYXR0cmlidXRlcy52YWx1ZSkpIHtcbiAgXHRcdEJpbmRpbmcgPSBCaW5kaW5nX0NvbnRlbnRFZGl0YWJsZUJpbmRpbmc7XG4gIFx0fVxuXG4gIFx0Ly8gPGlucHV0PlxuICBcdGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gXCJpbnB1dFwiKSB7XG4gIFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuXG4gIFx0XHRpZiAodHlwZSA9PT0gXCJyYWRpb1wiIHx8IHR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICBcdFx0XHRiaW5kTmFtZSA9IGlzQmluZGFibGUoYXR0cmlidXRlcy5uYW1lKTtcbiAgXHRcdFx0YmluZENoZWNrZWQgPSBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMuY2hlY2tlZCk7XG5cbiAgXHRcdFx0Ly8gd2UgY2FuIGVpdGhlciBiaW5kIHRoZSBuYW1lIGF0dHJpYnV0ZSwgb3IgdGhlIGNoZWNrZWQgYXR0cmlidXRlIC0gbm90IGJvdGhcbiAgXHRcdFx0aWYgKGJpbmROYW1lICYmIGJpbmRDaGVja2VkKSB7XG4gIFx0XHRcdFx0d2FybklmRGVidWcoXCJBIHJhZGlvIGlucHV0IGNhbiBoYXZlIHR3by13YXkgYmluZGluZyBvbiBpdHMgbmFtZSBhdHRyaWJ1dGUsIG9yIGl0cyBjaGVja2VkIGF0dHJpYnV0ZSAtIG5vdCBib3RoXCIsIHsgcmFjdGl2ZTogZWxlbWVudC5yb290IH0pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGJpbmROYW1lKSB7XG4gIFx0XHRcdFx0QmluZGluZyA9IHR5cGUgPT09IFwicmFkaW9cIiA/IEJpbmRpbmdfUmFkaW9OYW1lQmluZGluZyA6IEJpbmRpbmdfQ2hlY2tib3hOYW1lQmluZGluZztcbiAgXHRcdFx0fSBlbHNlIGlmIChiaW5kQ2hlY2tlZCkge1xuICBcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSBcInJhZGlvXCIgPyBCaW5kaW5nX1JhZGlvQmluZGluZyA6IEJpbmRpbmdfQ2hlY2tib3hCaW5kaW5nO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IFwiZmlsZVwiICYmIGlzQmluZGFibGUoYXR0cmlidXRlcy52YWx1ZSkpIHtcbiAgXHRcdFx0QmluZGluZyA9IEJpbmRpbmdfRmlsZUxpc3RCaW5kaW5nO1xuICBcdFx0fSBlbHNlIGlmIChpc0JpbmRhYmxlKGF0dHJpYnV0ZXMudmFsdWUpKSB7XG4gIFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwicmFuZ2VcIiA/IE51bWVyaWNCaW5kaW5nIDogQmluZGluZ19HZW5lcmljQmluZGluZztcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyA8c2VsZWN0PlxuICBcdGVsc2UgaWYgKGVsZW1lbnQubmFtZSA9PT0gXCJzZWxlY3RcIiAmJiBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMudmFsdWUpKSB7XG4gIFx0XHRCaW5kaW5nID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSA/IEJpbmRpbmdfTXVsdGlwbGVTZWxlY3RCaW5kaW5nIDogQmluZGluZ19TZWxlY3RCaW5kaW5nO1xuICBcdH1cblxuICBcdC8vIDx0ZXh0YXJlYT5cbiAgXHRlbHNlIGlmIChlbGVtZW50Lm5hbWUgPT09IFwidGV4dGFyZWFcIiAmJiBpc0JpbmRhYmxlKGF0dHJpYnV0ZXMudmFsdWUpKSB7XG4gIFx0XHRCaW5kaW5nID0gQmluZGluZ19HZW5lcmljQmluZGluZztcbiAgXHR9XG5cbiAgXHRpZiAoQmluZGluZyAmJiAoYmluZGluZyA9IG5ldyBCaW5kaW5nKGVsZW1lbnQpKSAmJiBiaW5kaW5nLmtleXBhdGgpIHtcbiAgXHRcdHJldHVybiBiaW5kaW5nO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQmluZGFibGUoYXR0cmlidXRlKSB7XG4gIFx0cmV0dXJuIGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNCaW5kYWJsZTtcbiAgfVxuXG4gIC8vIGFuZCB0aGlzIGVsZW1lbnQgYWxzbyBoYXMgYSB2YWx1ZSBhdHRyaWJ1dGUgdG8gYmluZFxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2J1YmJsZSA9IEV2ZW50SGFuZGxlciRidWJibGU7XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGJ1YmJsZSgpIHtcbiAgXHR2YXIgaGFzQWN0aW9uID0gdGhpcy5nZXRBY3Rpb24oKTtcblxuICBcdGlmIChoYXNBY3Rpb24gJiYgIXRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgXHRcdHRoaXMubGlzdGVuKCk7XG4gIFx0fSBlbHNlIGlmICghaGFzQWN0aW9uICYmIHRoaXMuaGFzTGlzdGVuZXIpIHtcbiAgXHRcdHRoaXMudW5yZW5kZXIoKTtcbiAgXHR9XG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIG1heSBiZSBvdmVyd3JpdHRlbiwgaWYgdGhlIGV2ZW50IGRpcmVjdGl2ZVxuICAvLyBpbmNsdWRlcyBwYXJhbWV0ZXJzXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2ZpcmUgPSBFdmVudEhhbmRsZXIkZmlyZTtcbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGZpcmUoZXZlbnQpIHtcbiAgXHRzaGFyZWRfZmlyZUV2ZW50KHRoaXMucm9vdCwgdGhpcy5nZXRBY3Rpb24oKSwgeyBldmVudDogZXZlbnQgfSk7XG4gIH1cblxuICB2YXIgZ2V0QWN0aW9uID0gRXZlbnRIYW5kbGVyJGdldEFjdGlvbjtcblxuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkZ2V0QWN0aW9uKCkge1xuICBcdHJldHVybiB0aGlzLmFjdGlvbi50b1N0cmluZygpLnRyaW0oKTtcbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2luaXQgPSBFdmVudEhhbmRsZXIkaW5pdDtcblxuICB2YXIgZXZlbnRQYXR0ZXJuID0gL15ldmVudCg/OlxcLiguKykpPy87XG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRpbml0KGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBhY3Rpb24sIHJlZnMsIHJhY3RpdmU7XG5cbiAgXHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IGVsZW1lbnQucm9vdDtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLm5hbWUgPSBuYW1lO1xuXG4gIFx0aWYgKG5hbWUuaW5kZXhPZihcIipcIikgIT09IC0xKSB7XG4gIFx0XHRmYXRhbChcIk9ubHkgY29tcG9uZW50IHByb3h5LWV2ZW50cyBtYXkgY29udGFpbiBcXFwiKlxcXCIgd2lsZGNhcmRzLCA8JXMgb24tJXM9XFxcIi4uLlxcXCIvPiBpcyBub3QgdmFsaWRcIiwgZWxlbWVudC5uYW1lLCBuYW1lKTtcbiAgXHRcdHRoaXMuaW52YWxpZCA9IHRydWU7XG4gIFx0fVxuXG4gIFx0aWYgKHRlbXBsYXRlLm0pIHtcbiAgXHRcdHJlZnMgPSB0ZW1wbGF0ZS5hLnI7XG5cbiAgXHRcdC8vIFRoaXMgaXMgYSBtZXRob2QgY2FsbFxuICBcdFx0dGhpcy5tZXRob2QgPSB0ZW1wbGF0ZS5tO1xuICBcdFx0dGhpcy5rZXlwYXRocyA9IFtdO1xuICBcdFx0dGhpcy5mbiA9IHNoYXJlZF9nZXRGdW5jdGlvbkZyb21TdHJpbmcodGVtcGxhdGUuYS5zLCByZWZzLmxlbmd0aCk7XG5cbiAgXHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBlbGVtZW50LnBhcmVudEZyYWdtZW50O1xuICBcdFx0cmFjdGl2ZSA9IHRoaXMucm9vdDtcblxuICBcdFx0Ly8gQ3JlYXRlIHJlc29sdmVycyBmb3IgZWFjaCByZWZlcmVuY2VcbiAgXHRcdHRoaXMucmVmUmVzb2x2ZXJzID0gW107XG4gIFx0XHRyZWZzLmZvckVhY2goZnVuY3Rpb24gKHJlZiwgaSkge1xuICBcdFx0XHR2YXIgbWF0Y2ggPSB1bmRlZmluZWQ7XG5cbiAgXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gdGhlIGBldmVudGAgb2JqZWN0XG4gIFx0XHRcdGlmIChtYXRjaCA9IGV2ZW50UGF0dGVybi5leGVjKHJlZikpIHtcbiAgXHRcdFx0XHRfdGhpcy5rZXlwYXRoc1tpXSA9IHtcbiAgXHRcdFx0XHRcdGV2ZW50T2JqZWN0OiB0cnVlLFxuICBcdFx0XHRcdFx0cmVmaW5lbWVudHM6IG1hdGNoWzFdID8gbWF0Y2hbMV0uc3BsaXQoXCIuXCIpIDogW11cbiAgXHRcdFx0XHR9O1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdF90aGlzLnJlZlJlc29sdmVycy5wdXNoKFJlc29sdmVyc19jcmVhdGVSZWZlcmVuY2VSZXNvbHZlcihfdGhpcywgcmVmLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRcdFx0cmV0dXJuIF90aGlzLnJlc29sdmUoaSwga2V5cGF0aCk7XG4gIFx0XHRcdFx0fSkpO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5maXJlID0gZmlyZU1ldGhvZENhbGw7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIEdldCBhY3Rpb24gKCdmb28nIGluICdvbi1jbGljaz0nZm9vJylcbiAgXHRcdGFjdGlvbiA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG4gIFx0XHRpZiAodHlwZW9mIGFjdGlvbiAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRhY3Rpb24gPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdFx0dGVtcGxhdGU6IGFjdGlvbixcbiAgXHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG4gIFx0XHRcdFx0b3duZXI6IHRoaXNcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuYWN0aW9uID0gYWN0aW9uO1xuXG4gIFx0XHQvLyBHZXQgcGFyYW1ldGVyc1xuICBcdFx0aWYgKHRlbXBsYXRlLmQpIHtcbiAgXHRcdFx0dGhpcy5keW5hbWljUGFyYW1zID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuICBcdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdFx0XHRvd25lcjogdGhpcy5lbGVtZW50XG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHRoaXMuZmlyZSA9IGZpcmVFdmVudFdpdGhEeW5hbWljUGFyYW1zO1xuICBcdFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS5hKSB7XG4gIFx0XHRcdHRoaXMucGFyYW1zID0gdGVtcGxhdGUuYTtcbiAgXHRcdFx0dGhpcy5maXJlID0gZmlyZUV2ZW50V2l0aFBhcmFtcztcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlTWV0aG9kQ2FsbChldmVudCkge1xuICBcdHZhciByYWN0aXZlLCB2YWx1ZXMsIGFyZ3M7XG5cbiAgXHRyYWN0aXZlID0gdGhpcy5yb290O1xuXG4gIFx0aWYgKHR5cGVvZiByYWN0aXZlW3RoaXMubWV0aG9kXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gY2FsbCBhIG5vbi1leGlzdGVudCBtZXRob2QgKFxcXCJcIiArIHRoaXMubWV0aG9kICsgXCJcXFwiKVwiKTtcbiAgXHR9XG5cbiAgXHR2YWx1ZXMgPSB0aGlzLmtleXBhdGhzLm1hcChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0dmFyIHZhbHVlLCBsZW4sIGk7XG5cbiAgXHRcdGlmIChrZXlwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0Ly8gbm90IHlldCByZXNvbHZlZFxuICBcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBUT0RPIHRoZSByZWZpbmVtZW50cyBzdHVmZiB3b3VsZCBiZSBiZXR0ZXIgaGFuZGxlZCBhdCBwYXJzZSB0aW1lXG4gIFx0XHRpZiAoa2V5cGF0aC5ldmVudE9iamVjdCkge1xuICBcdFx0XHR2YWx1ZSA9IGV2ZW50O1xuXG4gIFx0XHRcdGlmIChsZW4gPSBrZXlwYXRoLnJlZmluZW1lbnRzLmxlbmd0aCkge1xuICBcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtrZXlwYXRoLnJlZmluZW1lbnRzW2ldXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0fSk7XG5cbiAgXHRzaGFyZWRfZXZlbnRTdGFjay5lbnF1ZXVlKHJhY3RpdmUsIGV2ZW50KTtcblxuICBcdGFyZ3MgPSB0aGlzLmZuLmFwcGx5KG51bGwsIHZhbHVlcyk7XG4gIFx0cmFjdGl2ZVt0aGlzLm1ldGhvZF0uYXBwbHkocmFjdGl2ZSwgYXJncyk7XG5cbiAgXHRzaGFyZWRfZXZlbnRTdGFjay5kZXF1ZXVlKHJhY3RpdmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUV2ZW50V2l0aFBhcmFtcyhldmVudCkge1xuICBcdHNoYXJlZF9maXJlRXZlbnQodGhpcy5yb290LCB0aGlzLmdldEFjdGlvbigpLCB7IGV2ZW50OiBldmVudCwgYXJnczogdGhpcy5wYXJhbXMgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlRXZlbnRXaXRoRHluYW1pY1BhcmFtcyhldmVudCkge1xuICBcdHZhciBhcmdzID0gdGhpcy5keW5hbWljUGFyYW1zLmdldEFyZ3NMaXN0KCk7XG5cbiAgXHQvLyBuZWVkIHRvIHN0cmlwIFtdIGZyb20gZW5kcyBpZiBhIHN0cmluZyFcbiAgXHRpZiAodHlwZW9mIGFyZ3MgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGFyZ3MgPSBhcmdzLnN1YnN0cigxLCBhcmdzLmxlbmd0aCAtIDIpO1xuICBcdH1cblxuICBcdHNoYXJlZF9maXJlRXZlbnQodGhpcy5yb290LCB0aGlzLmdldEFjdGlvbigpLCB7IGV2ZW50OiBldmVudCwgYXJnczogYXJncyB9KTtcbiAgfVxuXG4gIHZhciBzaGFyZWRfZ2VuZXJpY0hhbmRsZXIgPSBnZW5lcmljSGFuZGxlcjtcbiAgZnVuY3Rpb24gZ2VuZXJpY0hhbmRsZXIoZXZlbnQpIHtcbiAgXHR2YXIgc3RvcmFnZSxcbiAgXHQgICAgaGFuZGxlcixcbiAgXHQgICAgaW5kaWNlcyxcbiAgXHQgICAgaW5kZXggPSB7fTtcblxuICBcdHN0b3JhZ2UgPSB0aGlzLl9yYWN0aXZlO1xuICBcdGhhbmRsZXIgPSBzdG9yYWdlLmV2ZW50c1tldmVudC50eXBlXTtcblxuICBcdGlmIChpbmRpY2VzID0gUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMoaGFuZGxlci5lbGVtZW50LnBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0aW5kZXggPSBSZXNvbHZlcnNfZmluZEluZGV4UmVmcy5yZXNvbHZlKGluZGljZXMpO1xuICBcdH1cblxuICBcdGhhbmRsZXIuZmlyZSh7XG4gIFx0XHRub2RlOiB0aGlzLFxuICBcdFx0b3JpZ2luYWw6IGV2ZW50LFxuICBcdFx0aW5kZXg6IGluZGV4LFxuICBcdFx0a2V5cGF0aDogc3RvcmFnZS5rZXlwYXRoLnN0cixcbiAgXHRcdGNvbnRleHQ6IHN0b3JhZ2Uucm9vdC52aWV3bW9kZWwuZ2V0KHN0b3JhZ2Uua2V5cGF0aClcbiAgXHR9KTtcbiAgfVxuXG4gIHZhciBsaXN0ZW4gPSBFdmVudEhhbmRsZXIkbGlzdGVuO1xuXG4gIHZhciBjdXN0b21IYW5kbGVycyA9IHt9LFxuICAgICAgdG91Y2hFdmVudHMgPSB7XG4gIFx0dG91Y2hzdGFydDogdHJ1ZSxcbiAgXHR0b3VjaG1vdmU6IHRydWUsXG4gIFx0dG91Y2hlbmQ6IHRydWUsXG4gIFx0dG91Y2hjYW5jZWw6IHRydWUsXG4gIFx0Ly9ub3QgdzNjLCBidXQgc3VwcG9ydGVkIGluIHNvbWUgYnJvd3NlcnNcbiAgXHR0b3VjaGxlYXZlOiB0cnVlXG4gIH07XG4gIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRsaXN0ZW4oKSB7XG4gIFx0dmFyIGRlZmluaXRpb24sXG4gIFx0ICAgIG5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgXHRpZiAodGhpcy5pbnZhbGlkKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKGRlZmluaXRpb24gPSBmaW5kSW5WaWV3SGllcmFyY2h5KFwiZXZlbnRzXCIsIHRoaXMucm9vdCwgbmFtZSkpIHtcbiAgXHRcdHRoaXMuY3VzdG9tID0gZGVmaW5pdGlvbih0aGlzLm5vZGUsIGdldEN1c3RvbUhhbmRsZXIobmFtZSkpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBMb29rcyBsaWtlIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHN0YW5kYXJkIERPTSBldmVudC4uLiBidXQgbGV0J3MgY2hlY2tcbiAgXHRcdGlmICghKFwib25cIiArIG5hbWUgaW4gdGhpcy5ub2RlKSAmJiAhKHdpbmRvdyAmJiBcIm9uXCIgKyBuYW1lIGluIHdpbmRvdykgJiYgIWlzSnNkb20pIHtcblxuICBcdFx0XHQvLyBva2F5IHRvIHVzZSB0b3VjaCBldmVudHMgaWYgdGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGVtXG4gIFx0XHRcdGlmICghdG91Y2hFdmVudHNbbmFtZV0pIHtcbiAgXHRcdFx0XHR3YXJuT25jZUlmRGVidWcobWlzc2luZ1BsdWdpbihuYW1lLCBcImV2ZW50XCIpLCB7IG5vZGU6IHRoaXMubm9kZSB9KTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgc2hhcmVkX2dlbmVyaWNIYW5kbGVyLCBmYWxzZSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5oYXNMaXN0ZW5lciA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXN0b21IYW5kbGVyKG5hbWUpIHtcbiAgXHRpZiAoIWN1c3RvbUhhbmRsZXJzW25hbWVdKSB7XG4gIFx0XHRjdXN0b21IYW5kbGVyc1tuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICBcdFx0XHR2YXIgc3RvcmFnZSA9IGV2ZW50Lm5vZGUuX3JhY3RpdmU7XG5cbiAgXHRcdFx0ZXZlbnQuaW5kZXggPSBzdG9yYWdlLmluZGV4O1xuICBcdFx0XHRldmVudC5rZXlwYXRoID0gc3RvcmFnZS5rZXlwYXRoLnN0cjtcbiAgXHRcdFx0ZXZlbnQuY29udGV4dCA9IHN0b3JhZ2Uucm9vdC52aWV3bW9kZWwuZ2V0KHN0b3JhZ2Uua2V5cGF0aCk7XG5cbiAgXHRcdFx0c3RvcmFnZS5ldmVudHNbbmFtZV0uZmlyZShldmVudCk7XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBjdXN0b21IYW5kbGVyc1tuYW1lXTtcbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3JlYmluZCA9IEV2ZW50SGFuZGxlciRyZWJpbmQ7XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKSB7XG4gIFx0dmFyIGZyYWdtZW50O1xuICBcdGlmICh0aGlzLm1ldGhvZCkge1xuICBcdFx0ZnJhZ21lbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0XHR0aGlzLnJlZlJlc29sdmVycy5mb3JFYWNoKHJlYmluZCk7XG5cbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIHRoaXMuYWN0aW9uICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRyZWJpbmQodGhpcy5hY3Rpb24pO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmR5bmFtaWNQYXJhbXMpIHtcbiAgXHRcdHJlYmluZCh0aGlzLmR5bmFtaWNQYXJhbXMpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIHJlYmluZCh0aGluZykge1xuICBcdFx0dGhpbmcgJiYgdGhpbmcucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3JlbmRlciA9IEV2ZW50SGFuZGxlciRyZW5kZXI7XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlbmRlcigpIHtcbiAgXHR0aGlzLm5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcbiAgXHQvLyBzdG9yZSB0aGlzIG9uIHRoZSBub2RlIGl0c2VsZiwgc28gaXQgY2FuIGJlIHJldHJpZXZlZCBieSBhXG4gIFx0Ly8gdW5pdmVyc2FsIGhhbmRsZXJcbiAgXHR0aGlzLm5vZGUuX3JhY3RpdmUuZXZlbnRzW3RoaXMubmFtZV0gPSB0aGlzO1xuXG4gIFx0aWYgKHRoaXMubWV0aG9kIHx8IHRoaXMuZ2V0QWN0aW9uKCkpIHtcbiAgXHRcdHRoaXMubGlzdGVuKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9yZXNvbHZlID0gRXZlbnRIYW5kbGVyJHJlc29sdmU7XG5cbiAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlc29sdmUoaW5kZXgsIGtleXBhdGgpIHtcbiAgXHR0aGlzLmtleXBhdGhzW2luZGV4XSA9IGtleXBhdGg7XG4gIH1cblxuICB2YXIgRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV91bmJpbmQgPSBFdmVudEhhbmRsZXIkdW5iaW5kO1xuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkdW5iaW5kKCkge1xuICBcdGlmICh0aGlzLm1ldGhvZCkge1xuICBcdFx0dGhpcy5yZWZSZXNvbHZlcnMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIFRlYXIgZG93biBkeW5hbWljIG5hbWVcbiAgXHRpZiAodHlwZW9mIHRoaXMuYWN0aW9uICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHR0aGlzLmFjdGlvbi51bmJpbmQoKTtcbiAgXHR9XG5cbiAgXHQvLyBUZWFyIGRvd24gZHluYW1pYyBwYXJhbWV0ZXJzXG4gIFx0aWYgKHRoaXMuZHluYW1pY1BhcmFtcykge1xuICBcdFx0dGhpcy5keW5hbWljUGFyYW1zLnVuYmluZCgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3VucmVuZGVyID0gRXZlbnRIYW5kbGVyJHVucmVuZGVyO1xuICBmdW5jdGlvbiBFdmVudEhhbmRsZXIkdW5yZW5kZXIoKSB7XG5cbiAgXHRpZiAodGhpcy5jdXN0b20pIHtcbiAgXHRcdHRoaXMuY3VzdG9tLnRlYXJkb3duKCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMubmFtZSwgc2hhcmVkX2dlbmVyaWNIYW5kbGVyLCBmYWxzZSk7XG4gIFx0fVxuXG4gIFx0dGhpcy5oYXNMaXN0ZW5lciA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSkge1xuICBcdHRoaXMuaW5pdChlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSk7XG4gIH07XG5cbiAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfYnViYmxlLFxuICBcdGZpcmU6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfZmlyZSxcbiAgXHRnZXRBY3Rpb246IGdldEFjdGlvbixcbiAgXHRpbml0OiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX2luaXQsXG4gIFx0bGlzdGVuOiBsaXN0ZW4sXG4gIFx0cmViaW5kOiBFdmVudEhhbmRsZXJfcHJvdG90eXBlX3JlYmluZCxcbiAgXHRyZW5kZXI6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHJlc29sdmU6IHByb3RvdHlwZV9yZXNvbHZlLFxuICBcdHVuYmluZDogRXZlbnRIYW5kbGVyX3Byb3RvdHlwZV91bmJpbmQsXG4gIFx0dW5yZW5kZXI6IEV2ZW50SGFuZGxlcl9wcm90b3R5cGVfdW5yZW5kZXJcbiAgfTtcblxuICB2YXIgX0V2ZW50SGFuZGxlciA9IEV2ZW50SGFuZGxlcjtcblxuICB2YXIgY3JlYXRlRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZW1wbGF0ZSkge1xuICBcdHZhciBpLFxuICBcdCAgICBuYW1lLFxuICBcdCAgICBuYW1lcyxcbiAgXHQgICAgaGFuZGxlcixcbiAgXHQgICAgcmVzdWx0ID0gW107XG5cbiAgXHRmb3IgKG5hbWUgaW4gdGVtcGxhdGUpIHtcbiAgXHRcdGlmICh0ZW1wbGF0ZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICBcdFx0XHRuYW1lcyA9IG5hbWUuc3BsaXQoXCItXCIpO1xuICBcdFx0XHRpID0gbmFtZXMubGVuZ3RoO1xuXG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRoYW5kbGVyID0gbmV3IF9FdmVudEhhbmRsZXIoZWxlbWVudCwgbmFtZXNbaV0sIHRlbXBsYXRlW25hbWVdKTtcbiAgXHRcdFx0XHRyZXN1bHQucHVzaChoYW5kbGVyKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIERlY29yYXRvciA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZW1wbGF0ZSkge1xuICBcdHZhciBzZWxmID0gdGhpcyxcbiAgXHQgICAgcmFjdGl2ZSxcbiAgXHQgICAgbmFtZSxcbiAgXHQgICAgZnJhZ21lbnQ7XG5cbiAgXHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICBcdHRoaXMucm9vdCA9IHJhY3RpdmUgPSBlbGVtZW50LnJvb3Q7XG5cbiAgXHRuYW1lID0gdGVtcGxhdGUubiB8fCB0ZW1wbGF0ZTtcblxuICBcdGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0ZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiBuYW1lLFxuICBcdFx0XHRyb290OiByYWN0aXZlLFxuICBcdFx0XHRvd25lcjogZWxlbWVudFxuICBcdFx0fSk7XG5cbiAgXHRcdG5hbWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuICBcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cbiAgXHRcdGlmIChuYW1lID09PSBcIlwiKSB7XG4gIFx0XHRcdC8vIGVtcHR5IHN0cmluZyBva2F5LCBqdXN0IG5vIGRlY29yYXRvclxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHRlbXBsYXRlLmEpIHtcbiAgXHRcdHRoaXMucGFyYW1zID0gdGVtcGxhdGUuYTtcbiAgXHR9IGVsc2UgaWYgKHRlbXBsYXRlLmQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuICBcdFx0XHRyb290OiByYWN0aXZlLFxuICBcdFx0XHRvd25lcjogZWxlbWVudFxuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMucGFyYW1zID0gdGhpcy5mcmFnbWVudC5nZXRBcmdzTGlzdCgpO1xuXG4gIFx0XHR0aGlzLmZyYWdtZW50LmJ1YmJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dGhpcy5kaXJ0eUFyZ3MgPSB0aGlzLmRpcnR5VmFsdWUgPSB0cnVlO1xuICBcdFx0XHRzZWxmLnBhcmFtcyA9IHRoaXMuZ2V0QXJnc0xpc3QoKTtcblxuICBcdFx0XHRpZiAoc2VsZi5yZWFkeSkge1xuICBcdFx0XHRcdHNlbGYudXBkYXRlKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0dGhpcy5mbiA9IGZpbmRJblZpZXdIaWVyYXJjaHkoXCJkZWNvcmF0b3JzXCIsIHJhY3RpdmUsIG5hbWUpO1xuXG4gIFx0aWYgKCF0aGlzLmZuKSB7XG4gIFx0XHRmYXRhbChtaXNzaW5nUGx1Z2luKG5hbWUsIFwiZGVjb3JhdG9yXCIpKTtcbiAgXHR9XG4gIH07XG5cbiAgRGVjb3JhdG9yLnByb3RvdHlwZSA9IHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgbm9kZSwgcmVzdWx0LCBhcmdzO1xuXG4gIFx0XHRub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cbiAgXHRcdGlmICh0aGlzLnBhcmFtcykge1xuICBcdFx0XHRhcmdzID0gW25vZGVdLmNvbmNhdCh0aGlzLnBhcmFtcyk7XG4gIFx0XHRcdHJlc3VsdCA9IHRoaXMuZm4uYXBwbHkodGhpcy5yb290LCBhcmdzKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJlc3VsdCA9IHRoaXMuZm4uY2FsbCh0aGlzLnJvb3QsIG5vZGUpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LnRlYXJkb3duKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkRlY29yYXRvciBkZWZpbml0aW9uIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aXRoIGEgdGVhcmRvd24gbWV0aG9kXCIpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBUT0RPIGRvZXMgdGhpcyBtYWtlIHNlbnNlP1xuICBcdFx0dGhpcy5hY3R1YWwgPSByZXN1bHQ7XG4gIFx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgXHR9LFxuXG4gIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5hY3R1YWwudXBkYXRlKSB7XG4gIFx0XHRcdHRoaXMuYWN0dWFsLnVwZGF0ZS5hcHBseSh0aGlzLnJvb3QsIHRoaXMucGFyYW1zKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuYWN0dWFsLnRlYXJkb3duKHRydWUpO1xuICBcdFx0XHR0aGlzLmluaXQoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHRlYXJkb3duOiBmdW5jdGlvbiAodXBkYXRpbmcpIHtcbiAgXHRcdHRoaXMudG9ybmRvd24gPSB0cnVlO1xuICBcdFx0aWYgKHRoaXMucmVhZHkpIHtcbiAgXHRcdFx0dGhpcy5hY3R1YWwudGVhcmRvd24oKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF1cGRhdGluZyAmJiB0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIHZhciBfRGVjb3JhdG9yID0gRGVjb3JhdG9yO1xuXG4gIGZ1bmN0aW9uIHNlbGVjdF9fYnViYmxlKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRpZiAoIXRoaXMuZGlydHkpIHtcbiAgXHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRzeW5jKF90aGlzKTtcbiAgXHRcdFx0X3RoaXMuZGlydHkgPSBmYWxzZTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7IC8vIGRlZmF1bHQgYmVoYXZpb3VyXG4gIH1cblxuICBmdW5jdGlvbiBzeW5jKHNlbGVjdEVsZW1lbnQpIHtcbiAgXHR2YXIgc2VsZWN0Tm9kZSwgc2VsZWN0VmFsdWUsIGlzTXVsdGlwbGUsIG9wdGlvbnMsIG9wdGlvbldhc1NlbGVjdGVkO1xuXG4gIFx0c2VsZWN0Tm9kZSA9IHNlbGVjdEVsZW1lbnQubm9kZTtcblxuICBcdGlmICghc2VsZWN0Tm9kZSkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdG9wdGlvbnMgPSB0b0FycmF5KHNlbGVjdE5vZGUub3B0aW9ucyk7XG5cbiAgXHRzZWxlY3RWYWx1ZSA9IHNlbGVjdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG4gIFx0aXNNdWx0aXBsZSA9IHNlbGVjdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIik7XG5cbiAgXHQvLyBJZiB0aGUgPHNlbGVjdD4gaGFzIGEgc3BlY2lmaWVkIHZhbHVlLCB0aGF0IHNob3VsZCBvdmVycmlkZVxuICBcdC8vIHRoZXNlIG9wdGlvbnNcbiAgXHRpZiAoc2VsZWN0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0b3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gIFx0XHRcdHZhciBvcHRpb25WYWx1ZSwgc2hvdWxkU2VsZWN0O1xuXG4gIFx0XHRcdG9wdGlvblZhbHVlID0gby5fcmFjdGl2ZSA/IG8uX3JhY3RpdmUudmFsdWUgOiBvLnZhbHVlO1xuICBcdFx0XHRzaG91bGRTZWxlY3QgPSBpc011bHRpcGxlID8gdmFsdWVDb250YWlucyhzZWxlY3RWYWx1ZSwgb3B0aW9uVmFsdWUpIDogc2VsZWN0VmFsdWUgPT0gb3B0aW9uVmFsdWU7XG5cbiAgXHRcdFx0aWYgKHNob3VsZFNlbGVjdCkge1xuICBcdFx0XHRcdG9wdGlvbldhc1NlbGVjdGVkID0gdHJ1ZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdG8uc2VsZWN0ZWQgPSBzaG91bGRTZWxlY3Q7XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKCFvcHRpb25XYXNTZWxlY3RlZCkge1xuICBcdFx0XHRpZiAob3B0aW9uc1swXSkge1xuICBcdFx0XHRcdG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHNlbGVjdEVsZW1lbnQuYmluZGluZykge1xuICBcdFx0XHRcdHNlbGVjdEVsZW1lbnQuYmluZGluZy5mb3JjZVVwZGF0ZSgpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gT3RoZXJ3aXNlIHRoZSB2YWx1ZSBzaG91bGQgYmUgaW5pdGlhbGlzZWQgYWNjb3JkaW5nIHRvIHdoaWNoXG4gIFx0Ly8gPG9wdGlvbj4gZWxlbWVudCBpcyBzZWxlY3RlZCwgaWYgdHdvd2F5IGJpbmRpbmcgaXMgaW4gZWZmZWN0XG4gIFx0ZWxzZSBpZiAoc2VsZWN0RWxlbWVudC5iaW5kaW5nKSB7XG4gIFx0XHRzZWxlY3RFbGVtZW50LmJpbmRpbmcuZm9yY2VVcGRhdGUoKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB2YWx1ZUNvbnRhaW5zKHNlbGVjdFZhbHVlLCBvcHRpb25WYWx1ZSkge1xuICBcdHZhciBpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGlmIChzZWxlY3RWYWx1ZVtpXSA9PSBvcHRpb25WYWx1ZSkge1xuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBzcGVjaWFsX29wdGlvbl9faW5pdChvcHRpb24sIHRlbXBsYXRlKSB7XG4gIFx0b3B0aW9uLnNlbGVjdCA9IGZpbmRQYXJlbnRTZWxlY3Qob3B0aW9uLnBhcmVudCk7XG5cbiAgXHQvLyB3ZSBtaWdodCBiZSBpbnNpZGUgYSA8ZGF0YWxpc3Q+IGVsZW1lbnRcbiAgXHRpZiAoIW9wdGlvbi5zZWxlY3QpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRvcHRpb24uc2VsZWN0Lm9wdGlvbnMucHVzaChvcHRpb24pO1xuXG4gIFx0Ly8gSWYgdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyBtaXNzaW5nLCB1c2UgdGhlIGVsZW1lbnQncyBjb250ZW50XG4gIFx0aWYgKCF0ZW1wbGF0ZS5hKSB7XG4gIFx0XHR0ZW1wbGF0ZS5hID0ge307XG4gIFx0fVxuXG4gIFx0Ly8gLi4uYXMgbG9uZyBhcyBpdCBpc24ndCBkaXNhYmxlZFxuICBcdGlmICh0ZW1wbGF0ZS5hLnZhbHVlID09PSB1bmRlZmluZWQgJiYgIXRlbXBsYXRlLmEuaGFzT3duUHJvcGVydHkoXCJkaXNhYmxlZFwiKSkge1xuICBcdFx0dGVtcGxhdGUuYS52YWx1ZSA9IHRlbXBsYXRlLmY7XG4gIFx0fVxuXG4gIFx0Ly8gSWYgdGhlcmUgaXMgYSBgc2VsZWN0ZWRgIGF0dHJpYnV0ZSwgYnV0IHRoZSA8c2VsZWN0PlxuICBcdC8vIGFscmVhZHkgaGFzIGEgdmFsdWUsIGRlbGV0ZSBpdFxuICBcdGlmIChcInNlbGVjdGVkXCIgaW4gdGVtcGxhdGUuYSAmJiBvcHRpb24uc2VsZWN0LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdGRlbGV0ZSB0ZW1wbGF0ZS5hLnNlbGVjdGVkO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNwZWNpYWxfb3B0aW9uX191bmJpbmQob3B0aW9uKSB7XG4gIFx0aWYgKG9wdGlvbi5zZWxlY3QpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheShvcHRpb24uc2VsZWN0Lm9wdGlvbnMsIG9wdGlvbik7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZFBhcmVudFNlbGVjdChlbGVtZW50KSB7XG4gIFx0aWYgKCFlbGVtZW50KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0ZG8ge1xuICBcdFx0aWYgKGVsZW1lbnQubmFtZSA9PT0gXCJzZWxlY3RcIikge1xuICBcdFx0XHRyZXR1cm4gZWxlbWVudDtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQpO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX2luaXQgPSBFbGVtZW50JGluaXQ7XG4gIGZ1bmN0aW9uIEVsZW1lbnQkaW5pdChvcHRpb25zKSB7XG4gIFx0dmFyIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZSwgcmFjdGl2ZSwgYmluZGluZywgYmluZGluZ3MsIHR3b3dheSwgYmluZGluZ0F0dHJzO1xuXG4gIFx0dGhpcy50eXBlID0gRUxFTUVOVDtcblxuICBcdC8vIHN0dWZmIHdlJ2xsIG5lZWQgbGF0ZXJcbiAgXHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuICBcdHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cbiAgXHR0aGlzLnBhcmVudCA9IG9wdGlvbnMucEVsZW1lbnQgfHwgcGFyZW50RnJhZ21lbnQucEVsZW1lbnQ7XG5cbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlID0gcGFyZW50RnJhZ21lbnQucm9vdDtcbiAgXHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgXHR0aGlzLmtleSA9IG9wdGlvbnMua2V5O1xuXG4gIFx0dGhpcy5uYW1lID0gZW5mb3JjZUNhc2UodGVtcGxhdGUuZSk7XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSA8b3B0aW9uPiBlbGVtZW50c1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgXHRcdHNwZWNpYWxfb3B0aW9uX19pbml0KHRoaXMsIHRlbXBsYXRlKTtcbiAgXHR9XG5cbiAgXHQvLyBTcGVjaWFsIGNhc2UgLSA8c2VsZWN0PiBlbGVtZW50c1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwic2VsZWN0XCIpIHtcbiAgXHRcdHRoaXMub3B0aW9ucyA9IFtdO1xuICBcdFx0dGhpcy5idWJibGUgPSBzZWxlY3RfX2J1YmJsZTsgLy8gVE9ETyB0aGlzIGlzIGEga2x1ZGdlXG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gPGZvcm0+IGVsZW1lbnRzXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJmb3JtXCIpIHtcbiAgXHRcdHRoaXMuZm9ybUJpbmRpbmdzID0gW107XG4gIFx0fVxuXG4gIFx0Ly8gaGFuZGxlIGJpbmRpbmcgYXR0cmlidXRlcyBmaXJzdCAodHdvd2F5LCBsYXp5KVxuICBcdGJpbmRpbmdBdHRycyA9IHByb2Nlc3NCaW5kaW5nQXR0cmlidXRlcyh0aGlzLCB0ZW1wbGF0ZSk7XG5cbiAgXHQvLyBjcmVhdGUgYXR0cmlidXRlc1xuICBcdHRoaXMuYXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZXModGhpcywgdGVtcGxhdGUuYSk7XG4gIFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMgPSBjcmVhdGVDb25kaXRpb25hbEF0dHJpYnV0ZXModGhpcywgdGVtcGxhdGUubSk7XG5cbiAgXHQvLyBhcHBlbmQgY2hpbGRyZW4sIGlmIHRoZXJlIGFyZSBhbnlcbiAgXHRpZiAodGVtcGxhdGUuZikge1xuICBcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmYsXG4gIFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiB0aGlzLFxuICBcdFx0XHRwRWxlbWVudDogdGhpcyxcbiAgXHRcdFx0Y3NzSWRzOiBudWxsXG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHQvLyB0aGUgZWxlbWVudCBzZXR0aW5nIHNob3VsZCBvdmVycmlkZSB0aGUgcmFjdGl2ZSBzZXR0aW5nXG4gIFx0dHdvd2F5ID0gcmFjdGl2ZS50d293YXk7XG4gIFx0aWYgKGJpbmRpbmdBdHRycy50d293YXkgPT09IGZhbHNlKSB0d293YXkgPSBmYWxzZTtlbHNlIGlmIChiaW5kaW5nQXR0cnMudHdvd2F5ID09PSB0cnVlKSB0d293YXkgPSB0cnVlO1xuXG4gIFx0dGhpcy50d293YXkgPSB0d293YXk7XG4gIFx0dGhpcy5sYXp5ID0gYmluZGluZ0F0dHJzLmxhenk7XG5cbiAgXHQvLyBjcmVhdGUgdHdvd2F5IGJpbmRpbmdcbiAgXHRpZiAodHdvd2F5ICYmIChiaW5kaW5nID0gaW5pdF9jcmVhdGVUd293YXlCaW5kaW5nKHRoaXMsIHRlbXBsYXRlLmEpKSkge1xuICBcdFx0dGhpcy5iaW5kaW5nID0gYmluZGluZztcblxuICBcdFx0Ly8gcmVnaXN0ZXIgdGhpcyB3aXRoIHRoZSByb290LCBzbyB0aGF0IHdlIGNhbiBkbyByYWN0aXZlLnVwZGF0ZU1vZGVsKClcbiAgXHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tiaW5kaW5nLmtleXBhdGguc3RyXSB8fCAodGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tiaW5kaW5nLmtleXBhdGguc3RyXSA9IFtdKTtcbiAgXHRcdGJpbmRpbmdzLnB1c2goYmluZGluZyk7XG4gIFx0fVxuXG4gIFx0Ly8gY3JlYXRlIGV2ZW50IHByb3hpZXNcbiAgXHRpZiAodGVtcGxhdGUudikge1xuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzID0gY3JlYXRlRXZlbnRIYW5kbGVycyh0aGlzLCB0ZW1wbGF0ZS52KTtcbiAgXHR9XG5cbiAgXHQvLyBjcmVhdGUgZGVjb3JhdG9yXG4gIFx0aWYgKHRlbXBsYXRlLm8pIHtcbiAgXHRcdHRoaXMuZGVjb3JhdG9yID0gbmV3IF9EZWNvcmF0b3IodGhpcywgdGVtcGxhdGUubyk7XG4gIFx0fVxuXG4gIFx0Ly8gY3JlYXRlIHRyYW5zaXRpb25zXG4gIFx0dGhpcy5pbnRybyA9IHRlbXBsYXRlLnQwIHx8IHRlbXBsYXRlLnQxO1xuICBcdHRoaXMub3V0cm8gPSB0ZW1wbGF0ZS50MCB8fCB0ZW1wbGF0ZS50MjtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV9yZWJpbmQgPSBFbGVtZW50JHJlYmluZDtcbiAgZnVuY3Rpb24gRWxlbWVudCRyZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdHZhciBpLCBzdG9yYWdlLCBsaXZlUXVlcmllcywgcmFjdGl2ZTtcblxuICBcdGlmICh0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgXHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKHJlYmluZCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzKSB7XG4gIFx0XHR0aGlzLmNvbmRpdGlvbmFsQXR0cmlidXRlcy5mb3JFYWNoKHJlYmluZCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZXZlbnRIYW5kbGVycykge1xuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2gocmViaW5kKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5kZWNvcmF0b3IpIHtcbiAgXHRcdHJlYmluZCh0aGlzLmRlY29yYXRvcik7XG4gIFx0fVxuXG4gIFx0Ly8gcmViaW5kIGNoaWxkcmVuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHJlYmluZCh0aGlzLmZyYWdtZW50KTtcbiAgXHR9XG5cbiAgXHQvLyBVcGRhdGUgbGl2ZSBxdWVyaWVzLCBpZiBuZWNlc3NhcnlcbiAgXHRpZiAobGl2ZVF1ZXJpZXMgPSB0aGlzLmxpdmVRdWVyaWVzKSB7XG4gIFx0XHRyYWN0aXZlID0gdGhpcy5yb290O1xuXG4gIFx0XHRpID0gbGl2ZVF1ZXJpZXMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRsaXZlUXVlcmllc1tpXS5fbWFrZURpcnR5KCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMubm9kZSAmJiAoc3RvcmFnZSA9IHRoaXMubm9kZS5fcmFjdGl2ZSkpIHtcblxuICBcdFx0Ly8gYWRqdXN0IGtleXBhdGggaWYgbmVlZGVkXG4gIFx0XHRhc3NpZ25OZXdLZXlwYXRoKHN0b3JhZ2UsIFwia2V5cGF0aFwiLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiByZWJpbmQodGhpbmcpIHtcbiAgXHRcdHRoaW5nLnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBzcGVjaWFsX2ltZ19fcmVuZGVyKGltZykge1xuICBcdHZhciBsb2FkSGFuZGxlcjtcblxuICBcdC8vIGlmIHRoaXMgaXMgYW4gPGltZz4sIGFuZCB3ZSdyZSBpbiBhIGNyYXAgYnJvd3Nlciwgd2UgbWF5IG5lZWQgdG8gcHJldmVudCBpdFxuICBcdC8vIGZyb20gb3ZlcnJpZGluZyB3aWR0aCBhbmQgaGVpZ2h0IHdoZW4gaXQgbG9hZHMgdGhlIHNyY1xuICBcdGlmIChpbWcuYXR0cmlidXRlcy53aWR0aCB8fCBpbWcuYXR0cmlidXRlcy5oZWlnaHQpIHtcbiAgXHRcdGltZy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGxvYWRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHR2YXIgd2lkdGggPSBpbWcuZ2V0QXR0cmlidXRlKFwid2lkdGhcIiksXG4gIFx0XHRcdCAgICBoZWlnaHQgPSBpbWcuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpO1xuXG4gIFx0XHRcdGlmICh3aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0aW1nLm5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGgpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0aW1nLm5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpbWcubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsb2FkSGFuZGxlciwgZmFsc2UpO1xuICBcdFx0fSwgZmFsc2UpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1fX3JlbmRlcihlbGVtZW50KSB7XG4gIFx0ZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldFwiLCBoYW5kbGVSZXNldCwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybV9fdW5yZW5kZXIoZWxlbWVudCkge1xuICBcdGVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzZXRcIiwgaGFuZGxlUmVzZXQsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJlc2V0KCkge1xuICBcdHZhciBlbGVtZW50ID0gdGhpcy5fcmFjdGl2ZS5wcm94eTtcblxuICBcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KCk7XG4gIFx0ZWxlbWVudC5mb3JtQmluZGluZ3MuZm9yRWFjaCh1cGRhdGVNb2RlbCk7XG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNb2RlbChiaW5kaW5nKSB7XG4gIFx0YmluZGluZy5yb290LnZpZXdtb2RlbC5zZXQoYmluZGluZy5rZXlwYXRoLCBiaW5kaW5nLnJlc2V0VmFsdWUpO1xuICB9XG5cbiAgdmFyIFRyYW5zaXRpb25fcHJvdG90eXBlX2luaXQgPSBUcmFuc2l0aW9uJGluaXQ7XG4gIGZ1bmN0aW9uIFRyYW5zaXRpb24kaW5pdChlbGVtZW50LCB0ZW1wbGF0ZSwgaXNJbnRybykge1xuICBcdHZhciByYWN0aXZlLCBuYW1lLCBmcmFnbWVudDtcblxuICBcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZSA9IGVsZW1lbnQucm9vdDtcbiAgXHR0aGlzLmlzSW50cm8gPSBpc0ludHJvO1xuXG4gIFx0bmFtZSA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG5cbiAgXHRpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogbmFtZSxcbiAgXHRcdFx0cm9vdDogcmFjdGl2ZSxcbiAgXHRcdFx0b3duZXI6IGVsZW1lbnRcbiAgXHRcdH0pO1xuXG4gIFx0XHRuYW1lID0gZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgXHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXG4gIFx0XHRpZiAobmFtZSA9PT0gXCJcIikge1xuICBcdFx0XHQvLyBlbXB0eSBzdHJpbmcgb2theSwganVzdCBubyB0cmFuc2l0aW9uXG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR0aGlzLm5hbWUgPSBuYW1lO1xuXG4gIFx0aWYgKHRlbXBsYXRlLmEpIHtcbiAgXHRcdHRoaXMucGFyYW1zID0gdGVtcGxhdGUuYTtcbiAgXHR9IGVsc2UgaWYgKHRlbXBsYXRlLmQpIHtcbiAgXHRcdC8vIFRPRE8gaXMgdGhlcmUgYSB3YXkgdG8gaW50ZXJwcmV0IGR5bmFtaWMgYXJndW1lbnRzIHdpdGhvdXQgYWxsIHRoZVxuICBcdFx0Ly8gJ2RlcGVuZGVuY3kgdGhyYXNoaW5nJz9cbiAgXHRcdGZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZCxcbiAgXHRcdFx0cm9vdDogcmFjdGl2ZSxcbiAgXHRcdFx0b3duZXI6IGVsZW1lbnRcbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLnBhcmFtcyA9IGZyYWdtZW50LmdldEFyZ3NMaXN0KCk7XG4gIFx0XHRmcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9XG5cbiAgXHR0aGlzLl9mbiA9IGZpbmRJblZpZXdIaWVyYXJjaHkoXCJ0cmFuc2l0aW9uc1wiLCByYWN0aXZlLCBuYW1lKTtcblxuICBcdGlmICghdGhpcy5fZm4pIHtcbiAgXHRcdHdhcm5PbmNlSWZEZWJ1ZyhtaXNzaW5nUGx1Z2luKG5hbWUsIFwidHJhbnNpdGlvblwiKSwgeyByYWN0aXZlOiB0aGlzLnJvb3QgfSk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGNhbWVsQ2FzZSA9IGZ1bmN0aW9uIChoeXBoZW5hdGVkU3RyKSB7XG4gIFx0cmV0dXJuIGh5cGhlbmF0ZWRTdHIucmVwbGFjZSgvLShbYS16QS1aXSkvZywgZnVuY3Rpb24gKG1hdGNoLCAkMSkge1xuICBcdFx0cmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7XG4gIFx0fSk7XG4gIH07XG5cbiAgdmFyIGhlbHBlcnNfcHJlZml4X19wcmVmaXgsIHByZWZpeENhY2hlLCBoZWxwZXJzX3ByZWZpeF9fdGVzdFN0eWxlO1xuXG4gIGlmICghaXNDbGllbnQpIHtcbiAgXHRoZWxwZXJzX3ByZWZpeF9fcHJlZml4ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHRwcmVmaXhDYWNoZSA9IHt9O1xuICBcdGhlbHBlcnNfcHJlZml4X190ZXN0U3R5bGUgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlO1xuXG4gIFx0aGVscGVyc19wcmVmaXhfX3ByZWZpeCA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gIFx0XHR2YXIgaSwgdmVuZG9yLCBjYXBwZWQ7XG5cbiAgXHRcdHByb3AgPSBjYW1lbENhc2UocHJvcCk7XG5cbiAgXHRcdGlmICghcHJlZml4Q2FjaGVbcHJvcF0pIHtcbiAgXHRcdFx0aWYgKGhlbHBlcnNfcHJlZml4X190ZXN0U3R5bGVbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdHByZWZpeENhY2hlW3Byb3BdID0gcHJvcDtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHQvLyB0ZXN0IHZlbmRvcnMuLi5cbiAgXHRcdFx0XHRjYXBwZWQgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zdWJzdHJpbmcoMSk7XG5cbiAgXHRcdFx0XHRpID0gdmVuZG9ycy5sZW5ndGg7XG4gIFx0XHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdFx0dmVuZG9yID0gdmVuZG9yc1tpXTtcbiAgXHRcdFx0XHRcdGlmIChoZWxwZXJzX3ByZWZpeF9fdGVzdFN0eWxlW3ZlbmRvciArIGNhcHBlZF0gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdFx0XHRwcmVmaXhDYWNoZVtwcm9wXSA9IHZlbmRvciArIGNhcHBlZDtcbiAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwcmVmaXhDYWNoZVtwcm9wXTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGhlbHBlcnNfcHJlZml4ID0gaGVscGVyc19wcmVmaXhfX3ByZWZpeDtcblxuICB2YXIgZ2V0U3R5bGUsIHByb3RvdHlwZV9nZXRTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZTtcblxuICBpZiAoIWlzQ2xpZW50KSB7XG4gIFx0Z2V0U3R5bGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdHByb3RvdHlwZV9nZXRTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHx8IGxlZ2FjeS5nZXRDb21wdXRlZFN0eWxlO1xuXG4gIFx0Z2V0U3R5bGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgXHRcdHZhciBjb21wdXRlZFN0eWxlLCBzdHlsZXMsIGksIHByb3AsIHZhbHVlO1xuXG4gIFx0XHRjb21wdXRlZFN0eWxlID0gcHJvdG90eXBlX2dldFN0eWxlX19nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSk7XG5cbiAgXHRcdGlmICh0eXBlb2YgcHJvcHMgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0dmFsdWUgPSBjb21wdXRlZFN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3BzKV07XG4gIFx0XHRcdGlmICh2YWx1ZSA9PT0gXCIwcHhcIikge1xuICBcdFx0XHRcdHZhbHVlID0gMDtcbiAgXHRcdFx0fVxuICBcdFx0XHRyZXR1cm4gdmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghaXNBcnJheShwcm9wcykpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVHJhbnNpdGlvbiRnZXRTdHlsZSBtdXN0IGJlIHBhc3NlZCBhIHN0cmluZywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgQ1NTIHByb3BlcnRpZXNcIik7XG4gIFx0XHR9XG5cbiAgXHRcdHN0eWxlcyA9IHt9O1xuXG4gIFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRwcm9wID0gcHJvcHNbaV07XG4gIFx0XHRcdHZhbHVlID0gY29tcHV0ZWRTdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wKV07XG4gIFx0XHRcdGlmICh2YWx1ZSA9PT0gXCIwcHhcIikge1xuICBcdFx0XHRcdHZhbHVlID0gMDtcbiAgXHRcdFx0fVxuICBcdFx0XHRzdHlsZXNbcHJvcF0gPSB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHN0eWxlcztcbiAgXHR9O1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZV9nZXRTdHlsZSA9IGdldFN0eWxlO1xuXG4gIHZhciBzZXRTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSwgdmFsdWUpIHtcbiAgXHR2YXIgcHJvcDtcblxuICBcdGlmICh0eXBlb2Ygc3R5bGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHRoaXMubm9kZS5zdHlsZVtoZWxwZXJzX3ByZWZpeChzdHlsZSldID0gdmFsdWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGZvciAocHJvcCBpbiBzdHlsZSkge1xuICBcdFx0XHRpZiAoc3R5bGUuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgXHRcdFx0XHR0aGlzLm5vZGUuc3R5bGVbaGVscGVyc19wcmVmaXgocHJvcCldID0gc3R5bGVbcHJvcF07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgVGlja2VyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR2YXIgZWFzaW5nO1xuXG4gIFx0dGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG4gIFx0dGhpcy5zdGVwID0gb3B0aW9ucy5zdGVwO1xuICBcdHRoaXMuY29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xuXG4gIFx0Ly8gZWFzaW5nXG4gIFx0aWYgKHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0ZWFzaW5nID0gb3B0aW9ucy5yb290LmVhc2luZ1tvcHRpb25zLmVhc2luZ107XG5cbiAgXHRcdGlmICghZWFzaW5nKSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhtaXNzaW5nUGx1Z2luKG9wdGlvbnMuZWFzaW5nLCBcImVhc2luZ1wiKSk7XG4gIFx0XHRcdGVhc2luZyA9IGxpbmVhcjtcbiAgXHRcdH1cbiAgXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcbiAgXHR9IGVsc2Uge1xuICBcdFx0ZWFzaW5nID0gbGluZWFyO1xuICBcdH1cblxuICBcdHRoaXMuZWFzaW5nID0gZWFzaW5nO1xuXG4gIFx0dGhpcy5zdGFydCA9IHV0aWxzX2dldFRpbWUoKTtcbiAgXHR0aGlzLmVuZCA9IHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuXG4gIFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgXHRzaGFyZWRfYW5pbWF0aW9ucy5hZGQodGhpcyk7XG4gIH07XG5cbiAgVGlja2VyLnByb3RvdHlwZSA9IHtcbiAgXHR0aWNrOiBmdW5jdGlvbiAobm93KSB7XG4gIFx0XHR2YXIgZWxhcHNlZCwgZWFzZWQ7XG5cbiAgXHRcdGlmICghdGhpcy5ydW5uaW5nKSB7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG5vdyA+IHRoaXMuZW5kKSB7XG4gIFx0XHRcdGlmICh0aGlzLnN0ZXApIHtcbiAgXHRcdFx0XHR0aGlzLnN0ZXAoMSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAodGhpcy5jb21wbGV0ZSkge1xuICBcdFx0XHRcdHRoaXMuY29tcGxldGUoMSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdGVsYXBzZWQgPSBub3cgLSB0aGlzLnN0YXJ0O1xuICBcdFx0ZWFzZWQgPSB0aGlzLmVhc2luZyhlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbik7XG5cbiAgXHRcdGlmICh0aGlzLnN0ZXApIHtcbiAgXHRcdFx0dGhpcy5zdGVwKGVhc2VkKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fSxcblxuICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICh0aGlzLmFib3J0KSB7XG4gIFx0XHRcdHRoaXMuYWJvcnQoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBzaGFyZWRfVGlja2VyID0gVGlja2VyO1xuICBmdW5jdGlvbiBsaW5lYXIodCkge1xuICBcdHJldHVybiB0O1xuICB9XG5cbiAgdmFyIHVucHJlZml4UGF0dGVybiA9IG5ldyBSZWdFeHAoXCJeLSg/OlwiICsgdmVuZG9ycy5qb2luKFwifFwiKSArIFwiKS1cIik7XG5cbiAgdmFyIHVucHJlZml4ID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgXHRyZXR1cm4gcHJvcC5yZXBsYWNlKHVucHJlZml4UGF0dGVybiwgXCJcIik7XG4gIH07XG5cbiAgdmFyIHZlbmRvclBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgdmVuZG9ycy5qb2luKFwifFwiKSArIFwiKShbQS1aXSlcIik7XG5cbiAgdmFyIGh5cGhlbmF0ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgXHR2YXIgaHlwaGVuYXRlZDtcblxuICBcdGlmICghc3RyKSB7XG4gIFx0XHRyZXR1cm4gXCJcIjsgLy8gZWRnZSBjYXNlXG4gIFx0fVxuXG4gIFx0aWYgKHZlbmRvclBhdHRlcm4udGVzdChzdHIpKSB7XG4gIFx0XHRzdHIgPSBcIi1cIiArIHN0cjtcbiAgXHR9XG5cbiAgXHRoeXBoZW5hdGVkID0gc3RyLnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICBcdFx0cmV0dXJuIFwiLVwiICsgbWF0Y2gudG9Mb3dlckNhc2UoKTtcbiAgXHR9KTtcblxuICBcdHJldHVybiBoeXBoZW5hdGVkO1xuICB9O1xuXG4gIHZhciBjcmVhdGVUcmFuc2l0aW9ucyxcbiAgICAgIGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9uc19fdGVzdFN0eWxlLFxuICAgICAgVFJBTlNJVElPTixcbiAgICAgIFRSQU5TSVRJT05FTkQsXG4gICAgICBDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCxcbiAgICAgIFRSQU5TSVRJT05fRFVSQVRJT04sXG4gICAgICBUUkFOU0lUSU9OX1BST1BFUlRZLFxuICAgICAgVFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT04sXG4gICAgICBjYW5Vc2VDc3NUcmFuc2l0aW9ucyA9IHt9LFxuICAgICAgY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnMgPSB7fTtcblxuICBpZiAoIWlzQ2xpZW50KSB7XG4gIFx0Y3JlYXRlVHJhbnNpdGlvbnMgPSBudWxsO1xuICB9IGVsc2Uge1xuICBcdGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9uc19fdGVzdFN0eWxlID0gY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZTtcblxuICBcdC8vIGRldGVybWluZSBzb21lIGZhY3RzIGFib3V0IG91ciBlbnZpcm9ubWVudFxuICBcdChmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zX190ZXN0U3R5bGUudHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFRSQU5TSVRJT04gPSBcInRyYW5zaXRpb25cIjtcbiAgXHRcdFx0VFJBTlNJVElPTkVORCA9IFwidHJhbnNpdGlvbmVuZFwiO1xuICBcdFx0XHRDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCA9IHRydWU7XG4gIFx0XHR9IGVsc2UgaWYgKGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9uc19fdGVzdFN0eWxlLndlYmtpdFRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRUUkFOU0lUSU9OID0gXCJ3ZWJraXRUcmFuc2l0aW9uXCI7XG4gIFx0XHRcdFRSQU5TSVRJT05FTkQgPSBcIndlYmtpdFRyYW5zaXRpb25FbmRcIjtcbiAgXHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSB0cnVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9KSgpO1xuXG4gIFx0aWYgKFRSQU5TSVRJT04pIHtcbiAgXHRcdFRSQU5TSVRJT05fRFVSQVRJT04gPSBUUkFOU0lUSU9OICsgXCJEdXJhdGlvblwiO1xuICBcdFx0VFJBTlNJVElPTl9QUk9QRVJUWSA9IFRSQU5TSVRJT04gKyBcIlByb3BlcnR5XCI7XG4gIFx0XHRUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTiA9IFRSQU5TSVRJT04gKyBcIlRpbWluZ0Z1bmN0aW9uXCI7XG4gIFx0fVxuXG4gIFx0Y3JlYXRlVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAodCwgdG8sIG9wdGlvbnMsIGNoYW5nZWRQcm9wZXJ0aWVzLCByZXNvbHZlKSB7XG5cbiAgXHRcdC8vIFdhaXQgYSBiZWF0IChvdGhlcndpc2UgdGhlIHRhcmdldCBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIGltbWVkaWF0ZWx5KVxuICBcdFx0Ly8gVE9ETyB1c2UgYSBmYXN0ZG9tLXN0eWxlIG1lY2hhbmlzbT9cbiAgXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXG4gIFx0XHRcdHZhciBoYXNoUHJlZml4LCBqc1RyYW5zaXRpb25zQ29tcGxldGUsIGNzc1RyYW5zaXRpb25zQ29tcGxldGUsIGNoZWNrQ29tcGxldGUsIHRyYW5zaXRpb25FbmRIYW5kbGVyO1xuXG4gIFx0XHRcdGNoZWNrQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0aWYgKGpzVHJhbnNpdGlvbnNDb21wbGV0ZSAmJiBjc3NUcmFuc2l0aW9uc0NvbXBsZXRlKSB7XG4gIFx0XHRcdFx0XHQvLyB3aWxsIGNoYW5nZXMgdG8gZXZlbnRzIGFuZCBmaXJlIGhhdmUgYW4gdW5leHBlY3RlZCBjb25zZXF1ZW5jZSBoZXJlP1xuICBcdFx0XHRcdFx0dC5yb290LmZpcmUodC5uYW1lICsgXCI6ZW5kXCIsIHQubm9kZSwgdC5pc0ludHJvKTtcbiAgXHRcdFx0XHRcdHJlc29sdmUoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0Ly8gdGhpcyBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZWxlbWVudHMgY2FuIHVzZSBDU1MgdG8gYW5pbWF0ZVxuICBcdFx0XHQvLyB3aGljaCBwcm9wZXJ0aWVzXG4gIFx0XHRcdGhhc2hQcmVmaXggPSAodC5ub2RlLm5hbWVzcGFjZVVSSSB8fCBcIlwiKSArIHQubm9kZS50YWdOYW1lO1xuXG4gIFx0XHRcdHQubm9kZS5zdHlsZVtUUkFOU0lUSU9OX1BST1BFUlRZXSA9IGNoYW5nZWRQcm9wZXJ0aWVzLm1hcChoZWxwZXJzX3ByZWZpeCkubWFwKGh5cGhlbmF0ZSkuam9pbihcIixcIik7XG4gIFx0XHRcdHQubm9kZS5zdHlsZVtUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTl0gPSBoeXBoZW5hdGUob3B0aW9ucy5lYXNpbmcgfHwgXCJsaW5lYXJcIik7XG4gIFx0XHRcdHQubm9kZS5zdHlsZVtUUkFOU0lUSU9OX0RVUkFUSU9OXSA9IG9wdGlvbnMuZHVyYXRpb24gLyAxMDAwICsgXCJzXCI7XG5cbiAgXHRcdFx0dHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgXHRcdFx0XHR2YXIgaW5kZXg7XG5cbiAgXHRcdFx0XHRpbmRleCA9IGNoYW5nZWRQcm9wZXJ0aWVzLmluZGV4T2YoY2FtZWxDYXNlKHVucHJlZml4KGV2ZW50LnByb3BlcnR5TmFtZSkpKTtcbiAgXHRcdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmIChjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRcdC8vIHN0aWxsIHRyYW5zaXRpb25pbmcuLi5cbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHR0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UpO1xuXG4gIFx0XHRcdFx0Y3NzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG4gIFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHQubm9kZS5hZGRFdmVudExpc3RlbmVyKFRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBmYWxzZSk7XG5cbiAgXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0dmFyIGkgPSBjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGgsXG4gIFx0XHRcdFx0ICAgIGhhc2gsXG4gIFx0XHRcdFx0ICAgIG9yaWdpbmFsVmFsdWUsXG4gIFx0XHRcdFx0ICAgIGluZGV4LFxuICBcdFx0XHRcdCAgICBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5KcyA9IFtdLFxuICBcdFx0XHRcdCAgICBwcm9wLFxuICBcdFx0XHRcdCAgICBzdWZmaXg7XG5cbiAgXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdFx0XHRwcm9wID0gY2hhbmdlZFByb3BlcnRpZXNbaV07XG4gIFx0XHRcdFx0XHRoYXNoID0gaGFzaFByZWZpeCArIHByb3A7XG5cbiAgXHRcdFx0XHRcdGlmIChDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCAmJiAhY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0pIHtcbiAgXHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXSA9IHRvW3Byb3BdO1xuXG4gIFx0XHRcdFx0XHRcdC8vIElmIHdlJ3JlIG5vdCBzdXJlIGlmIENTUyB0cmFuc2l0aW9ucyBhcmUgc3VwcG9ydGVkIGZvclxuICBcdFx0XHRcdFx0XHQvLyB0aGlzIHRhZy9wcm9wZXJ0eSBjb21ibywgZmluZCBvdXQgbm93XG4gIFx0XHRcdFx0XHRcdGlmICghY2FuVXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0pIHtcbiAgXHRcdFx0XHRcdFx0XHRvcmlnaW5hbFZhbHVlID0gdC5nZXRTdHlsZShwcm9wKTtcblxuICBcdFx0XHRcdFx0XHRcdC8vIGlmIHRoaXMgcHJvcGVydHkgaXMgdHJhbnNpdGlvbmFibGUgaW4gdGhpcyBicm93c2VyLFxuICBcdFx0XHRcdFx0XHRcdC8vIHRoZSBjdXJyZW50IHN0eWxlIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gdGhlIHRhcmdldCBzdHlsZVxuICBcdFx0XHRcdFx0XHRcdGNhblVzZUNzc1RyYW5zaXRpb25zW2hhc2hdID0gdC5nZXRTdHlsZShwcm9wKSAhPSB0b1twcm9wXTtcbiAgXHRcdFx0XHRcdFx0XHRjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1toYXNoXSA9ICFjYW5Vc2VDc3NUcmFuc2l0aW9uc1toYXNoXTtcblxuICBcdFx0XHRcdFx0XHRcdC8vIFJlc2V0LCBpZiB3ZSdyZSBnb2luZyB0byB1c2UgdGltZXJzIGFmdGVyIGFsbFxuICBcdFx0XHRcdFx0XHRcdGlmIChjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1toYXNoXSkge1xuICBcdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXSA9IG9yaWdpbmFsVmFsdWU7XG4gIFx0XHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdGlmICghQ1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgfHwgY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbaGFzaF0pIHtcbiAgXHRcdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gdGltZXItYmFzZWQgc3R1ZmZcbiAgXHRcdFx0XHRcdFx0aWYgKG9yaWdpbmFsVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHRcdFx0XHRcdG9yaWdpbmFsVmFsdWUgPSB0LmdldFN0eWxlKHByb3ApO1xuICBcdFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdFx0Ly8gbmVlZCB0byByZW1vdmUgdGhpcyBmcm9tIGNoYW5nZWRQcm9wZXJ0aWVzLCBvdGhlcndpc2UgdHJhbnNpdGlvbkVuZEhhbmRsZXJcbiAgXHRcdFx0XHRcdFx0Ly8gd2lsbCBnZXQgY29uZnVzZWRcbiAgXHRcdFx0XHRcdFx0aW5kZXggPSBjaGFuZ2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApO1xuICBcdFx0XHRcdFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdFx0XHRcdFx0d2FybklmRGVidWcoXCJTb21ldGhpbmcgdmVyeSBzdHJhbmdlIGhhcHBlbmVkIHdpdGggdHJhbnNpdGlvbnMuIFBsZWFzZSByYWlzZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIVwiLCB7IG5vZGU6IHQubm9kZSB9KTtcbiAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBcdFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdFx0Ly8gVE9ETyBEZXRlcm1pbmUgd2hldGhlciB0aGlzIHByb3BlcnR5IGlzIGFuaW1hdGFibGUgYXQgYWxsXG5cbiAgXHRcdFx0XHRcdFx0c3VmZml4ID0gL1teXFxkXSokLy5leGVjKHRvW3Byb3BdKVswXTtcblxuICBcdFx0XHRcdFx0XHQvLyAuLi50aGVuIGtpY2sgb2ZmIGEgdGltZXItYmFzZWQgdHJhbnNpdGlvblxuICBcdFx0XHRcdFx0XHRwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5wdXNoKHtcbiAgXHRcdFx0XHRcdFx0XHRuYW1lOiBoZWxwZXJzX3ByZWZpeChwcm9wKSxcbiAgXHRcdFx0XHRcdFx0XHRpbnRlcnBvbGF0b3I6IHNoYXJlZF9pbnRlcnBvbGF0ZShwYXJzZUZsb2F0KG9yaWdpbmFsVmFsdWUpLCBwYXJzZUZsb2F0KHRvW3Byb3BdKSksXG4gIFx0XHRcdFx0XHRcdFx0c3VmZml4OiBzdWZmaXhcbiAgXHRcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gamF2YXNjcmlwdCB0cmFuc2l0aW9uc1xuICBcdFx0XHRcdGlmIChwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5sZW5ndGgpIHtcbiAgXHRcdFx0XHRcdG5ldyBzaGFyZWRfVGlja2VyKHtcbiAgXHRcdFx0XHRcdFx0cm9vdDogdC5yb290LFxuICBcdFx0XHRcdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgXHRcdFx0XHRcdFx0ZWFzaW5nOiBjYW1lbENhc2Uob3B0aW9ucy5lYXNpbmcgfHwgXCJcIiksXG4gIFx0XHRcdFx0XHRcdHN0ZXA6IGZ1bmN0aW9uIChwb3MpIHtcbiAgXHRcdFx0XHRcdFx0XHR2YXIgcHJvcCwgaTtcblxuICBcdFx0XHRcdFx0XHRcdGkgPSBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5sZW5ndGg7XG4gIFx0XHRcdFx0XHRcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRcdFx0XHRcdFx0cHJvcCA9IHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzW2ldO1xuICBcdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlW3Byb3AubmFtZV0gPSBwcm9wLmludGVycG9sYXRvcihwb3MpICsgcHJvcC5zdWZmaXg7XG4gIFx0XHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHR9LFxuICBcdFx0XHRcdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0XHRcdGpzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG4gIFx0XHRcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0anNUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoIWNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICBcdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBhbmQgZGVhbCB3aXRoXG4gIFx0XHRcdFx0XHQvLyB0aGUgZmFjdCB0aGF0IGl0IHdpbGwgbmV2ZXIgZmlyZVxuICBcdFx0XHRcdFx0dC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlKTtcbiAgXHRcdFx0XHRcdGNzc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuICBcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSwgMCk7XG4gIFx0XHR9LCBvcHRpb25zLmRlbGF5IHx8IDApO1xuICBcdH07XG4gIH1cblxuICB2YXIgYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zID0gY3JlYXRlVHJhbnNpdGlvbnM7XG5cbiAgdmFyIGhpZGRlbiwgdmVuZG9yLCBhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9fcHJlZml4LCBhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9faSwgdmlzaWJpbGl0eTtcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIFx0aGlkZGVuID0gXCJoaWRkZW5cIjtcblxuICBcdHZpc2liaWxpdHkgPSB7fTtcblxuICBcdGlmIChoaWRkZW4gaW4gZG9jdW1lbnQpIHtcbiAgXHRcdGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19wcmVmaXggPSBcIlwiO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRhbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9faSA9IHZlbmRvcnMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19pLS0pIHtcbiAgXHRcdFx0dmVuZG9yID0gdmVuZG9yc1thbmltYXRlU3R5bGVfdmlzaWJpbGl0eV9faV07XG4gIFx0XHRcdGhpZGRlbiA9IHZlbmRvciArIFwiSGlkZGVuXCI7XG5cbiAgXHRcdFx0aWYgKGhpZGRlbiBpbiBkb2N1bWVudCkge1xuICBcdFx0XHRcdGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19wcmVmaXggPSB2ZW5kb3I7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHlfX3ByZWZpeCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5X19wcmVmaXggKyBcInZpc2liaWxpdHljaGFuZ2VcIiwgb25DaGFuZ2UpO1xuXG4gIFx0XHQvLyBpbml0aWFsaXNlXG4gIFx0XHRvbkNoYW5nZSgpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBnYWgsIHdlJ3JlIGluIGFuIG9sZCBicm93c2VyXG4gIFx0XHRpZiAoXCJvbmZvY3Vzb3V0XCIgaW4gZG9jdW1lbnQpIHtcbiAgXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIG9uSGlkZSk7XG4gIFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIG9uU2hvdyk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIG9uSGlkZSk7XG4gIFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBvbkhpZGUpO1xuXG4gIFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZXNob3dcIiwgb25TaG93KTtcbiAgXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBvblNob3cpO1xuICBcdFx0fVxuXG4gIFx0XHR2aXNpYmlsaXR5LmhpZGRlbiA9IGZhbHNlOyAvLyB1bnRpbCBwcm92ZW4gb3RoZXJ3aXNlLiBOb3QgaWRlYWwgYnV0IGhleVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICBcdHZpc2liaWxpdHkuaGlkZGVuID0gZG9jdW1lbnRbaGlkZGVuXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uSGlkZSgpIHtcbiAgXHR2aXNpYmlsaXR5LmhpZGRlbiA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBvblNob3coKSB7XG4gIFx0dmlzaWJpbGl0eS5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBhbmltYXRlU3R5bGVfdmlzaWJpbGl0eSA9IHZpc2liaWxpdHk7XG5cbiAgdmFyIGFuaW1hdGVTdHlsZSwgX2FuaW1hdGVTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZSwgcmVzb2x2ZWQ7XG5cbiAgaWYgKCFpc0NsaWVudCkge1xuICBcdGFuaW1hdGVTdHlsZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gIFx0X2FuaW1hdGVTdHlsZV9fZ2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHx8IGxlZ2FjeS5nZXRDb21wdXRlZFN0eWxlO1xuXG4gIFx0YW5pbWF0ZVN0eWxlID0gZnVuY3Rpb24gKHN0eWxlLCB2YWx1ZSwgb3B0aW9ucykge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIHRvO1xuXG4gIFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ0LmFuaW1hdGVTdHlsZSgpIHJldHVybnMgYSBwcm9taXNlIC0gdXNlIC50aGVuKCkgaW5zdGVhZCBvZiBwYXNzaW5nIGEgY2FsbGJhY2tcIik7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSAtIHBhZ2UgaXNuJ3QgdmlzaWJsZS4gRG9uJ3QgYW5pbWF0ZSBhbnl0aGluZywgYmVjYXVzZVxuICBcdFx0Ly8gdGhhdCB3YXkgeW91J2xsIG5ldmVyIGdldCBDU1MgdHJhbnNpdGlvbmVuZCBldmVudHNcbiAgXHRcdGlmIChhbmltYXRlU3R5bGVfdmlzaWJpbGl0eS5oaWRkZW4pIHtcbiAgXHRcdFx0dGhpcy5zZXRTdHlsZShzdHlsZSwgdmFsdWUpO1xuICBcdFx0XHRyZXR1cm4gcmVzb2x2ZWQgfHwgKHJlc29sdmVkID0gdXRpbHNfUHJvbWlzZS5yZXNvbHZlKCkpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodHlwZW9mIHN0eWxlID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdHRvID0ge307XG4gIFx0XHRcdHRvW3N0eWxlXSA9IHZhbHVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dG8gPSBzdHlsZTtcblxuICBcdFx0XHQvLyBzaHVmZmxlIGFyZ3VtZW50c1xuICBcdFx0XHRvcHRpb25zID0gdmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIEFzIG9mIDAuMy45LCB0cmFuc2l0aW9uIGF1dGhvcnMgc2hvdWxkIHN1cHBseSBhbiBgb3B0aW9uYCBvYmplY3Qgd2l0aFxuICBcdFx0Ly8gYGR1cmF0aW9uYCBhbmQgYGVhc2luZ2AgcHJvcGVydGllcyAoYW5kIG9wdGlvbmFsIGBkZWxheWApLCBwbHVzIGFcbiAgXHRcdC8vIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXNcblxuICBcdFx0Ly8gVE9ETyByZW1vdmUgdGhpcyBjaGVjayBpbiBhIGZ1dHVyZSB2ZXJzaW9uXG4gIFx0XHRpZiAoIW9wdGlvbnMpIHtcbiAgXHRcdFx0d2Fybk9uY2VJZkRlYnVnKFwiVGhlIFxcXCIlc1xcXCIgdHJhbnNpdGlvbiBkb2VzIG5vdCBzdXBwbHkgYW4gb3B0aW9ucyBvYmplY3QgdG8gYHQuYW5pbWF0ZVN0eWxlKClgLiBUaGlzIHdpbGwgYnJlYWsgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSYWN0aXZlLiBGb3IgbW9yZSBpbmZvIHNlZSBodHRwczovL2dpdGh1Yi5jb20vUmFjdGl2ZUpTL1JhY3RpdmUvaXNzdWVzLzM0MFwiLCB0aGlzLm5hbWUpO1xuICBcdFx0XHRvcHRpb25zID0gdGhpcztcbiAgXHRcdH1cblxuICBcdFx0dmFyIHByb21pc2UgPSBuZXcgdXRpbHNfUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICBcdFx0XHR2YXIgcHJvcGVydHlOYW1lcywgY2hhbmdlZFByb3BlcnRpZXMsIGNvbXB1dGVkU3R5bGUsIGN1cnJlbnQsIGZyb20sIGksIHByb3A7XG5cbiAgXHRcdFx0Ly8gRWRnZSBjYXNlIC0gaWYgZHVyYXRpb24gaXMgemVybywgc2V0IHN0eWxlIHN5bmNocm9ub3VzbHkgYW5kIGNvbXBsZXRlXG4gIFx0XHRcdGlmICghb3B0aW9ucy5kdXJhdGlvbikge1xuICBcdFx0XHRcdF90aGlzLnNldFN0eWxlKHRvKTtcbiAgXHRcdFx0XHRyZXNvbHZlKCk7XG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gR2V0IGEgbGlzdCBvZiB0aGUgcHJvcGVydGllcyB3ZSdyZSBhbmltYXRpbmdcbiAgXHRcdFx0cHJvcGVydHlOYW1lcyA9IE9iamVjdC5rZXlzKHRvKTtcbiAgXHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMgPSBbXTtcblxuICBcdFx0XHQvLyBTdG9yZSB0aGUgY3VycmVudCBzdHlsZXNcbiAgXHRcdFx0Y29tcHV0ZWRTdHlsZSA9IF9hbmltYXRlU3R5bGVfX2dldENvbXB1dGVkU3R5bGUoX3RoaXMubm9kZSk7XG5cbiAgXHRcdFx0ZnJvbSA9IHt9O1xuICBcdFx0XHRpID0gcHJvcGVydHlOYW1lcy5sZW5ndGg7XG4gIFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRwcm9wID0gcHJvcGVydHlOYW1lc1tpXTtcbiAgXHRcdFx0XHRjdXJyZW50ID0gY29tcHV0ZWRTdHlsZVtoZWxwZXJzX3ByZWZpeChwcm9wKV07XG5cbiAgXHRcdFx0XHRpZiAoY3VycmVudCA9PT0gXCIwcHhcIikge1xuICBcdFx0XHRcdFx0Y3VycmVudCA9IDA7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBrbm93IGlmIHdlJ3JlIGFjdHVhbGx5IGNoYW5naW5nIGFueXRoaW5nXG4gIFx0XHRcdFx0aWYgKGN1cnJlbnQgIT0gdG9bcHJvcF0pIHtcbiAgXHRcdFx0XHRcdC8vIHVzZSAhPSBpbnN0ZWFkIG9mICE9PSwgc28gd2UgY2FuIGNvbXBhcmUgc3RyaW5ncyB3aXRoIG51bWJlcnNcbiAgXHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG5cbiAgXHRcdFx0XHRcdC8vIG1ha2UgdGhlIGNvbXB1dGVkIHN0eWxlIGV4cGxpY2l0LCBzbyB3ZSBjYW4gYW5pbWF0ZSB3aGVyZVxuICBcdFx0XHRcdFx0Ly8gZS5nLiBoZWlnaHQ9J2F1dG8nXG4gIFx0XHRcdFx0XHRfdGhpcy5ub2RlLnN0eWxlW2hlbHBlcnNfcHJlZml4KHByb3ApXSA9IGN1cnJlbnQ7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gSWYgd2UncmUgbm90IGFjdHVhbGx5IGNoYW5naW5nIGFueXRoaW5nLCB0aGUgdHJhbnNpdGlvbmVuZCBldmVudFxuICBcdFx0XHQvLyB3aWxsIG5ldmVyIGZpcmUhIFNvIHdlIGNvbXBsZXRlIGVhcmx5XG4gIFx0XHRcdGlmICghY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0cmVzb2x2ZSgpO1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9ucyhfdGhpcywgdG8sIG9wdGlvbnMsIGNoYW5nZWRQcm9wZXJ0aWVzLCByZXNvbHZlKTtcbiAgXHRcdH0pO1xuXG4gIFx0XHRyZXR1cm4gcHJvbWlzZTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIF9hbmltYXRlU3R5bGUgPSBhbmltYXRlU3R5bGU7XG5cbiAgdmFyIHByb2Nlc3NQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBkZWZhdWx0cykge1xuICBcdGlmICh0eXBlb2YgcGFyYW1zID09PSBcIm51bWJlclwiKSB7XG4gIFx0XHRwYXJhbXMgPSB7IGR1cmF0aW9uOiBwYXJhbXMgfTtcbiAgXHR9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdGlmIChwYXJhbXMgPT09IFwic2xvd1wiKSB7XG4gIFx0XHRcdHBhcmFtcyA9IHsgZHVyYXRpb246IDYwMCB9O1xuICBcdFx0fSBlbHNlIGlmIChwYXJhbXMgPT09IFwiZmFzdFwiKSB7XG4gIFx0XHRcdHBhcmFtcyA9IHsgZHVyYXRpb246IDIwMCB9O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyYW1zID0geyBkdXJhdGlvbjogNDAwIH07XG4gIFx0XHR9XG4gIFx0fSBlbHNlIGlmICghcGFyYW1zKSB7XG4gIFx0XHRwYXJhbXMgPSB7fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZmlsbEdhcHMoe30sIHBhcmFtcywgZGVmYXVsdHMpO1xuICB9O1xuXG4gIHZhciBwcm90b3R5cGVfc3RhcnQgPSBUcmFuc2l0aW9uJHN0YXJ0O1xuXG4gIGZ1bmN0aW9uIFRyYW5zaXRpb24kc3RhcnQoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciBub2RlLCBvcmlnaW5hbFN0eWxlLCBjb21wbGV0ZWQ7XG5cbiAgXHRub2RlID0gdGhpcy5ub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG4gIFx0b3JpZ2luYWxTdHlsZSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG5cbiAgXHQvLyBjcmVhdGUgdC5jb21wbGV0ZSgpIC0gd2UgZG9uJ3Qgd2FudCB0aGlzIG9uIHRoZSBwcm90b3R5cGUsXG4gIFx0Ly8gYmVjYXVzZSB3ZSBkb24ndCB3YW50IGB0aGlzYCBzaWxsaW5lc3Mgd2hlbiBwYXNzaW5nIGl0IGFzXG4gIFx0Ly8gYW4gYXJndW1lbnRcbiAgXHR0aGlzLmNvbXBsZXRlID0gZnVuY3Rpb24gKG5vUmVzZXQpIHtcbiAgXHRcdGlmIChjb21wbGV0ZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIW5vUmVzZXQgJiYgX3RoaXMuaXNJbnRybykge1xuICBcdFx0XHRyZXNldFN0eWxlKG5vZGUsIG9yaWdpbmFsU3R5bGUpO1xuICBcdFx0fVxuXG4gIFx0XHRub2RlLl9yYWN0aXZlLnRyYW5zaXRpb24gPSBudWxsO1xuICBcdFx0X3RoaXMuX21hbmFnZXIucmVtb3ZlKF90aGlzKTtcblxuICBcdFx0Y29tcGxldGVkID0gdHJ1ZTtcbiAgXHR9O1xuXG4gIFx0Ly8gSWYgdGhlIHRyYW5zaXRpb24gZnVuY3Rpb24gZG9lc24ndCBleGlzdCwgYWJvcnRcbiAgXHRpZiAoIXRoaXMuX2ZuKSB7XG4gIFx0XHR0aGlzLmNvbXBsZXRlKCk7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dGhpcy5fZm4uYXBwbHkodGhpcy5yb290LCBbdGhpc10uY29uY2F0KHRoaXMucGFyYW1zKSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFN0eWxlKG5vZGUsIHN0eWxlKSB7XG4gIFx0aWYgKHN0eWxlKSB7XG4gIFx0XHRub2RlLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIHN0eWxlKTtcbiAgXHR9IGVsc2Uge1xuXG4gIFx0XHQvLyBOZXh0IGxpbmUgaXMgbmVjZXNzYXJ5LCB0byByZW1vdmUgZW1wdHkgc3R5bGUgYXR0cmlidXRlIVxuICBcdFx0Ly8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNjc1NTNcbiAgXHRcdG5vZGUuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIFx0XHRub2RlLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG93bmVyLCB0ZW1wbGF0ZSwgaXNJbnRybykge1xuICBcdHRoaXMuaW5pdChvd25lciwgdGVtcGxhdGUsIGlzSW50cm8pO1xuICB9O1xuXG4gIFRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuICBcdGluaXQ6IFRyYW5zaXRpb25fcHJvdG90eXBlX2luaXQsXG4gIFx0c3RhcnQ6IHByb3RvdHlwZV9zdGFydCxcbiAgXHRnZXRTdHlsZTogcHJvdG90eXBlX2dldFN0eWxlLFxuICBcdHNldFN0eWxlOiBzZXRTdHlsZSxcbiAgXHRhbmltYXRlU3R5bGU6IF9hbmltYXRlU3R5bGUsXG4gIFx0cHJvY2Vzc1BhcmFtczogcHJvY2Vzc1BhcmFtc1xuICB9O1xuXG4gIHZhciBfVHJhbnNpdGlvbiA9IFRyYW5zaXRpb247XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX3JlbmRlciA9IEVsZW1lbnQkcmVuZGVyO1xuXG4gIHZhciB1cGRhdGVDc3MsIHVwZGF0ZVNjcmlwdDtcblxuICB1cGRhdGVDc3MgPSBmdW5jdGlvbiAoKSB7XG4gIFx0dmFyIG5vZGUgPSB0aGlzLm5vZGUsXG4gIFx0ICAgIGNvbnRlbnQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKGZhbHNlKTtcblxuICBcdC8vIElFOCBoYXMgbm8gc3R5bGVTaGVldCB1bmxlc3MgdGhlcmUncyBhIHR5cGUgdGV4dC9jc3NcbiAgXHRpZiAod2luZG93ICYmIHdpbmRvdy5hcHBlYXJzVG9CZUlFTGVzc0VxdWFsOCkge1xuICBcdFx0bm9kZS50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICBcdH1cblxuICBcdGlmIChub2RlLnN0eWxlU2hlZXQpIHtcbiAgXHRcdG5vZGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY29udGVudDtcbiAgXHR9IGVsc2Uge1xuXG4gIFx0XHR3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgXHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICBcdFx0fVxuXG4gIFx0XHRub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpKTtcbiAgXHR9XG4gIH07XG5cbiAgdXBkYXRlU2NyaXB0ID0gZnVuY3Rpb24gKCkge1xuICBcdGlmICghdGhpcy5ub2RlLnR5cGUgfHwgdGhpcy5ub2RlLnR5cGUgPT09IFwidGV4dC9qYXZhc2NyaXB0XCIpIHtcbiAgXHRcdHdhcm5JZkRlYnVnKFwiU2NyaXB0IHRhZyB3YXMgdXBkYXRlZC4gVGhpcyBkb2VzIG5vdCBjYXVzZSB0aGUgY29kZSB0byBiZSByZS1ldmFsdWF0ZWQhXCIsIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdFx0Ly8gQXMgaXQgaGFwcGVucywgd2UgQVJFIGluIGEgcG9zaXRpb24gdG8gcmUtZXZhbHVhdGUgdGhlIGNvZGUgaWYgd2Ugd2FudGVkXG4gIFx0XHQvLyB0byAtIHdlIGNvdWxkIGV2YWwoKSBpdCwgb3IgaW5zZXJ0IGl0IGludG8gYSBmcmVzaCAodGVtcG9yYXJ5KSBzY3JpcHQgdGFnLlxuICBcdFx0Ly8gQnV0IHRoaXMgd291bGQgYmUgYSB0ZXJyaWJsZSBpZGVhIHdpdGggdW5wcmVkaWN0YWJsZSByZXN1bHRzLCBzbyBsZXQncyBub3QuXG4gIFx0fVxuXG4gIFx0dGhpcy5ub2RlLnRleHQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKGZhbHNlKTtcbiAgfTtcbiAgZnVuY3Rpb24gRWxlbWVudCRyZW5kZXIoKSB7XG4gIFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdHZhciByb290ID0gdGhpcy5yb290LFxuICBcdCAgICBuYW1lc3BhY2UsXG4gIFx0ICAgIG5vZGUsXG4gIFx0ICAgIHRyYW5zaXRpb247XG5cbiAgXHRuYW1lc3BhY2UgPSBnZXROYW1lc3BhY2UodGhpcyk7XG4gIFx0bm9kZSA9IHRoaXMubm9kZSA9IGNyZWF0ZUVsZW1lbnQodGhpcy5uYW1lLCBuYW1lc3BhY2UpO1xuXG4gIFx0Ly8gSXMgdGhpcyBhIHRvcC1sZXZlbCBub2RlIG9mIGEgY29tcG9uZW50PyBJZiBzbywgd2UgbWF5IG5lZWQgdG8gYWRkXG4gIFx0Ly8gYSBkYXRhLXJhY3RpdmUtY3NzIGF0dHJpYnV0ZSwgZm9yIENTUyBlbmNhcHN1bGF0aW9uXG4gIFx0aWYgKHRoaXMucGFyZW50RnJhZ21lbnQuY3NzSWRzKSB7XG4gIFx0XHR0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS1yYWN0aXZlLWNzc1wiLCB0aGlzLnBhcmVudEZyYWdtZW50LmNzc0lkcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgXHRcdFx0cmV0dXJuIFwie1wiICsgeCArIFwifVwiO1xuICBcdFx0fSkuam9pbihcIiBcIikpO1xuICBcdH1cblxuICBcdC8vIEFkZCBfcmFjdGl2ZSBwcm9wZXJ0eSB0byB0aGUgbm9kZSAtIHdlIHVzZSB0aGlzIG9iamVjdCB0byBzdG9yZSBzdHVmZlxuICBcdC8vIHJlbGF0ZWQgdG8gcHJveHkgZXZlbnRzLCB0d28td2F5IGJpbmRpbmdzIGV0Y1xuICBcdGRlZmluZVByb3BlcnR5KHRoaXMubm9kZSwgXCJfcmFjdGl2ZVwiLCB7XG4gIFx0XHR2YWx1ZToge1xuICBcdFx0XHRwcm94eTogdGhpcyxcbiAgXHRcdFx0a2V5cGF0aDogZ2V0SW5uZXJDb250ZXh0KHRoaXMucGFyZW50RnJhZ21lbnQpLFxuICBcdFx0XHRldmVudHM6IGNyZWF0ZShudWxsKSxcbiAgXHRcdFx0cm9vdDogcm9vdFxuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0Ly8gUmVuZGVyIGF0dHJpYnV0ZXNcbiAgXHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICBcdFx0cmV0dXJuIGEucmVuZGVyKG5vZGUpO1xuICBcdH0pO1xuICBcdHRoaXMuY29uZGl0aW9uYWxBdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgXHRcdHJldHVybiBhLnJlbmRlcihub2RlKTtcbiAgXHR9KTtcblxuICBcdC8vIFJlbmRlciBjaGlsZHJlblxuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8c2NyaXB0PiBlbGVtZW50XG4gIFx0XHRpZiAodGhpcy5uYW1lID09PSBcInNjcmlwdFwiKSB7XG4gIFx0XHRcdHRoaXMuYnViYmxlID0gdXBkYXRlU2NyaXB0O1xuICBcdFx0XHR0aGlzLm5vZGUudGV4dCA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoZmFsc2UpOyAvLyBieXBhc3Mgd2FybmluZyBpbml0aWFsbHlcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciA9IG5vb3A7IC8vIFRPRE8gdGhpcyBpcyBhIGtsdWRnZVxuICBcdFx0fVxuXG4gIFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8c3R5bGU+IGVsZW1lbnRcbiAgXHRcdGVsc2UgaWYgKHRoaXMubmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gIFx0XHRcdHRoaXMuYnViYmxlID0gdXBkYXRlQ3NzO1xuICBcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyID0gbm9vcDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gY29udGVudGVkaXRhYmxlXG4gIFx0XHRlbHNlIGlmICh0aGlzLmJpbmRpbmcgJiYgdGhpcy5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciA9IG5vb3A7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5mcmFnbWVudC5yZW5kZXIoKSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gZGVhbCB3aXRoIHR3by13YXkgYmluZGluZ3NcbiAgXHRpZiAodGhpcy5iaW5kaW5nKSB7XG4gIFx0XHR0aGlzLmJpbmRpbmcucmVuZGVyKCk7XG4gIFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuYmluZGluZyA9IHRoaXMuYmluZGluZztcbiAgXHR9XG5cbiAgXHQvLyBBZGQgcHJveHkgZXZlbnQgaGFuZGxlcnNcbiAgXHRpZiAodGhpcy5ldmVudEhhbmRsZXJzKSB7XG4gIFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaCkge1xuICBcdFx0XHRyZXR1cm4gaC5yZW5kZXIoKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgXHRcdHByb2Nlc3NPcHRpb24odGhpcyk7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlc1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwiaW1nXCIpIHtcbiAgXHRcdC8vIGlmIHRoaXMgaXMgYW4gPGltZz4sIGFuZCB3ZSdyZSBpbiBhIGNyYXAgYnJvd3Nlciwgd2UgbWF5XG4gIFx0XHQvLyBuZWVkIHRvIHByZXZlbnQgaXQgZnJvbSBvdmVycmlkaW5nIHdpZHRoIGFuZCBoZWlnaHQgd2hlblxuICBcdFx0Ly8gaXQgbG9hZHMgdGhlIHNyY1xuICBcdFx0c3BlY2lhbF9pbWdfX3JlbmRlcih0aGlzKTtcbiAgXHR9IGVsc2UgaWYgKHRoaXMubmFtZSA9PT0gXCJmb3JtXCIpIHtcbiAgXHRcdC8vIGZvcm1zIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB0aGVpciBiaW5kaW5ncywgaW4gY2FzZSBvZiByZXNldFxuICBcdFx0Zm9ybV9fcmVuZGVyKHRoaXMpO1xuICBcdH0gZWxzZSBpZiAodGhpcy5uYW1lID09PSBcImlucHV0XCIgfHwgdGhpcy5uYW1lID09PSBcInRleHRhcmVhXCIpIHtcbiAgXHRcdC8vIGlucHV0cyBhbmQgdGV4dGFyZWFzIHNob3VsZCBzdG9yZSB0aGVpciBpbml0aWFsIHZhbHVlIGFzXG4gIFx0XHQvLyBgZGVmYXVsdFZhbHVlYCBpbiBjYXNlIG9mIHJlc2V0XG4gIFx0XHR0aGlzLm5vZGUuZGVmYXVsdFZhbHVlID0gdGhpcy5ub2RlLnZhbHVlO1xuICBcdH0gZWxzZSBpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiKSB7XG4gIFx0XHQvLyBzaW1pbGFybHkgZm9yIG9wdGlvbiBub2Rlc1xuICBcdFx0dGhpcy5ub2RlLmRlZmF1bHRTZWxlY3RlZCA9IHRoaXMubm9kZS5zZWxlY3RlZDtcbiAgXHR9XG5cbiAgXHQvLyBhcHBseSBkZWNvcmF0b3IocylcbiAgXHRpZiAodGhpcy5kZWNvcmF0b3IgJiYgdGhpcy5kZWNvcmF0b3IuZm4pIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdGlmICghX3RoaXMuZGVjb3JhdG9yLnRvcm5kb3duKSB7XG4gIFx0XHRcdFx0X3RoaXMuZGVjb3JhdG9yLmluaXQoKTtcbiAgXHRcdFx0fVxuICBcdFx0fSwgdHJ1ZSk7XG4gIFx0fVxuXG4gIFx0Ly8gdHJpZ2dlciBpbnRybyB0cmFuc2l0aW9uXG4gIFx0aWYgKHJvb3QudHJhbnNpdGlvbnNFbmFibGVkICYmIHRoaXMuaW50cm8pIHtcbiAgXHRcdHRyYW5zaXRpb24gPSBuZXcgX1RyYW5zaXRpb24odGhpcywgdGhpcy5pbnRybywgdHJ1ZSk7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5yZWdpc3RlclRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gdHJhbnNpdGlvbi5zdGFydCgpO1xuICBcdFx0fSwgdHJ1ZSk7XG5cbiAgXHRcdHRoaXMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMubm9kZS5hdXRvZm9jdXMpIHtcbiAgXHRcdC8vIFNwZWNpYWwgY2FzZS4gU29tZSBicm93c2VycyAoKmNvdWdoKiBGaXJlZml4ICpjb3VnaCopIGhhdmUgYSBwcm9ibGVtXG4gIFx0XHQvLyB3aXRoIGR5bmFtaWNhbGx5LWdlbmVyYXRlZCBlbGVtZW50cyBoYXZpbmcgYXV0b2ZvY3VzLCBhbmQgdGhleSB3b24ndFxuICBcdFx0Ly8gYWxsb3cgeW91IHRvIHByb2dyYW1tYXRpY2FsbHkgZm9jdXMgdGhlIGVsZW1lbnQgdW50aWwgaXQncyBpbiB0aGUgRE9NXG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zY2hlZHVsZVRhc2soZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gX3RoaXMubm9kZS5mb2N1cygpO1xuICBcdFx0fSwgdHJ1ZSk7XG4gIFx0fVxuXG4gIFx0dXBkYXRlTGl2ZVF1ZXJpZXModGhpcyk7XG4gIFx0cmV0dXJuIHRoaXMubm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5hbWVzcGFjZShlbGVtZW50KSB7XG4gIFx0dmFyIG5hbWVzcGFjZSwgeG1sbnMsIHBhcmVudDtcblxuICBcdC8vIFVzZSBzcGVjaWZpZWQgbmFtZXNwYWNlLi4uXG4gIFx0aWYgKHhtbG5zID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiKSkge1xuICBcdFx0bmFtZXNwYWNlID0geG1sbnM7XG4gIFx0fVxuXG4gIFx0Ly8gLi4ub3IgU1ZHIG5hbWVzcGFjZSwgaWYgdGhpcyBpcyBhbiA8c3ZnPiBlbGVtZW50XG4gIFx0ZWxzZSBpZiAoZWxlbWVudC5uYW1lID09PSBcInN2Z1wiKSB7XG4gIFx0XHRuYW1lc3BhY2UgPSBuYW1lc3BhY2VzLnN2ZztcbiAgXHR9IGVsc2UgaWYgKHBhcmVudCA9IGVsZW1lbnQucGFyZW50KSB7XG4gIFx0XHQvLyAuLi5vciBIVE1MLCBpZiB0aGUgcGFyZW50IGlzIGEgPGZvcmVpZ25PYmplY3Q+XG4gIFx0XHRpZiAocGFyZW50Lm5hbWUgPT09IFwiZm9yZWlnbk9iamVjdFwiKSB7XG4gIFx0XHRcdG5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuaHRtbDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gLi4ub3IgaW5oZXJpdCBmcm9tIHRoZSBwYXJlbnQgbm9kZVxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdG5hbWVzcGFjZSA9IHBhcmVudC5ub2RlLm5hbWVzcGFjZVVSSTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0bmFtZXNwYWNlID0gZWxlbWVudC5yb290LmVsLm5hbWVzcGFjZVVSSTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbmFtZXNwYWNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc09wdGlvbihvcHRpb24pIHtcbiAgXHR2YXIgb3B0aW9uVmFsdWUsIHNlbGVjdFZhbHVlLCBpO1xuXG4gIFx0aWYgKCFvcHRpb24uc2VsZWN0KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0c2VsZWN0VmFsdWUgPSBvcHRpb24uc2VsZWN0LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICBcdGlmIChzZWxlY3RWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRpZiAob3B0aW9uLnNlbGVjdC5ub2RlLm11bHRpcGxlICYmIGlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gIFx0XHRpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpZiAob3B0aW9uVmFsdWUgPT0gc2VsZWN0VmFsdWVbaV0pIHtcbiAgXHRcdFx0XHRvcHRpb24ubm9kZS5zZWxlY3RlZCA9IHRydWU7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0b3B0aW9uLm5vZGUuc2VsZWN0ZWQgPSBvcHRpb25WYWx1ZSA9PSBzZWxlY3RWYWx1ZTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaXZlUXVlcmllcyhlbGVtZW50KSB7XG4gIFx0dmFyIGluc3RhbmNlLCBsaXZlUXVlcmllcywgaSwgc2VsZWN0b3IsIHF1ZXJ5O1xuXG4gIFx0Ly8gRG9lcyB0aGlzIG5lZWQgdG8gYmUgYWRkZWQgdG8gYW55IGxpdmUgcXVlcmllcz9cbiAgXHRpbnN0YW5jZSA9IGVsZW1lbnQucm9vdDtcblxuICBcdGRvIHtcbiAgXHRcdGxpdmVRdWVyaWVzID0gaW5zdGFuY2UuX2xpdmVRdWVyaWVzO1xuXG4gIFx0XHRpID0gbGl2ZVF1ZXJpZXMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRzZWxlY3RvciA9IGxpdmVRdWVyaWVzW2ldO1xuICBcdFx0XHRxdWVyeSA9IGxpdmVRdWVyaWVzW1wiX1wiICsgc2VsZWN0b3JdO1xuXG4gIFx0XHRcdGlmIChxdWVyeS5fdGVzdChlbGVtZW50KSkge1xuICBcdFx0XHRcdC8vIGtlZXAgcmVnaXN0ZXIgb2YgYXBwbGljYWJsZSBzZWxlY3RvcnMsIGZvciB3aGVuIHdlIHRlYXJkb3duXG4gIFx0XHRcdFx0KGVsZW1lbnQubGl2ZVF1ZXJpZXMgfHwgKGVsZW1lbnQubGl2ZVF1ZXJpZXMgPSBbXSkpLnB1c2gocXVlcnkpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5wYXJlbnQpO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX3RvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICBcdHZhciBzdHIsIGVzY2FwZTtcblxuICBcdGlmICh0aGlzLnRlbXBsYXRlLnkpIHtcbiAgXHRcdC8vIERPQ1RZUEUgZGVjbGFyYXRpb25cbiAgXHRcdHJldHVybiBcIjwhRE9DVFlQRVwiICsgdGhpcy50ZW1wbGF0ZS5kZCArIFwiPlwiO1xuICBcdH1cblxuICBcdHN0ciA9IFwiPFwiICsgdGhpcy50ZW1wbGF0ZS5lO1xuXG4gIFx0c3RyICs9IHRoaXMuYXR0cmlidXRlcy5tYXAoc3RyaW5naWZ5QXR0cmlidXRlKS5qb2luKFwiXCIpICsgdGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMubWFwKHN0cmluZ2lmeUF0dHJpYnV0ZSkuam9pbihcIlwiKTtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHNlbGVjdGVkIG9wdGlvbnNcbiAgXHRpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiICYmIG9wdGlvbklzU2VsZWN0ZWQodGhpcykpIHtcbiAgXHRcdHN0ciArPSBcIiBzZWxlY3RlZFwiO1xuICBcdH1cblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHR3by13YXkgcmFkaW8gbmFtZSBiaW5kaW5nc1xuICBcdGlmICh0aGlzLm5hbWUgPT09IFwiaW5wdXRcIiAmJiBpbnB1dElzQ2hlY2tlZFJhZGlvKHRoaXMpKSB7XG4gIFx0XHRzdHIgKz0gXCIgY2hlY2tlZFwiO1xuICBcdH1cblxuICBcdHN0ciArPSBcIj5cIjtcblxuICBcdC8vIFNwZWNpYWwgY2FzZSAtIHRleHRhcmVhXG4gIFx0aWYgKHRoaXMubmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICYmIHRoaXMuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0c3RyICs9IGVzY2FwZUh0bWwodGhpcy5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSk7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gY29udGVudGVkaXRhYmxlXG4gIFx0ZWxzZSBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0c3RyICs9IHRoaXMuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgfHwgXCJcIjtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0ZXNjYXBlID0gdGhpcy5uYW1lICE9PSBcInNjcmlwdFwiICYmIHRoaXMubmFtZSAhPT0gXCJzdHlsZVwiO1xuICBcdFx0c3RyICs9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoZXNjYXBlKTtcbiAgXHR9XG5cbiAgXHQvLyBhZGQgYSBjbG9zaW5nIHRhZyBpZiB0aGlzIGlzbid0IGEgdm9pZCBlbGVtZW50XG4gIFx0aWYgKCF2b2lkRWxlbWVudE5hbWVzLnRlc3QodGhpcy50ZW1wbGF0ZS5lKSkge1xuICBcdFx0c3RyICs9IFwiPC9cIiArIHRoaXMudGVtcGxhdGUuZSArIFwiPlwiO1xuICBcdH1cblxuICBcdHJldHVybiBzdHI7XG4gIH07XG5cbiAgZnVuY3Rpb24gb3B0aW9uSXNTZWxlY3RlZChlbGVtZW50KSB7XG4gIFx0dmFyIG9wdGlvblZhbHVlLCBzZWxlY3RWYWx1ZSwgaTtcblxuICBcdG9wdGlvblZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcblxuICBcdGlmIChvcHRpb25WYWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFlbGVtZW50LnNlbGVjdCkge1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdHNlbGVjdFZhbHVlID0gZWxlbWVudC5zZWxlY3QuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik7XG5cbiAgXHRpZiAoc2VsZWN0VmFsdWUgPT0gb3B0aW9uVmFsdWUpIHtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cblxuICBcdGlmIChlbGVtZW50LnNlbGVjdC5nZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSAmJiBpc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICBcdFx0aSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0aWYgKHNlbGVjdFZhbHVlW2ldID09IG9wdGlvblZhbHVlKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHRydWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBpbnB1dElzQ2hlY2tlZFJhZGlvKGVsZW1lbnQpIHtcbiAgXHR2YXIgYXR0cmlidXRlcywgdHlwZUF0dHJpYnV0ZSwgdmFsdWVBdHRyaWJ1dGUsIG5hbWVBdHRyaWJ1dGU7XG5cbiAgXHRhdHRyaWJ1dGVzID0gZWxlbWVudC5hdHRyaWJ1dGVzO1xuXG4gIFx0dHlwZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMudHlwZTtcbiAgXHR2YWx1ZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMudmFsdWU7XG4gIFx0bmFtZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMubmFtZTtcblxuICBcdGlmICghdHlwZUF0dHJpYnV0ZSB8fCB0eXBlQXR0cmlidXRlLnZhbHVlICE9PSBcInJhZGlvXCIgfHwgIXZhbHVlQXR0cmlidXRlIHx8ICFuYW1lQXR0cmlidXRlLmludGVycG9sYXRvcikge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdGlmICh2YWx1ZUF0dHJpYnV0ZS52YWx1ZSA9PT0gbmFtZUF0dHJpYnV0ZS5pbnRlcnBvbGF0b3IudmFsdWUpIHtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeUF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgXHR2YXIgc3RyID0gYXR0cmlidXRlLnRvU3RyaW5nKCk7XG4gIFx0cmV0dXJuIHN0ciA/IFwiIFwiICsgc3RyIDogXCJcIjtcbiAgfVxuXG4gIHZhciBFbGVtZW50X3Byb3RvdHlwZV91bmJpbmQgPSBFbGVtZW50JHVuYmluZDtcbiAgZnVuY3Rpb24gRWxlbWVudCR1bmJpbmQoKSB7XG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuYmluZGluZykge1xuICBcdFx0dGhpcy5iaW5kaW5nLnVuYmluZCgpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmV2ZW50SGFuZGxlcnMpIHtcbiAgXHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gPG9wdGlvbj5cbiAgXHRpZiAodGhpcy5uYW1lID09PSBcIm9wdGlvblwiKSB7XG4gIFx0XHRzcGVjaWFsX29wdGlvbl9fdW5iaW5kKHRoaXMpO1xuICBcdH1cblxuICBcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG4gIFx0dGhpcy5jb25kaXRpb25hbEF0dHJpYnV0ZXMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bmJpbmQpO1xuICB9XG5cbiAgdmFyIEVsZW1lbnRfcHJvdG90eXBlX3VucmVuZGVyID0gRWxlbWVudCR1bnJlbmRlcjtcblxuICBmdW5jdGlvbiBFbGVtZW50JHVucmVuZGVyKHNob3VsZERlc3Ryb3kpIHtcbiAgXHR2YXIgYmluZGluZywgYmluZGluZ3MsIHRyYW5zaXRpb247XG5cbiAgXHRpZiAodHJhbnNpdGlvbiA9IHRoaXMudHJhbnNpdGlvbikge1xuICBcdFx0dHJhbnNpdGlvbi5jb21wbGV0ZSgpO1xuICBcdH1cblxuICBcdC8vIERldGFjaCBhcyBzb29uIGFzIHdlIGNhblxuICBcdGlmICh0aGlzLm5hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgXHRcdC8vIDxvcHRpb24+IGVsZW1lbnRzIGRldGFjaCBpbW1lZGlhdGVseSwgc28gdGhhdFxuICBcdFx0Ly8gdGhlaXIgcGFyZW50IDxzZWxlY3Q+IGVsZW1lbnQgc3luY3MgY29ycmVjdGx5LCBhbmRcbiAgXHRcdC8vIHNpbmNlIG9wdGlvbiBlbGVtZW50cyBjYW4ndCBoYXZlIHRyYW5zaXRpb25zIGFueXdheVxuICBcdFx0dGhpcy5kZXRhY2goKTtcbiAgXHR9IGVsc2UgaWYgKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdGdsb2JhbF9ydW5sb29wLmRldGFjaFdoZW5SZWFkeSh0aGlzKTtcbiAgXHR9XG5cbiAgXHQvLyBDaGlsZHJlbiBmaXJzdC4gdGhhdCB3YXksIGFueSB0cmFuc2l0aW9ucyBvbiBjaGlsZCBlbGVtZW50cyB3aWxsIGJlXG4gIFx0Ly8gaGFuZGxlZCBieSB0aGUgY3VycmVudCB0cmFuc2l0aW9uTWFuYWdlclxuICBcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKGZhbHNlKTtcbiAgXHR9XG5cbiAgXHRpZiAoYmluZGluZyA9IHRoaXMuYmluZGluZykge1xuICBcdFx0dGhpcy5iaW5kaW5nLnVucmVuZGVyKCk7XG5cbiAgXHRcdHRoaXMubm9kZS5fcmFjdGl2ZS5iaW5kaW5nID0gbnVsbDtcbiAgXHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1tiaW5kaW5nLmtleXBhdGguc3RyXTtcbiAgXHRcdGJpbmRpbmdzLnNwbGljZShiaW5kaW5ncy5pbmRleE9mKGJpbmRpbmcpLCAxKTtcbiAgXHR9XG5cbiAgXHQvLyBSZW1vdmUgZXZlbnQgaGFuZGxlcnNcbiAgXHRpZiAodGhpcy5ldmVudEhhbmRsZXJzKSB7XG4gIFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaChtZXRob2RDYWxsZXJzX191bnJlbmRlcik7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZGVjb3JhdG9yKSB7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5yZWdpc3RlckRlY29yYXRvcih0aGlzLmRlY29yYXRvcik7XG4gIFx0fVxuXG4gIFx0Ly8gdHJpZ2dlciBvdXRybyB0cmFuc2l0aW9uIGlmIG5lY2Vzc2FyeVxuICBcdGlmICh0aGlzLnJvb3QudHJhbnNpdGlvbnNFbmFibGVkICYmIHRoaXMub3V0cm8pIHtcbiAgXHRcdHRyYW5zaXRpb24gPSBuZXcgX1RyYW5zaXRpb24odGhpcywgdGhpcy5vdXRybywgZmFsc2UpO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AucmVnaXN0ZXJUcmFuc2l0aW9uKHRyYW5zaXRpb24pO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIHRyYW5zaXRpb24uc3RhcnQoKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdC8vIFJlbW92ZSB0aGlzIG5vZGUgZnJvbSBhbnkgbGl2ZSBxdWVyaWVzXG4gIFx0aWYgKHRoaXMubGl2ZVF1ZXJpZXMpIHtcbiAgXHRcdHJlbW92ZUZyb21MaXZlUXVlcmllcyh0aGlzKTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5uYW1lID09PSBcImZvcm1cIikge1xuICBcdFx0Zm9ybV9fdW5yZW5kZXIodGhpcyk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRnJvbUxpdmVRdWVyaWVzKGVsZW1lbnQpIHtcbiAgXHR2YXIgcXVlcnksIHNlbGVjdG9yLCBpO1xuXG4gIFx0aSA9IGVsZW1lbnQubGl2ZVF1ZXJpZXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdHF1ZXJ5ID0gZWxlbWVudC5saXZlUXVlcmllc1tpXTtcbiAgXHRcdHNlbGVjdG9yID0gcXVlcnkuc2VsZWN0b3I7XG5cbiAgXHRcdHF1ZXJ5Ll9yZW1vdmUoZWxlbWVudC5ub2RlKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRWxlbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy5pbml0KG9wdGlvbnMpO1xuICB9O1xuXG4gIEVsZW1lbnQucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogRWxlbWVudF9wcm90b3R5cGVfYnViYmxlLFxuICBcdGRldGFjaDogRWxlbWVudF9wcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IEVsZW1lbnRfcHJvdG90eXBlX2ZpbmQsXG4gIFx0ZmluZEFsbDogRWxlbWVudF9wcm90b3R5cGVfZmluZEFsbCxcbiAgXHRmaW5kQWxsQ29tcG9uZW50czogRWxlbWVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogRWxlbWVudF9wcm90b3R5cGVfZmluZENvbXBvbmVudCxcbiAgXHRmaW5kTmV4dE5vZGU6IEVsZW1lbnRfcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSxcbiAgXHRmaXJzdE5vZGU6IEVsZW1lbnRfcHJvdG90eXBlX2ZpcnN0Tm9kZSxcbiAgXHRnZXRBdHRyaWJ1dGU6IGdldEF0dHJpYnV0ZSxcbiAgXHRpbml0OiBFbGVtZW50X3Byb3RvdHlwZV9pbml0LFxuICBcdHJlYmluZDogRWxlbWVudF9wcm90b3R5cGVfcmViaW5kLFxuICBcdHJlbmRlcjogRWxlbWVudF9wcm90b3R5cGVfcmVuZGVyLFxuICBcdHRvU3RyaW5nOiBFbGVtZW50X3Byb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IEVsZW1lbnRfcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1bnJlbmRlcjogRWxlbWVudF9wcm90b3R5cGVfdW5yZW5kZXJcbiAgfTtcblxuICB2YXIgX0VsZW1lbnQgPSBFbGVtZW50O1xuXG4gIHZhciBkZUluZGVudF9fZW1wdHkgPSAvXlxccyokLyxcbiAgICAgIGRlSW5kZW50X19sZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKi87XG5cbiAgdmFyIGRlSW5kZW50ID0gZnVuY3Rpb24gKHN0cikge1xuICBcdHZhciBsaW5lcywgZmlyc3RMaW5lLCBsYXN0TGluZSwgbWluSW5kZW50O1xuXG4gIFx0bGluZXMgPSBzdHIuc3BsaXQoXCJcXG5cIik7XG5cbiAgXHQvLyByZW1vdmUgZmlyc3QgYW5kIGxhc3QgbGluZSwgaWYgdGhleSBvbmx5IGNvbnRhaW4gd2hpdGVzcGFjZVxuICBcdGZpcnN0TGluZSA9IGxpbmVzWzBdO1xuICBcdGlmIChmaXJzdExpbmUgIT09IHVuZGVmaW5lZCAmJiBkZUluZGVudF9fZW1wdHkudGVzdChmaXJzdExpbmUpKSB7XG4gIFx0XHRsaW5lcy5zaGlmdCgpO1xuICBcdH1cblxuICBcdGxhc3RMaW5lID0gbGFzdEl0ZW0obGluZXMpO1xuICBcdGlmIChsYXN0TGluZSAhPT0gdW5kZWZpbmVkICYmIGRlSW5kZW50X19lbXB0eS50ZXN0KGxhc3RMaW5lKSkge1xuICBcdFx0bGluZXMucG9wKCk7XG4gIFx0fVxuXG4gIFx0bWluSW5kZW50ID0gbGluZXMucmVkdWNlKHJlZHVjZXIsIG51bGwpO1xuXG4gIFx0aWYgKG1pbkluZGVudCkge1xuICBcdFx0c3RyID0gbGluZXMubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gIFx0XHRcdHJldHVybiBsaW5lLnJlcGxhY2UobWluSW5kZW50LCBcIlwiKTtcbiAgXHRcdH0pLmpvaW4oXCJcXG5cIik7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0cjtcbiAgfTtcblxuICBmdW5jdGlvbiByZWR1Y2VyKHByZXZpb3VzLCBsaW5lKSB7XG4gIFx0dmFyIGxpbmVJbmRlbnQgPSBkZUluZGVudF9fbGVhZGluZ1doaXRlc3BhY2UuZXhlYyhsaW5lKVswXTtcblxuICBcdGlmIChwcmV2aW91cyA9PT0gbnVsbCB8fCBsaW5lSW5kZW50Lmxlbmd0aCA8IHByZXZpb3VzLmxlbmd0aCkge1xuICBcdFx0cmV0dXJuIGxpbmVJbmRlbnQ7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHByZXZpb3VzO1xuICB9XG5cbiAgdmFyIFBhcnRpYWxfZ2V0UGFydGlhbFRlbXBsYXRlID0gZ2V0UGFydGlhbFRlbXBsYXRlO1xuXG4gIGZ1bmN0aW9uIGdldFBhcnRpYWxUZW1wbGF0ZShyYWN0aXZlLCBuYW1lLCBwYXJlbnRGcmFnbWVudCkge1xuICBcdHZhciBwYXJ0aWFsO1xuXG4gIFx0Ly8gSWYgdGhlIHBhcnRpYWwgaW4gaW5zdGFuY2Ugb3IgdmlldyBoZWlyYXJjaHkgaW5zdGFuY2VzLCBncmVhdFxuICBcdGlmIChwYXJ0aWFsID0gZ2V0UGFydGlhbEZyb21SZWdpc3RyeShyYWN0aXZlLCBuYW1lLCBwYXJlbnRGcmFnbWVudCB8fCB7fSkpIHtcbiAgXHRcdHJldHVybiBwYXJ0aWFsO1xuICBcdH1cblxuICBcdC8vIERvZXMgaXQgZXhpc3Qgb24gdGhlIHBhZ2UgYXMgYSBzY3JpcHQgdGFnP1xuICBcdHBhcnRpYWwgPSB0ZW1wbGF0ZV9wYXJzZXIuZnJvbUlkKG5hbWUsIHsgbm9UaHJvdzogdHJ1ZSB9KTtcblxuICBcdGlmIChwYXJ0aWFsKSB7XG4gIFx0XHQvLyBpcyB0aGlzIG5lY2Vzc2FyeT9cbiAgXHRcdHBhcnRpYWwgPSBkZUluZGVudChwYXJ0aWFsKTtcblxuICBcdFx0Ly8gcGFyc2UgYW5kIHJlZ2lzdGVyIHRvIHRoaXMgcmFjdGl2ZSBpbnN0YW5jZVxuICBcdFx0dmFyIHBhcnNlZCA9IHRlbXBsYXRlX3BhcnNlci5wYXJzZShwYXJ0aWFsLCB0ZW1wbGF0ZV9wYXJzZXIuZ2V0UGFyc2VPcHRpb25zKHJhY3RpdmUpKTtcblxuICBcdFx0Ly8gcmVnaXN0ZXIgKGFuZCByZXR1cm4gbWFpbiBwYXJ0aWFsIGlmIHRoZXJlIGFyZSBvdGhlcnMgaW4gdGhlIHRlbXBsYXRlKVxuICBcdFx0cmV0dXJuIHJhY3RpdmUucGFydGlhbHNbbmFtZV0gPSBwYXJzZWQudDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXJ0aWFsRnJvbVJlZ2lzdHJ5KHJhY3RpdmUsIG5hbWUsIHBhcmVudEZyYWdtZW50KSB7XG4gIFx0dmFyIGZuID0gdW5kZWZpbmVkLFxuICBcdCAgICBwYXJ0aWFsID0gZmluZFBhcmVudFBhcnRpYWwobmFtZSwgcGFyZW50RnJhZ21lbnQub3duZXIpO1xuXG4gIFx0Ly8gaWYgdGhlcmUgd2FzIGFuIGluc3RhbmNlIHVwLWhpZXJhcmNoeSwgY29vbFxuICBcdGlmIChwYXJ0aWFsKSByZXR1cm4gcGFydGlhbDtcblxuICBcdC8vIGZpbmQgZmlyc3QgaW5zdGFuY2UgaW4gdGhlIHJhY3RpdmUgb3IgdmlldyBoaWVyYXJjaHkgdGhhdCBoYXMgdGhpcyBwYXJ0aWFsXG4gIFx0dmFyIGluc3RhbmNlID0gZmluZEluc3RhbmNlKFwicGFydGlhbHNcIiwgcmFjdGl2ZSwgbmFtZSk7XG5cbiAgXHRpZiAoIWluc3RhbmNlKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0cGFydGlhbCA9IGluc3RhbmNlLnBhcnRpYWxzW25hbWVdO1xuXG4gIFx0Ly8gcGFydGlhbCBpcyBhIGZ1bmN0aW9uP1xuICBcdGlmICh0eXBlb2YgcGFydGlhbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIFx0XHRmbiA9IHBhcnRpYWwuYmluZChpbnN0YW5jZSk7XG4gIFx0XHRmbi5pc093bmVyID0gaW5zdGFuY2UucGFydGlhbHMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIFx0XHRwYXJ0aWFsID0gZm4uY2FsbChyYWN0aXZlLCB0ZW1wbGF0ZV9wYXJzZXIpO1xuICBcdH1cblxuICBcdGlmICghcGFydGlhbCAmJiBwYXJ0aWFsICE9PSBcIlwiKSB7XG4gIFx0XHR3YXJuSWZEZWJ1Zyhub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm4sIG5hbWUsIFwicGFydGlhbFwiLCBcInBhcnRpYWxcIiwgeyByYWN0aXZlOiByYWN0aXZlIH0pO1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdC8vIElmIHRoaXMgd2FzIGFkZGVkIG1hbnVhbGx5IHRvIHRoZSByZWdpc3RyeSxcbiAgXHQvLyBidXQgaGFzbid0IGJlZW4gcGFyc2VkLCBwYXJzZSBpdCBub3dcbiAgXHRpZiAoIXRlbXBsYXRlX3BhcnNlci5pc1BhcnNlZChwYXJ0aWFsKSkge1xuXG4gIFx0XHQvLyB1c2UgdGhlIHBhcnNlT3B0aW9ucyBvZiB0aGUgcmFjdGl2ZSBpbnN0YW5jZSBvbiB3aGljaCBpdCB3YXMgZm91bmRcbiAgXHRcdHZhciBwYXJzZWQgPSB0ZW1wbGF0ZV9wYXJzZXIucGFyc2UocGFydGlhbCwgdGVtcGxhdGVfcGFyc2VyLmdldFBhcnNlT3B0aW9ucyhpbnN0YW5jZSkpO1xuXG4gIFx0XHQvLyBQYXJ0aWFscyBjYW5ub3QgY29udGFpbiBuZXN0ZWQgcGFydGlhbHMhXG4gIFx0XHQvLyBUT0RPIGFkZCBhIHRlc3QgZm9yIHRoaXNcbiAgXHRcdGlmIChwYXJzZWQucCkge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyhcIlBhcnRpYWxzICh7ez4lc319KSBjYW5ub3QgY29udGFpbiBuZXN0ZWQgaW5saW5lIHBhcnRpYWxzXCIsIG5hbWUsIHsgcmFjdGl2ZTogcmFjdGl2ZSB9KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gaWYgZm4sIHVzZSBpbnN0YW5jZSB0byBzdG9yZSByZXN1bHQsIG90aGVyd2lzZSBuZWVkcyB0byBnb1xuICBcdFx0Ly8gaW4gdGhlIGNvcnJlY3QgcG9pbnQgaW4gcHJvdG90eXBlIGNoYWluIG9uIGluc3RhbmNlIG9yIGNvbnN0cnVjdG9yXG4gIFx0XHR2YXIgdGFyZ2V0ID0gZm4gPyBpbnN0YW5jZSA6IGZpbmRPd25lcihpbnN0YW5jZSwgbmFtZSk7XG5cbiAgXHRcdC8vIG1heSBiZSBhIHRlbXBsYXRlIHdpdGggcGFydGlhbHMsIHdoaWNoIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCBhbmQgbWFpbiB0ZW1wbGF0ZSBleHRyYWN0ZWRcbiAgXHRcdHRhcmdldC5wYXJ0aWFsc1tuYW1lXSA9IHBhcnRpYWwgPSBwYXJzZWQudDtcbiAgXHR9XG5cbiAgXHQvLyBzdG9yZSBmb3IgcmVzZXRcbiAgXHRpZiAoZm4pIHtcbiAgXHRcdHBhcnRpYWwuX2ZuID0gZm47XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHBhcnRpYWwudiA/IHBhcnRpYWwudCA6IHBhcnRpYWw7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kT3duZXIocmFjdGl2ZSwga2V5KSB7XG4gIFx0cmV0dXJuIHJhY3RpdmUucGFydGlhbHMuaGFzT3duUHJvcGVydHkoa2V5KSA/IHJhY3RpdmUgOiBmaW5kQ29uc3RydWN0b3IocmFjdGl2ZS5jb25zdHJ1Y3Rvciwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRDb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvciwga2V5KSB7XG4gIFx0aWYgKCFjb25zdHJ1Y3Rvcikge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cbiAgXHRyZXR1cm4gY29uc3RydWN0b3IucGFydGlhbHMuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNvbnN0cnVjdG9yIDogZmluZENvbnN0cnVjdG9yKGNvbnN0cnVjdG9yLl9QYXJlbnQsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kUGFyZW50UGFydGlhbChuYW1lLCBwYXJlbnQpIHtcbiAgXHRpZiAocGFyZW50KSB7XG4gIFx0XHRpZiAocGFyZW50LnRlbXBsYXRlICYmIHBhcmVudC50ZW1wbGF0ZS5wICYmIHBhcmVudC50ZW1wbGF0ZS5wW25hbWVdKSB7XG4gIFx0XHRcdHJldHVybiBwYXJlbnQudGVtcGxhdGUucFtuYW1lXTtcbiAgXHRcdH0gZWxzZSBpZiAocGFyZW50LnBhcmVudEZyYWdtZW50ICYmIHBhcmVudC5wYXJlbnRGcmFnbWVudC5vd25lcikge1xuICBcdFx0XHRyZXR1cm4gZmluZFBhcmVudFBhcnRpYWwobmFtZSwgcGFyZW50LnBhcmVudEZyYWdtZW50Lm93bmVyKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgYXBwbHlJbmRlbnQgPSBmdW5jdGlvbiAoc3RyaW5nLCBpbmRlbnQpIHtcbiAgXHR2YXIgaW5kZW50ZWQ7XG5cbiAgXHRpZiAoIWluZGVudCkge1xuICBcdFx0cmV0dXJuIHN0cmluZztcbiAgXHR9XG5cbiAgXHRpbmRlbnRlZCA9IHN0cmluZy5zcGxpdChcIlxcblwiKS5tYXAoZnVuY3Rpb24gKGxpbmUsIG5vdEZpcnN0TGluZSkge1xuICBcdFx0cmV0dXJuIG5vdEZpcnN0TGluZSA/IGluZGVudCArIGxpbmUgOiBsaW5lO1xuICBcdH0pLmpvaW4oXCJcXG5cIik7XG5cbiAgXHRyZXR1cm4gaW5kZW50ZWQ7XG4gIH07XG5cbiAgdmFyIG1pc3NpbmdQYXJ0aWFsTWVzc2FnZSA9IFwiQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZm9yIHBhcnRpYWwgXFxcIiVzXFxcIlwiO1xuXG4gIHZhciBQYXJ0aWFsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR2YXIgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlO1xuXG4gIFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblxuICBcdHRoaXMucm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG4gIFx0dGhpcy50eXBlID0gUEFSVElBTDtcbiAgXHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgXHR0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLnI7XG4gIFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuXG4gIFx0dGhpcy5mcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRUb1JlbmRlciA9IHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyID0gbnVsbDtcblxuICBcdE11c3RhY2hlLmluaXQodGhpcywgb3B0aW9ucyk7XG5cbiAgXHQvLyBJZiB0aGlzIGRpZG4ndCByZXNvbHZlLCBpdCBtb3N0IGxpa2VseSBtZWFucyB3ZSBoYXZlIGEgbmFtZWQgcGFydGlhbFxuICBcdC8vIChpLmUuIGB7ez5mb299fWAgbWVhbnMgJ3VzZSB0aGUgZm9vIHBhcnRpYWwnLCBub3QgJ3VzZSB0aGUgcGFydGlhbFxuICBcdC8vIHdob3NlIG5hbWUgaXMgdGhlIHZhbHVlIG9mIGBmb29gJylcbiAgXHRpZiAoIXRoaXMua2V5cGF0aCkge1xuICBcdFx0aWYgKHRlbXBsYXRlID0gUGFydGlhbF9nZXRQYXJ0aWFsVGVtcGxhdGUodGhpcy5yb290LCB0aGlzLm5hbWUsIHBhcmVudEZyYWdtZW50KSkge1xuICBcdFx0XHRzaGFyZWRfdW5iaW5kLmNhbGwodGhpcyk7IC8vIHByZXZlbnQgYW55IGZ1cnRoZXIgY2hhbmdlc1xuICBcdFx0XHR0aGlzLmlzTmFtZWQgPSB0cnVlO1xuICBcdFx0XHR0aGlzLnNldFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyhtaXNzaW5nUGFydGlhbE1lc3NhZ2UsIHRoaXMubmFtZSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIFBhcnRpYWwucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcbiAgXHR9LFxuXG4gIFx0ZGV0YWNoOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcbiAgXHR9LFxuXG4gIFx0ZmluZDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKHNlbGVjdG9yKTtcbiAgXHR9LFxuXG4gIFx0ZmluZEFsbDogZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbChzZWxlY3RvciwgcXVlcnkpO1xuICBcdH0sXG5cbiAgXHRmaW5kQ29tcG9uZW50OiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoc2VsZWN0b3IpO1xuICBcdH0sXG5cbiAgXHRmaW5kQWxsQ29tcG9uZW50czogZnVuY3Rpb24gKHNlbGVjdG9yLCBxdWVyeSkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9LFxuXG4gIFx0Zmlyc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maXJzdE5vZGUoKTtcbiAgXHR9LFxuXG4gIFx0ZmluZE5leHROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUodGhpcyk7XG4gIFx0fSxcblxuICBcdGdldFBhcnRpYWxOYW1lOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAodGhpcy5pc05hbWVkICYmIHRoaXMubmFtZSkgcmV0dXJuIHRoaXMubmFtZTtlbHNlIGlmICh0aGlzLnZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLm5hbWU7ZWxzZSByZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG4gIFx0fSxcblxuICBcdHJlYmluZDogZnVuY3Rpb24gKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHRcdC8vIG5hbWVkIHBhcnRpYWxzIGFyZW4ndCBib3VuZCwgc28gZG9uJ3QgcmViaW5kXG4gIFx0XHRpZiAoIXRoaXMuaXNOYW1lZCkge1xuICBcdFx0XHRNdXN0YWNoZV9yZWJpbmQuY2FsbCh0aGlzLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBcdFx0dGhpcy51cGRhdGUoKTtcblxuICBcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0XHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuICBcdH0sXG5cbiAgXHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuXG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0dmFyIHRlbXBsYXRlO1xuXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA9PT0gdGhpcy52YWx1ZSkge1xuICBcdFx0XHQvLyBub3RoaW5nIGhhcyBjaGFuZ2VkLCBzbyBubyB3b3JrIHRvIGJlIGRvbmVcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICBcdFx0XHR0ZW1wbGF0ZSA9IFBhcnRpYWxfZ2V0UGFydGlhbFRlbXBsYXRlKHRoaXMucm9vdCwgXCJcIiArIHZhbHVlLCB0aGlzLnBhcmVudEZyYWdtZW50KTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gd2UgbWF5IGJlIGhlcmUgaWYgd2UgaGF2ZSBhIHBhcnRpYWwgbGlrZSBge3s+Zm9vfX1gIGFuZCBgZm9vYCBpcyB0aGVcbiAgXHRcdC8vIG5hbWUgb2YgYm90aCBhIGRhdGEgcHJvcGVydHkgKHdob3NlIHZhbHVlIElTTidUIHRoZSBuYW1lIG9mIGEgcGFydGlhbClcbiAgXHRcdC8vIGFuZCBhIHBhcnRpYWwuIEluIHRob3NlIGNhc2VzLCB0aGlzIGJlY29tZXMgYSBuYW1lZCBwYXJ0aWFsXG4gIFx0XHRpZiAoIXRlbXBsYXRlICYmIHRoaXMubmFtZSAmJiAodGVtcGxhdGUgPSBQYXJ0aWFsX2dldFBhcnRpYWxUZW1wbGF0ZSh0aGlzLnJvb3QsIHRoaXMubmFtZSwgdGhpcy5wYXJlbnRGcmFnbWVudCkpKSB7XG4gIFx0XHRcdHNoYXJlZF91bmJpbmQuY2FsbCh0aGlzKTtcbiAgXHRcdFx0dGhpcy5pc05hbWVkID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCF0ZW1wbGF0ZSkge1xuICBcdFx0XHR3YXJuT25jZUlmRGVidWcobWlzc2luZ1BhcnRpYWxNZXNzYWdlLCB0aGlzLm5hbWUsIHsgcmFjdGl2ZTogdGhpcy5yb290IH0pO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdHRoaXMuc2V0VGVtcGxhdGUodGVtcGxhdGUgfHwgW10pO1xuXG4gIFx0XHR0aGlzLmJ1YmJsZSgpO1xuXG4gIFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRzZXRUZW1wbGF0ZTogZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdFx0XHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0XHRcdHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyID0gdGhpcy5mcmFnbWVudDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gIFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcbiAgXHRcdFx0b3duZXI6IHRoaXMsXG4gIFx0XHRcdHBFbGVtZW50OiB0aGlzLnBhcmVudEZyYWdtZW50LnBFbGVtZW50XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5mcmFnbWVudFRvUmVuZGVyID0gdGhpcy5mcmFnbWVudDtcbiAgXHR9LFxuXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICh0b1N0cmluZykge1xuICBcdFx0dmFyIHN0cmluZywgcHJldmlvdXNJdGVtLCBsYXN0TGluZSwgbWF0Y2g7XG5cbiAgXHRcdHN0cmluZyA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcodG9TdHJpbmcpO1xuXG4gIFx0XHRwcmV2aW91c0l0ZW0gPSB0aGlzLnBhcmVudEZyYWdtZW50Lml0ZW1zW3RoaXMuaW5kZXggLSAxXTtcblxuICBcdFx0aWYgKCFwcmV2aW91c0l0ZW0gfHwgcHJldmlvdXNJdGVtLnR5cGUgIT09IFRFWFQpIHtcbiAgXHRcdFx0cmV0dXJuIHN0cmluZztcbiAgXHRcdH1cblxuICBcdFx0bGFzdExpbmUgPSBwcmV2aW91c0l0ZW0udGV4dC5zcGxpdChcIlxcblwiKS5wb3AoKTtcblxuICBcdFx0aWYgKG1hdGNoID0gL15cXHMrJC8uZXhlYyhsYXN0TGluZSkpIHtcbiAgXHRcdFx0cmV0dXJuIGFwcGx5SW5kZW50KHN0cmluZywgbWF0Y2hbMF0pO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gc3RyaW5nO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5pc05hbWVkKSB7XG4gIFx0XHRcdC8vIGR5bmFtaWMgcGFydGlhbCAtIG5lZWQgdG8gdW5iaW5kIHNlbGZcbiAgXHRcdFx0c2hhcmVkX3VuYmluZC5jYWxsKHRoaXMpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudCkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1bnJlbmRlcjogZnVuY3Rpb24gKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRcdGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gIFx0XHRcdGlmICh0aGlzLmZyYWdtZW50KSB7XG4gIFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlcihzaG91bGREZXN0cm95KTtcbiAgXHRcdFx0fVxuICBcdFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHRhcmdldCwgYW5jaG9yO1xuXG4gIFx0XHRpZiAodGhpcy5mcmFnbWVudFRvVW5yZW5kZXIpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudFRvVW5yZW5kZXIudW5yZW5kZXIodHJ1ZSk7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnRUb1VucmVuZGVyID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnRUb1JlbmRlcikge1xuICBcdFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQodGhpcy5mcmFnbWVudFRvUmVuZGVyLnJlbmRlcigpKTtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudFRvUmVuZGVyID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdFx0dGFyZ2V0ID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG4gIFx0XHRcdGFuY2hvciA9IHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICBcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuZG9jRnJhZywgYW5jaG9yKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgdmFyIF9QYXJ0aWFsID0gUGFydGlhbDtcblxuICAvLyBmaW5kcyB0aGUgY29tcG9uZW50IGNvbnN0cnVjdG9yIGluIHRoZSByZWdpc3RyeSBvciB2aWV3IGhpZXJhcmNoeSByZWdpc3RyaWVzXG5cbiAgdmFyIENvbXBvbmVudF9nZXRDb21wb25lbnQgPSBnZXRDb21wb25lbnQ7XG4gIGZ1bmN0aW9uIGdldENvbXBvbmVudChyYWN0aXZlLCBuYW1lKSB7XG5cbiAgXHR2YXIgQ29tcG9uZW50LFxuICBcdCAgICBpbnN0YW5jZSA9IGZpbmRJbnN0YW5jZShcImNvbXBvbmVudHNcIiwgcmFjdGl2ZSwgbmFtZSk7XG5cbiAgXHRpZiAoaW5zdGFuY2UpIHtcbiAgXHRcdENvbXBvbmVudCA9IGluc3RhbmNlLmNvbXBvbmVudHNbbmFtZV07XG5cbiAgXHRcdC8vIGJlc3QgdGVzdCB3ZSBoYXZlIGZvciBub3QgUmFjdGl2ZS5leHRlbmRcbiAgXHRcdGlmICghQ29tcG9uZW50Ll9QYXJlbnQpIHtcbiAgXHRcdFx0Ly8gZnVuY3Rpb24gb3B0aW9uLCBleGVjdXRlIGFuZCBzdG9yZSBmb3IgcmVzZXRcbiAgXHRcdFx0dmFyIGZuID0gQ29tcG9uZW50LmJpbmQoaW5zdGFuY2UpO1xuICBcdFx0XHRmbi5pc093bmVyID0gaW5zdGFuY2UuY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgXHRcdFx0Q29tcG9uZW50ID0gZm4oKTtcblxuICBcdFx0XHRpZiAoIUNvbXBvbmVudCkge1xuICBcdFx0XHRcdHdhcm5JZkRlYnVnKG5vUmVnaXN0cnlGdW5jdGlvblJldHVybiwgbmFtZSwgXCJjb21wb25lbnRcIiwgXCJjb21wb25lbnRcIiwgeyByYWN0aXZlOiByYWN0aXZlIH0pO1xuXG4gIFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiBDb21wb25lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHQvLyBhbGxvdyBzdHJpbmcgbG9va3VwXG4gIFx0XHRcdFx0Q29tcG9uZW50ID0gZ2V0Q29tcG9uZW50KHJhY3RpdmUsIENvbXBvbmVudCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRDb21wb25lbnQuX2ZuID0gZm47XG4gIFx0XHRcdGluc3RhbmNlLmNvbXBvbmVudHNbbmFtZV0gPSBDb21wb25lbnQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIENvbXBvbmVudDtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2RldGFjaCA9IENvbXBvbmVudCRkZXRhY2g7XG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2RldGFjaF9fZGV0YWNoSG9vayA9IG5ldyBob29rc19Ib29rKFwiZGV0YWNoXCIpO1xuICBmdW5jdGlvbiBDb21wb25lbnQkZGV0YWNoKCkge1xuICBcdHZhciBkZXRhY2hlZCA9IHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIFx0Q29tcG9uZW50X3Byb3RvdHlwZV9kZXRhY2hfX2RldGFjaEhvb2suZmlyZSh0aGlzLmluc3RhbmNlKTtcbiAgXHRyZXR1cm4gZGV0YWNoZWQ7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kID0gQ29tcG9uZW50JGZpbmQ7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JGZpbmQoc2VsZWN0b3IpIHtcbiAgXHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kKHNlbGVjdG9yKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRBbGwgPSBDb21wb25lbnQkZmluZEFsbDtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZEFsbChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQWxsKHNlbGVjdG9yLCBxdWVyeSk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyA9IENvbXBvbmVudCRmaW5kQWxsQ29tcG9uZW50cztcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZEFsbENvbXBvbmVudHMoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gIFx0cXVlcnkuX3Rlc3QodGhpcywgdHJ1ZSk7XG5cbiAgXHRpZiAodGhpcy5pbnN0YW5jZS5mcmFnbWVudCkge1xuICBcdFx0dGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyhzZWxlY3RvciwgcXVlcnkpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQgPSBDb21wb25lbnQkZmluZENvbXBvbmVudDtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZENvbXBvbmVudChzZWxlY3Rvcikge1xuICBcdGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IHRoaXMubmFtZSkge1xuICBcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQpIHtcbiAgXHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmRDb21wb25lbnQoc2VsZWN0b3IpO1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfZmluZE5leHROb2RlID0gQ29tcG9uZW50JGZpbmROZXh0Tm9kZTtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkZmluZE5leHROb2RlKCkge1xuICBcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSh0aGlzKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2ZpcnN0Tm9kZSA9IENvbXBvbmVudCRmaXJzdE5vZGU7XG5cbiAgZnVuY3Rpb24gQ29tcG9uZW50JGZpcnN0Tm9kZSgpIHtcbiAgXHRpZiAodGhpcy5yZW5kZXJlZCkge1xuICBcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcHJvY2Vzc1dyYXBwZXIgPSBmdW5jdGlvbiAod3JhcHBlciwgYXJyYXksIG1ldGhvZE5hbWUsIG5ld0luZGljZXMpIHtcbiAgXHR2YXIgcm9vdCA9IHdyYXBwZXIucm9vdDtcbiAgXHR2YXIga2V5cGF0aCA9IHdyYXBwZXIua2V5cGF0aDtcblxuICBcdGlmICghIW5ld0luZGljZXMpIHtcbiAgXHRcdHJvb3Qudmlld21vZGVsLnNtYXJ0VXBkYXRlKGtleXBhdGgsIGFycmF5LCBuZXdJbmRpY2VzKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gSWYgdGhpcyBpcyBhIHNvcnQgb3IgcmV2ZXJzZSwgd2UganVzdCBkbyByb290LnNldCgpLi4uXG4gIFx0XHQvLyBUT0RPIHVzZSBtZXJnZSBsb2dpYz9cbiAgXHRcdHJvb3Qudmlld21vZGVsLm1hcmsoa2V5cGF0aCk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBwYXRjaGVkQXJyYXlQcm90byA9IFtdLFxuICAgICAgbXV0YXRvck1ldGhvZHMgPSBbXCJwb3BcIiwgXCJwdXNoXCIsIFwicmV2ZXJzZVwiLCBcInNoaWZ0XCIsIFwic29ydFwiLCBcInNwbGljZVwiLCBcInVuc2hpZnRcIl0sXG4gICAgICB0ZXN0T2JqLFxuICAgICAgcGF0Y2hBcnJheU1ldGhvZHMsXG4gICAgICB1bnBhdGNoQXJyYXlNZXRob2RzO1xuXG4gIG11dGF0b3JNZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgXHR2YXIgbWV0aG9kID0gZnVuY3Rpb24gKCkge1xuICBcdFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgXHRcdFx0YXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIG5ld0luZGljZXMsIHJlc3VsdCwgd3JhcHBlciwgaTtcblxuICBcdFx0bmV3SW5kaWNlcyA9IHNoYXJlZF9nZXROZXdJbmRpY2VzKHRoaXMsIG1ldGhvZE5hbWUsIGFyZ3MpO1xuXG4gIFx0XHQvLyBhcHBseSB0aGUgdW5kZXJseWluZyBtZXRob2RcbiAgXHRcdHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZVttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIFx0XHQvLyB0cmlnZ2VyIGNoYW5nZXNcbiAgXHRcdGdsb2JhbF9ydW5sb29wLnN0YXJ0KCk7XG5cbiAgXHRcdHRoaXMuX3JhY3RpdmUuc2V0dGluZyA9IHRydWU7XG4gIFx0XHRpID0gdGhpcy5fcmFjdGl2ZS53cmFwcGVycy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdHdyYXBwZXIgPSB0aGlzLl9yYWN0aXZlLndyYXBwZXJzW2ldO1xuXG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFJhY3RpdmUod3JhcHBlci5yb290KTtcbiAgXHRcdFx0cHJvY2Vzc1dyYXBwZXIod3JhcHBlciwgdGhpcywgbWV0aG9kTmFtZSwgbmV3SW5kaWNlcyk7XG4gIFx0XHR9XG5cbiAgXHRcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0XHR0aGlzLl9yYWN0aXZlLnNldHRpbmcgPSBmYWxzZTtcbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fTtcblxuICBcdGRlZmluZVByb3BlcnR5KHBhdGNoZWRBcnJheVByb3RvLCBtZXRob2ROYW1lLCB7XG4gIFx0XHR2YWx1ZTogbWV0aG9kXG4gIFx0fSk7XG4gIH0pO1xuXG4gIC8vIGNhbiB3ZSB1c2UgcHJvdG90eXBlIGNoYWluIGluamVjdGlvbj9cbiAgLy8gaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vaG93LWVjbWFzY3JpcHQtNS1zdGlsbC1kb2VzLW5vdC1hbGxvdy10by1zdWJjbGFzcy1hbi1hcnJheS8jd3JhcHBlcnNfcHJvdG90eXBlX2NoYWluX2luamVjdGlvblxuICB0ZXN0T2JqID0ge307XG5cbiAgaWYgKHRlc3RPYmouX19wcm90b19fKSB7XG4gIFx0Ly8geWVzLCB3ZSBjYW5cbiAgXHRwYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uIChhcnJheSkge1xuICBcdFx0YXJyYXkuX19wcm90b19fID0gcGF0Y2hlZEFycmF5UHJvdG87XG4gIFx0fTtcblxuICBcdHVucGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgXHRcdGFycmF5Ll9fcHJvdG9fXyA9IEFycmF5LnByb3RvdHlwZTtcbiAgXHR9O1xuICB9IGVsc2Uge1xuICBcdC8vIG5vLCB3ZSBjYW4ndFxuICBcdHBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIFx0XHR2YXIgaSwgbWV0aG9kTmFtZTtcblxuICBcdFx0aSA9IG11dGF0b3JNZXRob2RzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0bWV0aG9kTmFtZSA9IG11dGF0b3JNZXRob2RzW2ldO1xuICBcdFx0XHRkZWZpbmVQcm9wZXJ0eShhcnJheSwgbWV0aG9kTmFtZSwge1xuICBcdFx0XHRcdHZhbHVlOiBwYXRjaGVkQXJyYXlQcm90b1ttZXRob2ROYW1lXSxcbiAgXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHVucGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgXHRcdHZhciBpO1xuXG4gIFx0XHRpID0gbXV0YXRvck1ldGhvZHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRkZWxldGUgYXJyYXlbbXV0YXRvck1ldGhvZHNbaV1dO1xuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICBwYXRjaEFycmF5TWV0aG9kcy51bnBhdGNoID0gdW5wYXRjaEFycmF5TWV0aG9kcztcbiAgdmFyIHBhdGNoID0gcGF0Y2hBcnJheU1ldGhvZHM7XG5cbiAgdmFyIGFycmF5QWRhcHRvcixcblxuICAvLyBoZWxwZXJzXG4gIEFycmF5V3JhcHBlciwgYXJyYXlfaW5kZXhfX2Vycm9yTWVzc2FnZTtcblxuICBhcnJheUFkYXB0b3IgPSB7XG4gIFx0ZmlsdGVyOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIFx0XHQvLyB3cmFwIHRoZSBhcnJheSBpZiBhKSBiKSBpdCdzIGFuIGFycmF5LCBhbmQgYikgZWl0aGVyIGl0IGhhc24ndCBiZWVuIHdyYXBwZWQgYWxyZWFkeSxcbiAgXHRcdC8vIG9yIHRoZSBhcnJheSBkaWRuJ3QgdHJpZ2dlciB0aGUgZ2V0KCkgaXRzZWxmXG4gIFx0XHRyZXR1cm4gaXNBcnJheShvYmplY3QpICYmICghb2JqZWN0Ll9yYWN0aXZlIHx8ICFvYmplY3QuX3JhY3RpdmUuc2V0dGluZyk7XG4gIFx0fSxcbiAgXHR3cmFwOiBmdW5jdGlvbiAocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpIHtcbiAgXHRcdHJldHVybiBuZXcgQXJyYXlXcmFwcGVyKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKTtcbiAgXHR9XG4gIH07XG5cbiAgQXJyYXlXcmFwcGVyID0gZnVuY3Rpb24gKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKSB7XG4gIFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcbiAgXHR0aGlzLnZhbHVlID0gYXJyYXk7XG4gIFx0dGhpcy5rZXlwYXRoID0gZ2V0S2V5cGF0aChrZXlwYXRoKTtcblxuICBcdC8vIGlmIHRoaXMgYXJyYXkgaGFzbid0IGFscmVhZHkgYmVlbiByYWN0aWZpZWQsIHJhY3RpZnkgaXRcbiAgXHRpZiAoIWFycmF5Ll9yYWN0aXZlKSB7XG5cbiAgXHRcdC8vIGRlZmluZSBhIG5vbi1lbnVtZXJhYmxlIF9yYWN0aXZlIHByb3BlcnR5IHRvIHN0b3JlIHRoZSB3cmFwcGVyc1xuICBcdFx0ZGVmaW5lUHJvcGVydHkoYXJyYXksIFwiX3JhY3RpdmVcIiwge1xuICBcdFx0XHR2YWx1ZToge1xuICBcdFx0XHRcdHdyYXBwZXJzOiBbXSxcbiAgXHRcdFx0XHRpbnN0YW5jZXM6IFtdLFxuICBcdFx0XHRcdHNldHRpbmc6IGZhbHNlXG4gIFx0XHRcdH0sXG4gIFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICBcdFx0fSk7XG5cbiAgXHRcdHBhdGNoKGFycmF5KTtcbiAgXHR9XG5cbiAgXHQvLyBzdG9yZSB0aGUgcmFjdGl2ZSBpbnN0YW5jZSwgc28gd2UgY2FuIGhhbmRsZSB0cmFuc2l0aW9ucyBsYXRlclxuICBcdGlmICghYXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzW3JhY3RpdmUuX2d1aWRdKSB7XG4gIFx0XHRhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXNbcmFjdGl2ZS5fZ3VpZF0gPSAwO1xuICBcdFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzLnB1c2gocmFjdGl2ZSk7XG4gIFx0fVxuXG4gIFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzW3JhY3RpdmUuX2d1aWRdICs9IDE7XG4gIFx0YXJyYXkuX3JhY3RpdmUud3JhcHBlcnMucHVzaCh0aGlzKTtcbiAgfTtcblxuICBBcnJheVdyYXBwZXIucHJvdG90eXBlID0ge1xuICBcdGdldDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0fSxcbiAgXHR0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGFycmF5LCBzdG9yYWdlLCB3cmFwcGVycywgaW5zdGFuY2VzLCBpbmRleDtcblxuICBcdFx0YXJyYXkgPSB0aGlzLnZhbHVlO1xuICBcdFx0c3RvcmFnZSA9IGFycmF5Ll9yYWN0aXZlO1xuICBcdFx0d3JhcHBlcnMgPSBzdG9yYWdlLndyYXBwZXJzO1xuICBcdFx0aW5zdGFuY2VzID0gc3RvcmFnZS5pbnN0YW5jZXM7XG5cbiAgXHRcdC8vIGlmIHRlYXJkb3duKCkgd2FzIGludm9rZWQgYmVjYXVzZSB3ZSdyZSBjbGVhcmluZyB0aGUgY2FjaGUgYXMgYSByZXN1bHQgb2ZcbiAgXHRcdC8vIGEgY2hhbmdlIHRoYXQgdGhlIGFycmF5IGl0c2VsZiB0cmlnZ2VyZWQsIHdlIGNhbiBzYXZlIG91cnNlbHZlcyB0aGUgdGVhcmRvd25cbiAgXHRcdC8vIGFuZCBpbW1lZGlhdGUgc2V0dXBcbiAgXHRcdGlmIChzdG9yYWdlLnNldHRpbmcpIHtcbiAgXHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBzbyB0aGF0IHdlIGRvbid0IHJlbW92ZSBpdCBmcm9tIHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFxuICBcdFx0fVxuXG4gIFx0XHRpbmRleCA9IHdyYXBwZXJzLmluZGV4T2YodGhpcyk7XG4gIFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihhcnJheV9pbmRleF9fZXJyb3JNZXNzYWdlKTtcbiAgXHRcdH1cblxuICBcdFx0d3JhcHBlcnMuc3BsaWNlKGluZGV4LCAxKTtcblxuICBcdFx0Ly8gaWYgbm90aGluZyBlbHNlIGRlcGVuZHMgb24gdGhpcyBhcnJheSwgd2UgY2FuIHJldmVydCBpdCB0byBpdHNcbiAgXHRcdC8vIG5hdHVyYWwgc3RhdGVcbiAgXHRcdGlmICghd3JhcHBlcnMubGVuZ3RoKSB7XG4gIFx0XHRcdGRlbGV0ZSBhcnJheS5fcmFjdGl2ZTtcbiAgXHRcdFx0cGF0Y2gudW5wYXRjaCh0aGlzLnZhbHVlKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdC8vIHJlbW92ZSByYWN0aXZlIGluc3RhbmNlIGlmIHBvc3NpYmxlXG4gIFx0XHRcdGluc3RhbmNlc1t0aGlzLnJvb3QuX2d1aWRdIC09IDE7XG4gIFx0XHRcdGlmICghaW5zdGFuY2VzW3RoaXMucm9vdC5fZ3VpZF0pIHtcbiAgXHRcdFx0XHRpbmRleCA9IGluc3RhbmNlcy5pbmRleE9mKHRoaXMucm9vdCk7XG5cbiAgXHRcdFx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYXJyYXlfaW5kZXhfX2Vycm9yTWVzc2FnZSk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgYXJyYXlfaW5kZXhfX2Vycm9yTWVzc2FnZSA9IFwiU29tZXRoaW5nIHdlbnQgd3JvbmcgaW4gYSByYXRoZXIgaW50ZXJlc3Rpbmcgd2F5XCI7XG4gIHZhciBhcnJheV9pbmRleCA9IGFycmF5QWRhcHRvcjtcblxuICB2YXIgbnVtZXJpYyA9IC9eXFxzKlswLTldK1xccyokLztcblxuICB2YXIgY3JlYXRlQnJhbmNoID0gZnVuY3Rpb24gKGtleSkge1xuICBcdHJldHVybiBudW1lcmljLnRlc3Qoa2V5KSA/IFtdIDoge307XG4gIH07XG5cbiAgdmFyIG1hZ2ljQWRhcHRvciwgTWFnaWNXcmFwcGVyO1xuXG4gIHRyeSB7XG4gIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInRlc3RcIiwgeyB2YWx1ZTogMCB9KTtcblxuICBcdG1hZ2ljQWRhcHRvciA9IHtcbiAgXHRcdGZpbHRlcjogZnVuY3Rpb24gKG9iamVjdCwga2V5cGF0aCwgcmFjdGl2ZSkge1xuICBcdFx0XHR2YXIgcGFyZW50V3JhcHBlciwgcGFyZW50VmFsdWU7XG5cbiAgXHRcdFx0aWYgKCFrZXlwYXRoKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0a2V5cGF0aCA9IGdldEtleXBhdGgoa2V5cGF0aCk7XG5cbiAgXHRcdFx0Ly8gSWYgdGhlIHBhcmVudCB2YWx1ZSBpcyBhIHdyYXBwZXIsIG90aGVyIHRoYW4gYSBtYWdpYyB3cmFwcGVyLFxuICBcdFx0XHQvLyB3ZSBzaG91bGRuJ3Qgd3JhcCB0aGlzIHByb3BlcnR5XG4gIFx0XHRcdGlmICgocGFyZW50V3JhcHBlciA9IHJhY3RpdmUudmlld21vZGVsLndyYXBwZWRba2V5cGF0aC5wYXJlbnQuc3RyXSkgJiYgIXBhcmVudFdyYXBwZXIubWFnaWMpIHtcbiAgXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwYXJlbnRWYWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLmdldChrZXlwYXRoLnBhcmVudCk7XG5cbiAgXHRcdFx0Ly8gaWYgcGFyZW50VmFsdWUgaXMgYW4gYXJyYXkgdGhhdCBkb2Vzbid0IGluY2x1ZGUgdGhpcyBtZW1iZXIsXG4gIFx0XHRcdC8vIHdlIHNob3VsZCByZXR1cm4gZmFsc2Ugb3RoZXJ3aXNlIGxlbmd0aHMgd2lsbCBnZXQgbWVzc2VkIHVwXG4gIFx0XHRcdGlmIChpc0FycmF5KHBhcmVudFZhbHVlKSAmJiAvXlswLTldKyQvLnRlc3Qoa2V5cGF0aC5sYXN0S2V5KSkge1xuICBcdFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBwYXJlbnRWYWx1ZSAmJiAodHlwZW9mIHBhcmVudFZhbHVlID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgXHRcdH0sXG4gIFx0XHR3cmFwOiBmdW5jdGlvbiAocmFjdGl2ZSwgcHJvcGVydHksIGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIG5ldyBNYWdpY1dyYXBwZXIocmFjdGl2ZSwgcHJvcGVydHksIGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRNYWdpY1dyYXBwZXIgPSBmdW5jdGlvbiAocmFjdGl2ZSwgdmFsdWUsIGtleXBhdGgpIHtcbiAgXHRcdHZhciBvYmpLZXlwYXRoLCB0ZW1wbGF0ZSwgc2libGluZ3M7XG5cbiAgXHRcdGtleXBhdGggPSBnZXRLZXlwYXRoKGtleXBhdGgpO1xuXG4gIFx0XHR0aGlzLm1hZ2ljID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5yYWN0aXZlID0gcmFjdGl2ZTtcbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdHRoaXMucHJvcCA9IGtleXBhdGgubGFzdEtleTtcblxuICBcdFx0b2JqS2V5cGF0aCA9IGtleXBhdGgucGFyZW50O1xuICBcdFx0dGhpcy5vYmogPSBvYmpLZXlwYXRoLmlzUm9vdCA/IHJhY3RpdmUudmlld21vZGVsLmRhdGEgOiByYWN0aXZlLnZpZXdtb2RlbC5nZXQob2JqS2V5cGF0aCk7XG5cbiAgXHRcdHRlbXBsYXRlID0gdGhpcy5vcmlnaW5hbERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMub2JqLCB0aGlzLnByb3ApO1xuXG4gIFx0XHQvLyBIYXMgdGhpcyBwcm9wZXJ0eSBhbHJlYWR5IGJlZW4gd3JhcHBlZD9cbiAgXHRcdGlmICh0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5zZXQgJiYgKHNpYmxpbmdzID0gdGVtcGxhdGUuc2V0Ll9yYWN0aXZlV3JhcHBlcnMpKSB7XG5cbiAgXHRcdFx0Ly8gWWVzLiBSZWdpc3RlciB0aGlzIHdyYXBwZXIgdG8gdGhpcyBwcm9wZXJ0eSwgaWYgaXQgaGFzbid0IGJlZW4gYWxyZWFkeVxuICBcdFx0XHRpZiAoc2libGluZ3MuaW5kZXhPZih0aGlzKSA9PT0gLTEpIHtcbiAgXHRcdFx0XHRzaWJsaW5ncy5wdXNoKHRoaXMpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuOyAvLyBhbHJlYWR5IHdyYXBwZWRcbiAgXHRcdH1cblxuICBcdFx0Ly8gTm8sIGl0IGhhc24ndCBiZWVuIHdyYXBwZWRcbiAgXHRcdGNyZWF0ZUFjY2Vzc29ycyh0aGlzLCB2YWx1ZSwgdGVtcGxhdGUpO1xuICBcdH07XG5cbiAgXHRNYWdpY1dyYXBwZXIucHJvdG90eXBlID0ge1xuICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuICBcdFx0fSxcbiAgXHRcdHJlc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcbiAgXHRcdFx0dGhpcy5vYmpbdGhpcy5wcm9wXSA9IHZhbHVlOyAvLyB0cmlnZ2VyIHNldCgpIGFjY2Vzc29yXG4gIFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFJhY3RpdmUodGhpcy5yYWN0aXZlKTtcbiAgXHRcdFx0dGhpcy5yYWN0aXZlLnZpZXdtb2RlbC5tYXJrKHRoaXMua2V5cGF0aCwgeyBrZWVwRXhpc3RpbmdXcmFwcGVyOiB0cnVlIH0pO1xuICBcdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fSxcbiAgXHRcdHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgXHRcdFx0aWYgKHRoaXMudXBkYXRpbmcpIHtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIXRoaXMub2JqW3RoaXMucHJvcF0pIHtcbiAgXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcbiAgXHRcdFx0XHR0aGlzLm9ialt0aGlzLnByb3BdID0gY3JlYXRlQnJhbmNoKGtleSk7XG4gIFx0XHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5vYmpbdGhpcy5wcm9wXVtrZXldID0gdmFsdWU7XG4gIFx0XHR9LFxuICBcdFx0dGVhcmRvd246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dmFyIHRlbXBsYXRlLCBzZXQsIHZhbHVlLCB3cmFwcGVycywgaW5kZXg7XG5cbiAgXHRcdFx0Ly8gSWYgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZCBiZWNhdXNlIHRoZSBjYWNoZSB3YXMgYmVpbmcgY2xlYXJlZCBhcyBhXG4gIFx0XHRcdC8vIHJlc3VsdCBvZiBhIHNldCgpL3VwZGF0ZSgpIGNhbGwgbWFkZSBieSB0aGlzIHdyYXBwZXIsIHdlIHJldHVybiBmYWxzZVxuICBcdFx0XHQvLyBzbyB0aGF0IGl0IGRvZXNuJ3QgZ2V0IHRvcm4gZG93blxuICBcdFx0XHRpZiAodGhpcy51cGRhdGluZykge1xuICBcdFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRlbXBsYXRlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLm9iaiwgdGhpcy5wcm9wKTtcbiAgXHRcdFx0c2V0ID0gdGVtcGxhdGUgJiYgdGVtcGxhdGUuc2V0O1xuXG4gIFx0XHRcdGlmICghc2V0KSB7XG4gIFx0XHRcdFx0Ly8gbW9zdCBsaWtlbHksIHRoaXMgd2FzIGFuIGFycmF5IG1lbWJlciB0aGF0IHdhcyBzcGxpY2VkIG91dFxuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHdyYXBwZXJzID0gc2V0Ll9yYWN0aXZlV3JhcHBlcnM7XG5cbiAgXHRcdFx0aW5kZXggPSB3cmFwcGVycy5pbmRleE9mKHRoaXMpO1xuICBcdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG4gIFx0XHRcdFx0d3JhcHBlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIExhc3Qgb25lIG91dCwgdHVybiBvZmYgdGhlIGxpZ2h0c1xuICBcdFx0XHRpZiAoIXdyYXBwZXJzLmxlbmd0aCkge1xuICBcdFx0XHRcdHZhbHVlID0gdGhpcy5vYmpbdGhpcy5wcm9wXTtcblxuICBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLm9iaiwgdGhpcy5wcm9wLCB0aGlzLm9yaWdpbmFsRGVzY3JpcHRvciB8fCB7XG4gIFx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcbiAgXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gIFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcbiAgXHRcdFx0XHR9KTtcblxuICBcdFx0XHRcdHRoaXMub2JqW3RoaXMucHJvcF0gPSB2YWx1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG4gIH0gY2F0Y2ggKGVycikge1xuICBcdG1hZ2ljQWRhcHRvciA9IGZhbHNlOyAvLyBubyBtYWdpYyBpbiB0aGlzIGJyb3dzZXJcbiAgfVxuXG4gIHZhciBhZGFwdG9yc19tYWdpYyA9IG1hZ2ljQWRhcHRvcjtcblxuICBmdW5jdGlvbiBjcmVhdGVBY2Nlc3NvcnMob3JpZ2luYWxXcmFwcGVyLCB2YWx1ZSwgdGVtcGxhdGUpIHtcblxuICBcdHZhciBvYmplY3QsIHByb3BlcnR5LCBvbGRHZXQsIG9sZFNldCwgZ2V0LCBzZXQ7XG5cbiAgXHRvYmplY3QgPSBvcmlnaW5hbFdyYXBwZXIub2JqO1xuICBcdHByb3BlcnR5ID0gb3JpZ2luYWxXcmFwcGVyLnByb3A7XG5cbiAgXHQvLyBJcyB0aGlzIHRlbXBsYXRlIGNvbmZpZ3VyYWJsZT9cbiAgXHRpZiAodGVtcGxhdGUgJiYgIXRlbXBsYXRlLmNvbmZpZ3VyYWJsZSkge1xuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gYXJyYXkgbGVuZ3RoXG4gIFx0XHRpZiAocHJvcGVydHkgPT09IFwibGVuZ3RoXCIpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIG1hZ2ljIG1vZGUgd2l0aCBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wZXJ0eSArIFwiXFxcIiAtIG9iamVjdCBpcyBub3QgY29uZmlndXJhYmxlXCIpO1xuICBcdH1cblxuICBcdC8vIFRpbWUgdG8gd3JhcCB0aGlzIHByb3BlcnR5XG4gIFx0aWYgKHRlbXBsYXRlKSB7XG4gIFx0XHRvbGRHZXQgPSB0ZW1wbGF0ZS5nZXQ7XG4gIFx0XHRvbGRTZXQgPSB0ZW1wbGF0ZS5zZXQ7XG4gIFx0fVxuXG4gIFx0Z2V0ID0gb2xkR2V0IHx8IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB2YWx1ZTtcbiAgXHR9O1xuXG4gIFx0c2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgXHRcdGlmIChvbGRTZXQpIHtcbiAgXHRcdFx0b2xkU2V0KHYpO1xuICBcdFx0fVxuXG4gIFx0XHR2YWx1ZSA9IG9sZEdldCA/IG9sZEdldCgpIDogdjtcbiAgXHRcdHNldC5fcmFjdGl2ZVdyYXBwZXJzLmZvckVhY2godXBkYXRlV3JhcHBlcik7XG4gIFx0fTtcblxuICBcdGZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIod3JhcHBlcikge1xuICBcdFx0dmFyIGtleXBhdGgsIHJhY3RpdmU7XG5cbiAgXHRcdHdyYXBwZXIudmFsdWUgPSB2YWx1ZTtcblxuICBcdFx0aWYgKHdyYXBwZXIudXBkYXRpbmcpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRyYWN0aXZlID0gd3JhcHBlci5yYWN0aXZlO1xuICBcdFx0a2V5cGF0aCA9IHdyYXBwZXIua2V5cGF0aDtcblxuICBcdFx0d3JhcHBlci51cGRhdGluZyA9IHRydWU7XG4gIFx0XHRnbG9iYWxfcnVubG9vcC5zdGFydChyYWN0aXZlKTtcblxuICBcdFx0cmFjdGl2ZS52aWV3bW9kZWwubWFyayhrZXlwYXRoKTtcblxuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0XHR3cmFwcGVyLnVwZGF0aW5nID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0Ly8gQ3JlYXRlIGFuIGFycmF5IG9mIHdyYXBwZXJzLCBpbiBjYXNlIG90aGVyIGtleXBhdGhzL3JhY3RpdmVzIGRlcGVuZCBvbiB0aGlzIHByb3BlcnR5LlxuICBcdC8vIEhhbmRpbHksIHdlIGNhbiBzdG9yZSB0aGVtIGFzIGEgcHJvcGVydHkgb2YgdGhlIHNldCBmdW5jdGlvbi4gWWF5IEphdmFTY3JpcHQuXG4gIFx0c2V0Ll9yYWN0aXZlV3JhcHBlcnMgPSBbb3JpZ2luYWxXcmFwcGVyXTtcbiAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgeyBnZXQ6IGdldCwgc2V0OiBzZXQsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIHZhciBtYWdpY0FycmF5QWRhcHRvciwgTWFnaWNBcnJheVdyYXBwZXI7XG5cbiAgaWYgKGFkYXB0b3JzX21hZ2ljKSB7XG4gIFx0bWFnaWNBcnJheUFkYXB0b3IgPSB7XG4gIFx0XHRmaWx0ZXI6IGZ1bmN0aW9uIChvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUpIHtcbiAgXHRcdFx0cmV0dXJuIGFkYXB0b3JzX21hZ2ljLmZpbHRlcihvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUpICYmIGFycmF5X2luZGV4LmZpbHRlcihvYmplY3QpO1xuICBcdFx0fSxcblxuICBcdFx0d3JhcDogZnVuY3Rpb24gKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBuZXcgTWFnaWNBcnJheVdyYXBwZXIocmFjdGl2ZSwgYXJyYXksIGtleXBhdGgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRNYWdpY0FycmF5V3JhcHBlciA9IGZ1bmN0aW9uIChyYWN0aXZlLCBhcnJheSwga2V5cGF0aCkge1xuICBcdFx0dGhpcy52YWx1ZSA9IGFycmF5O1xuXG4gIFx0XHR0aGlzLm1hZ2ljID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5tYWdpY1dyYXBwZXIgPSBhZGFwdG9yc19tYWdpYy53cmFwKHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoKTtcbiAgXHRcdHRoaXMuYXJyYXlXcmFwcGVyID0gYXJyYXlfaW5kZXgud3JhcChyYWN0aXZlLCBhcnJheSwga2V5cGF0aCk7XG4gIFx0fTtcblxuICBcdE1hZ2ljQXJyYXlXcmFwcGVyLnByb3RvdHlwZSA9IHtcbiAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHRcdH0sXG4gIFx0XHR0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xuICBcdFx0XHR0aGlzLmFycmF5V3JhcHBlci50ZWFyZG93bigpO1xuICBcdFx0XHR0aGlzLm1hZ2ljV3JhcHBlci50ZWFyZG93bigpO1xuICBcdFx0fSxcbiAgXHRcdHJlc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMubWFnaWNXcmFwcGVyLnJlc2V0KHZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgdmFyIG1hZ2ljQXJyYXkgPSBtYWdpY0FycmF5QWRhcHRvcjtcblxuICB2YXIgcHJvdG90eXBlX2FkYXB0ID0gVmlld21vZGVsJGFkYXB0O1xuXG4gIHZhciBwcmVmaXhlcnMgPSB7fTtcbiAgZnVuY3Rpb24gVmlld21vZGVsJGFkYXB0KGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0dmFyIGxlbiwgaSwgYWRhcHRvciwgd3JhcHBlZDtcblxuICBcdGlmICghdGhpcy5hZGFwdG9ycykgcmV0dXJuO1xuXG4gIFx0Ly8gRG8gd2UgaGF2ZSBhbiBhZGFwdG9yIGZvciB0aGlzIHZhbHVlP1xuICBcdGxlbiA9IHRoaXMuYWRhcHRvcnMubGVuZ3RoO1xuICBcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICBcdFx0YWRhcHRvciA9IHRoaXMuYWRhcHRvcnNbaV07XG5cbiAgXHRcdGlmIChhZGFwdG9yLmZpbHRlcih2YWx1ZSwga2V5cGF0aCwgdGhpcy5yYWN0aXZlKSkge1xuICBcdFx0XHR3cmFwcGVkID0gdGhpcy53cmFwcGVkW2tleXBhdGhdID0gYWRhcHRvci53cmFwKHRoaXMucmFjdGl2ZSwgdmFsdWUsIGtleXBhdGgsIGdldFByZWZpeGVyKGtleXBhdGgpKTtcbiAgXHRcdFx0d3JhcHBlZC52YWx1ZSA9IHZhbHVlO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcHJlZml4S2V5cGF0aChvYmosIHByZWZpeCkge1xuICBcdHZhciBwcmVmaXhlZCA9IHt9LFxuICBcdCAgICBrZXk7XG5cbiAgXHRpZiAoIXByZWZpeCkge1xuICBcdFx0cmV0dXJuIG9iajtcbiAgXHR9XG5cbiAgXHRwcmVmaXggKz0gXCIuXCI7XG5cbiAgXHRmb3IgKGtleSBpbiBvYmopIHtcbiAgXHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICBcdFx0XHRwcmVmaXhlZFtwcmVmaXggKyBrZXldID0gb2JqW2tleV07XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHByZWZpeGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UHJlZml4ZXIocm9vdEtleXBhdGgpIHtcbiAgXHR2YXIgcm9vdERvdDtcblxuICBcdGlmICghcHJlZml4ZXJzW3Jvb3RLZXlwYXRoXSkge1xuICBcdFx0cm9vdERvdCA9IHJvb3RLZXlwYXRoID8gcm9vdEtleXBhdGggKyBcIi5cIiA6IFwiXCI7XG5cbiAgXHRcdHByZWZpeGVyc1tyb290S2V5cGF0aF0gPSBmdW5jdGlvbiAocmVsYXRpdmVLZXlwYXRoLCB2YWx1ZSkge1xuICBcdFx0XHR2YXIgb2JqO1xuXG4gIFx0XHRcdGlmICh0eXBlb2YgcmVsYXRpdmVLZXlwYXRoID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdFx0b2JqID0ge307XG4gIFx0XHRcdFx0b2JqW3Jvb3REb3QgKyByZWxhdGl2ZUtleXBhdGhdID0gdmFsdWU7XG4gIFx0XHRcdFx0cmV0dXJuIG9iajtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICh0eXBlb2YgcmVsYXRpdmVLZXlwYXRoID09PSBcIm9iamVjdFwiKSB7XG4gIFx0XHRcdFx0Ly8gJ3JlbGF0aXZlS2V5cGF0aCcgaXMgaW4gZmFjdCBhIGhhc2gsIG5vdCBhIGtleXBhdGhcbiAgXHRcdFx0XHRyZXR1cm4gcm9vdERvdCA/IHByZWZpeEtleXBhdGgocmVsYXRpdmVLZXlwYXRoLCByb290S2V5cGF0aCkgOiByZWxhdGl2ZUtleXBhdGg7XG4gIFx0XHRcdH1cbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHByZWZpeGVyc1tyb290S2V5cGF0aF07XG4gIH1cblxuICAvLyBURU1QXG5cbiAgdmFyIGhlbHBlcnNfZ2V0VXBzdHJlYW1DaGFuZ2VzID0gZ2V0VXBzdHJlYW1DaGFuZ2VzO1xuICBmdW5jdGlvbiBnZXRVcHN0cmVhbUNoYW5nZXMoY2hhbmdlcykge1xuICBcdHZhciB1cHN0cmVhbUNoYW5nZXMgPSBbcm9vdEtleXBhdGhdLFxuICBcdCAgICBpLFxuICBcdCAgICBrZXlwYXRoO1xuXG4gIFx0aSA9IGNoYW5nZXMubGVuZ3RoO1xuICBcdHdoaWxlIChpLS0pIHtcbiAgXHRcdGtleXBhdGggPSBjaGFuZ2VzW2ldLnBhcmVudDtcblxuICBcdFx0d2hpbGUgKGtleXBhdGggJiYgIWtleXBhdGguaXNSb290KSB7XG4gIFx0XHRcdGlmIChjaGFuZ2VzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xKSB7XG4gIFx0XHRcdFx0YWRkVG9BcnJheSh1cHN0cmVhbUNoYW5nZXMsIGtleXBhdGgpO1xuICBcdFx0XHR9XG4gIFx0XHRcdGtleXBhdGggPSBrZXlwYXRoLnBhcmVudDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdXBzdHJlYW1DaGFuZ2VzO1xuICB9XG5cbiAgdmFyIGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzID0gbm90aWZ5UGF0dGVybk9ic2VydmVycztcblxuICBmdW5jdGlvbiBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzKHZpZXdtb2RlbCwga2V5cGF0aCwgb25seURpcmVjdCkge1xuICBcdHZhciBwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXM7XG5cbiAgXHR1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnModmlld21vZGVsLCBrZXlwYXRoKTtcblxuICBcdGlmIChvbmx5RGlyZWN0KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0cG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzID0ga2V5cGF0aC53aWxkY2FyZE1hdGNoZXMoKTtcbiAgXHRwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAodXBzdHJlYW1QYXR0ZXJuKSB7XG4gIFx0XHRjYXNjYWRlKHZpZXdtb2RlbCwgdXBzdHJlYW1QYXR0ZXJuLCBrZXlwYXRoKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhc2NhZGUodmlld21vZGVsLCB1cHN0cmVhbVBhdHRlcm4sIGtleXBhdGgpIHtcbiAgXHR2YXIgZ3JvdXAsIG1hcCwgYWN0dWFsQ2hpbGRLZXlwYXRoO1xuXG4gIFx0Ly8gVE9ETyBzaG91bGQgYmUgb25lIG9yIHRoZSBvdGhlclxuICBcdHVwc3RyZWFtUGF0dGVybiA9IHVwc3RyZWFtUGF0dGVybi5zdHIgfHwgdXBzdHJlYW1QYXR0ZXJuO1xuXG4gIFx0Z3JvdXAgPSB2aWV3bW9kZWwuZGVwc01hcC5wYXR0ZXJuT2JzZXJ2ZXJzO1xuICBcdG1hcCA9IGdyb3VwICYmIGdyb3VwW3Vwc3RyZWFtUGF0dGVybl07XG5cbiAgXHRpZiAoIW1hcCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdG1hcC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZEtleXBhdGgpIHtcbiAgXHRcdGFjdHVhbENoaWxkS2V5cGF0aCA9IGtleXBhdGguam9pbihjaGlsZEtleXBhdGgubGFzdEtleSk7IC8vICdmb28uYmFyLmJheidcblxuICBcdFx0dXBkYXRlTWF0Y2hpbmdQYXR0ZXJuT2JzZXJ2ZXJzKHZpZXdtb2RlbCwgYWN0dWFsQ2hpbGRLZXlwYXRoKTtcbiAgXHRcdGNhc2NhZGUodmlld21vZGVsLCBjaGlsZEtleXBhdGgsIGFjdHVhbENoaWxkS2V5cGF0aCk7XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnModmlld21vZGVsLCBrZXlwYXRoKSB7XG4gIFx0dmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgXHRcdGlmIChvYnNlcnZlci5yZWdleC50ZXN0KGtleXBhdGguc3RyKSkge1xuICBcdFx0XHRvYnNlcnZlci51cGRhdGUoa2V5cGF0aCk7XG4gIFx0XHR9XG4gIFx0fSk7XG4gIH1cblxuICB2YXIgYXBwbHlDaGFuZ2VzID0gVmlld21vZGVsJGFwcGx5Q2hhbmdlcztcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkYXBwbHlDaGFuZ2VzKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgc2VsZiA9IHRoaXMsXG4gIFx0ICAgIGNoYW5nZXMsXG4gIFx0ICAgIHVwc3RyZWFtQ2hhbmdlcyxcbiAgXHQgICAgaGFzaCA9IHt9LFxuICBcdCAgICBiaW5kaW5ncztcblxuICBcdGNoYW5nZXMgPSB0aGlzLmNoYW5nZXM7XG5cbiAgXHRpZiAoIWNoYW5nZXMubGVuZ3RoKSB7XG4gIFx0XHQvLyBUT0RPIHdlIGVuZCB1cCBoZXJlIG9uIGluaXRpYWwgcmVuZGVyLiBQZXJoYXBzIHdlIHNob3VsZG4ndD9cbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBpbnZhbGlkYXRlQ29tcHV0YXRpb24oY29tcHV0YXRpb24pIHtcbiAgXHRcdHZhciBrZXkgPSBjb21wdXRhdGlvbi5rZXk7XG5cbiAgXHRcdGlmIChjb21wdXRhdGlvbi52aWV3bW9kZWwgPT09IHNlbGYpIHtcbiAgXHRcdFx0c2VsZi5jbGVhckNhY2hlKGtleS5zdHIpO1xuICBcdFx0XHRjb21wdXRhdGlvbi5pbnZhbGlkYXRlKCk7XG5cbiAgXHRcdFx0Y2hhbmdlcy5wdXNoKGtleSk7XG4gIFx0XHRcdGNhc2NhZGUoa2V5KTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGNvbXB1dGF0aW9uLnZpZXdtb2RlbC5tYXJrKGtleSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gY2FzY2FkZShrZXlwYXRoKSB7XG4gIFx0XHR2YXIgbWFwLCBjb21wdXRhdGlvbnM7XG5cbiAgXHRcdGlmIChzZWxmLm5vQ2FzY2FkZS5oYXNPd25Qcm9wZXJ0eShrZXlwYXRoLnN0cikpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoY29tcHV0YXRpb25zID0gc2VsZi5kZXBzLmNvbXB1dGVkW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRjb21wdXRhdGlvbnMuZm9yRWFjaChpbnZhbGlkYXRlQ29tcHV0YXRpb24pO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAobWFwID0gc2VsZi5kZXBzTWFwLmNvbXB1dGVkW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRtYXAuZm9yRWFjaChjYXNjYWRlKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRjaGFuZ2VzLnNsaWNlKCkuZm9yRWFjaChjYXNjYWRlKTtcblxuICBcdHVwc3RyZWFtQ2hhbmdlcyA9IGhlbHBlcnNfZ2V0VXBzdHJlYW1DaGFuZ2VzKGNoYW5nZXMpO1xuICBcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHR2YXIgY29tcHV0YXRpb25zO1xuXG4gIFx0XHQvLyBtYWtlIHN1cmUgd2UgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gZG93biB0aGlzIHBhcnRpY3VsYXIga2V5cGF0aCBpbiB0aGlzIHR1cm5cbiAgXHRcdGlmIChjaGFuZ2VzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xICYmIChjb21wdXRhdGlvbnMgPSBzZWxmLmRlcHMuY29tcHV0ZWRba2V5cGF0aC5zdHJdKSkge1xuICBcdFx0XHRjb21wdXRhdGlvbnMuZm9yRWFjaChpbnZhbGlkYXRlQ29tcHV0YXRpb24pO1xuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0dGhpcy5jaGFuZ2VzID0gW107XG5cbiAgXHQvLyBQYXR0ZXJuIG9ic2VydmVycyBhcmUgYSB3ZWlyZCBzcGVjaWFsIGNhc2VcbiAgXHRpZiAodGhpcy5wYXR0ZXJuT2JzZXJ2ZXJzLmxlbmd0aCkge1xuICBcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzKF90aGlzLCBrZXlwYXRoLCB0cnVlKTtcbiAgXHRcdH0pO1xuICBcdFx0Y2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiBhcHBseUNoYW5nZXNfbm90aWZ5UGF0dGVybk9ic2VydmVycyhfdGhpcywga2V5cGF0aCk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRpZiAodGhpcy5kZXBzLm9ic2VydmVycykge1xuICBcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0cmV0dXJuIG5vdGlmeVVwc3RyZWFtRGVwZW5kYW50cyhfdGhpcywgbnVsbCwga2V5cGF0aCwgXCJvYnNlcnZlcnNcIik7XG4gIFx0XHR9KTtcbiAgXHRcdG5vdGlmeUFsbERlcGVuZGFudHModGhpcywgY2hhbmdlcywgXCJvYnNlcnZlcnNcIik7XG4gIFx0fVxuXG4gIFx0aWYgKHRoaXMuZGVwc1tcImRlZmF1bHRcIl0pIHtcbiAgXHRcdGJpbmRpbmdzID0gW107XG4gIFx0XHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRyZXR1cm4gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKF90aGlzLCBiaW5kaW5ncywga2V5cGF0aCwgXCJkZWZhdWx0XCIpO1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmIChiaW5kaW5ncy5sZW5ndGgpIHtcbiAgXHRcdFx0bm90aWZ5QmluZGluZ3ModGhpcywgYmluZGluZ3MsIGNoYW5nZXMpO1xuICBcdFx0fVxuXG4gIFx0XHRub3RpZnlBbGxEZXBlbmRhbnRzKHRoaXMsIGNoYW5nZXMsIFwiZGVmYXVsdFwiKTtcbiAgXHR9XG5cbiAgXHQvLyBSZXR1cm4gYSBoYXNoIG9mIGtleXBhdGhzIHRvIHVwZGF0ZWQgdmFsdWVzXG4gIFx0Y2hhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRoYXNoW2tleXBhdGguc3RyXSA9IF90aGlzLmdldChrZXlwYXRoKTtcbiAgXHR9KTtcblxuICBcdHRoaXMuaW1wbGljaXRDaGFuZ2VzID0ge307XG4gIFx0dGhpcy5ub0Nhc2NhZGUgPSB7fTtcblxuICBcdHJldHVybiBoYXNoO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKHZpZXdtb2RlbCwgYmluZGluZ3MsIGtleXBhdGgsIGdyb3VwTmFtZSkge1xuICBcdHZhciBkZXBlbmRhbnRzLCB2YWx1ZTtcblxuICBcdGlmIChkZXBlbmRhbnRzID0gZmluZERlcGVuZGFudHModmlld21vZGVsLCBrZXlwYXRoLCBncm91cE5hbWUpKSB7XG4gIFx0XHR2YWx1ZSA9IHZpZXdtb2RlbC5nZXQoa2V5cGF0aCk7XG5cbiAgXHRcdGRlcGVuZGFudHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHQvLyBkb24ndCBcInNldFwiIHRoZSBwYXJlbnQgdmFsdWUsIHJlZmluZSBpdFxuICBcdFx0XHQvLyBpLmUuIG5vdCBkYXRhID0gdmFsdWUsIGJ1dCBkYXRhW2Zvb10gPSBmb29WYWx1ZVxuICBcdFx0XHRpZiAoYmluZGluZ3MgJiYgZC5yZWZpbmVWYWx1ZSkge1xuICBcdFx0XHRcdGJpbmRpbmdzLnB1c2goZCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0ZC5zZXRWYWx1ZSh2YWx1ZSk7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeUJpbmRpbmdzKHZpZXdtb2RlbCwgYmluZGluZ3MsIGNoYW5nZXMpIHtcblxuICBcdGJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgXHRcdHZhciB1c2VTZXQgPSBmYWxzZSxcbiAgXHRcdCAgICBpID0gMCxcbiAgXHRcdCAgICBsZW5ndGggPSBjaGFuZ2VzLmxlbmd0aCxcbiAgXHRcdCAgICByZWZpbmVtZW50cyA9IFtdO1xuXG4gIFx0XHR3aGlsZSAoaSA8IGxlbmd0aCkge1xuICBcdFx0XHR2YXIga2V5cGF0aCA9IGNoYW5nZXNbaV07XG5cbiAgXHRcdFx0aWYgKGtleXBhdGggPT09IGJpbmRpbmcua2V5cGF0aCkge1xuICBcdFx0XHRcdHVzZVNldCA9IHRydWU7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoa2V5cGF0aC5zbGljZSgwLCBiaW5kaW5nLmtleXBhdGgubGVuZ3RoKSA9PT0gYmluZGluZy5rZXlwYXRoKSB7XG4gIFx0XHRcdFx0cmVmaW5lbWVudHMucHVzaChrZXlwYXRoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGkrKztcbiAgXHRcdH1cblxuICBcdFx0aWYgKHVzZVNldCkge1xuICBcdFx0XHRiaW5kaW5nLnNldFZhbHVlKHZpZXdtb2RlbC5nZXQoYmluZGluZy5rZXlwYXRoKSk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChyZWZpbmVtZW50cy5sZW5ndGgpIHtcbiAgXHRcdFx0YmluZGluZy5yZWZpbmVWYWx1ZShyZWZpbmVtZW50cyk7XG4gIFx0XHR9XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlBbGxEZXBlbmRhbnRzKHZpZXdtb2RlbCwga2V5cGF0aHMsIGdyb3VwTmFtZSkge1xuICBcdHZhciBxdWV1ZSA9IFtdO1xuXG4gIFx0YWRkS2V5cGF0aHMoa2V5cGF0aHMpO1xuICBcdHF1ZXVlLmZvckVhY2goZGlzcGF0Y2gpO1xuXG4gIFx0ZnVuY3Rpb24gYWRkS2V5cGF0aHMoa2V5cGF0aHMpIHtcbiAgXHRcdGtleXBhdGhzLmZvckVhY2goYWRkS2V5cGF0aCk7XG4gIFx0XHRrZXlwYXRocy5mb3JFYWNoKGNhc2NhZGUpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIGFkZEtleXBhdGgoa2V5cGF0aCkge1xuICBcdFx0dmFyIGRlcHMgPSBmaW5kRGVwZW5kYW50cyh2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSk7XG5cbiAgXHRcdGlmIChkZXBzKSB7XG4gIFx0XHRcdHF1ZXVlLnB1c2goe1xuICBcdFx0XHRcdGtleXBhdGg6IGtleXBhdGgsXG4gIFx0XHRcdFx0ZGVwczogZGVwc1xuICBcdFx0XHR9KTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBjYXNjYWRlKGtleXBhdGgpIHtcbiAgXHRcdHZhciBjaGlsZERlcHM7XG5cbiAgXHRcdGlmIChjaGlsZERlcHMgPSB2aWV3bW9kZWwuZGVwc01hcFtncm91cE5hbWVdW2tleXBhdGguc3RyXSkge1xuICBcdFx0XHRhZGRLZXlwYXRocyhjaGlsZERlcHMpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGZ1bmN0aW9uIGRpc3BhdGNoKHNldCkge1xuICBcdFx0dmFyIHZhbHVlID0gdmlld21vZGVsLmdldChzZXQua2V5cGF0aCk7XG4gIFx0XHRzZXQuZGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gIFx0XHRcdHJldHVybiBkLnNldFZhbHVlKHZhbHVlKTtcbiAgXHRcdH0pO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmREZXBlbmRhbnRzKHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXBOYW1lKSB7XG4gIFx0dmFyIGdyb3VwID0gdmlld21vZGVsLmRlcHNbZ3JvdXBOYW1lXTtcbiAgXHRyZXR1cm4gZ3JvdXAgPyBncm91cFtrZXlwYXRoLnN0cl0gOiBudWxsO1xuICB9XG5cbiAgdmFyIGNhcHR1cmUgPSBWaWV3bW9kZWwkY2FwdHVyZTtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkY2FwdHVyZSgpIHtcbiAgXHR0aGlzLmNhcHR1cmVHcm91cHMucHVzaChbXSk7XG4gIH1cblxuICB2YXIgY2xlYXJDYWNoZSA9IFZpZXdtb2RlbCRjbGVhckNhY2hlO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRjbGVhckNhY2hlKGtleXBhdGgsIGtlZXBFeGlzdGluZ1dyYXBwZXIpIHtcbiAgXHR2YXIgY2FjaGVNYXAsIHdyYXBwZXI7XG5cbiAgXHRpZiAoIWtlZXBFeGlzdGluZ1dyYXBwZXIpIHtcbiAgXHRcdC8vIElzIHRoZXJlIGEgd3JhcHBlZCBwcm9wZXJ0eSBhdCB0aGlzIGtleXBhdGg/XG4gIFx0XHRpZiAod3JhcHBlciA9IHRoaXMud3JhcHBlZFtrZXlwYXRoXSkge1xuICBcdFx0XHQvLyBEaWQgd2UgdW53cmFwIGl0P1xuICBcdFx0XHRpZiAod3JhcHBlci50ZWFyZG93bigpICE9PSBmYWxzZSkge1xuICBcdFx0XHRcdC8vIElzIHRoaXMgcmlnaHQ/XG4gIFx0XHRcdFx0Ly8gV2hhdCdzIHRoZSBtZWFuaW5nIG9mIHJldHVybmluZyBmYWxzZSBmcm9tIHRlYXJkb3duP1xuICBcdFx0XHRcdC8vIENvdWxkIHRoZXJlIGJlIGEgR0MgcmFtaWZpY2F0aW9uIGlmIHRoaXMgaXMgYSBcInJlYWxcIiByYWN0aXZlLnRlYXJkb3duKCk/XG4gIFx0XHRcdFx0dGhpcy53cmFwcGVkW2tleXBhdGhdID0gbnVsbDtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHRoaXMuY2FjaGVba2V5cGF0aF0gPSB1bmRlZmluZWQ7XG5cbiAgXHRpZiAoY2FjaGVNYXAgPSB0aGlzLmNhY2hlTWFwW2tleXBhdGhdKSB7XG4gIFx0XHR3aGlsZSAoY2FjaGVNYXAubGVuZ3RoKSB7XG4gIFx0XHRcdHRoaXMuY2xlYXJDYWNoZShjYWNoZU1hcC5wb3AoKSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIFVucmVzb2x2ZWREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKGNvbXB1dGF0aW9uLCByZWYpIHtcbiAgXHR0aGlzLmNvbXB1dGF0aW9uID0gY29tcHV0YXRpb247XG4gIFx0dGhpcy52aWV3bW9kZWwgPSBjb21wdXRhdGlvbi52aWV3bW9kZWw7XG4gIFx0dGhpcy5yZWYgPSByZWY7XG5cbiAgXHQvLyBUT0RPIHRoaXMgc2VlbXMgbGlrZSBhIHJlZCBmbGFnIVxuICBcdHRoaXMucm9vdCA9IHRoaXMudmlld21vZGVsLnJhY3RpdmU7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHRoaXMucm9vdC5jb21wb25lbnQgJiYgdGhpcy5yb290LmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcbiAgfTtcblxuICBVbnJlc29sdmVkRGVwZW5kZW5jeS5wcm90b3R5cGUgPSB7XG4gIFx0cmVzb2x2ZTogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdHRoaXMuY29tcHV0YXRpb24uc29mdERlcHMucHVzaChrZXlwYXRoKTtcbiAgXHRcdHRoaXMuY29tcHV0YXRpb24udW5yZXNvbHZlZERlcHNba2V5cGF0aC5zdHJdID0gbnVsbDtcbiAgXHRcdHRoaXMudmlld21vZGVsLnJlZ2lzdGVyKGtleXBhdGgsIHRoaXMuY29tcHV0YXRpb24sIFwiY29tcHV0ZWRcIik7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBDb21wdXRhdGlvbl9VbnJlc29sdmVkRGVwZW5kZW5jeSA9IFVucmVzb2x2ZWREZXBlbmRlbmN5O1xuXG4gIHZhciBDb21wdXRhdGlvbiA9IGZ1bmN0aW9uIChrZXksIHNpZ25hdHVyZSkge1xuICBcdHRoaXMua2V5ID0ga2V5O1xuXG4gIFx0dGhpcy5nZXR0ZXIgPSBzaWduYXR1cmUuZ2V0dGVyO1xuICBcdHRoaXMuc2V0dGVyID0gc2lnbmF0dXJlLnNldHRlcjtcblxuICBcdHRoaXMuaGFyZERlcHMgPSBzaWduYXR1cmUuZGVwcyB8fCBbXTtcbiAgXHR0aGlzLnNvZnREZXBzID0gW107XG4gIFx0dGhpcy51bnJlc29sdmVkRGVwcyA9IHt9O1xuXG4gIFx0dGhpcy5kZXBWYWx1ZXMgPSB7fTtcblxuICBcdHRoaXMuX2RpcnR5ID0gdGhpcy5fZmlyc3RSdW4gPSB0cnVlO1xuICB9O1xuXG4gIENvbXB1dGF0aW9uLnByb3RvdHlwZSA9IHtcbiAgXHRjb25zdHJ1Y3RvcjogQ29tcHV0YXRpb24sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAodmlld21vZGVsKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHR2YXIgaW5pdGlhbDtcblxuICBcdFx0dGhpcy52aWV3bW9kZWwgPSB2aWV3bW9kZWw7XG4gIFx0XHR0aGlzLmJ5cGFzcyA9IHRydWU7XG5cbiAgXHRcdGluaXRpYWwgPSB2aWV3bW9kZWwuZ2V0KHRoaXMua2V5KTtcbiAgXHRcdHZpZXdtb2RlbC5jbGVhckNhY2hlKHRoaXMua2V5LnN0cik7XG5cbiAgXHRcdHRoaXMuYnlwYXNzID0gZmFsc2U7XG5cbiAgXHRcdGlmICh0aGlzLnNldHRlciAmJiBpbml0aWFsICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy5zZXQoaW5pdGlhbCk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICh0aGlzLmhhcmREZXBzKSB7XG4gIFx0XHRcdHRoaXMuaGFyZERlcHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHRcdHJldHVybiB2aWV3bW9kZWwucmVnaXN0ZXIoZCwgX3RoaXMsIFwiY29tcHV0ZWRcIik7XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRpbnZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR0aGlzLl9kaXJ0eSA9IHRydWU7XG4gIFx0fSxcblxuICBcdGdldDogZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIF90aGlzID0gdGhpcztcblxuICBcdFx0dmFyIG5ld0RlcHMsXG4gIFx0XHQgICAgZGVwZW5kZW5jaWVzQ2hhbmdlZCxcbiAgXHRcdCAgICBkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCA9IGZhbHNlO1xuXG4gIFx0XHRpZiAodGhpcy5nZXR0aW5nKSB7XG4gIFx0XHRcdC8vIHByZXZlbnQgZG91YmxlLWNvbXB1dGF0aW9uIChlLmcuIGNhdXNlZCBieSBhcnJheSBtdXRhdGlvbiBpbnNpZGUgY29tcHV0YXRpb24pXG4gIFx0XHRcdHZhciBtc2cgPSBcIlRoZSBcIiArIHRoaXMua2V5LnN0ciArIFwiIGNvbXB1dGF0aW9uIGluZGlyZWN0bHkgY2FsbGVkIGl0c2VsZi4gVGhpcyBwcm9iYWJseSBpbmRpY2F0ZXMgYSBidWcgaW4gdGhlIGNvbXB1dGF0aW9uLiBJdCBpcyBjb21tb25seSBjYXVzZWQgYnkgYGFycmF5LnNvcnQoLi4uKWAgLSBpZiB0aGF0J3MgdGhlIGNhc2UsIGNsb25lIHRoZSBhcnJheSBmaXJzdCB3aXRoIGBhcnJheS5zbGljZSgpLnNvcnQoLi4uKWBcIjtcbiAgXHRcdFx0d2Fybk9uY2UobXNnKTtcbiAgXHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZ2V0dGluZyA9IHRydWU7XG5cbiAgXHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuICBcdFx0XHQvLyBkZXRlcm1pbmUgd2hldGhlciB0aGUgaW5wdXRzIGhhdmUgY2hhbmdlZCwgaW4gY2FzZSB0aGlzIGRlcGVuZHMgb25cbiAgXHRcdFx0Ly8gb3RoZXIgY29tcHV0ZWQgdmFsdWVzXG4gIFx0XHRcdGlmICh0aGlzLl9maXJzdFJ1biB8fCAhdGhpcy5oYXJkRGVwcy5sZW5ndGggJiYgIXRoaXMuc29mdERlcHMubGVuZ3RoKSB7XG4gIFx0XHRcdFx0ZGVwZW5kZW5jeVZhbHVlc0NoYW5nZWQgPSB0cnVlO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFt0aGlzLmhhcmREZXBzLCB0aGlzLnNvZnREZXBzXS5mb3JFYWNoKGZ1bmN0aW9uIChkZXBzKSB7XG4gIFx0XHRcdFx0XHR2YXIga2V5cGF0aCwgdmFsdWUsIGk7XG5cbiAgXHRcdFx0XHRcdGlmIChkZXBlbmRlbmN5VmFsdWVzQ2hhbmdlZCkge1xuICBcdFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdGkgPSBkZXBzLmxlbmd0aDtcbiAgXHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0XHRcdFx0a2V5cGF0aCA9IGRlcHNbaV07XG4gIFx0XHRcdFx0XHRcdHZhbHVlID0gX3RoaXMudmlld21vZGVsLmdldChrZXlwYXRoKTtcblxuICBcdFx0XHRcdFx0XHRpZiAoIWlzRXF1YWwodmFsdWUsIF90aGlzLmRlcFZhbHVlc1trZXlwYXRoLnN0cl0pKSB7XG4gIFx0XHRcdFx0XHRcdFx0X3RoaXMuZGVwVmFsdWVzW2tleXBhdGguc3RyXSA9IHZhbHVlO1xuICBcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkID0gdHJ1ZTtcblxuICBcdFx0XHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKGRlcGVuZGVuY3lWYWx1ZXNDaGFuZ2VkKSB7XG4gIFx0XHRcdFx0dGhpcy52aWV3bW9kZWwuY2FwdHVyZSgpO1xuXG4gIFx0XHRcdFx0dHJ5IHtcbiAgXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLmdldHRlcigpO1xuICBcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuICBcdFx0XHRcdFx0d2FybklmRGVidWcoXCJGYWlsZWQgdG8gY29tcHV0ZSBcXFwiJXNcXFwiXCIsIHRoaXMua2V5LnN0cik7XG4gIFx0XHRcdFx0XHRsb2dJZkRlYnVnKGVyci5zdGFjayB8fCBlcnIpO1xuXG4gIFx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdm9pZCAwO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdG5ld0RlcHMgPSB0aGlzLnZpZXdtb2RlbC5yZWxlYXNlKCk7XG4gIFx0XHRcdFx0ZGVwZW5kZW5jaWVzQ2hhbmdlZCA9IHRoaXMudXBkYXRlRGVwZW5kZW5jaWVzKG5ld0RlcHMpO1xuXG4gIFx0XHRcdFx0aWYgKGRlcGVuZGVuY2llc0NoYW5nZWQpIHtcbiAgXHRcdFx0XHRcdFt0aGlzLmhhcmREZXBzLCB0aGlzLnNvZnREZXBzXS5mb3JFYWNoKGZ1bmN0aW9uIChkZXBzKSB7XG4gIFx0XHRcdFx0XHRcdGRlcHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRcdFx0XHRcdF90aGlzLmRlcFZhbHVlc1trZXlwYXRoLnN0cl0gPSBfdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHRcdH0pO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZ2V0dGluZyA9IHRoaXMuX2ZpcnN0UnVuID0gZmFsc2U7XG4gIFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHR9LFxuXG4gIFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdGlmICh0aGlzLnNldHRpbmcpIHtcbiAgXHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICghdGhpcy5zZXR0ZXIpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ29tcHV0ZWQgcHJvcGVydGllcyB3aXRob3V0IHNldHRlcnMgYXJlIHJlYWQtb25seS4gKFRoaXMgbWF5IGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJhY3RpdmUhKVwiKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5zZXR0ZXIodmFsdWUpO1xuICBcdH0sXG5cbiAgXHR1cGRhdGVEZXBlbmRlbmNpZXM6IGZ1bmN0aW9uIChuZXdEZXBzKSB7XG4gIFx0XHR2YXIgaSwgb2xkRGVwcywga2V5cGF0aCwgZGVwZW5kZW5jaWVzQ2hhbmdlZCwgdW5yZXNvbHZlZDtcblxuICBcdFx0b2xkRGVwcyA9IHRoaXMuc29mdERlcHM7XG5cbiAgXHRcdC8vIHJlbW92ZSBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHVzZWRcbiAgXHRcdGkgPSBvbGREZXBzLmxlbmd0aDtcbiAgXHRcdHdoaWxlIChpLS0pIHtcbiAgXHRcdFx0a2V5cGF0aCA9IG9sZERlcHNbaV07XG5cbiAgXHRcdFx0aWYgKG5ld0RlcHMuaW5kZXhPZihrZXlwYXRoKSA9PT0gLTEpIHtcbiAgXHRcdFx0XHRkZXBlbmRlbmNpZXNDaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlZ2lzdGVyKGtleXBhdGgsIHRoaXMsIFwiY29tcHV0ZWRcIik7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gY3JlYXRlIHJlZmVyZW5jZXMgZm9yIGFueSBuZXcgZGVwZW5kZW5jaWVzXG4gIFx0XHRpID0gbmV3RGVwcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRcdGtleXBhdGggPSBuZXdEZXBzW2ldO1xuXG4gIFx0XHRcdGlmIChvbGREZXBzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xICYmICghdGhpcy5oYXJkRGVwcyB8fCB0aGlzLmhhcmREZXBzLmluZGV4T2Yoa2V5cGF0aCkgPT09IC0xKSkge1xuICBcdFx0XHRcdGRlcGVuZGVuY2llc0NoYW5nZWQgPSB0cnVlO1xuXG4gIFx0XHRcdFx0Ly8gaWYgdGhpcyBrZXlwYXRoIGlzIGN1cnJlbnRseSB1bnJlc29sdmVkLCB3ZSBuZWVkIHRvIG1hcmtcbiAgXHRcdFx0XHQvLyBpdCBhcyBzdWNoLiBUT0RPIHRoaXMgaXMgYSBiaXQgbXVkZHkuLi5cbiAgXHRcdFx0XHRpZiAoaXNVbnJlc29sdmVkKHRoaXMudmlld21vZGVsLCBrZXlwYXRoKSAmJiAhdGhpcy51bnJlc29sdmVkRGVwc1trZXlwYXRoLnN0cl0pIHtcbiAgXHRcdFx0XHRcdHVucmVzb2x2ZWQgPSBuZXcgQ29tcHV0YXRpb25fVW5yZXNvbHZlZERlcGVuZGVuY3kodGhpcywga2V5cGF0aC5zdHIpO1xuICBcdFx0XHRcdFx0bmV3RGVwcy5zcGxpY2UoaSwgMSk7XG5cbiAgXHRcdFx0XHRcdHRoaXMudW5yZXNvbHZlZERlcHNba2V5cGF0aC5zdHJdID0gdW5yZXNvbHZlZDtcbiAgXHRcdFx0XHRcdGdsb2JhbF9ydW5sb29wLmFkZFVucmVzb2x2ZWQodW5yZXNvbHZlZCk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnJlZ2lzdGVyKGtleXBhdGgsIHRoaXMsIFwiY29tcHV0ZWRcIik7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGlmIChkZXBlbmRlbmNpZXNDaGFuZ2VkKSB7XG4gIFx0XHRcdHRoaXMuc29mdERlcHMgPSBuZXdEZXBzLnNsaWNlKCk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBkZXBlbmRlbmNpZXNDaGFuZ2VkO1xuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBpc1VucmVzb2x2ZWQodmlld21vZGVsLCBrZXlwYXRoKSB7XG4gIFx0dmFyIGtleSA9IGtleXBhdGguZmlyc3RLZXk7XG5cbiAgXHRyZXR1cm4gIShrZXkgaW4gdmlld21vZGVsLmRhdGEpICYmICEoa2V5IGluIHZpZXdtb2RlbC5jb21wdXRhdGlvbnMpICYmICEoa2V5IGluIHZpZXdtb2RlbC5tYXBwaW5ncyk7XG4gIH1cblxuICB2YXIgQ29tcHV0YXRpb25fQ29tcHV0YXRpb24gPSBDb21wdXRhdGlvbjtcblxuICB2YXIgY29tcHV0ZSA9IFZpZXdtb2RlbCRjb21wdXRlO1xuICBmdW5jdGlvbiBWaWV3bW9kZWwkY29tcHV0ZShrZXksIHNpZ25hdHVyZSkge1xuICBcdHZhciBjb21wdXRhdGlvbiA9IG5ldyBDb21wdXRhdGlvbl9Db21wdXRhdGlvbihrZXksIHNpZ25hdHVyZSk7XG5cbiAgXHRpZiAodGhpcy5yZWFkeSkge1xuICBcdFx0Y29tcHV0YXRpb24uaW5pdCh0aGlzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5jb21wdXRhdGlvbnNba2V5LnN0cl0gPSBjb21wdXRhdGlvbjtcbiAgfVxuXG4gIHZhciBGQUlMRURfTE9PS1VQID0geyBGQUlMRURfTE9PS1VQOiB0cnVlIH07XG5cbiAgdmFyIHZpZXdtb2RlbF9wcm90b3R5cGVfZ2V0ID0gVmlld21vZGVsJGdldDtcblxuICB2YXIgdmlld21vZGVsX3Byb3RvdHlwZV9nZXRfX2VtcHR5ID0ge307XG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRnZXQoa2V5cGF0aCwgb3B0aW9ucykge1xuICBcdHZhciBjYWNoZSA9IHRoaXMuY2FjaGUsXG4gIFx0ICAgIHZhbHVlLFxuICBcdCAgICBjb21wdXRhdGlvbixcbiAgXHQgICAgd3JhcHBlZCxcbiAgXHQgICAgY2FwdHVyZUdyb3VwLFxuICBcdCAgICBrZXlwYXRoU3RyID0ga2V5cGF0aC5zdHIsXG4gIFx0ICAgIGtleTtcblxuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHZpZXdtb2RlbF9wcm90b3R5cGVfZ2V0X19lbXB0eTtcblxuICBcdC8vIGNhcHR1cmUgdGhlIGtleXBhdGgsIGlmIHdlJ3JlIGluc2lkZSBhIGNvbXB1dGF0aW9uXG4gIFx0aWYgKG9wdGlvbnMuY2FwdHVyZSAmJiAoY2FwdHVyZUdyb3VwID0gbGFzdEl0ZW0odGhpcy5jYXB0dXJlR3JvdXBzKSkpIHtcbiAgXHRcdGlmICghIH5jYXB0dXJlR3JvdXAuaW5kZXhPZihrZXlwYXRoKSkge1xuICBcdFx0XHRjYXB0dXJlR3JvdXAucHVzaChrZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoaGFzT3duLmNhbGwodGhpcy5tYXBwaW5ncywga2V5cGF0aC5maXJzdEtleSkpIHtcbiAgXHRcdHJldHVybiB0aGlzLm1hcHBpbmdzW2tleXBhdGguZmlyc3RLZXldLmdldChrZXlwYXRoLCBvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHRpZiAoa2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdHJldHVybiBrZXlwYXRoLnZhbHVlO1xuICBcdH1cblxuICBcdGlmIChjYWNoZVtrZXlwYXRoU3RyXSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgXHRcdC8vIElzIHRoaXMgYSBjb21wdXRlZCBwcm9wZXJ0eT9cbiAgXHRcdGlmICgoY29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1trZXlwYXRoU3RyXSkgJiYgIWNvbXB1dGF0aW9uLmJ5cGFzcykge1xuICBcdFx0XHR2YWx1ZSA9IGNvbXB1dGF0aW9uLmdldCgpO1xuICBcdFx0XHR0aGlzLmFkYXB0KGtleXBhdGhTdHIsIHZhbHVlKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSXMgdGhpcyBhIHdyYXBwZWQgcHJvcGVydHk/XG4gIFx0XHRlbHNlIGlmICh3cmFwcGVkID0gdGhpcy53cmFwcGVkW2tleXBhdGhTdHJdKSB7XG4gIFx0XHRcdHZhbHVlID0gd3JhcHBlZC52YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSXMgaXQgdGhlIHJvb3Q/XG4gIFx0XHRlbHNlIGlmIChrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0XHR0aGlzLmFkYXB0KFwiXCIsIHRoaXMuZGF0YSk7XG4gIFx0XHRcdHZhbHVlID0gdGhpcy5kYXRhO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBObz8gVGhlbiB3ZSBuZWVkIHRvIHJldHJpZXZlIHRoZSB2YWx1ZSBvbmUga2V5IGF0IGEgdGltZVxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdHZhbHVlID0gcmV0cmlldmUodGhpcywga2V5cGF0aCk7XG4gIFx0XHR9XG5cbiAgXHRcdGNhY2hlW2tleXBhdGhTdHJdID0gdmFsdWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHZhbHVlID0gY2FjaGVba2V5cGF0aFN0cl07XG4gIFx0fVxuXG4gIFx0aWYgKCFvcHRpb25zLm5vVW53cmFwICYmICh3cmFwcGVkID0gdGhpcy53cmFwcGVkW2tleXBhdGhTdHJdKSkge1xuICBcdFx0dmFsdWUgPSB3cmFwcGVkLmdldCgpO1xuICBcdH1cblxuICBcdGlmIChrZXlwYXRoLmlzUm9vdCAmJiBvcHRpb25zLmZ1bGxSb290R2V0KSB7XG4gIFx0XHRmb3IgKGtleSBpbiB0aGlzLm1hcHBpbmdzKSB7XG4gIFx0XHRcdHZhbHVlW2tleV0gPSB0aGlzLm1hcHBpbmdzW2tleV0uZ2V0VmFsdWUoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWUgPT09IEZBSUxFRF9MT09LVVAgPyB2b2lkIDAgOiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldHJpZXZlKHZpZXdtb2RlbCwga2V5cGF0aCkge1xuXG4gIFx0dmFyIHBhcmVudFZhbHVlLCBjYWNoZU1hcCwgdmFsdWUsIHdyYXBwZWQ7XG5cbiAgXHRwYXJlbnRWYWx1ZSA9IHZpZXdtb2RlbC5nZXQoa2V5cGF0aC5wYXJlbnQpO1xuXG4gIFx0aWYgKHdyYXBwZWQgPSB2aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnBhcmVudC5zdHJdKSB7XG4gIFx0XHRwYXJlbnRWYWx1ZSA9IHdyYXBwZWQuZ2V0KCk7XG4gIFx0fVxuXG4gIFx0aWYgKHBhcmVudFZhbHVlID09PSBudWxsIHx8IHBhcmVudFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyB1cGRhdGUgY2FjaGUgbWFwXG4gIFx0aWYgKCEoY2FjaGVNYXAgPSB2aWV3bW9kZWwuY2FjaGVNYXBba2V5cGF0aC5wYXJlbnQuc3RyXSkpIHtcbiAgXHRcdHZpZXdtb2RlbC5jYWNoZU1hcFtrZXlwYXRoLnBhcmVudC5zdHJdID0gW2tleXBhdGguc3RyXTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0aWYgKGNhY2hlTWFwLmluZGV4T2Yoa2V5cGF0aC5zdHIpID09PSAtMSkge1xuICBcdFx0XHRjYWNoZU1hcC5wdXNoKGtleXBhdGguc3RyKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGlzIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QsIHdlIHJldHVybiBhIHNlbnRpbmVsIHZhbHVlXG4gIFx0Ly8gc28gdGhhdCB3ZSBrbm93IHRvIHF1ZXJ5IHBhcmVudCBzY29wZSAoaWYgc3VjaCB0aGVyZSBiZSlcbiAgXHRpZiAodHlwZW9mIHBhcmVudFZhbHVlID09PSBcIm9iamVjdFwiICYmICEoa2V5cGF0aC5sYXN0S2V5IGluIHBhcmVudFZhbHVlKSkge1xuICBcdFx0cmV0dXJuIHZpZXdtb2RlbC5jYWNoZVtrZXlwYXRoLnN0cl0gPSBGQUlMRURfTE9PS1VQO1xuICBcdH1cblxuICBcdHZhbHVlID0gcGFyZW50VmFsdWVba2V5cGF0aC5sYXN0S2V5XTtcblxuICBcdC8vIERvIHdlIGhhdmUgYW4gYWRhcHRvciBmb3IgdGhpcyB2YWx1ZT9cbiAgXHR2aWV3bW9kZWwuYWRhcHQoa2V5cGF0aC5zdHIsIHZhbHVlLCBmYWxzZSk7XG5cbiAgXHQvLyBVcGRhdGUgY2FjaGVcbiAgXHR2aWV3bW9kZWwuY2FjaGVba2V5cGF0aC5zdHJdID0gdmFsdWU7XG4gIFx0cmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdmFyIHZpZXdtb2RlbF9wcm90b3R5cGVfaW5pdCA9IFZpZXdtb2RlbCRpbml0O1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRpbml0KCkge1xuICBcdHZhciBrZXk7XG5cbiAgXHRmb3IgKGtleSBpbiB0aGlzLmNvbXB1dGF0aW9ucykge1xuICBcdFx0dGhpcy5jb21wdXRhdGlvbnNba2V5XS5pbml0KHRoaXMpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfbWFwID0gVmlld21vZGVsJG1hcDtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkbWFwKGtleSwgb3B0aW9ucykge1xuICBcdHZhciBtYXBwaW5nID0gdGhpcy5tYXBwaW5nc1trZXkuc3RyXSA9IG5ldyBNYXBwaW5nKGtleSwgb3B0aW9ucyk7XG4gIFx0bWFwcGluZy5pbml0Vmlld21vZGVsKHRoaXMpO1xuICBcdHJldHVybiBtYXBwaW5nO1xuICB9XG5cbiAgdmFyIE1hcHBpbmcgPSBmdW5jdGlvbiAobG9jYWxLZXksIG9wdGlvbnMpIHtcbiAgXHR0aGlzLmxvY2FsS2V5ID0gbG9jYWxLZXk7XG4gIFx0dGhpcy5rZXlwYXRoID0gb3B0aW9ucy5rZXlwYXRoO1xuICBcdHRoaXMub3JpZ2luID0gb3B0aW9ucy5vcmlnaW47XG5cbiAgXHR0aGlzLmRlcHMgPSBbXTtcbiAgXHR0aGlzLnVucmVzb2x2ZWQgPSBbXTtcblxuICBcdHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcbiAgfTtcblxuICBNYXBwaW5nLnByb3RvdHlwZSA9IHtcbiAgXHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uICgpIHtcbiAgXHRcdC8vIFRPRE8gd2FybiwgYXMgcGVyICMxNjkyP1xuICBcdFx0dGhpcy5rZXlwYXRoID0gdGhpcy5sb2NhbEtleTtcbiAgXHRcdHRoaXMuc2V0dXAoKTtcbiAgXHR9LFxuXG4gIFx0Z2V0OiBmdW5jdGlvbiAoa2V5cGF0aCwgb3B0aW9ucykge1xuICBcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcy5vcmlnaW4uZ2V0KHRoaXMubWFwKGtleXBhdGgpLCBvcHRpb25zKTtcbiAgXHR9LFxuXG4gIFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5rZXlwYXRoKSB7XG4gIFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdGhpcy5vcmlnaW4uZ2V0KHRoaXMua2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdGluaXRWaWV3bW9kZWw6IGZ1bmN0aW9uICh2aWV3bW9kZWwpIHtcbiAgXHRcdHRoaXMubG9jYWwgPSB2aWV3bW9kZWw7XG4gIFx0XHR0aGlzLnNldHVwKCk7XG4gIFx0fSxcblxuICBcdG1hcDogZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdGlmICh0eXBlb2YgdGhpcy5rZXlwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMubG9jYWxLZXk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4ga2V5cGF0aC5yZXBsYWNlKHRoaXMubG9jYWxLZXksIHRoaXMua2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHJlZ2lzdGVyOiBmdW5jdGlvbiAoa2V5cGF0aCwgZGVwZW5kYW50LCBncm91cCkge1xuICBcdFx0dGhpcy5kZXBzLnB1c2goeyBrZXlwYXRoOiBrZXlwYXRoLCBkZXA6IGRlcGVuZGFudCwgZ3JvdXA6IGdyb3VwIH0pO1xuXG4gIFx0XHRpZiAodGhpcy5yZXNvbHZlZCkge1xuICBcdFx0XHR0aGlzLm9yaWdpbi5yZWdpc3Rlcih0aGlzLm1hcChrZXlwYXRoKSwgZGVwZW5kYW50LCBncm91cCk7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHJlc29sdmU6IGZ1bmN0aW9uIChrZXlwYXRoKSB7XG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0dGhpcy51bmJpbmQodHJ1ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG4gIFx0XHR0aGlzLnNldHVwKCk7XG4gIFx0fSxcblxuICBcdHNldDogZnVuY3Rpb24gKGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0dGhpcy5mb3JjZVJlc29sdXRpb24oKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5vcmlnaW4uc2V0KHRoaXMubWFwKGtleXBhdGgpLCB2YWx1ZSk7XG4gIFx0fSxcblxuICBcdHNldHVwOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0XHRpZiAodGhpcy5rZXlwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnJlc29sdmVkID0gdHJ1ZTtcblxuICBcdFx0Ly8gYWNjdW11bGF0ZWQgZGVwZW5kYW50cyBjYW4gbm93IGJlIHJlZ2lzdGVyZWRcbiAgXHRcdGlmICh0aGlzLmRlcHMubGVuZ3RoKSB7XG4gIFx0XHRcdHRoaXMuZGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gIFx0XHRcdFx0dmFyIGtleXBhdGggPSBfdGhpcy5tYXAoZC5rZXlwYXRoKTtcbiAgXHRcdFx0XHRfdGhpcy5vcmlnaW4ucmVnaXN0ZXIoa2V5cGF0aCwgZC5kZXAsIGQuZ3JvdXApO1xuXG4gIFx0XHRcdFx0Ly8gVE9ETyB0aGlzIGlzIGEgYml0IG9mIGEgcmVkIGZsYWcuLi4gYWxsIGRlcHMgc2hvdWxkIGJlIHRoZSBzYW1lP1xuICBcdFx0XHRcdGlmIChkLmRlcC5zZXRWYWx1ZSkge1xuICBcdFx0XHRcdFx0ZC5kZXAuc2V0VmFsdWUoX3RoaXMub3JpZ2luLmdldChrZXlwYXRoKSk7XG4gIFx0XHRcdFx0fSBlbHNlIGlmIChkLmRlcC5pbnZhbGlkYXRlKSB7XG4gIFx0XHRcdFx0XHRkLmRlcC5pbnZhbGlkYXRlKCk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQuIFBsZWFzZSByYWlzZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIVwiKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0pO1xuXG4gIFx0XHRcdHRoaXMub3JpZ2luLm1hcmsodGhpcy5rZXlwYXRoKTtcbiAgXHRcdH1cbiAgXHR9LFxuXG4gIFx0c2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBcdFx0aWYgKCF0aGlzLmtleXBhdGgpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTWFwcGluZyBkb2VzIG5vdCBoYXZlIGtleXBhdGgsIGNhbm5vdCBzZXQgdmFsdWUuIFBsZWFzZSByYWlzZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIVwiKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5vcmlnaW4uc2V0KHRoaXMua2V5cGF0aCwgdmFsdWUpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uIChrZWVwTG9jYWwpIHtcbiAgXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHRcdGlmICgha2VlcExvY2FsKSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLmxvY2FsLm1hcHBpbmdzW3RoaXMubG9jYWxLZXldO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIXRoaXMucmVzb2x2ZWQpIHtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmRlcHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICBcdFx0XHRfdGhpcy5vcmlnaW4udW5yZWdpc3RlcihfdGhpcy5tYXAoZC5rZXlwYXRoKSwgZC5kZXAsIGQuZ3JvdXApO1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmICh0aGlzLnRyYWNrZXIpIHtcbiAgXHRcdFx0dGhpcy5vcmlnaW4udW5yZWdpc3Rlcih0aGlzLmtleXBhdGgsIHRoaXMudHJhY2tlcik7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdHVucmVnaXN0ZXI6IGZ1bmN0aW9uIChrZXlwYXRoLCBkZXBlbmRhbnQsIGdyb3VwKSB7XG4gIFx0XHR2YXIgZGVwcywgaTtcblxuICBcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0ZGVwcyA9IHRoaXMuZGVwcztcbiAgXHRcdGkgPSBkZXBzLmxlbmd0aDtcblxuICBcdFx0d2hpbGUgKGktLSkge1xuICBcdFx0XHRpZiAoZGVwc1tpXS5kZXAgPT09IGRlcGVuZGFudCkge1xuICBcdFx0XHRcdGRlcHMuc3BsaWNlKGksIDEpO1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHR0aGlzLm9yaWdpbi51bnJlZ2lzdGVyKHRoaXMubWFwKGtleXBhdGgpLCBkZXBlbmRhbnQsIGdyb3VwKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIG1hcmsgPSBWaWV3bW9kZWwkbWFyaztcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkbWFyayhrZXlwYXRoLCBvcHRpb25zKSB7XG4gIFx0dmFyIGNvbXB1dGF0aW9uLFxuICBcdCAgICBrZXlwYXRoU3RyID0ga2V5cGF0aC5zdHI7XG5cbiAgXHQvLyBpbXBsaWNpdCBjaGFuZ2VzIChpLmUuIGBmb28ubGVuZ3RoYCBvbiBgcmFjdGl2ZS5wdXNoKCdmb28nLDQyKWApXG4gIFx0Ly8gc2hvdWxkIG5vdCBiZSBwaWNrZWQgdXAgYnkgcGF0dGVybiBvYnNlcnZlcnNcbiAgXHRpZiAob3B0aW9ucykge1xuICBcdFx0aWYgKG9wdGlvbnMuaW1wbGljaXQpIHtcbiAgXHRcdFx0dGhpcy5pbXBsaWNpdENoYW5nZXNba2V5cGF0aFN0cl0gPSB0cnVlO1xuICBcdFx0fVxuICBcdFx0aWYgKG9wdGlvbnMubm9DYXNjYWRlKSB7XG4gIFx0XHRcdHRoaXMubm9DYXNjYWRlW2tleXBhdGhTdHJdID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoY29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1trZXlwYXRoU3RyXSkge1xuICBcdFx0Y29tcHV0YXRpb24uaW52YWxpZGF0ZSgpO1xuICBcdH1cblxuICBcdGlmICh0aGlzLmNoYW5nZXMuaW5kZXhPZihrZXlwYXRoKSA9PT0gLTEpIHtcbiAgXHRcdHRoaXMuY2hhbmdlcy5wdXNoKGtleXBhdGgpO1xuICBcdH1cblxuICBcdC8vIHBhc3Mgb24ga2VlcEV4aXN0aW5nV3JhcHBlciwgaWYgd2UgY2FuXG4gIFx0dmFyIGtlZXBFeGlzdGluZ1dyYXBwZXIgPSBvcHRpb25zID8gb3B0aW9ucy5rZWVwRXhpc3RpbmdXcmFwcGVyIDogZmFsc2U7XG5cbiAgXHR0aGlzLmNsZWFyQ2FjaGUoa2V5cGF0aFN0ciwga2VlcEV4aXN0aW5nV3JhcHBlcik7XG5cbiAgXHRpZiAodGhpcy5yZWFkeSkge1xuICBcdFx0dGhpcy5vbmNoYW5nZSgpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBtYXBPbGRUb05ld0luZGV4ID0gZnVuY3Rpb24gKG9sZEFycmF5LCBuZXdBcnJheSkge1xuICBcdHZhciB1c2VkSW5kaWNlcywgZmlyc3RVbnVzZWRJbmRleCwgbmV3SW5kaWNlcywgY2hhbmdlZDtcblxuICBcdHVzZWRJbmRpY2VzID0ge307XG4gIFx0Zmlyc3RVbnVzZWRJbmRleCA9IDA7XG5cbiAgXHRuZXdJbmRpY2VzID0gb2xkQXJyYXkubWFwKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gIFx0XHR2YXIgaW5kZXgsIHN0YXJ0LCBsZW47XG5cbiAgXHRcdHN0YXJ0ID0gZmlyc3RVbnVzZWRJbmRleDtcbiAgXHRcdGxlbiA9IG5ld0FycmF5Lmxlbmd0aDtcblxuICBcdFx0ZG8ge1xuICBcdFx0XHRpbmRleCA9IG5ld0FycmF5LmluZGV4T2YoaXRlbSwgc3RhcnQpO1xuXG4gIFx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcbiAgXHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHRyZXR1cm4gLTE7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRzdGFydCA9IGluZGV4ICsgMTtcbiAgXHRcdH0gd2hpbGUgKHVzZWRJbmRpY2VzW2luZGV4XSAmJiBzdGFydCA8IGxlbik7XG5cbiAgXHRcdC8vIGtlZXAgdHJhY2sgb2YgdGhlIGZpcnN0IHVudXNlZCBpbmRleCwgc28gd2UgZG9uJ3Qgc2VhcmNoXG4gIFx0XHQvLyB0aGUgd2hvbGUgb2YgbmV3QXJyYXkgZm9yIGVhY2ggaXRlbSBpbiBvbGRBcnJheSB1bm5lY2Vzc2FyaWx5XG4gIFx0XHRpZiAoaW5kZXggPT09IGZpcnN0VW51c2VkSW5kZXgpIHtcbiAgXHRcdFx0Zmlyc3RVbnVzZWRJbmRleCArPSAxO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoaW5kZXggIT09IGkpIHtcbiAgXHRcdFx0Y2hhbmdlZCA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdHVzZWRJbmRpY2VzW2luZGV4XSA9IHRydWU7XG4gIFx0XHRyZXR1cm4gaW5kZXg7XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gbmV3SW5kaWNlcztcbiAgfTtcblxuICB2YXIgbWVyZ2UgPSBWaWV3bW9kZWwkbWVyZ2U7XG5cbiAgdmFyIGNvbXBhcmF0b3JzID0ge307XG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRtZXJnZShrZXlwYXRoLCBjdXJyZW50QXJyYXksIGFycmF5LCBvcHRpb25zKSB7XG4gIFx0dmFyIG9sZEFycmF5LCBuZXdBcnJheSwgY29tcGFyYXRvciwgbmV3SW5kaWNlcztcblxuICBcdHRoaXMubWFyayhrZXlwYXRoKTtcblxuICBcdGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29tcGFyZSkge1xuXG4gIFx0XHRjb21wYXJhdG9yID0gZ2V0Q29tcGFyYXRvckZ1bmN0aW9uKG9wdGlvbnMuY29tcGFyZSk7XG5cbiAgXHRcdHRyeSB7XG4gIFx0XHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5Lm1hcChjb21wYXJhdG9yKTtcbiAgXHRcdFx0bmV3QXJyYXkgPSBhcnJheS5tYXAoY29tcGFyYXRvcik7XG4gIFx0XHR9IGNhdGNoIChlcnIpIHtcbiAgXHRcdFx0Ly8gZmFsbGJhY2sgdG8gYW4gaWRlbnRpdHkgY2hlY2sgLSB3b3JzdCBjYXNlIHNjZW5hcmlvIHdlIGhhdmVcbiAgXHRcdFx0Ly8gdG8gZG8gbW9yZSBET00gbWFuaXB1bGF0aW9uIHRoYW4gd2UgdGhvdWdodC4uLlxuICBcdFx0XHR3YXJuSWZEZWJ1ZyhcIm1lcmdlKCk6IFxcXCIlc1xcXCIgY29tcGFyaXNvbiBmYWlsZWQuIEZhbGxpbmcgYmFjayB0byBpZGVudGl0eSBjaGVja2luZ1wiLCBrZXlwYXRoKTtcblxuICBcdFx0XHRvbGRBcnJheSA9IGN1cnJlbnRBcnJheTtcbiAgXHRcdFx0bmV3QXJyYXkgPSBhcnJheTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0b2xkQXJyYXkgPSBjdXJyZW50QXJyYXk7XG4gIFx0XHRuZXdBcnJheSA9IGFycmF5O1xuICBcdH1cblxuICBcdC8vIGZpbmQgbmV3IGluZGljZXMgZm9yIG1lbWJlcnMgb2Ygb2xkQXJyYXlcbiAgXHRuZXdJbmRpY2VzID0gbWFwT2xkVG9OZXdJbmRleChvbGRBcnJheSwgbmV3QXJyYXkpO1xuXG4gIFx0dGhpcy5zbWFydFVwZGF0ZShrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcywgY3VycmVudEFycmF5Lmxlbmd0aCAhPT0gYXJyYXkubGVuZ3RoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeShpdGVtKSB7XG4gIFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGl0ZW0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29tcGFyYXRvckZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgXHQvLyBJZiBgY29tcGFyZWAgaXMgYHRydWVgLCB3ZSB1c2UgSlNPTi5zdHJpbmdpZnkgdG8gY29tcGFyZVxuICBcdC8vIG9iamVjdHMgdGhhdCBhcmUgdGhlIHNhbWUgc2hhcGUsIGJ1dCBub24taWRlbnRpY2FsIC0gaS5lLlxuICBcdC8vIHsgZm9vOiAnYmFyJyB9ICE9PSB7IGZvbzogJ2JhcicgfVxuICBcdGlmIChjb21wYXJhdG9yID09PSB0cnVlKSB7XG4gIFx0XHRyZXR1cm4gc3RyaW5naWZ5O1xuICBcdH1cblxuICBcdGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0aWYgKCFjb21wYXJhdG9yc1tjb21wYXJhdG9yXSkge1xuICBcdFx0XHRjb21wYXJhdG9yc1tjb21wYXJhdG9yXSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHRcdFx0cmV0dXJuIGl0ZW1bY29tcGFyYXRvcl07XG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBjb21wYXJhdG9yc1tjb21wYXJhdG9yXTtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIGNvbXBhcmF0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0cmV0dXJuIGNvbXBhcmF0b3I7XG4gIFx0fVxuXG4gIFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIGBjb21wYXJlYCBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uLCBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gaWRlbnRpZnlpbmcgZmllbGQgKG9yIGB0cnVlYCB0byB1c2UgSlNPTi5zdHJpbmdpZnkpXCIpO1xuICB9XG5cbiAgdmFyIHJlZ2lzdGVyID0gVmlld21vZGVsJHJlZ2lzdGVyO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRyZWdpc3RlcihrZXlwYXRoLCBkZXBlbmRhbnQpIHtcbiAgXHR2YXIgZ3JvdXAgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IFwiZGVmYXVsdFwiIDogYXJndW1lbnRzWzJdO1xuXG4gIFx0dmFyIG1hcHBpbmcsIGRlcHNCeUtleXBhdGgsIGRlcHM7XG5cbiAgXHRpZiAoZGVwZW5kYW50LmlzU3RhdGljKSB7XG4gIFx0XHRyZXR1cm47IC8vIFRPRE8gd2Ugc2hvdWxkIG5ldmVyIGdldCBoZXJlIGlmIGEgZGVwZW5kYW50IGlzIHN0YXRpYy4uLlxuICBcdH1cblxuICBcdGlmIChtYXBwaW5nID0gdGhpcy5tYXBwaW5nc1trZXlwYXRoLmZpcnN0S2V5XSkge1xuICBcdFx0bWFwcGluZy5yZWdpc3RlcihrZXlwYXRoLCBkZXBlbmRhbnQsIGdyb3VwKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0ZGVwc0J5S2V5cGF0aCA9IHRoaXMuZGVwc1tncm91cF0gfHwgKHRoaXMuZGVwc1tncm91cF0gPSB7fSk7XG4gIFx0XHRkZXBzID0gZGVwc0J5S2V5cGF0aFtrZXlwYXRoLnN0cl0gfHwgKGRlcHNCeUtleXBhdGhba2V5cGF0aC5zdHJdID0gW10pO1xuXG4gIFx0XHRkZXBzLnB1c2goZGVwZW5kYW50KTtcblxuICBcdFx0aWYgKCF0aGlzLmRlcHNNYXBbZ3JvdXBdKSB7XG4gIFx0XHRcdHRoaXMuZGVwc01hcFtncm91cF0gPSB7fTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFrZXlwYXRoLmlzUm9vdCkge1xuICBcdFx0XHRyZWdpc3Rlcl9fdXBkYXRlRGVwZW5kYW50c01hcCh0aGlzLCBrZXlwYXRoLCBncm91cCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJfX3VwZGF0ZURlcGVuZGFudHNNYXAodmlld21vZGVsLCBrZXlwYXRoLCBncm91cCkge1xuICBcdHZhciBtYXAsIHBhcmVudCwga2V5cGF0aFN0cjtcblxuICBcdC8vIHVwZGF0ZSBkZXBlbmRhbnRzIG1hcFxuICBcdHdoaWxlICgha2V5cGF0aC5pc1Jvb3QpIHtcbiAgXHRcdG1hcCA9IHZpZXdtb2RlbC5kZXBzTWFwW2dyb3VwXTtcbiAgXHRcdHBhcmVudCA9IG1hcFtrZXlwYXRoLnBhcmVudC5zdHJdIHx8IChtYXBba2V5cGF0aC5wYXJlbnQuc3RyXSA9IFtdKTtcblxuICBcdFx0a2V5cGF0aFN0ciA9IGtleXBhdGguc3RyO1xuXG4gIFx0XHQvLyBUT0RPIGZpbmQgYW4gYWx0ZXJuYXRpdmUgdG8gdGhpcyBuYXN0eSBhcHByb2FjaFxuICBcdFx0aWYgKHBhcmVudFtcIl9cIiArIGtleXBhdGhTdHJdID09PSB1bmRlZmluZWQpIHtcbiAgXHRcdFx0cGFyZW50W1wiX1wiICsga2V5cGF0aFN0cl0gPSAwO1xuICBcdFx0XHRwYXJlbnQucHVzaChrZXlwYXRoKTtcbiAgXHRcdH1cblxuICBcdFx0cGFyZW50W1wiX1wiICsga2V5cGF0aFN0cl0gKz0gMTtcbiAgXHRcdGtleXBhdGggPSBrZXlwYXRoLnBhcmVudDtcbiAgXHR9XG4gIH1cblxuICB2YXIgcmVsZWFzZSA9IFZpZXdtb2RlbCRyZWxlYXNlO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRyZWxlYXNlKCkge1xuICBcdHJldHVybiB0aGlzLmNhcHR1cmVHcm91cHMucG9wKCk7XG4gIH1cblxuICB2YXIgcmVzZXQgPSBWaWV3bW9kZWwkcmVzZXQ7XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJHJlc2V0KGRhdGEpIHtcbiAgXHR0aGlzLmRhdGEgPSBkYXRhO1xuICBcdHRoaXMuY2xlYXJDYWNoZShcIlwiKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfc2V0ID0gVmlld21vZGVsJHNldDtcblxuICBmdW5jdGlvbiBWaWV3bW9kZWwkc2V0KGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdO1xuXG4gIFx0dmFyIG1hcHBpbmcsIGNvbXB1dGF0aW9uLCB3cmFwcGVyLCBrZWVwRXhpc3RpbmdXcmFwcGVyO1xuXG4gIFx0Ly8gdW5sZXNzIGRhdGEgaXMgYmVpbmcgc2V0IGZvciBkYXRhIHRyYWNraW5nIHB1cnBvc2VzXG4gIFx0aWYgKCFvcHRpb25zLm5vTWFwcGluZykge1xuICBcdFx0Ly8gSWYgdGhpcyBkYXRhIGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgdmlld21vZGVsLFxuICBcdFx0Ly8gcGFzcyB0aGUgY2hhbmdlIGFsb25nXG4gIFx0XHRpZiAobWFwcGluZyA9IHRoaXMubWFwcGluZ3Nba2V5cGF0aC5maXJzdEtleV0pIHtcbiAgXHRcdFx0cmV0dXJuIG1hcHBpbmcuc2V0KGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRjb21wdXRhdGlvbiA9IHRoaXMuY29tcHV0YXRpb25zW2tleXBhdGguc3RyXTtcbiAgXHRpZiAoY29tcHV0YXRpb24pIHtcbiAgXHRcdGlmIChjb21wdXRhdGlvbi5zZXR0aW5nKSB7XG4gIFx0XHRcdC8vIGxldCB0aGUgb3RoZXIgY29tcHV0YXRpb24gc2V0KCkgaGFuZGxlIHRoaW5ncy4uLlxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG4gIFx0XHRjb21wdXRhdGlvbi5zZXQodmFsdWUpO1xuICBcdFx0dmFsdWUgPSBjb21wdXRhdGlvbi5nZXQoKTtcbiAgXHR9XG5cbiAgXHRpZiAoaXNFcXVhbCh0aGlzLmNhY2hlW2tleXBhdGguc3RyXSwgdmFsdWUpKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0d3JhcHBlciA9IHRoaXMud3JhcHBlZFtrZXlwYXRoLnN0cl07XG5cbiAgXHQvLyBJZiB3ZSBoYXZlIGEgd3JhcHBlciB3aXRoIGEgYHJlc2V0KClgIG1ldGhvZCwgd2UgdHJ5IGFuZCB1c2UgaXQuIElmIHRoZVxuICBcdC8vIGByZXNldCgpYCBtZXRob2QgcmV0dXJucyBmYWxzZSwgdGhlIHdyYXBwZXIgc2hvdWxkIGJlIHRvcm4gZG93biwgYW5kXG4gIFx0Ly8gKG1vc3QgbGlrZWx5KSBhIG5ldyBvbmUgc2hvdWxkIGJlIGNyZWF0ZWQgbGF0ZXJcbiAgXHRpZiAod3JhcHBlciAmJiB3cmFwcGVyLnJlc2V0KSB7XG4gIFx0XHRrZWVwRXhpc3RpbmdXcmFwcGVyID0gd3JhcHBlci5yZXNldCh2YWx1ZSkgIT09IGZhbHNlO1xuXG4gIFx0XHRpZiAoa2VlcEV4aXN0aW5nV3JhcHBlcikge1xuICBcdFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCFjb21wdXRhdGlvbiAmJiAha2VlcEV4aXN0aW5nV3JhcHBlcikge1xuICBcdFx0cmVzb2x2ZVNldCh0aGlzLCBrZXlwYXRoLCB2YWx1ZSk7XG4gIFx0fVxuXG4gIFx0aWYgKCFvcHRpb25zLnNpbGVudCkge1xuICBcdFx0dGhpcy5tYXJrKGtleXBhdGgpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBXZSdyZSBzZXR0aW5nIGEgcGFyZW50IG9mIHRoZSBvcmlnaW5hbCB0YXJnZXQga2V5cGF0aCAoaS5lLlxuICBcdFx0Ly8gY3JlYXRpbmcgYSBmcmVzaCBicmFuY2gpIC0gd2UgbmVlZCB0byBjbGVhciB0aGUgY2FjaGUsIGJ1dFxuICBcdFx0Ly8gbm90IG1hcmsgaXQgYXMgYSBjaGFuZ2VcbiAgXHRcdHRoaXMuY2xlYXJDYWNoZShrZXlwYXRoLnN0cik7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNldCh2aWV3bW9kZWwsIGtleXBhdGgsIHZhbHVlKSB7XG4gIFx0dmFyIHdyYXBwZXIsIHBhcmVudFZhbHVlLCB3cmFwcGVyU2V0LCB2YWx1ZVNldDtcblxuICBcdHdyYXBwZXJTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAod3JhcHBlci5zZXQpIHtcbiAgXHRcdFx0d3JhcHBlci5zZXQoa2V5cGF0aC5sYXN0S2V5LCB2YWx1ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRwYXJlbnRWYWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG4gIFx0XHRcdHZhbHVlU2V0KCk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHZhbHVlU2V0ID0gZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCFwYXJlbnRWYWx1ZSkge1xuICBcdFx0XHRwYXJlbnRWYWx1ZSA9IGNyZWF0ZUJyYW5jaChrZXlwYXRoLmxhc3RLZXkpO1xuICBcdFx0XHR2aWV3bW9kZWwuc2V0KGtleXBhdGgucGFyZW50LCBwYXJlbnRWYWx1ZSwgeyBzaWxlbnQ6IHRydWUgfSk7XG4gIFx0XHR9XG4gIFx0XHRwYXJlbnRWYWx1ZVtrZXlwYXRoLmxhc3RLZXldID0gdmFsdWU7XG4gIFx0fTtcblxuICBcdHdyYXBwZXIgPSB2aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnBhcmVudC5zdHJdO1xuXG4gIFx0aWYgKHdyYXBwZXIpIHtcbiAgXHRcdHdyYXBwZXJTZXQoKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cGFyZW50VmFsdWUgPSB2aWV3bW9kZWwuZ2V0KGtleXBhdGgucGFyZW50KTtcblxuICBcdFx0Ly8gbWF5IGhhdmUgYmVlbiB3cmFwcGVkIHZpYSB0aGUgYWJvdmUgLmdldCgpXG4gIFx0XHQvLyBjYWxsIG9uIHZpZXdtb2RlbCBpZiB0aGlzIGlzIGZpcnN0IGFjY2VzcyB2aWEgLnNldCgpIVxuICBcdFx0aWYgKHdyYXBwZXIgPSB2aWV3bW9kZWwud3JhcHBlZFtrZXlwYXRoLnBhcmVudC5zdHJdKSB7XG4gIFx0XHRcdHdyYXBwZXJTZXQoKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHZhbHVlU2V0KCk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIHNtYXJ0VXBkYXRlID0gVmlld21vZGVsJHNtYXJ0VXBkYXRlO1xuXG4gIHZhciBpbXBsaWNpdE9wdGlvbiA9IHsgaW1wbGljaXQ6IHRydWUgfSxcbiAgICAgIG5vQ2FzY2FkZU9wdGlvbiA9IHsgbm9DYXNjYWRlOiB0cnVlIH07XG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCRzbWFydFVwZGF0ZShrZXlwYXRoLCBhcnJheSwgbmV3SW5kaWNlcykge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgZGVwZW5kYW50cywgb2xkTGVuZ3RoLCBpO1xuXG4gIFx0b2xkTGVuZ3RoID0gbmV3SW5kaWNlcy5sZW5ndGg7XG5cbiAgXHQvLyBJbmRpY2VzIHRoYXQgYXJlIGJlaW5nIHJlbW92ZWQgc2hvdWxkIGJlIG1hcmtlZCBhcyBkaXJ0eVxuICBcdG5ld0luZGljZXMuZm9yRWFjaChmdW5jdGlvbiAobmV3SW5kZXgsIG9sZEluZGV4KSB7XG4gIFx0XHRpZiAobmV3SW5kZXggPT09IC0xKSB7XG4gIFx0XHRcdF90aGlzLm1hcmsoa2V5cGF0aC5qb2luKG9sZEluZGV4KSwgbm9DYXNjYWRlT3B0aW9uKTtcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdC8vIFVwZGF0ZSB0aGUgbW9kZWxcbiAgXHQvLyBUT0RPIGFsbG93IGV4aXN0aW5nIGFycmF5IHRvIGJlIHVwZGF0ZWQgaW4gcGxhY2UsIHJhdGhlciB0aGFuIHJlcGxhY2VkP1xuICBcdHRoaXMuc2V0KGtleXBhdGgsIGFycmF5LCB7IHNpbGVudDogdHJ1ZSB9KTtcblxuICBcdGlmIChkZXBlbmRhbnRzID0gdGhpcy5kZXBzW1wiZGVmYXVsdFwiXVtrZXlwYXRoLnN0cl0pIHtcbiAgXHRcdGRlcGVuZGFudHMuZmlsdGVyKGNhblNodWZmbGUpLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgXHRcdFx0cmV0dXJuIGQuc2h1ZmZsZShuZXdJbmRpY2VzLCBhcnJheSk7XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRpZiAob2xkTGVuZ3RoICE9PSBhcnJheS5sZW5ndGgpIHtcbiAgXHRcdHRoaXMubWFyayhrZXlwYXRoLmpvaW4oXCJsZW5ndGhcIiksIGltcGxpY2l0T3B0aW9uKTtcblxuICBcdFx0Zm9yIChpID0gbmV3SW5kaWNlcy50b3VjaGVkRnJvbTsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG4gIFx0XHRcdHRoaXMubWFyayhrZXlwYXRoLmpvaW4oaSkpO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBkb24ndCBhbGxvdyByZW1vdmVkIGluZGV4ZXMgYmV5b25kIGVuZCBvZiBuZXcgYXJyYXkgdG8gdHJpZ2dlciByZWNvbXB1dGF0aW9uc1xuICBcdFx0Ly8gVE9ETyBpcyB0aGlzIHN0aWxsIG5lY2Vzc2FyeSwgbm93IHRoYXQgY29tcHV0YXRpb25zIGFyZSBsYXp5P1xuICBcdFx0Zm9yIChpID0gYXJyYXkubGVuZ3RoOyBpIDwgb2xkTGVuZ3RoOyBpICs9IDEpIHtcbiAgXHRcdFx0dGhpcy5tYXJrKGtleXBhdGguam9pbihpKSwgbm9DYXNjYWRlT3B0aW9uKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBjYW5TaHVmZmxlKGRlcGVuZGFudCkge1xuICBcdHJldHVybiB0eXBlb2YgZGVwZW5kYW50LnNodWZmbGUgPT09IFwiZnVuY3Rpb25cIjtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGVfdGVhcmRvd24gPSBWaWV3bW9kZWwkdGVhcmRvd247XG5cbiAgZnVuY3Rpb24gVmlld21vZGVsJHRlYXJkb3duKCkge1xuICBcdHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgXHR2YXIgdW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeTtcblxuICBcdC8vIENsZWFyIGVudGlyZSBjYWNoZSAtIHRoaXMgaGFzIHRoZSBkZXNpcmVkIHNpZGUtZWZmZWN0XG4gIFx0Ly8gb2YgdW53cmFwcGluZyBhZGFwdGVkIHZhbHVlcyAoZS5nLiBhcnJheXMpXG4gIFx0T2JqZWN0LmtleXModGhpcy5jYWNoZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0cmV0dXJuIF90aGlzLmNsZWFyQ2FjaGUoa2V5cGF0aCk7XG4gIFx0fSk7XG5cbiAgXHQvLyBUZWFyZG93biBhbnkgZmFpbGVkIGxvb2t1cHMgLSB3ZSBkb24ndCBuZWVkIHRoZW0gdG8gcmVzb2x2ZSBhbnkgbW9yZVxuICBcdHdoaWxlICh1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5ID0gdGhpcy51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMucG9wKCkpIHtcbiAgXHRcdHVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kudGVhcmRvd24oKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgdW5yZWdpc3RlciA9IFZpZXdtb2RlbCR1bnJlZ2lzdGVyO1xuXG4gIGZ1bmN0aW9uIFZpZXdtb2RlbCR1bnJlZ2lzdGVyKGtleXBhdGgsIGRlcGVuZGFudCkge1xuICBcdHZhciBncm91cCA9IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gXCJkZWZhdWx0XCIgOiBhcmd1bWVudHNbMl07XG5cbiAgXHR2YXIgbWFwcGluZywgZGVwcywgaW5kZXg7XG5cbiAgXHRpZiAoZGVwZW5kYW50LmlzU3RhdGljKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKG1hcHBpbmcgPSB0aGlzLm1hcHBpbmdzW2tleXBhdGguZmlyc3RLZXldKSB7XG4gIFx0XHRyZXR1cm4gbWFwcGluZy51bnJlZ2lzdGVyKGtleXBhdGgsIGRlcGVuZGFudCwgZ3JvdXApO1xuICBcdH1cblxuICBcdGRlcHMgPSB0aGlzLmRlcHNbZ3JvdXBdW2tleXBhdGguc3RyXTtcbiAgXHRpbmRleCA9IGRlcHMuaW5kZXhPZihkZXBlbmRhbnQpO1xuXG4gIFx0aWYgKGluZGV4ID09PSAtMSkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHJlbW92ZSBhIGRlcGVuZGFudCB0aGF0IHdhcyBubyBsb25nZXIgcmVnaXN0ZXJlZCEgVGhpcyBzaG91bGQgbm90IGhhcHBlbi4gSWYgeW91IGFyZSBzZWVpbmcgdGhpcyBidWcgaW4gZGV2ZWxvcG1lbnQgcGxlYXNlIHJhaXNlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3NcIik7XG4gIFx0fVxuXG4gIFx0ZGVwcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gIFx0aWYgKGtleXBhdGguaXNSb290KSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0dW5yZWdpc3Rlcl9fdXBkYXRlRGVwZW5kYW50c01hcCh0aGlzLCBrZXlwYXRoLCBncm91cCk7XG4gIH1cblxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyX191cGRhdGVEZXBlbmRhbnRzTWFwKHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXApIHtcbiAgXHR2YXIgbWFwLCBwYXJlbnQ7XG5cbiAgXHQvLyB1cGRhdGUgZGVwZW5kYW50cyBtYXBcbiAgXHR3aGlsZSAoIWtleXBhdGguaXNSb290KSB7XG4gIFx0XHRtYXAgPSB2aWV3bW9kZWwuZGVwc01hcFtncm91cF07XG4gIFx0XHRwYXJlbnQgPSBtYXBba2V5cGF0aC5wYXJlbnQuc3RyXTtcblxuICBcdFx0cGFyZW50W1wiX1wiICsga2V5cGF0aC5zdHJdIC09IDE7XG5cbiAgXHRcdGlmICghcGFyZW50W1wiX1wiICsga2V5cGF0aC5zdHJdKSB7XG4gIFx0XHRcdC8vIHJlbW92ZSBmcm9tIHBhcmVudCBkZXBzIG1hcFxuICBcdFx0XHRyZW1vdmVGcm9tQXJyYXkocGFyZW50LCBrZXlwYXRoKTtcbiAgXHRcdFx0cGFyZW50W1wiX1wiICsga2V5cGF0aC5zdHJdID0gdW5kZWZpbmVkO1xuICBcdFx0fVxuXG4gIFx0XHRrZXlwYXRoID0ga2V5cGF0aC5wYXJlbnQ7XG4gIFx0fVxuICB9XG5cbiAgdmFyIFZpZXdtb2RlbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dmFyIGFkYXB0ID0gb3B0aW9ucy5hZGFwdDtcbiAgXHR2YXIgZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgXHR2YXIgcmFjdGl2ZSA9IG9wdGlvbnMucmFjdGl2ZTtcbiAgXHR2YXIgY29tcHV0ZWQgPSBvcHRpb25zLmNvbXB1dGVkO1xuICBcdHZhciBtYXBwaW5ncyA9IG9wdGlvbnMubWFwcGluZ3M7XG4gIFx0dmFyIGtleTtcbiAgXHR2YXIgbWFwcGluZztcblxuICBcdC8vIFRPRE8gaXMgaXQgcG9zc2libGUgdG8gcmVtb3ZlIHRoaXMgcmVmZXJlbmNlP1xuICBcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG5cbiAgXHR0aGlzLmFkYXB0b3JzID0gYWRhcHQ7XG4gIFx0dGhpcy5vbmNoYW5nZSA9IG9wdGlvbnMub25jaGFuZ2U7XG5cbiAgXHR0aGlzLmNhY2hlID0ge307IC8vIHdlIG5lZWQgdG8gYmUgYWJsZSB0byB1c2UgaGFzT3duUHJvcGVydHksIHNvIGNhbid0IGluaGVyaXQgZnJvbSBudWxsXG4gIFx0dGhpcy5jYWNoZU1hcCA9IGNyZWF0ZShudWxsKTtcblxuICBcdHRoaXMuZGVwcyA9IHtcbiAgXHRcdGNvbXB1dGVkOiBjcmVhdGUobnVsbCksXG4gIFx0XHRcImRlZmF1bHRcIjogY3JlYXRlKG51bGwpXG4gIFx0fTtcbiAgXHR0aGlzLmRlcHNNYXAgPSB7XG4gIFx0XHRjb21wdXRlZDogY3JlYXRlKG51bGwpLFxuICBcdFx0XCJkZWZhdWx0XCI6IGNyZWF0ZShudWxsKVxuICBcdH07XG5cbiAgXHR0aGlzLnBhdHRlcm5PYnNlcnZlcnMgPSBbXTtcblxuICBcdHRoaXMuc3BlY2lhbHMgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHR0aGlzLndyYXBwZWQgPSBjcmVhdGUobnVsbCk7XG4gIFx0dGhpcy5jb21wdXRhdGlvbnMgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHR0aGlzLmNhcHR1cmVHcm91cHMgPSBbXTtcbiAgXHR0aGlzLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llcyA9IFtdO1xuXG4gIFx0dGhpcy5jaGFuZ2VzID0gW107XG4gIFx0dGhpcy5pbXBsaWNpdENoYW5nZXMgPSB7fTtcbiAgXHR0aGlzLm5vQ2FzY2FkZSA9IHt9O1xuXG4gIFx0dGhpcy5kYXRhID0gZGF0YTtcblxuICBcdC8vIHNldCB1cCBleHBsaWNpdCBtYXBwaW5nc1xuICBcdHRoaXMubWFwcGluZ3MgPSBjcmVhdGUobnVsbCk7XG4gIFx0Zm9yIChrZXkgaW4gbWFwcGluZ3MpIHtcbiAgXHRcdHRoaXMubWFwKGdldEtleXBhdGgoa2V5KSwgbWFwcGluZ3Nba2V5XSk7XG4gIFx0fVxuXG4gIFx0aWYgKGRhdGEpIHtcbiAgXHRcdC8vIGlmIGRhdGEgZXhpc3RzIGxvY2FsbHksIGJ1dCBpcyBtaXNzaW5nIG9uIHRoZSBwYXJlbnQsXG4gIFx0XHQvLyB3ZSB0cmFuc2ZlciBvd25lcnNoaXAgdG8gdGhlIHBhcmVudFxuICBcdFx0Zm9yIChrZXkgaW4gZGF0YSkge1xuICBcdFx0XHRpZiAoKG1hcHBpbmcgPSB0aGlzLm1hcHBpbmdzW2tleV0pICYmIG1hcHBpbmcuZ2V0VmFsdWUoKSA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0XHRcdFx0bWFwcGluZy5zZXRWYWx1ZShkYXRhW2tleV0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Zm9yIChrZXkgaW4gY29tcHV0ZWQpIHtcbiAgXHRcdGlmIChtYXBwaW5ncyAmJiBrZXkgaW4gbWFwcGluZ3MpIHtcbiAgXHRcdFx0ZmF0YWwoXCJDYW5ub3QgbWFwIHRvIGEgY29tcHV0ZWQgcHJvcGVydHkgKCclcycpXCIsIGtleSk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuY29tcHV0ZShnZXRLZXlwYXRoKGtleSksIGNvbXB1dGVkW2tleV0pO1xuICBcdH1cblxuICBcdHRoaXMucmVhZHkgPSB0cnVlO1xuICB9O1xuXG4gIFZpZXdtb2RlbC5wcm90b3R5cGUgPSB7XG4gIFx0YWRhcHQ6IHByb3RvdHlwZV9hZGFwdCxcbiAgXHRhcHBseUNoYW5nZXM6IGFwcGx5Q2hhbmdlcyxcbiAgXHRjYXB0dXJlOiBjYXB0dXJlLFxuICBcdGNsZWFyQ2FjaGU6IGNsZWFyQ2FjaGUsXG4gIFx0Y29tcHV0ZTogY29tcHV0ZSxcbiAgXHRnZXQ6IHZpZXdtb2RlbF9wcm90b3R5cGVfZ2V0LFxuICBcdGluaXQ6IHZpZXdtb2RlbF9wcm90b3R5cGVfaW5pdCxcbiAgXHRtYXA6IHByb3RvdHlwZV9tYXAsXG4gIFx0bWFyazogbWFyayxcbiAgXHRtZXJnZTogbWVyZ2UsXG4gIFx0cmVnaXN0ZXI6IHJlZ2lzdGVyLFxuICBcdHJlbGVhc2U6IHJlbGVhc2UsXG4gIFx0cmVzZXQ6IHJlc2V0LFxuICBcdHNldDogcHJvdG90eXBlX3NldCxcbiAgXHRzbWFydFVwZGF0ZTogc21hcnRVcGRhdGUsXG4gIFx0dGVhcmRvd246IHByb3RvdHlwZV90ZWFyZG93bixcbiAgXHR1bnJlZ2lzdGVyOiB1bnJlZ2lzdGVyXG4gIH07XG5cbiAgdmFyIHZpZXdtb2RlbF9WaWV3bW9kZWwgPSBWaWV3bW9kZWw7XG5cbiAgZnVuY3Rpb24gSG9va1F1ZXVlKGV2ZW50KSB7XG4gIFx0dGhpcy5ob29rID0gbmV3IGhvb2tzX0hvb2soZXZlbnQpO1xuICBcdHRoaXMuaW5Qcm9jZXNzID0ge307XG4gIFx0dGhpcy5xdWV1ZSA9IHt9O1xuICB9XG5cbiAgSG9va1F1ZXVlLnByb3RvdHlwZSA9IHtcblxuICBcdGNvbnN0cnVjdG9yOiBIb29rUXVldWUsXG5cbiAgXHRiZWdpbjogZnVuY3Rpb24gKHJhY3RpdmUpIHtcbiAgXHRcdHRoaXMuaW5Qcm9jZXNzW3JhY3RpdmUuX2d1aWRdID0gdHJ1ZTtcbiAgXHR9LFxuXG4gIFx0ZW5kOiBmdW5jdGlvbiAocmFjdGl2ZSkge1xuXG4gIFx0XHR2YXIgcGFyZW50ID0gcmFjdGl2ZS5wYXJlbnQ7XG5cbiAgXHRcdC8vIElmIHRoaXMgaXMgKmlzbid0KiBhIGNoaWxkIG9mIGEgY29tcG9uZW50IHRoYXQncyBpbiBwcm9jZXNzLFxuICBcdFx0Ly8gaXQgc2hvdWxkIGNhbGwgbWV0aG9kcyBvciBmaXJlIGF0IHRoaXMgcG9pbnRcbiAgXHRcdGlmICghcGFyZW50IHx8ICF0aGlzLmluUHJvY2Vzc1twYXJlbnQuX2d1aWRdKSB7XG4gIFx0XHRcdGZpcmUodGhpcywgcmFjdGl2ZSk7XG4gIFx0XHR9XG4gIFx0XHQvLyBlbHNld2lzZSwgaGFuZG9mZiB0byBwYXJlbnQgdG8gZmlyZSB3aGVuIHJlYWR5XG4gIFx0XHRlbHNlIHtcbiAgXHRcdFx0Z2V0Q2hpbGRRdWV1ZSh0aGlzLnF1ZXVlLCBwYXJlbnQpLnB1c2gocmFjdGl2ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdGRlbGV0ZSB0aGlzLmluUHJvY2Vzc1tyYWN0aXZlLl9ndWlkXTtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0Q2hpbGRRdWV1ZShxdWV1ZSwgcmFjdGl2ZSkge1xuICBcdHJldHVybiBxdWV1ZVtyYWN0aXZlLl9ndWlkXSB8fCAocXVldWVbcmFjdGl2ZS5fZ3VpZF0gPSBbXSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlKGhvb2tRdWV1ZSwgcmFjdGl2ZSkge1xuXG4gIFx0dmFyIGNoaWxkUXVldWUgPSBnZXRDaGlsZFF1ZXVlKGhvb2tRdWV1ZS5xdWV1ZSwgcmFjdGl2ZSk7XG5cbiAgXHRob29rUXVldWUuaG9vay5maXJlKHJhY3RpdmUpO1xuXG4gIFx0Ly8gcXVldWUgaXMgXCJsaXZlXCIgYmVjYXVzZSBjb21wb25lbnRzIGNhbiBlbmQgdXAgYmVpbmdcbiAgXHQvLyBhZGRlZCB3aGlsZSBob29rcyBmaXJlIG9uIHBhcmVudHMgdGhhdCBtb2RpZnkgZGF0YSB2YWx1ZXMuXG4gIFx0d2hpbGUgKGNoaWxkUXVldWUubGVuZ3RoKSB7XG4gIFx0XHRmaXJlKGhvb2tRdWV1ZSwgY2hpbGRRdWV1ZS5zaGlmdCgpKTtcbiAgXHR9XG5cbiAgXHRkZWxldGUgaG9va1F1ZXVlLnF1ZXVlW3JhY3RpdmUuX2d1aWRdO1xuICB9XG5cbiAgdmFyIGhvb2tzX0hvb2tRdWV1ZSA9IEhvb2tRdWV1ZTtcblxuICB2YXIgaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXMgPSBnZXRDb21wdXRhdGlvblNpZ25hdHVyZXM7XG5cbiAgdmFyIGhlbHBlcnNfZ2V0Q29tcHV0YXRpb25TaWduYXR1cmVzX19wYXR0ZXJuID0gL1xcJFxceyhbXlxcfV0rKVxcfS9nO1xuICBmdW5jdGlvbiBnZXRDb21wdXRhdGlvblNpZ25hdHVyZXMocmFjdGl2ZSwgY29tcHV0ZWQpIHtcbiAgXHR2YXIgc2lnbmF0dXJlcyA9IHt9LFxuICBcdCAgICBrZXk7XG5cbiAgXHRmb3IgKGtleSBpbiBjb21wdXRlZCkge1xuICBcdFx0c2lnbmF0dXJlc1trZXldID0gZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUocmFjdGl2ZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc2lnbmF0dXJlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbXB1dGF0aW9uU2lnbmF0dXJlKHJhY3RpdmUsIGtleSwgc2lnbmF0dXJlKSB7XG4gIFx0dmFyIGdldHRlciwgc2V0dGVyO1xuXG4gIFx0aWYgKHR5cGVvZiBzaWduYXR1cmUgPT09IFwiZnVuY3Rpb25cIikge1xuICBcdFx0Z2V0dGVyID0gaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX2JpbmQoc2lnbmF0dXJlLCByYWN0aXZlKTtcbiAgXHR9XG5cbiAgXHRpZiAodHlwZW9mIHNpZ25hdHVyZSA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0Z2V0dGVyID0gY3JlYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKHJhY3RpdmUsIHNpZ25hdHVyZSk7XG4gIFx0fVxuXG4gIFx0aWYgKHR5cGVvZiBzaWduYXR1cmUgPT09IFwib2JqZWN0XCIpIHtcbiAgXHRcdGlmICh0eXBlb2Ygc2lnbmF0dXJlLmdldCA9PT0gXCJzdHJpbmdcIikge1xuICBcdFx0XHRnZXR0ZXIgPSBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcocmFjdGl2ZSwgc2lnbmF0dXJlLmdldCk7XG4gIFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBzaWduYXR1cmUuZ2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0Z2V0dGVyID0gaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX2JpbmQoc2lnbmF0dXJlLmdldCwgcmFjdGl2ZSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmYXRhbChcImAlc2AgY29tcHV0YXRpb24gbXVzdCBoYXZlIGEgYGdldCgpYCBtZXRob2RcIiwga2V5KTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKHR5cGVvZiBzaWduYXR1cmUuc2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgXHRcdFx0c2V0dGVyID0gaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX2JpbmQoc2lnbmF0dXJlLnNldCwgcmFjdGl2ZSk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHsgZ2V0dGVyOiBnZXR0ZXIsIHNldHRlcjogc2V0dGVyIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcocmFjdGl2ZSwgc3RyKSB7XG4gIFx0dmFyIGZ1bmN0aW9uQm9keSwgaGFzVGhpcywgZm47XG5cbiAgXHRmdW5jdGlvbkJvZHkgPSBcInJldHVybiAoXCIgKyBzdHIucmVwbGFjZShoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlc19fcGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoLCBrZXlwYXRoKSB7XG4gIFx0XHRoYXNUaGlzID0gdHJ1ZTtcbiAgXHRcdHJldHVybiBcIl9fcmFjdGl2ZS5nZXQoXFxcIlwiICsga2V5cGF0aCArIFwiXFxcIilcIjtcbiAgXHR9KSArIFwiKTtcIjtcblxuICBcdGlmIChoYXNUaGlzKSB7XG4gIFx0XHRmdW5jdGlvbkJvZHkgPSBcInZhciBfX3JhY3RpdmUgPSB0aGlzOyBcIiArIGZ1bmN0aW9uQm9keTtcbiAgXHR9XG5cbiAgXHRmbiA9IG5ldyBGdW5jdGlvbihmdW5jdGlvbkJvZHkpO1xuICBcdHJldHVybiBoYXNUaGlzID8gZm4uYmluZChyYWN0aXZlKSA6IGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gaGVscGVyc19nZXRDb21wdXRhdGlvblNpZ25hdHVyZXNfX2JpbmQoZm4sIGNvbnRleHQpIHtcbiAgXHRyZXR1cm4gL3RoaXMvLnRlc3QoZm4udG9TdHJpbmcoKSkgPyBmbi5iaW5kKGNvbnRleHQpIDogZm47XG4gIH1cblxuICB2YXIgY29uc3RydWN0SG9vayA9IG5ldyBob29rc19Ib29rKFwiY29uc3RydWN0XCIpO1xuICB2YXIgY29uZmlnSG9vayA9IG5ldyBob29rc19Ib29rKFwiY29uZmlnXCIpO1xuICB2YXIgaW5pdEhvb2sgPSBuZXcgaG9va3NfSG9va1F1ZXVlKFwiaW5pdFwiKTtcbiAgdmFyIGluaXRpYWxpc2VfX3VpZCA9IDA7XG5cbiAgdmFyIGluaXRpYWxpc2VfX3JlZ2lzdHJ5TmFtZXMgPSBbXCJhZGFwdG9yc1wiLCBcImNvbXBvbmVudHNcIiwgXCJkZWNvcmF0b3JzXCIsIFwiZWFzaW5nXCIsIFwiZXZlbnRzXCIsIFwiaW50ZXJwb2xhdG9yc1wiLCBcInBhcnRpYWxzXCIsIFwidHJhbnNpdGlvbnNcIl07XG5cbiAgdmFyIGluaXRpYWxpc2UgPSBpbml0aWFsaXNlUmFjdGl2ZUluc3RhbmNlO1xuXG4gIGZ1bmN0aW9uIGluaXRpYWxpc2VSYWN0aXZlSW5zdGFuY2UocmFjdGl2ZSkge1xuICBcdHZhciB1c2VyT3B0aW9ucyA9IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG4gIFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdO1xuXG4gIFx0dmFyIGVsLCB2aWV3bW9kZWw7XG5cbiAgXHRpZiAoX1JhY3RpdmUuREVCVUcpIHtcbiAgXHRcdHdlbGNvbWUoKTtcbiAgXHR9XG5cbiAgXHRpbml0aWFsaXNlUHJvcGVydGllcyhyYWN0aXZlLCBvcHRpb25zKTtcblxuICBcdC8vIFRPRE8gcmVtb3ZlIHRoaXMsIGV2ZW50dWFsbHlcbiAgXHRkZWZpbmVQcm9wZXJ0eShyYWN0aXZlLCBcImRhdGFcIiwgeyBnZXQ6IGRlcHJlY2F0ZVJhY3RpdmVEYXRhIH0pO1xuXG4gIFx0Ly8gVE9ETyBkb24ndCBhbGxvdyBgb25jb25zdHJ1Y3RgIHdpdGggYG5ldyBSYWN0aXZlKClgLCB0aGVyZSdzIG5vIG5lZWQgZm9yIGl0XG4gIFx0Y29uc3RydWN0SG9vay5maXJlKHJhY3RpdmUsIHVzZXJPcHRpb25zKTtcblxuICBcdC8vIEFkZCByZWdpc3RyaWVzXG4gIFx0aW5pdGlhbGlzZV9fcmVnaXN0cnlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIFx0XHRyYWN0aXZlW25hbWVdID0gdXRpbHNfb2JqZWN0X19leHRlbmQoY3JlYXRlKHJhY3RpdmUuY29uc3RydWN0b3JbbmFtZV0gfHwgbnVsbCksIHVzZXJPcHRpb25zW25hbWVdKTtcbiAgXHR9KTtcblxuICBcdC8vIENyZWF0ZSBhIHZpZXdtb2RlbFxuICBcdHZpZXdtb2RlbCA9IG5ldyB2aWV3bW9kZWxfVmlld21vZGVsKHtcbiAgXHRcdGFkYXB0OiBnZXRBZGFwdG9ycyhyYWN0aXZlLCByYWN0aXZlLmFkYXB0LCB1c2VyT3B0aW9ucyksXG4gIFx0XHRkYXRhOiBjdXN0b21fZGF0YS5pbml0KHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUsIHVzZXJPcHRpb25zKSxcbiAgXHRcdGNvbXB1dGVkOiBoZWxwZXJzX2dldENvbXB1dGF0aW9uU2lnbmF0dXJlcyhyYWN0aXZlLCB1dGlsc19vYmplY3RfX2V4dGVuZChjcmVhdGUocmFjdGl2ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcHV0ZWQpLCB1c2VyT3B0aW9ucy5jb21wdXRlZCkpLFxuICBcdFx0bWFwcGluZ3M6IG9wdGlvbnMubWFwcGluZ3MsXG4gIFx0XHRyYWN0aXZlOiByYWN0aXZlLFxuICBcdFx0b25jaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuIGdsb2JhbF9ydW5sb29wLmFkZFJhY3RpdmUocmFjdGl2ZSk7XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHRyYWN0aXZlLnZpZXdtb2RlbCA9IHZpZXdtb2RlbDtcblxuICBcdC8vIFRoaXMgY2FuJ3QgaGFwcGVuIGVhcmxpZXIsIGJlY2F1c2UgY29tcHV0ZWQgcHJvcGVydGllcyBtYXkgY2FsbCBgcmFjdGl2ZS5nZXQoKWAsIGV0Y1xuICBcdHZpZXdtb2RlbC5pbml0KCk7XG5cbiAgXHQvLyBpbml0IGNvbmZpZyBmcm9tIFBhcmVudCBhbmQgb3B0aW9uc1xuICBcdGNvbmZpZ19jb25maWcuaW5pdChyYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCB1c2VyT3B0aW9ucyk7XG5cbiAgXHRjb25maWdIb29rLmZpcmUocmFjdGl2ZSk7XG4gIFx0aW5pdEhvb2suYmVnaW4ocmFjdGl2ZSk7XG5cbiAgXHQvLyAvLyBJZiB0aGlzIGlzIGEgY29tcG9uZW50IHdpdGggYSBmdW5jdGlvbiBgZGF0YWAgcHJvcGVydHksIGNhbGwgdGhlIGZ1bmN0aW9uXG4gIFx0Ly8gLy8gd2l0aCBgcmFjdGl2ZWAgYXMgY29udGV4dCAodW5sZXNzIHRoZSBjaGlsZCB3YXMgYWxzbyBhIGZ1bmN0aW9uKVxuICBcdC8vIGlmICggdHlwZW9mIHJhY3RpdmUuY29uc3RydWN0b3IucHJvdG90eXBlLmRhdGEgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHVzZXJPcHRpb25zLmRhdGEgIT09ICdmdW5jdGlvbicgKSB7XG4gIFx0Ly8gXHR2aWV3bW9kZWwucmVzZXQoIHJhY3RpdmUuY29uc3RydWN0b3IucHJvdG90eXBlLmRhdGEuY2FsbCggcmFjdGl2ZSApIHx8IGZhdGFsKCAnYGRhdGFgIGZ1bmN0aW9ucyBtdXN0IHJldHVybiBhIGRhdGEgb2JqZWN0JyApICk7XG4gIFx0Ly8gfVxuXG4gIFx0Ly8gUmVuZGVyIHZpcnR1YWwgRE9NXG4gIFx0aWYgKHJhY3RpdmUudGVtcGxhdGUpIHtcbiAgXHRcdHZhciBjc3NJZHMgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdGlmIChvcHRpb25zLmNzc0lkcyB8fCByYWN0aXZlLmNzc0lkKSB7XG4gIFx0XHRcdGNzc0lkcyA9IG9wdGlvbnMuY3NzSWRzID8gb3B0aW9ucy5jc3NJZHMuc2xpY2UoKSA6IFtdO1xuXG4gIFx0XHRcdGlmIChyYWN0aXZlLmNzc0lkKSB7XG4gIFx0XHRcdFx0Y3NzSWRzLnB1c2gocmFjdGl2ZS5jc3NJZCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmFjdGl2ZS5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdFx0dGVtcGxhdGU6IHJhY3RpdmUudGVtcGxhdGUsXG4gIFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiByYWN0aXZlLCAvLyBzYXZlcyBkb2luZyBgaWYgKCB0aGlzLnBhcmVudCApIHsgLyouLi4qLyB9YCBsYXRlciBvblxuICBcdFx0XHRjc3NJZHM6IGNzc0lkc1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0aW5pdEhvb2suZW5kKHJhY3RpdmUpO1xuXG4gIFx0Ly8gcmVuZGVyIGF1dG9tYXRpY2FsbHkgKCBpZiBgZWxgIGlzIHNwZWNpZmllZCApXG4gIFx0aWYgKGVsID0gZ2V0RWxlbWVudChyYWN0aXZlLmVsKSkge1xuICBcdFx0dmFyIHByb21pc2UgPSByYWN0aXZlLnJlbmRlcihlbCwgcmFjdGl2ZS5hcHBlbmQpO1xuXG4gIFx0XHRpZiAoX1JhY3RpdmUuREVCVUdfUFJPTUlTRVMpIHtcbiAgXHRcdFx0cHJvbWlzZVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgXHRcdFx0XHR3YXJuT25jZUlmRGVidWcoXCJQcm9taXNlIGRlYnVnZ2luZyBpcyBlbmFibGVkLCB0byBoZWxwIHNvbHZlIGVycm9ycyB0aGF0IGhhcHBlbiBhc3luY2hyb25vdXNseS4gU29tZSBicm93c2VycyB3aWxsIGxvZyB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25zLCBpbiB3aGljaCBjYXNlIHlvdSBjYW4gc2FmZWx5IGRpc2FibGUgcHJvbWlzZSBkZWJ1Z2dpbmc6XFxuICBSYWN0aXZlLkRFQlVHX1BST01JU0VTID0gZmFsc2U7XCIpO1xuICBcdFx0XHRcdHdhcm5JZkRlYnVnKFwiQW4gZXJyb3IgaGFwcGVuZWQgZHVyaW5nIHJlbmRlcmluZ1wiLCB7IHJhY3RpdmU6IHJhY3RpdmUgfSk7XG4gIFx0XHRcdFx0ZXJyLnN0YWNrICYmIGxvZ0lmRGVidWcoZXJyLnN0YWNrKTtcblxuICBcdFx0XHRcdHRocm93IGVycjtcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QWRhcHRvcnMocmFjdGl2ZSwgcHJvdG9BZGFwdCwgdXNlck9wdGlvbnMpIHtcbiAgXHR2YXIgYWRhcHQsIG1hZ2ljLCBtb2RpZnlBcnJheXM7XG5cbiAgXHRwcm90b0FkYXB0ID0gcHJvdG9BZGFwdC5tYXAobG9va3VwKTtcbiAgXHRhZGFwdCA9IGVuc3VyZUFycmF5KHVzZXJPcHRpb25zLmFkYXB0KS5tYXAobG9va3VwKTtcblxuICBcdGFkYXB0ID0gaW5pdGlhbGlzZV9fY29tYmluZShwcm90b0FkYXB0LCBhZGFwdCk7XG5cbiAgXHRtYWdpYyA9IFwibWFnaWNcIiBpbiB1c2VyT3B0aW9ucyA/IHVzZXJPcHRpb25zLm1hZ2ljIDogcmFjdGl2ZS5tYWdpYztcbiAgXHRtb2RpZnlBcnJheXMgPSBcIm1vZGlmeUFycmF5c1wiIGluIHVzZXJPcHRpb25zID8gdXNlck9wdGlvbnMubW9kaWZ5QXJyYXlzIDogcmFjdGl2ZS5tb2RpZnlBcnJheXM7XG5cbiAgXHRpZiAobWFnaWMpIHtcbiAgXHRcdGlmICghZW52aXJvbm1lbnRfX21hZ2ljKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkdldHRlcnMgYW5kIHNldHRlcnMgKG1hZ2ljIG1vZGUpIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKG1vZGlmeUFycmF5cykge1xuICBcdFx0XHRhZGFwdC5wdXNoKG1hZ2ljQXJyYXkpO1xuICBcdFx0fVxuXG4gIFx0XHRhZGFwdC5wdXNoKGFkYXB0b3JzX21hZ2ljKTtcbiAgXHR9XG5cbiAgXHRpZiAobW9kaWZ5QXJyYXlzKSB7XG4gIFx0XHRhZGFwdC5wdXNoKGFycmF5X2luZGV4KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYWRhcHQ7XG5cbiAgXHRmdW5jdGlvbiBsb29rdXAoYWRhcHRvcikge1xuICBcdFx0aWYgKHR5cGVvZiBhZGFwdG9yID09PSBcInN0cmluZ1wiKSB7XG4gIFx0XHRcdGFkYXB0b3IgPSBmaW5kSW5WaWV3SGllcmFyY2h5KFwiYWRhcHRvcnNcIiwgcmFjdGl2ZSwgYWRhcHRvcik7XG5cbiAgXHRcdFx0aWYgKCFhZGFwdG9yKSB7XG4gIFx0XHRcdFx0ZmF0YWwobWlzc2luZ1BsdWdpbihhZGFwdG9yLCBcImFkYXB0b3JcIikpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBhZGFwdG9yO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpc2VfX2NvbWJpbmUoYSwgYikge1xuICBcdHZhciBjID0gYS5zbGljZSgpLFxuICBcdCAgICBpID0gYi5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoISB+Yy5pbmRleE9mKGJbaV0pKSB7XG4gIFx0XHRcdGMucHVzaChiW2ldKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gYztcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpc2VQcm9wZXJ0aWVzKHJhY3RpdmUsIG9wdGlvbnMpIHtcbiAgXHQvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpZGVudGlmaWVyLCBmb3IgcGxhY2VzIHdoZXJlIHlvdSdkIHVzZSBhIHdlYWsgbWFwIGlmIGl0XG4gIFx0Ly8gZXhpc3RlZFxuICBcdHJhY3RpdmUuX2d1aWQgPSBcInItXCIgKyBpbml0aWFsaXNlX191aWQrKztcblxuICBcdC8vIGV2ZW50c1xuICBcdHJhY3RpdmUuX3N1YnMgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHQvLyBzdG9yYWdlIGZvciBpdGVtIGNvbmZpZ3VyYXRpb24gZnJvbSBpbnN0YW50aWF0aW9uIHRvIHJlc2V0LFxuICBcdC8vIGxpa2UgZHluYW1pYyBmdW5jdGlvbnMgb3Igb3JpZ2luYWwgdmFsdWVzXG4gIFx0cmFjdGl2ZS5fY29uZmlnID0ge307XG5cbiAgXHQvLyB0d28td2F5IGJpbmRpbmdzXG4gIFx0cmFjdGl2ZS5fdHdvd2F5QmluZGluZ3MgPSBjcmVhdGUobnVsbCk7XG5cbiAgXHQvLyBhbmltYXRpb25zIChzbyB3ZSBjYW4gc3RvcCBhbnkgaW4gcHJvZ3Jlc3MgYXQgdGVhcmRvd24pXG4gIFx0cmFjdGl2ZS5fYW5pbWF0aW9ucyA9IFtdO1xuXG4gIFx0Ly8gbm9kZXMgcmVnaXN0cnlcbiAgXHRyYWN0aXZlLm5vZGVzID0ge307XG5cbiAgXHQvLyBsaXZlIHF1ZXJpZXNcbiAgXHRyYWN0aXZlLl9saXZlUXVlcmllcyA9IFtdO1xuICBcdHJhY3RpdmUuX2xpdmVDb21wb25lbnRRdWVyaWVzID0gW107XG5cbiAgXHQvLyBib3VuZCBkYXRhIGZ1bmN0aW9uc1xuICBcdHJhY3RpdmUuX2JvdW5kRnVuY3Rpb25zID0gW107XG5cbiAgXHQvLyBvYnNlcnZlcnNcbiAgXHRyYWN0aXZlLl9vYnNlcnZlcnMgPSBbXTtcblxuICBcdC8vIHByb3BlcnRpZXMgc3BlY2lmaWMgdG8gaW5saW5lIGNvbXBvbmVudHNcbiAgXHRpZiAob3B0aW9ucy5jb21wb25lbnQpIHtcbiAgXHRcdHJhY3RpdmUucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIFx0XHRyYWN0aXZlLmNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyIHx8IG51bGw7XG4gIFx0XHRyYWN0aXZlLnJvb3QgPSByYWN0aXZlLnBhcmVudC5yb290O1xuXG4gIFx0XHRyYWN0aXZlLmNvbXBvbmVudCA9IG9wdGlvbnMuY29tcG9uZW50O1xuICBcdFx0b3B0aW9ucy5jb21wb25lbnQuaW5zdGFuY2UgPSByYWN0aXZlO1xuXG4gIFx0XHQvLyBmb3IgaGFja2FiaWxpdHksIHRoaXMgY291bGQgYmUgYW4gb3BlbiBvcHRpb25cbiAgXHRcdC8vIGZvciBhbnkgcmFjdGl2ZSBpbnN0YW5jZSwgYnV0IGZvciBub3csIGp1c3RcbiAgXHRcdC8vIGZvciBjb21wb25lbnRzIGFuZCBqdXN0IGZvciByYWN0aXZlLi4uXG4gIFx0XHRyYWN0aXZlLl9pbmxpbmVQYXJ0aWFscyA9IG9wdGlvbnMuaW5saW5lUGFydGlhbHM7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJhY3RpdmUucm9vdCA9IHJhY3RpdmU7XG4gIFx0XHRyYWN0aXZlLnBhcmVudCA9IHJhY3RpdmUuY29udGFpbmVyID0gbnVsbDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBkZXByZWNhdGVSYWN0aXZlRGF0YSgpIHtcbiAgXHR0aHJvdyBuZXcgRXJyb3IoXCJVc2luZyBgcmFjdGl2ZS5kYXRhYCBpcyBubyBsb25nZXIgc3VwcG9ydGVkIC0geW91IG11c3QgdXNlIHRoZSBgcmFjdGl2ZS5nZXQoKWAgQVBJIGluc3RlYWRcIik7XG4gIH1cblxuICBmdW5jdGlvbiBDb21wbGV4UGFyYW1ldGVyKGNvbXBvbmVudCwgdGVtcGxhdGUsIGNhbGxiYWNrKSB7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuICBcdFx0cm9vdDogY29tcG9uZW50LnJvb3QsXG4gIFx0XHRvd25lcjogdGhpc1xuICBcdH0pO1xuXG4gIFx0dGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHZhciBpbml0aWFsaXNlX0NvbXBsZXhQYXJhbWV0ZXIgPSBDb21wbGV4UGFyYW1ldGVyO1xuXG4gIENvbXBsZXhQYXJhbWV0ZXIucHJvdG90eXBlID0ge1xuICBcdGJ1YmJsZTogZnVuY3Rpb24gKCkge1xuICBcdFx0aWYgKCF0aGlzLmRpcnR5KSB7XG4gIFx0XHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuICBcdFx0XHRnbG9iYWxfcnVubG9vcC5hZGRWaWV3KHRoaXMpO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuY2FsbGJhY2sodGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpKTtcbiAgXHRcdHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHVuYmluZDogZnVuY3Rpb24gKCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgQ29tcG9uZW50LCBhdHRyaWJ1dGVzLCB5aWVsZFRlbXBsYXRlLCBwYXJ0aWFscykge1xuICBcdHZhciBpbnN0YW5jZSxcbiAgXHQgICAgcGFyZW50RnJhZ21lbnQsXG4gIFx0ICAgIHJhY3RpdmUsXG4gIFx0ICAgIGZyYWdtZW50LFxuICBcdCAgICBjb250YWluZXIsXG4gIFx0ICAgIGlubGluZVBhcnRpYWxzID0ge30sXG4gIFx0ICAgIGRhdGEgPSB7fSxcbiAgXHQgICAgbWFwcGluZ3MgPSB7fSxcbiAgXHQgICAgcmVhZHksXG4gIFx0ICAgIHJlc29sdmVycyA9IFtdO1xuXG4gIFx0cGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG4gIFx0cmFjdGl2ZSA9IGNvbXBvbmVudC5yb290O1xuXG4gIFx0cGFydGlhbHMgPSBwYXJ0aWFscyB8fCB7fTtcbiAgXHR1dGlsc19vYmplY3RfX2V4dGVuZChpbmxpbmVQYXJ0aWFscywgcGFydGlhbHMpO1xuXG4gIFx0Ly8gTWFrZSBjb250ZW50cyBhdmFpbGFibGUgYXMgYSB7ez5jb250ZW50fX0gcGFydGlhbFxuICBcdHBhcnRpYWxzLmNvbnRlbnQgPSB5aWVsZFRlbXBsYXRlIHx8IFtdO1xuXG4gIFx0Ly8gc2V0IGEgZGVmYXVsdCBwYXJ0aWFsIGZvciB5aWVsZHMgd2l0aCBubyBuYW1lXG4gIFx0aW5saW5lUGFydGlhbHNbXCJcIl0gPSBwYXJ0aWFscy5jb250ZW50O1xuXG4gIFx0aWYgKENvbXBvbmVudC5kZWZhdWx0cy5lbCkge1xuICBcdFx0d2FybklmRGVidWcoXCJUaGUgPCVzLz4gY29tcG9uZW50IGhhcyBhIGRlZmF1bHQgYGVsYCBwcm9wZXJ0eTsgaXQgaGFzIGJlZW4gZGlzcmVnYXJkZWRcIiwgY29tcG9uZW50Lm5hbWUpO1xuICBcdH1cblxuICBcdC8vIGZpbmQgY29udGFpbmVyXG4gIFx0ZnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcbiAgXHR3aGlsZSAoZnJhZ21lbnQpIHtcbiAgXHRcdGlmIChmcmFnbWVudC5vd25lci50eXBlID09PSBZSUVMREVSKSB7XG4gIFx0XHRcdGNvbnRhaW5lciA9IGZyYWdtZW50Lm93bmVyLmNvbnRhaW5lcjtcbiAgXHRcdFx0YnJlYWs7XG4gIFx0XHR9XG5cbiAgXHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuICBcdH1cblxuICBcdC8vIGVhY2ggYXR0cmlidXRlIHJlcHJlc2VudHMgZWl0aGVyIGEpIGRhdGEgb3IgYikgYSBtYXBwaW5nXG4gIFx0aWYgKGF0dHJpYnV0ZXMpIHtcbiAgXHRcdE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBcdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXldLFxuICBcdFx0XHQgICAgcGFyc2VkLFxuICBcdFx0XHQgICAgcmVzb2x2ZXI7XG5cbiAgXHRcdFx0aWYgKHR5cGVvZiBhdHRyaWJ1dGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdFx0XHQvLyBpdCdzIHN0YXRpYyBkYXRhXG4gIFx0XHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKGF0dHJpYnV0ZSk7XG4gIFx0XHRcdFx0ZGF0YVtrZXldID0gcGFyc2VkID8gcGFyc2VkLnZhbHVlIDogYXR0cmlidXRlO1xuICBcdFx0XHR9IGVsc2UgaWYgKGF0dHJpYnV0ZSA9PT0gMCkge1xuICBcdFx0XHRcdC8vIGl0IGhhZCBubyAnPScsIHNvIHdlJ2xsIGNhbGwgaXQgdHJ1ZVxuICBcdFx0XHRcdGRhdGFba2V5XSA9IHRydWU7XG4gIFx0XHRcdH0gZWxzZSBpZiAoaXNBcnJheShhdHRyaWJ1dGUpKSB7XG4gIFx0XHRcdFx0Ly8gdGhpcyByZXByZXNlbnRzIGR5bmFtaWMgZGF0YVxuICBcdFx0XHRcdGlmIChpc1NpbmdsZUludGVycG9sYXRvcihhdHRyaWJ1dGUpKSB7XG4gIFx0XHRcdFx0XHRtYXBwaW5nc1trZXldID0ge1xuICBcdFx0XHRcdFx0XHRvcmlnaW46IGNvbXBvbmVudC5yb290LnZpZXdtb2RlbCxcbiAgXHRcdFx0XHRcdFx0a2V5cGF0aDogdW5kZWZpbmVkXG4gIFx0XHRcdFx0XHR9O1xuXG4gIFx0XHRcdFx0XHRyZXNvbHZlciA9IGNyZWF0ZVJlc29sdmVyKGNvbXBvbmVudCwgYXR0cmlidXRlWzBdLCBmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRcdFx0XHRpZiAoa2V5cGF0aC5pc1NwZWNpYWwpIHtcbiAgXHRcdFx0XHRcdFx0XHRpZiAocmVhZHkpIHtcbiAgXHRcdFx0XHRcdFx0XHRcdGluc3RhbmNlLnNldChrZXksIGtleXBhdGgudmFsdWUpOyAvLyBUT0RPIHVzZSB2aWV3bW9kZWw/XG4gIFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRcdGRhdGFba2V5XSA9IGtleXBhdGgudmFsdWU7XG5cbiAgXHRcdFx0XHRcdFx0XHRcdC8vIFRPRE8gZXJyci4uLi4gd291bGQgYmUgYmV0dGVyIGlmIHdlIGRpZG4ndCBoYXZlIHRvIGRvIHRoaXNcbiAgXHRcdFx0XHRcdFx0XHRcdGRlbGV0ZSBtYXBwaW5nc1trZXldO1xuICBcdFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRpZiAocmVhZHkpIHtcbiAgXHRcdFx0XHRcdFx0XHRcdGluc3RhbmNlLnZpZXdtb2RlbC5tYXBwaW5nc1trZXldLnJlc29sdmUoa2V5cGF0aCk7XG4gIFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRcdC8vIHJlc29sdmVkIGltbWVkaWF0ZWx5XG4gIFx0XHRcdFx0XHRcdFx0XHRtYXBwaW5nc1trZXldLmtleXBhdGggPSBrZXlwYXRoO1xuICBcdFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdHJlc29sdmVyID0gbmV3IGluaXRpYWxpc2VfQ29tcGxleFBhcmFtZXRlcihjb21wb25lbnQsIGF0dHJpYnV0ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gIFx0XHRcdFx0XHRcdGlmIChyZWFkeSkge1xuICBcdFx0XHRcdFx0XHRcdGluc3RhbmNlLnNldChrZXksIHZhbHVlKTsgLy8gVE9ETyB1c2Ugdmlld21vZGVsP1xuICBcdFx0XHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0XHRcdGRhdGFba2V5XSA9IHZhbHVlO1xuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRyZXNvbHZlcnMucHVzaChyZXNvbHZlcik7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZXJtIHd1dFwiKTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0aW5zdGFuY2UgPSBjcmVhdGUoQ29tcG9uZW50LnByb3RvdHlwZSk7XG5cbiAgXHRpbml0aWFsaXNlKGluc3RhbmNlLCB7XG4gIFx0XHRlbDogbnVsbCxcbiAgXHRcdGFwcGVuZDogdHJ1ZSxcbiAgXHRcdGRhdGE6IGRhdGEsXG4gIFx0XHRwYXJ0aWFsczogcGFydGlhbHMsXG4gIFx0XHRtYWdpYzogcmFjdGl2ZS5tYWdpYyB8fCBDb21wb25lbnQuZGVmYXVsdHMubWFnaWMsXG4gIFx0XHRtb2RpZnlBcnJheXM6IHJhY3RpdmUubW9kaWZ5QXJyYXlzLFxuICBcdFx0Ly8gbmVlZCB0byBpbmhlcml0IHJ1bnRpbWUgcGFyZW50IGFkYXB0b3JzXG4gIFx0XHRhZGFwdDogcmFjdGl2ZS5hZGFwdFxuICBcdH0sIHtcbiAgXHRcdHBhcmVudDogcmFjdGl2ZSxcbiAgXHRcdGNvbXBvbmVudDogY29tcG9uZW50LFxuICBcdFx0Y29udGFpbmVyOiBjb250YWluZXIsXG4gIFx0XHRtYXBwaW5nczogbWFwcGluZ3MsXG4gIFx0XHRpbmxpbmVQYXJ0aWFsczogaW5saW5lUGFydGlhbHMsXG4gIFx0XHRjc3NJZHM6IHBhcmVudEZyYWdtZW50LmNzc0lkc1xuICBcdH0pO1xuXG4gIFx0cmVhZHkgPSB0cnVlO1xuICBcdGNvbXBvbmVudC5yZXNvbHZlcnMgPSByZXNvbHZlcnM7XG5cbiAgXHRyZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVzb2x2ZXIoY29tcG9uZW50LCB0ZW1wbGF0ZSwgY2FsbGJhY2spIHtcbiAgXHR2YXIgcmVzb2x2ZXI7XG5cbiAgXHRpZiAodGVtcGxhdGUucikge1xuICBcdFx0cmVzb2x2ZXIgPSBSZXNvbHZlcnNfY3JlYXRlUmVmZXJlbmNlUmVzb2x2ZXIoY29tcG9uZW50LCB0ZW1wbGF0ZS5yLCBjYWxsYmFjayk7XG4gIFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS54KSB7XG4gIFx0XHRyZXNvbHZlciA9IG5ldyBSZXNvbHZlcnNfRXhwcmVzc2lvblJlc29sdmVyKGNvbXBvbmVudCwgY29tcG9uZW50LnBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZS54LCBjYWxsYmFjayk7XG4gIFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS5yeCkge1xuICBcdFx0cmVzb2x2ZXIgPSBuZXcgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyX1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcihjb21wb25lbnQsIHRlbXBsYXRlLnJ4LCBjYWxsYmFjayk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc29sdmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTaW5nbGVJbnRlcnBvbGF0b3IodGVtcGxhdGUpIHtcbiAgXHRyZXR1cm4gdGVtcGxhdGUubGVuZ3RoID09PSAxICYmIHRlbXBsYXRlWzBdLnQgPT09IElOVEVSUE9MQVRPUjtcbiAgfVxuXG4gIC8vIFRPRE8gaG93IHNob3VsZCBldmVudCBhcmd1bWVudHMgYmUgaGFuZGxlZD8gZS5nLlxuICAvLyA8d2lkZ2V0IG9uLWZvbz0nYmFyOjEsMiwzJy8+XG4gIC8vIFRoZSBldmVudCAnYmFyJyB3aWxsIGJlIGZpcmVkIG9uIHRoZSBwYXJlbnQgaW5zdGFuY2VcbiAgLy8gd2hlbiAnZm9vJyBmaXJlcyBvbiB0aGUgY2hpbGQsIGJ1dCB0aGUgMSwyLDMgYXJndW1lbnRzXG4gIC8vIHdpbGwgYmUgbG9zdFxuXG4gIHZhciBpbml0aWFsaXNlX3Byb3BhZ2F0ZUV2ZW50cyA9IHByb3BhZ2F0ZUV2ZW50cztcblxuICBmdW5jdGlvbiBwcm9wYWdhdGVFdmVudHMoY29tcG9uZW50LCBldmVudHNEZXNjcmlwdG9yKSB7XG4gIFx0dmFyIGV2ZW50TmFtZTtcblxuICBcdGZvciAoZXZlbnROYW1lIGluIGV2ZW50c0Rlc2NyaXB0b3IpIHtcbiAgXHRcdGlmIChldmVudHNEZXNjcmlwdG9yLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgXHRcdFx0cHJvcGFnYXRlRXZlbnQoY29tcG9uZW50Lmluc3RhbmNlLCBjb21wb25lbnQucm9vdCwgZXZlbnROYW1lLCBldmVudHNEZXNjcmlwdG9yW2V2ZW50TmFtZV0pO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3BhZ2F0ZUV2ZW50KGNoaWxkSW5zdGFuY2UsIHBhcmVudEluc3RhbmNlLCBldmVudE5hbWUsIHByb3h5RXZlbnROYW1lKSB7XG4gIFx0aWYgKHR5cGVvZiBwcm94eUV2ZW50TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICBcdFx0ZmF0YWwoXCJDb21wb25lbnRzIGN1cnJlbnRseSBvbmx5IHN1cHBvcnQgc2ltcGxlIGV2ZW50cyAtIHlvdSBjYW5ub3QgaW5jbHVkZSBhcmd1bWVudHMuIFNvcnJ5IVwiKTtcbiAgXHR9XG5cbiAgXHRjaGlsZEluc3RhbmNlLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGV2ZW50LCBhcmdzO1xuXG4gIFx0XHQvLyBzZW1pLXdlYWsgdGVzdCwgYnV0IHdoYXQgZWxzZT8gdGFnIHRoZSBldmVudCBvYmogLl9pc0V2ZW50ID9cbiAgXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoICYmIGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF0ubm9kZSkge1xuICBcdFx0XHRldmVudCA9IEFycmF5LnByb3RvdHlwZS5zaGlmdC5jYWxsKGFyZ3VtZW50cyk7XG4gIFx0XHR9XG5cbiAgXHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIFx0XHRzaGFyZWRfZmlyZUV2ZW50KHBhcmVudEluc3RhbmNlLCBwcm94eUV2ZW50TmFtZSwgeyBldmVudDogZXZlbnQsIGFyZ3M6IGFyZ3MgfSk7XG5cbiAgXHRcdC8vIGNhbmNlbCBidWJibGluZ1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH0pO1xuICB9XG5cbiAgdmFyIGluaXRpYWxpc2VfdXBkYXRlTGl2ZVF1ZXJpZXMgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gIFx0dmFyIGFuY2VzdG9yLCBxdWVyeTtcblxuICBcdC8vIElmIHRoZXJlJ3MgYSBsaXZlIHF1ZXJ5IGZvciB0aGlzIGNvbXBvbmVudCB0eXBlLCBhZGQgaXRcbiAgXHRhbmNlc3RvciA9IGNvbXBvbmVudC5yb290O1xuICBcdHdoaWxlIChhbmNlc3Rvcikge1xuICBcdFx0aWYgKHF1ZXJ5ID0gYW5jZXN0b3IuX2xpdmVDb21wb25lbnRRdWVyaWVzW1wiX1wiICsgY29tcG9uZW50Lm5hbWVdKSB7XG4gIFx0XHRcdHF1ZXJ5LnB1c2goY29tcG9uZW50Lmluc3RhbmNlKTtcbiAgXHRcdH1cblxuICBcdFx0YW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX2luaXQgPSBDb21wb25lbnQkaW5pdDtcbiAgZnVuY3Rpb24gQ29tcG9uZW50JGluaXQob3B0aW9ucywgQ29tcG9uZW50KSB7XG4gIFx0dmFyIHBhcmVudEZyYWdtZW50LCByb290O1xuXG4gIFx0aWYgKCFDb21wb25lbnQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkNvbXBvbmVudCBcXFwiXCIgKyB0aGlzLm5hbWUgKyBcIlxcXCIgbm90IGZvdW5kXCIpO1xuICBcdH1cblxuICBcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG4gIFx0cm9vdCA9IHBhcmVudEZyYWdtZW50LnJvb3Q7XG5cbiAgXHR0aGlzLnJvb3QgPSByb290O1xuICBcdHRoaXMudHlwZSA9IENPTVBPTkVOVDtcbiAgXHR0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLmU7XG4gIFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG4gIFx0dGhpcy5pbmRleFJlZkJpbmRpbmdzID0ge307XG4gIFx0dGhpcy55aWVsZGVycyA9IHt9O1xuICBcdHRoaXMucmVzb2x2ZXJzID0gW107XG5cbiAgXHRjcmVhdGVJbnN0YW5jZSh0aGlzLCBDb21wb25lbnQsIG9wdGlvbnMudGVtcGxhdGUuYSwgb3B0aW9ucy50ZW1wbGF0ZS5mLCBvcHRpb25zLnRlbXBsYXRlLnApO1xuICBcdGluaXRpYWxpc2VfcHJvcGFnYXRlRXZlbnRzKHRoaXMsIG9wdGlvbnMudGVtcGxhdGUudik7XG5cbiAgXHQvLyBpbnRybywgb3V0cm8gYW5kIGRlY29yYXRvciBkaXJlY3RpdmVzIGhhdmUgbm8gZWZmZWN0XG4gIFx0aWYgKG9wdGlvbnMudGVtcGxhdGUudDAgfHwgb3B0aW9ucy50ZW1wbGF0ZS50MSB8fCBvcHRpb25zLnRlbXBsYXRlLnQyIHx8IG9wdGlvbnMudGVtcGxhdGUubykge1xuICBcdFx0d2FybklmRGVidWcoXCJUaGUgXFxcImludHJvXFxcIiwgXFxcIm91dHJvXFxcIiBhbmQgXFxcImRlY29yYXRvclxcXCIgZGlyZWN0aXZlcyBoYXZlIG5vIGVmZmVjdCBvbiBjb21wb25lbnRzXCIsIHsgcmFjdGl2ZTogdGhpcy5pbnN0YW5jZSB9KTtcbiAgXHR9XG5cbiAgXHRpbml0aWFsaXNlX3VwZGF0ZUxpdmVRdWVyaWVzKHRoaXMpO1xuICB9XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfcmViaW5kID0gQ29tcG9uZW50JHJlYmluZDtcblxuICBmdW5jdGlvbiBDb21wb25lbnQkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcbiAgXHR2YXIgcXVlcnk7XG5cbiAgXHR0aGlzLnJlc29sdmVycy5mb3JFYWNoKHJlYmluZCk7XG5cbiAgXHRmb3IgKHZhciBrIGluIHRoaXMueWllbGRlcnMpIHtcbiAgXHRcdGlmICh0aGlzLnlpZWxkZXJzW2tdWzBdKSB7XG4gIFx0XHRcdHJlYmluZCh0aGlzLnlpZWxkZXJzW2tdWzBdKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAocXVlcnkgPSB0aGlzLnJvb3QuX2xpdmVDb21wb25lbnRRdWVyaWVzW1wiX1wiICsgdGhpcy5uYW1lXSkge1xuICBcdFx0cXVlcnkuX21ha2VEaXJ0eSgpO1xuICBcdH1cblxuICBcdGZ1bmN0aW9uIHJlYmluZCh4KSB7XG4gIFx0XHR4LnJlYmluZChvbGRLZXlwYXRoLCBuZXdLZXlwYXRoKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV9yZW5kZXIgPSBDb21wb25lbnQkcmVuZGVyO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCRyZW5kZXIoKSB7XG4gIFx0dmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZTtcblxuICBcdGluc3RhbmNlLnJlbmRlcih0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKSk7XG5cbiAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHRyZXR1cm4gaW5zdGFuY2UuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50X3Byb3RvdHlwZV90b1N0cmluZyA9IENvbXBvbmVudCR0b1N0cmluZztcblxuICBmdW5jdGlvbiBDb21wb25lbnQkdG9TdHJpbmcoKSB7XG4gIFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX3VuYmluZCA9IENvbXBvbmVudCR1bmJpbmQ7XG5cbiAgdmFyIENvbXBvbmVudF9wcm90b3R5cGVfdW5iaW5kX190ZWFyZG93bkhvb2sgPSBuZXcgaG9va3NfSG9vayhcInRlYXJkb3duXCIpO1xuICBmdW5jdGlvbiBDb21wb25lbnQkdW5iaW5kKCkge1xuICBcdHZhciBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2U7XG5cbiAgXHR0aGlzLnJlc29sdmVycy5mb3JFYWNoKG1ldGhvZENhbGxlcnNfX3VuYmluZCk7XG5cbiAgXHRyZW1vdmVGcm9tTGl2ZUNvbXBvbmVudFF1ZXJpZXModGhpcyk7XG5cbiAgXHRpbnN0YW5jZS5fb2JzZXJ2ZXJzLmZvckVhY2goY2FuY2VsKTtcblxuICBcdC8vIHRlYXJkb3duIHRoZSBpbnN0YW5jZVxuICBcdGluc3RhbmNlLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdGluc3RhbmNlLnZpZXdtb2RlbC50ZWFyZG93bigpO1xuXG4gIFx0aWYgKGluc3RhbmNlLmZyYWdtZW50LnJlbmRlcmVkICYmIGluc3RhbmNlLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXykge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KGluc3RhbmNlLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgaW5zdGFuY2UpO1xuICBcdH1cblxuICBcdENvbXBvbmVudF9wcm90b3R5cGVfdW5iaW5kX190ZWFyZG93bkhvb2suZmlyZShpbnN0YW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVGcm9tTGl2ZUNvbXBvbmVudFF1ZXJpZXMoY29tcG9uZW50KSB7XG4gIFx0dmFyIGluc3RhbmNlLCBxdWVyeTtcblxuICBcdGluc3RhbmNlID0gY29tcG9uZW50LnJvb3Q7XG5cbiAgXHRkbyB7XG4gIFx0XHRpZiAocXVlcnkgPSBpbnN0YW5jZS5fbGl2ZUNvbXBvbmVudFF1ZXJpZXNbXCJfXCIgKyBjb21wb25lbnQubmFtZV0pIHtcbiAgXHRcdFx0cXVlcnkuX3JlbW92ZShjb21wb25lbnQpO1xuICBcdFx0fVxuICBcdH0gd2hpbGUgKGluc3RhbmNlID0gaW5zdGFuY2UucGFyZW50KTtcbiAgfVxuXG4gIHZhciBDb21wb25lbnRfcHJvdG90eXBlX3VucmVuZGVyID0gQ29tcG9uZW50JHVucmVuZGVyO1xuXG4gIGZ1bmN0aW9uIENvbXBvbmVudCR1bnJlbmRlcihzaG91bGREZXN0cm95KSB7XG4gIFx0dGhpcy5zaG91bGREZXN0cm95ID0gc2hvdWxkRGVzdHJveTtcbiAgXHR0aGlzLmluc3RhbmNlLnVucmVuZGVyKCk7XG4gIH1cblxuICB2YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMsIENvbnN0cnVjdG9yKSB7XG4gIFx0dGhpcy5pbml0KG9wdGlvbnMsIENvbnN0cnVjdG9yKTtcbiAgfTtcblxuICBDb21wb25lbnQucHJvdG90eXBlID0ge1xuICBcdGRldGFjaDogQ29tcG9uZW50X3Byb3RvdHlwZV9kZXRhY2gsXG4gIFx0ZmluZDogQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kLFxuICBcdGZpbmRBbGw6IENvbXBvbmVudF9wcm90b3R5cGVfZmluZEFsbCxcbiAgXHRmaW5kQWxsQ29tcG9uZW50czogQ29tcG9uZW50X3Byb3RvdHlwZV9maW5kQWxsQ29tcG9uZW50cyxcbiAgXHRmaW5kQ29tcG9uZW50OiBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQsXG4gIFx0ZmluZE5leHROb2RlOiBDb21wb25lbnRfcHJvdG90eXBlX2ZpbmROZXh0Tm9kZSxcbiAgXHRmaXJzdE5vZGU6IENvbXBvbmVudF9wcm90b3R5cGVfZmlyc3ROb2RlLFxuICBcdGluaXQ6IENvbXBvbmVudF9wcm90b3R5cGVfaW5pdCxcbiAgXHRyZWJpbmQ6IENvbXBvbmVudF9wcm90b3R5cGVfcmViaW5kLFxuICBcdHJlbmRlcjogQ29tcG9uZW50X3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0dG9TdHJpbmc6IENvbXBvbmVudF9wcm90b3R5cGVfdG9TdHJpbmcsXG4gIFx0dW5iaW5kOiBDb21wb25lbnRfcHJvdG90eXBlX3VuYmluZCxcbiAgXHR1bnJlbmRlcjogQ29tcG9uZW50X3Byb3RvdHlwZV91bnJlbmRlclxuICB9O1xuXG4gIHZhciBfQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuXG4gIHZhciBDb21tZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHR0aGlzLnR5cGUgPSBDT01NRU5UO1xuICBcdHRoaXMudmFsdWUgPSBvcHRpb25zLnRlbXBsYXRlLmM7XG4gIH07XG5cbiAgQ29tbWVudC5wcm90b3R5cGUgPSB7XG4gIFx0ZGV0YWNoOiBzaGFyZWRfZGV0YWNoLFxuXG4gIFx0Zmlyc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICghdGhpcy5ub2RlKSB7XG4gIFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGhpcy52YWx1ZSk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gXCI8IS0tXCIgKyB0aGlzLnZhbHVlICsgXCItLT5cIjtcbiAgXHR9LFxuXG4gIFx0dW5yZW5kZXI6IGZ1bmN0aW9uIChzaG91bGREZXN0cm95KSB7XG4gIFx0XHRpZiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0XHR0aGlzLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfQ29tbWVudCA9IENvbW1lbnQ7XG5cbiAgdmFyIFlpZWxkZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHZhciBjb250YWluZXIsIGNvbXBvbmVudDtcblxuICBcdHRoaXMudHlwZSA9IFlJRUxERVI7XG5cbiAgXHR0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lciA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQucm9vdDtcbiAgXHR0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudCA9IGNvbnRhaW5lci5jb21wb25lbnQ7XG5cbiAgXHR0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgXHR0aGlzLmNvbnRhaW5lckZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXG4gIFx0dmFyIG5hbWUgPSB0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLm4gfHwgXCJcIjtcblxuICBcdHZhciB0ZW1wbGF0ZSA9IGNvbnRhaW5lci5faW5saW5lUGFydGlhbHNbbmFtZV07XG5cbiAgXHRpZiAoIXRlbXBsYXRlKSB7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcIkNvdWxkIG5vdCBmaW5kIHRlbXBsYXRlIGZvciBwYXJ0aWFsIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIiwgeyByYWN0aXZlOiBvcHRpb25zLnJvb3QgfSk7XG4gIFx0XHR0ZW1wbGF0ZSA9IFtdO1xuICBcdH1cblxuICBcdHRoaXMuZnJhZ21lbnQgPSBuZXcgdmlydHVhbGRvbV9GcmFnbWVudCh7XG4gIFx0XHRvd25lcjogdGhpcyxcbiAgXHRcdHJvb3Q6IGNvbnRhaW5lci5wYXJlbnQsXG4gIFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gIFx0XHRwRWxlbWVudDogdGhpcy5jb250YWluZXJGcmFnbWVudC5wRWxlbWVudFxuICBcdH0pO1xuXG4gIFx0Ly8gZXZlbiB0aG91Z2ggb25seSBvbmUgeWllbGRlciBpcyBhbGxvd2VkLCB3ZSBuZWVkIHRvIGhhdmUgYW4gYXJyYXkgb2YgdGhlbVxuICBcdC8vIGFzIGl0J3MgcG9zc2libGUgdG8gY2F1c2UgYSB5aWVsZGVyIHRvIGJlIGNyZWF0ZWQgYmVmb3JlIHRoZSBsYXN0IG9uZVxuICBcdC8vIHdhcyBkZXN0cm95ZWQgaW4gdGhlIHNhbWUgdHVybiBvZiB0aGUgcnVubG9vcFxuICBcdGlmICghaXNBcnJheShjb21wb25lbnQueWllbGRlcnNbbmFtZV0pKSB7XG4gIFx0XHRjb21wb25lbnQueWllbGRlcnNbbmFtZV0gPSBbdGhpc107XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGNvbXBvbmVudC55aWVsZGVyc1tuYW1lXS5wdXNoKHRoaXMpO1xuICBcdH1cblxuICBcdGdsb2JhbF9ydW5sb29wLnNjaGVkdWxlVGFzayhmdW5jdGlvbiAoKSB7XG4gIFx0XHRpZiAoY29tcG9uZW50LnlpZWxkZXJzW25hbWVdLmxlbmd0aCA+IDEpIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQSBjb21wb25lbnQgdGVtcGxhdGUgY2FuIG9ubHkgaGF2ZSBvbmUge3t5aWVsZFwiICsgKG5hbWUgPyBcIiBcIiArIG5hbWUgOiBcIlwiKSArIFwifX0gZGVjbGFyYXRpb24gYXQgYSB0aW1lXCIpO1xuICBcdFx0fVxuICBcdH0pO1xuICB9O1xuXG4gIFlpZWxkZXIucHJvdG90eXBlID0ge1xuICBcdGRldGFjaDogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIFx0fSxcblxuICBcdGZpbmQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZChzZWxlY3Rvcik7XG4gIFx0fSxcblxuICBcdGZpbmRBbGw6IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGwoc2VsZWN0b3IsIHF1ZXJ5KTtcbiAgXHR9LFxuXG4gIFx0ZmluZENvbXBvbmVudDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KHNlbGVjdG9yKTtcbiAgXHR9LFxuXG4gIFx0ZmluZEFsbENvbXBvbmVudHM6IGZ1bmN0aW9uIChzZWxlY3RvciwgcXVlcnkpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKHNlbGVjdG9yLCBxdWVyeSk7XG4gIFx0fSxcblxuICBcdGZpbmROZXh0Tm9kZTogZnVuY3Rpb24gKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuY29udGFpbmVyRnJhZ21lbnQuZmluZE5leHROb2RlKHRoaXMpO1xuICBcdH0sXG5cbiAgXHRmaXJzdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuICBcdH0sXG5cbiAgXHRnZXRWYWx1ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmdldFZhbHVlKG9wdGlvbnMpO1xuICBcdH0sXG5cbiAgXHRyZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnJlbmRlcigpO1xuICBcdH0sXG5cbiAgXHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fSxcblxuICBcdHVucmVuZGVyOiBmdW5jdGlvbiAoc2hvdWxkRGVzdHJveSkge1xuICBcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlcihzaG91bGREZXN0cm95KTtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLmNvbXBvbmVudC55aWVsZGVyc1t0aGlzLm5hbWVdLCB0aGlzKTtcbiAgXHR9LFxuXG4gIFx0cmViaW5kOiBmdW5jdGlvbiAob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQob2xkS2V5cGF0aCwgbmV3S2V5cGF0aCk7XG4gIFx0fSxcblxuICBcdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC50b1N0cmluZygpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfWWllbGRlciA9IFlpZWxkZXI7XG5cbiAgdmFyIERvY3R5cGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdHRoaXMuZGVjbGFyYXRpb24gPSBvcHRpb25zLnRlbXBsYXRlLmE7XG4gIH07XG5cbiAgRG9jdHlwZS5wcm90b3R5cGUgPSB7XG4gIFx0aW5pdDogbm9vcCxcbiAgXHRyZW5kZXI6IG5vb3AsXG4gIFx0dW5yZW5kZXI6IG5vb3AsXG4gIFx0dGVhcmRvd246IG5vb3AsXG4gIFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiBcIjwhRE9DVFlQRVwiICsgdGhpcy5kZWNsYXJhdGlvbiArIFwiPlwiO1xuICBcdH1cbiAgfTtcblxuICB2YXIgaXRlbXNfRG9jdHlwZSA9IERvY3R5cGU7XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9pbml0ID0gRnJhZ21lbnQkaW5pdDtcblxuICBmdW5jdGlvbiBGcmFnbWVudCRpbml0KG9wdGlvbnMpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0dGhpcy5vd25lciA9IG9wdGlvbnMub3duZXI7IC8vIFRoZSBpdGVtIHRoYXQgb3ducyB0aGlzIGZyYWdtZW50IC0gYW4gZWxlbWVudCwgc2VjdGlvbiwgcGFydGlhbCwgb3IgYXR0cmlidXRlXG4gIFx0dGhpcy5wYXJlbnQgPSB0aGlzLm93bmVyLnBhcmVudEZyYWdtZW50O1xuXG4gIFx0Ly8gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgXHR0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3Q7XG4gIFx0dGhpcy5wRWxlbWVudCA9IG9wdGlvbnMucEVsZW1lbnQ7XG4gIFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0O1xuICBcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuICBcdHRoaXMua2V5ID0gb3B0aW9ucy5rZXk7XG4gIFx0dGhpcy5yZWdpc3RlcmVkSW5kZXhSZWZzID0gW107XG5cbiAgXHQvLyBlbmNhcHN1bGF0ZWQgc3R5bGVzIHNob3VsZCBiZSBpbmhlcml0ZWQgdW50aWwgdGhleSBnZXQgYXBwbGllZCBieSBhbiBlbGVtZW50XG4gIFx0dGhpcy5jc3NJZHMgPSBcImNzc0lkc1wiIGluIG9wdGlvbnMgPyBvcHRpb25zLmNzc0lkcyA6IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuY3NzSWRzIDogbnVsbDtcblxuICBcdHRoaXMuaXRlbXMgPSBvcHRpb25zLnRlbXBsYXRlLm1hcChmdW5jdGlvbiAodGVtcGxhdGUsIGkpIHtcbiAgXHRcdHJldHVybiBjcmVhdGVJdGVtKHtcbiAgXHRcdFx0cGFyZW50RnJhZ21lbnQ6IF90aGlzLFxuICBcdFx0XHRwRWxlbWVudDogb3B0aW9ucy5wRWxlbWVudCxcbiAgXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuICBcdFx0XHRpbmRleDogaVxuICBcdFx0fSk7XG4gIFx0fSk7XG5cbiAgXHR0aGlzLnZhbHVlID0gdGhpcy5hcmdzTGlzdCA9IG51bGw7XG4gIFx0dGhpcy5kaXJ0eUFyZ3MgPSB0aGlzLmRpcnR5VmFsdWUgPSB0cnVlO1xuXG4gIFx0dGhpcy5ib3VuZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJdGVtKG9wdGlvbnMpIHtcbiAgXHRpZiAodHlwZW9mIG9wdGlvbnMudGVtcGxhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgXHRcdHJldHVybiBuZXcgaXRlbXNfVGV4dChvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHRzd2l0Y2ggKG9wdGlvbnMudGVtcGxhdGUudCkge1xuICBcdFx0Y2FzZSBZSUVMREVSOlxuICBcdFx0XHRyZXR1cm4gbmV3IGl0ZW1zX1lpZWxkZXIob3B0aW9ucyk7XG4gIFx0XHRjYXNlIElOVEVSUE9MQVRPUjpcbiAgXHRcdFx0cmV0dXJuIG5ldyBpdGVtc19JbnRlcnBvbGF0b3Iob3B0aW9ucyk7XG4gIFx0XHRjYXNlIFNFQ1RJT046XG4gIFx0XHRcdHJldHVybiBuZXcgX1NlY3Rpb24ob3B0aW9ucyk7XG4gIFx0XHRjYXNlIFRSSVBMRTpcbiAgXHRcdFx0cmV0dXJuIG5ldyBfVHJpcGxlKG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBFTEVNRU5UOlxuICBcdFx0XHR2YXIgY29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gIFx0XHRcdGlmIChjb25zdHJ1Y3RvciA9IENvbXBvbmVudF9nZXRDb21wb25lbnQob3B0aW9ucy5wYXJlbnRGcmFnbWVudC5yb290LCBvcHRpb25zLnRlbXBsYXRlLmUpKSB7XG4gIFx0XHRcdFx0cmV0dXJuIG5ldyBfQ29tcG9uZW50KG9wdGlvbnMsIGNvbnN0cnVjdG9yKTtcbiAgXHRcdFx0fVxuICBcdFx0XHRyZXR1cm4gbmV3IF9FbGVtZW50KG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBQQVJUSUFMOlxuICBcdFx0XHRyZXR1cm4gbmV3IF9QYXJ0aWFsKG9wdGlvbnMpO1xuICBcdFx0Y2FzZSBDT01NRU5UOlxuICBcdFx0XHRyZXR1cm4gbmV3IGl0ZW1zX0NvbW1lbnQob3B0aW9ucyk7XG4gIFx0XHRjYXNlIERPQ1RZUEU6XG4gIFx0XHRcdHJldHVybiBuZXcgaXRlbXNfRG9jdHlwZShvcHRpb25zKTtcblxuICBcdFx0ZGVmYXVsdDpcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU29tZXRoaW5nIHZlcnkgc3RyYW5nZSBoYXBwZW5lZC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy4gVGhhbmtzIVwiKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX3JlYmluZCA9IEZyYWdtZW50JHJlYmluZDtcbiAgZnVuY3Rpb24gRnJhZ21lbnQkcmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpIHtcblxuICBcdC8vIGFzc2lnbiBuZXcgY29udGV4dCBrZXlwYXRoIGlmIG5lZWRlZFxuICBcdGlmICghdGhpcy5vd25lciB8fCB0aGlzLm93bmVyLmhhc0NvbnRleHQpIHtcbiAgXHRcdGFzc2lnbk5ld0tleXBhdGgodGhpcywgXCJjb250ZXh0XCIsIG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdH1cblxuICBcdHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0aWYgKGl0ZW0ucmViaW5kKSB7XG4gIFx0XHRcdGl0ZW0ucmViaW5kKG9sZEtleXBhdGgsIG5ld0tleXBhdGgpO1xuICBcdFx0fVxuICBcdH0pO1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV9yZW5kZXIgPSBGcmFnbWVudCRyZW5kZXI7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkcmVuZGVyKCkge1xuICBcdHZhciByZXN1bHQ7XG5cbiAgXHRpZiAodGhpcy5pdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgXHRcdHJlc3VsdCA9IHRoaXMuaXRlbXNbMF0ucmVuZGVyKCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBcdFx0dGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gIFx0XHRcdHJlc3VsdC5hcHBlbmRDaGlsZChpdGVtLnJlbmRlcigpKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgRnJhZ21lbnRfcHJvdG90eXBlX3RvU3RyaW5nID0gRnJhZ21lbnQkdG9TdHJpbmc7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkdG9TdHJpbmcoZXNjYXBlKSB7XG4gIFx0aWYgKCF0aGlzLml0ZW1zKSB7XG4gIFx0XHRyZXR1cm4gXCJcIjtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5pdGVtcy5tYXAoZXNjYXBlID8gdG9Fc2NhcGVkU3RyaW5nIDogRnJhZ21lbnRfcHJvdG90eXBlX3RvU3RyaW5nX190b1N0cmluZykuam9pbihcIlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEZyYWdtZW50X3Byb3RvdHlwZV90b1N0cmluZ19fdG9TdHJpbmcoaXRlbSkge1xuICBcdHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG4gIH1cblxuICBmdW5jdGlvbiB0b0VzY2FwZWRTdHJpbmcoaXRlbSkge1xuICBcdHJldHVybiBpdGVtLnRvU3RyaW5nKHRydWUpO1xuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV91bmJpbmQgPSBGcmFnbWVudCR1bmJpbmQ7XG5cbiAgZnVuY3Rpb24gRnJhZ21lbnQkdW5iaW5kKCkge1xuICBcdGlmICghdGhpcy5ib3VuZCkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHRoaXMuaXRlbXMuZm9yRWFjaCh1bmJpbmRJdGVtKTtcbiAgXHR0aGlzLmJvdW5kID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiB1bmJpbmRJdGVtKGl0ZW0pIHtcbiAgXHRpZiAoaXRlbS51bmJpbmQpIHtcbiAgXHRcdGl0ZW0udW5iaW5kKCk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEZyYWdtZW50X3Byb3RvdHlwZV91bnJlbmRlciA9IEZyYWdtZW50JHVucmVuZGVyO1xuXG4gIGZ1bmN0aW9uIEZyYWdtZW50JHVucmVuZGVyKHNob3VsZERlc3Ryb3kpIHtcbiAgXHRpZiAoIXRoaXMucmVuZGVyZWQpIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byB1bnJlbmRlciBhIGZyYWdtZW50IHRoYXQgd2FzIG5vdCByZW5kZXJlZFwiKTtcbiAgXHR9XG5cbiAgXHR0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgXHRcdHJldHVybiBpLnVucmVuZGVyKHNob3VsZERlc3Ryb3kpO1xuICBcdH0pO1xuICBcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBGcmFnbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0dGhpcy5pbml0KG9wdGlvbnMpO1xuICB9O1xuXG4gIEZyYWdtZW50LnByb3RvdHlwZSA9IHtcbiAgXHRidWJibGU6IHByb3RvdHlwZV9idWJibGUsXG4gIFx0ZGV0YWNoOiBGcmFnbWVudF9wcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IEZyYWdtZW50X3Byb3RvdHlwZV9maW5kLFxuICBcdGZpbmRBbGw6IEZyYWdtZW50X3Byb3RvdHlwZV9maW5kQWxsLFxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBGcmFnbWVudF9wcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogRnJhZ21lbnRfcHJvdG90eXBlX2ZpbmRDb21wb25lbnQsXG4gIFx0ZmluZE5leHROb2RlOiBwcm90b3R5cGVfZmluZE5leHROb2RlLFxuICBcdGZpcnN0Tm9kZTogcHJvdG90eXBlX2ZpcnN0Tm9kZSxcbiAgXHRnZXRBcmdzTGlzdDogZ2V0QXJnc0xpc3QsXG4gIFx0Z2V0Tm9kZTogZ2V0Tm9kZSxcbiAgXHRnZXRWYWx1ZTogcHJvdG90eXBlX2dldFZhbHVlLFxuICBcdGluaXQ6IEZyYWdtZW50X3Byb3RvdHlwZV9pbml0LFxuICBcdHJlYmluZDogRnJhZ21lbnRfcHJvdG90eXBlX3JlYmluZCxcbiAgXHRyZWdpc3RlckluZGV4UmVmOiBmdW5jdGlvbiAoaWR4KSB7XG4gIFx0XHR2YXIgaWR4cyA9IHRoaXMucmVnaXN0ZXJlZEluZGV4UmVmcztcbiAgXHRcdGlmIChpZHhzLmluZGV4T2YoaWR4KSA9PT0gLTEpIHtcbiAgXHRcdFx0aWR4cy5wdXNoKGlkeCk7XG4gIFx0XHR9XG4gIFx0fSxcbiAgXHRyZW5kZXI6IEZyYWdtZW50X3Byb3RvdHlwZV9yZW5kZXIsXG4gIFx0dG9TdHJpbmc6IEZyYWdtZW50X3Byb3RvdHlwZV90b1N0cmluZyxcbiAgXHR1bmJpbmQ6IEZyYWdtZW50X3Byb3RvdHlwZV91bmJpbmQsXG4gIFx0dW5yZWdpc3RlckluZGV4UmVmOiBmdW5jdGlvbiAoaWR4KSB7XG4gIFx0XHR2YXIgaWR4cyA9IHRoaXMucmVnaXN0ZXJlZEluZGV4UmVmcztcbiAgXHRcdGlkeHMuc3BsaWNlKGlkeHMuaW5kZXhPZihpZHgpLCAxKTtcbiAgXHR9LFxuICBcdHVucmVuZGVyOiBGcmFnbWVudF9wcm90b3R5cGVfdW5yZW5kZXJcbiAgfTtcblxuICB2YXIgdmlydHVhbGRvbV9GcmFnbWVudCA9IEZyYWdtZW50O1xuXG4gIHZhciBwcm90b3R5cGVfcmVzZXQgPSBSYWN0aXZlJHJlc2V0O1xuICB2YXIgc2hvdWxkUmVyZW5kZXIgPSBbXCJ0ZW1wbGF0ZVwiLCBcInBhcnRpYWxzXCIsIFwiY29tcG9uZW50c1wiLCBcImRlY29yYXRvcnNcIiwgXCJldmVudHNcIl0sXG4gICAgICByZXNldEhvb2sgPSBuZXcgaG9va3NfSG9vayhcInJlc2V0XCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHJlc2V0KGRhdGEpIHtcbiAgXHR2YXIgcHJvbWlzZSwgd3JhcHBlciwgY2hhbmdlcywgaSwgcmVyZW5kZXI7XG5cbiAgXHRkYXRhID0gZGF0YSB8fCB7fTtcblxuICBcdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc2V0IG1ldGhvZCB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnRzLCBvciBhbiBvYmplY3QgY29udGFpbmluZyBuZXcgZGF0YVwiKTtcbiAgXHR9XG5cbiAgXHQvLyBJZiB0aGUgcm9vdCBvYmplY3QgaXMgd3JhcHBlZCwgdHJ5IGFuZCB1c2UgdGhlIHdyYXBwZXIncyByZXNldCB2YWx1ZVxuICBcdGlmICgod3JhcHBlciA9IHRoaXMudmlld21vZGVsLndyYXBwZWRbXCJcIl0pICYmIHdyYXBwZXIucmVzZXQpIHtcbiAgXHRcdGlmICh3cmFwcGVyLnJlc2V0KGRhdGEpID09PSBmYWxzZSkge1xuICBcdFx0XHQvLyByZXNldCB3YXMgcmVqZWN0ZWQsIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgb2JqZWN0XG4gIFx0XHRcdHRoaXMudmlld21vZGVsLnJlc2V0KGRhdGEpO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5yZXNldChkYXRhKTtcbiAgXHR9XG5cbiAgXHQvLyByZXNldCBjb25maWcgaXRlbXMgYW5kIHRyYWNrIGlmIG5lZWQgdG8gcmVyZW5kZXJcbiAgXHRjaGFuZ2VzID0gY29uZmlnX2NvbmZpZy5yZXNldCh0aGlzKTtcblxuICBcdGkgPSBjaGFuZ2VzLmxlbmd0aDtcbiAgXHR3aGlsZSAoaS0tKSB7XG4gIFx0XHRpZiAoc2hvdWxkUmVyZW5kZXIuaW5kZXhPZihjaGFuZ2VzW2ldKSA+IC0xKSB7XG4gIFx0XHRcdHJlcmVuZGVyID0gdHJ1ZTtcbiAgXHRcdFx0YnJlYWs7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKHJlcmVuZGVyKSB7XG4gIFx0XHR2YXIgY29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKHJvb3RLZXlwYXRoKTtcblxuICBcdFx0Ly8gSXMgdGhpcyBpcyBhIGNvbXBvbmVudCwgd2UgbmVlZCB0byBzZXQgdGhlIGBzaG91bGREZXN0cm95YFxuICBcdFx0Ly8gZmxhZywgb3RoZXJ3aXNlIGl0IHdpbGwgYXNzdW1lIGJ5IGRlZmF1bHQgdGhhdCBhIHBhcmVudCBub2RlXG4gIFx0XHQvLyB3aWxsIGJlIGRldGFjaGVkLCBhbmQgdGhlcmVmb3JlIGl0IGRvZXNuJ3QgbmVlZCB0byBib3RoZXJcbiAgXHRcdC8vIGRldGFjaGluZyBpdHMgb3duIG5vZGVzXG4gIFx0XHRpZiAoY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQpIHtcbiAgXHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnVucmVuZGVyKCk7XG5cbiAgXHRcdGlmIChjb21wb25lbnQpIHtcbiAgXHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSBmYWxzZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSWYgdGhlIHRlbXBsYXRlIGNoYW5nZWQsIHdlIG5lZWQgdG8gZGVzdHJveSB0aGUgcGFyYWxsZWwgRE9NXG4gIFx0XHQvLyBUT0RPIGlmIHdlJ3JlIGhlcmUsIHByZXN1bWFibHkgaXQgZGlkP1xuICBcdFx0aWYgKHRoaXMuZnJhZ21lbnQudGVtcGxhdGUgIT09IHRoaXMudGVtcGxhdGUpIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblxuICBcdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IHZpcnR1YWxkb21fRnJhZ21lbnQoe1xuICBcdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuICBcdFx0XHRcdHJvb3Q6IHRoaXMsXG4gIFx0XHRcdFx0b3duZXI6IHRoaXNcbiAgXHRcdFx0fSk7XG4gIFx0XHR9XG5cbiAgXHRcdHByb21pc2UgPSB0aGlzLnJlbmRlcih0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcbiAgXHRcdHRoaXMudmlld21vZGVsLm1hcmsocm9vdEtleXBhdGgpO1xuICBcdFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0fVxuXG4gIFx0cmVzZXRIb29rLmZpcmUodGhpcywgZGF0YSk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciByZXNldFBhcnRpYWwgPSBmdW5jdGlvbiAobmFtZSwgcGFydGlhbCkge1xuICBcdHZhciBwcm9taXNlLFxuICBcdCAgICBjb2xsZWN0aW9uID0gW107XG5cbiAgXHRmdW5jdGlvbiBjb2xsZWN0KHNvdXJjZSwgZGVzdCwgcmFjdGl2ZSkge1xuICBcdFx0Ly8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCBhbmQgaXQgaGFzIGl0cyBvd24gcGFydGlhbCwgYmFpbFxuICBcdFx0aWYgKHJhY3RpdmUgJiYgcmFjdGl2ZS5wYXJ0aWFsc1tuYW1lXSkgcmV0dXJuO1xuXG4gIFx0XHRzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0XHQvLyBxdWV1ZSB0byByZXJlbmRlciBpZiB0aGUgaXRlbSBpcyBhIHBhcnRpYWwgYW5kIHRoZSBjdXJyZW50IG5hbWUgbWF0Y2hlc1xuICBcdFx0XHRpZiAoaXRlbS50eXBlID09PSBQQVJUSUFMICYmIGl0ZW0uZ2V0UGFydGlhbE5hbWUoKSA9PT0gbmFtZSkge1xuICBcdFx0XHRcdGRlc3QucHVzaChpdGVtKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGlmIGl0IGhhcyBhIGZyYWdtZW50LCBwcm9jZXNzIGl0cyBpdGVtc1xuICBcdFx0XHRpZiAoaXRlbS5mcmFnbWVudCkge1xuICBcdFx0XHRcdGNvbGxlY3QoaXRlbS5mcmFnbWVudC5pdGVtcywgZGVzdCwgcmFjdGl2ZSk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBvciBpZiBpdCBoYXMgZnJhZ21lbnRzXG4gIFx0XHRcdGlmIChpc0FycmF5KGl0ZW0uZnJhZ21lbnRzKSkge1xuICBcdFx0XHRcdGNvbGxlY3QoaXRlbS5mcmFnbWVudHMsIGRlc3QsIHJhY3RpdmUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gb3IgaWYgaXQgaXMgaXRzZWxmIGEgZnJhZ21lbnQsIHByb2Nlc3MgaXRzIGl0ZW1zXG4gIFx0XHRcdGVsc2UgaWYgKGlzQXJyYXkoaXRlbS5pdGVtcykpIHtcbiAgXHRcdFx0XHRjb2xsZWN0KGl0ZW0uaXRlbXMsIGRlc3QsIHJhY3RpdmUpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gb3IgaWYgaXQgaXMgYSBjb21wb25lbnQsIHN0ZXAgaW4gYW5kIHByb2Nlc3MgaXRzIGl0ZW1zXG4gIFx0XHRcdGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gQ09NUE9ORU5UICYmIGl0ZW0uaW5zdGFuY2UpIHtcbiAgXHRcdFx0XHRjb2xsZWN0KGl0ZW0uaW5zdGFuY2UuZnJhZ21lbnQuaXRlbXMsIGRlc3QsIGl0ZW0uaW5zdGFuY2UpO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gaWYgdGhlIGl0ZW0gaXMgYW4gZWxlbWVudCwgcHJvY2VzcyBpdHMgYXR0cmlidXRlcyB0b29cbiAgXHRcdFx0aWYgKGl0ZW0udHlwZSA9PT0gRUxFTUVOVCkge1xuICBcdFx0XHRcdGlmIChpc0FycmF5KGl0ZW0uYXR0cmlidXRlcykpIHtcbiAgXHRcdFx0XHRcdGNvbGxlY3QoaXRlbS5hdHRyaWJ1dGVzLCBkZXN0LCByYWN0aXZlKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoaXNBcnJheShpdGVtLmNvbmRpdGlvbmFsQXR0cmlidXRlcykpIHtcbiAgXHRcdFx0XHRcdGNvbGxlY3QoaXRlbS5jb25kaXRpb25hbEF0dHJpYnV0ZXMsIGRlc3QsIHJhY3RpdmUpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Y29sbGVjdCh0aGlzLmZyYWdtZW50Lml0ZW1zLCBjb2xsZWN0aW9uKTtcbiAgXHR0aGlzLnBhcnRpYWxzW25hbWVdID0gcGFydGlhbDtcblxuICBcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcblxuICBcdGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICBcdFx0aXRlbS52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgXHRcdGl0ZW0uc2V0VmFsdWUobmFtZSk7XG4gIFx0fSk7XG5cbiAgXHRnbG9iYWxfcnVubG9vcC5lbmQoKTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8vIFRPRE8gc2hvdWxkIHJlc2V0VGVtcGxhdGUgYmUgYXN5bmNocm9ub3VzPyBpLmUuIHNob3VsZCBpdCBiZSBhIGNhc2VcbiAgLy8gb2Ygb3V0cm8sIHVwZGF0ZSB0ZW1wbGF0ZSwgaW50cm8/IEkgcmVja29uIHByb2JhYmx5IG5vdCwgc2luY2UgdGhhdFxuICAvLyBjb3VsZCBiZSBhY2hpZXZlZCB3aXRoIHVucmVuZGVyLXJlc2V0VGVtcGxhdGUtcmVuZGVyLiBBbHNvLCBpdCBzaG91bGRcbiAgLy8gY29uY2VwdHVhbGx5IGJlIHNpbWlsYXIgdG8gcmVzZXRQYXJ0aWFsLCB3aGljaCBjb3VsZG4ndCBiZSBhc3luY1xuXG4gIHZhciByZXNldFRlbXBsYXRlID0gUmFjdGl2ZSRyZXNldFRlbXBsYXRlO1xuICBmdW5jdGlvbiBSYWN0aXZlJHJlc2V0VGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgXHR2YXIgdHJhbnNpdGlvbnNFbmFibGVkLCBjb21wb25lbnQ7XG5cbiAgXHR0ZW1wbGF0ZV90ZW1wbGF0ZS5pbml0KG51bGwsIHRoaXMsIHsgdGVtcGxhdGU6IHRlbXBsYXRlIH0pO1xuXG4gIFx0dHJhbnNpdGlvbnNFbmFibGVkID0gdGhpcy50cmFuc2l0aW9uc0VuYWJsZWQ7XG4gIFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSBmYWxzZTtcblxuICBcdC8vIElzIHRoaXMgaXMgYSBjb21wb25lbnQsIHdlIG5lZWQgdG8gc2V0IHRoZSBgc2hvdWxkRGVzdHJveWBcbiAgXHQvLyBmbGFnLCBvdGhlcndpc2UgaXQgd2lsbCBhc3N1bWUgYnkgZGVmYXVsdCB0aGF0IGEgcGFyZW50IG5vZGVcbiAgXHQvLyB3aWxsIGJlIGRldGFjaGVkLCBhbmQgdGhlcmVmb3JlIGl0IGRvZXNuJ3QgbmVlZCB0byBib3RoZXJcbiAgXHQvLyBkZXRhY2hpbmcgaXRzIG93biBub2Rlc1xuICBcdGlmIChjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudCkge1xuICBcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSB0cnVlO1xuICBcdH1cblxuICBcdHRoaXMudW5yZW5kZXIoKTtcblxuICBcdGlmIChjb21wb25lbnQpIHtcbiAgXHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gZmFsc2U7XG4gIFx0fVxuXG4gIFx0Ly8gcmVtb3ZlIGV4aXN0aW5nIGZyYWdtZW50IGFuZCBjcmVhdGUgbmV3IG9uZVxuICBcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0dGhpcy5mcmFnbWVudCA9IG5ldyB2aXJ0dWFsZG9tX0ZyYWdtZW50KHtcbiAgXHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuICBcdFx0cm9vdDogdGhpcyxcbiAgXHRcdG93bmVyOiB0aGlzXG4gIFx0fSk7XG5cbiAgXHR0aGlzLnJlbmRlcih0aGlzLmVsLCB0aGlzLmFuY2hvcik7XG5cbiAgXHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IHRyYW5zaXRpb25zRW5hYmxlZDtcbiAgfVxuXG4gIHZhciByZXZlcnNlID0gbWFrZUFycmF5TWV0aG9kKFwicmV2ZXJzZVwiKTtcblxuICB2YXIgUmFjdGl2ZV9wcm90b3R5cGVfc2V0ID0gUmFjdGl2ZSRzZXQ7XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRzZXQoa2V5cGF0aCwgdmFsdWUpIHtcbiAgXHR2YXIgbWFwLCBwcm9taXNlO1xuXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuXG4gIFx0Ly8gU2V0IG11bHRpcGxlIGtleXBhdGhzIGluIG9uZSBnb1xuICBcdGlmIChpc09iamVjdChrZXlwYXRoKSkge1xuICBcdFx0bWFwID0ga2V5cGF0aDtcblxuICBcdFx0Zm9yIChrZXlwYXRoIGluIG1hcCkge1xuICBcdFx0XHRpZiAobWFwLmhhc093blByb3BlcnR5KGtleXBhdGgpKSB7XG4gIFx0XHRcdFx0dmFsdWUgPSBtYXBba2V5cGF0aF07XG4gIFx0XHRcdFx0c2V0KHRoaXMsIGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIFNldCBhIHNpbmdsZSBrZXlwYXRoXG4gIFx0ZWxzZSB7XG4gIFx0XHRzZXQodGhpcywga2V5cGF0aCwgdmFsdWUpO1xuICBcdH1cblxuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBzZXQocmFjdGl2ZSwga2V5cGF0aCwgdmFsdWUpIHtcbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChub3JtYWxpc2Uoa2V5cGF0aCkpO1xuXG4gIFx0aWYgKGtleXBhdGguaXNQYXR0ZXJuKSB7XG4gIFx0XHRnZXRNYXRjaGluZ0tleXBhdGhzKHJhY3RpdmUsIGtleXBhdGgpLmZvckVhY2goZnVuY3Rpb24gKGtleXBhdGgpIHtcbiAgXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuc2V0KGtleXBhdGgsIHZhbHVlKTtcbiAgXHRcdH0pO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQoa2V5cGF0aCwgdmFsdWUpO1xuICBcdH1cbiAgfVxuXG4gIHZhciBzaGlmdCA9IG1ha2VBcnJheU1ldGhvZChcInNoaWZ0XCIpO1xuXG4gIHZhciBwcm90b3R5cGVfc29ydCA9IG1ha2VBcnJheU1ldGhvZChcInNvcnRcIik7XG5cbiAgdmFyIHNwbGljZSA9IG1ha2VBcnJheU1ldGhvZChcInNwbGljZVwiKTtcblxuICB2YXIgc3VidHJhY3QgPSBSYWN0aXZlJHN1YnRyYWN0O1xuICBmdW5jdGlvbiBSYWN0aXZlJHN1YnRyYWN0KGtleXBhdGgsIGQpIHtcbiAgXHRyZXR1cm4gc2hhcmVkX2FkZCh0aGlzLCBrZXlwYXRoLCBkID09PSB1bmRlZmluZWQgPyAtMSA6IC1kKTtcbiAgfVxuXG4gIC8vIFRlYXJkb3duLiBUaGlzIGdvZXMgdGhyb3VnaCB0aGUgcm9vdCBmcmFnbWVudCBhbmQgYWxsIGl0cyBjaGlsZHJlbiwgcmVtb3Zpbmcgb2JzZXJ2ZXJzXG4gIC8vIGFuZCBnZW5lcmFsbHkgY2xlYW5pbmcgdXAgYWZ0ZXIgaXRzZWxmXG5cbiAgdmFyIFJhY3RpdmVfcHJvdG90eXBlX3RlYXJkb3duID0gUmFjdGl2ZSR0ZWFyZG93bjtcblxuICB2YXIgUmFjdGl2ZV9wcm90b3R5cGVfdGVhcmRvd25fX3RlYXJkb3duSG9vayA9IG5ldyBob29rc19Ib29rKFwidGVhcmRvd25cIik7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkdGVhcmRvd24oKSB7XG4gIFx0dmFyIHByb21pc2U7XG5cbiAgXHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdHRoaXMudmlld21vZGVsLnRlYXJkb3duKCk7XG5cbiAgXHR0aGlzLl9vYnNlcnZlcnMuZm9yRWFjaChjYW5jZWwpO1xuXG4gIFx0aWYgKHRoaXMuZnJhZ21lbnQucmVuZGVyZWQgJiYgdGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18pIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSh0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgdGhpcyk7XG4gIFx0fVxuXG4gIFx0dGhpcy5zaG91bGREZXN0cm95ID0gdHJ1ZTtcbiAgXHRwcm9taXNlID0gdGhpcy5mcmFnbWVudC5yZW5kZXJlZCA/IHRoaXMudW5yZW5kZXIoKSA6IHV0aWxzX1Byb21pc2UucmVzb2x2ZSgpO1xuXG4gIFx0UmFjdGl2ZV9wcm90b3R5cGVfdGVhcmRvd25fX3RlYXJkb3duSG9vay5maXJlKHRoaXMpO1xuXG4gIFx0dGhpcy5fYm91bmRGdW5jdGlvbnMuZm9yRWFjaChkZWxldGVGdW5jdGlvbkNvcHkpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVGdW5jdGlvbkNvcHkoYm91bmQpIHtcbiAgXHRkZWxldGUgYm91bmQuZm5bYm91bmQucHJvcF07XG4gIH1cblxuICB2YXIgdG9nZ2xlID0gUmFjdGl2ZSR0b2dnbGU7XG4gIGZ1bmN0aW9uIFJhY3RpdmUkdG9nZ2xlKGtleXBhdGgpIHtcbiAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIFx0aWYgKHR5cGVvZiBrZXlwYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gIFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGJhZEFyZ3VtZW50cyk7XG4gIFx0fVxuXG4gIFx0dmFyIGNoYW5nZXMgPSB1bmRlZmluZWQ7XG5cbiAgXHRpZiAoL1xcKi8udGVzdChrZXlwYXRoKSkge1xuICBcdFx0Y2hhbmdlcyA9IHt9O1xuXG4gIFx0XHRnZXRNYXRjaGluZ0tleXBhdGhzKHRoaXMsIGdldEtleXBhdGgobm9ybWFsaXNlKGtleXBhdGgpKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHRjaGFuZ2VzW2tleXBhdGguc3RyXSA9ICFfdGhpcy52aWV3bW9kZWwuZ2V0KGtleXBhdGgpO1xuICBcdFx0fSk7XG5cbiAgXHRcdHJldHVybiB0aGlzLnNldChjaGFuZ2VzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5zZXQoa2V5cGF0aCwgIXRoaXMuZ2V0KGtleXBhdGgpKTtcbiAgfVxuXG4gIHZhciB0b0hUTUwgPSBSYWN0aXZlJHRvSFRNTDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJHRvSFRNTCgpIHtcbiAgXHRyZXR1cm4gdGhpcy5mcmFnbWVudC50b1N0cmluZyh0cnVlKTtcbiAgfVxuXG4gIHZhciBSYWN0aXZlX3Byb3RvdHlwZV91bnJlbmRlciA9IFJhY3RpdmUkdW5yZW5kZXI7XG4gIHZhciB1bnJlbmRlckhvb2sgPSBuZXcgaG9va3NfSG9vayhcInVucmVuZGVyXCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHVucmVuZGVyKCkge1xuICBcdHZhciBwcm9taXNlLCBzaG91bGREZXN0cm95O1xuXG4gIFx0aWYgKCF0aGlzLmZyYWdtZW50LnJlbmRlcmVkKSB7XG4gIFx0XHR3YXJuSWZEZWJ1ZyhcInJhY3RpdmUudW5yZW5kZXIoKSB3YXMgY2FsbGVkIG9uIGEgUmFjdGl2ZSBpbnN0YW5jZSB0aGF0IHdhcyBub3QgcmVuZGVyZWRcIik7XG4gIFx0XHRyZXR1cm4gdXRpbHNfUHJvbWlzZS5yZXNvbHZlKCk7XG4gIFx0fVxuXG4gIFx0cHJvbWlzZSA9IGdsb2JhbF9ydW5sb29wLnN0YXJ0KHRoaXMsIHRydWUpO1xuXG4gIFx0Ly8gSWYgdGhpcyBpcyBhIGNvbXBvbmVudCwgYW5kIHRoZSBjb21wb25lbnQgaXNuJ3QgbWFya2VkIGZvciBkZXN0cnVjdGlvbixcbiAgXHQvLyBkb24ndCBkZXRhY2ggbm9kZXMgZnJvbSB0aGUgRE9NIHVubmVjZXNzYXJpbHlcbiAgXHRzaG91bGREZXN0cm95ID0gIXRoaXMuY29tcG9uZW50IHx8IHRoaXMuY29tcG9uZW50LnNob3VsZERlc3Ryb3kgfHwgdGhpcy5zaG91bGREZXN0cm95O1xuXG4gIFx0Ly8gQ2FuY2VsIGFueSBhbmltYXRpb25zIGluIHByb2dyZXNzXG4gIFx0d2hpbGUgKHRoaXMuX2FuaW1hdGlvbnNbMF0pIHtcbiAgXHRcdHRoaXMuX2FuaW1hdGlvbnNbMF0uc3RvcCgpOyAvLyBpdCB3aWxsIHJlbW92ZSBpdHNlbGYgZnJvbSB0aGUgaW5kZXhcbiAgXHR9XG5cbiAgXHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKHNob3VsZERlc3Ryb3kpO1xuXG4gIFx0cmVtb3ZlRnJvbUFycmF5KHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzKTtcblxuICBcdHVucmVuZGVySG9vay5maXJlKHRoaXMpO1xuXG4gIFx0Z2xvYmFsX3J1bmxvb3AuZW5kKCk7XG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgdW5zaGlmdCA9IG1ha2VBcnJheU1ldGhvZChcInVuc2hpZnRcIik7XG5cbiAgdmFyIFJhY3RpdmVfcHJvdG90eXBlX3VwZGF0ZSA9IFJhY3RpdmUkdXBkYXRlO1xuICB2YXIgdXBkYXRlSG9vayA9IG5ldyBob29rc19Ib29rKFwidXBkYXRlXCIpO1xuICBmdW5jdGlvbiBSYWN0aXZlJHVwZGF0ZShrZXlwYXRoKSB7XG4gIFx0dmFyIHByb21pc2U7XG5cbiAgXHRrZXlwYXRoID0gZ2V0S2V5cGF0aChrZXlwYXRoKSB8fCByb290S2V5cGF0aDtcblxuICBcdHByb21pc2UgPSBnbG9iYWxfcnVubG9vcC5zdGFydCh0aGlzLCB0cnVlKTtcbiAgXHR0aGlzLnZpZXdtb2RlbC5tYXJrKGtleXBhdGgpO1xuICBcdGdsb2JhbF9ydW5sb29wLmVuZCgpO1xuXG4gIFx0dXBkYXRlSG9vay5maXJlKHRoaXMsIGtleXBhdGgpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlX3VwZGF0ZU1vZGVsID0gUmFjdGl2ZSR1cGRhdGVNb2RlbDtcblxuICBmdW5jdGlvbiBSYWN0aXZlJHVwZGF0ZU1vZGVsKGtleXBhdGgsIGNhc2NhZGUpIHtcbiAgXHR2YXIgdmFsdWVzLCBrZXksIGJpbmRpbmdzO1xuXG4gIFx0aWYgKHR5cGVvZiBrZXlwYXRoID09PSBcInN0cmluZ1wiICYmICFjYXNjYWRlKSB7XG4gIFx0XHRiaW5kaW5ncyA9IHRoaXMuX3R3b3dheUJpbmRpbmdzW2tleXBhdGhdO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRiaW5kaW5ncyA9IFtdO1xuXG4gIFx0XHRmb3IgKGtleSBpbiB0aGlzLl90d293YXlCaW5kaW5ncykge1xuICBcdFx0XHRpZiAoIWtleXBhdGggfHwgZ2V0S2V5cGF0aChrZXkpLmVxdWFsc09yU3RhcnRzV2l0aChrZXlwYXRoKSkge1xuICBcdFx0XHRcdC8vIFRPRE8gaXMgdGhpcyByaWdodD9cbiAgXHRcdFx0XHRiaW5kaW5ncy5wdXNoLmFwcGx5KGJpbmRpbmdzLCB0aGlzLl90d293YXlCaW5kaW5nc1trZXldKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHZhbHVlcyA9IGNvbnNvbGlkYXRlKHRoaXMsIGJpbmRpbmdzKTtcbiAgXHRyZXR1cm4gdGhpcy5zZXQodmFsdWVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnNvbGlkYXRlKHJhY3RpdmUsIGJpbmRpbmdzKSB7XG4gIFx0dmFyIHZhbHVlcyA9IHt9LFxuICBcdCAgICBjaGVja2JveEdyb3VwcyA9IFtdO1xuXG4gIFx0YmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICBcdFx0dmFyIG9sZFZhbHVlLCBuZXdWYWx1ZTtcblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gcmFkaW8gbmFtZSBiaW5kaW5nc1xuICBcdFx0aWYgKGIucmFkaW9OYW1lICYmICFiLmVsZW1lbnQubm9kZS5jaGVja2VkKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gY2hlY2tib3ggbmFtZSBiaW5kaW5ncyBjb21lIGluIGdyb3Vwcywgc29cbiAgXHRcdC8vIHdlIHdhbnQgdG8gZ2V0IHRoZSB2YWx1ZSBvbmNlIGF0IG1vc3RcbiAgXHRcdGlmIChiLmNoZWNrYm94TmFtZSkge1xuICBcdFx0XHRpZiAoIWNoZWNrYm94R3JvdXBzW2Iua2V5cGF0aC5zdHJdICYmICFiLmNoYW5nZWQoKSkge1xuICBcdFx0XHRcdGNoZWNrYm94R3JvdXBzLnB1c2goYi5rZXlwYXRoKTtcbiAgXHRcdFx0XHRjaGVja2JveEdyb3Vwc1tiLmtleXBhdGguc3RyXSA9IGI7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdG9sZFZhbHVlID0gYi5hdHRyaWJ1dGUudmFsdWU7XG4gIFx0XHRuZXdWYWx1ZSA9IGIuZ2V0VmFsdWUoKTtcblxuICBcdFx0aWYgKGFycmF5Q29udGVudHNNYXRjaChvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCFpc0VxdWFsKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgXHRcdFx0dmFsdWVzW2Iua2V5cGF0aC5zdHJdID0gbmV3VmFsdWU7XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHQvLyBIYW5kbGUgZ3JvdXBzIG9mIGA8aW5wdXQgdHlwZT0nY2hlY2tib3gnIG5hbWU9J3t7Zm9vfX0nIC4uLj5gXG4gIFx0aWYgKGNoZWNrYm94R3JvdXBzLmxlbmd0aCkge1xuICBcdFx0Y2hlY2tib3hHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5cGF0aCkge1xuICBcdFx0XHR2YXIgYmluZGluZywgb2xkVmFsdWUsIG5ld1ZhbHVlO1xuXG4gIFx0XHRcdGJpbmRpbmcgPSBjaGVja2JveEdyb3Vwc1trZXlwYXRoLnN0cl07IC8vIG9uZSB0byByZXByZXNlbnQgdGhlIGVudGlyZSBncm91cFxuICBcdFx0XHRvbGRWYWx1ZSA9IGJpbmRpbmcuYXR0cmlidXRlLnZhbHVlO1xuICBcdFx0XHRuZXdWYWx1ZSA9IGJpbmRpbmcuZ2V0VmFsdWUoKTtcblxuICBcdFx0XHRpZiAoIWFycmF5Q29udGVudHNNYXRjaChvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gIFx0XHRcdFx0dmFsdWVzW2tleXBhdGguc3RyXSA9IG5ld1ZhbHVlO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZSA9IHtcbiAgXHRhZGQ6IHByb3RvdHlwZV9hZGQsXG4gIFx0YW5pbWF0ZTogcHJvdG90eXBlX2FuaW1hdGUsXG4gIFx0ZGV0YWNoOiBwcm90b3R5cGVfZGV0YWNoLFxuICBcdGZpbmQ6IHByb3RvdHlwZV9maW5kLFxuICBcdGZpbmRBbGw6IHByb3RvdHlwZV9maW5kQWxsLFxuICBcdGZpbmRBbGxDb21wb25lbnRzOiBwcm90b3R5cGVfZmluZEFsbENvbXBvbmVudHMsXG4gIFx0ZmluZENvbXBvbmVudDogcHJvdG90eXBlX2ZpbmRDb21wb25lbnQsXG4gIFx0ZmluZENvbnRhaW5lcjogZmluZENvbnRhaW5lcixcbiAgXHRmaW5kUGFyZW50OiBmaW5kUGFyZW50LFxuICBcdGZpcmU6IHByb3RvdHlwZV9maXJlLFxuICBcdGdldDogcHJvdG90eXBlX2dldCxcbiAgXHRpbnNlcnQ6IGluc2VydCxcbiAgXHRtZXJnZTogcHJvdG90eXBlX21lcmdlLFxuICBcdG9ic2VydmU6IG9ic2VydmUsXG4gIFx0b2JzZXJ2ZU9uY2U6IG9ic2VydmVPbmNlLFxuICBcdG9mZjogb2ZmLFxuICBcdG9uOiBvbixcbiAgXHRvbmNlOiBvbmNlLFxuICBcdHBvcDogcG9wLFxuICBcdHB1c2g6IHB1c2gsXG4gIFx0cmVuZGVyOiBwcm90b3R5cGVfcmVuZGVyLFxuICBcdHJlc2V0OiBwcm90b3R5cGVfcmVzZXQsXG4gIFx0cmVzZXRQYXJ0aWFsOiByZXNldFBhcnRpYWwsXG4gIFx0cmVzZXRUZW1wbGF0ZTogcmVzZXRUZW1wbGF0ZSxcbiAgXHRyZXZlcnNlOiByZXZlcnNlLFxuICBcdHNldDogUmFjdGl2ZV9wcm90b3R5cGVfc2V0LFxuICBcdHNoaWZ0OiBzaGlmdCxcbiAgXHRzb3J0OiBwcm90b3R5cGVfc29ydCxcbiAgXHRzcGxpY2U6IHNwbGljZSxcbiAgXHRzdWJ0cmFjdDogc3VidHJhY3QsXG4gIFx0dGVhcmRvd246IFJhY3RpdmVfcHJvdG90eXBlX3RlYXJkb3duLFxuICBcdHRvZ2dsZTogdG9nZ2xlLFxuICBcdHRvSFRNTDogdG9IVE1MLFxuICBcdHRvSHRtbDogdG9IVE1MLFxuICBcdHVucmVuZGVyOiBSYWN0aXZlX3Byb3RvdHlwZV91bnJlbmRlcixcbiAgXHR1bnNoaWZ0OiB1bnNoaWZ0LFxuICBcdHVwZGF0ZTogUmFjdGl2ZV9wcm90b3R5cGVfdXBkYXRlLFxuICBcdHVwZGF0ZU1vZGVsOiBwcm90b3R5cGVfdXBkYXRlTW9kZWxcbiAgfTtcblxuICB2YXIgd3JhcE1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QsIHN1cGVyTWV0aG9kLCBmb3JjZSkge1xuXG4gIFx0aWYgKGZvcmNlIHx8IG5lZWRzU3VwZXIobWV0aG9kLCBzdXBlck1ldGhvZCkpIHtcblxuICBcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICBcdFx0XHR2YXIgaGFzU3VwZXIgPSAoXCJfc3VwZXJcIiBpbiB0aGlzKSxcbiAgXHRcdFx0ICAgIF9zdXBlciA9IHRoaXMuX3N1cGVyLFxuICBcdFx0XHQgICAgcmVzdWx0O1xuXG4gIFx0XHRcdHRoaXMuX3N1cGVyID0gc3VwZXJNZXRob2Q7XG5cbiAgXHRcdFx0cmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgXHRcdFx0aWYgKGhhc1N1cGVyKSB7XG4gIFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdFx0fTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIG1ldGhvZDtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gbmVlZHNTdXBlcihtZXRob2QsIHN1cGVyTWV0aG9kKSB7XG4gIFx0cmV0dXJuIHR5cGVvZiBzdXBlck1ldGhvZCA9PT0gXCJmdW5jdGlvblwiICYmIC9fc3VwZXIvLnRlc3QobWV0aG9kKTtcbiAgfVxuXG4gIHZhciB1bndyYXBFeHRlbmRlZCA9IHVud3JhcDtcblxuICBmdW5jdGlvbiB1bndyYXAoQ2hpbGQpIHtcbiAgXHR2YXIgb3B0aW9ucyA9IHt9O1xuXG4gIFx0d2hpbGUgKENoaWxkKSB7XG4gIFx0XHRhZGRSZWdpc3RyaWVzKENoaWxkLCBvcHRpb25zKTtcbiAgXHRcdGFkZE90aGVyT3B0aW9ucyhDaGlsZCwgb3B0aW9ucyk7XG5cbiAgXHRcdGlmIChDaGlsZC5fUGFyZW50ICE9PSBfUmFjdGl2ZSkge1xuICBcdFx0XHRDaGlsZCA9IENoaWxkLl9QYXJlbnQ7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRDaGlsZCA9IGZhbHNlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBvcHRpb25zO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkUmVnaXN0cmllcyhDaGlsZCwgb3B0aW9ucykge1xuICBcdGNvbmZpZ19yZWdpc3RyaWVzLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgXHRcdGFkZFJlZ2lzdHJ5KHIudXNlRGVmYXVsdHMgPyBDaGlsZC5wcm90b3R5cGUgOiBDaGlsZCwgb3B0aW9ucywgci5uYW1lKTtcbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFJlZ2lzdHJ5KHRhcmdldCwgb3B0aW9ucywgbmFtZSkge1xuICBcdHZhciByZWdpc3RyeSxcbiAgXHQgICAga2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldFtuYW1lXSk7XG5cbiAgXHRpZiAoIWtleXMubGVuZ3RoKSB7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0aWYgKCEocmVnaXN0cnkgPSBvcHRpb25zW25hbWVdKSkge1xuICBcdFx0cmVnaXN0cnkgPSBvcHRpb25zW25hbWVdID0ge307XG4gIFx0fVxuXG4gIFx0a2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICBcdFx0cmV0dXJuICEoa2V5IGluIHJlZ2lzdHJ5KTtcbiAgXHR9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgXHRcdHJldHVybiByZWdpc3RyeVtrZXldID0gdGFyZ2V0W25hbWVdW2tleV07XG4gIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRPdGhlck9wdGlvbnMoQ2hpbGQsIG9wdGlvbnMpIHtcbiAgXHRPYmplY3Qua2V5cyhDaGlsZC5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBcdFx0aWYgKGtleSA9PT0gXCJjb21wdXRlZFwiKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dmFyIHZhbHVlID0gQ2hpbGQucHJvdG90eXBlW2tleV07XG5cbiAgXHRcdGlmICghKGtleSBpbiBvcHRpb25zKSkge1xuICBcdFx0XHRvcHRpb25zW2tleV0gPSB2YWx1ZS5fbWV0aG9kID8gdmFsdWUuX21ldGhvZCA6IHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBpcyBpdCBhIHdyYXBwZWQgZnVuY3Rpb24/XG4gIFx0XHRlbHNlIGlmICh0eXBlb2Ygb3B0aW9uc1trZXldID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgb3B0aW9uc1trZXldLl9tZXRob2QpIHtcblxuICBcdFx0XHR2YXIgcmVzdWx0ID0gdW5kZWZpbmVkLFxuICBcdFx0XHQgICAgbmVlZHNTdXBlciA9IHZhbHVlLl9tZXRob2Q7XG5cbiAgXHRcdFx0aWYgKG5lZWRzU3VwZXIpIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLl9tZXRob2Q7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyByZXdyYXAgYm91bmQgZGlyZWN0bHkgdG8gcGFyZW50IGZuXG4gIFx0XHRcdHJlc3VsdCA9IHdyYXBNZXRob2Qob3B0aW9uc1trZXldLl9tZXRob2QsIHZhbHVlKTtcblxuICBcdFx0XHRpZiAobmVlZHNTdXBlcikge1xuICBcdFx0XHRcdHJlc3VsdC5fbWV0aG9kID0gcmVzdWx0O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0b3B0aW9uc1trZXldID0gcmVzdWx0O1xuICBcdFx0fVxuICBcdH0pO1xuICB9XG5cbiAgdmFyIF9leHRlbmQgPSBfZXh0ZW5kX19leHRlbmQ7XG5cbiAgZnVuY3Rpb24gX2V4dGVuZF9fZXh0ZW5kKCkge1xuICBcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvcHRpb25zID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gIFx0XHRvcHRpb25zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICBcdH1cblxuICBcdGlmICghb3B0aW9ucy5sZW5ndGgpIHtcbiAgXHRcdHJldHVybiBleHRlbmRPbmUodGhpcyk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiBvcHRpb25zLnJlZHVjZShleHRlbmRPbmUsIHRoaXMpO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZE9uZShQYXJlbnQpIHtcbiAgXHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgXHR2YXIgQ2hpbGQsIHByb3RvO1xuXG4gIFx0Ly8gaWYgd2UncmUgZXh0ZW5kaW5nIHdpdGggYW5vdGhlciBSYWN0aXZlIGluc3RhbmNlLi4uXG4gIFx0Ly9cbiAgXHQvLyAgIHZhciBIdW1hbiA9IFJhY3RpdmUuZXh0ZW5kKC4uLiksIFNwaWRlciA9IFJhY3RpdmUuZXh0ZW5kKC4uLik7XG4gIFx0Ly8gICB2YXIgU3BpZGVybWFuID0gSHVtYW4uZXh0ZW5kKCBTcGlkZXIgKTtcbiAgXHQvL1xuICBcdC8vIC4uLmluaGVyaXQgcHJvdG90eXBlIG1ldGhvZHMgYW5kIGRlZmF1bHQgb3B0aW9ucyBhcyB3ZWxsXG4gIFx0aWYgKG9wdGlvbnMucHJvdG90eXBlIGluc3RhbmNlb2YgX1JhY3RpdmUpIHtcbiAgXHRcdG9wdGlvbnMgPSB1bndyYXBFeHRlbmRlZChvcHRpb25zKTtcbiAgXHR9XG5cbiAgXHRDaGlsZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIFx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2hpbGQpKSByZXR1cm4gbmV3IENoaWxkKG9wdGlvbnMpO1xuICBcdFx0aW5pdGlhbGlzZSh0aGlzLCBvcHRpb25zKTtcbiAgXHR9O1xuXG4gIFx0cHJvdG8gPSBjcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG4gIFx0cHJvdG8uY29uc3RydWN0b3IgPSBDaGlsZDtcblxuICBcdC8vIFN0YXRpYyBwcm9wZXJ0aWVzXG4gIFx0ZGVmaW5lUHJvcGVydGllcyhDaGlsZCwge1xuICBcdFx0Ly8gYWxpYXMgcHJvdG90eXBlIGFzIGRlZmF1bHRzXG4gIFx0XHRkZWZhdWx0czogeyB2YWx1ZTogcHJvdG8gfSxcblxuICBcdFx0Ly8gZXh0ZW5kYWJsZVxuICBcdFx0ZXh0ZW5kOiB7IHZhbHVlOiBfZXh0ZW5kX19leHRlbmQsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSxcblxuICBcdFx0Ly8gUGFyZW50IC0gZm9yIElFOCwgY2FuJ3QgdXNlIE9iamVjdC5nZXRQcm90b3R5cGVPZlxuICBcdFx0X1BhcmVudDogeyB2YWx1ZTogUGFyZW50IH1cbiAgXHR9KTtcblxuICBcdC8vIGV4dGVuZCBjb25maWd1cmF0aW9uXG4gIFx0Y29uZmlnX2NvbmZpZy5leHRlbmQoUGFyZW50LCBwcm90bywgb3B0aW9ucyk7XG5cbiAgXHRjdXN0b21fZGF0YS5leHRlbmQoUGFyZW50LCBwcm90bywgb3B0aW9ucyk7XG5cbiAgXHRpZiAob3B0aW9ucy5jb21wdXRlZCkge1xuICBcdFx0cHJvdG8uY29tcHV0ZWQgPSB1dGlsc19vYmplY3RfX2V4dGVuZChjcmVhdGUoUGFyZW50LnByb3RvdHlwZS5jb21wdXRlZCksIG9wdGlvbnMuY29tcHV0ZWQpO1xuICBcdH1cblxuICBcdENoaWxkLnByb3RvdHlwZSA9IHByb3RvO1xuXG4gIFx0cmV0dXJuIENoaWxkO1xuICB9XG5cbiAgdmFyIGdldE5vZGVJbmZvID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgXHR2YXIgaW5mbyA9IHt9LFxuICBcdCAgICBwcml2LFxuICBcdCAgICBpbmRpY2VzO1xuXG4gIFx0aWYgKCFub2RlIHx8ICEocHJpdiA9IG5vZGUuX3JhY3RpdmUpKSB7XG4gIFx0XHRyZXR1cm4gaW5mbztcbiAgXHR9XG5cbiAgXHRpbmZvLnJhY3RpdmUgPSBwcml2LnJvb3Q7XG4gIFx0aW5mby5rZXlwYXRoID0gcHJpdi5rZXlwYXRoLnN0cjtcbiAgXHRpbmZvLmluZGV4ID0ge307XG5cbiAgXHQvLyBmaW5kIGFsbCBpbmRleCByZWZlcmVuY2VzIGFuZCByZXNvbHZlIHRoZW1cbiAgXHRpZiAoaW5kaWNlcyA9IFJlc29sdmVyc19maW5kSW5kZXhSZWZzKHByaXYucHJveHkucGFyZW50RnJhZ21lbnQpKSB7XG4gIFx0XHRpbmZvLmluZGV4ID0gUmVzb2x2ZXJzX2ZpbmRJbmRleFJlZnMucmVzb2x2ZShpbmRpY2VzKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gaW5mbztcbiAgfTtcblxuICB2YXIgUmFjdGl2ZSwgcHJvcGVydGllcztcblxuICAvLyBNYWluIFJhY3RpdmUgcmVxdWlyZWQgb2JqZWN0XG4gIFJhY3RpdmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYWN0aXZlKSkgcmV0dXJuIG5ldyBSYWN0aXZlKG9wdGlvbnMpO1xuICBcdGluaXRpYWxpc2UodGhpcywgb3B0aW9ucyk7XG4gIH07XG5cbiAgLy8gUmFjdGl2ZSBwcm9wZXJ0aWVzXG4gIHByb3BlcnRpZXMgPSB7XG5cbiAgXHQvLyBkZWJ1ZyBmbGFnXG4gIFx0REVCVUc6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0cnVlIH0sXG4gIFx0REVCVUdfUFJPTUlTRVM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0cnVlIH0sXG5cbiAgXHQvLyBzdGF0aWMgbWV0aG9kczpcbiAgXHRleHRlbmQ6IHsgdmFsdWU6IF9leHRlbmQgfSxcbiAgXHRnZXROb2RlSW5mbzogeyB2YWx1ZTogZ2V0Tm9kZUluZm8gfSxcbiAgXHRwYXJzZTogeyB2YWx1ZTogX3BhcnNlIH0sXG5cbiAgXHQvLyBOYW1lc3BhY2VkIGNvbnN0cnVjdG9yc1xuICBcdFByb21pc2U6IHsgdmFsdWU6IHV0aWxzX1Byb21pc2UgfSxcblxuICBcdC8vIHN1cHBvcnRcbiAgXHRzdmc6IHsgdmFsdWU6IHN2ZyB9LFxuICBcdG1hZ2ljOiB7IHZhbHVlOiBlbnZpcm9ubWVudF9fbWFnaWMgfSxcblxuICBcdC8vIHZlcnNpb25cbiAgXHRWRVJTSU9OOiB7IHZhbHVlOiBcIjAuNy4yXCIgfSxcblxuICBcdC8vIFBsdWdpbnNcbiAgXHRhZGFwdG9yczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0Y29tcG9uZW50czogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0ZGVjb3JhdG9yczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0ZWFzaW5nOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogc3RhdGljX2Vhc2luZyB9LFxuICBcdGV2ZW50czogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0aW50ZXJwb2xhdG9yczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHN0YXRpY19pbnRlcnBvbGF0b3JzIH0sXG4gIFx0cGFydGlhbHM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuICBcdHRyYW5zaXRpb25zOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfVxuICB9O1xuXG4gIC8vIFJhY3RpdmUgcHJvcGVydGllc1xuICBkZWZpbmVQcm9wZXJ0aWVzKFJhY3RpdmUsIHByb3BlcnRpZXMpO1xuXG4gIFJhY3RpdmUucHJvdG90eXBlID0gdXRpbHNfb2JqZWN0X19leHRlbmQocHJvdG90eXBlLCBjb25maWdfZGVmYXVsdHMpO1xuXG4gIFJhY3RpdmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFjdGl2ZTtcblxuICAvLyBhbGlhcyBwcm90b3R5cGUgYXMgZGVmYXVsdHNcbiAgUmFjdGl2ZS5kZWZhdWx0cyA9IFJhY3RpdmUucHJvdG90eXBlO1xuXG4gIC8vIFJhY3RpdmUuanMgbWFrZXMgbGliZXJhbCB1c2Ugb2YgdGhpbmdzIGxpa2UgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuIEluXG4gIC8vIG9sZGVyIGJyb3dzZXJzLCB0aGVzZSBhcmUgbWFkZSBhdmFpbGFibGUgdmlhIGEgc2hpbSAtIGhlcmUsIHdlIGRvIGEgcXVpY2tcbiAgLy8gcHJlLWZsaWdodCBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCBlaXRoZXIgYSkgd2UncmUgbm90IGluIGEgc2hpdCBicm93c2VyLFxuICAvLyBvciBiKSB3ZSdyZSB1c2luZyBhIFJhY3RpdmUtbGVnYWN5LmpzIGJ1aWxkXG4gIHZhciBGVU5DVElPTiA9IFwiZnVuY3Rpb25cIjtcblxuICBpZiAodHlwZW9mIERhdGUubm93ICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS50cmltICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgT2JqZWN0LmtleXMgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLm1hcCAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5maWx0ZXIgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSBGVU5DVElPTikge1xuICBcdHRocm93IG5ldyBFcnJvcihcIkl0IGxvb2tzIGxpa2UgeW91J3JlIGF0dGVtcHRpbmcgdG8gdXNlIFJhY3RpdmUuanMgaW4gYW4gb2xkZXIgYnJvd3Nlci4gWW91J2xsIG5lZWQgdG8gdXNlIG9uZSBvZiB0aGUgJ2xlZ2FjeSBidWlsZHMnIGluIG9yZGVyIHRvIGNvbnRpbnVlIC0gc2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L2xlZ2FjeS1idWlsZHMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIpO1xuICB9XG5cbiAgdmFyIF9SYWN0aXZlID0gUmFjdGl2ZTtcblxuICByZXR1cm4gX1JhY3RpdmU7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhY3RpdmUuanMubWFwXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYWN0aXZlL3JhY3RpdmUuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9');

},function(module,exports,__webpack_require__){eval("module.exports = function(module) {\r\n	if(!module.webpackPolyfill) {\r\n		module.deprecate = function() {};\r\n		module.paths = [];\r\n		// module.parent = undefined by default\r\n		module.children = [];\r\n		module.webpackPolyfill = 1;\r\n	}\r\n	return module;\r\n}\r\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2MzYzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9")}]);